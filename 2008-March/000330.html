<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Transform-svn] r388 - dev/dev-2-4/src/com/flagstone/transform/util
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/transform-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r388%20-%20dev/dev-2-4/src/com/flagstone/transform/util&In-Reply-To=%3C200803261751.m2QHpifo011453%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000322.html">
   <LINK REL="Next"  HREF="000323.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Transform-svn] r388 - dev/dev-2-4/src/com/flagstone/transform/util</H1>
    <B>smackay at mail.berlios.de</B> 
    <A HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r388%20-%20dev/dev-2-4/src/com/flagstone/transform/util&In-Reply-To=%3C200803261751.m2QHpifo011453%40sheep.berlios.de%3E"
       TITLE="[Transform-svn] r388 - dev/dev-2-4/src/com/flagstone/transform/util">smackay at mail.berlios.de
       </A><BR>
    <I>Wed Mar 26 18:51:44 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000322.html">[Transform-svn] r387 - in dev/dev-2-4/src/com/flagstone/transform:	. util
</A></li>
        <LI>Next message: <A HREF="000323.html">[Transform-svn] r389 - dev/dev-2-4/src/com/flagstone/transform/util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#330">[ date ]</a>
              <a href="thread.html#330">[ thread ]</a>
              <a href="subject.html#330">[ subject ]</a>
              <a href="author.html#330">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: smackay
Date: 2008-03-26 18:51:14 +0100 (Wed, 26 Mar 2008)
New Revision: 388

Added:
   dev/dev-2-4/src/com/flagstone/transform/util/BMPDecoder.java
   dev/dev-2-4/src/com/flagstone/transform/util/Canvas.java
   dev/dev-2-4/src/com/flagstone/transform/util/CharacterSet.java
   dev/dev-2-4/src/com/flagstone/transform/util/CharacterTable.java
   dev/dev-2-4/src/com/flagstone/transform/util/Font.java
   dev/dev-2-4/src/com/flagstone/transform/util/Glyph.java
   dev/dev-2-4/src/com/flagstone/transform/util/Image.java
   dev/dev-2-4/src/com/flagstone/transform/util/ImageDecoder.java
   dev/dev-2-4/src/com/flagstone/transform/util/ImageInfo.java
   dev/dev-2-4/src/com/flagstone/transform/util/JPGDecoder.java
   dev/dev-2-4/src/com/flagstone/transform/util/MP3Decoder.java
   dev/dev-2-4/src/com/flagstone/transform/util/PNGDecoder.java
   dev/dev-2-4/src/com/flagstone/transform/util/Sound.java
   dev/dev-2-4/src/com/flagstone/transform/util/SoundDecoder.java
   dev/dev-2-4/src/com/flagstone/transform/util/Text.java
   dev/dev-2-4/src/com/flagstone/transform/util/WAVDecoder.java
Removed:
   dev/dev-2-4/src/com/flagstone/transform/util/FSCharacterTable.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java
Log:
Refactored classes to suppotr plugin decoders and stateless generation of movie objects.

Added: dev/dev-2-4/src/com/flagstone/transform/util/BMPDecoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/BMPDecoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/BMPDecoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,605 @@
+/*
+ *  FSImageConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.zip.*;
+
+import com.flagstone.transform.FSCoder;
+
+public class BMPDecoder
+{
+    private static final int[] bmpSignature = { 66, 77 };
+
+    private final int BI_RGB = 0;
+    private final int BI_RLE8 = 1;
+    private final int BI_RLE4 = 2;
+    private final int BI_BITFIELDS = 3;
+    
+    private int format;
+    private int width;
+    private int height;
+
+    private byte[][] colourTable;
+    private byte[][] indexedImage;
+    private byte[][][] colorImage;
+   
+    private int bitDepth;
+    private int colourChannels;
+    private int compressionMethod;
+    private int redMask;
+    private int greenMask;
+    private int blueMask;
+    
+    /**
+     * Constructs an FSImageConstructor object with no image.
+     */
+    public BMPDecoder()
+    {
+    }
+    
+    /**
+     * Constructs and FSImageConstructor object and loads the image from the specified file. The FSImageConstructor
+     * class support Windows bitmap (BMP), Portable Network Graphics (PNG) or JPEG encoded images.
+     *
+     * @param filename the name of the file containing the image.
+     *
+     * @throws FileNotFoundException is the file cannot be found.
+     *
+     * @throws IOException if an error occurs while reading the file.
+     *
+     * @throws DataFormatException if the file contains an unsupported image format or if an error occurs 
+     * while decoding the image in the file.
+     */
+    public BMPDecoder(String filename) throws IOException, DataFormatException
+    {
+        setImage(dataFromFile(filename));
+    }   
+    /**
+     * Constructs and FSImageConstructor object and loads the encoded image data. The FSImageConstructor
+     * class support Windows bitmap (BMP), Portable Network Graphics (PNG) or JPEG encoded images.
+     *
+     * @param bytes an array of bytes containing the encoded image.
+     *
+     * @throws DataFormatException if the data contains an unsupported image format or if an error occurs 
+     * while decoding the image.
+     */
+    public BMPDecoder(byte[] bytes) throws DataFormatException
+    {
+        setImage(bytes);
+    }
+    
+    /**
+     * Initialises the FSImageConstructor object with the image in the specified file. This method can be used
+     * to generate the image definition objects for a Flash movie using the same FSImageConstructor object.
+     *
+     * @param filename the name of the file containing the image.
+     *
+     * @throws FileNotFoundException is the file cannot be found.
+     *
+     * @throws IOException if an error occurs while reading the file.
+     *
+     * @throws DataFormatException if the file contains an unsupported image format or if an error occurs 
+     * while decoding the image in the file.
+     */
+    public void setImageFromFile(String filename) throws IOException, DataFormatException
+    {
+        setImage(dataFromFile(filename));
+    }
+    
+    /**
+     * Initialises the FSImageConstructor object with the image data.
+     *
+     * @param bytes an array of bytes containing the encoded image.
+     *
+     * @throws DataFormatException if the data contains an unsupported image format or if an error occurs 
+     * while decoding the image.
+     */
+    public void setImage(byte[] bytes) throws DataFormatException
+    {
+        int signature = ((bytes[0] &amp; 0xFF) &lt;&lt; 8) | (bytes[1] &amp; 0xFF);
+
+        format = 0;
+        width = 0;
+        height = 0;
+    
+        bitDepth = 0;
+        colourChannels = 0;
+        compressionMethod = 0;
+        redMask = 0;
+        greenMask = 0;
+        blueMask = 0;
+
+        colourTable = null;
+        indexedImage = null;
+        colorImage = null;
+        
+        switch (signature)
+        {
+            case 0x424d: decodeBMP(bytes); break;
+            default: 
+                throw new DataFormatException(&quot;Unsupported image format&quot;);  
+        }
+    }
+    
+    /**
+     * Returns a constant identifying the format for the way the pixels are encoded.
+     *
+     * @return the image format.
+     */
+    public int getFormat()
+    {
+        return format;
+    }
+
+    /**
+     * Returns the width of the image in pixels.
+     * 
+     * @return the image width in pixels.
+     */
+    public int getWidth()
+    {
+        return width;
+    }
+    /**
+     * Returns the height of the image in pixels.
+     * 
+     * @return the image height in pixels.
+     */
+    public int getHeight()
+    {
+        return height;
+    }   
+    /**
+     * Returns a copy of the colour table used in an indexed image. Each entry in the 
+     * colour table contains 4 bytes with one byte for the alpha channel and each
+     * of the three colour channels, red, green and blue. The alpha channel occupied the 
+     * most significant byte (3) followed by red, green and blue (the least significant byte).
+     * 
+     * For images in IDX8 format the alpha channel defaults to 255 (completely opaque).
+     * 
+     * If the image format is JPEG or one of the true colour formats (RGB5, RGB8, RGBA)
+     * then the colour table returned is null.
+     *
+     * @return a two-dimensional array of bytes containing the colours used in an indexed image.
+     */
+    public byte[][] getColorTable()
+    {
+        byte[][] table = null;
+        
+        if (colourTable != null)
+        {
+            table = new byte[colourTable.length][4];
+        
+            for (int i=0; i&lt;colourTable.length; i++)
+            {
+                for (int j=0; j&lt;4; j++)
+                    table[i][j] = colourTable[i][j];            
+            }
+        }
+        return table;
+    }
+    /**
+     * Returns a copy of the image data decoded from an indexed image. A two
+     * dimensional array is returned, byte[height][width] with each entry containing an 
+     * index into the colour table.
+     * 
+     * If the image format is JPEG or one of the true colour formats (RGB5, RGB8, RGBA)
+     * then the indexed image returned is null.
+     *
+     * @return a two-dimensional array of bytes (height x width) with each entry containing 
+     * an index into the colour table.
+     */
+    
+    public byte[][] getIndexedImage()
+    {
+        byte[][] image = null;
+        
+        if (indexedImage != null)
+        {
+            image = new byte[height][width];
+        
+            for (int i=0; i&lt;height; i++)
+            {
+                for (int j=0; j&lt;width; j++)
+                    image[i][j] = indexedImage[i][j];            
+            }
+        }
+        return image;
+    }
+    /**
+     * Returns a copy of the image data decoded from a true colour file. A three
+     * dimensional array is returned with four bytes for each pixel in the image,
+     * byte[height][width][4] - one byte for the red [0], green [1], blue [2] and
+     * alpha [3] channels.
+     * 
+     * If the image format is JPEG or an indexed image (IDX8, IDXA) then the image
+     * data returned is null.
+     *
+     * @return an array of bytes containing the colour channels for each pixel in
+     * the image.
+     */
+    public byte[][][] getColorImage()
+    {
+        byte[][][] image = null;
+        
+        if (colorImage != null)
+        {
+            image = new byte[height][width][4];
+
+            for (int h=0; h&lt;height; h++)
+            {
+                for (int w=0; w&lt;width; w++)
+                {
+                    image[h][w][0] = colorImage[h][w][0];    
+                    image[h][w][1] = colorImage[h][w][1];    
+                    image[h][w][2] = colorImage[h][w][2];    
+                    image[h][w][3] = colorImage[h][w][3];    
+                }
+            }
+        }
+        return image;
+    }
+    	
+       
+    private void decodeBMP(byte[] bytes) throws DataFormatException
+    {
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
+        
+        for (int i=0; i&lt;2; i++)
+        {
+            if (coder.readByte() != bmpSignature[i])
+                throw new DataFormatException(&quot;Not a valid BMP file&quot;);
+        }
+
+        coder.readWord(4, false); // fileSize
+        coder.readWord(4, false); // reserved
+        int offset = coder.readWord(4, false);
+        int headerSize = coder.readWord(4, false);
+        
+        int bitsPerPixel = 0;
+        int coloursUsed = 0;
+
+        switch (headerSize)
+        {
+            case 12:
+                width = coder.readWord(2, false);
+                height = coder.readWord(2, false);
+                coder.readWord(2, false); // bitPlanes
+                bitsPerPixel = coder.readWord(2, false);
+                break;
+            case 40:
+                width = coder.readWord(4, false);
+                height = coder.readWord(4, false);
+                coder.readWord(2, false); // bitPlanes
+                bitsPerPixel = coder.readWord(2, false);
+                compressionMethod = coder.readWord(4, false);
+                coder.readWord(4, false); //imageSize
+                coder.readWord(4, false); // horizontalResolution
+                coder.readWord(4, false); // verticalResolution
+                coloursUsed = coder.readWord(4, false);
+                coder.readWord(4, false); // importantColours
+                break;
+            default:
+                break;
+        }
+        
+        if (compressionMethod == BI_BITFIELDS)
+        {
+            redMask = coder.readWord(4, false);
+            greenMask = coder.readWord(4, false);
+            blueMask = coder.readWord(4, false);
+        }
+        
+        switch (bitsPerPixel)
+        {
+            case 1: format = Image.IDX8; bitDepth = 1; colourChannels = 1; break;
+            case 2: format = Image.IDX8; bitDepth = 2; colourChannels = 1; break;
+            case 4: format = Image.IDX8; bitDepth = 4; colourChannels = 1; break;
+            case 8: format = Image.IDX8; bitDepth = 8; colourChannels = 1; break;
+            case 16: format = Image.RGB5; bitDepth = 5; colourChannels = 3; break;
+            case 24: format = Image.RGB8; bitDepth = 8; colourChannels = 3; break;
+            case 32: format = Image.RGBA; bitDepth = 8; colourChannels = 4; break;
+        }
+        
+        if (format == Image.IDX8) 
+        {
+            coloursUsed = 1 &lt;&lt; bitsPerPixel;
+            colourTable = new byte[coloursUsed][4];
+            indexedImage = new byte[height][width];
+
+            if (headerSize == 12)
+            {
+                for (int i=0; i &lt; coloursUsed; i++) 
+                {
+                    colourTable[i][3] = (byte)0xFF;
+                    colourTable[i][2] = (byte)coder.readByte();
+                    colourTable[i][1] = (byte)coder.readByte();
+                    colourTable[i][0] = (byte)coder.readByte();
+                }
+            }
+            else
+            {
+                for (int i=0; i &lt; coloursUsed; i++)
+                {
+                    colourTable[i][0] = (byte)coder.readByte();
+                    colourTable[i][1] = (byte)coder.readByte();
+                    colourTable[i][2] = (byte)coder.readByte();
+                    colourTable[i][3] = (byte)(coder.readByte() | 0xFF);
+                }
+            }
+                
+            coder.setPointer(offset&lt;&lt;3);
+
+            switch (compressionMethod)
+            {
+                case BI_RGB:  decodeIDX8(coder); break;
+                case BI_RLE8: decodeRLE8(coder); break;
+                case BI_RLE4: decodeRLE4(coder); break;
+            }
+        }
+        else
+        {
+            colorImage = new byte[height][width][4];
+
+            coder.setPointer(offset&lt;&lt;3);
+
+            switch (format)
+            {
+                case Image.RGB5: decodeRGB5(coder); break;
+                case Image.RGB8: decodeRGB8(coder); break;
+                case Image.RGBA: decodeRGBA(coder); break;
+            }
+        }
+    }
+
+    private void decodeIDX8(FSCoder coder)
+    {
+        int h = 0;
+        int w = 0;
+        int bitsRead = 0;
+        
+        for (h=height-1; h&gt;0; h--)
+        {
+            for (w=0, bitsRead=0; w&lt;width; w++)
+            {
+                indexedImage[h][w] = (byte)coder.readBits(bitDepth, false);
+                bitsRead += bitDepth;
+            }
+            if (bitsRead % 32 &gt; 0)
+                coder.adjustPointer(32 - (bitsRead % 32));
+        }
+    }
+
+    private void decodeRLE4(FSCoder coder)
+    {
+        int row = height-1;
+        int col = 0;
+        
+        boolean containsMorePixels = true;
+
+        while (containsMorePixels) 
+        {       
+            int count = coder.readByte();
+        
+            if (count == 0)
+            {
+                int code = coder.readByte();
+                
+                switch (code)
+                {
+                    case 0: 
+                        col = 0; 
+                        row--; 
+                        break;
+                    case 1: 
+                        containsMorePixels = false; 
+                        break;
+                    case 2: 
+                        col += coder.readWord(2, false);
+                        row -= coder.readWord(2, false);
+                    default:
+                        for (int i=0; i&lt;code; i+=2)
+                        {
+                            indexedImage[row][col++] = (byte) coder.readBits(4, false);
+                            indexedImage[row][col++] = (byte) coder.readBits(4, false);
+                        }
+                        
+                        if ((code &amp; 2) == 2) coder.readByte();
+                        break;
+                }
+            }
+            else
+            {
+                byte indexA = (byte)coder.readBits(4, false);
+                byte indexB = (byte)coder.readBits(4, false);
+                
+                for (int i=0; i&lt;count &amp;&amp; col &lt; width; i++) 
+                    indexedImage[row][col++] = (i % 2 &gt; 0) ? indexB : indexA;
+            }
+        }
+    }
+    
+    private void decodeRLE8(FSCoder coder)
+    {
+        int row = height-1;
+        int col = 0;
+        
+        boolean containsMorePixels = true;
+
+        while (containsMorePixels) 
+        {       
+            int count = coder.readByte();
+        
+            if (count == 0)
+            {
+                int code = coder.readByte();
+                
+                switch (code)
+                {
+                    case 0: 
+                        col = 0; 
+                        row--; 
+                        break;
+                    case 1: 
+                        containsMorePixels = false; 
+                        break;
+                    case 2: 
+                        col += coder.readWord(2, false);
+                        row -= coder.readWord(2, false);
+                    default:
+                        for (int i=0; i&lt;code; i++)
+                            indexedImage[row][col++] = (byte) coder.readByte();
+                        
+                        if ((code &amp; 1) == 1) coder.readByte();
+                        break;
+                }
+            }
+            else
+            {
+                byte index = (byte)coder.readByte();
+                
+                for (int i=0; i&lt;count; i++) 
+                    indexedImage[row][col++] = index;
+            }
+        }
+    }
+    
+    private void decodeRGB5(FSCoder coder)
+    {
+        int h = 0;
+        int w = 0;
+        int bitsRead = 0;
+        
+        if (compressionMethod == BI_RGB)
+        {
+            for (h=height-1; h&gt;0; h--)
+            {
+                for (w=0, bitsRead=0; w&lt;width; w++)
+                {                
+                    int colour = coder.readWord(2, false) &amp; 0xFFFF;
+                    
+                    colorImage[h][w][0] = (byte)((colour &amp; 0x7C00) &gt;&gt; 7);
+                    colorImage[h][w][1] = (byte)((colour &amp; 0x03E0) &gt;&gt; 2);
+                    colorImage[h][w][2] = (byte)((colour &amp; 0x001F) &lt;&lt; 3);
+                    colorImage[h][w][3] = (byte)0xFF;
+
+                    bitsRead += 16;
+                }
+                if (bitsRead % 32 &gt; 0)
+                    coder.adjustPointer(32 - (bitsRead % 32));
+            }
+        }
+        else
+        {
+            for (h=height-1; h&gt;0; h--)
+            {
+                for (w=0, bitsRead=0; w&lt;width; w++)
+                {
+                    int colour = coder.readWord(2, false) &amp; 0xFFFF;
+                    
+                    if (redMask == 0x7C00 &amp;&amp; greenMask == 0x03E0 &amp;&amp; blueMask == 0x001F)
+                    {
+                        colorImage[h][w][0] = (byte)((colour &amp; 0x7C00) &gt;&gt; 7);
+                        colorImage[h][w][1] = (byte)((colour &amp; 0x03E0) &gt;&gt; 2);
+                        colorImage[h][w][2] = (byte)((colour &amp; 0x001F) &lt;&lt; 3);
+                        colorImage[h][w][3] = (byte)0xFF;
+                    }
+                    else if (redMask == 0xF800 &amp;&amp; greenMask == 0x07E0 &amp;&amp; blueMask == 0x001F)
+                    {
+                        colorImage[h][w][0] = (byte)((colour &amp; 0xF800) &gt;&gt; 8);
+                        colorImage[h][w][1] = (byte)((colour &amp; 0x07E0) &gt;&gt; 3);
+                        colorImage[h][w][2] = (byte)((colour &amp; 0x001F) &lt;&lt; 3);
+                        colorImage[h][w][3] = (byte)0xFF;
+                    }
+                    bitsRead += 16;
+                }
+                if (bitsRead % 32 &gt; 0)
+                    coder.adjustPointer(32 - (bitsRead % 32));
+            }
+        }
+        
+    }
+
+    private void decodeRGB8(FSCoder coder)
+    {
+        int h = 0;
+        int w = 0;
+        int bitsRead = 0;
+        
+        for (h=height-1; h&gt;0; h--)
+        {
+            for (w=0, bitsRead=0; w&lt;width; w++)
+            {
+                colorImage[h][w][0] = (byte)coder.readBits(bitDepth, false);
+                colorImage[h][w][1] = (byte)coder.readBits(bitDepth, false);
+                colorImage[h][w][2] = (byte)coder.readBits(bitDepth, false);
+                colorImage[h][w][3] = (byte)0xFF;
+                
+                bitsRead += 24;
+            }
+            if (bitsRead % 32 &gt; 0)
+                coder.adjustPointer(32 - (bitsRead % 32));
+        }
+    }
+
+    private void decodeRGBA(FSCoder coder)
+    {
+        int h = 0;
+        int w = 0;
+        
+        for (h=height-1; h&gt;0; h--)
+        {
+            for (w=0; w&lt;width; w++)
+            {
+                colorImage[h][w][2] = (byte)coder.readByte();
+                colorImage[h][w][1] = (byte)coder.readByte();
+                colorImage[h][w][0] = (byte)coder.readByte();
+                colorImage[h][w][3] = (byte)coder.readByte();
+                colorImage[h][w][3] = (byte)0xFF;
+            }
+        }
+    }
+   
+    private byte[] dataFromFile(String filename) throws FileNotFoundException, IOException
+    {
+        File aFile = new File(filename);
+        FileInputStream imageContents = null;
+        
+        byte[] bytes = new byte[(int)aFile.length()];
+        
+        imageContents = new FileInputStream(aFile);            
+        imageContents.read(bytes);
+        imageContents.close();
+
+        return bytes;
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/Canvas.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/Canvas.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/Canvas.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,1129 @@
+/*
+ *  FSShapeConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import com.flagstone.transform.*;
+import java.util.*;
+
+
+/**
+ * The FSShapeConstructor class is used to create shape definitions. Arbitrary paths can be 
+ * created using a series of move, line or curve segments. Drawing operations using both
+ * absolute coordinates and coordinates relative to the current point (updated after every 
+ * operation) are supported. 
+ * 
+ * For curves both cubic and quadratic curves are supported. Flash only supports quadratic 
+ * curves so cubic curves are approximated by a series of line segments using (converting cubic 
+ * to quadratic curves is mathematically difficult). The smoothness of cubic curves is 
+ * controlled by the flatness attribute which can be used to limit the number of line segments
+ * that are drawn.
+ * 
+ * While drawing the start of the first segment to be drawn is recorded so the path can 
+ * easily be closed by drawing a line from the current point to the start of the first 
+ * segment drawn. To account for the rounded mitering supported by Flash the path is closed 
+ * by re-adding the first segment drawn so the line ends overlap.
+ * 
+ * As a path is drawn the maximum and minimum x and y coordinates are recorded so that the 
+ * bounding rectangle that completely encloses the shape can be defined. This is used when
+ * creating shape definitions using the FSDefineShape, FSDefineShape2 or FSDefineShape3 classes.
+ * 
+ * The FSShapeConstructor class also supports a number of method to create closed paths that
+ * represent different geometric shapes. Basic rectangles, ellipses and circles are supported.
+ * More complex shapes can be drawn using the polygon() method which uses pairs of points to 
+ * specified the vertices of an arbitrary shapes.
+ * 
+ * When drawing paths whether coordinates are specified in twips or pixels is controlled by 
+ * the attributes COORDINATES_ARE_PIXELS. This is independent of the flag of the same name 
+ * supported in the Transform SWF frameworks. When true coordinates are specified in pixels,
+ * while coordinates are specified in twips when false. 1 pixel == 20 twips. Internally all
+ * coordinates are converted to twips to perform the actual drawing.
+ * 
+ * The styles used to draw the path and fill the area enclosed is specified using the ordinal
+ * position of the style object in the arrays of styles maintained by the shape definition
+ * object (FSDefineShape, SDefineShape2 or FSDefineShape3) used to construct the final shape. 
+ *  
+ * &lt;b&gt;Examples&lt;/b&gt;
+ *
+ * The following code samples illustrate how to use the FSShapeConstructor class create shapes.
+ *
+ * 1. Defining a rectangle using move and line drawing operations.\n
+ * 
+ *&lt;pre&gt;
+ *    FSShapeConstructor path = new FSShapeConstructor();
+ * 
+ *    path.COORDINATES_ARE_PIXELS = true;
+ * 
+ *    int width = 200;
+ *    int height = 100;
+ *
+ *    // Setting the line style before any drawing commands is important
+ *    // so the thickness of the line can be taken into account when
+ *    // calculating the bounding rectangle which must completely enclose
+ *    // the shape so it will be drawn correctly.
+ *
+ *    path.add(new FSLineStyle(1, FSColorTable.black()));
+ *    path.add(new FSSolidFill(FSColorTable.red()));
+ *
+ *    newPath();                   // start a new path
+ *    selectStyle(1, 1);              // select the first line and fill style objects
+ *    move(-width/2, -height/2);   // Move to the top left corner
+ *    rline(width, 0);             // Draw the sides of the rectangle
+ *    rline(0, height);
+ *    rline(-width, 0);
+ *    rline(0, -height);
+ *    closePath();                 // close the path to correctly seal the line ends.
+ * 
+ *    // Now define the shape.
+ * 
+ *    FSDefineShape3 rect = path.defineShape(movie.newIdentifier());
+ * 
+ *&lt;/pre&gt;
+ *
+ * 2. Defining a rectangle using the path creation method.\n
+ * 
+ *&lt;pre&gt;
+ *    FSShapeConstructor path = new FSShapeConstructor();
+ * 
+ *    path.COORDINATES_ARE_PIXELS = true;
+ *
+ *    // Define the origin for the shape so the bottom left corner of the 
+ *    // rectangle will appear at the coordinates the shape is place at 
+ *    // using the FSPlaceObject or FSPlaceObject2 class.
+ * 
+ *    int xorigin = 100;
+ *    int yorigin = -50;
+ * 
+ *    int width = 200;
+ *    int height = 100;
+ *    int cornerRadius = 10
+ *
+ *    path.add(new FSLineStyle(1, FSColorTable.black()));
+ *    path.add(new FSSolidFill(FSColorTable.red()));
+ *
+ *    // Create a rectangle with rounded corners.
+ * 
+ *    path.rect(xorign, yorigin, width, height, cornerRadius);
+ * 
+ *    // Now define the shape.
+ * 
+ *    FSDefineShape3 rect = path.defineShape(movie.newIdentifier());
+ *
+ *&lt;/pre&gt;
+ *
+ */
+public class Canvas
+{
+    private double flattenLimit = 0.25;
+   /** 
+     * The COORDINATES_ARE_PIXELS flag controls whether the coordinates passed to methods when creating 
+     * a path of predefined shape are expressed in pixels (true) or twips (false).
+     *
+     * Flash coordinates are specified in twips (1 twip equals 1/1440th of an inch or 1/20th of a point). 
+     * Allowing coordinates to be specified in pixels simplifies the drawing process avoiding the conversion 
+     * to twips by multiplying each value by 20.
+     *
+     * IMPORTANT: The value of this flag is independent of the COORDINATES_ARE_PIXELS flag specified in 
+     * the Transform class of the Transform SWF framework.
+     */
+    public boolean COORDINATES_ARE_PIXELS = false;
+    
+    private double[] Px = new double[4];
+    private double[] Py = new double[4];
+    
+    private boolean pathInProgress = false;
+    
+    private int initialX = 0;
+    private int initialY = 0;
+    
+    private int currentX = 0;
+    private int currentY = 0;
+    
+    private int controlX = 0;
+    private int controlY = 0;
+
+    private int minX = 0;
+    private int minY = 0;
+    private int maxX = 0;
+    private int maxY = 0;
+    
+    private int lineWidth = 0;
+    
+    ArrayList objects = new ArrayList();
+    ArrayList lineStyles = new ArrayList();
+    ArrayList fillStyles = new ArrayList();
+    
+    /**
+     * Creates an FSShapeConstructor object with no path defined.
+     */
+    public Canvas()
+    {
+    }
+    
+    /** Sets the line style at the index in the array of line styles.
+
+        @param index the position in the array of line styles.
+        @param aLineStyle and FSLineStyle object.
+        @throws ArrayIndexOutOfBounds if the index &lt; 0 or index &gt; array size.
+        */
+    public void set(int index, FSLineStyle aLineStyle)
+    {
+        lineStyles.set(index, aLineStyle);
+    }
+
+    /** Add a FSLineStyle object to the array of line styles.
+
+        @param aLineStyle and FSLineStyle object.
+        */
+    public void add(FSLineStyle aLineStyle)
+    {
+        lineStyles.add(aLineStyle);
+    }
+
+    /** Sets the fill style at the index in the array of fill styles.
+
+        @param index the position in the array of fill styles.
+        @param aFillStyle an FSFillStyle object.
+        @throws ArrayIndexOutOfBounds if the index &lt; 0 or index &gt; array size.
+        */
+    public void set(int index, FSFillStyle aFillStyle)
+    {
+        fillStyles.set(index, aFillStyle);
+    }
+
+    /** Add the fill style object to the array of fill styles.
+
+        @param aFillStyle and FSFillStyle object.
+        */
+    public void add(FSFillStyle aFillStyle)
+    {
+        fillStyles.add(aFillStyle);
+    }
+    
+    /** Gets the array line styles.
+
+        @return the line styles used in the shape.
+        */
+    public ArrayList getLineStyles() 
+    { 
+        return lineStyles; 
+    }
+
+    /** Sets the line styles.
+
+        @param anArray set the line styles for the shape.
+        */
+    public void setLineStyles(ArrayList anArray)
+    {
+        lineStyles = anArray;
+    }
+
+    /** Gets the array fill styles.
+
+        @return the fill styles used in the shape.
+        */
+    public ArrayList getFillStyles()
+    {
+        return fillStyles;
+    }
+
+    /** Sets the fill styles.
+
+        @param anArray set the fill styles for the shape.
+        */
+    public void setFillStyles(ArrayList anArray)
+    {
+        fillStyles = anArray;
+    }
+
+    /**
+     * Selects the style used to draw the outline of the shape from the array of 
+     * line styles.
+     * 
+     * @param index the position of the style used to draw the shape.
+     */
+    public void selectLineStyle(int index)
+    {
+        lineWidth = ((FSLineStyle)lineStyles.get(index)).getWidth();
+
+        objects.add(new FSShapeStyle(index+1, Transform.VALUE_NOT_SET, Transform.VALUE_NOT_SET));
+    }
+    
+    /**
+     * Selects the style used to fill the contents of the shape from the array of 
+     * fill styles.
+     * 
+     * @param index the position of the style used to fill the shape.
+     */
+    public void selectFillStyle(int index)
+    {
+        objects.add(new FSShapeStyle(Transform.VALUE_NOT_SET, index+1, Transform.VALUE_NOT_SET));
+    }
+    
+    /**
+     * Selects the style used to fill overlapping areas of the shape from the 
+     * array of fill styles.
+     * 
+     * @param index the position of the style used to fill overlapping areas.
+     */
+    public void selectAltStyle(int index)
+    {
+        objects.add(new FSShapeStyle(Transform.VALUE_NOT_SET, Transform.VALUE_NOT_SET, index+1));
+    }
+    
+    /**
+     * Selects the styles used to draw the outline and fill the contents of the 
+     * shape from the array of line and fill styles.
+     * 
+     * @param lineIndex the position of the style used to draw the outline of the shape.
+     * @param fillIndex the position of the style used to fill the shape.
+     */
+    public void selectStyle(int lineIndex, int fillIndex)
+    {
+        lineWidth = ((FSLineStyle)lineStyles.get(lineIndex)).getWidth();
+        
+        objects.add(new FSShapeStyle(lineIndex+1, fillIndex+1, Transform.VALUE_NOT_SET));
+    }
+    
+    /**
+     * Selects the styles used to draw the outline and fill the contents of the 
+     * shape, including overlapping area, from the array of line and fill styles.
+     * 
+     * @param lineIndex the position of the style used to draw the outline of the shape.
+     * @param fillIndex the position of the style used to fill the shape.
+     * @param altIndex the position of the style used to fill overlapping areas of the shape.
+     */
+    public void selectStyle(int lineIndex, int fillIndex, int altIndex)
+    {
+        lineWidth = ((FSLineStyle)lineStyles.get(lineIndex)).getWidth();
+ 
+        objects.add(new FSShapeStyle(lineIndex+1, fillIndex+1, altIndex+1));
+    }
+    
+    /**
+     * Generates the bounding box that encloses the current path.
+     *
+     * @return an FSBounds object representing the bounding box that encloses the path.
+     */
+    public FSBounds bounds()
+    {
+        return new FSBounds(minX, minY, maxX, maxY);
+    }
+
+    /**
+     * Generates an FSShape object containing the objects used to draw the current path.
+     *
+     * @return an FSShape object contain the FSLine, FSCurve and FSShapeStyle objects used to 
+     * construct the current path.
+     */
+    public FSShape shape()
+    {
+        return new FSShape((ArrayList)objects.clone());
+    }
+
+    /**
+     * Generates a shape containing the current path and styles.
+     *
+     * The shape is constructed with copies of the style arrays and the shape representing the 
+     * path drawn. This allows the number of styles to be changed without affecting previously
+     * created shapes.
+     *
+     * @param identifier an unique identifier for the shape.
+     */
+     public FSDefineShape2 defineShape(int identifier)
+     {
+        return new FSDefineShape2(identifier, bounds(), (ArrayList)fillStyles.clone(), (ArrayList)lineStyles.clone(), new FSShape((ArrayList)objects.clone()));
+     }
+     
+    /**
+     * Generates a transparent shape containing the current path and styles.
+     *
+     * The shape is constructed with copies of the style arrays and the shape representing the 
+     * path drawn. This allows the number of styles to be changed without affecting previously
+     * created shapes.
+     *
+     * @param identifier an unique identifier for the shape.
+     */
+     public FSDefineShape3 defineTransparentShape(int identifier)
+     {
+        return new FSDefineShape3(identifier, bounds(), (ArrayList)fillStyles.clone(), (ArrayList)lineStyles.clone(), new FSShape((ArrayList)objects.clone()));
+     }
+     
+    /**
+     * Creates a new path, discarding any path elements drawn.
+     */
+    public void newPath()
+    {
+        pathInProgress = false;
+        
+        setInitial(0, 0);
+        setCurrent(0, 0);
+        setControl(0, 0);
+        setBounds(0, 0, 0, 0);
+        
+        objects.clear();
+
+        lineWidth = 0;
+    }
+    
+    /**
+     * Closes the current path by drawing a line from the current point to the starting point of the 
+     * path. 
+     */
+    public void closePath()
+    {
+        int dx = initialX - currentX;
+        int dy = initialY - currentY;
+        
+        if (dx != 0 || dy != 0)
+            objects.add(new FSLine(dx, dy));
+            
+        setCurrent(initialX, initialY);
+        pathInProgress = false;
+    }
+    
+    /**
+     * move to the point (x,y).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x the x-coordinate of the point to move to.
+     * @param y the y-coordinate of the point to move to.
+     */
+    public void move(int x, int y)
+    {
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+        
+        objects.add(new FSShapeStyle(x, y));
+
+        setControl((currentX+x)/2, (currentY+y)/2);
+        setCurrent(x, y);
+        setInitial(x, y);
+    }
+    
+    void moveForFont(int x, int y)
+    {
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+        
+        objects.add(new FSShapeStyle(1, -1, 1, x, y));
+
+        setControl((currentX+x)/2, (currentY+y)/2);
+        setCurrent(x, y);
+        setInitial(x, y);
+    }
+  
+    /**
+     * move relative to the current point.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x the distance along the x-axis.
+     * @param y the distance along the y-axis.
+     */
+    public void rmove(int x, int y)
+    {
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+        
+        objects.add(new FSShapeStyle(x+currentX, y+currentY)); 
+
+        setControl(currentX+x/2, currentY+y/2);
+        setCurrent(currentX+x, currentY+y);
+   }
+    
+    /**
+     * draw a line from the current point to the point (x,y).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x the x-coordinate of the end of the line.
+     * @param y the y-coordinate of the end of the line.
+     */
+    public void line(int x, int y)
+    {
+        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX;
+        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY;
+
+        objects.add(new FSLine(x, y));
+        
+        if (pathInProgress == false)
+        {
+            setInitial(currentX, currentY);
+            pathInProgress = true;
+        }
+        setControl(currentX+x/2, currentY+y/2);
+        setCurrent(currentX+x, currentY+y);
+    }
+    
+    /**
+     * draw a line relative to the current point.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x the distance along the x-axis to the end of the line.
+     * @param y the distance along the y-axis to the end of the line.
+     */
+    public void rline(int x, int y)
+    {
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+
+        objects.add(new FSLine(x, y));
+
+        if (pathInProgress == false)
+        {
+            setInitial(currentX, currentY);
+            pathInProgress = true;
+        }
+        setControl(currentX+x/2, currentY+y/2);
+        setCurrent(currentX+x, currentY+y);
+    }
+    
+    /**
+     * draw a quadratic bezier curve from the current point to the point (x,y) with the control 
+     * point (x1, y1).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x1 the x-coordinate of the control point.
+     * @param y1 the y-coordinate of the control point.
+     * @param x the x-coordinate of the end of the curve.
+     * @param y the y-coordinate of the end of the curve.
+     */
+    public void curve(int x1, int y1, int x, int y)
+    {
+        x1 = (COORDINATES_ARE_PIXELS ? x1 * 20 : x1) - currentX;
+        y1 = (COORDINATES_ARE_PIXELS ? y1 * 20 : y1) - currentY;
+        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX - x1;
+        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY - y1;
+
+        objects.add(new FSCurve(x1, y1, x, y));
+
+        if (pathInProgress == false)
+        {
+            setInitial(currentX, currentY);
+            pathInProgress = true;
+        }
+        setControl(currentX+x1, currentY+y1);
+        setCurrent(currentX+x1+x, currentY+y1+y);
+    }
+    
+    /**
+     * draw a quadratic bezier curve relative to the current point to the point.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x1 the distance along the x-axis from the current point to the control point.
+     * @param y1 the distance along the y-axis from the current point to the control point.
+     * @param x the distance along the x-axis from the current point to the end of the curve.
+     * @param y the distance along the y-axis from the current point to the end of the curve.
+     */
+    public void rcurve(int x1, int y1, int x, int y)
+    {
+        x1 = COORDINATES_ARE_PIXELS ? x1 * 20 : x1;
+        y1 = COORDINATES_ARE_PIXELS ? y1 * 20 : y1;
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+
+        objects.add(new FSCurve(x1, y1, x, y));
+
+        if (pathInProgress == false)
+        {
+            setInitial(currentX, currentY);
+            pathInProgress = true;
+        }
+ 
+        setControl(currentX+x1, currentY+y1);
+        setCurrent(currentX+x1+x, currentY+y1+y);
+    }
+    
+    /**
+     * draw a cubic bezier curve from the current point to the point (x,y) with the off-curve control 
+     * points (x1, y1) and (x2, y2).
+     * 
+     * IMPORTANT: Converting cubic bezier curves to the quadratic bezier curves supported by Flash is 
+     * mathematically difficult. The cubic curve is approximated by a series of straight line segments. 
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x1 the x-coordinate of the first control point.
+     * @param y1 the y-coordinate of the first control point.
+     * @param x2 the x-coordinate of the second control point.
+     * @param y2 the y-coordinate of the second control point.
+     * @param x the x-coordinate of the end of the curve.
+     * @param y the y-coordinate of the end of the curve.
+     */
+    public void curve(int x1, int y1, int x2, int y2, int x, int y)
+    {
+        Px[0] = currentX;
+        Py[0] = currentY;
+        Px[1] = COORDINATES_ARE_PIXELS ? x1 * 20 : x1;
+        Py[1] = COORDINATES_ARE_PIXELS ? y1 * 20 : y1;
+        Px[2] = COORDINATES_ARE_PIXELS ? x2 * 20 : x2;
+        Py[2] = COORDINATES_ARE_PIXELS ? y2 * 20 : y2;
+        Px[3] = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        Py[3] = COORDINATES_ARE_PIXELS ? y * 20 : y;
+        
+        flatten();
+    }
+    
+    /**
+     * draw a cubic bezier curve relative to the current point.
+     * 
+     * IMPORTANT: Converting cubic bezier curves to the quadratic bezier curves supported by Flash is 
+     * mathematically difficult. The cubic curve is approximated by a series of straight line segments. 
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x1 the distance along the x-axis from the current point to the first control point.
+     * @param y1 the distance along the y-axis from the current point to the first control point.
+     * @param x2 the distance along the x-axis from the current point to the second control point.
+     * @param y2 the distance along the y-axis from the current point to the second control point.
+     * @param x the distance along the x-axis from the current point to the end of the curve.
+     * @param y the distance along the y-axis from the current point to the end of the curve.
+     */
+    public void rcurve(int x1, int y1, int x2, int y2, int x, int y)
+    {
+        Px[0] = currentX;
+        Py[0] = currentY;
+        Px[1] = currentX + (COORDINATES_ARE_PIXELS ? x1 * 20 : x1);
+        Py[1] = currentY + (COORDINATES_ARE_PIXELS ? y1 * 20 : y1);
+        Px[2] = currentX + (COORDINATES_ARE_PIXELS ? x2 * 20 : x2);
+        Py[2] = currentY + (COORDINATES_ARE_PIXELS ? y2 * 20 : y2);
+        Px[3] = currentX + (COORDINATES_ARE_PIXELS ? x * 20 : x);
+        Py[3] = currentY + (COORDINATES_ARE_PIXELS ? y * 20 : y);
+        
+        flatten();
+    }
+    
+    /**
+     * draw a quadratic bezier curve from the current point to the point (x,y) using the control point
+     * for the previously drawn curve.
+     * 
+     * If no curve has been drawn previously then a control point midway along the previous line or 
+     * move is used.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x the x-coordinate of the end of the curve.
+     * @param y the y-coordinate of the end of the curve.
+     */
+    public void reflect(int x, int y)
+    {
+        int x1 = currentX - controlX;
+        int y1 = currentY - controlY;
+        
+        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX;
+        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY;
+
+        objects.add(new FSCurve(x1, y1, x, y));
+
+        if (pathInProgress == false)
+        {
+            setInitial(currentX, currentY);
+            pathInProgress = true;
+        }
+ 
+        setControl(x1+currentX, y1+currentY);
+        setCurrent(x+currentX, y+currentY);
+    }
+
+    /**
+     * draw a quadratic bezier curve relative to the current point to the point using the control point
+     * for the previously drawn curve.
+     * 
+     * If no curve has been drawn previously then a control point midway along the previous line or 
+     * move is used.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x the distance along the x-axis from the current point to the end of the curve.
+     * @param y the distance along the y-axis from the current point to the end of the curve.
+     */
+    public void rreflect(int x, int y)
+    {
+        int x1 = currentX - controlX;
+        int y1 = currentY - controlY;
+
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+
+        objects.add(new FSCurve(x1, y1, x, y));
+
+        if (pathInProgress == false)
+        {
+            setInitial(currentX, currentY);
+            pathInProgress = true;
+        }
+ 
+        setControl(x1+currentX, y1+currentY);
+        setCurrent(x+currentX, y+currentY);
+    }
+
+    /**
+     * draw a cubic bezier curve from the current point to the point (x,y). The first control point
+     * is the one defined for the previously drawn curve. The second control point is the 
+     * coordinates (x2, y2).
+     * 
+     * If no curve has been drawn previously then a control point midway along the previous line or 
+     * move is used.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x2 the x-coordinate of the control point.
+     * @param y2 the y-coordinate of the control point.
+     * @param x the x-coordinate of the end of the curve.
+     * @param y the y-coordinate of the end of the curve.
+     */
+    public void reflect(int x2, int y2, int x, int y)
+    {
+        int x1 = currentX - controlX;
+        int y1 = currentY - controlY;
+
+        x2 = (COORDINATES_ARE_PIXELS ? x2 * 20 : x2) - currentX;
+        y2 = (COORDINATES_ARE_PIXELS ? y2 * 20 : y2) - currentY;
+
+        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX;
+        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY;
+
+        rcurve(x1, y1, x2, y2, x, y);
+    }
+
+    /**
+     * draw a cubic bezier curve relative to the current point. The first control point
+     * is the one defined for the previously drawn curve. The second control point is the 
+     * relative point (x2, y2).
+     * 
+     * If no curve has been drawn previously then a control point midway along the previous line or 
+     * move is used.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param x2 the distance along the x-axis from the current point to the second control point.
+     * @param y2 the distance along the y-axis from the current point to the second control point.
+     * @param x the distance along the x-axis from the current point to the end of the curve.
+     * @param y the distance along the y-axis from the current point to the end of the curve.
+     */
+    public void rreflect(int x2, int y2, int x, int y)
+    {
+        int x1 = currentX - controlX;
+        int y1 = currentY - controlY;
+
+        x2 = COORDINATES_ARE_PIXELS ? x2 * 20 : x2;
+        y2 = COORDINATES_ARE_PIXELS ? y2 * 20 : y2;
+
+        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
+        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
+
+        rcurve(x1, y1, x2, y2, x, y);
+    }
+
+    /**
+     * Creates a closed path in the shape of a rectangle with the specified width and height.
+     * The centre of the rectangle is located at the point (x,y).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * The origin of the shape can be used to control the relative placement of the rectangle 
+     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
+     * FSPlaceObject2 class.
+     * 
+     * @param x the x-coordinate of the centre of the rectangle.
+     * @param y the y-coordinate of the centre of the rectangle.
+     * @param width the width of the rectangle.
+     * @param height the height of the rectangle.
+     */
+    public void rect(int x, int y, int width, int height)
+    {
+        newPath();
+        selectStyle(0, 0);
+        move(x-width/2, y-height/2);
+        rline(width, 0);
+        rline(0, height);
+        rline(-width, 0);
+        rline(0, -height);
+        closePath();
+    }
+
+    /**
+     * Creates a closed path in the shape of a rectangle with the specified width and height.
+     * The centre of the rectangle is located at the point (0,0).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param width the width of the rectangle.
+     * @param height the height of the rectangle.
+     */
+    public void rect(int width, int height)
+    {
+        rect(0, 0, width, height);
+    }
+
+    /**
+     * Creates a closed path in the shape of a rectangle with rounded corners. The shape is drawn
+     * with specified width and height and the radius argument specified the radius of the quarter 
+     * circle used to draw the corners.
+     * 
+     * The centre of the rectangle is located at the point (x,y).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * The origin of the shape can be used to control the relative placement of the rectangle 
+     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
+     * FSPlaceObject2 class.
+     * 
+     * @param x the x-coordinate of the centre of the rectangle.
+     * @param y the y-coordinate of the centre of the rectangle.
+     * @param width the width of the rectangle.
+     * @param height the height of the rectangle.
+     * @param radius the radius of the quarter circle used to draw the corners.
+     */
+    public void rect(int x, int y, int width, int height, int radius)
+    {
+        int shortestSide = (height &lt; width) ? height : width;
+    
+        if (radius &gt; shortestSide/2)
+            radius = shortestSide/2;
+    
+        newPath();
+        selectStyle(0, 0);
+        move(x, y-height/2);
+        rline(width/2-radius, 0);
+        rcurve(radius, 0, 0, radius);
+        rline(0, height - 2*radius);
+        rcurve(0, radius, -radius, 0);
+        rline(-(width-2*radius), 0);
+        rcurve(-radius, 0, 0, -radius);
+        rline(0, -(height-2*radius));
+        rcurve(0, -radius, radius, 0);
+        closePath();
+    }
+
+    /**
+     * Creates a closed path in the shape of a rectangle with rounded corners. The shape is drawn
+     * with specified width and height and the radius argument specified the radius of the quarter 
+     * circle used to draw the corners. The centre of the rectangle is located at the point (0,0).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param width the width of the rectangle.
+     * @param height the height of the rectangle.
+     * @param radius the radius of the quarter circle used to draw the corners.
+     */
+    public void rect(int width, int height, int radius)
+    {
+        rect(0, 0, width, height, radius);
+    }
+
+    /**
+     * Creates a closed path in the shape of an ellipse. The arguments rx and ry specify the radius 
+     * of the ellipse in the x and y directions respectively.
+     * 
+     * The centre of the ellipse is located at the point (x,y).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * The origin of the shape can be used to control the relative placement of the ellipse 
+     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
+     * FSPlaceObject2 class.
+     * 
+     * @param x the x-coordinate of the centre of the ellipse.
+     * @param y the y-coordinate of the centre of the ellipse.
+     * @param rx the radius of the ellipse in the x direction.
+     * @param ry the radius of the ellipse in the y direction.
+     */
+    public void ellipse(int x, int y, int rx, int ry)
+    {
+        boolean wasInPixels = false;
+
+        if (COORDINATES_ARE_PIXELS)
+        {
+            COORDINATES_ARE_PIXELS = false;
+            wasInPixels = true;
+            
+            x *= 20;
+            y *= 20;
+            rx *= 20;
+            ry *= 20;
+        }
+
+        int startX = (int) (0.707 * rx) + x;
+        int startY = (int) (0.707 * ry) + y;
+
+        int ax = (int) (0.293 * rx);
+        int ay = (int) (0.293 * ry);
+        int cx = (int) (0.414 * rx);
+        int cy = (int) (0.414 * ry);
+            
+        newPath();
+        selectStyle(0, 0);
+        move(startX, startY);
+        rcurve(-ax, ay, -cx, 0);
+        rcurve(-cx, 0, -ax, -ay);
+        rcurve(-ax, -ay, 0, -cy);
+        rcurve(0, -cy,  ax, -ay);
+        rcurve(ax, -ay, cx, 0);
+        rcurve(cx, 0,  ax, ay);
+        rcurve(ax, ay, 0, cy);
+        rcurve(0, cy, -ax, ay);
+        closePath();
+        
+        if (wasInPixels)
+        {
+            COORDINATES_ARE_PIXELS = true;
+        }
+    }
+
+    /**
+     * Creates a closed path in the shape of an ellipse. The arguments rx and ry specify the radius 
+     * of the ellipse in the x and y directions respectively.
+     * 
+     * The centre of the ellipse is located at the point (0,0).
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param rx the radius of the ellipse in the x direction.
+     * @param ry the radius of the ellipse in the y direction.
+     */
+    public void ellipse(int rx, int ry)
+    {
+        ellipse(0, 0, rx, ry);
+    }
+
+    /**
+     * Creates a closed path in the shape of a circle. The centre of the circle is located at 
+     * the point (x,y) with radius r.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * The origin of the shape can be used to control the relative placement of the circle 
+     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
+     * FSPlaceObject2 class.
+     * 
+     * @param x the x-coordinate of the centre of the circle.
+     * @param y the y-coordinate of the centre of the circle.
+     * @param r the radius of the circle.
+     */
+    public void circle(int x, int y, int r)
+    {
+        ellipse(x, y, r, r);
+    }
+
+    /**
+     * Creates a closed path in the shape of a circle. The centre of the circle is located at 
+     * the point (0,0) with radius r.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param r the radius of the circle.
+     */
+    public void circle(int r)
+    {
+        ellipse(0, 0, r, r);
+    }
+
+    /**
+     * Create a closed shape with vertices defines by pairs of coordinates from the array argument.
+     * The first pair of points in the array specifies a move. Line segments a drawn relative to 
+     * the current point which is updated after each segment is drawn.
+     * 
+     * If the number of points is an odd number then the last point will be ignored.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param points and array of coordinate pairs. The first pair of points defines the coordinates
+     * of a move operation, successive pairs define the coordinates for relative lines.
+     */
+    public void rpolygon(int[] points)
+    {
+        int i;
+        int length = points.length;
+        
+        if (length % 2 == 1)
+            length -= 1;
+        
+        rmove(points[0], points[1]);
+
+        for (i=2; i&lt;length; i+=2)
+            rline(points[i], points[i+1]);
+            
+        closePath();
+    }
+    /**
+     * Create a closed shape with vertices defines by pairs of coordinates from the array argument.
+     * The first pair of points in the array specifies a move. Line segments a drawn using 
+     * abolute coordinates. The current point which is updated after each segment is drawn.
+     * 
+     * If the number of points is an odd number then the last point will be ignored.
+     * 
+     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
+     * otherwise the coordinates are specified in twips.
+     * 
+     * @param points and array of coordinate pairs. The first pair of points defines the coordinates
+     * of a move operation, successive pairs define the coordinates of the lines.
+     */
+    public void polygon(int[] points)
+    {
+        int i;
+        int length = points.length;
+        
+        if (length % 2 == 1)
+            length -= 1;
+        
+        move(points[0], points[1]);
+
+        for (i=2; i&lt;length; i+=2)
+            line(points[i], points[i+1]);
+            
+        closePath();
+    }
+
+    private void setInitial(int x, int y)
+    {
+        initialX = x;
+        initialY = y;
+    }
+    
+    private void setCurrent(int x, int y)
+    {
+        currentX = x;
+        currentY = y;
+        
+        if ((x - lineWidth/2) &lt; minX) minX = x - lineWidth/2;
+        if ((y - lineWidth/2) &lt; minY) minY = y - lineWidth/2;
+        if ((x + lineWidth/2) &gt; maxX) maxX = x + lineWidth/2;
+        if ((y + lineWidth/2) &gt; maxY) maxY = y + lineWidth/2;
+    }
+    
+    private void setControl(int x, int y)
+    {
+        controlX = x;
+        controlY = y;
+
+        if ((x - lineWidth/2) &lt; minX) minX = x - lineWidth/2;
+        if ((y - lineWidth/2) &lt; minY) minY = y - lineWidth/2;
+        if ((x + lineWidth/2) &gt; maxX) maxX = x + lineWidth/2;
+        if ((y + lineWidth/2) &gt; maxY) maxY = y + lineWidth/2;
+    }
+    
+    private void setBounds(int xl, int yl, int xu, int yu)
+    {
+        minX = xl;
+        minY = yl;
+        maxX = xu;
+        maxY = yu;
+    }
+    
+    private void flatten()
+    {
+        double[] Qx = new double[] {0.0, 0.0, 0.0, 0.0};
+        double[] Qy = new double[] {0.0, 0.0, 0.0, 0.0};
+
+        double u;
+        double Ax, Ay, Bx, By;
+
+        for (;;) 
+        {
+            Ax = 2.0 * Px[0] + Px[3] - 3.0 * Px[1];  Ax *= Ax;
+            Bx = 2.0 * Px[3] + Px[0] - 3.0 * Px[2];  Bx *= Bx;
+        
+            if (Ax &lt; Bx) Ax = Bx;
+
+            Ay = 2.0 * Py[0] + Py[3] - 3.0 * Py[1];  Ay *= Ay;
+            By = 2.0 * Py[3] + Py[0] - 3.0 * Py[2];  By*= By;
+        
+            if (Ay &lt; By) Ay = By;
+
+            if ((Ax + Ay) &lt; flattenLimit) 
+            {
+                objects.add(new FSLine((int)(Px[3])-currentX, (int)(Py[3])-currentY));
+                setControl((int)(Px[1]), (int)(Py[1]));
+                setControl((int)(Px[2]), (int)(Py[2]));
+                setCurrent((int)(Px[3]), (int)(Py[3]));
+                break;
+            }
+            else 
+            {
+                Qx[3] = Px[3];
+                u = (Px[1] + Px[2]) / 2;
+                Px[1] = (Px[0] + Px[1]) / 2;
+                Qx[2] = (Px[2] + Px[3]) / 2;
+                Px[2] = (Px[1] + u) / 2;
+                Qx[1] = (u + Qx[2]) / 2;
+                Px[3] = Qx[0] = (Px[2] + Qx[1]) / 2;
+
+                Qy[3] = Py[3];
+                u = (Py[1] + Py[2]) / 2;
+                Py[1] = (Py[0] + Py[1]) / 2;
+                Qy[2] = (Py[2] + Py[3]) / 2;
+                Py[2] = (Py[1] + u) / 2;
+                Qy[1] = (u + Qy[2]) / 2;
+                Py[3] = Qy[0] = (Py[2] + Qy[1]) / 2;
+
+                flatten();
+                  
+                Px[0] = Qx[0];
+                Py[0] = Qy[0];
+                Px[1] = Qx[1];
+                Py[1] = Qy[1];
+                Px[2] = Qx[2];
+                Py[2] = Qy[2];
+                Px[3] = Qx[3];
+                Py[3] = Qy[3];
+                  
+                continue;
+            }
+        }
+    }
+}
+

Added: dev/dev-2-4/src/com/flagstone/transform/util/CharacterSet.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/CharacterSet.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/CharacterSet.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,203 @@
+/*
+ *  CharacterSet.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.flagstone.transform.util;
+
+import java.util.HashMap;
+
+public class CharacterSet 
+{
+	private static HashMap&lt;String,CharacterSet&gt; sets;
+	
+	static {
+		sets = new HashMap&lt;String,CharacterSet&gt;();
+	}
+	
+	public static void addSet(String language, CharacterSet set)
+	{
+		if (language == null) {
+			throw new IllegalArgumentException(&quot;Language for character set cannot be null&quot;);
+		}
+		if (set == null) {
+			throw new IllegalArgumentException(&quot;Character set cannot be null&quot;);
+		}
+		sets.put(language, new CharacterSet(set));
+	}
+	
+	public CharacterSet getCharacterSet(String language)
+	{
+		CharacterSet set = null;
+		
+		if (sets.containsKey(language)) {
+			set = new CharacterSet(sets.get(language));
+		}
+		return set;
+	}
+	
+	private int[] table;
+	
+	public CharacterSet()
+	{
+	}
+	
+	public CharacterSet(char c)
+	{
+		table = new int[c];
+	}
+	
+	public CharacterSet(CharacterSet set)
+	{
+		table = new int[set.table.length];
+		
+		for (int i=0; i&lt;set.table.length; i++) {
+			table[i] = set.table[i];
+		}
+			
+	}
+	
+	public char first() 
+	{
+		char c = 0;
+		
+		for (int i=0; i&lt;table.length; i++) {
+			if (table[i] != 0) {
+				c = (char)i;
+			}
+		}
+		return c;
+	}
+
+	public char last() 
+	{
+		char c = 0;
+		
+		for (int i=table.length; i&gt;=0;) {
+			if (table[--i] != 0) {
+				c = (char)i;
+			}
+		}
+		return c;
+	}
+
+	public boolean contains(char c) 
+	{
+		boolean has = false;
+		
+		if (c &lt; table.length) {
+			has = table[c] != 0;
+		}
+		return has;
+	}
+	
+	public void add(char c) 
+	{
+		if (c &gt; table.length)
+		{
+			int[] newTable = new int[c];
+			
+			for (int i=0; i&lt;table.length; i++) {
+				newTable[i] = table[i];
+			}
+			
+			int index = table.length;
+
+			while (index &lt; c) {
+				newTable[index++] = 0;
+			}
+			
+			table = newTable;
+		}
+		table[c] = 1;
+	}
+	
+	public void add(char from, char to)
+	{
+		if (to &lt; from) {
+			throw new IllegalArgumentException(&quot;End of character range is before the start.&quot;);
+		}
+	}
+	
+	public void add(char[] array)
+	{
+		if (array == null) {
+			throw new IllegalArgumentException(&quot;Array of characters cannot be null.&quot;);
+		}
+		
+		for (char c : array) {
+			add(c);
+		}
+	}
+	
+	public void add(String s) 
+	{
+		for (int i=0; i&lt;s.length(); i++) {
+			add(s.charAt(i));
+		}
+	}
+	
+	public void remove(char c) 
+	{
+		if (c &lt; table.length) {
+			table[c] = 0;
+		}
+	}
+	
+	public void remove(char from, char to)
+	{
+		if (to &lt; from) {
+			throw new IllegalArgumentException(&quot;End of character range is before the start.&quot;);
+		}
+		
+		for (int i=from; i&lt;=to; i++) {
+			table[i] = 0;
+		}
+	}
+	
+	public char[] getCharacters()
+	{
+		int count = 0;
+		
+		for (int i=0; i&lt;table.length; i++) {
+			if (table[i] != 0) {
+				count++;
+			}
+		}
+		
+		char[] array = new char[count];
+		int index = 0;
+		
+		for (int i=0; i&lt;table.length; i++) {
+			if (table[i] != 0) {
+				array[index++] = (char)i;
+			}
+		}
+
+		return array;
+	}
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/CharacterTable.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/CharacterTable.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/CharacterTable.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,664 @@
+/*
+ *  FSCharacterTable.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.flagstone.transform.util;
+
+import java.util.Locale;
+
+/**
+ * The FSCharacterTable class provides predefined arrays of characters that can
+ * be used with the FSTextConstructor's willDisplay() method to predefine the 
+ * characters that will be displayed using a given font.
+ * 
+ * Character sets are simply list of characters to use. The names used to 
+ * identify collections of characters use official character set names, such
+ * as iso_8859_1. However they do NOT indicate how the characters are encoded
+ * as such (all strings are encoded using UTF-8) they are simply a way of 
+ * naming a group of characters in a recognized (and standard) way.
+ * 
+ * Other sets that use characters appropriate for a specific country and 
+ * language also use ISO designations for a specific locale such as en_US
+ * or pt_BR.
+ *
+ */
+public class CharacterTable 
+{
+    /*
+     * List of character sets supported. 
+     */
+    
+    /**
+     * Code identifying a set containing the single character for the euro
+     * currency symbol. It is included as a separate set as manly formal 
+     * coded character sets do not include it. A separate set makes it easier
+     * to match different sets of characters together.
+     * 
+     * The (Unicode) character code for this symbol is 0x20AC so it will
+     * typically be the last character set passed to the FSTextConstructor's
+     * willDisplay() method.
+     */
+    public static final int euro = 0;
+    /**
+     * Code identifying formal the characters defined in ISO 646.
+     * 
+     * Alias: ASCII
+     */
+    public static final int iso_646 = 1;
+    /**
+     * Code identifying formal the characters defined in ISO-8859-1.
+     * 
+     * Alias: Latin-1
+     */
+    public static final int iso_8859_1 = 2;
+    
+    /*
+     * The ISO 646 character set is used as a base for other characters sets.
+     * Other character sets are created by including these characters in the 
+     * array returned by the characterSetWithCode() method. This saves space
+     * and more importantly makes it easier to correct errors.
+     */
+    private final static char[] iso_646_chars = {
+        '\u0020', // space
+        '\u0021', // exclamation mark
+        '\u0022', // quotation mark
+        '\u0023', // number sign
+        '\u0024', // dollar sign
+        '\u0025', // percent sign
+        '\u0026', // ampersand
+        '\'',     // apostrophe
+        '\u0028', // left parenthesis
+        '\u0029', // right parenthesis
+        '\u002A', // asterisk
+        '\u002B', // plus sign
+        '\u002C', // comma
+        '\u002D', // hyphen or minus
+        '\u002E', // full stop
+        '\u002F', // forward slash
+        '\u0030', // digit zero
+        '\u0031', // digit one
+        '\u0032', // digit two
+        '\u0033', // digit three
+        '\u0034', // digit four
+        '\u0035', // digit five
+        '\u0036', // digit six
+        '\u0037', // digit seven
+        '\u0038', // digit eight
+        '\u0039', // digit nine
+        '\u003A', // colon
+        '\u003B', // semicolon
+        '\u003C', // less than sign
+        '\u003D', // equals sign
+        '\u003E', // greater than sign
+        '\u003F', // question mark
+        '\u0040', // commercial at
+        '\u0041', // upper case A
+        '\u0042', // upper case B
+        '\u0043', // upper case C
+        '\u0044', // upper case D
+        '\u0045', // upper case E
+        '\u0046', // upper case F
+        '\u0047', // upper case G
+        '\u0048', // upper case H
+        '\u0049', // upper case I
+        '\u004A', // upper case J
+        '\u004B', // upper case K
+        '\u004C', // upper case L
+        '\u004D', // upper case M
+        '\u004E', // upper case N
+        '\u004F', // upper case O
+        '\u0050', // upper case P
+        '\u0051', // upper case Q
+        '\u0052', // upper case R
+        '\u0053', // upper case S
+        '\u0054', // upper case T
+        '\u0055', // upper case U
+        '\u0056', // upper case V
+        '\u0057', // upper case W
+        '\u0058', // upper case X
+        '\u0059', // upper case Y
+        '\u005A', // upper case Z
+        '\u005B', // left square bracket
+        '\\',     // backslash
+        '\u005D', // right square bracket
+        '\u005E', // circumflex
+        '\u005F', // underscore
+        '\u0060', // grave
+        '\u0061', // lower case A
+        '\u0062', // lower case B
+        '\u0063', // lower case C
+        '\u0064', // lower case D
+        '\u0065', // lower case E
+        '\u0066', // lower case F
+        '\u0067', // lower case G
+        '\u0068', // lower case H
+        '\u0069', // lower case I
+        '\u006A', // lower case J
+        '\u006B', // lower case K
+        '\u006C', // lower case L
+        '\u006D', // lower case M
+        '\u006E', // lower case N
+        '\u006F', // lower case O
+        '\u0070', // lower case P
+        '\u0071', // lower case Q
+        '\u0072', // lower case R
+        '\u0073', // lower case S
+        '\u0074', // lower case T
+        '\u0075', // lower case U
+        '\u0076', // lower case V
+        '\u0077', // lower case W
+        '\u0078', // lower case X
+        '\u0079', // lower case Y
+        '\u007A', // lower case Z
+        '\u007B', // left curly bracket
+        '\u007C', // vertical line
+        '\u007D', // right curly bracket
+        '\u007E', // tilde
+    };
+    
+    private static final char[] iso_8859_1_chars = new char[] {
+        '\u00A0', // non-breaking space
+        '\u00A1', // inverted exclamation mark
+        '\u00A2', // cent sign
+        '\u00A3', // pound sign
+        '\u00A4', // currency sign
+        '\u00A5', // yen sign
+        '\u00A6', // broken BAR
+        '\u00A7', // section sign
+        '\u00A8', // diaresis
+        '\u00A9', // copyright sign
+        '\u00AA', // feminine ordinal indicator
+        '\u00AB', // left pointing double angle quotation mark
+        '\u00AC', // not sign
+        '\u00AD', // soft hyphen
+        '\u00AE', // registered trademark sign
+        '\u00AF', // macron
+        '\u00B0', // degree sign
+        '\u00B1', // plus-minus sign
+        '\u00B2', // superscript two
+        '\u00B3', // superscript three
+        '\u00B4', // acute accent
+        '\u00B5', // micro sign
+        '\u00B6', // pilcrow sign
+        '\u00B7', // middle dot
+        '\u00B8', // cedilla
+        '\u00B9', // superscript ONE
+        '\u00BA', // masculine ordinal indicator
+        '\u00BB', // right pointing double angle quotation mark
+        '\u00BC', // vulgar fraction one quarter
+        '\u00BD', // vulgar fraction one half
+        '\u00BE', // vulgar fraction three quarters
+        '\u00BF', // inverted question mark
+        '\u00C0', // upper case letter A with grave
+        '\u00C1', // upper case letter A with acute
+        '\u00C2', // upper case letter A with circumflex
+        '\u00C3', // upper case letter A with tilde
+        '\u00C4', // upper case letter A with diaresis
+        '\u00C5', // upper case letter A with ring above
+        '\u00C6', // upper case letter AE
+        '\u00C7', // upper case letter C with cedilla
+        '\u00C8', // upper case letter E with grave
+        '\u00C9', // upper case letter E with acute
+        '\u00CA', // upper case letter E with circumflex
+        '\u00CB', // upper case letter E with diaresis
+        '\u00CC', // upper case letter I with grave
+        '\u00CD', // upper case letter I with acute
+        '\u00CE', // upper case letter I with circumflex
+        '\u00CF', // upper case letter I with diaresis
+        '\u00D0', // upper case letter Eth (Icelandic)
+        '\u00D1', // upper case letter N with tilde
+        '\u00D2', // upper case letter O with grave
+        '\u00D3', // upper case letter O with acute
+        '\u00D4', // upper case letter O with circumflex
+        '\u00D5', // upper case letter O with tilde
+        '\u00D6', // upper case letter O with diaresis
+        '\u00D7', // multiplication sign
+        '\u00D8', // upper case letter O with stroke
+        '\u00D9', // upper case letter U with grave
+        '\u00DA', // upper case letter U with acute
+        '\u00DB', // upper case letter U with circumflex
+        '\u00DC', // upper case letter U with diaresis
+        '\u00DD', // upper case letter Y with acute
+        '\u00DE', // upper case letter Thorn (Icelandic)
+        '\u00DF', // lower case letter Sharp S (German)
+        '\u00E0', // lower case letter A with grave
+        '\u00E1', // lower case letter A with acute
+        '\u00E2', // lower case letter A with circumflex
+        '\u00E3', // lower case letter A with tilde
+        '\u00E4', // lower case letter A with diaresis
+        '\u00E5', // lower case letter A with ring above
+        '\u00E6', // lower case letter AE
+        '\u00E7', // lower case letter C with cedilla
+        '\u00E8', // lower case letter E with grave
+        '\u00E9', // lower case letter E with acute
+        '\u00EA', // lower case letter E with circumflex
+        '\u00EB', // lower case letter E with diaresis
+        '\u00EC', // lower case letter I with grave
+        '\u00ED', // lower case letter I with acute
+        '\u00EE', // lower case letter I with circumflex
+        '\u00EF', // lower case letter I with diaresis
+        '\u00F0', // lower case letter Eth (Icelandic)
+        '\u00F1', // lower case letter N with tilde
+        '\u00F2', // lower case letter O with grave
+        '\u00F3', // lower case letter O with acute
+        '\u00F4', // lower case letter O with circumflex
+        '\u00F5', // lower case letter O with tilde
+        '\u00F6', // lower case letter O with diaresis
+        '\u00F7', // division sign
+        '\u00F8', // lower case letter O with stroke
+        '\u00F9', // lower case letter U with grave
+        '\u00FA', // lower case letter U with acute
+        '\u00FB', // lower case letter U with circumflex
+        '\u00FC', // lower case letter U with diaresis
+        '\u00FD', // lower case letter Y with acute
+        '\u00FE', // lower case letter Thorn (Icelandic)
+        '\u00FF', // lower case letter Y with diaresis
+    };
+
+    private final static char[] euroChar = { 
+        '\u20AC', // Euro currency symbol
+    };
+    
+    private final static char[] de_DE = {
+        '\u00A2', // cent sign
+        '\u00C1', // upper case letter A with acute
+        '\u00D6', // upper case letter O with diaresis
+        '\u00DC', // upper case letter U with diaresis
+        '\u00DF', // lower case letter Sharp S (German)
+        '\u00E1', // lower case letter A with acute
+        '\u00F6', // lower case letter O with diaresis
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] dk_DK = {
+        '\u00C5', // upper case letter A with ring above
+        '\u00C6', // upper case letter AE
+        '\u00D8', // upper case letter O with stroke
+        '\u00E5', // lower case letter A with ring above
+        '\u00E6', // lower case letter AE
+        '\u00F8', // lower case letter O with stroke
+    };
+
+    private final static char[] en_GB = {
+        '\u00A2', // cent sign
+        '\u00A3', // pound sign
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] en_US = {
+    };
+    
+    private final static char[] es_ES = {
+        '\u00A2', // cent sign
+        '\u00C1', // upper case letter A with acute
+        '\u00C9', // upper case letter E with acute
+        '\u00CD', // upper case letter I with acute
+        '\u00D1', // upper case letter N with tilde
+        '\u00D3', // upper case letter O with acute
+        '\u00DA', // upper case letter U with acute
+        '\u00DC', // upper case letter U with diaresis
+        '\u00E1', // lower case letter A with acute
+        '\u00E9', // lower case letter E with acute
+        '\u00ED', // lower case letter I with acute
+        '\u00F1', // lower case letter N with tilde
+        '\u00F3', // lower case letter O with acute
+        '\u00FA', // lower case letter U with acute
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] fi_FI = { 
+        '\u00A2', // cent sign
+        '\u00C4', // upper case letter A with diaresis
+        '\u00C5', // upper case letter A with ring above
+        '\u00D6', // upper case letter O with diaresis
+        '\u00E4', // lower case letter A with diaresis
+        '\u00E5', // lower case letter A with ring above
+        '\u00F6', // lower case letter O with diaresis
+        '\u0160', // upper case letter S with caron
+        '\u0161', // lower case letter S with caron
+        '\u017D', // upper case letter Z with caron
+        '\u017E', // lower case letter z with caron
+        '\u20AC', // Euro currency symbol
+    };
+    
+    private final static char[] fr_FR = {
+        '\u00A2', // cent sign
+        '\u00C0', // upper case letter A with grave
+        '\u00C2', // upper case letter A with circumflex
+        '\u00C7', // upper case letter C with cedilla
+        '\u00C8', // upper case letter E with grave
+        '\u00C9', // upper case letter E with acute
+        '\u00CA', // upper case letter E with circumflex
+        '\u00CB', // upper case letter E with diaresis
+        '\u00CE', // upper case letter I with circumflex
+        '\u00CF', // upper case letter I with diaresis
+        '\u00D4', // upper case letter O with circumflex
+        '\u00DA', // upper case letter U with acute
+        '\u00DC', // upper case letter U with diaresis
+        '\u00E0', // lower case letter A with grave
+        '\u00E2', // lower case letter A with circumflex
+        '\u00E7', // lower case letter C with cedilla
+        '\u00E8', // lower case letter E with grave
+        '\u00E9', // lower case letter E with acute
+        '\u00EA', // lower case letter E with circumflex
+        '\u00EB', // lower case letter E with diaresis
+        '\u00EE', // lower case letter I with circumflex
+        '\u00EF', // lower case letter I with diaresis
+        '\u00F4', // lower case letter O with circumflex
+        '\u00FA', // lower case letter U with acute
+        '\u00FC', // lower case letter U with diaresis
+        '\u0152', // upper case oE ligature
+        '\u0153', // lower case oE ligature
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] it_IT = {
+        '\u00A2', // cent sign
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] nl_NL = {
+        '\u0132', // upper case IJ ligature
+        '\u0133', // lower case IJ ligature
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] no_NO = {
+        '\u00C5', // upper case letter A with ring above
+        '\u00C6', // upper case letter AE
+        '\u00D8', // upper case letter O with stroke
+        '\u00E5', // lower case letter A with ring above
+        '\u00E6', // lower case letter AE
+        '\u00F8', // lower case letter O with stroke
+    };
+
+    private final static char[] pt_PT = {
+        '\u00A2', // cent sign
+        '\u00C0', // upper case letter A with grave
+        '\u00C1', // upper case letter A with acute
+        '\u00C2', // upper case letter A with circumflex
+        '\u00C3', // upper case letter A with tilde
+        '\u00C7', // upper case letter C with cedilla
+        '\u00C9', // upper case letter E with acute
+        '\u00CA', // upper case letter E with circumflex
+        '\u00CD', // upper case letter I with acute
+        '\u00D3', // upper case letter O with acute
+        '\u00D4', // upper case letter O with circumflex
+        '\u00D5', // upper case letter O with tilde
+        '\u00DA', // upper case letter U with acute
+        '\u00DC', // upper case letter U with diaresis
+        '\u00E0', // lower case letter A with grave
+        '\u00E1', // lower case letter A with acute
+        '\u00E2', // lower case letter A with circumflex
+        '\u00E3', // lower case letter A with tilde
+        '\u00E7', // lower case letter C with cedilla
+        '\u00E9', // lower case letter E with acute
+        '\u00EA', // lower case letter E with circumflex
+        '\u00ED', // lower case letter I with acute
+        '\u00F3', // lower case letter O with acute
+        '\u00F4', // lower case letter O with circumflex
+        '\u00F5', // lower case letter O with tilde
+        '\u00FA', // lower case letter U with acute
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] se_SE = {
+        '\u00A2', // cent sign
+        '\u00C4', // upper case letter A with diaresis
+        '\u00C5', // upper case letter A with ring above
+        '\u00D6', // upper case letter O with diaresis
+        '\u00DF', // lower case letter Sharp S (German)
+        '\u00E4', // lower case letter A with diaresis
+        '\u00E5', // lower case letter A with ring above
+        '\u00F6', // lower case letter O with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    /**
+     * Return a predefined set of characters. An integer code is used to select 
+     * the set to avoid possible formatting issues with names of character sets
+     * specified as strings.
+     * 
+     * @param code a predefine constant identifying the character set to 
+     * return.
+     * 
+     * @return an char[] contains all the characters for a given character 
+     * set. If an unknown code is used then an empty array will be returned.
+     */
+    public static final char[] characterSet(int code)
+    {
+        char[] set = new char[0];
+        int index = 0;
+        
+        switch (code)
+        {
+            case euro: set=euroChar; break;
+            case iso_646: set=iso_646_chars; break;
+            case iso_8859_1:
+                set = new char[iso_646_chars.length+iso_8859_1_chars.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;iso_8859_1_chars.length; i++, index++)
+                    set[index] = iso_8859_1_chars[i];
+                 
+                break;
+            default:
+                break;
+        }
+        
+        return set;
+    }
+    /**
+     * Return a character set for a given country and language. This method is
+     * used to generate smaller character sets which will also reduce the size 
+     * of the font definitions.
+     * 
+     * @param locale a Locale identifying the country and optional language 
+     * used to select a character set.
+     * 
+     * @return an array containing all the characters suitable for display
+     * using the specified country and language.
+     */
+    public static final char[] characterSetForLocale(Locale locale)
+    {
+        char[] set = new char[0];
+        
+        String country = locale.getCountry();
+        String language = locale.getLanguage();
+        
+        int index = 0;
+
+        if (language.equals(&quot;de&quot;))
+        {
+            if (country.equals(&quot;DE&quot;))
+            {
+                set = new char[iso_646_chars.length+de_DE.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;de_DE.length; i++, index++)
+                    set[index] = de_DE[i];            
+            }
+        }
+        else if (language.equals(&quot;dk&quot;))
+        {
+            if (country.equals(&quot;DK&quot;))
+            {
+                set = new char[iso_646_chars.length+dk_DK.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;dk_DK.length; i++, index++)
+                    set[index] = dk_DK[i];            
+            }
+        }
+        else if (language.equals(&quot;en&quot;))
+        {
+            if (country.equals(&quot;US&quot;))
+            {
+                set = new char[iso_646_chars.length+en_US.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;en_US.length; i++, index++)
+                    set[index] = en_US[i];            
+            }
+            else if (country.equals(&quot;GB&quot;) || country.equals(&quot;UK&quot;))
+            {
+                set = new char[iso_646_chars.length+en_GB.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;en_GB.length; i++, index++)
+                    set[index] = en_GB[i];            
+            }
+            else
+            {
+                set = new char[iso_646_chars.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+            }
+        }
+        else if (language.equals(&quot;es&quot;))
+        {
+            if (country.equals(&quot;ES&quot;))
+            {
+                set = new char[iso_646_chars.length+es_ES.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;es_ES.length; i++, index++)
+                    set[index] = es_ES[i];            
+            }
+        }
+        else if (language.equals(&quot;fi&quot;))
+        {
+            if (country.equals(&quot;FI&quot;))
+            {
+                set = new char[iso_646_chars.length+fi_FI.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;fi_FI.length; i++, index++)
+                    set[index] = fi_FI[i];            
+            }
+        }
+        else if (language.equals(&quot;fr&quot;))
+        {
+            if (country.equals(&quot;FR&quot;))
+            {
+                set = new char[iso_646_chars.length+fr_FR.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;fr_FR.length; i++, index++)
+                    set[index] = fr_FR[i];            
+            }
+        }
+        else if (language.equals(&quot;it&quot;))
+        {
+            if (country.equals(&quot;IT&quot;))
+            {
+                set = new char[iso_646_chars.length+it_IT.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;it_IT.length; i++, index++)
+                    set[index] = it_IT[i];            
+            }
+        }
+        else if (language.equals(&quot;nl&quot;))
+        {
+            if (country.equals(&quot;NL&quot;))
+            {
+                set = new char[iso_646_chars.length+nl_NL.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;nl_NL.length; i++, index++)
+                    set[index] = nl_NL[i];            
+            }
+        }
+        else if (language.equals(&quot;no&quot;))
+        {
+            if (country.equals(&quot;N0&quot;))
+            {
+                set = new char[iso_646_chars.length+no_NO.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;no_NO.length; i++, index++)
+                    set[index] = no_NO[i];            
+            }
+        }
+        else if (language.equals(&quot;pt&quot;))
+        {
+            if (country.equals(&quot;PT&quot;))
+            {
+                set = new char[iso_646_chars.length+pt_PT.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;pt_PT.length; i++, index++)
+                    set[index] = pt_PT[i];            
+            }
+        }
+        else if (language.equals(&quot;se&quot;))
+        {
+            if (country.equals(&quot;SE&quot;))
+            {
+                set = new char[iso_646_chars.length+se_SE.length];
+                
+                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i&lt;se_SE.length; i++, index++)
+                    set[index] = se_SE[i];            
+            }
+        }
+        return set;
+    }
+
+}

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/FSCharacterTable.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSCharacterTable.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSCharacterTable.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -1,664 +0,0 @@
-/*
- *  FSCharacterTable.java
- *  Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package com.flagstone.transform.util;
-
-import java.util.Locale;
-
-/**
- * The FSCharacterTable class provides predefined arrays of characters that can
- * be used with the FSTextConstructor's willDisplay() method to predefine the 
- * characters that will be displayed using a given font.
- * 
- * Character sets are simply list of characters to use. The names used to 
- * identify collections of characters use official character set names, such
- * as iso_8859_1. However they do NOT indicate how the characters are encoded
- * as such (all strings are encoded using UTF-8) they are simply a way of 
- * naming a group of characters in a recognized (and standard) way.
- * 
- * Other sets that use characters appropriate for a specific country and 
- * language also use ISO designations for a specific locale such as en_US
- * or pt_BR.
- *
- */
-public class FSCharacterTable 
-{
-    /*
-     * List of character sets supported. 
-     */
-    
-    /**
-     * Code identifying a set containing the single character for the euro
-     * currency symbol. It is included as a separate set as manly formal 
-     * coded character sets do not include it. A separate set makes it easier
-     * to match different sets of characters together.
-     * 
-     * The (Unicode) character code for this symbol is 0x20AC so it will
-     * typically be the last character set passed to the FSTextConstructor's
-     * willDisplay() method.
-     */
-    public static final int euro = 0;
-    /**
-     * Code identifying formal the characters defined in ISO 646.
-     * 
-     * Alias: ASCII
-     */
-    public static final int iso_646 = 1;
-    /**
-     * Code identifying formal the characters defined in ISO-8859-1.
-     * 
-     * Alias: Latin-1
-     */
-    public static final int iso_8859_1 = 2;
-    
-    /*
-     * The ISO 646 character set is used as a base for other characters sets.
-     * Other character sets are created by including these characters in the 
-     * array returned by the characterSetWithCode() method. This saves space
-     * and more importantly makes it easier to correct errors.
-     */
-    private final static char[] iso_646_chars = {
-        '\u0020', // space
-        '\u0021', // exclamation mark
-        '\u0022', // quotation mark
-        '\u0023', // number sign
-        '\u0024', // dollar sign
-        '\u0025', // percent sign
-        '\u0026', // ampersand
-        '\'',     // apostrophe
-        '\u0028', // left parenthesis
-        '\u0029', // right parenthesis
-        '\u002A', // asterisk
-        '\u002B', // plus sign
-        '\u002C', // comma
-        '\u002D', // hyphen or minus
-        '\u002E', // full stop
-        '\u002F', // forward slash
-        '\u0030', // digit zero
-        '\u0031', // digit one
-        '\u0032', // digit two
-        '\u0033', // digit three
-        '\u0034', // digit four
-        '\u0035', // digit five
-        '\u0036', // digit six
-        '\u0037', // digit seven
-        '\u0038', // digit eight
-        '\u0039', // digit nine
-        '\u003A', // colon
-        '\u003B', // semicolon
-        '\u003C', // less than sign
-        '\u003D', // equals sign
-        '\u003E', // greater than sign
-        '\u003F', // question mark
-        '\u0040', // commercial at
-        '\u0041', // upper case A
-        '\u0042', // upper case B
-        '\u0043', // upper case C
-        '\u0044', // upper case D
-        '\u0045', // upper case E
-        '\u0046', // upper case F
-        '\u0047', // upper case G
-        '\u0048', // upper case H
-        '\u0049', // upper case I
-        '\u004A', // upper case J
-        '\u004B', // upper case K
-        '\u004C', // upper case L
-        '\u004D', // upper case M
-        '\u004E', // upper case N
-        '\u004F', // upper case O
-        '\u0050', // upper case P
-        '\u0051', // upper case Q
-        '\u0052', // upper case R
-        '\u0053', // upper case S
-        '\u0054', // upper case T
-        '\u0055', // upper case U
-        '\u0056', // upper case V
-        '\u0057', // upper case W
-        '\u0058', // upper case X
-        '\u0059', // upper case Y
-        '\u005A', // upper case Z
-        '\u005B', // left square bracket
-        '\\',     // backslash
-        '\u005D', // right square bracket
-        '\u005E', // circumflex
-        '\u005F', // underscore
-        '\u0060', // grave
-        '\u0061', // lower case A
-        '\u0062', // lower case B
-        '\u0063', // lower case C
-        '\u0064', // lower case D
-        '\u0065', // lower case E
-        '\u0066', // lower case F
-        '\u0067', // lower case G
-        '\u0068', // lower case H
-        '\u0069', // lower case I
-        '\u006A', // lower case J
-        '\u006B', // lower case K
-        '\u006C', // lower case L
-        '\u006D', // lower case M
-        '\u006E', // lower case N
-        '\u006F', // lower case O
-        '\u0070', // lower case P
-        '\u0071', // lower case Q
-        '\u0072', // lower case R
-        '\u0073', // lower case S
-        '\u0074', // lower case T
-        '\u0075', // lower case U
-        '\u0076', // lower case V
-        '\u0077', // lower case W
-        '\u0078', // lower case X
-        '\u0079', // lower case Y
-        '\u007A', // lower case Z
-        '\u007B', // left curly bracket
-        '\u007C', // vertical line
-        '\u007D', // right curly bracket
-        '\u007E', // tilde
-    };
-    
-    private static final char[] iso_8859_1_chars = new char[] {
-        '\u00A0', // non-breaking space
-        '\u00A1', // inverted exclamation mark
-        '\u00A2', // cent sign
-        '\u00A3', // pound sign
-        '\u00A4', // currency sign
-        '\u00A5', // yen sign
-        '\u00A6', // broken BAR
-        '\u00A7', // section sign
-        '\u00A8', // diaresis
-        '\u00A9', // copyright sign
-        '\u00AA', // feminine ordinal indicator
-        '\u00AB', // left pointing double angle quotation mark
-        '\u00AC', // not sign
-        '\u00AD', // soft hyphen
-        '\u00AE', // registered trademark sign
-        '\u00AF', // macron
-        '\u00B0', // degree sign
-        '\u00B1', // plus-minus sign
-        '\u00B2', // superscript two
-        '\u00B3', // superscript three
-        '\u00B4', // acute accent
-        '\u00B5', // micro sign
-        '\u00B6', // pilcrow sign
-        '\u00B7', // middle dot
-        '\u00B8', // cedilla
-        '\u00B9', // superscript ONE
-        '\u00BA', // masculine ordinal indicator
-        '\u00BB', // right pointing double angle quotation mark
-        '\u00BC', // vulgar fraction one quarter
-        '\u00BD', // vulgar fraction one half
-        '\u00BE', // vulgar fraction three quarters
-        '\u00BF', // inverted question mark
-        '\u00C0', // upper case letter A with grave
-        '\u00C1', // upper case letter A with acute
-        '\u00C2', // upper case letter A with circumflex
-        '\u00C3', // upper case letter A with tilde
-        '\u00C4', // upper case letter A with diaresis
-        '\u00C5', // upper case letter A with ring above
-        '\u00C6', // upper case letter AE
-        '\u00C7', // upper case letter C with cedilla
-        '\u00C8', // upper case letter E with grave
-        '\u00C9', // upper case letter E with acute
-        '\u00CA', // upper case letter E with circumflex
-        '\u00CB', // upper case letter E with diaresis
-        '\u00CC', // upper case letter I with grave
-        '\u00CD', // upper case letter I with acute
-        '\u00CE', // upper case letter I with circumflex
-        '\u00CF', // upper case letter I with diaresis
-        '\u00D0', // upper case letter Eth (Icelandic)
-        '\u00D1', // upper case letter N with tilde
-        '\u00D2', // upper case letter O with grave
-        '\u00D3', // upper case letter O with acute
-        '\u00D4', // upper case letter O with circumflex
-        '\u00D5', // upper case letter O with tilde
-        '\u00D6', // upper case letter O with diaresis
-        '\u00D7', // multiplication sign
-        '\u00D8', // upper case letter O with stroke
-        '\u00D9', // upper case letter U with grave
-        '\u00DA', // upper case letter U with acute
-        '\u00DB', // upper case letter U with circumflex
-        '\u00DC', // upper case letter U with diaresis
-        '\u00DD', // upper case letter Y with acute
-        '\u00DE', // upper case letter Thorn (Icelandic)
-        '\u00DF', // lower case letter Sharp S (German)
-        '\u00E0', // lower case letter A with grave
-        '\u00E1', // lower case letter A with acute
-        '\u00E2', // lower case letter A with circumflex
-        '\u00E3', // lower case letter A with tilde
-        '\u00E4', // lower case letter A with diaresis
-        '\u00E5', // lower case letter A with ring above
-        '\u00E6', // lower case letter AE
-        '\u00E7', // lower case letter C with cedilla
-        '\u00E8', // lower case letter E with grave
-        '\u00E9', // lower case letter E with acute
-        '\u00EA', // lower case letter E with circumflex
-        '\u00EB', // lower case letter E with diaresis
-        '\u00EC', // lower case letter I with grave
-        '\u00ED', // lower case letter I with acute
-        '\u00EE', // lower case letter I with circumflex
-        '\u00EF', // lower case letter I with diaresis
-        '\u00F0', // lower case letter Eth (Icelandic)
-        '\u00F1', // lower case letter N with tilde
-        '\u00F2', // lower case letter O with grave
-        '\u00F3', // lower case letter O with acute
-        '\u00F4', // lower case letter O with circumflex
-        '\u00F5', // lower case letter O with tilde
-        '\u00F6', // lower case letter O with diaresis
-        '\u00F7', // division sign
-        '\u00F8', // lower case letter O with stroke
-        '\u00F9', // lower case letter U with grave
-        '\u00FA', // lower case letter U with acute
-        '\u00FB', // lower case letter U with circumflex
-        '\u00FC', // lower case letter U with diaresis
-        '\u00FD', // lower case letter Y with acute
-        '\u00FE', // lower case letter Thorn (Icelandic)
-        '\u00FF', // lower case letter Y with diaresis
-    };
-
-    private final static char[] euroChar = { 
-        '\u20AC', // Euro currency symbol
-    };
-    
-    private final static char[] de_DE = {
-        '\u00A2', // cent sign
-        '\u00C1', // upper case letter A with acute
-        '\u00D6', // upper case letter O with diaresis
-        '\u00DC', // upper case letter U with diaresis
-        '\u00DF', // lower case letter Sharp S (German)
-        '\u00E1', // lower case letter A with acute
-        '\u00F6', // lower case letter O with diaresis
-        '\u00FC', // lower case letter U with diaresis
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] dk_DK = {
-        '\u00C5', // upper case letter A with ring above
-        '\u00C6', // upper case letter AE
-        '\u00D8', // upper case letter O with stroke
-        '\u00E5', // lower case letter A with ring above
-        '\u00E6', // lower case letter AE
-        '\u00F8', // lower case letter O with stroke
-    };
-
-    private final static char[] en_GB = {
-        '\u00A2', // cent sign
-        '\u00A3', // pound sign
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] en_US = {
-    };
-    
-    private final static char[] es_ES = {
-        '\u00A2', // cent sign
-        '\u00C1', // upper case letter A with acute
-        '\u00C9', // upper case letter E with acute
-        '\u00CD', // upper case letter I with acute
-        '\u00D1', // upper case letter N with tilde
-        '\u00D3', // upper case letter O with acute
-        '\u00DA', // upper case letter U with acute
-        '\u00DC', // upper case letter U with diaresis
-        '\u00E1', // lower case letter A with acute
-        '\u00E9', // lower case letter E with acute
-        '\u00ED', // lower case letter I with acute
-        '\u00F1', // lower case letter N with tilde
-        '\u00F3', // lower case letter O with acute
-        '\u00FA', // lower case letter U with acute
-        '\u00FC', // lower case letter U with diaresis
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] fi_FI = { 
-        '\u00A2', // cent sign
-        '\u00C4', // upper case letter A with diaresis
-        '\u00C5', // upper case letter A with ring above
-        '\u00D6', // upper case letter O with diaresis
-        '\u00E4', // lower case letter A with diaresis
-        '\u00E5', // lower case letter A with ring above
-        '\u00F6', // lower case letter O with diaresis
-        '\u0160', // upper case letter S with caron
-        '\u0161', // lower case letter S with caron
-        '\u017D', // upper case letter Z with caron
-        '\u017E', // lower case letter z with caron
-        '\u20AC', // Euro currency symbol
-    };
-    
-    private final static char[] fr_FR = {
-        '\u00A2', // cent sign
-        '\u00C0', // upper case letter A with grave
-        '\u00C2', // upper case letter A with circumflex
-        '\u00C7', // upper case letter C with cedilla
-        '\u00C8', // upper case letter E with grave
-        '\u00C9', // upper case letter E with acute
-        '\u00CA', // upper case letter E with circumflex
-        '\u00CB', // upper case letter E with diaresis
-        '\u00CE', // upper case letter I with circumflex
-        '\u00CF', // upper case letter I with diaresis
-        '\u00D4', // upper case letter O with circumflex
-        '\u00DA', // upper case letter U with acute
-        '\u00DC', // upper case letter U with diaresis
-        '\u00E0', // lower case letter A with grave
-        '\u00E2', // lower case letter A with circumflex
-        '\u00E7', // lower case letter C with cedilla
-        '\u00E8', // lower case letter E with grave
-        '\u00E9', // lower case letter E with acute
-        '\u00EA', // lower case letter E with circumflex
-        '\u00EB', // lower case letter E with diaresis
-        '\u00EE', // lower case letter I with circumflex
-        '\u00EF', // lower case letter I with diaresis
-        '\u00F4', // lower case letter O with circumflex
-        '\u00FA', // lower case letter U with acute
-        '\u00FC', // lower case letter U with diaresis
-        '\u0152', // upper case oE ligature
-        '\u0153', // lower case oE ligature
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] it_IT = {
-        '\u00A2', // cent sign
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] nl_NL = {
-        '\u0132', // upper case IJ ligature
-        '\u0133', // lower case IJ ligature
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] no_NO = {
-        '\u00C5', // upper case letter A with ring above
-        '\u00C6', // upper case letter AE
-        '\u00D8', // upper case letter O with stroke
-        '\u00E5', // lower case letter A with ring above
-        '\u00E6', // lower case letter AE
-        '\u00F8', // lower case letter O with stroke
-    };
-
-    private final static char[] pt_PT = {
-        '\u00A2', // cent sign
-        '\u00C0', // upper case letter A with grave
-        '\u00C1', // upper case letter A with acute
-        '\u00C2', // upper case letter A with circumflex
-        '\u00C3', // upper case letter A with tilde
-        '\u00C7', // upper case letter C with cedilla
-        '\u00C9', // upper case letter E with acute
-        '\u00CA', // upper case letter E with circumflex
-        '\u00CD', // upper case letter I with acute
-        '\u00D3', // upper case letter O with acute
-        '\u00D4', // upper case letter O with circumflex
-        '\u00D5', // upper case letter O with tilde
-        '\u00DA', // upper case letter U with acute
-        '\u00DC', // upper case letter U with diaresis
-        '\u00E0', // lower case letter A with grave
-        '\u00E1', // lower case letter A with acute
-        '\u00E2', // lower case letter A with circumflex
-        '\u00E3', // lower case letter A with tilde
-        '\u00E7', // lower case letter C with cedilla
-        '\u00E9', // lower case letter E with acute
-        '\u00EA', // lower case letter E with circumflex
-        '\u00ED', // lower case letter I with acute
-        '\u00F3', // lower case letter O with acute
-        '\u00F4', // lower case letter O with circumflex
-        '\u00F5', // lower case letter O with tilde
-        '\u00FA', // lower case letter U with acute
-        '\u00FC', // lower case letter U with diaresis
-        '\u20AC', // Euro currency symbol
-    };
-
-    private final static char[] se_SE = {
-        '\u00A2', // cent sign
-        '\u00C4', // upper case letter A with diaresis
-        '\u00C5', // upper case letter A with ring above
-        '\u00D6', // upper case letter O with diaresis
-        '\u00DF', // lower case letter Sharp S (German)
-        '\u00E4', // lower case letter A with diaresis
-        '\u00E5', // lower case letter A with ring above
-        '\u00F6', // lower case letter O with diaresis
-        '\u20AC', // Euro currency symbol
-    };
-
-    /**
-     * Return a predefined set of characters. An integer code is used to select 
-     * the set to avoid possible formatting issues with names of character sets
-     * specified as strings.
-     * 
-     * @param code a predefine constant identifying the character set to 
-     * return.
-     * 
-     * @return an char[] contains all the characters for a given character 
-     * set. If an unknown code is used then an empty array will be returned.
-     */
-    public static final char[] characterSet(int code)
-    {
-        char[] set = new char[0];
-        int index = 0;
-        
-        switch (code)
-        {
-            case euro: set=euroChar; break;
-            case iso_646: set=iso_646_chars; break;
-            case iso_8859_1:
-                set = new char[iso_646_chars.length+iso_8859_1_chars.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;iso_8859_1_chars.length; i++, index++)
-                    set[index] = iso_8859_1_chars[i];
-                 
-                break;
-            default:
-                break;
-        }
-        
-        return set;
-    }
-    /**
-     * Return a character set for a given country and language. This method is
-     * used to generate smaller character sets which will also reduce the size 
-     * of the font definitions.
-     * 
-     * @param locale a Locale identifying the country and optional language 
-     * used to select a character set.
-     * 
-     * @return an array containing all the characters suitable for display
-     * using the specified country and language.
-     */
-    public static final char[] characterSetForLocale(Locale locale)
-    {
-        char[] set = new char[0];
-        
-        String country = locale.getCountry();
-        String language = locale.getLanguage();
-        
-        int index = 0;
-
-        if (language.equals(&quot;de&quot;))
-        {
-            if (country.equals(&quot;DE&quot;))
-            {
-                set = new char[iso_646_chars.length+de_DE.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;de_DE.length; i++, index++)
-                    set[index] = de_DE[i];            
-            }
-        }
-        else if (language.equals(&quot;dk&quot;))
-        {
-            if (country.equals(&quot;DK&quot;))
-            {
-                set = new char[iso_646_chars.length+dk_DK.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;dk_DK.length; i++, index++)
-                    set[index] = dk_DK[i];            
-            }
-        }
-        else if (language.equals(&quot;en&quot;))
-        {
-            if (country.equals(&quot;US&quot;))
-            {
-                set = new char[iso_646_chars.length+en_US.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;en_US.length; i++, index++)
-                    set[index] = en_US[i];            
-            }
-            else if (country.equals(&quot;GB&quot;) || country.equals(&quot;UK&quot;))
-            {
-                set = new char[iso_646_chars.length+en_GB.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;en_GB.length; i++, index++)
-                    set[index] = en_GB[i];            
-            }
-            else
-            {
-                set = new char[iso_646_chars.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-            }
-        }
-        else if (language.equals(&quot;es&quot;))
-        {
-            if (country.equals(&quot;ES&quot;))
-            {
-                set = new char[iso_646_chars.length+es_ES.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;es_ES.length; i++, index++)
-                    set[index] = es_ES[i];            
-            }
-        }
-        else if (language.equals(&quot;fi&quot;))
-        {
-            if (country.equals(&quot;FI&quot;))
-            {
-                set = new char[iso_646_chars.length+fi_FI.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;fi_FI.length; i++, index++)
-                    set[index] = fi_FI[i];            
-            }
-        }
-        else if (language.equals(&quot;fr&quot;))
-        {
-            if (country.equals(&quot;FR&quot;))
-            {
-                set = new char[iso_646_chars.length+fr_FR.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;fr_FR.length; i++, index++)
-                    set[index] = fr_FR[i];            
-            }
-        }
-        else if (language.equals(&quot;it&quot;))
-        {
-            if (country.equals(&quot;IT&quot;))
-            {
-                set = new char[iso_646_chars.length+it_IT.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;it_IT.length; i++, index++)
-                    set[index] = it_IT[i];            
-            }
-        }
-        else if (language.equals(&quot;nl&quot;))
-        {
-            if (country.equals(&quot;NL&quot;))
-            {
-                set = new char[iso_646_chars.length+nl_NL.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;nl_NL.length; i++, index++)
-                    set[index] = nl_NL[i];            
-            }
-        }
-        else if (language.equals(&quot;no&quot;))
-        {
-            if (country.equals(&quot;N0&quot;))
-            {
-                set = new char[iso_646_chars.length+no_NO.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;no_NO.length; i++, index++)
-                    set[index] = no_NO[i];            
-            }
-        }
-        else if (language.equals(&quot;pt&quot;))
-        {
-            if (country.equals(&quot;PT&quot;))
-            {
-                set = new char[iso_646_chars.length+pt_PT.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;pt_PT.length; i++, index++)
-                    set[index] = pt_PT[i];            
-            }
-        }
-        else if (language.equals(&quot;se&quot;))
-        {
-            if (country.equals(&quot;SE&quot;))
-            {
-                set = new char[iso_646_chars.length+se_SE.length];
-                
-                for (int i=0; i&lt;iso_646_chars.length; i++, index++)
-                    set[index] = iso_646_chars[i];
-                
-                for (int i=0; i&lt;se_SE.length; i++, index++)
-                    set[index] = se_SE[i];            
-            }
-        }
-        return set;
-    }
-
-}

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -1,1721 +0,0 @@
-/*
- *  FSImageConstructor.java
- *  Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform.util;
-
-import java.io.*;
-import java.util.*;
-import java.util.zip.*;
-
-import com.flagstone.transform.FSDefineObject;
-import com.flagstone.transform.FSDefineImage;
-import com.flagstone.transform.FSDefineImage2;
-import com.flagstone.transform.FSDefineJPEGImage2;
-import com.flagstone.transform.FSDefineShape3;
-
-import com.flagstone.transform.FSCoder;
-import com.flagstone.transform.FSImageBlock;
-import com.flagstone.transform.FSShape;
-import com.flagstone.transform.FSCoordTransform;
-import com.flagstone.transform.FSBounds;
-import com.flagstone.transform.FSShapeStyle;
-import com.flagstone.transform.FSLine;
-
-import com.flagstone.transform.FSLineStyle;
-
-import com.flagstone.transform.FSFillStyle;
-import com.flagstone.transform.FSBitmapFill;
-
-/**
- * The FSImageConstructor class is used to generate an image definition object from an image stored
- * in a file. Currently PNG, BMP and JPEG encoded images are supported. The name of the file containing 
- * the image can be specified directly in the class constructor:&lt;/p&gt;
- *
- * &lt;pre&gt;
- *     FSImageConstructor imageConstructor = new FSImageConstructor(imageFile);
-  * &lt;/pre&gt;
- *
- * A single FSImageConstructor object can also be used to load a series of images:
- *
- * &lt;pre&gt;
- *     imageConstructor.setImageFromFile(imageFile);
- * &lt;/pre&gt;
- *
- * &lt;P&gt;If an error occurs each method will throw either a FileNotFoundException, IOException or 
- * DataFormatException depending on the error detected.&lt;/P&gt;
- *
- * &lt;P&gt;When an image is loaded the getFormat() method identifies the way the image is encoded:&lt;/P&gt;
- *
- * &lt;table&gt;
- * &lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;JPEG&lt;/td&gt;
- * &lt;td&gt;A JPEG encoded image.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;IDX8&lt;/td&gt;
- * &lt;td&gt;An indexed image where each pixel specifies an index into a colour table containing up to 
- * 256 24-bit colours. Transparent colours are not supported.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;IDXA&lt;/td&gt;
- * &lt;td&gt;An indexed image where each pixel specifies an index into a colour table containing up to 
- * 256 32-bit colours - 8-bits for each colour channel and 8-bits for transparency.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;RGB5&lt;/td&gt;
- * &lt;td&gt;An true colour image where each pixel specifies a 16-bit colour, with 5-bits per colour
- * channel. Transparent colours are not supported.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;RGB8&lt;/td&gt;
- * &lt;td&gt;An true colour image where each pixel specifies a 24-bit colour, with 8-bits per colour
- * channel. Each pixel occupies 32-bits. Transparent colours are not supported so the first 
- * (most significant) byte is set to 255 by default.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;RGBA&lt;/td&gt;
- * &lt;td&gt;An true colour image where each pixel specifies a 32-bit colour, with 8-bits per colour
- * channel and 8-bits for transparency. The first (most significant) byte contains the 
- * transparency information.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;/table&gt;
- *
- * &lt;P&gt;Once an image is loaded the definition required to add the image to a Flash file is 
- * generated using the defineImage() method:&lt;/p&gt;
- *
- * &lt;pre&gt;
- *     movie.add(imageConstructor.defineImage(movie.newIdentifier()));
- * &lt;/pre&gt;
- *
- * &lt;P&gt;The defineImage()method returns an FSDefineObject (the abstract base class for all objects used 
- * to define shapes etc. in a Flash file. The exact class of the object generated depends of the format 
- * of the image loaded.&lt;/P&gt;
- *
- * &lt;table&gt;
- * &lt;tr&gt;&lt;th&gt;Class&lt;/th&gt;&lt;th&gt;Generated when...&lt;/th&gt;&lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;FSDefineJPEGImage2&lt;/td&gt;
- * &lt;td&gt;A JPEG encoded image is loaded. The getFormat() method returns the class constant JPEG.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;FSDefineImage&lt;/td&gt;
- * &lt;td&gt;An indexed BMP or PNG image contains a colour table without transparent colours or 
- * when a true colour image contains 16-bit or 24-bit colours is loaded. The getFormat() method returns 
- * the class constants IDX8, RGB5 or RGB8.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;tr&gt;
- * &lt;td&gt;FSDefineImage2&lt;/td&gt;
- * &lt;td&gt;A BMP or PNG indexed image contains a colour table with transparent colours is loaded or 
- * when a true colour image contains 32-bit bit colours. The getFormat() method returns the class 
- * constants IDXA or RGBA.&lt;/td&gt;
- * &lt;/tr&gt;
- *
- * &lt;/table&gt;
- * 
- * &lt;P&gt;Images are displayed in Flash by filling a shape with the image bitmap. The defineEnclosingShape()
- * method generates a rectangular shape object which wraps the image:
- *
- * &lt;pre&gt;
- *     int imageId = movie.newIdentifier();
- *     int shapeId = movie.newIdentifier();
- * 
- *     int xOrigin = imageConstructor.getWidth()/2;
- *     int yOrigin = imageConstructor.getHeight()/2;
- * 
- *     boolean border = false;
- * 
- *     movie.add(imageConstructor.defineImage(imageId));
- *     movie.add(imageConstructor.defineEnclosingShape(shapeId, imageId, xOrigin, yOrigin, border));
- * &lt;/pre&gt;
- * 
- * &lt;P&gt;Here the origin, used when placing the shape on the screen, is defined as the centre of the shape.
- * Other points may be defined to suit the alignment of the shape when it is placed on the display list.&lt;/P&gt;
- * 
- * &lt;h2&gt;Post Processing&lt;/h2&gt;
- * 
- * &lt;P&gt;Once an image has been loaded, FSImageConstructor supports a range of methods to access the colour table 
- * or image data - depending on the image format. This allows the image data to be processed before the objects
- * used to add the image to a Flash file are defined.
- * 
- * &lt;pre&gt;
- *     imageConstructor.getColorTable();
- *     imageConstructor.getIndexedImage();
- *     imageConstructor.setColorImage();
- *     imageConstructor.getJPEGImage();
- * &lt;/pre&gt;
- * 
- * &lt;P&gt;The information returned will depend on the image format. If an indexed image is loaded then the 
- * getColourTable() and getIndexedImage() will return the arrays of bytes for the colour table and image
- * respectively. If getColorImage() or getJPEGImage() are used on an indexed image then they will return 
- * null objects.&lt;/P&gt;
- * 
- * &lt;P&gt;Once the image data has been processed separate set methods are available depending on the type of 
- * image:&lt;/P&gt;
- *
- * &lt;pre&gt;
- *     imageConstructor.setIndexedImage(format, imageWidth, imageHeight, colourTable, image);
- *     imageConstructor.setColorImage(format, imageWidth, imageHeight, image);
- *     imageConstructor.setJPEGImage(imageWidth, imageHeight, image);
- * &lt;/pre&gt;
- */
-public class FSImageConstructor
-{
-    /** Format for JPEG encoded images */
-    public static final int JPEG = 0;
-    /** Format for indexed images containing a colour table with 24-bit colours. */
-    public static final int IDX8 = 1;
-    /** Format for indexed images containing a colour table with 32-bit colours. */
-    public static final int IDXA = 2;
-    /** Format for true colour images containing 16-bit colours, 5-bits for each colour channel. */
-    public static final int RGB5 = 3;
-    /** Format for true colour images containing 24-bit colours, 8-bits for each colour channel. */
-    public static final int RGB8 = 4;
-    /** Format for true colour images containing 32-bit colours, 8-bits for each colour channel plus transparency. */
-    public static final int RGBA = 5;
-    
-    // Tables mapping greyscale values onto 8-bit colour channels
-    
-    private static final int[] monochrome = { 0, 255 };
-    private static final int[] greyscale2 = { 0, 85, 170, 255 };
-    private static final int[] greyscale4 = { 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255 };
-    
-    // Constants used for BMP images 
-    
-    private static final int[] bmpSignature = { 66, 77 };
-
-    private final int BI_RGB = 0;
-    private final int BI_RLE8 = 1;
-    private final int BI_RLE4 = 2;
-    private final int BI_BITFIELDS = 3;
-
-    // Constants used for PNG images 
-        
-    private static final int[] pngSignature = { 137, 80, 78, 71, 13, 10, 26, 10 };
-
-    /*
-     * The constants commented out in the following section are defined
-     * for completeness when decoding LNG format images.
-     */
-     
-    // private static final int CRITICAL_CHUNK = 0x20000000;
-    
-    private static final int IHDR = 0x49484452;
-    private static final int PLTE = 0x504c5445;
-    private static final int IDAT = 0x49444154;
-    private static final int IEND = 0x49454e44;
-    private static final int tRNS = 0x74524e53;
-    // private static final int bKGD = 0x624b4744;
-    // private static final int cHRM = 0x6348524d;
-    // private static final int fRAc = 0x66524163;
-    // private static final int gAMA = 0x67414d41;
-    // private static final int gIFg = 0x67494667;
-    // private static final int gIFt = 0x67494674;
-    // private static final int gIFx = 0x67494678;
-    // private static final int hIST = 0x68495354;
-    // private static final int iCCP = 0x69434350;
-    // private static final int iTXt = 0x69545874;
-    // private static final int oFFs = 0x6f464673;
-    // private static final int pCAL = 0x7043414c;
-    // private static final int pHYs = 0x70485973;
-    // private static final int sBIT = 0x73424954;
-    // private static final int sCAL = 0x7343414c;
-    // private static final int sPLT = 0x73504c54;
-    // private static final int sRGB = 0x73524742;
-    // private static final int tEXt = 0x74455874;
-    // private static final int tIME = 0x74494d45;
-    // private static final int zTXt = 0x7a545874;
-    
-    private static final int GREYSCALE = 0;
-    private static final int TRUE_COLOUR = 2;
-    private static final int INDEXED_COLOUR = 3;
-    private static final int ALPHA_GREYSCALE = 4;
-    private static final int ALPHA_TRUECOLOUR = 6;
-    
-    private static final int NO_FILTER = 0;
-    private static final int SUB_FILTER = 1;
-    private static final int UP_FILTER = 2;
-    private static final int AVG_FILTER = 3;
-    private static final int PAETH_FILTER = 4;
-    
-    private static final int[] startRow =        { 0, 0, 4, 0, 2, 0, 1 };
-    private static final int[] startColumn =     { 0, 4, 0, 2, 0, 1, 0 };
-    private static final int[] rowIncrement =    { 8, 8, 8, 4, 4, 2, 2 };
-    private static final int[] columnIncrement = { 8, 8, 4, 4, 2, 2, 1 };
-    
-    // Attributes shred between different image formats
-    private static final int BIT_DEPTH = 0;
-    private static final int COLOUR_COMPONENTS = 1;
-    private static final int COMPRESSION_METHOD = 2;
-    
-    // BMP specific attributes
-    private static final int RED_MASK = 4;
-    private static final int GREEN_MASK = 5;
-    private static final int BLUE_MASK = 6;
-
-    // PNG specific attributes
-    private static final int COLOUR_TYPE = 4;
-    private static final int FILTER_METHOD = 5;
-    private static final int INTERLACE_METHOD = 6;
-    private static final int TRANSPARENT_GREY = 7;
-    private static final int TRANSPARENT_RED = 8;
-    private static final int TRANSPARENT_GREEN = 9;
-    private static final int TRANSPARENT_BLUE = 10;
-    
-    private int format = 0;
-    private int width = 0;
-    private int height = 0;
-
-    private byte[][] colourTable = null;
-    private byte[][] indexedImage = null;
-    private byte[][][] colorImage = null;
-    private byte[] jpegImage = null;
-    
-    private int[] attributes = new int[16];
-    private byte[] chunkData = new byte[0];
-    
-    /**
-     * Constructs an FSImageConstructor object with no image.
-     */
-    public FSImageConstructor()
-    {
-    }
-    
-    /**
-     * Constructs and FSImageConstructor object and loads the image from the specified file. The FSImageConstructor
-     * class support Windows bitmap (BMP), Portable Network Graphics (PNG) or JPEG encoded images.
-     *
-     * @param filename the name of the file containing the image.
-     *
-     * @throws FileNotFoundException is the file cannot be found.
-     *
-     * @throws IOException if an error occurs while reading the file.
-     *
-     * @throws DataFormatException if the file contains an unsupported image format or if an error occurs 
-     * while decoding the image in the file.
-     */
-    public FSImageConstructor(String filename) throws IOException, DataFormatException
-    {
-        setImage(dataFromFile(filename));
-    }   
-    /**
-     * Constructs and FSImageConstructor object and loads the encoded image data. The FSImageConstructor
-     * class support Windows bitmap (BMP), Portable Network Graphics (PNG) or JPEG encoded images.
-     *
-     * @param bytes an array of bytes containing the encoded image.
-     *
-     * @throws DataFormatException if the data contains an unsupported image format or if an error occurs 
-     * while decoding the image.
-     */
-    public FSImageConstructor(byte[] bytes) throws DataFormatException
-    {
-        setImage(bytes);
-    }
-    
-    /**
-     * Initialises the FSImageConstructor object with the image in the specified file. This method can be used
-     * to generate the image definition objects for a Flash movie using the same FSImageConstructor object.
-     *
-     * @param filename the name of the file containing the image.
-     *
-     * @throws FileNotFoundException is the file cannot be found.
-     *
-     * @throws IOException if an error occurs while reading the file.
-     *
-     * @throws DataFormatException if the file contains an unsupported image format or if an error occurs 
-     * while decoding the image in the file.
-     */
-    public void setImageFromFile(String filename) throws IOException, DataFormatException
-    {
-        setImage(dataFromFile(filename));
-    }
-    
-    /**
-     * Initialises the FSImageConstructor object with the image data.
-     *
-     * @param bytes an array of bytes containing the encoded image.
-     *
-     * @throws DataFormatException if the data contains an unsupported image format or if an error occurs 
-     * while decoding the image.
-     */
-    public void setImage(byte[] bytes) throws DataFormatException
-    {
-        int signature = ((bytes[0] &amp; 0xFF) &lt;&lt; 8) | (bytes[1] &amp; 0xFF);
-
-        format = 0;
-        width = 0;
-        height = 0;
-    
-        attributes[BIT_DEPTH] = 0;
-        attributes[COLOUR_COMPONENTS] = 0;
-        attributes[COLOUR_TYPE] = 0;
-        attributes[COMPRESSION_METHOD] = 0;
-        attributes[FILTER_METHOD] = 0;
-        attributes[INTERLACE_METHOD] = 0;
-        chunkData = new byte[0];
-
-        attributes[TRANSPARENT_GREY] = -1;    
-        attributes[TRANSPARENT_RED] = -1;
-        attributes[TRANSPARENT_GREEN] = -1;
-        attributes[TRANSPARENT_BLUE] = -1;
-
-        attributes[RED_MASK] = 0;
-        attributes[GREEN_MASK] = 0;
-        attributes[BLUE_MASK] = 0;
-
-        colourTable = null;
-        indexedImage = null;
-        colorImage = null;
-        jpegImage = null;
-        
-        switch (signature)
-        {
-            case 0xffd8: decodeJPEG(bytes); break;
-            case 0x424d: decodeBMP(bytes); break;
-            case 0x8950: decodePNG(bytes); break;
-            default: 
-                throw new DataFormatException(&quot;Unsupported image format&quot;);  
-        }
-    }
-    
-    /**
-     * Returns a constant identifying the format for the way the pixels are encoded.
-     *
-     * @return the image format.
-     */
-    public int getFormat()
-    {
-        return format;
-    }
-
-    /**
-     * Returns the width of the image in pixels.
-     * 
-     * @return the image width in pixels.
-     */
-    public int getWidth()
-    {
-        return width;
-    }
-    /**
-     * Returns the height of the image in pixels.
-     * 
-     * @return the image height in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }   
-    /**
-     * Returns a copy of the colour table used in an indexed image. Each entry in the 
-     * colour table contains 4 bytes with one byte for the alpha channel and each
-     * of the three colour channels, red, green and blue. The alpha channel occupied the 
-     * most significant byte (3) followed by red, green and blue (the least significant byte).
-     * 
-     * For images in IDX8 format the alpha channel defaults to 255 (completely opaque).
-     * 
-     * If the image format is JPEG or one of the true colour formats (RGB5, RGB8, RGBA)
-     * then the colour table returned is null.
-     *
-     * @return a two-dimensional array of bytes containing the colours used in an indexed image.
-     */
-    public byte[][] getColorTable()
-    {
-        byte[][] table = null;
-        
-        if (colourTable != null)
-        {
-            table = new byte[colourTable.length][4];
-        
-            for (int i=0; i&lt;colourTable.length; i++)
-            {
-                for (int j=0; j&lt;4; j++)
-                    table[i][j] = colourTable[i][j];            
-            }
-        }
-        return table;
-    }
-    /**
-     * Returns a copy of the image data decoded from an indexed image. A two
-     * dimensional array is returned, byte[height][width] with each entry containing an 
-     * index into the colour table.
-     * 
-     * If the image format is JPEG or one of the true colour formats (RGB5, RGB8, RGBA)
-     * then the indexed image returned is null.
-     *
-     * @return a two-dimensional array of bytes (height x width) with each entry containing 
-     * an index into the colour table.
-     */
-    public byte[][] getIndexedImage()
-    {
-        byte[][] image = null;
-        
-        if (indexedImage != null)
-        {
-            image = new byte[height][width];
-        
-            for (int i=0; i&lt;height; i++)
-            {
-                for (int j=0; j&lt;width; j++)
-                    image[i][j] = indexedImage[i][j];            
-            }
-        }
-        return image;
-    }
-    /**
-     * Returns a copy of the image data decoded from a true colour file. A three
-     * dimensional array is returned with four bytes for each pixel in the image,
-     * byte[height][width][4] - one byte for the red [0], green [1], blue [2] and
-     * alpha [3] channels.
-     * 
-     * If the image format is JPEG or an indexed image (IDX8, IDXA) then the image
-     * data returned is null.
-     *
-     * @return an array of bytes containing the colour channels for each pixel in
-     * the image.
-     */
-    public byte[][][] getColorImage()
-    {
-        byte[][][] image = null;
-        
-        if (colorImage != null)
-        {
-            image = new byte[height][width][4];
-
-            for (int h=0; h&lt;height; h++)
-            {
-                for (int w=0; w&lt;width; w++)
-                {
-                    image[h][w][0] = colorImage[h][w][0];    
-                    image[h][w][1] = colorImage[h][w][1];    
-                    image[h][w][2] = colorImage[h][w][2];    
-                    image[h][w][3] = colorImage[h][w][3];    
-                }
-            }
-        }
-        return image;
-    }
-    /**
-     * Returns a copy of the encoded data decoded from a JPEG image file.
-     * 
-     * If the image format is an indexed or true colour image (IDX8, IDXA, RGB5, 
-     * RGB8, RGBA) then the indexed image returned is null.
-     *
-     * @return an array of bytes containing the JPEG encoded image.
-     */
-    public byte[] getJPEGImage()
-    {
-        byte[] image = null;
-        
-        if (jpegImage != null)
-        {
-            image = new byte[jpegImage.length];
-        
-            System.arraycopy(jpegImage, 0, image, 0, jpegImage.length);
-        }
-        return image;
-    }
-    
-    /**
-     * Return the image as an array of FSImageBlock objects that can be used
-     * when creating ScreenVideo streams.
-     * 
-     * The image is divided by tiling blocks of the specified width and height 
-     * across the image. For blocks at the right and bottom edges the size of 
-     * the block may be reduced so that it fits the image exactly. In other 
-     * words the blocks are not padded with extra pixel information.
-     * 
-     * @param blockWidth the width of a block in pixels.
-     * @param blockHeight the height of a block in pixels
-     * @return an array of FMImageBlock objects.
-     */   
-	public ArrayList getImageAsBlocks(int blockWidth, int blockHeight)
-	{
-        int row = 0;
-        int col = 0;
-        int index = 0;
-
-        byte[] formattedImage = new byte[width*height*3];
-        
-        switch (format)
-        {
-            case IDX8:
-            case IDXA: 
-                for (row=height-1; row&gt;=0; row--)
-                {
-                    for (col=0; col&lt;width; col++) 
-                    {                  	
-                        formattedImage[index++] = colourTable[indexedImage[row][col]][2];
-                        formattedImage[index++] = colourTable[indexedImage[row][col]][1];
-                        formattedImage[index++] = colourTable[indexedImage[row][col]][0];                    	
-                    }
-                }
-                break;
-            case RGB5: 
-            case RGB8: 
-            case RGBA: 
-                for (row=height-1; row&gt;=0; row--)
-                {
-                    for (col=0; col&lt;width; col++)
-                    {
-                        formattedImage[index++] = colorImage[row][col][2];
-                        formattedImage[index++] = colorImage[row][col][1];
-                        formattedImage[index++] = colorImage[row][col][0];
-                    }
-                }
-                break;
-        }
-
-		int columns = (width+blockWidth-1)/blockWidth;
-		int rows = (height+blockHeight-1)/blockHeight;
-		
-		ArrayList blocks = new ArrayList(rows*columns);
-		byte[] blockData = new byte[blockHeight*blockWidth*3];
-		
-		for (int i=0; i&lt;rows; i++)
-		{
-			for (int j=0; j&lt;columns; j++)
-			{
-				int xOffset = j*blockWidth;
-				int yOffset = i*blockHeight;
-				
-				int xSpan = (width-xOffset &gt; blockWidth) ? blockWidth : width-xOffset;
-				int ySpan = (height-yOffset &gt; blockHeight) ? blockHeight : height-yOffset;
-				int offset = 0;
-				
-				int idx;
-				
-				for (int k=0; k&lt;ySpan; k++) 
-				{
-					for (int l=0; l&lt;xSpan; l++, offset+=3) 
-					{
-						idx = (yOffset+k)*(width*3)+(xOffset+l)*3;
-						
-						blockData[offset] = formattedImage[idx];					
-						blockData[offset+1] = formattedImage[idx+1];					
-						blockData[offset+2] = formattedImage[idx+2];					
-					}
-				}
-				
-				blocks.add(new FSImageBlock(xSpan, ySpan, zip(blockData, offset)));
-			}
-		}
-		return blocks;
-	}
-	
-	private static byte[] zip(byte[] image, int length)
-	{
-		Deflater deflater = new Deflater();
-		deflater.setInput(image, 0, length);
-		deflater.finish();
-
-		byte[] compressedData = new byte[image.length];
-		int bytesCompressed = deflater.deflate(compressedData);
-
-		byte[] newData = new byte[bytesCompressed];
-
-		for (int i = 0; i &lt; bytesCompressed; i++)
-			newData[i] = compressedData[i];
-
-		return newData;
-	}
-    
-    /**
-     * Sets the image data for an indexed image.
-     * 
-     * @param encoding the format for the encoded image, either IDX8, or IDXA.
-     * @param imageWidth the width of the image in pixels.
-     * @param imageHeight the height of the image in pixels.
-     * @param table a two-dimensional array containing four bytes for each colour, [n][4]. For each 
-     * entry [n][3] contains alpha, [n][2] red, [n][1] green and [n][0] blue.
-     * @param image a two-dimensional array of bytes, [imageHeight][imageWidth] containing
-     * the index into the colour table for each pixel in the image.
-     */
-    public void setIndexedImage(int encoding, int imageWidth, int imageHeight, byte[][] table, byte[][] image)
-    {
-        if (encoding != IDX8 &amp;&amp; encoding != IDXA)
-            throw new IllegalArgumentException(&quot;Indexed images must have a format of IDX8 or IDXA&quot;);
-            
-        format = encoding;
-        width = imageWidth;
-        height = imageHeight;
-        
-        colourTable = new byte[table.length][4];
-
-        for (int i=0; i&lt;table.length; i++)
-        {
-            for (int j=0; j&lt;4; j++)
-                colourTable[i][j] = table[i][j];    
-        }
-
-        indexedImage = new byte[height][width];
-
-        for (int h=0; h&lt;height; h++)
-        {
-            for (int w=0; w&lt;width; w++)
-                indexedImage[h][w] = image[h][w];    
-        }
-    }
-
-    /**
-     * Sets the image data for a true colour image.
-     * 
-     * @param encoding the format for the encoded image, either RGB5, RGB8 or RGBA.
-     * @param imageWidth the width of the image in pixels.
-     * @param imageHeight the height of the image in pixels.
-     * @param image a three-dimensional array of bytes, [imageHeight][imageWidth][4] containing
-     * the colours for each pixel in the image. Four bytes are used to specify the colour. The
-     * order of the colour information from the most significant [3] to the least [0] is alpha, red, 
-     * green and blue.   
-     */
-    public void setColorImage(int encoding, int imageWidth, int imageHeight, byte[][][] image)
-    {
-        if (encoding != RGB5 &amp;&amp; encoding != RGB8 &amp;&amp; encoding != RGBA)
-            throw new IllegalArgumentException(&quot;True colour images must has a format of RGB5, RGB8 or RGBA&quot;);
-            
-        format = encoding;
-        width = imageWidth;
-        height = imageHeight;
-        
-        colorImage = new byte[height][width][4];
-
-        for (int h=0; h&lt;height; h++)
-        {
-            for (int w=0; w&lt;width; w++)
-            {
-                colorImage[h][w][0] = image[h][w][0];    
-                colorImage[h][w][1] = image[h][w][1];    
-                colorImage[h][w][2] = image[h][w][2];    
-                colorImage[h][w][3] = image[h][w][3];    
-            }
-        }
-    }
-
-    /**
-     * Sets the image data for a JPEG encoded image.
-     * 
-     * @param imageWidth the width of the image in pixels.
-     * @param imageHeight the height of the image in pixels.
-     * @param image an array of bytes containing the JPEG encoded image.   
-     */
-    public void setJPEGImage(int imageWidth, int imageHeight, byte[] image)
-    {
-        format = JPEG;
-        width = imageWidth;
-        height = imageHeight;
-        
-        jpegImage = new byte[image.length];
-        
-        System.arraycopy(image, 0, jpegImage, 0, image.length);
-    }
-
-    /**
-     * Generates an object used to define an image in a Flash file. The class of the object returned is 
-     * determined by the format of the image data:
-     *
-     * &lt;table&gt;
-     * &lt;tr&gt;&lt;th&gt;Class&lt;/th&gt;&lt;th&gt;Generated when...&lt;/th&gt;&lt;/tr&gt;
-     *
-     * &lt;tr&gt;
-     * &lt;td&gt;FSDefineJPEGImage2&lt;/td&gt;
-     * &lt;td&gt;The image format is JPEG and the level of transparency is not defined.&lt;/td&gt;
-     * &lt;/tr&gt;
-     *
-     * &lt;tr&gt;
-     * &lt;td&gt;FSDefineImage&lt;/td&gt;
-     * &lt;td&gt;The image format is IDX8, RGB5 or RGB8.&lt;/td&gt;
-     * &lt;/tr&gt;
-     *
-     * &lt;tr&gt;
-     * &lt;td&gt;FSDefineImage2&lt;/td&gt;
-     * &lt;td&gt;The image format is IDXA, RGBA.&lt;/td&gt;
-     * &lt;/tr&gt;
-     *
-     * &lt;/table&gt;
-     *
-     * @param identifier an unique identifier that is used to reference the image definition in a Flash movie.
-     */
-    public FSDefineObject defineImage(int identifier)
-    {
-        FSDefineObject object = null;
-        
-        switch (format)
-        {
-            case JPEG: object = new FSDefineJPEGImage2(identifier, jpegImage); break;
-            case IDX8: object = new FSDefineImage(identifier, width, height, colourTable.length, zip(getImage(), colourTable, false)); break;
-            case IDXA: object = new FSDefineImage2(identifier, width, height, colourTable.length, zip(getImage(), colourTable, true)); break;
-            case RGB5: object = new FSDefineImage(identifier, width, height, zip(getImage()), 16); break;
-            case RGB8: object = new FSDefineImage(identifier, width, height, zip(getImage()), 24); break;
-            case RGBA: object = new FSDefineImage2(identifier, width, height, zip(getImage())); break;
-        }
-        return object;
-    }
-
-    byte[] getImage()
-    {
-        int row = 0;
-        int col = 0;
-        int index = 0;
-        int scanLength = 0;
-        byte[] formattedImage = null;
-        
-        switch (format)
-        {
-            case IDX8:
-            case IDXA: 
-                scanLength = (width + 3) &amp; ~3;
-                formattedImage = new byte[scanLength*height];
-                for (row=0; row&lt;height; row++)
-                {
-                    for (col=0; col&lt;width; col++)
-                        formattedImage[index++] = indexedImage[row][col];
-                    
-                    for (; col&lt;scanLength; col++)
-                        formattedImage[index++] = 0;
-                }
-                break;
-            case RGB5: 
-                scanLength = width + (width &amp; 1);
-                formattedImage = new byte[scanLength*height*2];
-                for (row=0; row&lt;height; row++)
-                {
-                    for (col=0; col&lt;width; col++)
-                    {
-                        int red = (colorImage[row][col][0] &amp; 0xF8) &lt;&lt; 7;
-                        int green = (colorImage[row][col][1] &amp; 0xF8) &lt;&lt; 2;
-                        int blue = (colorImage[row][col][2] &amp; 0xF8) &gt;&gt; 3;
-                        int colour = (red | green | blue) &amp; 0x7FFF;
-                        
-                        formattedImage[index++] = (byte) (colour &gt;&gt; 8);
-                        formattedImage[index++] = (byte) colour;
-                    }
-
-                    for (; col&lt;scanLength; col++)
-                    {
-                        formattedImage[index++] = 0;
-                        formattedImage[index++] = 0;
-                    }
-                }
-                break;
-            case RGB8: 
-                formattedImage = new byte[width*height*4];
-                for (row=0; row&lt;height; row++)
-                {
-                    for (col=0; col&lt;width; col++)
-                    {
-                        formattedImage[index++] = (byte)0xFF;
-                        formattedImage[index++] = colorImage[row][col][0];
-                        formattedImage[index++] = colorImage[row][col][1];
-                        formattedImage[index++] = colorImage[row][col][2];
-                    }
-                }
-                break;
-            case RGBA: 
-                formattedImage = new byte[width*height*4];
-                for (row=0; row&lt;height; row++)
-                {
-                    for (col=0; col&lt;width; col++)
-                    {
-                        int alpha = colorImage[row][col][3] &amp; 0xFF;
-                        int red = ((colorImage[row][col][0] &amp; 0xFF) * alpha) / 255;
-                        int green = ((colorImage[row][col][1] &amp; 0xFF) * alpha) / 255;
-                        int blue = ((colorImage[row][col][2] &amp; 0xFf) * alpha) / 255;
-                            
-                        formattedImage[index++] = (byte)alpha;
-                        formattedImage[index++] = (byte)red;
-                        formattedImage[index++] = (byte)green;
-                        formattedImage[index++] = (byte)blue;
-                    }
-                }
-                break;
-        }
-        return formattedImage;
-    }
-    
-    /**
-     * Generates the shape definition object that is required to display an image in a Flash movie.
-     * The shape is generated with a single fill style (FSBitmapFill object). The origin of the shape
-     * is specified relative to the top left corner of the image.
-     *
-     * The borderStyle argument specifies a border that will be drawn around the image. The style
-     * may be set to null is no border is drawn.
-     * 
-     * @param shapeIdentifier an unique identifier that is used to reference the shape definition in a  
-     * Flash movie.
-     *
-     * @param imageIdentifier the unique identifier of the image generated using the defineImage() method.
-     * 
-     * @param xOrigin the offset in pixels along the x-axis, relative to the top left corner of 
-     * the image, where the origin (0,0) of the shape will be located.
-     * 
-     * @param yOrigin the offset in pixels along the y-axis, relative to the top left corner of 
-     * the image, where the origin (0,0) of the shape will be located.
-     *
-     * @param borderStyle the style drawn around the border of the image. May be null if no 
-     * border is drawn.
-     */
-    public FSDefineShape3 defineEnclosingShape(int shapeIdentifier, int imageIdentifier, int xOrigin, int yOrigin, FSLineStyle borderStyle)
-    {
-        int lineWidth = 0;
-        
-        if (borderStyle != null)
-            lineWidth = borderStyle.getWidth() / 2;
-        
-        FSBounds bounds = new FSBounds(-xOrigin*20-lineWidth, -yOrigin*20-lineWidth, 
-            (width-xOrigin)*20+lineWidth, (height-yOrigin)*20+lineWidth);
-
-        FSShape shape = new FSShape();
-    
-        shape.add(new FSShapeStyle((borderStyle != null) ? 1 : 0, 1, 0, -xOrigin*20, -yOrigin*20));
-        shape.add(new FSLine(width*20, 0));
-        shape.add(new FSLine(0, height*20));
-        shape.add(new FSLine(-width*20, 0));
-        shape.add(new FSLine(0, -height*20));
-        
-        FSDefineShape3 definition = new FSDefineShape3(shapeIdentifier, bounds, new ArrayList(), new ArrayList(), shape);
-        FSCoordTransform transform = new FSCoordTransform(-xOrigin*20, -yOrigin*20, 20.0, 20.0);
-    
-        if (borderStyle != null)
-            definition.add(borderStyle);
-        
-        definition.add(new FSBitmapFill(FSFillStyle.Clipped, imageIdentifier, transform));
-
-        return definition;
-    }
-    
-    private boolean jpegInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, jpegImage);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
-
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readByte();
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
-    
-    private void decodeJPEG(byte[] bytes) throws DataFormatException
-    {
-        format = JPEG;
-        jpegImage = bytes;
-
-        if (jpegInfo() == false)
-            throw new DataFormatException();
-    }
-
-    private void decodeBMP(byte[] bytes) throws DataFormatException
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
-        
-        for (int i=0; i&lt;2; i++)
-        {
-            if (coder.readByte() != bmpSignature[i])
-                throw new DataFormatException(&quot;Not a valid BMP file&quot;);
-        }
-
-        coder.readWord(4, false); // fileSize
-        coder.readWord(4, false); // reserved
-        int offset = coder.readWord(4, false);
-        int headerSize = coder.readWord(4, false);
-        
-        int bitsPerPixel = 0;
-        int coloursUsed = 0;
-
-        switch (headerSize)
-        {
-            case 12:
-                width = coder.readWord(2, false);
-                height = coder.readWord(2, false);
-                coder.readWord(2, false); // bitPlanes
-                bitsPerPixel = coder.readWord(2, false);
-                break;
-            case 40:
-                width = coder.readWord(4, false);
-                height = coder.readWord(4, false);
-                coder.readWord(2, false); // bitPlanes
-                bitsPerPixel = coder.readWord(2, false);
-                attributes[COMPRESSION_METHOD] = coder.readWord(4, false);
-                coder.readWord(4, false); //imageSize
-                coder.readWord(4, false); // horizontalResolution
-                coder.readWord(4, false); // verticalResolution
-                coloursUsed = coder.readWord(4, false);
-                coder.readWord(4, false); // importantColours
-                break;
-            default:
-                break;
-        }
-        
-        if (attributes[COMPRESSION_METHOD] == BI_BITFIELDS)
-        {
-            attributes[RED_MASK] = coder.readWord(4, false);
-            attributes[GREEN_MASK] = coder.readWord(4, false);
-            attributes[BLUE_MASK] = coder.readWord(4, false);
-        }
-        
-        switch (bitsPerPixel)
-        {
-            case 1: format = IDX8; attributes[BIT_DEPTH] = 1; attributes[COLOUR_COMPONENTS] = 1; break;
-            case 2: format = IDX8; attributes[BIT_DEPTH] = 2; attributes[COLOUR_COMPONENTS] = 1; break;
-            case 4: format = IDX8; attributes[BIT_DEPTH] = 4; attributes[COLOUR_COMPONENTS] = 1; break;
-            case 8: format = IDX8; attributes[BIT_DEPTH] = 8; attributes[COLOUR_COMPONENTS] = 1; break;
-            case 16: format = RGB5; attributes[BIT_DEPTH] = 5; attributes[COLOUR_COMPONENTS] = 3; break;
-            case 24: format = RGB8; attributes[BIT_DEPTH] = 8; attributes[COLOUR_COMPONENTS] = 3; break;
-            case 32: format = RGBA; attributes[BIT_DEPTH] = 8; attributes[COLOUR_COMPONENTS] = 4; break;
-        }
-        
-        if (format == IDX8) 
-        {
-            coloursUsed = 1 &lt;&lt; bitsPerPixel;
-            colourTable = new byte[coloursUsed][4];
-            indexedImage = new byte[height][width];
-
-            if (headerSize == 12)
-            {
-                for (int i=0; i &lt; coloursUsed; i++) 
-                {
-                    colourTable[i][3] = (byte)0xFF;
-                    colourTable[i][2] = (byte)coder.readByte();
-                    colourTable[i][1] = (byte)coder.readByte();
-                    colourTable[i][0] = (byte)coder.readByte();
-                }
-            }
-            else
-            {
-                for (int i=0; i &lt; coloursUsed; i++)
-                {
-                    colourTable[i][0] = (byte)coder.readByte();
-                    colourTable[i][1] = (byte)coder.readByte();
-                    colourTable[i][2] = (byte)coder.readByte();
-                    colourTable[i][3] = (byte)(coder.readByte() | 0xFF);
-                }
-            }
-                
-            coder.setPointer(offset&lt;&lt;3);
-
-            switch (attributes[COMPRESSION_METHOD])
-            {
-                case BI_RGB:  decodeIDX8(coder); break;
-                case BI_RLE8: decodeRLE8(coder); break;
-                case BI_RLE4: decodeRLE4(coder); break;
-            }
-        }
-        else
-        {
-            colorImage = new byte[height][width][4];
-
-            coder.setPointer(offset&lt;&lt;3);
-
-            switch (format)
-            {
-                case RGB5: decodeRGB5(coder); break;
-                case RGB8: decodeRGB8(coder); break;
-                case RGBA: decodeRGBA(coder); break;
-            }
-        }
-    }
-
-    private void decodeIDX8(FSCoder coder)
-    {
-        int h = 0;
-        int w = 0;
-        int bitsRead = 0;
-        
-        for (h=height-1; h&gt;0; h--)
-        {
-            for (w=0, bitsRead=0; w&lt;width; w++)
-            {
-                indexedImage[h][w] = (byte)coder.readBits(attributes[BIT_DEPTH], false);
-                bitsRead += attributes[BIT_DEPTH];
-            }
-            if (bitsRead % 32 &gt; 0)
-                coder.adjustPointer(32 - (bitsRead % 32));
-        }
-    }
-
-    private void decodeRLE4(FSCoder coder)
-    {
-        int row = height-1;
-        int col = 0;
-        
-        boolean containsMorePixels = true;
-
-        while (containsMorePixels) 
-        {       
-            int count = coder.readByte();
-        
-            if (count == 0)
-            {
-                int code = coder.readByte();
-                
-                switch (code)
-                {
-                    case 0: 
-                        col = 0; 
-                        row--; 
-                        break;
-                    case 1: 
-                        containsMorePixels = false; 
-                        break;
-                    case 2: 
-                        col += coder.readWord(2, false);
-                        row -= coder.readWord(2, false);
-                    default:
-                        for (int i=0; i&lt;code; i+=2)
-                        {
-                            indexedImage[row][col++] = (byte) coder.readBits(4, false);
-                            indexedImage[row][col++] = (byte) coder.readBits(4, false);
-                        }
-                        
-                        if ((code &amp; 2) == 2) coder.readByte();
-                        break;
-                }
-            }
-            else
-            {
-                byte indexA = (byte)coder.readBits(4, false);
-                byte indexB = (byte)coder.readBits(4, false);
-                
-                for (int i=0; i&lt;count &amp;&amp; col &lt; width; i++) 
-                    indexedImage[row][col++] = (i % 2 &gt; 0) ? indexB : indexA;
-            }
-        }
-    }
-    
-    private void decodeRLE8(FSCoder coder)
-    {
-        int row = height-1;
-        int col = 0;
-        
-        boolean containsMorePixels = true;
-
-        while (containsMorePixels) 
-        {       
-            int count = coder.readByte();
-        
-            if (count == 0)
-            {
-                int code = coder.readByte();
-                
-                switch (code)
-                {
-                    case 0: 
-                        col = 0; 
-                        row--; 
-                        break;
-                    case 1: 
-                        containsMorePixels = false; 
-                        break;
-                    case 2: 
-                        col += coder.readWord(2, false);
-                        row -= coder.readWord(2, false);
-                    default:
-                        for (int i=0; i&lt;code; i++)
-                            indexedImage[row][col++] = (byte) coder.readByte();
-                        
-                        if ((code &amp; 1) == 1) coder.readByte();
-                        break;
-                }
-            }
-            else
-            {
-                byte index = (byte)coder.readByte();
-                
-                for (int i=0; i&lt;count; i++) 
-                    indexedImage[row][col++] = index;
-            }
-        }
-    }
-    
-    private void decodeRGB5(FSCoder coder)
-    {
-        int h = 0;
-        int w = 0;
-        int bitsRead = 0;
-        
-        if (attributes[COMPRESSION_METHOD] == BI_RGB)
-        {
-            for (h=height-1; h&gt;0; h--)
-            {
-                for (w=0, bitsRead=0; w&lt;width; w++)
-                {                
-                    int colour = coder.readWord(2, false) &amp; 0xFFFF;
-                    
-                    colorImage[h][w][0] = (byte)((colour &amp; 0x7C00) &gt;&gt; 7);
-                    colorImage[h][w][1] = (byte)((colour &amp; 0x03E0) &gt;&gt; 2);
-                    colorImage[h][w][2] = (byte)((colour &amp; 0x001F) &lt;&lt; 3);
-                    colorImage[h][w][3] = (byte)0xFF;
-
-                    bitsRead += 16;
-                }
-                if (bitsRead % 32 &gt; 0)
-                    coder.adjustPointer(32 - (bitsRead % 32));
-            }
-        }
-        else
-        {
-            for (h=height-1; h&gt;0; h--)
-            {
-                for (w=0, bitsRead=0; w&lt;width; w++)
-                {
-                    int colour = coder.readWord(2, false) &amp; 0xFFFF;
-                    
-                    if (attributes[RED_MASK] == 0x7C00 &amp;&amp; attributes[GREEN_MASK] == 0x03E0 &amp;&amp; attributes[BLUE_MASK] == 0x001F)
-                    {
-                        colorImage[h][w][0] = (byte)((colour &amp; 0x7C00) &gt;&gt; 7);
-                        colorImage[h][w][1] = (byte)((colour &amp; 0x03E0) &gt;&gt; 2);
-                        colorImage[h][w][2] = (byte)((colour &amp; 0x001F) &lt;&lt; 3);
-                        colorImage[h][w][3] = (byte)0xFF;
-                    }
-                    else if (attributes[RED_MASK] == 0xF800 &amp;&amp; attributes[GREEN_MASK] == 0x07E0 &amp;&amp; attributes[BLUE_MASK] == 0x001F)
-                    {
-                        colorImage[h][w][0] = (byte)((colour &amp; 0xF800) &gt;&gt; 8);
-                        colorImage[h][w][1] = (byte)((colour &amp; 0x07E0) &gt;&gt; 3);
-                        colorImage[h][w][2] = (byte)((colour &amp; 0x001F) &lt;&lt; 3);
-                        colorImage[h][w][3] = (byte)0xFF;
-                    }
-                    bitsRead += 16;
-                }
-                if (bitsRead % 32 &gt; 0)
-                    coder.adjustPointer(32 - (bitsRead % 32));
-            }
-        }
-        
-    }
-
-    private void decodeRGB8(FSCoder coder)
-    {
-        int h = 0;
-        int w = 0;
-        int bitsRead = 0;
-        
-        for (h=height-1; h&gt;0; h--)
-        {
-            for (w=0, bitsRead=0; w&lt;width; w++)
-            {
-                colorImage[h][w][0] = (byte)coder.readBits(attributes[BIT_DEPTH], false);
-                colorImage[h][w][1] = (byte)coder.readBits(attributes[BIT_DEPTH], false);
-                colorImage[h][w][2] = (byte)coder.readBits(attributes[BIT_DEPTH], false);
-                colorImage[h][w][3] = (byte)0xFF;
-                
-                bitsRead += 24;
-            }
-            if (bitsRead % 32 &gt; 0)
-                coder.adjustPointer(32 - (bitsRead % 32));
-        }
-    }
-
-    private void decodeRGBA(FSCoder coder)
-    {
-        int h = 0;
-        int w = 0;
-        
-        for (h=height-1; h&gt;0; h--)
-        {
-            for (w=0; w&lt;width; w++)
-            {
-                colorImage[h][w][2] = (byte)coder.readByte();
-                colorImage[h][w][1] = (byte)coder.readByte();
-                colorImage[h][w][0] = (byte)coder.readByte();
-                colorImage[h][w][3] = (byte)coder.readByte();
-                colorImage[h][w][3] = (byte)0xFF;
-            }
-        }
-    }
-
-    private void decodePNG(byte[] bytes) throws DataFormatException
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
-
-        int length = 0;
-        int chunkType = 0;
-        boolean moreChunks = true;
-
-        for (int i=0; i&lt;8; i++)
-        {
-            if (coder.readByte() != pngSignature[i])
-                throw new DataFormatException(&quot;Not a valid PNG file&quot;);
-        }
-        
-        while (moreChunks)
-        {
-            length = coder.readWord(4, false);
-            chunkType = coder.readWord(4, false);
-            
-            int current = coder.getPointer();
-            int next = current + ((length+4) &lt;&lt; 3);
-            
-            switch (chunkType)
-            {
-                case IHDR: decodeIHDR(coder, length); break;
-                case PLTE: decodePLTE(coder, length); break;
-                case tRNS: decodeTRNS(coder, length); break;
-                case IDAT: decodeIDAT(coder, length); break;
-                case IEND: moreChunks = false; coder.adjustPointer(32); break;
-                default:
-                    coder.adjustPointer((length+4) &lt;&lt; 3);
-                    break;
-            }         
-            length += 4; // include CRC at end of chunk
-/*
-            int bytesRead = (coder.getPointer() - current) &gt;&gt; 3;
-            
-            byte[] chars = new byte[4];
-            
-            chars[3] = (byte)chunkType;
-            chars[2] = (byte)(chunkType &gt;&gt; 8);
-            chars[1] = (byte)(chunkType &gt;&gt; 16);
-            chars[0] = (byte)(chunkType &gt;&gt; 24);
-            
-            String chunk = new String(chars);
-            
-            if (bytesRead &lt; length)
-                System.err.println(chunk + &quot; chunk underflowed by &quot; + (length - bytesRead) + &quot; bytes.&quot;);
-            else if (bytesRead &gt; length)
-                System.err.println(chunk + &quot; chunk overflowed by &quot; + (bytesRead - length) + &quot; bytes.&quot;);
-*/
-            coder.setPointer(next);
-            
-            if (coder.eof())
-                moreChunks = false;
-        }    
-        decodeImage();
-    }
-
-    private void decodeIHDR(FSCoder coder, int length)
-    {
-        width = coder.readWord(4, false);
-        height = coder.readWord(4, false);
-        attributes[BIT_DEPTH] = coder.readByte();
-        attributes[COLOUR_TYPE] = coder.readByte();
-        attributes[COMPRESSION_METHOD] = coder.readByte();
-        attributes[FILTER_METHOD] = coder.readByte();
-        attributes[INTERLACE_METHOD] = coder.readByte();
-        
-        coder.readWord(4, false); // crc
-
-        switch (attributes[COLOUR_TYPE])
-        {
-            case GREYSCALE: format = (attributes[TRANSPARENT_GREY] != -1) ? RGBA : RGB8; attributes[COLOUR_COMPONENTS] = 1; break;
-            case TRUE_COLOUR: format = (attributes[TRANSPARENT_RED] != -1) ? RGBA : RGB8; attributes[COLOUR_COMPONENTS] = 3; break;
-            case INDEXED_COLOUR: format = IDX8; attributes[COLOUR_COMPONENTS] = 1; break;
-            case ALPHA_GREYSCALE: format = RGBA; attributes[COLOUR_COMPONENTS] = 2; break;
-            case ALPHA_TRUECOLOUR: format = RGBA; attributes[COLOUR_COMPONENTS] = 4; break;
-        }  
-    }
-
-    private void decodePLTE(FSCoder coder, int length)
-    {
-        if (attributes[COLOUR_TYPE] == 3)
-        {
-            int paletteSize = length / 3;
-            
-            colourTable = new byte[paletteSize][4];
-            
-            for (int i=0; i&lt;paletteSize; i++)
-            {
-                colourTable[i][3] = (byte)0xFF;
-                colourTable[i][2] = (byte)coder.readByte();
-                colourTable[i][1] = (byte)coder.readByte();
-                colourTable[i][0] = (byte)coder.readByte();
-            }
-        }
-        else
-        {
-            coder.adjustPointer(length &lt;&lt; 3);
-        }        
-        coder.readWord(4, false); // crc
-    }
-
-    private void decodeTRNS(FSCoder coder, int length)
-    {
-        switch(attributes[COLOUR_TYPE])
-        {
-            case GREYSCALE:
-                attributes[TRANSPARENT_GREY] = coder.readWord(2, false);
-                break;
-            case TRUE_COLOUR:
-                attributes[TRANSPARENT_RED] = coder.readWord(2, false);
-                attributes[TRANSPARENT_GREEN] = coder.readWord(2, false);
-                attributes[TRANSPARENT_BLUE] = coder.readWord(2, false);
-                break;
-            case INDEXED_COLOUR:
-                format = IDXA;
-                for (int i=0; i&lt;length; i++) 
-                {
-                    colourTable[i][3] = (byte)coder.readByte();
-
-                    if (colourTable[i][3] == 0) {
-                        colourTable[i][0] = 0;
-                        colourTable[i][1] = 0;
-                        colourTable[i][2] = 0;
-                    }
-                }
-                break;
-            default:
-                break;
-        }
-        coder.readWord(4, false); // crc
-    }
-
-    private void decodeIDAT(FSCoder coder, int length)
-    {
-        int currentLength = chunkData.length;
-        int newLength = currentLength + length;
-        
-        byte[] data = new byte[newLength];
-        
-        System.arraycopy(chunkData, 0, data, 0, currentLength);
-
-        for (int i=currentLength; i&lt;newLength; i++)
-            data[i] = (byte)coder.readByte();
-            
-        chunkData = data;
-        
-        coder.readWord(4, false); // crc
-    }
-
-    private void decodeImage() throws DataFormatException
-    {
-        if (format == RGB8 &amp;&amp; attributes[BIT_DEPTH] &lt;= 5)
-            format = RGB5;
-
-        if (format == RGB5 || format == RGB8 || format == RGBA)
-            colorImage = new byte[height][width][4];
-            
-        if (format == IDX8 || format == IDXA)
-            indexedImage = new byte[height][width];
-            
-        byte[] encodedImage = unzip(chunkData);
-        
-        int bitsPerPixel = attributes[BIT_DEPTH]*attributes[COLOUR_COMPONENTS];
-        int bitsPerRow = width * bitsPerPixel;
-        int rowWidth = (bitsPerRow % 8 &gt; 0) ? (bitsPerRow/8)+1 : (bitsPerRow/8);
-        int bytesPerPixel = (bitsPerPixel&lt;8) ? 1 : bitsPerPixel/8;
-        
-        byte[] current = new byte[rowWidth];
-        byte[] previous = new byte[rowWidth];
-        
-        for (int i=0; i&lt;rowWidth; i++)
-            previous[i] = (byte)0;
-            
-        int rowStart = 0;
-        int rowInc = 0;
-        int colStart = 0;
-        int colInc = 0;
-        
-        int imageIndex = 0;
-        int pixelCount = 0;
-        
-        int row = 0;
-        int col = 0;
-        int filter = 0;
-        
-        int scanBits = 0;
-        int scanLength = 0;
-        
-        int numberOfPasses = (attributes[INTERLACE_METHOD] == 1) ? 7 : 1;
-
-        int xc = 0;
-        int xp = 0;
-
-        for (int pass=0; pass&lt;numberOfPasses; pass++)
-        {
-            rowStart = (attributes[INTERLACE_METHOD] == 1) ? startRow[pass] : 0;
-            rowInc = (attributes[INTERLACE_METHOD] == 1) ? rowIncrement[pass] : 1;
-            
-            colStart = (attributes[INTERLACE_METHOD] == 1) ? startColumn[pass] : 0;
-            colInc = (attributes[INTERLACE_METHOD] == 1) ? columnIncrement[pass] : 1;
-            
-            for (row=rowStart; row&lt;height &amp;&amp; imageIndex&lt;encodedImage.length; row+=rowInc)
-            {
-                for (col=colStart, pixelCount=0, scanBits=0; col&lt;width; pixelCount++, col += colInc, scanBits+=bitsPerPixel);
-
-                scanLength = (scanBits%8 &gt; 0) ? (scanBits/8)+1 : (scanBits/8);
-
-                filter = encodedImage[imageIndex++];
-                              
-                for (int i=0; i&lt;scanLength; i++, imageIndex++)
-                    current[i] = (imageIndex &lt; encodedImage.length) ? encodedImage[imageIndex] : previous[i];
-
-                switch (filter) 
-                {
-                    case NO_FILTER:
-                        break;
-                    case SUB_FILTER:
-                        for (xc = bytesPerPixel, xp = 0; xc &lt; scanLength; xc++, xp++)
-                            current[xc] = (byte)(current[xc] + current[xp]);
-                        break;
-                    case UP_FILTER:
-                        for (xc = 0; xc &lt; scanLength; xc++)
-                            current[xc] = (byte)(current[xc] + previous[xc]);
-                        break;
-                    case AVG_FILTER:
-                        for (xc = 0; xc &lt; bytesPerPixel; xc++)
-                            current[xc] = (byte)(current[xc] + (0 + (0xFF &amp; previous[xc])) / 2);
-                        
-                        for (xc = bytesPerPixel, xp = 0; xc &lt; scanLength; xc++, xp++)
-                            current[xc] = (byte)(current[xc] + ((0xFF &amp; current[xp]) + (0xFF &amp; previous[xc])) / 2);
-                        break;
-                    case PAETH_FILTER:
-                        for (xc = 0; xc &lt; bytesPerPixel; xc++)
-                            current[xc] = (byte)(current[xc] + Paeth((byte)0, previous[xc], (byte)0));
-                        
-                        for (xc = bytesPerPixel, xp = 0; xc &lt; scanLength; xc++, xp++)
-                            current[xc] = (byte)(current[xc] + Paeth(current[xp], previous[xc], previous[xp]));
-                        break;
-                }
-        
-                System.arraycopy(current, 0, previous, 0, scanLength);
-                        
-                FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, current);
-                
-                for (col=colStart; col&lt;width; col+=colInc)
-                {
-                    switch (attributes[COLOUR_TYPE])
-                    {
-                        case GREYSCALE: decodeGreyscale(coder, row, col); break;
-                        case TRUE_COLOUR: decodeTrueColour(coder, row, col); break;
-                        case INDEXED_COLOUR: decodeIndexedColour(coder, row, col); break;
-                        case ALPHA_GREYSCALE: decodeAlphaGreyscale(coder, row, col); break;
-                        case ALPHA_TRUECOLOUR: decodeAlphaTrueColour(coder, row, col); break;
-                    }        
-                }
-            }
-        }
-    }
-
-    private int Paeth(byte L, byte u, byte nw)
-    {
-        int a = 0xFF &amp; L;
-        int b = 0xFF &amp; u; 
-        int c = 0xFF &amp; nw; 
-        int p = a + b - c;
-        int pa = p - a; if (pa &lt; 0) pa = -pa;
-        int pb = p - b; if (pb &lt; 0) pb = -pb; 
-        int pc = p - c; if (pc &lt; 0) pc = -pc; 
-        if (pa &lt;= pb &amp;&amp; pa &lt;= pc) return a;
-        if (pb &lt;= pc) return b;
-        return c;
-    }
-
-    private void decodeGreyscale(FSCoder coder, int row, int col)
-    {
-        int pixel = 0;
-        byte colour = 0;
-        
-        switch (attributes[BIT_DEPTH])
-        {
-            case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; break;
-            case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; break;
-            case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; break;
-            case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
-            case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
-        }                    
-
-        colorImage[row][col][0] = colour;
-        colorImage[row][col][1] = colour;
-        colorImage[row][col][2] = colour;
-        colorImage[row][col][3] = (byte)attributes[TRANSPARENT_GREY];
-    }
-    
-    private void decodeTrueColour(FSCoder coder, int row, int col)
-    {
-        int pixel = 0;
-        byte colour = 0;
-        
-        for (int i=0; i&lt;attributes[COLOUR_COMPONENTS]; i++)
-        {
-            switch (attributes[BIT_DEPTH])
-            {
-                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
-                case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
-            }                    
-            colorImage[row][col][i] = colour;
-        }
-        colorImage[row][col][3] = (byte)attributes[TRANSPARENT_RED];
-    }
-    
-    private void decodeIndexedColour(FSCoder coder, int row, int col)
-    {
-        int index = 0;
-        
-        switch (attributes[BIT_DEPTH])
-        {
-            case 1:  index = coder.readBits(1, false); break;
-            case 2:  index = coder.readBits(2, false); break;
-            case 4:  index = coder.readBits(4, false); break;
-            case 8:  index = coder.readByte(); break;
-            case 16: index = coder.readWord(2, false); break;
-        }                    
-        indexedImage[row][col] = (byte)index;
-    }
-    
-    private void decodeAlphaGreyscale(FSCoder coder, int row, int col)
-    {
-        int pixel = 0;
-        byte colour = 0;
-        int alpha = 0;
-        
-        switch (attributes[BIT_DEPTH])
-        {
-            case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; alpha = coder.readBits(1, false); break;
-            case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; alpha = coder.readBits(2, false); break;
-            case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; alpha = coder.readBits(4, false); break;
-            case 8:  pixel = coder.readByte(); colour = (byte) pixel; alpha = coder.readByte(); break;
-            case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); alpha = coder.readWord(2, false) &gt;&gt; 8; break;
-        }                    
-
-        colorImage[row][col][0] = colour;
-        colorImage[row][col][1] = colour;
-        colorImage[row][col][2] = colour;
-        colorImage[row][col][3] = (byte) alpha;
-    }
-    
-    private void decodeAlphaTrueColour(FSCoder coder, int row, int col)
-    {
-        int pixel = 0;
-        byte colour = 0;
-        
-        for (int i=0; i&lt;attributes[COLOUR_COMPONENTS]; i++)
-        {
-            switch (attributes[BIT_DEPTH])
-            {
-                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
-                case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
-            }                    
-            colorImage[row][col][i] = colour;
-        }
-    }
-    
-    private byte[] dataFromFile(String filename) throws FileNotFoundException, IOException
-    {
-        File aFile = new File(filename);
-        FileInputStream imageContents = null;
-        
-        byte[] bytes = new byte[(int)aFile.length()];
-        
-        imageContents = new FileInputStream(aFile);            
-        imageContents.read(bytes);
-        imageContents.close();
-
-        return bytes;
-    }
-    
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*8];
-        int count = 0;
-        
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
-        
-        byte[] uncompressedData = new byte[count];
-        
-        System.arraycopy(data, 0, uncompressedData, 0, count);
-
-        return uncompressedData;
-    }
-    
-    private byte[] zip(byte[] image, byte[][] table, boolean hasAlpha)
-    {
-        int bytesPerColor = hasAlpha ? 4 : 3;
-        
-        byte[] combinedData = new byte[table.length*bytesPerColor+image.length];
-        int index = 0;
-        
-        /*
-         * Add colour table to start of combined data
-         */
-        for (int i=0; i&lt;table.length; i++)
-        {
-            combinedData[index++] = table[i][2]; // R
-            combinedData[index++] = table[i][1]; // G
-            combinedData[index++] = table[i][0]; // B
-            
-            if (hasAlpha)
-                combinedData[index++] = table[i][3]; // A
-        }
-        
-        /*
-         * Now add image to combined data
-         */
-        for (int i=0; i&lt;image.length; i++)
-            combinedData[index++] = image[i];
-
-        return zip(combinedData);
-    }
-
-    private byte[] zip(byte[] image)
-    {
-        Deflater deflater = new Deflater();
-        deflater.setInput(image);
-        deflater.finish();
-        
-        byte[] compressedData = new byte[image.length*2];
-        int bytesCompressed = deflater.deflate(compressedData);
-
-        byte[] newData = new byte[bytesCompressed];
-        
-        for (int i=0; i&lt;bytesCompressed; i++)
-            newData[i] = compressedData[i];
-            
-        return newData;
-    }
-
-}

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -1,1129 +0,0 @@
-/*
- *  FSShapeConstructor.java
- *  Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform.util;
-
-import com.flagstone.transform.*;
-import java.util.*;
-
-
-/**
- * The FSShapeConstructor class is used to create shape definitions. Arbitrary paths can be 
- * created using a series of move, line or curve segments. Drawing operations using both
- * absolute coordinates and coordinates relative to the current point (updated after every 
- * operation) are supported. 
- * 
- * For curves both cubic and quadratic curves are supported. Flash only supports quadratic 
- * curves so cubic curves are approximated by a series of line segments using (converting cubic 
- * to quadratic curves is mathematically difficult). The smoothness of cubic curves is 
- * controlled by the flatness attribute which can be used to limit the number of line segments
- * that are drawn.
- * 
- * While drawing the start of the first segment to be drawn is recorded so the path can 
- * easily be closed by drawing a line from the current point to the start of the first 
- * segment drawn. To account for the rounded mitering supported by Flash the path is closed 
- * by re-adding the first segment drawn so the line ends overlap.
- * 
- * As a path is drawn the maximum and minimum x and y coordinates are recorded so that the 
- * bounding rectangle that completely encloses the shape can be defined. This is used when
- * creating shape definitions using the FSDefineShape, FSDefineShape2 or FSDefineShape3 classes.
- * 
- * The FSShapeConstructor class also supports a number of method to create closed paths that
- * represent different geometric shapes. Basic rectangles, ellipses and circles are supported.
- * More complex shapes can be drawn using the polygon() method which uses pairs of points to 
- * specified the vertices of an arbitrary shapes.
- * 
- * When drawing paths whether coordinates are specified in twips or pixels is controlled by 
- * the attributes COORDINATES_ARE_PIXELS. This is independent of the flag of the same name 
- * supported in the Transform SWF frameworks. When true coordinates are specified in pixels,
- * while coordinates are specified in twips when false. 1 pixel == 20 twips. Internally all
- * coordinates are converted to twips to perform the actual drawing.
- * 
- * The styles used to draw the path and fill the area enclosed is specified using the ordinal
- * position of the style object in the arrays of styles maintained by the shape definition
- * object (FSDefineShape, SDefineShape2 or FSDefineShape3) used to construct the final shape. 
- *  
- * &lt;b&gt;Examples&lt;/b&gt;
- *
- * The following code samples illustrate how to use the FSShapeConstructor class create shapes.
- *
- * 1. Defining a rectangle using move and line drawing operations.\n
- * 
- *&lt;pre&gt;
- *    FSShapeConstructor path = new FSShapeConstructor();
- * 
- *    path.COORDINATES_ARE_PIXELS = true;
- * 
- *    int width = 200;
- *    int height = 100;
- *
- *    // Setting the line style before any drawing commands is important
- *    // so the thickness of the line can be taken into account when
- *    // calculating the bounding rectangle which must completely enclose
- *    // the shape so it will be drawn correctly.
- *
- *    path.add(new FSLineStyle(1, FSColorTable.black()));
- *    path.add(new FSSolidFill(FSColorTable.red()));
- *
- *    newPath();                   // start a new path
- *    selectStyle(1, 1);              // select the first line and fill style objects
- *    move(-width/2, -height/2);   // Move to the top left corner
- *    rline(width, 0);             // Draw the sides of the rectangle
- *    rline(0, height);
- *    rline(-width, 0);
- *    rline(0, -height);
- *    closePath();                 // close the path to correctly seal the line ends.
- * 
- *    // Now define the shape.
- * 
- *    FSDefineShape3 rect = path.defineShape(movie.newIdentifier());
- * 
- *&lt;/pre&gt;
- *
- * 2. Defining a rectangle using the path creation method.\n
- * 
- *&lt;pre&gt;
- *    FSShapeConstructor path = new FSShapeConstructor();
- * 
- *    path.COORDINATES_ARE_PIXELS = true;
- *
- *    // Define the origin for the shape so the bottom left corner of the 
- *    // rectangle will appear at the coordinates the shape is place at 
- *    // using the FSPlaceObject or FSPlaceObject2 class.
- * 
- *    int xorigin = 100;
- *    int yorigin = -50;
- * 
- *    int width = 200;
- *    int height = 100;
- *    int cornerRadius = 10
- *
- *    path.add(new FSLineStyle(1, FSColorTable.black()));
- *    path.add(new FSSolidFill(FSColorTable.red()));
- *
- *    // Create a rectangle with rounded corners.
- * 
- *    path.rect(xorign, yorigin, width, height, cornerRadius);
- * 
- *    // Now define the shape.
- * 
- *    FSDefineShape3 rect = path.defineShape(movie.newIdentifier());
- *
- *&lt;/pre&gt;
- *
- */
-public class FSShapeConstructor
-{
-    private double flattenLimit = 0.25;
-   /** 
-     * The COORDINATES_ARE_PIXELS flag controls whether the coordinates passed to methods when creating 
-     * a path of predefined shape are expressed in pixels (true) or twips (false).
-     *
-     * Flash coordinates are specified in twips (1 twip equals 1/1440th of an inch or 1/20th of a point). 
-     * Allowing coordinates to be specified in pixels simplifies the drawing process avoiding the conversion 
-     * to twips by multiplying each value by 20.
-     *
-     * IMPORTANT: The value of this flag is independent of the COORDINATES_ARE_PIXELS flag specified in 
-     * the Transform class of the Transform SWF framework.
-     */
-    public boolean COORDINATES_ARE_PIXELS = false;
-    
-    private double[] Px = new double[4];
-    private double[] Py = new double[4];
-    
-    private boolean pathInProgress = false;
-    
-    private int initialX = 0;
-    private int initialY = 0;
-    
-    private int currentX = 0;
-    private int currentY = 0;
-    
-    private int controlX = 0;
-    private int controlY = 0;
-
-    private int minX = 0;
-    private int minY = 0;
-    private int maxX = 0;
-    private int maxY = 0;
-    
-    private int lineWidth = 0;
-    
-    ArrayList objects = new ArrayList();
-    ArrayList lineStyles = new ArrayList();
-    ArrayList fillStyles = new ArrayList();
-    
-    /**
-     * Creates an FSShapeConstructor object with no path defined.
-     */
-    public FSShapeConstructor()
-    {
-    }
-    
-    /** Sets the line style at the index in the array of line styles.
-
-        @param index the position in the array of line styles.
-        @param aLineStyle and FSLineStyle object.
-        @throws ArrayIndexOutOfBounds if the index &lt; 0 or index &gt; array size.
-        */
-    public void set(int index, FSLineStyle aLineStyle)
-    {
-        lineStyles.set(index, aLineStyle);
-    }
-
-    /** Add a FSLineStyle object to the array of line styles.
-
-        @param aLineStyle and FSLineStyle object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
-
-    /** Sets the fill style at the index in the array of fill styles.
-
-        @param index the position in the array of fill styles.
-        @param aFillStyle an FSFillStyle object.
-        @throws ArrayIndexOutOfBounds if the index &lt; 0 or index &gt; array size.
-        */
-    public void set(int index, FSFillStyle aFillStyle)
-    {
-        fillStyles.set(index, aFillStyle);
-    }
-
-    /** Add the fill style object to the array of fill styles.
-
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
-    
-    /** Gets the array line styles.
-
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() 
-    { 
-        return lineStyles; 
-    }
-
-    /** Sets the line styles.
-
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
-
-    /** Gets the array fill styles.
-
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles()
-    {
-        return fillStyles;
-    }
-
-    /** Sets the fill styles.
-
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
-
-    /**
-     * Selects the style used to draw the outline of the shape from the array of 
-     * line styles.
-     * 
-     * @param index the position of the style used to draw the shape.
-     */
-    public void selectLineStyle(int index)
-    {
-        lineWidth = ((FSLineStyle)lineStyles.get(index)).getWidth();
-
-        objects.add(new FSShapeStyle(index+1, Transform.VALUE_NOT_SET, Transform.VALUE_NOT_SET));
-    }
-    
-    /**
-     * Selects the style used to fill the contents of the shape from the array of 
-     * fill styles.
-     * 
-     * @param index the position of the style used to fill the shape.
-     */
-    public void selectFillStyle(int index)
-    {
-        objects.add(new FSShapeStyle(Transform.VALUE_NOT_SET, index+1, Transform.VALUE_NOT_SET));
-    }
-    
-    /**
-     * Selects the style used to fill overlapping areas of the shape from the 
-     * array of fill styles.
-     * 
-     * @param index the position of the style used to fill overlapping areas.
-     */
-    public void selectAltStyle(int index)
-    {
-        objects.add(new FSShapeStyle(Transform.VALUE_NOT_SET, Transform.VALUE_NOT_SET, index+1));
-    }
-    
-    /**
-     * Selects the styles used to draw the outline and fill the contents of the 
-     * shape from the array of line and fill styles.
-     * 
-     * @param lineIndex the position of the style used to draw the outline of the shape.
-     * @param fillIndex the position of the style used to fill the shape.
-     */
-    public void selectStyle(int lineIndex, int fillIndex)
-    {
-        lineWidth = ((FSLineStyle)lineStyles.get(lineIndex)).getWidth();
-        
-        objects.add(new FSShapeStyle(lineIndex+1, fillIndex+1, Transform.VALUE_NOT_SET));
-    }
-    
-    /**
-     * Selects the styles used to draw the outline and fill the contents of the 
-     * shape, including overlapping area, from the array of line and fill styles.
-     * 
-     * @param lineIndex the position of the style used to draw the outline of the shape.
-     * @param fillIndex the position of the style used to fill the shape.
-     * @param altIndex the position of the style used to fill overlapping areas of the shape.
-     */
-    public void selectStyle(int lineIndex, int fillIndex, int altIndex)
-    {
-        lineWidth = ((FSLineStyle)lineStyles.get(lineIndex)).getWidth();
- 
-        objects.add(new FSShapeStyle(lineIndex+1, fillIndex+1, altIndex+1));
-    }
-    
-    /**
-     * Generates the bounding box that encloses the current path.
-     *
-     * @return an FSBounds object representing the bounding box that encloses the path.
-     */
-    public FSBounds bounds()
-    {
-        return new FSBounds(minX, minY, maxX, maxY);
-    }
-
-    /**
-     * Generates an FSShape object containing the objects used to draw the current path.
-     *
-     * @return an FSShape object contain the FSLine, FSCurve and FSShapeStyle objects used to 
-     * construct the current path.
-     */
-    public FSShape shape()
-    {
-        return new FSShape((ArrayList)objects.clone());
-    }
-
-    /**
-     * Generates a shape containing the current path and styles.
-     *
-     * The shape is constructed with copies of the style arrays and the shape representing the 
-     * path drawn. This allows the number of styles to be changed without affecting previously
-     * created shapes.
-     *
-     * @param identifier an unique identifier for the shape.
-     */
-     public FSDefineShape2 defineShape(int identifier)
-     {
-        return new FSDefineShape2(identifier, bounds(), (ArrayList)fillStyles.clone(), (ArrayList)lineStyles.clone(), new FSShape((ArrayList)objects.clone()));
-     }
-     
-    /**
-     * Generates a transparent shape containing the current path and styles.
-     *
-     * The shape is constructed with copies of the style arrays and the shape representing the 
-     * path drawn. This allows the number of styles to be changed without affecting previously
-     * created shapes.
-     *
-     * @param identifier an unique identifier for the shape.
-     */
-     public FSDefineShape3 defineTransparentShape(int identifier)
-     {
-        return new FSDefineShape3(identifier, bounds(), (ArrayList)fillStyles.clone(), (ArrayList)lineStyles.clone(), new FSShape((ArrayList)objects.clone()));
-     }
-     
-    /**
-     * Creates a new path, discarding any path elements drawn.
-     */
-    public void newPath()
-    {
-        pathInProgress = false;
-        
-        setInitial(0, 0);
-        setCurrent(0, 0);
-        setControl(0, 0);
-        setBounds(0, 0, 0, 0);
-        
-        objects.clear();
-
-        lineWidth = 0;
-    }
-    
-    /**
-     * Closes the current path by drawing a line from the current point to the starting point of the 
-     * path. 
-     */
-    public void closePath()
-    {
-        int dx = initialX - currentX;
-        int dy = initialY - currentY;
-        
-        if (dx != 0 || dy != 0)
-            objects.add(new FSLine(dx, dy));
-            
-        setCurrent(initialX, initialY);
-        pathInProgress = false;
-    }
-    
-    /**
-     * move to the point (x,y).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x the x-coordinate of the point to move to.
-     * @param y the y-coordinate of the point to move to.
-     */
-    public void move(int x, int y)
-    {
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-        
-        objects.add(new FSShapeStyle(x, y));
-
-        setControl((currentX+x)/2, (currentY+y)/2);
-        setCurrent(x, y);
-        setInitial(x, y);
-    }
-    
-    void moveForFont(int x, int y)
-    {
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-        
-        objects.add(new FSShapeStyle(1, -1, 1, x, y));
-
-        setControl((currentX+x)/2, (currentY+y)/2);
-        setCurrent(x, y);
-        setInitial(x, y);
-    }
-  
-    /**
-     * move relative to the current point.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x the distance along the x-axis.
-     * @param y the distance along the y-axis.
-     */
-    public void rmove(int x, int y)
-    {
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-        
-        objects.add(new FSShapeStyle(x+currentX, y+currentY)); 
-
-        setControl(currentX+x/2, currentY+y/2);
-        setCurrent(currentX+x, currentY+y);
-   }
-    
-    /**
-     * draw a line from the current point to the point (x,y).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x the x-coordinate of the end of the line.
-     * @param y the y-coordinate of the end of the line.
-     */
-    public void line(int x, int y)
-    {
-        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX;
-        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY;
-
-        objects.add(new FSLine(x, y));
-        
-        if (pathInProgress == false)
-        {
-            setInitial(currentX, currentY);
-            pathInProgress = true;
-        }
-        setControl(currentX+x/2, currentY+y/2);
-        setCurrent(currentX+x, currentY+y);
-    }
-    
-    /**
-     * draw a line relative to the current point.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x the distance along the x-axis to the end of the line.
-     * @param y the distance along the y-axis to the end of the line.
-     */
-    public void rline(int x, int y)
-    {
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-
-        objects.add(new FSLine(x, y));
-
-        if (pathInProgress == false)
-        {
-            setInitial(currentX, currentY);
-            pathInProgress = true;
-        }
-        setControl(currentX+x/2, currentY+y/2);
-        setCurrent(currentX+x, currentY+y);
-    }
-    
-    /**
-     * draw a quadratic bezier curve from the current point to the point (x,y) with the control 
-     * point (x1, y1).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x1 the x-coordinate of the control point.
-     * @param y1 the y-coordinate of the control point.
-     * @param x the x-coordinate of the end of the curve.
-     * @param y the y-coordinate of the end of the curve.
-     */
-    public void curve(int x1, int y1, int x, int y)
-    {
-        x1 = (COORDINATES_ARE_PIXELS ? x1 * 20 : x1) - currentX;
-        y1 = (COORDINATES_ARE_PIXELS ? y1 * 20 : y1) - currentY;
-        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX - x1;
-        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY - y1;
-
-        objects.add(new FSCurve(x1, y1, x, y));
-
-        if (pathInProgress == false)
-        {
-            setInitial(currentX, currentY);
-            pathInProgress = true;
-        }
-        setControl(currentX+x1, currentY+y1);
-        setCurrent(currentX+x1+x, currentY+y1+y);
-    }
-    
-    /**
-     * draw a quadratic bezier curve relative to the current point to the point.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x1 the distance along the x-axis from the current point to the control point.
-     * @param y1 the distance along the y-axis from the current point to the control point.
-     * @param x the distance along the x-axis from the current point to the end of the curve.
-     * @param y the distance along the y-axis from the current point to the end of the curve.
-     */
-    public void rcurve(int x1, int y1, int x, int y)
-    {
-        x1 = COORDINATES_ARE_PIXELS ? x1 * 20 : x1;
-        y1 = COORDINATES_ARE_PIXELS ? y1 * 20 : y1;
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-
-        objects.add(new FSCurve(x1, y1, x, y));
-
-        if (pathInProgress == false)
-        {
-            setInitial(currentX, currentY);
-            pathInProgress = true;
-        }
- 
-        setControl(currentX+x1, currentY+y1);
-        setCurrent(currentX+x1+x, currentY+y1+y);
-    }
-    
-    /**
-     * draw a cubic bezier curve from the current point to the point (x,y) with the off-curve control 
-     * points (x1, y1) and (x2, y2).
-     * 
-     * IMPORTANT: Converting cubic bezier curves to the quadratic bezier curves supported by Flash is 
-     * mathematically difficult. The cubic curve is approximated by a series of straight line segments. 
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x1 the x-coordinate of the first control point.
-     * @param y1 the y-coordinate of the first control point.
-     * @param x2 the x-coordinate of the second control point.
-     * @param y2 the y-coordinate of the second control point.
-     * @param x the x-coordinate of the end of the curve.
-     * @param y the y-coordinate of the end of the curve.
-     */
-    public void curve(int x1, int y1, int x2, int y2, int x, int y)
-    {
-        Px[0] = currentX;
-        Py[0] = currentY;
-        Px[1] = COORDINATES_ARE_PIXELS ? x1 * 20 : x1;
-        Py[1] = COORDINATES_ARE_PIXELS ? y1 * 20 : y1;
-        Px[2] = COORDINATES_ARE_PIXELS ? x2 * 20 : x2;
-        Py[2] = COORDINATES_ARE_PIXELS ? y2 * 20 : y2;
-        Px[3] = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        Py[3] = COORDINATES_ARE_PIXELS ? y * 20 : y;
-        
-        flatten();
-    }
-    
-    /**
-     * draw a cubic bezier curve relative to the current point.
-     * 
-     * IMPORTANT: Converting cubic bezier curves to the quadratic bezier curves supported by Flash is 
-     * mathematically difficult. The cubic curve is approximated by a series of straight line segments. 
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x1 the distance along the x-axis from the current point to the first control point.
-     * @param y1 the distance along the y-axis from the current point to the first control point.
-     * @param x2 the distance along the x-axis from the current point to the second control point.
-     * @param y2 the distance along the y-axis from the current point to the second control point.
-     * @param x the distance along the x-axis from the current point to the end of the curve.
-     * @param y the distance along the y-axis from the current point to the end of the curve.
-     */
-    public void rcurve(int x1, int y1, int x2, int y2, int x, int y)
-    {
-        Px[0] = currentX;
-        Py[0] = currentY;
-        Px[1] = currentX + (COORDINATES_ARE_PIXELS ? x1 * 20 : x1);
-        Py[1] = currentY + (COORDINATES_ARE_PIXELS ? y1 * 20 : y1);
-        Px[2] = currentX + (COORDINATES_ARE_PIXELS ? x2 * 20 : x2);
-        Py[2] = currentY + (COORDINATES_ARE_PIXELS ? y2 * 20 : y2);
-        Px[3] = currentX + (COORDINATES_ARE_PIXELS ? x * 20 : x);
-        Py[3] = currentY + (COORDINATES_ARE_PIXELS ? y * 20 : y);
-        
-        flatten();
-    }
-    
-    /**
-     * draw a quadratic bezier curve from the current point to the point (x,y) using the control point
-     * for the previously drawn curve.
-     * 
-     * If no curve has been drawn previously then a control point midway along the previous line or 
-     * move is used.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x the x-coordinate of the end of the curve.
-     * @param y the y-coordinate of the end of the curve.
-     */
-    public void reflect(int x, int y)
-    {
-        int x1 = currentX - controlX;
-        int y1 = currentY - controlY;
-        
-        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX;
-        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY;
-
-        objects.add(new FSCurve(x1, y1, x, y));
-
-        if (pathInProgress == false)
-        {
-            setInitial(currentX, currentY);
-            pathInProgress = true;
-        }
- 
-        setControl(x1+currentX, y1+currentY);
-        setCurrent(x+currentX, y+currentY);
-    }
-
-    /**
-     * draw a quadratic bezier curve relative to the current point to the point using the control point
-     * for the previously drawn curve.
-     * 
-     * If no curve has been drawn previously then a control point midway along the previous line or 
-     * move is used.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x the distance along the x-axis from the current point to the end of the curve.
-     * @param y the distance along the y-axis from the current point to the end of the curve.
-     */
-    public void rreflect(int x, int y)
-    {
-        int x1 = currentX - controlX;
-        int y1 = currentY - controlY;
-
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-
-        objects.add(new FSCurve(x1, y1, x, y));
-
-        if (pathInProgress == false)
-        {
-            setInitial(currentX, currentY);
-            pathInProgress = true;
-        }
- 
-        setControl(x1+currentX, y1+currentY);
-        setCurrent(x+currentX, y+currentY);
-    }
-
-    /**
-     * draw a cubic bezier curve from the current point to the point (x,y). The first control point
-     * is the one defined for the previously drawn curve. The second control point is the 
-     * coordinates (x2, y2).
-     * 
-     * If no curve has been drawn previously then a control point midway along the previous line or 
-     * move is used.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x2 the x-coordinate of the control point.
-     * @param y2 the y-coordinate of the control point.
-     * @param x the x-coordinate of the end of the curve.
-     * @param y the y-coordinate of the end of the curve.
-     */
-    public void reflect(int x2, int y2, int x, int y)
-    {
-        int x1 = currentX - controlX;
-        int y1 = currentY - controlY;
-
-        x2 = (COORDINATES_ARE_PIXELS ? x2 * 20 : x2) - currentX;
-        y2 = (COORDINATES_ARE_PIXELS ? y2 * 20 : y2) - currentY;
-
-        x = (COORDINATES_ARE_PIXELS ? x * 20 : x) - currentX;
-        y = (COORDINATES_ARE_PIXELS ? y * 20 : y) - currentY;
-
-        rcurve(x1, y1, x2, y2, x, y);
-    }
-
-    /**
-     * draw a cubic bezier curve relative to the current point. The first control point
-     * is the one defined for the previously drawn curve. The second control point is the 
-     * relative point (x2, y2).
-     * 
-     * If no curve has been drawn previously then a control point midway along the previous line or 
-     * move is used.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param x2 the distance along the x-axis from the current point to the second control point.
-     * @param y2 the distance along the y-axis from the current point to the second control point.
-     * @param x the distance along the x-axis from the current point to the end of the curve.
-     * @param y the distance along the y-axis from the current point to the end of the curve.
-     */
-    public void rreflect(int x2, int y2, int x, int y)
-    {
-        int x1 = currentX - controlX;
-        int y1 = currentY - controlY;
-
-        x2 = COORDINATES_ARE_PIXELS ? x2 * 20 : x2;
-        y2 = COORDINATES_ARE_PIXELS ? y2 * 20 : y2;
-
-        x = COORDINATES_ARE_PIXELS ? x * 20 : x;
-        y = COORDINATES_ARE_PIXELS ? y * 20 : y;
-
-        rcurve(x1, y1, x2, y2, x, y);
-    }
-
-    /**
-     * Creates a closed path in the shape of a rectangle with the specified width and height.
-     * The centre of the rectangle is located at the point (x,y).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * The origin of the shape can be used to control the relative placement of the rectangle 
-     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
-     * FSPlaceObject2 class.
-     * 
-     * @param x the x-coordinate of the centre of the rectangle.
-     * @param y the y-coordinate of the centre of the rectangle.
-     * @param width the width of the rectangle.
-     * @param height the height of the rectangle.
-     */
-    public void rect(int x, int y, int width, int height)
-    {
-        newPath();
-        selectStyle(0, 0);
-        move(x-width/2, y-height/2);
-        rline(width, 0);
-        rline(0, height);
-        rline(-width, 0);
-        rline(0, -height);
-        closePath();
-    }
-
-    /**
-     * Creates a closed path in the shape of a rectangle with the specified width and height.
-     * The centre of the rectangle is located at the point (0,0).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param width the width of the rectangle.
-     * @param height the height of the rectangle.
-     */
-    public void rect(int width, int height)
-    {
-        rect(0, 0, width, height);
-    }
-
-    /**
-     * Creates a closed path in the shape of a rectangle with rounded corners. The shape is drawn
-     * with specified width and height and the radius argument specified the radius of the quarter 
-     * circle used to draw the corners.
-     * 
-     * The centre of the rectangle is located at the point (x,y).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * The origin of the shape can be used to control the relative placement of the rectangle 
-     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
-     * FSPlaceObject2 class.
-     * 
-     * @param x the x-coordinate of the centre of the rectangle.
-     * @param y the y-coordinate of the centre of the rectangle.
-     * @param width the width of the rectangle.
-     * @param height the height of the rectangle.
-     * @param radius the radius of the quarter circle used to draw the corners.
-     */
-    public void rect(int x, int y, int width, int height, int radius)
-    {
-        int shortestSide = (height &lt; width) ? height : width;
-    
-        if (radius &gt; shortestSide/2)
-            radius = shortestSide/2;
-    
-        newPath();
-        selectStyle(0, 0);
-        move(x, y-height/2);
-        rline(width/2-radius, 0);
-        rcurve(radius, 0, 0, radius);
-        rline(0, height - 2*radius);
-        rcurve(0, radius, -radius, 0);
-        rline(-(width-2*radius), 0);
-        rcurve(-radius, 0, 0, -radius);
-        rline(0, -(height-2*radius));
-        rcurve(0, -radius, radius, 0);
-        closePath();
-    }
-
-    /**
-     * Creates a closed path in the shape of a rectangle with rounded corners. The shape is drawn
-     * with specified width and height and the radius argument specified the radius of the quarter 
-     * circle used to draw the corners. The centre of the rectangle is located at the point (0,0).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param width the width of the rectangle.
-     * @param height the height of the rectangle.
-     * @param radius the radius of the quarter circle used to draw the corners.
-     */
-    public void rect(int width, int height, int radius)
-    {
-        rect(0, 0, width, height, radius);
-    }
-
-    /**
-     * Creates a closed path in the shape of an ellipse. The arguments rx and ry specify the radius 
-     * of the ellipse in the x and y directions respectively.
-     * 
-     * The centre of the ellipse is located at the point (x,y).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * The origin of the shape can be used to control the relative placement of the ellipse 
-     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
-     * FSPlaceObject2 class.
-     * 
-     * @param x the x-coordinate of the centre of the ellipse.
-     * @param y the y-coordinate of the centre of the ellipse.
-     * @param rx the radius of the ellipse in the x direction.
-     * @param ry the radius of the ellipse in the y direction.
-     */
-    public void ellipse(int x, int y, int rx, int ry)
-    {
-        boolean wasInPixels = false;
-
-        if (COORDINATES_ARE_PIXELS)
-        {
-            COORDINATES_ARE_PIXELS = false;
-            wasInPixels = true;
-            
-            x *= 20;
-            y *= 20;
-            rx *= 20;
-            ry *= 20;
-        }
-
-        int startX = (int) (0.707 * rx) + x;
-        int startY = (int) (0.707 * ry) + y;
-
-        int ax = (int) (0.293 * rx);
-        int ay = (int) (0.293 * ry);
-        int cx = (int) (0.414 * rx);
-        int cy = (int) (0.414 * ry);
-            
-        newPath();
-        selectStyle(0, 0);
-        move(startX, startY);
-        rcurve(-ax, ay, -cx, 0);
-        rcurve(-cx, 0, -ax, -ay);
-        rcurve(-ax, -ay, 0, -cy);
-        rcurve(0, -cy,  ax, -ay);
-        rcurve(ax, -ay, cx, 0);
-        rcurve(cx, 0,  ax, ay);
-        rcurve(ax, ay, 0, cy);
-        rcurve(0, cy, -ax, ay);
-        closePath();
-        
-        if (wasInPixels)
-        {
-            COORDINATES_ARE_PIXELS = true;
-        }
-    }
-
-    /**
-     * Creates a closed path in the shape of an ellipse. The arguments rx and ry specify the radius 
-     * of the ellipse in the x and y directions respectively.
-     * 
-     * The centre of the ellipse is located at the point (0,0).
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param rx the radius of the ellipse in the x direction.
-     * @param ry the radius of the ellipse in the y direction.
-     */
-    public void ellipse(int rx, int ry)
-    {
-        ellipse(0, 0, rx, ry);
-    }
-
-    /**
-     * Creates a closed path in the shape of a circle. The centre of the circle is located at 
-     * the point (x,y) with radius r.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * The origin of the shape can be used to control the relative placement of the circle 
-     * when it is placed on the Flash Player's display list using either the FSPlaceObject or 
-     * FSPlaceObject2 class.
-     * 
-     * @param x the x-coordinate of the centre of the circle.
-     * @param y the y-coordinate of the centre of the circle.
-     * @param r the radius of the circle.
-     */
-    public void circle(int x, int y, int r)
-    {
-        ellipse(x, y, r, r);
-    }
-
-    /**
-     * Creates a closed path in the shape of a circle. The centre of the circle is located at 
-     * the point (0,0) with radius r.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param r the radius of the circle.
-     */
-    public void circle(int r)
-    {
-        ellipse(0, 0, r, r);
-    }
-
-    /**
-     * Create a closed shape with vertices defines by pairs of coordinates from the array argument.
-     * The first pair of points in the array specifies a move. Line segments a drawn relative to 
-     * the current point which is updated after each segment is drawn.
-     * 
-     * If the number of points is an odd number then the last point will be ignored.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param points and array of coordinate pairs. The first pair of points defines the coordinates
-     * of a move operation, successive pairs define the coordinates for relative lines.
-     */
-    public void rpolygon(int[] points)
-    {
-        int i;
-        int length = points.length;
-        
-        if (length % 2 == 1)
-            length -= 1;
-        
-        rmove(points[0], points[1]);
-
-        for (i=2; i&lt;length; i+=2)
-            rline(points[i], points[i+1]);
-            
-        closePath();
-    }
-    /**
-     * Create a closed shape with vertices defines by pairs of coordinates from the array argument.
-     * The first pair of points in the array specifies a move. Line segments a drawn using 
-     * abolute coordinates. The current point which is updated after each segment is drawn.
-     * 
-     * If the number of points is an odd number then the last point will be ignored.
-     * 
-     * If the COORDINATES_ARE_PIXELS attribute is true then the coordinates are specified in pixels,
-     * otherwise the coordinates are specified in twips.
-     * 
-     * @param points and array of coordinate pairs. The first pair of points defines the coordinates
-     * of a move operation, successive pairs define the coordinates of the lines.
-     */
-    public void polygon(int[] points)
-    {
-        int i;
-        int length = points.length;
-        
-        if (length % 2 == 1)
-            length -= 1;
-        
-        move(points[0], points[1]);
-
-        for (i=2; i&lt;length; i+=2)
-            line(points[i], points[i+1]);
-            
-        closePath();
-    }
-
-    private void setInitial(int x, int y)
-    {
-        initialX = x;
-        initialY = y;
-    }
-    
-    private void setCurrent(int x, int y)
-    {
-        currentX = x;
-        currentY = y;
-        
-        if ((x - lineWidth/2) &lt; minX) minX = x - lineWidth/2;
-        if ((y - lineWidth/2) &lt; minY) minY = y - lineWidth/2;
-        if ((x + lineWidth/2) &gt; maxX) maxX = x + lineWidth/2;
-        if ((y + lineWidth/2) &gt; maxY) maxY = y + lineWidth/2;
-    }
-    
-    private void setControl(int x, int y)
-    {
-        controlX = x;
-        controlY = y;
-
-        if ((x - lineWidth/2) &lt; minX) minX = x - lineWidth/2;
-        if ((y - lineWidth/2) &lt; minY) minY = y - lineWidth/2;
-        if ((x + lineWidth/2) &gt; maxX) maxX = x + lineWidth/2;
-        if ((y + lineWidth/2) &gt; maxY) maxY = y + lineWidth/2;
-    }
-    
-    private void setBounds(int xl, int yl, int xu, int yu)
-    {
-        minX = xl;
-        minY = yl;
-        maxX = xu;
-        maxY = yu;
-    }
-    
-    private void flatten()
-    {
-        double[] Qx = new double[] {0.0, 0.0, 0.0, 0.0};
-        double[] Qy = new double[] {0.0, 0.0, 0.0, 0.0};
-
-        double u;
-        double Ax, Ay, Bx, By;
-
-        for (;;) 
-        {
-            Ax = 2.0 * Px[0] + Px[3] - 3.0 * Px[1];  Ax *= Ax;
-            Bx = 2.0 * Px[3] + Px[0] - 3.0 * Px[2];  Bx *= Bx;
-        
-            if (Ax &lt; Bx) Ax = Bx;
-
-            Ay = 2.0 * Py[0] + Py[3] - 3.0 * Py[1];  Ay *= Ay;
-            By = 2.0 * Py[3] + Py[0] - 3.0 * Py[2];  By*= By;
-        
-            if (Ay &lt; By) Ay = By;
-
-            if ((Ax + Ay) &lt; flattenLimit) 
-            {
-                objects.add(new FSLine((int)(Px[3])-currentX, (int)(Py[3])-currentY));
-                setControl((int)(Px[1]), (int)(Py[1]));
-                setControl((int)(Px[2]), (int)(Py[2]));
-                setCurrent((int)(Px[3]), (int)(Py[3]));
-                break;
-            }
-            else 
-            {
-                Qx[3] = Px[3];
-                u = (Px[1] + Px[2]) / 2;
-                Px[1] = (Px[0] + Px[1]) / 2;
-                Qx[2] = (Px[2] + Px[3]) / 2;
-                Px[2] = (Px[1] + u) / 2;
-                Qx[1] = (u + Qx[2]) / 2;
-                Px[3] = Qx[0] = (Px[2] + Qx[1]) / 2;
-
-                Qy[3] = Py[3];
-                u = (Py[1] + Py[2]) / 2;
-                Py[1] = (Py[0] + Py[1]) / 2;
-                Qy[2] = (Py[2] + Py[3]) / 2;
-                Py[2] = (Py[1] + u) / 2;
-                Qy[1] = (u + Qy[2]) / 2;
-                Py[3] = Qy[0] = (Py[2] + Qy[1]) / 2;
-
-                flatten();
-                  
-                Px[0] = Qx[0];
-                Py[0] = Qy[0];
-                Px[1] = Qx[1];
-                Py[1] = Qy[1];
-                Px[2] = Qx[2];
-                Py[2] = Qy[2];
-                Px[3] = Qx[3];
-                Py[3] = Qy[3];
-                  
-                continue;
-            }
-        }
-    }
-}
-

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -1,717 +0,0 @@
-/*
- *  FSSoundConstructor.java
- *  Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform.util;
-
-import java.io.*;
-import java.util.zip.*;
-import com.flagstone.transform.*;
-
-/** 
- * The FSSoundConstructor class is used to generate the objects used to define and 
- * control the sounds that are played in a Flash movie. The FSSoundConstructor can 
- * be used to generate definitions for:
- *
- * &lt;ul&gt;
- * &lt;li&gt;Event sounds that are played in response to a particular event such as a button 
- * being clicked.&lt;/li&gt;
- * &lt;li&gt;Streaming sound that is played as movie is being displayed.&lt;/li&gt;
- * &lt;/ul&gt;
- *
- * The FSSoundConstructor contains constructors and methods that allow sound data to 
- * be loaded from an external file simplifying the process of adding sound to a movie. 
- * The FSSoundConstructor currently supports uncompressed PCM format (with either 
- * big-endian or little-endian byte ordering) and MP3 format files.
- *
- * Once loaded, the PCM sound data should be compressed to ADPCM format as the relatively 
- * large sizes make PCM coded sounds generally unsuitable for inclusion in a Flash movie. 
- * ADPCM is a compressed format and Flash supports a modified ADPCM algorithm with 
- * compressed samples taking 2, 3, 4 or 5 bits. This results in much smaller file sizes 
- * when a movie is encoded. Code, developed at Centre for Mathematics and Computer Science,
- * Amsterdam, The Netherlands, is available on Flagstone's web site to perform the 
- * ADPCM compression.
- * 
- * For sounds containing more than one channel, the sound levels for each channel are 
- * interleaved for each sample. For example a stereo sound the order of the samples and 
- * channels levels are:
- *
- *&lt;pre&gt;
- * Sample       0          1          2
- *          +---+---+  +---+---+  +---+---+
- *          | 1 | 2 |  | 1 | 2 |  | 1 | 2 | ....
- *          +---+---+  +---+---+  +---+---+
- *&lt;/pre&gt;
- *
- * NOTE: The byte order for the PCM data in WAVE sound files may vary according to the 
- * platform on which the sound file was created. The FSSoundConstructor currently only
- * supports WAVE files with little-endian byte order.
- *
- * &lt;b&gt;Examples&lt;/b&gt;
- *
- * The following code samples illustrate how to use the FSSoundConstructor class to add 
- * sounds to a Flash file.
- *
- * 1. Playing an uncompressed WAVE file.\n
- *
- *&lt;pre&gt;
- * int soundId = movie.newIdentifier();
- *
- * // Generate an FSDefineSound object using the attributes defined in the wave file.
- * // An FSSound object is used to instruct the Flash Player to start playing a sound.
- *
- * FSSoundConstructor soundGenerator = new FSSoundGenerator(&quot;sound.wav&quot;);
- *
- * movie.add(soundGenerator.defineSound(soundId));
- * movie.add(new FSSound(soundId, FSSound.Start));
- *&lt;/pre&gt;
- *
- * 2. Streaming Sounds.\n
- *
- * Larger sound files may be streamed to the Flash Player - splitting the sound data into a 
- * sequence of blocks which is synchronised with the frames as they are displayed. Typically 
- * block of sound data is generated for each frame displayed.
- *
- *&lt;pre&gt;
- * int framesPerSecond = 12;
- *
- * FSSoundConstructor soundGenerator = new FSSoundGenerator(&quot;soundTrack.wav&quot;);
- *   
- * // Calculate the number of decoded sound samples played for each frame
- *
- * int samplesPerBlock = soundGenerator.getSampleRate() / framesPerSecond;
- * int numberOfBlocks = soundGenerator.getSamplesPerChannel() / samplesPerBlock;
- *
- * // An FSSoundStreamHeader2 object defines the attributes of the streaming sound.
- * 
- * movie.add(soundGenerator.streamHeader(samplesPerBlock));
- *
- * // Add a streaming block for each frame so the sound is played as each frame is displayed.
- *
- * for (int i=0; i&lt;numberOfBlocks; i++)
- * {
- *     movie.add(soundGenerator.streamBlock(i, samplesPerBlock));
- *     movie.add(new FSShowFrame());
- * }
- * &lt;/pre&gt;
- *
- */
-public class FSSoundConstructor
-{
-    private static final int[] riffSignature = { 82, 73, 70, 70 };
-    private static final int[] wavSignature = { 87, 65, 86, 69 };
-
-    private static final int FMT = 0x20746d66;
-    private static final int DATA = 0x61746164;
-
-    private static final int MPEG1 = 3;
-    
-    private static final int frameSizeMP3[] = { 576, 576, 576, 1152 };
-    private static final int channelCount[] = { 2, 2, 2, 1 };
-
-    private static final int bitRates[][] =
-    {
-        { -1,  8, 16, 24, 32, 40, 48, 56,  64,  80,  96, 112, 128, 144, 160, -1 }, // MPEG 2.5
-        { -1, -1, -1, -1, -1, -1, -1, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1 }, // Reserved
-        { -1,  8, 16, 24, 32, 40, 48, 56,  64,  80,  96, 112, 128, 144, 160, -1 }, // MPEG 2.0
-        { -1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1 }, // MPEG 1.0
-    };
-
-    private static final int samplingRates[][] =
-    {
-        { 11025, -1, -1, -1 },
-        {    -1, -1, -1, -1 },
-        { 22050, -1, -1, -1 },
-        { 44100, -1, -1, -1 }
-    };
-    
-    private int format = FSSound.PCM;
-    private int numberOfChannels = 0;
-    private int samplesPerChannel = 0;
-    private int sampleRate = 0;
-    private int sampleSize = 0;
-
-    private byte[] sound = null;
-    
-    private int[][] frameTable = null;
-    private int samplesPerFrame = 0;
-
-    /**
-     * Creates a new uninitialized FSSoundConstructor object.  Use setSound to 
-     * provide the content.
-     */
-    public FSSoundConstructor() 
-    {
-    }
-    /** 
-     * Creates a new FSSoundConstructor object initialised with the contents of 
-     * the specified sound file.
-     *
-     * @param fileName the name of the file containing the sound.
-     * 
-     * @throws FileNotFoundException - if the file does not exist, is a 
-     * directory rather than a regular file, or for some other reason cannot be 
-     * opened for reading.
-     * 
-     * @throws IOException - if an I/O error occurs while reading the file.
-     * 
-     * @throws DataFormatException if the file contains a sound format not 
-     * supported by the FSSoundConstructor.
-     */
-    public FSSoundConstructor(String fileName) throws IOException, DataFormatException
-    {
-        setSound(fileName);
-    }
-    /** 
-     * Accessor method returning the format for the encoded sound data.
-     *
-     * @return the format of the encoded sound, either FSSound.NATIVE_PCM (platform
-     * dependent byte-order), FSSound.PCM (PCM little-endian byte-order), FSSound.ADPCM or
-     * FSSound.MP3.
-     */
-    public int getFormat()
-    {
-        return format;
-    }
-
-    /** 
-     * Accessor method returning the number of channels in the sound.
-     * 
-     * @return the number of sound channels, typically this will be 1 (mono) or 2 (stereo).
-     */
-    public int getNumberOfChannels()
-    {
-        return numberOfChannels;
-    }
-
-    /** 
-     * Accessor method returning the number of samples in each channel.
-     *
-     * @return the number of samples in each channel.
-     */
-    public int getSamplesPerChannel()
-    {
-        return samplesPerChannel;
-    }
-
-    /** 
-     * Accessor method returning the rate at which the sound will be played. The playback 
-     * rate should be a value supported by the Flash Player 5512, 11025, 22050 or 44100 
-     * Hertz. Although the sound rate may be changed using the changeSampleRate method 
-     * the FSSoundConstructor class does not support the filtering required to change 
-     * the sample rate from an arbitrary value to one of the rates supported by the Flash 
-     * Player.
-     *
-     * MP3 formatted sounds have playback rates of 11025, 22050 or 44100.
-     *
-     * @return the playback rate for the sound, either 5512, 11025, 22050 or 44100 Hertz.
-     */
-    public int getSampleRate()
-    {
-        return sampleRate;
-    }
-
-    /** 
-     * Accessor method returning the number of bytes for each decoded sound sample.
-     * 
-     * @return the number of bytes in each sample.
-     */
-    public int getSampleSize()
-    {
-        return sampleSize;
-    }
-
-    /** 
-     * Accessor method returning a copy of the encoded sound data.
-     * 
-     * @return encoded sound data.
-     */
-    public byte[] getSound()
-    {
-        byte[] bytes = new byte[sound.length];
-        
-        System.arraycopy(sound, 0, bytes, 0, sound.length);
-
-        return bytes;
-    }
-
-    /** 
-     * Initialises the FSSoundConstructor with the contents of the specified file.
-     * 
-     * @param filename the name of a file containing encoded sound data.
-     * 
-     * @throws FileNotFoundException - if the file does not exist, is a directory 
-     * rather than a regular file, or for some other reason cannot be opened for 
-     * reading.
-     * 
-     * @throws IOException - if an I/O error occurs while reading the file.
-     * 
-     * @throws DataFormatException if the file contains a sound format not 
-     * supported by the FSSoundConstructor.
-     */
-    public void setSound(String filename) throws IOException, DataFormatException
-    {
-        if (filename.toLowerCase().endsWith(&quot;.mp3&quot;))
-            decodeMP3(dataFromFile(filename));
-        else if (filename.toLowerCase().endsWith(&quot;.wav&quot;))
-            decodeWAV(filename);
-    }
-    /** 
-     * Initialises the FSSoundConstructor with the sound data and set of 
-     * parameters. This method can be used to update the sound following 
-     * processing for example to convert a stereo sound to mono to reduce the 
-     * size of the encoded data.
-     * 
-     * @param format the format of the encoded sound either FSSound.PCM, 
-     * FSSound.ADPCM or FSSound.MP3.
-     * 
-     * @param channelCount the number of sound channels, 1 = mono, 2 = stereo.
-     * @param sampleCount the number of samples in each channel.
-     * 
-     * @param sampleRate the rate at which the sound is played in kiloHertz. 
-     * Flash supports 5512, 11025, 22050 or 44100.
-     * 
-     * @param sampleSize the number of bytes for each uncompressed sound sample, 
-     * either 1 or 2.
-     * 
-     * @param bytes an array of sound samples encoding in the specified format.
-     */
-    public void setSound(int format, int channelCount, int sampleCount, int sampleRate, int sampleSize, byte[] bytes)
-    {
-        this.format = format;
-        this.numberOfChannels = channelCount;
-        this.samplesPerChannel = sampleCount;
-        this.sampleRate = sampleRate;
-        this.sampleSize = sampleSize;
-
-        sound = new byte[bytes.length];
-        System.arraycopy(bytes, 0, sound, 0, bytes.length);
-        
-        if (format == FSSound.MP3)
-            initFrameTable(bytes);
-    }
-
-    /** 
-     * Generates an FSDefineSound object from the sound data. The FSDefineSound object is 
-     * created using the encoded sound data so if the sound was decoded in order to change 
-     * the number of channels, sample rate or sample size it must be re-encoded.
-     * 
-     * @param anIdentifier a unique identifier for the FSDefineSound object.
-     * 
-     * @return an FSDefineSound object initialised with the encoded sound data.
-     */
-    public FSDefineSound defineSound(int anIdentifier)
-    {
-        byte[] bytes = null;
-        
-        switch (format)
-        {
-            case FSSound.PCM:
-            case FSSound.ADPCM:
-                bytes = new byte[sound.length];
-                System.arraycopy(sound, 0, bytes, 0, sound.length);
-                break;
-            case FSSound.MP3:
-                bytes = new byte[2+sound.length];
-                bytes[0] = 0;
-                bytes[1] = 0;
-                System.arraycopy(sound, 0, bytes, 2, sound.length);
-                break;
-        }
-        return new FSDefineSound(anIdentifier, format, sampleRate, numberOfChannels, sampleSize, samplesPerChannel, bytes);
-    }
-
-    /** 
-     * Generates an FSSoundStreamHead2 object to stream the sound data to the Flash Player.
-     * 
-     * @param samplesPerBlock the number of samples in each subsequent FSSoundStreamBlock 
-     * object.
-     * 
-     * @return an FSDefineSound object initialised with the encoded sound data.
-     */
-    public FSSoundStreamHead2 streamHeader(int samplesPerBlock)
-    {
-       return new FSSoundStreamHead2(format, sampleRate, numberOfChannels, sampleSize, sampleRate, numberOfChannels, sampleSize, samplesPerBlock);
-   }
-
-    /** 
-     * Generates an FSSoundStreamBlock object containing a block sound data. This method is 
-     * used to divide the encoded sound into a sequence of blocks to allow a sound to be 
-     * streamed to the Flash Player.
-     *
-     * If the number of samples in the last block to stream is less than the samplesPerBlock,
-     * the size of the FSSoundStreamBlock object is reduced accordingly. It is not padded 
-     * to maintain the specified length.
-     * 
-     * @param blockNumber the nth block of samples.
-     * 
-     * @param samplesPerBlock the number of samples to stream.
-     * 
-     * @return an FSSoundStreamBlock object containing a block of bytes from the encoded 
-     * sound.
-     */
-    public FSSoundStreamBlock streamBlock(int blockNumber, int samplesPerBlock)
-    {
-        int firstSample = 0;
-        int firstSampleOffset = 0;
-        int bytesPerBlock = 0;
-        int bytesRemaining = 0;
-        int numberOfBytes = 0;
-        
-        int framesToSend = 0;
-        int framesSent = 0;
-        int frameCount = 0;
-        int sampleCount = 0;
-        int seek = 0;
-        
-        byte[] bytes = null;
-
-        switch (format)
-        {
-            case FSSound.PCM:
-                firstSample = blockNumber * samplesPerBlock;
-                firstSampleOffset = firstSample * sampleSize * numberOfChannels;
-                bytesPerBlock = samplesPerBlock * sampleSize * numberOfChannels;
-                bytesRemaining = sound.length - firstSampleOffset;
-                
-                numberOfBytes = (bytesRemaining &lt; bytesPerBlock) ? bytesRemaining : bytesPerBlock;
-            
-                bytes = new byte[numberOfBytes];
-                System.arraycopy(sound, firstSampleOffset, bytes, 0, numberOfBytes);
-                break;
-            case FSSound.ADPCM:
-                break;
-            case FSSound.MP3:
-                framesToSend = ((blockNumber+1) * samplesPerBlock) / samplesPerFrame;
-                framesSent = (blockNumber * samplesPerBlock) / samplesPerFrame;
-                frameCount = framesToSend - framesSent;
-                sampleCount = frameCount * samplesPerFrame;
-                seek = (blockNumber * samplesPerBlock) - (framesSent * samplesPerFrame);
-            
-                numberOfBytes = 4;
-                
-                for (int i=0, j=framesSent; i&lt;frameCount; i++, j++)
-                     numberOfBytes += frameTable[j][1];
-                
-                bytes = new byte[numberOfBytes];
-            
-                bytes[0] = (byte)sampleCount;
-                bytes[1] = (byte)(sampleCount &gt;&gt; 8);
-                bytes[2] = (byte)seek;
-                bytes[3] = (byte)(seek &gt;&gt; 8);
-                
-                int offset = 4; 
-                
-                for (int i=0, j=framesSent; i&lt;frameCount; i++, j++)
-                {
-                    System.arraycopy(sound, frameTable[j][0], bytes, offset, frameTable[j][1]);
-                    offset += frameTable[j][1];
-                }
-                break;
-        }
-        
-        if (bytes != null)
-            return new FSSoundStreamBlock(bytes);
-        else
-            return null;
-    }
-
-    private void decodeWAV(String filename) throws FileNotFoundException, IOException, DataFormatException
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, dataFromFile(filename));
-        
-        int length = 0;
-        int chunkType = 0;
-        boolean moreChunks = true;
-
-        for (int i=0; i&lt;4; i++)
-        {
-            if (coder.readByte() != riffSignature[i])
-                throw new DataFormatException(&quot;Not a valid RIFF file&quot;);
-        }
-        
-        coder.readWord(4, false);
-        
-        for (int i=0; i&lt;4; i++)
-        {
-            if (coder.readByte() != wavSignature[i])
-                throw new DataFormatException(&quot;Not a valid WAV file&quot;);
-        }
-       
-        while (moreChunks)
-        {
-            chunkType = coder.readWord(4, false);
-            length = coder.readWord(4, false);
-            
-            int blockStart = coder.getPointer();
-            
-            switch (chunkType)
-            {
-                case FMT: 
-                	decodeFMT(coder); 
-                	break;
-                case DATA: 
-                	decodeDATA(coder, length); 
-                	break;
-                default: 
-                	coder.adjustPointer(length &lt;&lt; 3); 
-                	break;
-            }
-
-            int nextBlock = blockStart + (length &lt;&lt; 3);
-
-/*
-            int bytesRead = (coder.getPointer() - blockStart) &gt;&gt; 3;
-            
-            if (bytesRead &lt; length)
-                System.err.println(chunkType + &quot; chunk underflowed by &quot; + (length - bytesRead) + &quot; bytes.&quot;);
-            else if (bytesRead &gt; length)
-                System.err.println(chunkType + &quot; chunk overflowed by &quot; + (bytesRead - length) + &quot; bytes.&quot;);
- */
-            coder.setPointer(nextBlock);
-            moreChunks = coder.eof() == false;
-        }
-    }
-
-    private void decodeFMT(FSCoder coder) throws DataFormatException
-    {
-        format = FSSound.PCM;
-        
-        if (coder.readWord(2, false) != 1)
-            throw new DataFormatException(&quot;Compressed WAV files are not currently supported.&quot;);
-        
-        numberOfChannels = coder.readWord(2, false);
-        sampleRate = coder.readWord(4, false);
-        coder.readWord(4, false); // total data length
-        coder.readWord(2, false); // total bytes per sample
-        sampleSize = coder.readWord(2, false) / 8;
-    }
-    
-    private void decodeDATA(FSCoder coder, int length)
-    {
-        samplesPerChannel = length / (sampleSize*numberOfChannels);
-
-        sound = new byte[length];
-        coder.readBytes(sound);
-    }
-
-    private void decodeMP3(byte[] bytes) throws DataFormatException
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
-        
-        int numberOfFrames = 0;
-        int frameStart = 0;
-
-        format = FSSound.MP3;
-        sampleSize = 2;
-        
-        while (coder.eof() == false)
-        {        
-            if (coder.scanWord(3, false) == 0x494433) // ID3
-            {
-                coder.adjustPointer(24); // ID3 signature                
-                coder.adjustPointer(8); // version number
-                coder.adjustPointer(8); // revision number
-                
-                coder.adjustPointer(1); // unsynchronized
-                coder.adjustPointer(1); // extendedHeader
-                coder.adjustPointer(1); // experimental
-                int hasFooter = coder.readBits(1, false);
-                
-                coder.adjustPointer(4);
-                
-                int totalLength = (hasFooter == 1) ? 10 : 0;
-
-                totalLength += coder.readByte() &lt;&lt; 23;
-                totalLength += coder.readByte() &lt;&lt; 15;
-                totalLength += coder.readByte() &lt;&lt; 7;
-                totalLength += coder.readByte();
-
-                coder.adjustPointer(totalLength&lt;&lt;3);
-            }
-            else if (coder.scanWord(3, false) == 0x544147) // ID3 V1
-            {
-                coder.adjustPointer(128&lt;&lt;3);
-            }
-            else if (coder.scanBits(11, false) == 0x7FF) // MP3 frame
-            {
-                if (numberOfFrames == 0)
-                    frameStart = coder.getPointer();
-                
-                coder.adjustPointer(MP3FrameSize(coder) &lt;&lt; 3);
-                numberOfFrames++;
-            }
-            else
-            {
-                /*
-                 * If we get here it means we jumped into the middle of either 
-                 * a frame or tag information. This appears to be a common
-                 * occurrence. Goto the end of the file so we can keep the 
-                 * frames found so far.
-                 */
-                coder.setPointer(bytes.length&lt;&lt;3);
-            }
-        }
-
-        int dataLength = bytes.length - (frameStart &gt;&gt; 3);
-        
-        sound = new byte[dataLength];
-        
-        System.arraycopy(bytes, frameStart&gt;&gt;3, sound, 0, dataLength);
-        
-        frameTable = new int[numberOfFrames][2];
-        
-        for (int i=0; i&lt;numberOfFrames; i++)
-        {
-            frameTable[i][0] = -1;
-            frameTable[i][1] = 0;
-        }
-
-        coder.setPointer(frameStart);
-        
-        int frameNumber = 0;
-        
-        while (coder.findBits(0x7FF, 11, 8))
-        {
-            frameTable[frameNumber][0] = (coder.getPointer()- frameStart + 16) &gt;&gt; 3;
-            
-            coder.adjustPointer(11); // skip start of frame marker
-
-            int version = coder.readBits(2, false);
-            
-            samplesPerFrame = frameSizeMP3[version];
-            
-            if (coder.readBits(2, false) != 1)
-                throw new DataFormatException(&quot;Flash only supports MPEG Layer 3&quot;);
-                
-            coder.readBits(1, false); // crc follows header
-            
-            int bitRate = bitRates[version][coder.readBits(4, false)];
-            
-            if (bitRate == -1)
-                throw new DataFormatException(&quot;Unsupported Bit-rate&quot;);
-            
-            sampleRate = samplingRates[version][coder.readBits(2, false)];
-            
-            if (sampleRate == -1)
-                throw new DataFormatException(&quot;Unsupported Sampling-rate&quot;);
-            
-            int padding = coder.readBits(1, false);
-            coder.readBits(1, false); // reserved
-
-            numberOfChannels = channelCount[coder.readBits(2, false)];
-
-            coder.adjustPointer(6); // skip modeExtension, copyright, original and emphasis
-            
-            samplesPerChannel += samplesPerFrame;
-            
-            int frameSize = (((version == MPEG1) ? 144 : 72) * bitRate*1000 / sampleRate + padding) - 4;
-            
-            frameTable[frameNumber++][1] = 4 + frameSize;
-    
-            coder.adjustPointer(frameSize &lt;&lt; 3);
-        }
-    }
-    
-    private byte[] dataFromFile(String filename) throws IOException
-    {
-        File aFile = new File(filename);
-        FileInputStream imageContents = null;
-        
-        byte[] bytes = new byte[(int)aFile.length()];
-        
-        imageContents = new FileInputStream(aFile);            
-        imageContents.read(bytes);
-        imageContents.close();
-
-        return bytes;
-    }
-    
-    private void initFrameTable(byte[] bytes)
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
-                
-        coder.findBits(0x7FF, 11, 8);
-        
-        int frameStart = coder.getPointer();
-        int numberOfFrames = 0;
-        
-        while (coder.findBits(0x7FF, 11, 8))
-        {
-            coder.adjustPointer(MP3FrameSize(coder) &lt;&lt; 3);
-            numberOfFrames++;
-        }
-        
-        frameTable = new int[numberOfFrames][2];
-        
-        coder.setPointer(frameStart);
-        
-        int frameNumber = 0;
-        
-        while (coder.findBits(0x7FF, 11, 8))
-        {
-            frameTable[frameNumber][0] = (coder.getPointer()- frameStart + 16) &gt;&gt; 3;
-            
-            coder.adjustPointer(11); // skip start of frame marker
-
-            int version = coder.readBits(2, false);
-            
-            coder.adjustPointer(3);
-            
-            int bitRate = bitRates[version][coder.readBits(4, false)];
-            int samplingRate = samplingRates[version][coder.readBits(2, false)];
-            int padding = coder.readBits(1, false);
-
-            frameTable[frameNumber++][1] = 4 + (((version == MPEG1) ? 144 : 72) * bitRate*1000 / samplingRate + padding) - 4;
-    
-            coder.adjustPointer((MP3FrameSize(coder) &lt;&lt; 3)-23);
-        }
-    }
-    
-    private int MP3FrameSize(FSCoder coder)
-    {
-        int frameSize = 4;
-        
-        coder.adjustPointer(11);
-
-        int version = coder.readBits(2, false);
-            
-        coder.adjustPointer(3);
-            
-        int bitRate = bitRates[version][coder.readBits(4, false)];
-        int samplingRate = samplingRates[version][coder.readBits(2, false)];
-           int padding = coder.readBits(1, false);
-
-        coder.adjustPointer(-23);
-            
-        frameSize += (((version == MPEG1) ? 144 : 72) * bitRate*1000 / samplingRate + padding) - 4;
-        
-        return frameSize;
-    }
-}

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -1,2144 +0,0 @@
-/*
- *  FSTextConstructor.java
- *  Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
- 
-package com.flagstone.transform.util;
-
-import com.flagstone.transform.*;
-
-import java.awt.*;
-import java.awt.font.*;
-import java.awt.geom.*;
-
-import java.io.*;
-import java.util.*;
-import java.util.zip.*;
-
-/**
- * The FSTextConstructor class greatly simplifies the use of fonts and text when 
- * creating Flash files. Font definitions can be created in three ways:
- * 
- * &lt;ol&gt;
- * &lt;li&gt;Using TrueType or OpenType font definition stored in a file.&lt;/li&gt;
- * &lt;li&gt;Using a font definition stored in an existing Flash file.&lt;/li&gt;
- * &lt;li&gt;Using a given Java AWT font as a template.&lt;/li&gt;
- * &lt;/ol&gt;
- * 
- * &lt;P&gt;Font definitions from TrueType, OpenType or Flash files are created by 
- * specifying the name of the file:&lt;/p&gt;
- * 
- * &lt;pre&gt;
- * FSTextConstructor font = new FSTextConstructor(id, trueTypeFile.getPath());
- * FSTextConstructor font = new FSTextConstructor(id, swfFile.getPath());
- * &lt;/pre&gt;
- * 
- * &lt;P&gt;The OpenType or TrueType file is parsed to construct the font definition. 
- * Files with the extensions &quot;.otf&quot; or &quot;.ttf&quot; may be used. Files containing 
- * collections of fonts &quot;.otc&quot; are not currently supported. For Flash files the 
- * first font definition encountered is used and all the text definition objects 
- * associated with the font are used to obtain the advance information for each 
- * character. An example Flash file can be found in the resources directory 
- * included in this release.&lt;/p&gt;
- * 
- * &lt;P&gt;Font definitions from AWT templates are created by passing a font object:&lt;/p&gt;
- * 
- * &lt;pre&gt;
- * FSTextConstructor font = new FSTextConstructor(id, new Font(&quot;Arial&quot;, Font.PLAIN, 1));
- * &lt;/pre&gt;
- * 
- * &lt;p&gt;Only the font or file name needs to specified. Unlike Java fonts, font 
- * definitions in Flash are size independent, the size and colour in which a 
- * given string in rendered is specified in the object  that defines the text to 
- * be displayed avoiding the need to create multiple font definitions for  the 
- * same font name.&lt;/p&gt;
- *
- * &lt;P&gt;An array of FSGlyph objects are created from the font definition. Each 
- * object contains the glyph for the font, the associated character code and 
- * information used to lay out each glyph when it is displayed.&lt;/P&gt;
- * 
- * &lt;P&gt;Once a font has been created text strings can be generated:&lt;/p&gt;
- * 
- * &lt;pre&gt;
- *    int fontSize = 280; // twips
- *    FSColor fontColor = FSColorTable.black();
- *    FSDefineText2 aString = font.defineText(&quot;This is a string&quot;, fontSize, fontColor);
- * &lt;/pre&gt;
- * 
- * &lt;P&gt;The defineText method returns FSDefineText2 objects since they support 
- * transparent colours, while FSDefineText only supports opaque colours.&lt;/P&gt;
- *
- * &lt;P&gt;Once all the strings to be displayed have been generated the font 
- * definition object containing the glyphs can be generated.&lt;/p&gt;
- * 
- * &lt;pre&gt;
- *    FSDefineFont2 defineFont = font.defineFont();
- * &lt;/pre&gt;
- * 
- * &lt;P&gt;Remember however that objects in a Flash file must be defined before they 
- * are used so the font object must be added to the file before the first 
- * FSDefineText object that references the glyphs in the font.&lt;/p&gt;
- * 
- * &lt;P&gt;To reduce the size of the Flash file only the glyphs actually displayed 
- * can be included in a font definition object. When a FSDefineText object is 
- * created the glyphs used are marked. This is why the text definition objects 
- * are generated before the font definition.&lt;/P&gt;
- *
- * &lt;P&gt;Glyphs are included in the font in the order they are used with each 
- * FSDefineText2 object referencing a glyph by its position in the array of 
- * glyphs contained in a font definition. Any unused glyphs can then easily be 
- * omitted.&lt;/P&gt;
- * 
- * &lt;P&gt;When the font definition is created only the glyphs used (up to that 
- * point) are included. If subsequent FSDefineText objects are generated that 
- * include glyphs not previously used then the text will not be displayed 
- * correctly.&lt;/p&gt;
- *
- * &lt;b&gt;Text Fields&lt;/b&gt;&lt;br/&gt;
- *
- * &lt;P&gt;When creating text fields using the FSDefineTextField class, there are two 
- * options when specifying the font used to display the characters entered into 
- * the field:
- *
- * &lt;ol&gt;
- * &lt;li&gt;The glyphs for the font may be loaded from the host platform.&lt;/li&gt;
- * &lt;li&gt;The glyphs for the font are taken from a font definition object.&lt;/li&gt;
- * &lt;/ol&gt;
- *
- * &lt;P&gt;Using the glyphs loaded from the host platform is by far the easiest way 
- * of using text fields. First a font definition is created that specifies only 
- * the name of the font which will be loaded from the host platform. Then 
- * creating the text fields set the useFontGlyphs attribute to false.&lt;/P&gt;
- *
- * &lt;pre&gt;
- *    FSDefineFont2 fontDefinition = new FSDefineFont2(movie.newIdentifier(), &quot;Arial&quot;);
- *
- *    FSDefineTextField textField = new FSDefineTextField(movie.newIdentifier(), bounds);
- *
- *    textField.setUseFontGlyphs(false);
- * &lt;/pre&gt;
- *
- * &lt;P&gt;This approach only works if the font is defined on the host platform 
- * otherwise the Flash Player will substitute a default font.&lt;/P&gt;
- *
- * &lt;P&gt;When using a font definition contained in the Flash file obviously the 
- * glyphs for all possible characters must be defined otherwise the character 
- * will not be displayed correctly. When using text fields the characters must 
- * be defined in the font, sorted by ascending character code, otherwise the
- * text will not be displayed correctly. To do this the FSCharacterTable class
- * provides arrays of characters sorted in the correct order. The array is 
- * passed to the willDisplay() method and the FSTextConstructor will add the 
- * glyphs for the characters in the order they appear in the array:&lt;/p&gt;
- * 
- * &lt;pre&gt;
- *     char[] characterSet = FSCharacterTable.ascii();
- *     
- *     textConstructor.willDisplay(characterSet);
- * &lt;/pre&gt;
- * 
- * &lt;P&gt;This will add ALL of the characters in the array to the font definition.
- * Several character sets are provided in the FSCharacterTable class but any 
- * array of characters could be passed to the willDisplay() method - allowing
- * smaller font definitions to be created when only a few characters are 
- * displayed.&lt;/p&gt;
- *
- * &lt;b&gt;Missing Characters&lt;/b&gt;&lt;br/&gt;
- *
- * &lt;P&gt;Characters that cannot be displayed using the font are handled by a 
- * displaying a default glyph which typically represents a space or an empty 
- * box. Both Java AWT and True/Open Type definitions explicitly define the 
- * missing glyph. For fonts parsed from Flash files the missing glyph is assumed 
- * (by default) to be the first glyph in the font definition.&lt;/p&gt;
- * 
- * &lt;P&gt;When a font is loaded the missing glyph is added automatically to the font 
- * definition so there is no need to explicitly include it by creating a text 
- * object to force it to be included. The missing glyph will always be the first 
- * glyph in the font definition generated by the FSTextConstructor object so it 
- * may be substituted by another suitable shape if required.&lt;/P&gt;
- * 
- * &lt;P&gt;Whether a string can be displayed using a font can be determined by the 
- * &lt;em&gt;canDisplay()&lt;/em&gt; method which returns the index of the first character 
- * that cannot be displayed (the missing glyph will be displayed instead) or -1 
- * if all the characters are represented in the font.&lt;/P&gt;
- */
-public class FSTextConstructor
-{
-    private static final int OS_2 = 0x4F532F32;
-    private static final int HEAD = 0x68656164;
-    private static final int HHEA = 0x68686561;
-    private static final int MAXP = 0x6D617870;
-    private static final int LOCA = 0x6C6F6361;
-    private static final int CMAP = 0x636D6170;
-    private static final int HMTX = 0x686D7478;
-    private static final int NAME = 0x6E616D65;
-    private static final int GLYF = 0x676C7966;
-
-    private static final int ITLF_SHORT = 0;
-    private static final int ITLF_LONG  = 1;
-    
-    private static final int FONT_WEIGHT_THIN       = 100;
-    private static final int FONT_WEIGHT_EXTRALIGHT = 200;
-    private static final int FONT_WEIGHT_LIGHT      = 300;
-    private static final int FONT_WEIGHT_NORMAL     = 400;
-    private static final int FONT_WEIGHT_MEDIUM     = 500;
-    private static final int FONT_WEIGHT_SEMIBOLD   = 600;
-    private static final int FONT_WEIGHT_BOLD       = 700;
-    private static final int FONT_WEIGHT_EXTRABOLD  = 800;
-    private static final int FONT_WEIGHT_BLACK      = 900;
-    
-    private static final int ON_CURVE    = 0x01;
-    private static final int X_SHORT     = 0x02;
-    private static final int Y_SHORT     = 0x04;
-    private static final int REPEAT_FLAG = 0x08;
-    private static final int X_SAME      = 0x10;
-    private static final int Y_SAME      = 0x20;
-    private static final int X_POSITIVE  = 0x10;
-    private static final int Y_POSITIVE  = 0x20;
-    
-    private static final int ARG_1_AND_2_ARE_WORDS    = 0x01;
-    private static final int ARGS_ARE_XY_VALUES       = 0x02;
-    private static final int WE_HAVE_A_SCALE          = 0x08;
-    private static final int WE_HAVE_AN_X_AND_Y_SCALE = 0x40;
-    private static final int WE_HAVE_A_TWO_BY_TWO     = 0x80;
-    private static final int MORE_COMPONENTS          = 0x10;
-    
-    private static final int NUMBER_OF_METRICS = 0;
-    private static final int SCALE = 1;
-    private static final int GLYPH_OFFSET_SIZE = 2;
-    
-    private class FSGlyph
-    {
-        FSShape shape = null;
-        FSBounds bounds = new FSBounds(0, 0, 0, 0);
-        int advance = 0;
-
-        int[] xCoordinates = null;
-        int[] yCoordinates = null;
-        boolean[] onCurve = null;
-        int[] endPoints = null;
-        
-        FSGlyph()
-        {
-            shape = new FSShape();
-            bounds = new FSBounds(0, 0, 0, 0);
-            advance = 0;
-            
-            xCoordinates = new int[] {};
-            yCoordinates = new int[] {};
-            onCurve = new boolean[] {};
-            endPoints = new int[] {};
-        }
-
-        FSGlyph(FSShape aShape, FSBounds aBounds)
-        {
-            shape = aShape;
-            bounds = aBounds;
-            advance = 0;
-            
-            xCoordinates = new int[] {};
-            yCoordinates = new int[] {};
-            onCurve = new boolean[] {};
-            endPoints = new int[] {};
-        }
-    };
-    
-    private int identifier = 0;
-    private String name = &quot;&quot;;
-    private int encoding = 0;
-    private float size = 0.0f;
-    private boolean isBold = false;
-    private boolean isItalic = false;
-
-    private int baseline = 0;
-    private float ascent = 0;
-    private float descent = 0;
-    private float leading = 0;
-    
-    private short[] orderTable = new short[65536];
-    private short[] characterTable = new short[65536];
-    private FSGlyph[] glyphTable = null;
-    
-    private int numberOfGlyphs = 0;
-    private int missingGlyph = 0;
-    
-    private ArrayList kernings = new ArrayList();
-    private int[] attributes = new int[8];
-
-    /**
-     * Creates a new FSTextConstructor object using the specified font.
-     * 
-     * &lt;P&gt;The fontName can be used to identify a particular font in two ways, 
-     * either specifying:
-     * 
-     * &lt;ol&gt;
-     * &lt;li&gt;the name of a file containing a TrueType or OpenType font definition.&lt;/li&gt;
-     * &lt;li&gt;the name of a Flash file containing font definition.&lt;/li&gt;
-     * &lt;/ol&gt;
-     *
-     * IMPORTANT: This method previously allowed the name of a AWT Font to be 
-     * specified as an argument. This will no longer be supported in future 
-     * releases, use the FSTextCOnstructor(int, Font) method instead.
-     * 
-     * @param anIdentifier a unique identifier that will be assigned to the 
-     * font definition object generated and referenced by all the text object
-     * generated.
-     * 
-     * @param filename either the name of a Flash, TrueType or OpenType file 
-     * containing an existing font definition.
-     * 
-     * @throws FileNotFoundException if the fontName specifies a file and the 
-     * file cannot be found or opened.
-     * 
-     * @throws IOException if the fontName specifies a file and an error occurs while
-     * reading the file from disk.
-     * 
-     * @throws DataFormatException if the fontName specifies a file and an error occurs while 
-     * parsing the font definition.
-     */
-    public FSTextConstructor(int anIdentifier, String filename) throws IOException, DataFormatException
-    {
-        identifier = anIdentifier; 
-        
-        for (int i=0; i&lt;65536; i++)
-            orderTable[i] = -1;
-            
-        if (filename.toLowerCase().endsWith(&quot;.swf&quot;))
-            decodeSWFFont(filename);
-        else if (filename.toLowerCase().endsWith(&quot;.otf&quot;))
-            decodeOpenTypeFont(filename);
-        else if (filename.toLowerCase().endsWith(&quot;.ttf&quot;))
-            decodeOpenTypeFont(filename);
-        else
-             decodeAWTFont(filename);
-    }
-    /**
-     * Creates a new FSTextConstructor object using the specified font.
-     * 
-     * @param anIdentifier a unique identifier that will be assigned to the 
-     * font definition object generated and referenced by all the text object
-     * generated.
-     * 
-     * @param font an AWT Font object.
-     */
-    public FSTextConstructor(int anIdentifier, Font font)
-    {
-        identifier = anIdentifier; 
-        
-        for (int i=0; i&lt;65536; i++)
-            orderTable[i] = -1;
-            
-        decodeAWTFont(font);
-    }    
-    /**
-     * Resets the FSTextConstructor to generate a new set of font and text 
-     * objects. 
-     * 
-     * The character sets defined for the font are cleared so the characters
-     * that will be used to generate the next font definition should be set with
-     * the willDisplay() method.
-     * 
-     * This method is useful when generating objects for more than one Flash
-     * file as it avoids the penalty of reloading the font definition which 
-     * can be very expensive.
-     * 
-     * @param anIdentifier a unique identifier that will be assigned to the 
-     * font definition object generated and referenced by all the text object
-     * generated.
-     */
-    public void reset(int anIdentifier)
-    {
-        identifier = anIdentifier; 
-        
-        for (int i=0; i&lt;65536; i++)
-            orderTable[i] = -1;      
-    }
-    /**
-     * Indicates whether or not this FSTextConstructor can display all the 
-     * characters specified in the array. This method returns the index of the 
-     * first character that cannot be displayed using this font. If the Font can 
-     * display all characters, -1 is returned.
-     *
-     * @param chars an array containing all the characters to be displayed.
-     *
-     * @return the index of the first character that cannot be displayed, -1 
-     * otherwise.
-     */
-    public int canDisplay(char[] chars)
-    {
-        int firstMissingChar = -1;
-
-        for (int i=0; i&lt;chars.length; i++)
-        {
-            if (canDisplay(chars[i]) == false)
-            {
-                firstMissingChar = i;
-                break;
-            }
-        }
-        return firstMissingChar;
-    }
-    /**
-     * Indicates whether or not this FSTextConstructor can display a specified 
-     * Unicode String. This method returns the index of the first character that 
-     * cannot be displayed using this font. If the Font can display all 
-     * characters, -1 is returned.
-     *
-     * @param aString the String to be displayed.
-     *
-     * @return the index of the first character that cannot be displayed, -1 
-     * otherwise.
-     */
-    public int canDisplay(String aString)
-    {
-        int firstMissingChar = -1;
-
-        for (int i = 0; i &lt; aString.length(); i++)
-        {
-            if (canDisplay(aString.charAt(i)) == false)
-            {
-                firstMissingChar = i;
-
-                break;
-            }
-        }
-        return firstMissingChar;
-    }
-    /**
-     * willDisplay is used to predefine the set of characters that will be 
-     * used when defining text objects.
-     * 
-     * @see FSCharacterTable for lists of predefined character sets that can be
-     * used with different spoken languages.
-     * 
-     * @param chars an array of characters defining the character set that will
-     * be used when defining text objects and fonts. The characters must be 
-     * sorted by the code used to represent the character.
-     */
-    public void willDisplay(char[] chars)
-    {
-       for (int i=0; i&lt;chars.length; i++)
-       {
-           int glyphIndex = characterTable[chars[i]];
-           
-           for (int index=0; index&lt;65536; index++)
-           {
-               if (orderTable[index] == glyphIndex)
-                   break;
-               else if (orderTable[index] == -1)
-               {
-                   orderTable[index] = (short)glyphIndex;
-                   break;
-               }
-           }
-       }
-    }
-    /**
-     * Generates a FSDefineFont2 object containing a complete definition of the font.
-     *
-     * &lt;P&gt;NOTE: Only the glyphs specified in the array of characters passed to
-     * the willDisplay method will be shown.&lt;/P&gt;
-     *
-     * @return a FSDefineFont2 object generated from the font definition.
-     */
-    public FSDefineFont2 defineFont()
-    {
-        FSDefineFont2 font = null;
-        int count = 0;
-        
-        for (count=0; orderTable[count] != -1 &amp;&amp; count&lt;orderTable.length; count++);
-
-        ArrayList glyphsArray = new ArrayList(count);
-        ArrayList codesArray = new ArrayList(count);
-        ArrayList advancesArray = new ArrayList(count);
-        ArrayList boundsArray = new ArrayList(count);
-
-        for (int i=0; i&lt;count; i++)
-        {
-            int glyphIndex = orderTable[i];
-            int character = 0;
-            
-            while (characterTable[character] != glyphIndex) character++;
- 
-            glyphsArray.add(glyphTable[glyphIndex].shape);
-            codesArray.add(new Integer(character));
-            advancesArray.add(new Integer(glyphTable[glyphIndex].advance));
-            boundsArray.add(glyphTable[glyphIndex].bounds);
-        }
-
-        // Use simplest constructor to ensure compatibility between 
-        // different editions of Transform.
-        
-        font = new FSDefineFont2(identifier, name);
-                
-        font.setEncoding(encoding);
-        font.setItalic(isItalic);
-        font.setBold(isBold);
-        font.setAscent((int)ascent);
-        font.setDescent((int)descent);
-        font.setLeading((int)leading);
-        font.setShapes(glyphsArray);
-        font.setCodes(codesArray);
-        font.setAdvances(advancesArray);
-        font.setBounds(boundsArray);
-        font.setKernings(kernings);
-        
-        return font;
-    }
-    /**
-     * Generates an FSDefineText2 object for the text rendered in the specified font size
-     * and colour. This method is used to create FSDefineText2 objects for arbitrary
-     * strings, using the characters defined for the FSTextConstructor object when it is
-     * constructed.
-     * 
-     * NOTE: The font size is specified in twips not points or pixels.
-     * 
-     * &lt;P&gt;An FSDefineText2 object differs from an FSDefineText object in that it supports
-     * transparent colours.&lt;/p&gt;
-     * 
-     * &lt;P&gt;If any of the Unicode characters in the String cannot be displayed using this font
-     * then the missing glyph is substituted.&lt;/p&gt;
-     * 
-     * @param anIdentifier a unique identifier for the object.
-     * @param text the String to be displayed.
-     * @param fontSize the size of the font in twips.
-     * @param aColor the colour of the text including transparency.
-     *
-     * @return an FSDefineText object representing the text.
-     */
-    public FSDefineText2 defineText(int anIdentifier, String text, int fontSize,
-        FSColor aColor)
-    {
-        FSCoordTransform coordTransform = new FSCoordTransform(0, 0);
-
-        float scaleFactor = ((float)fontSize) / 1024.0f;
-
-        int[] glyphCodes = glyphIndicesForString(text);
-        int[] glyphAdvances = advancesForGlyphIndices(glyphCodes, scaleFactor);
-        
-        FSSpan textRecord = new FSSpan(identifier, aColor, 0,
-                scaleBaseline(scaleFactor), fontSize, charactersForGlyphs(glyphCodes, glyphAdvances));
-
-        ArrayList textRecords = new ArrayList();
-
-        textRecords.add(textRecord);
-
-        return new FSDefineText2(anIdentifier,
-            boundsForText(glyphCodes, glyphAdvances, fontSize), coordTransform,
-            textRecords);
-    }
-    /**
-     * Generates an FSDefineText2 object for a block of text.
-     * 
-     * &lt;P&gt;An FSDefineText2 object differs from an FSDefineText object in that it supports
-     * transparent colours.&lt;/p&gt;
-     * 
-     * &lt;P&gt;If any of the Unicode characters in the String cannot be displayed using this font
-     * then the missing glyph is substituted.&lt;/p&gt;
-     * 
-     * @param anIdentifier a unique identifier for the object.
-     * @param lines an array containing the lines of text to be displayed.
-     * @param fontSize the size of the font in twips.
-     * @param aColor the colour of the text including transparency.
-     * @param lineSpacing the distance, in twips, between successive lines.
-     *
-     * @return an FSDefineText object representing the text.
-     */
-    public FSDefineText2 defineTextBlock(int anIdentifier, ArrayList lines, int fontSize,
-        FSColor aColor, int lineSpacing)
-    {
-        FSCoordTransform coordTransform = new FSCoordTransform(0, 0);
-
-        float scaleFactor = ((float)fontSize) / 1024.0f;
-        
-        int xMin = 0;
-        int yMin = 0;
-        int xMax = 0;
-        int yMax = 0;
-        
-        int xOffset = 0;
-        int yOffset = scaleBaseline(scaleFactor);
-        ArrayList textRecords = new ArrayList();
-        
-        int n = 0;
-
-        for (Iterator i = lines.iterator(); i.hasNext(); yOffset += lineSpacing, n++)
-        {
-            String text = (String)i.next();
-
-            int[] glyphCodes = glyphIndicesForString(text);
-            int[] glyphAdvances = advancesForGlyphIndices(glyphCodes, scaleFactor);
-            
-            FSBounds bounds = boundsForText(glyphCodes, glyphAdvances, fontSize);
-            
-            if (n==0) {
-                yMin = bounds.getMinY();
-                yMax = bounds.getMaxY();
-            }
-            else {
-                yMax += lineSpacing;
-            }
-            
-            if (n==lines.size()-1)
-                yMax += bounds.getHeight();
-            
-            xMin = (xMin &lt; bounds.getMinX()) ? xMin : bounds.getMinX();
-            xMax = (xMax &gt; bounds.getMaxX()) ? xMax : bounds.getMaxX();
-                    
-            FSSpan textRecord = new FSSpan(identifier, aColor, xOffset,
-                    yOffset, fontSize, charactersForGlyphs(glyphCodes, glyphAdvances));
-
-            textRecords.add(textRecord);
-        }
-
-        return new FSDefineText2(anIdentifier, new FSBounds(xMin, yMin, xMax, yMax), coordTransform,
-            textRecords);
-    }
-    /**
-     * Generates an FSBounds object that defines the bounding box that encloses the text,
-     * rendered in the specified font size.
-     *
-     * @param text the String to be displayed.
-     * @param fontSize the size of the font in twips.
-     *
-     * @return an FSBounds object defining the bounding box enclosing the text.
-     */
-    public FSBounds boundsForText(String text, int fontSize)
-    {
-        float scaleFactor = ((float)fontSize) / 1024.0f;
-
-        int[] glyphCodes = glyphIndicesForString(text);
-        int[] glyphAdvances = advancesForGlyphIndices(glyphCodes, scaleFactor);
-
-        return boundsForText(glyphCodes, glyphAdvances, fontSize);
-    }
-    /**
-     * Returns the advance, in twips, to the next character. This method can be
-     * used when laying out sequences of individual characters, rather than as 
-     * as single string.
-     * 
-     * @param c the character that will be displayed.
-     * @param fontSize the size of the font the character will be rendered in.
-     * @return the distance to the next character.
-     */
-    public int advanceForChar(char c, int fontSize)
-    {
-        float scaleFactor = ((float)fontSize) / 1024.0f;
-
-        int index = characterTable[c];
-        int advance = (int) (glyphTable[index].advance * scaleFactor);
-        
-        return advance;
-    }
-    /**
-     * defineShape converts a string into an equivalent shape representation. The
-     * shape is constructed from glyphs used to represent each character in the 
-     * string and filled with the specified colour.
-     * 
-     * @param anIdentifier an unique identifier for the shape.
-     * @param text the string to convert into a shape.
-     * @param fontSize the font size in twips used to render the shape 
-     * @param aColor the colour which will be used to fill the shape.
-     *
-     * @return an FSDefineShape3 object4 which contains a shape that represents 
-     * the characters contained in the string argument.
-     */
-    public FSDefineShape3 defineShape(int anIdentifier, String text, int fontSize, FSColor aColor)
-    {
-        FSShapeConstructor path = new FSShapeConstructor();
-        
-        path.add(new FSSolidFill(aColor));
-        path.selectFillStyle(0);
-        
-        float scaleFactor = ((float)fontSize) / 1024.0f;
-        
-        int[] glyphCodes = glyphIndicesForString(text);
-        int[] glyphAdvances = advancesForGlyphIndices(glyphCodes, scaleFactor);
-        
-        int xOffset = 0;
-        
-        for (int i=0; i&lt;text.length(); i++)
-        {
-            ArrayList array = glyphTable[orderTable[glyphCodes[i]]].shape.getObjects();
-    
-            for (Iterator j = array.iterator(); j.hasNext();)
-            {
-                FSShapeObject currentObject = (FSShapeObject) j.next();
-
-                if (currentObject instanceof FSShapeStyle)
-                {
-                    FSShapeStyle style = (FSShapeStyle) currentObject;
-                    int moveX = (int)(style.getMoveX()*scaleFactor + ((style.getMoveX() &lt; 0) ? (-0.5) : 0.5));
-                    int moveY = (int)(style.getMoveY()*scaleFactor + ((style.getMoveY() &lt; 0) ? (-0.5) : 0.5));
-                    
-                    path.closePath();
-                    path.move(moveX + xOffset, moveY);
-                }
-                else if (currentObject instanceof FSLine)
-                {
-                    FSLine line = (FSLine) currentObject;
-                    int x = (int)(line.getX()*scaleFactor + ((line.getX() &lt; 0) ? (-0.5) : 0.5));
-                    int y = (int)(line.getY()*scaleFactor + ((line.getY() &lt; 0) ? (-0.5) : 0.5));
-
-                    path.rline(x, y);
-                }
-                else if (currentObject instanceof FSCurve)
-                {
-                    FSCurve curve = (FSCurve) currentObject;
-                    int cx = (int)(curve.getControlX()*scaleFactor + ((curve.getControlX() &lt; 0) ? (-0.5) : 0.5));
-                    int cy = (int)(curve.getControlY()*scaleFactor + ((curve.getControlY() &lt; 0) ? (-0.5) : 0.5));
-                    int ax = (int)(curve.getAnchorX()*scaleFactor + ((curve.getAnchorX() &lt; 0) ? (-0.5) : 0.5));
-                    int ay = (int)(curve.getAnchorY()*scaleFactor + ((curve.getAnchorY() &lt; 0) ? (-0.5) : 0.5));
-
-                    path.rcurve(cx, cy, ax, ay);
-                }
-            }
-            path.closePath();
-            xOffset += glyphAdvances[i];
-        }
-
-        return path.defineTransparentShape(anIdentifier);
-    }
-
-    private void decodeSWFFont(String filename) throws IOException, DataFormatException
-    {
-        FSMovie fontMovie = new FSMovie(filename);
-
-        FSDefineFont font = null;
-        FSFontInfo fontInfo = null;
-        FSDefineText text = null;
-        FSSpan textRecord = null;
-
-        for (Iterator i = fontMovie.getObjects().iterator(); i.hasNext();)
-        {
-            FSMovieObject currentObject = (FSMovieObject) i.next();
-
-            if (currentObject instanceof FSDefineFont)
-            {
-                font = (FSDefineFont) currentObject;
-            }
-            else if (currentObject instanceof FSFontInfo)
-            {
-                fontInfo = (FSFontInfo) currentObject;
-            }
-            else if (currentObject instanceof FSDefineText)
-            {
-                text = (FSDefineText) currentObject;
-            }
-        }
-
-        textRecord = (FSSpan) text.getObjects().get(0);
-
-        name = fontInfo.getName();
-        encoding = fontInfo.getEncoding();
-        size = (float) (textRecord.getHeight());
-        isBold = fontInfo.isBold();
-        isItalic = fontInfo.isItalic();
-        
-        /*
-         * Change the encoding for ASCII to Unicode since ASCII is compatible
-         * with UTF8.
-         */
-        if (encoding == FSSpan.ANSI)
-            encoding = FSSpan.Unicode;
-
-        glyphTable = new FSGlyph[font.getShapes().size()];
-        
-        int glyphIndex = 0;
-
-        for (Iterator j = font.getShapes().iterator(); j.hasNext(); glyphIndex++)
-            glyphTable[glyphIndex] = new FSGlyph((FSShape) j.next(), new FSBounds(0, 0, 0, 0));
-
-        glyphIndex = 0;
-
-        for (Iterator k = fontInfo.getCodes().iterator(); k.hasNext(); glyphIndex++)
-            characterTable[((Integer) (k.next())).intValue()] = (short) glyphIndex;
-
-        for (Iterator l = textRecord.getCharacters().iterator(); l.hasNext();)
-        {
-            FSCharacter character = (FSCharacter) l.next();
-
-            glyphTable[character.getGlyphIndex()].advance = (int) (character.getAdvance() * (1024.0 / size));
-        }
-        orderTable[0] = 0;
-    }  
-    /*
-     * This method will be superceded by decodeAWTFont(Font font) in a future 
-     * release.
-     */
-    private void decodeAWTFont(String fontName)
-    {
-        FontRenderContext fontContext = new FontRenderContext(new AffineTransform(), true, true);
-
-        /*
-         Create an initial 1 point font of the specified name. The PLAIN font style is 
-         used as the fontName if it contains a suffix such as &quot;BOLD&quot; or &quot;Italic&quot; will 
-         override the style.
-         */
-        Font font = new Font(fontName, Font.PLAIN, 1);
-
-        if (font == null)
-            throw new IllegalArgumentException(&quot;No such font: &quot; + fontName);
-        
-        name = fontName;
-        encoding = FSSpan.Unicode;
-
-        Rectangle2D transform = transformToEMSquare(font, fontContext);
-
-        double scaleY = 1024.0; // Math.abs(1024.0 / bounds.getY());
-        double scaleX = scaleY;
-        double translateX = 1024.0 - (transform.getX() * 1024.0);
-        double translateY = 1024.0 - (transform.getY() * 1024.0);
-
-        size = (float) scaleY;
-
-        /*
-         The new font scaled to the EM Square must be derived using the size as well 
-         as the transform used for the glyphs otherwise the advance values are not 
-         scaled accordingly.
-         */
-//        AffineTransform at = AffineTransform.getTranslateInstance(translateX, translateY);
-//        font = font.deriveFont(at);
-        font = font.deriveFont((float)scaleX);
-
-        missingGlyph = font.getMissingGlyphCode();
-
-        isBold = font.isBold();
-        isItalic = font.isItalic();
-
-        int numGlyphs = font.getNumGlyphs();
-        int glyphIndex = 0;
-        int characterCode = 0;
-    
-        glyphTable = new FSGlyph[numGlyphs];
-    
-        /*
-         * Run through all the unicode character codes looking for a corresponding glyph.
-         */
-        while ((glyphIndex &lt; numGlyphs) &amp;&amp; (characterCode &lt; 65535))
-        {
-            char currentChar = (char) characterCode;
-    
-            if (font.canDisplay(currentChar))
-            {
-                GlyphVector glyphVector = font.createGlyphVector(fontContext,
-                       new char[] { currentChar });
-    
-                Shape outline = glyphVector.getGlyphOutline(0);
-                int advance = (int) (glyphVector.getGlyphMetrics(0).getAdvance());
-    
-                characterTable[currentChar] = (short)glyphIndex;
-                glyphTable[glyphIndex] = new FSGlyph(convertShape(outline), new FSBounds(0, 0, 0, 0));
-                glyphTable[glyphIndex].advance = advance;
-    
-                if (font.hasUniformLineMetrics() == false)
-                {
-                    LineMetrics lineMetrics = font.getLineMetrics(new char[]
-                             { (char) currentChar }, 0, 1, fontContext);
-    
-                    ascent = 0; // Math.max(lineMetrics.getAscent() * 20, ascent);
-                       descent = 0; // Math.max(lineMetrics.getDescent() * 20, descent);
-                       leading = 0; // Math.max(lineMetrics.getLeading() * 20, leading);
-                }
-           }
-           else
-           {
-                GlyphVector glyphVector = font.createGlyphVector(fontContext, new char[] { (char)missingGlyph });
-            
-                Shape outline = glyphVector.getGlyphOutline(0);
-                int advance = (int) (glyphVector.getGlyphMetrics(0).getAdvance());
-    
-                characterTable[currentChar] = (short)glyphIndex;
-                glyphTable[glyphIndex] = new FSGlyph(convertShape(outline), new FSBounds(0, 0, 0, 0));
-                glyphTable[glyphIndex].advance = advance;
-    
-                if (font.hasUniformLineMetrics() == false)
-                {
-                    LineMetrics lineMetrics = font.getLineMetrics(new char[]
-                             {(char)currentChar }, 0, 1, fontContext);
-    
-                    ascent = 0; // Math.max(lineMetrics.getAscent() * 20, ascent);
-                    descent = 0; // Math.max(lineMetrics.getDescent() * 20, descent);
-                    leading = 0; // Math.max(lineMetrics.getLeading() * 20, leading);
-                }
-           }
-           glyphIndex++;
-           characterCode++;
-       }
-       orderTable[0] = (short)missingGlyph;
-    }
-    private void decodeAWTFont(Font font)
-    {
-        FontRenderContext fontContext = new FontRenderContext(new AffineTransform(), true, true);
-        font = font.deriveFont(1.0f);
-
-        name = font.getName();
-        encoding = FSSpan.Unicode;
-
-        Rectangle2D transform = transformToEMSquare(font, fontContext);
-
-        double scaleY = 1024.0; // Math.abs(1024.0 / bounds.getY());
-        double scaleX = scaleY;
-        double translateX = 1024.0 - (transform.getX() * 1024.0);
-        double translateY = 1024.0 - (transform.getY() * 1024.0);
-
-        size = (float) scaleY;
-
-        /*
-         The new font scaled to the EM Square must be derived using the size as well 
-         as the transform used for the glyphs otherwise the advance values are not 
-         scaled accordingly.
-         */
-        AffineTransform at = AffineTransform.getTranslateInstance(translateX, translateY);
-        font = font.deriveFont(at);
-        font = font.deriveFont((float)scaleX);
-
-        missingGlyph = font.getMissingGlyphCode();
-
-        isBold = font.isBold();
-        isItalic = font.isItalic();
-
-        int numGlyphs = font.getNumGlyphs();
-        int glyphIndex = 0;
-        int characterCode = 0;
-    
-        glyphTable = new FSGlyph[numGlyphs];
-    
-        /*
-         * Run through all the unicode character codes looking for a corresponding glyph.
-         */
-        while ((glyphIndex &lt; numGlyphs) &amp;&amp; (characterCode &lt; 65535))
-        {
-            char currentChar = (char) characterCode;
-    
-            if (font.canDisplay(currentChar))
-            {
-                GlyphVector glyphVector = font.createGlyphVector(fontContext,
-                       new char[] { currentChar });
-    
-                Shape outline = glyphVector.getGlyphOutline(0);
-                int advance = (int) (glyphVector.getGlyphMetrics(0).getAdvance());
-    
-                characterTable[currentChar] = (short)glyphIndex;
-                glyphTable[glyphIndex] = new FSGlyph(convertShape(outline), new FSBounds(0, 0, 0, 0));
-                glyphTable[glyphIndex].advance = advance;
-    
-                if (font.hasUniformLineMetrics() == false)
-                {
-                    LineMetrics lineMetrics = font.getLineMetrics(new char[]
-                             { (char) currentChar }, 0, 1, fontContext);
-    
-                       ascent = 0; // Math.max(lineMetrics.getAscent() * 20, ascent);
-                       descent = 0; // Math.max(lineMetrics.getDescent() * 20, descent);
-                       leading = 0; // Math.max(lineMetrics.getLeading() * 20, leading);
-                }
-           }
-           else
-           {
-                GlyphVector glyphVector = font.createGlyphVector(fontContext, new char[] { (char)missingGlyph });
-            
-                Shape outline = glyphVector.getGlyphOutline(0);
-                int advance = (int) (glyphVector.getGlyphMetrics(0).getAdvance());
-    
-                characterTable[currentChar] = (short)glyphIndex;
-                glyphTable[glyphIndex] = new FSGlyph(convertShape(outline), new FSBounds(0, 0, 0, 0));
-                glyphTable[glyphIndex].advance = advance;
-    
-                if (font.hasUniformLineMetrics() == false)
-                {
-                    LineMetrics lineMetrics = font.getLineMetrics(new char[]
-                             {(char)currentChar }, 0, 1, fontContext);
-    
-                    ascent = 0; // Math.max(lineMetrics.getAscent() * 20, ascent);
-                    descent = 0; // Math.max(lineMetrics.getDescent() * 20, descent);
-                    leading = 0; // Math.max(lineMetrics.getLeading() * 20, leading);
-                }
-           }
-           glyphIndex++;
-           characterCode++;
-       }
-       orderTable[0] = (short)missingGlyph;
-    }
-    private Rectangle2D transformToEMSquare(Font font, FontRenderContext fontContext)
-    {
-        int numGlyphs = font.getNumGlyphs();
-        int characterCode = 0;
-        int glyphIndex = 0;
-
-        double x = 0.0;
-        double y = 0.0;
-        double w = 0.0;
-        double h = 0.0;
-
-        /*
-         * Scan through all the glyphs looking for glyphs that will fall outside 
-         * the left or bottom side of the EM Square once the glyph has been scaled.
-         */
-        while ((glyphIndex &lt; numGlyphs) &amp;&amp; (characterCode &lt; 65535)) 
-        {
-            char currentChar = (char) characterCode;
-
-            if (font.canDisplay(currentChar)) 
-            {
-                GlyphVector glyphVector = font.createGlyphVector(fontContext,
-                    new char[] { currentChar });
-                Rectangle2D bounds = glyphVector.getGlyphOutline(0).getBounds2D();
-    
-                x = Math.min(bounds.getX(), x);
-                y = Math.min(bounds.getY(), y);
-    
-                w = Math.max(bounds.getWidth(), w);
-                h = Math.max(bounds.getHeight(), h);
-    
-                glyphIndex++;
-            }
-            characterCode++;
-        }
-        return new Rectangle2D.Double(x, y, w, h);
-    }
-    /*
-     * Convert the outline of the glyph into a Flash shape.
-     *
-     * Values returned are expressed in pixels.
-     */
-    private FSShape convertShape(Shape glyph)
-    {
-        PathIterator pathIter = glyph.getPathIterator(null);
-        FSShapeConstructor path = new FSShapeConstructor();
-        
-        double[] coords = new double[6];
-
-        int xOrigin = 0;
-        int yOrigin = 0;
-
-        int currentX = 0;
-        int currentY = 0;
-
-        while (!pathIter.isDone())
-        {
-            int segmentType = pathIter.currentSegment(coords);
-
-            int p1 = (int) (coords[0]);
-            int p2 = (int) (coords[1]);
-            int p3 = (int) (coords[2]);
-            int p4 = (int) (coords[3]);
-            int p5 = (int) (coords[4]);
-            int p6 = (int) (coords[5]);
-
-            switch (segmentType)
-            {
-                case PathIterator.SEG_MOVETO:
-                    path.closePath();
-                    path.move(p1, p2);
-                    break;
-                case PathIterator.SEG_LINETO:
-                    path.line(p1, p2);
-                    break;
-                case PathIterator.SEG_QUADTO:
-                    path.curve(p1, p2, p3, p4);
-                    break;
-                case PathIterator.SEG_CUBICTO:
-                    path.curve(p1, p2, p3, p4, p5, p6);
-                    break;
-                case PathIterator.SEG_CLOSE:
-                    path.closePath();
-                    break;
-            }
-            pathIter.next();
-        }
-                
-        if (path.objects.size() &gt; 0)
-        {
-            FSShapeStyle style = (FSShapeStyle)path.objects.get(0);
-            style.setLineStyle(0);
-            style.setAltFillStyle(1);
-        }
-        return path.shape();
-    }
-    /*
-     Generate the bounding rectangle for the text. 
-     */
-    private FSBounds boundsForText(int[] glyphIndices, int[] advances, int fontSize)
-    {
-        float scaleEMSquare = fontSize / 1024.0f;
-
-        int minX = 0;
-        int maxX = 0;
-        int minY = 0;
-        int maxY = 0;
-        boolean any = false;
-        
-        int advance = 0;
-
-        for (int i = 0; i &lt; glyphIndices.length; i++)
-        {
-           ArrayList array = null;
-
-      /* Patch added as there are null Glyphs decoded from the font. */
-      if (glyphTable[orderTable[glyphIndices[i]]] == null)
-          array = glyphTable[missingGlyph].shape.getObjects();
-      else
-          array = glyphTable[orderTable[glyphIndices[i]]].shape.getObjects();
-      /* end of patch */
-
-            int x = advance;
-            int y = 0;
-
-            for (Iterator j = array.iterator(); j.hasNext();)
-            {
-                FSShapeObject currentObject = (FSShapeObject) j.next();
-
-                if (currentObject instanceof FSShapeStyle)
-                {
-                    FSShapeStyle style = (FSShapeStyle) currentObject;
-
-                    x = advance + style.getMoveX();
-                    y = style.getMoveY();
-                }
-                else if (currentObject instanceof FSLine)
-                {
-                    FSLine line = (FSLine) currentObject;
-
-                    x += line.getX();
-                    y += line.getY();
-                }
-                else if (currentObject instanceof FSCurve)
-                {
-                    FSCurve curve = (FSCurve) currentObject;
-
-                    x += (curve.getControlX() + curve.getAnchorX());
-                    y += (curve.getControlY() + curve.getAnchorY());
-                }
-                
-                if (any) {
-                    minX = Math.min(minX, x);
-                    maxX = Math.max(maxX, x);
-                    minY = Math.min(minY, y);
-                    maxY = Math.max(maxY, y);
-                } else {
-                    minX = maxX = x;
-                    minY = maxY = y;
-                    any = true;
-                }
-            }
-            advance += advances[i] / scaleEMSquare;
-        }
-
-        minX = (int) (minX * scaleEMSquare);
-        maxX = (int) (maxX * scaleEMSquare);
-        minY = (int) (minY * scaleEMSquare) + scaleBaseline(scaleEMSquare);
-        maxY = (int) (maxY * scaleEMSquare) + scaleBaseline(scaleEMSquare);
-        return new FSBounds(minX, minY, maxX, maxY);
-    }
-    /*
-     Generate and array of FSCharacter objects from the glyph codes and advances.
-     */
-    private ArrayList charactersForGlyphs(int[] codes, int[] advances)
-    {
-        ArrayList characters = new ArrayList(codes.length);
-
-        for (int i = 0; i &lt; codes.length; i++)
-            characters.add(new FSCharacter(codes[i], advances[i]));
-
-        return characters;
-    }
-    /*
-     Indicates whether or not this FSTextConstructor can display a specified Unicode character. 
-     This method returns true if the character can be displayed, false if not.
-     */
-    private boolean canDisplay(char c)
-    {
-        boolean canDisplay = false;
-
-        if (c &lt; characterTable.length &amp;&amp; characterTable[c] != 0)
-           canDisplay = true;
-
-        return canDisplay;
-    }
-    /*
-     Return an array of indexes into the array of glyphs that represent each of the characters 
-     in the string.
-     */
-    private int[] glyphIndicesForString(String aString)
-    {
-        int[] glyphCodes = new int[aString.length()];
-        
-        for (int i = 0; i &lt; aString.length(); i++)
-        {
-            char character = aString.charAt(i);
-            int glyphIndex = characterTable[character];
-            int index = 0;
-            
-            for (index=0; index&lt;65536; index++)
-            {
-                if (orderTable[index] == glyphIndex)
-                    break;
-                else if (orderTable[index] == -1)
-                {
-                    orderTable[index] = (short)glyphIndex;
-                    break;
-                }
-            }
-            glyphCodes[i] = index;
-        }
-        return glyphCodes;
-    }
-    /*
-     Return an array of advances for the glyphs that represent each of the characters in the string
-     */
-    private int[] advancesForGlyphIndices(int[] glyphCodes, float scaleFactor)
-    {
-        int[] glyphAdvances = new int[glyphCodes.length];
-
-        for (int i=0; i&lt;glyphCodes.length; i++)
-        {
-            int index = orderTable[glyphCodes[i]];
-            
-            glyphAdvances[i] = (int) (glyphTable[index].advance * scaleFactor);
-        }
-
-        return glyphAdvances;
-    }
-    /*
-     Return a new baseline scaled according to the new font size.
-     */
-    private int scaleBaseline(float scaleFactor)
-    {
-        int newBaseline = (int) (baseline * scaleFactor);
-        newBaseline += (20 - (newBaseline % 20));
-
-        return newBaseline;
-    }
-    private byte[] dataFromFile(String filename) throws FileNotFoundException, IOException
-    {
-        File aFile = new File(filename);
-        FileInputStream imageContents = null;
-        
-        byte[] bytes = new byte[(int)aFile.length()];
-        
-        imageContents = new FileInputStream(aFile);            
-        imageContents.read(bytes);
-        imageContents.close();
-
-        return bytes;
-    }
-    private void decodeOpenTypeFont(String fontName) throws IOException, DataFormatException
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, dataFromFile(fontName));
-        
-        float version = coder.readFixedBits(32, 16);
-
-        int tableCount = coder.readWord(2, false);
-        int searchRange = coder.readWord(2, false);
-        int entrySelector = coder.readWord(2, false);
-        int rangeShift = coder.readWord(2, false);
-        
-        int os_2Offset = 0;
-        int headOffset = 0;
-        int hheaOffset = 0;
-        int maxpOffset = 0;
-        int locaOffset = 0;
-        int cmapOffset = 0;
-        int glyfOffset = 0;
-        int hmtxOffset = 0;
-        int nameOffset = 0;
-        
-        int os_2Length = 0;
-        int headLength = 0;
-        int hheaLength = 0;
-        int maxpLength = 0;
-        int locaLength = 0;
-        int cmapLength = 0;
-        int hmtxLength = 0;
-        int nameLength = 0;
-        int glyfLength = 0;
-
-        int chunkType = 0;
-        int checksum = 0;
-        int offset = 0;
-        int length = 0;
-        
-        for (int i=0; i&lt;tableCount; i++) 
-        {
-            chunkType = coder.readWord(4, false);
-            checksum = coder.readWord(4, false);
-            offset = coder.readWord(4, false) &lt;&lt; 3;
-            length = coder.readWord(4, false);
-            
-            /* 
-             * Chunks are encoded in ascending alphabetical order so
-             * the location of the tables is mapped before they are 
-             * decoded since the glyphs come before the loca or maxp
-             * table which identify how many glyphs are encoded.
-             */
-            switch (chunkType)
-            {
-                case OS_2: os_2Offset = offset; os_2Length = length; break;
-                case CMAP: cmapOffset = offset; cmapLength = length; break;
-                case GLYF: glyfOffset = offset; glyfLength = length; break;
-                case HEAD: headOffset = offset; headLength = length; break;
-                case HHEA: hheaOffset = offset; hheaLength = length; break;
-                case HMTX: hmtxOffset = offset; hmtxLength = length; break;
-                case LOCA: locaOffset = offset; locaLength = length; break;
-                case MAXP: maxpOffset = offset; maxpLength = length; break;
-                case NAME: nameOffset = offset; nameLength = length; break;
-                default: break;
-            }
-        }
-        
-        int bytesRead = 0;
-
-        if (maxpOffset != 0) { coder.setPointer(maxpOffset); decodeMAXP(coder); bytesRead = (coder.getPointer() - maxpOffset) &gt;&gt; 3; }
-        if (os_2Offset != 0) { coder.setPointer(os_2Offset); decodeOS_2(coder); bytesRead = (coder.getPointer() - os_2Offset) &gt;&gt; 3; }
-        if (headOffset != 0) { coder.setPointer(headOffset); decodeHEAD(coder); bytesRead = (coder.getPointer() - headOffset) &gt;&gt; 3; }
-        if (hheaOffset != 0) { coder.setPointer(hheaOffset); decodeHHEA(coder); bytesRead = (coder.getPointer() - hheaOffset) &gt;&gt; 3; }
-        if (nameOffset != 0) { coder.setPointer(nameOffset); decodeNAME(coder); bytesRead = (coder.getPointer() - nameOffset) &gt;&gt; 3; }
-        
-        glyphTable = new FSGlyph[numberOfGlyphs];
-        
-        // Decode glyphs first so objects will be created.
-        if (locaOffset != 0) { coder.setPointer(locaOffset); decodeGlyphs(coder, glyfOffset); bytesRead = (coder.getPointer() - locaOffset) &gt;&gt; 3; }
-        if (hmtxOffset != 0) { coder.setPointer(hmtxOffset); decodeHMTX(coder); bytesRead = (coder.getPointer() - hmtxOffset) &gt;&gt; 3; }
-        if (cmapOffset != 0) { coder.setPointer(cmapOffset); decodeCMAP(coder); bytesRead = (coder.getPointer() - cmapOffset) &gt;&gt; 3; }
-
-        orderTable[0] = characterTable[(short)' '];
-        
-        for (int i=0; i&lt;characterTable.length; i++)
-        {
-            if (characterTable[i] &gt;= glyphTable.length)
-                characterTable[i] = (short)missingGlyph;
-        }
-        /*
-         * Change the space character so no shape is drawn.
-         */
-        int spaceIndex = characterTable[(short)' '];
-        
-        glyphTable[spaceIndex].shape = new FSShape();
-        glyphTable[spaceIndex].advance = 250;
-    }
-    
-    private void decodeHEAD(FSCoder coder)
-    {
-        byte[] date = new byte[8];
-    
-        coder.readFixedBits(32, 16); // table version 
-        coder.readFixedBits(32, 16); // font version 
-        coder.readWord(4, false); // checksum adjustment
-        coder.readWord(4, false); // magic number
-        coder.readBits(1, false); // baseline at y=0
-        coder.readBits(1, false); // side bearing at x=0;
-        coder.readBits(1, false); // instructions depend on point size
-        coder.readBits(1, false); // force ppem to integer values
-        coder.readBits(1, false); // instructions may alter advance
-        coder.readBits(11, false);
-        attributes[SCALE] = coder.readWord(2, false) / 1024;  // units per em
-
-        if (attributes[SCALE] == 0) 
-            attributes[SCALE] = 1;
-
-        coder.readBytes(date); // number of seconds since midnight, Jan 01 1904
-        coder.readBytes(date); // number of seconds since midnight, Jan 01 1904
-    
-        coder.readWord(2, true); // xMin for all glyph bounding boxes
-        coder.readWord(2, true); // yMin for all glyph bounding boxes
-        coder.readWord(2, true); // xMax for all glyph bounding boxes
-        coder.readWord(2, true); // yMax for all glyph bounding boxes
-    
-        /*
-         * Next two byte define font appearance on Macs, values are 
-         * specified in the OS/2 table 
-         */ 
-        isBold = coder.readBits(1, false) != 0;
-        isItalic = coder.readBits(1, false) != 0;
-        coder.readBits(14, false); // 
-
-        coder.readWord(2, false);// smallest readable size in pixels
-        coder.readWord(2, true); // font direction hint
-        attributes[GLYPH_OFFSET_SIZE] = coder.readWord(2, true); 
-        coder.readWord(2, true); // glyph data format
-    }
-    
-    private void decodeHHEA(FSCoder coder)
-    {
-        coder.readFixedBits(32, 16); // table version
-    
-        ascent = coder.readWord(2, true);
-        descent = coder.readWord(2, true);
-        leading = coder.readWord(2, true);
-        
-        coder.readWord(2, false); // maximum advance in the htmx table
-        coder.readWord(2, true); // minimum left side bearing in the htmx table
-        coder.readWord(2, true); // minimum right side bearing in the htmx table
-        coder.readWord(2, true); // maximum extent
-        coder.readWord(2, true); // caret slope rise 
-        coder.readWord(2, true); // caret slope run
-        coder.readWord(2, true); // caret offset
-    
-        coder.readWord(2, false); // reserved
-        coder.readWord(2, false); // reserved
-        coder.readWord(2, false); // reserved
-        coder.readWord(2, false); // reserved
-    
-        coder.readWord(2, true); // metric data format 
-        
-        attributes[NUMBER_OF_METRICS] = coder.readWord(2, false);    
-    }
-    
-    private void decodeOS_2(FSCoder coder)
-    {
-        byte[] panose = new byte[10];
-        int[] unicodeRange = new int[4];
-        byte[] vendor = new byte[4];
-
-        int version = coder.readWord(2, false); // version
-        coder.readWord(2, true); // average character width
-        
-        switch (coder.readWord(2, false)) // weight class
-        {
-            case FONT_WEIGHT_BOLD: isBold = true; break;
-            default: break;
-        }
-
-        coder.readWord(2, false); // width class
-        coder.readWord(2, false); // embedding licence
-        
-        coder.readWord(2, true); // subscript x size
-        coder.readWord(2, true); // subscript y size
-        coder.readWord(2, true); // subscript x offset
-        coder.readWord(2, true); // subscript y offset
-        coder.readWord(2, true); // superscript x size
-        coder.readWord(2, true); // superscript y size
-        coder.readWord(2, true); // superscript x offset
-        coder.readWord(2, true); // superscript y offset
-        coder.readWord(2, true); // width of strikeout stroke
-        coder.readWord(2, true); // strikeout stroke position
-        coder.readWord(2, true); // font family class
-    
-        coder.readBytes(panose);
-        
-        for (int i=0; i&lt;4; i++)
-            unicodeRange[i] = coder.readWord(4, false);
-            
-        coder.readBytes(vendor); // font vendor identification
-        
-        isItalic = coder.readBits(1, false) != 0;
-        coder.readBits(4, false);
-        isBold = coder.readBits(1, false) != 0;
-        coder.readBits(10, false);
-        
-        coder.readWord(2, false); // first unicode character code
-        coder.readWord(2, false); // last unicode character code
-        
-        ascent = coder.readWord(2, false);
-        descent = coder.readWord(2, false);
-        leading = coder.readWord(2, false);
-    
-        coder.readWord(2, false); // ascent in Windows
-        coder.readWord(2, false); // descent in Windows
-        
-        if (version &gt; 0)
-        {
-            coder.readWord(4, false); // code page range 
-            coder.readWord(4, false); // code page range
-
-            if (version &gt; 1)
-            {
-                coder.readWord(2, true); // height
-                coder.readWord(2, true); // Capitals height
-                missingGlyph = coder.readWord(2, false);
-                coder.readWord(2, false); // break character
-                coder.readWord(2, false); // maximum context
-            }
-        }
-    }
-    
-    private void decodeNAME(FSCoder coder)
-    {
-    	int stringTableBase = coder.getPointer() &gt;&gt;&gt; 3;
-    	
-        int format = coder.readWord(2, false);
-        int numberOfNameRecords = coder.readWord(2, false);
-        int stringTable = coder.readWord(2, false) + stringTableBase;
-        
-        for (int i=0; i&lt;numberOfNameRecords; i++) 
-        {
-            int platformId = coder.readWord(2, false);
-            int encodingId = coder.readWord(2, false);
-            int languageId = coder.readWord(2, false);
-            int nameId = coder.readWord(2, false);
-            
-            int stringLength = coder.readWord(2, false);
-            int stringOffset = coder.readWord(2, false);
-            
-            int current = coder.getPointer();
-            
-            coder.setPointer((stringTable+stringOffset) &lt;&lt; 3);
-            byte[] b = new byte[stringLength];
-            coder.readBytes(b);
-            
-            String nameEncoding = &quot;UTF-8&quot;;
-            
-            if (platformId == 0) // Unicode
-            {
-                nameEncoding = &quot;UTF-16&quot;;
-            }
-            else if (platformId == 1) // Macintosh
-            {
-                if (encodingId == 0 &amp;&amp; languageId == 0)
-                    nameEncoding = &quot;ISO8859-1&quot;;
-            }
-            else if (platformId == 3) // Microsoft
-            {
-                switch (encodingId)
-                {
-                    case 1: nameEncoding = &quot;UTF-16&quot;; break;
-                    case 2: nameEncoding = &quot;SJIS&quot;; break;
-                    case 4: nameEncoding = &quot;Big5&quot;; break;
-                }
-            }
-            
-            try
-            {
-                if (nameId == 1)
-                    name = new String(b, nameEncoding);
-            }
-            catch (UnsupportedEncodingException e)
-            {
-                name = new String(b);
-            } 
-            coder.setPointer(current);
-        }
-    }
-    
-    private void decodeMAXP(FSCoder coder)
-    {
-        float version = coder.readFixedBits(32, 16);
-        numberOfGlyphs = coder.readWord(2, false);
-        
-        if (version == 1.0)
-        {
-            coder.readWord(2, false); // maximum number of points in a simple glyph
-            coder.readWord(2, false); // maximum number of contours in a simple glyph
-            coder.readWord(2, false); // maximum number of points in a composite glyph
-            coder.readWord(2, false); // maximum number of contours in a composite glyph
-            coder.readWord(2, false); // maximum number of zones
-            coder.readWord(2, false); // maximum number of point in Z0
-            coder.readWord(2, false); // number of storage area locations
-            coder.readWord(2, false); // maximum number of FDEFs
-            coder.readWord(2, false); // maximum number of IDEFs
-            coder.readWord(2, false); // maximum stack depth
-            coder.readWord(2, false); // maximum byte count for glyph instructions
-            coder.readWord(2, false); // maximum number of components for composite glyphs
-            coder.readWord(2, false); // maximum level of recursion
-        }
-    }
-    private void decodeHMTX(FSCoder coder)
-    {
-        int i = 0;
-        
-        for (i=0; i&lt;attributes[NUMBER_OF_METRICS]; i++) 
-        {
-            glyphTable[i].advance = (coder.readWord(2, false) / attributes[SCALE]);
-            coder.readWord(2, true); // left side bearing
-        }
-        
-        int advance = glyphTable[i-1].advance;
-
-        for (; i&lt;numberOfGlyphs; i++)
-            glyphTable[i].advance = advance;
-
-        for (; i&lt;numberOfGlyphs; i++)
-            coder.readWord(2, true);
-    }
-    
-    private void decodeCMAP(FSCoder coder)
-    {
-        int tableStart = coder.getPointer();
-        
-        int version = coder.readWord(2, false);
-        int numberOfTables = coder.readWord(2, false);
-        
-        int platformId = 0;
-        int encodingId = 0;
-        int offset = 0;
-        int current = 0;
-        
-        int format = 0;
-        int length = 0;
-        int language = 0;
-        
-        int segmentCount = 0;
-        int[] startCount = null;
-        int[] endCount = null;
-        int[] delta = null;
-        int[] range = null;
-        int[] rangeAdr = null;
-        
-        int i = 0;
-        int n = 0;
-        
-        for (i=0; i&lt;numberOfTables; i++)
-        {
-            platformId = coder.readWord(2, false);
-            encodingId = coder.readWord(2, false);
-            offset = coder.readWord(4, false) &lt;&lt; 3;
-            current = coder.getPointer();
-            
-            if (platformId == 0) // Unicode
-            {
-                encoding = FSSpan.Unicode;
-            }
-            else if (platformId == 1) // Macintosh
-            {
-                switch (encodingId)
-                {
-                    case 1: encoding = FSSpan.SJIS; break;
-                    default: encoding = FSSpan.ANSI; break;
-                }
-                    
-            }
-            else if (platformId == 3) // Microsoft
-            {
-                switch (encodingId)
-                {
-                    case 1: encoding = FSSpan.Unicode; break;
-                    case 2: encoding = FSSpan.SJIS; break;
-                    default: encoding = FSSpan.ANSI; break;
-                }
-            }
-
-            coder.setPointer(tableStart+offset);
-            
-            format = coder.readWord(2, false);
-            length = coder.readWord(2, false);
-            language = coder.readWord(2, false);
-            
-            switch (format) 
-            {
-                case 0: 
-                    for (n=0; n&lt;256; n++)
-                        characterTable[n] = (short)coder.readByte();
-                    break;
-                case 4:
-                    segmentCount = coder.readWord(2, false) / 2;
-    
-                    coder.readWord(2, false); // search range
-                    coder.readWord(2, false); // entry selector
-                    coder.readWord(2, false); // range shift
-
-                    startCount = new int[segmentCount];
-                    endCount = new int[segmentCount];
-                    delta = new int[segmentCount];
-                    range = new int[segmentCount];
-                    rangeAdr = new int[segmentCount];
-                    
-                    for (n=0; n&lt;segmentCount; n++)
-                        endCount[n] = coder.readWord(2, false);
-
-                    coder.readWord(2, false); // reserved padding
-                
-                    for (n=0; n&lt;segmentCount; n++)
-                        startCount[n] = coder.readWord(2, false);
-                
-                    for (n=0; n&lt;segmentCount; n++)
-                        delta[n] = coder.readWord(2, true);
-                
-                    for (n=0; n&lt;segmentCount; n++)
-                    {
-                        rangeAdr[n] = coder.getPointer() &gt;&gt; 3;
-                        range[n] = coder.readWord(2, true);
-                    }
-
-                    int glyphIndex = 0;
-                    int location = 0;
-                            
-                    for (n=0; n&lt;segmentCount; n++)
-                    {
-                        for (int code=startCount[n]; code&lt;=endCount[n]; code++)
-                        {
-                            if (range[n] != 0)
-                            {
-                                location = rangeAdr[n] + range[n] + ((code - startCount[n]) &lt;&lt; 1);
-                                coder.setPointer(location &lt;&lt; 3);
-                                glyphIndex = coder.readWord(2, false);
-                                
-                                if (glyphIndex != 0)
-                                    glyphIndex = (glyphIndex + delta[n]) % 65536;
-                            }
-                            else
-                                glyphIndex = (delta[n] + code) % 65536;
-
-                            characterTable[code] = (short)glyphIndex;
-                        }
-                    }
-                    break;
-                case 2:
-                case 6: 
-                    System.err.println(&quot;Unimplemented encoding table format: &quot; + format); 
-                    break;
-                default: 
-                    System.err.println(&quot;Illegal value for encoding table format: &quot; + format); 
-                    break;
-            }
-            coder.setPointer(current);
-        }
-        encoding = FSSpan.SJIS;
-    }
-    private void decodeGlyphs(FSCoder coder, int glyfOffset)
-    {
-        int numberOfContours = 0;
-        int glyphStart = 0;
-        int start = coder.getPointer();
-        int end = 0;
-        int[] offsets = new int[numberOfGlyphs];
-        
-        if (attributes[GLYPH_OFFSET_SIZE] == ITLF_SHORT)
-            offsets[0] = glyfOffset + (coder.readWord(2, false)*2 &lt;&lt; 3);
-        else
-            offsets[0] = glyfOffset + (coder.readWord(4, false) &lt;&lt; 3);
-
-        for (int i=1; i&lt;numberOfGlyphs; i++)
-        {
-            if (attributes[GLYPH_OFFSET_SIZE] == ITLF_SHORT)
-                offsets[i] = glyfOffset + (coder.readWord(2, false)*2 &lt;&lt; 3);
-            else
-                offsets[i] = glyfOffset + (coder.readWord(4, false) &lt;&lt; 3);
-            
-            if (offsets[i] == offsets[i-1])
-                offsets[i-1] = 0;
-        }
-        
-        end = coder.getPointer();
-            
-        for (int i=0; i&lt;numberOfGlyphs; i++)
-        {
-            if (offsets[i] == 0)
-            {
-                glyphTable[i] = new FSGlyph(new FSShape(),new FSBounds(0, 0, 0, 0));
-            }
-            else
-            {
-                coder.setPointer(offsets[i]);
-                
-                numberOfContours = coder.readWord(2, true);
-                
-                if (numberOfContours &gt;= 0)
-                    decodeSimpleGlyph(coder, i, numberOfContours);
-            }
-        }
-        
-        coder.setPointer(start);
-
-        for (int i=0; i&lt;numberOfGlyphs; i++)
-        {
-            if (offsets[i] != 0)
-            {
-                coder.setPointer(offsets[i]);
-            
-                if (coder.readWord(2, true) == -1)
-                    decodeCompositeGlyph(coder, i);
-            }
-        }
-        coder.setPointer(end);
-    }
-    private void decodeSimpleGlyph(FSCoder coder, int glyphIndex, int numberOfContours)
-    {
-        int xMin = coder.readWord(2, true) / attributes[SCALE];
-        int yMin = coder.readWord(2, true) / attributes[SCALE];
-        int xMax = coder.readWord(2, true) / attributes[SCALE];
-        int yMax = coder.readWord(2, true) / attributes[SCALE];
-        
-        int[] endPtsOfContours = new int[numberOfContours];
-
-        for (int i=0; i&lt;numberOfContours; i++)
-            endPtsOfContours[i] = coder.readWord(2, false);
-
-        int instructionCount = coder.readWord(2, false);   
-        int[] instructions = new int[instructionCount];
-            
-        for (int i=0; i&lt;instructionCount; i++)
-            instructions[i] = coder.readByte();
-                
-        int numberOfPoints = (numberOfContours == 0) ? 0 : endPtsOfContours[endPtsOfContours.length-1]+1;
-        
-        int[] flags = new int[numberOfPoints];
-        int[] xCoordinates = new int[numberOfPoints];
-        int[] yCoordinates = new int[numberOfPoints];
-        boolean[] onCurve = new boolean[numberOfPoints];
-        
-        int repeatCount = 0;
-        int repeatFlag  = 0;
-            
-        for (int i=0; i&lt;numberOfPoints; i++) 
-        {
-            if (repeatCount &gt; 0) 
-            {
-                flags[i] = repeatFlag;
-                repeatCount--;
-            } 
-            else 
-            {
-                flags[i] = coder.readByte();
-                    
-                if ((flags[i] &amp; REPEAT_FLAG) &gt; 0) 
-                {
-                    repeatCount = coder.readByte();
-                    repeatFlag = flags[i];
-                }
-            }
-            onCurve[i] = (flags[i] &amp; ON_CURVE) &gt; 0;
-        }
-
-        int last = 0;
-
-        for (int i=0; i&lt;numberOfPoints; i++) 
-        {        
-            if ((flags[i] &amp; X_SHORT) &gt; 0) 
-            {
-                if ((flags[i] &amp; X_POSITIVE) &gt; 0)
-                    last = xCoordinates[i] = last + coder.readByte();
-                else 
-                    last = xCoordinates[i] = last - coder.readByte();
-            } 
-            else 
-            {
-                if ((flags[i] &amp; X_SAME) &gt; 0)
-                    last = xCoordinates[i] = last;
-                else
-                    last = xCoordinates[i] = last + coder.readWord(2, true);
-            }
-        }
-
-        last = 0;
-
-        for (int i = 0; i &lt; numberOfPoints; i++) 
-        {
-            if ((flags[i] &amp; Y_SHORT) &gt; 0)
-            {
-                if ((flags[i] &amp; Y_POSITIVE) &gt; 0)
-                    last = yCoordinates[i] = last + coder.readByte();
-                else 
-                    last = yCoordinates[i] = last - coder.readByte();
-            } 
-            else 
-            {
-                if ((flags[i] &amp; Y_SAME) &gt; 0)
-                    last = yCoordinates[i] = last;
-                else 
-                    last = yCoordinates[i] = last + coder.readWord(2, true);
-            }
-        }
-            
-        /*
-         * Convert the coordinates into a shape
-         */
-        FSShapeConstructor path = new FSShapeConstructor();
-        
-        boolean contourStart = true;
-        boolean offPoint = false;
-        
-        int contour = 0;
-        
-        int x = 0;
-        int y = 0;
-        
-        int prevX = 0;
-        int prevY = 0;
-        
-        int initX = 0;
-        int initY = 0;
-        
-        for (int i=0; i&lt;numberOfPoints; i++)
-        {
-            x = xCoordinates[i] / attributes[SCALE];
-            y = yCoordinates[i] / attributes[SCALE];
-            
-            if (onCurve[i])
-            {
-                if (contourStart)
-                {
-                    path.moveForFont(x, -y);
-                    contourStart = false;
-                    initX = x;
-                    initY = y;
-                }
-                else if (offPoint)
-                {
-                    path.curve(prevX, -prevY, x, -y);
-                    offPoint = false;
-                }
-                else
-                {
-                    path.line(x, -y);
-                }
-            }
-            else
-            {
-                if (offPoint == true)
-                    path.curve(prevX, -prevY, (x+prevX)/2, -(y+prevY)/2);
-
-                prevX = x;
-                prevY = y;
-                offPoint = true;
-            }
-            
-            if (i == endPtsOfContours[contour])
-            {
-                if (offPoint)
-                {
-                    path.curve(x, -y, initX, -initY);
-                }
-                else
-                {
-                    path.closePath();
-                } 
-                contourStart = true;
-                offPoint = false;
-                prevX = 0;
-                prevY = 0;
-                contour++;
-            }
-        }
-        
-        glyphTable[glyphIndex] = new FSGlyph(path.shape(),new FSBounds(xMin, -yMax, xMax, -yMin));
-
-        glyphTable[glyphIndex].xCoordinates = xCoordinates;
-        glyphTable[glyphIndex].yCoordinates = yCoordinates;
-        glyphTable[glyphIndex].onCurve = onCurve;
-        glyphTable[glyphIndex].endPoints = endPtsOfContours;
-    }
-    
-    private void decodeCompositeGlyph(FSCoder coder, int glyphIndex)
-    {
-        FSShape shape = new FSShape();
-        FSCoordTransform transform = null;
-                        
-        int xMin = coder.readWord(2, true);
-        int yMin = coder.readWord(2, true);
-        int xMax = coder.readWord(2, true);
-        int yMax = coder.readWord(2, true);
-        
-        FSGlyph points = null;
-        
-        int numberOfPoints = 0;
-        
-        int[] endPtsOfContours = null;
-        int[] xCoordinates = null;
-        int[] yCoordinates = null;
-        boolean[] onCurve = null;
-        
-        int flags = 0;
-        int sourceGlyph = 0;
-        
-        int xOffset = 0;
-        int yOffset = 0;
-        
-        int sourceIndex = 0;
-        int destIndex = 0;
-
-        do {
-            transform = new FSCoordTransform();
-            
-            flags = coder.readWord(2, false);
-            sourceGlyph = coder.readWord(2, false);
-            
-            if (sourceGlyph &gt;= glyphTable.length || glyphTable[sourceGlyph] == null)
-            {
-                glyphTable[glyphIndex] = new FSGlyph();            
-                glyphTable[glyphIndex].bounds = new FSBounds(xMin, yMin, xMax, yMax);
-                return;
-            }
-            
-            points = glyphTable[sourceGlyph];
-            numberOfPoints = points.xCoordinates.length;
-            
-            endPtsOfContours = new int[points.endPoints.length];
-            
-            for (int i=0; i&lt;points.endPoints.length; i++)
-                endPtsOfContours[i] = points.endPoints[i];
-                
-            xCoordinates = new int[numberOfPoints];
-            
-            for (int i=0; i&lt;numberOfPoints; i++)
-                xCoordinates[i] = points.xCoordinates[i];
-                
-            yCoordinates = new int[numberOfPoints];
-            
-            for (int i=0; i&lt;numberOfPoints; i++)
-                yCoordinates[i] = points.yCoordinates[i];
-                
-            onCurve = new boolean[numberOfPoints];
-            
-            for (int i=0; i&lt;numberOfPoints; i++)
-                onCurve[i] = points.onCurve[i];
-            
-            if ((flags &amp; ARG_1_AND_2_ARE_WORDS) == 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) == 0)
-            {
-                destIndex = coder.readByte();
-                sourceIndex = coder.readByte();
-                
-                //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
-                //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
-                transform.translate(0, 0);
-            }
-            else if ((flags &amp; ARG_1_AND_2_ARE_WORDS) == 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) &gt; 0)
-            {
-                xOffset = (coder.readByte() &lt;&lt; 24) &gt;&gt; 24;
-                yOffset = (coder.readByte() &lt;&lt; 24) &gt;&gt; 24;
-                transform.translate(xOffset, yOffset);
-            }
-            else if ((flags &amp; ARG_1_AND_2_ARE_WORDS) &gt; 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) == 0)
-            {
-                destIndex = coder.readWord(2, false);
-                sourceIndex = coder.readWord(2, false);
-                
-                //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
-                //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
-                transform.translate(0, 0);
-            }
-            else
-            {
-                xOffset = coder.readWord(2, true);
-                yOffset = coder.readWord(2, true);
-                transform.translate(xOffset, yOffset);
-            }
-            
-            
-            if ((flags &amp; WE_HAVE_A_SCALE) &gt; 0) 
-            {
-                float scaleXY = coder.readFixedBits(16, 14);
-                transform.scale(scaleXY, scaleXY);
-            }
-            else if ((flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) &gt; 0)
-            {
-                float scaleX = coder.readFixedBits(16, 14);
-                float scaleY = coder.readFixedBits(16, 14);
-                transform.scale(scaleX, scaleY);
-            }
-            else if ((flags &amp; WE_HAVE_A_TWO_BY_TWO) &gt; 0) 
-            {
-                float scaleX = coder.readFixedBits(16, 14);
-                float scale01 = coder.readFixedBits(16, 14);
-                float scale10 = coder.readFixedBits(16, 14);
-                float scaleY = coder.readFixedBits(16, 14);
-                
-                float[][] matrix = new float[][] { 
-                    {scaleX, scale01, 0.0f}, 
-                    {scale10, scaleY, 0.0f}, 
-                    {0.0f, 0.0f, 1.0f}
-                };
-
-                transform.composite(new FSCoordTransform(matrix));
-            }
-            
-            for (int i=0; i&lt;numberOfPoints; i++)
-            {
-                int[] xy =  transform.transformPoint(xCoordinates[i], yCoordinates[i]);
-                
-                xCoordinates[i] = xy[0];
-                yCoordinates[i] = xy[1];
-            }
-
-            FSShapeConstructor path = new FSShapeConstructor();
-        
-            boolean contourStart = true;
-            boolean offPoint = false;
-        
-            int contour = 0;
-        
-            int x = 0;
-            int y = 0;
-        
-            int prevX = 0;
-            int prevY = 0;
-        
-            int initX = 0;
-            int initY = 0;
-        
-            for (int i=0; i&lt;numberOfPoints; i++)
-            {
-                x = xCoordinates[i] / attributes[SCALE];
-                y = yCoordinates[i] / attributes[SCALE];
-            
-                if (onCurve[i])
-                {
-                    if (contourStart)
-                    {
-                        path.moveForFont(x, -y);
-                        contourStart = false;
-                        initX = x;
-                        initY = y;
-                    }
-                    else if (offPoint)
-                    {
-                        path.curve(prevX, -prevY, x, -y);
-                        offPoint = false;
-                    }
-                    else
-                    {
-                        path.line(x, -y);
-                    }
-                }
-                else
-                {
-                    if (offPoint == true)
-                        path.curve(prevX, -prevY, (x+prevX)/2, -(y+prevY)/2);
-
-                    prevX = x;
-                    prevY = y;
-                    offPoint = true;
-                }
-            
-                if (i == endPtsOfContours[contour])
-                {
-                    if (offPoint)
-                    {
-                        path.curve(x, -y, initX, -initY);
-                    }
-                    else
-                    {
-                        path.closePath();
-                    } 
-                    contourStart = true;
-                    offPoint = false;
-                    prevX = 0;
-                    prevY = 0;
-                    contour++;
-                }
-            }
-            shape.getObjects().addAll(path.shape().getObjects());
-              
-        } while ((flags &amp; MORE_COMPONENTS) &gt; 0);
-
-        glyphTable[glyphIndex] = new FSGlyph(shape, new FSBounds(xMin, yMin, xMax, yMax));
-
-        glyphTable[glyphIndex].xCoordinates = xCoordinates;
-        glyphTable[glyphIndex].yCoordinates = yCoordinates;
-        glyphTable[glyphIndex].onCurve = onCurve;
-        glyphTable[glyphIndex].endPoints = endPtsOfContours;
-    }
-}

Added: dev/dev-2-4/src/com/flagstone/transform/util/Font.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/Font.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/Font.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,1417 @@
+package com.flagstone.transform.util;
+
+import java.awt.font.FontRenderContext;
+import java.awt.font.GlyphVector;
+import java.awt.font.LineMetrics;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.PathIterator;
+import java.awt.geom.Rectangle2D;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import java.util.zip.DataFormatException;
+
+import com.flagstone.transform.FSBounds;
+import com.flagstone.transform.FSCoder;
+import com.flagstone.transform.FSCoordTransform;
+import com.flagstone.transform.FSDefineFont2;
+import com.flagstone.transform.FSKerning;
+import com.flagstone.transform.FSMovie;
+import com.flagstone.transform.FSMovieObject;
+import com.flagstone.transform.FSShape;
+import com.flagstone.transform.FSShapeStyle;
+import com.flagstone.transform.FSSpan;
+
+public class Font
+{
+    private static final int OS_2 = 0x4F532F32;
+    private static final int HEAD = 0x68656164;
+    private static final int HHEA = 0x68686561;
+    private static final int MAXP = 0x6D617870;
+    private static final int LOCA = 0x6C6F6361;
+    private static final int CMAP = 0x636D6170;
+    private static final int HMTX = 0x686D7478;
+    private static final int NAME = 0x6E616D65;
+    private static final int GLYF = 0x676C7966;
+
+    private static final int ITLF_SHORT = 0;
+    private static final int ITLF_LONG  = 1;
+    
+    private static final int FONT_WEIGHT_THIN       = 100;
+    private static final int FONT_WEIGHT_EXTRALIGHT = 200;
+    private static final int FONT_WEIGHT_LIGHT      = 300;
+    private static final int FONT_WEIGHT_NORMAL     = 400;
+    private static final int FONT_WEIGHT_MEDIUM     = 500;
+    private static final int FONT_WEIGHT_SEMIBOLD   = 600;
+    private static final int FONT_WEIGHT_BOLD       = 700;
+    private static final int FONT_WEIGHT_EXTRABOLD  = 800;
+    private static final int FONT_WEIGHT_BLACK      = 900;
+    
+    private static final int ON_CURVE    = 0x01;
+    private static final int X_SHORT     = 0x02;
+    private static final int Y_SHORT     = 0x04;
+    private static final int REPEAT_FLAG = 0x08;
+    private static final int X_SAME      = 0x10;
+    private static final int Y_SAME      = 0x20;
+    private static final int X_POSITIVE  = 0x10;
+    private static final int Y_POSITIVE  = 0x20;
+    
+    private static final int ARG_1_AND_2_ARE_WORDS    = 0x01;
+    private static final int ARGS_ARE_XY_VALUES       = 0x02;
+    private static final int WE_HAVE_A_SCALE          = 0x08;
+    private static final int WE_HAVE_AN_X_AND_Y_SCALE = 0x40;
+    private static final int WE_HAVE_A_TWO_BY_TWO     = 0x80;
+    private static final int MORE_COMPONENTS          = 0x10;
+
+    private int key;
+
+    private String name;
+    private boolean isBold;
+    private boolean isItalic;
+
+    private int encoding;
+
+    private float ascent;
+    private float descent;
+    private float leading;
+
+    private short[] charToGlyph;
+    private short[] glyphToChar;
+
+    private Glyph[] glyphTable;
+
+    private int numberOfGlyphs;
+    private int missingGlyph;
+    private int highestChar;
+    
+    private ArrayList&lt;FSKerning&gt; kernings = new ArrayList&lt;FSKerning&gt;();
+    
+    private int scale;
+    private int metrics;
+    private int glyphOffset;
+
+    public Font(FSDefineFont2 font)
+    {
+    	name = font.getName();
+    	isBold = font.isBold();
+    	isItalic = font.isItalic();
+
+    	encoding = font.getEncoding();   	
+    	
+    	if (encoding == FSSpan.ANSI) {
+    		encoding = FSSpan.Unicode;
+    	}
+
+    	key = generateKey(name, isBold, isItalic);
+
+    	ascent = font.getAscent();
+    	descent = font.getDescent();
+    	leading = font.getLeading();
+    	
+    	missingGlyph = 0;
+
+    	numberOfGlyphs = font.getShapes().size();
+    	glyphTable = new Glyph[numberOfGlyphs];
+        glyphToChar = new short[numberOfGlyphs];
+        
+        highestChar = font.getCodes().get(font.getCodes().size()-1);
+        charToGlyph = new short[highestChar];
+
+    	if (numberOfGlyphs &gt; 0)
+    	{
+        	int glyphIndex = 0;
+
+        	for (Iterator&lt;FSShape&gt; i=font.getShapes().iterator(); i.hasNext(); glyphIndex++)
+        		glyphTable[glyphIndex] = new Glyph(i.next());
+
+        	int code;
+        	glyphIndex = 0;
+
+        	for (Iterator&lt;Integer&gt; i=font.getCodes().iterator(); i.hasNext(); glyphIndex++)
+        	{
+        		code = i.next();
+
+        		charToGlyph[code] = (short) glyphIndex;
+        		glyphToChar[glyphIndex] = (short) code;
+        	}
+
+        	if (font.getAdvances() != null)
+        	{
+            	glyphIndex = 0;  	
+            	
+            	for (Iterator&lt;Integer&gt; i = font.getAdvances().iterator(); i.hasNext(); glyphIndex++)
+            		glyphTable[glyphIndex].setAdvance(i.next());
+        	}
+        	
+        	if (font.getBounds() != null)
+        	{
+            	glyphIndex = 0;
+            	
+                	for (Iterator&lt;FSBounds&gt; i = font.getBounds().iterator(); i.hasNext(); glyphIndex++)
+                		glyphTable[glyphIndex].setBounds(i.next());
+        	}
+    	}
+    }
+    
+    public Font(java.awt.Font font)
+    {
+        FontRenderContext fontContext = new FontRenderContext(new AffineTransform(), true, true);
+        font = font.deriveFont(1.0f);
+
+        name = font.getName();
+        encoding = FSSpan.Unicode;
+
+        Rectangle2D transform = transformToEMSquare(font, fontContext);
+
+        double scaleY = 1024.0;
+        double scaleX = scaleY;
+        
+        double translateX = 1024.0 - (transform.getX() * 1024.0);
+        double translateY = 1024.0 - (transform.getY() * 1024.0);
+
+        /*
+         The new font scaled to the EM Square must be derived using the size as well 
+         as the transform used for the glyphs otherwise the advance values are not 
+         scaled accordingly.
+         */
+        AffineTransform at = AffineTransform.getTranslateInstance(translateX, translateY);
+ 
+        font = font.deriveFont(at);
+        font = font.deriveFont((float)scaleX);
+
+        missingGlyph = font.getMissingGlyphCode();
+
+        isBold = font.isBold();
+        isItalic = font.isItalic();
+
+        int numGlyphs = font.getNumGlyphs();
+        int glyphIndex = 0;
+        int characterCode = 0;
+    
+        glyphTable = new Glyph[numGlyphs];
+    
+        /*
+         * Run through all the unicode character codes looking for a corresponding glyph.
+         */
+        while ((glyphIndex &lt; numGlyphs) &amp;&amp; (characterCode &lt; 65535))
+        {
+            char currentChar = (char) characterCode;
+    
+            if (font.canDisplay(currentChar))
+            {
+                GlyphVector glyphVector = font.createGlyphVector(fontContext,
+                       new char[] { currentChar });
+    
+                java.awt.Shape outline = glyphVector.getGlyphOutline(0);
+                int advance = (int) (glyphVector.getGlyphMetrics(0).getAdvance());
+    
+                glyphTable[glyphIndex] = new Glyph(convertShape(outline), new FSBounds(0, 0, 0, 0), advance);
+                charToGlyph[currentChar] = (short)glyphIndex;
+                glyphToChar[glyphIndex] = (short)currentChar;
+    
+                if (font.hasUniformLineMetrics() == false)
+                {
+                    LineMetrics lineMetrics = font.getLineMetrics(new char[]
+                             { (char) currentChar }, 0, 1, fontContext);
+    
+                       ascent = 0; // Math.max(lineMetrics.getAscent() * 20, ascent);
+                       descent = 0; // Math.max(lineMetrics.getDescent() * 20, descent);
+                       leading = 0; // Math.max(lineMetrics.getLeading() * 20, leading);
+                }
+           }
+           else
+           {
+                GlyphVector glyphVector = font.createGlyphVector(fontContext, new char[] { (char)missingGlyph });
+            
+                java.awt.Shape outline = glyphVector.getGlyphOutline(0);
+                int advance = (int) (glyphVector.getGlyphMetrics(0).getAdvance());
+    
+                glyphTable[glyphIndex] = new Glyph(convertShape(outline), new FSBounds(0, 0, 0, 0), advance);
+                charToGlyph[currentChar] = (short)glyphIndex;
+                glyphToChar[glyphIndex] = (short)currentChar;
+    
+                if (font.hasUniformLineMetrics() == false)
+                {
+                    LineMetrics lineMetrics = font.getLineMetrics(new char[]
+                             {(char)currentChar }, 0, 1, fontContext);
+    
+                    ascent = 0; // Math.max(lineMetrics.getAscent() * 20, ascent);
+                    descent = 0; // Math.max(lineMetrics.getDescent() * 20, descent);
+                    leading = 0; // Math.max(lineMetrics.getLeading() * 20, leading);
+                }
+           }
+           glyphIndex++;
+           characterCode++;
+       }
+    }
+    
+    public Font(String path) throws FileNotFoundException, IOException, DataFormatException
+    {
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, dataFromFile(path));
+        
+        float version = coder.readFixedBits(32, 16);
+
+        int tableCount = coder.readWord(2, false);
+        int searchRange = coder.readWord(2, false);
+        int entrySelector = coder.readWord(2, false);
+        int rangeShift = coder.readWord(2, false);
+        
+        int os_2Offset = 0;
+        int headOffset = 0;
+        int hheaOffset = 0;
+        int maxpOffset = 0;
+        int locaOffset = 0;
+        int cmapOffset = 0;
+        int glyfOffset = 0;
+        int hmtxOffset = 0;
+        int nameOffset = 0;
+        
+        int os_2Length = 0;
+        int headLength = 0;
+        int hheaLength = 0;
+        int maxpLength = 0;
+        int locaLength = 0;
+        int cmapLength = 0;
+        int hmtxLength = 0;
+        int nameLength = 0;
+        int glyfLength = 0;
+
+        int chunkType = 0;
+        int checksum = 0;
+        int offset = 0;
+        int length = 0;
+        
+        for (int i=0; i&lt;tableCount; i++) 
+        {
+            chunkType = coder.readWord(4, false);
+            checksum = coder.readWord(4, false);
+            offset = coder.readWord(4, false) &lt;&lt; 3;
+            length = coder.readWord(4, false);
+            
+            /* 
+             * Chunks are encoded in ascending alphabetical order so
+             * the location of the tables is mapped before they are 
+             * decoded since the glyphs come before the loca or maxp
+             * table which identify how many glyphs are encoded.
+             */
+            switch (chunkType)
+            {
+                case OS_2: os_2Offset = offset; os_2Length = length; break;
+                case CMAP: cmapOffset = offset; cmapLength = length; break;
+                case GLYF: glyfOffset = offset; glyfLength = length; break;
+                case HEAD: headOffset = offset; headLength = length; break;
+                case HHEA: hheaOffset = offset; hheaLength = length; break;
+                case HMTX: hmtxOffset = offset; hmtxLength = length; break;
+                case LOCA: locaOffset = offset; locaLength = length; break;
+                case MAXP: maxpOffset = offset; maxpLength = length; break;
+                case NAME: nameOffset = offset; nameLength = length; break;
+                default: break;
+            }
+        }
+        
+        int bytesRead = 0;
+
+        if (maxpOffset != 0) { coder.setPointer(maxpOffset); decodeMAXP(coder); bytesRead = (coder.getPointer() - maxpOffset) &gt;&gt; 3; }
+        if (os_2Offset != 0) { coder.setPointer(os_2Offset); decodeOS_2(coder); bytesRead = (coder.getPointer() - os_2Offset) &gt;&gt; 3; }
+        if (headOffset != 0) { coder.setPointer(headOffset); decodeHEAD(coder); bytesRead = (coder.getPointer() - headOffset) &gt;&gt; 3; }
+        if (hheaOffset != 0) { coder.setPointer(hheaOffset); decodeHHEA(coder); bytesRead = (coder.getPointer() - hheaOffset) &gt;&gt; 3; }
+        if (nameOffset != 0) { coder.setPointer(nameOffset); decodeNAME(coder); bytesRead = (coder.getPointer() - nameOffset) &gt;&gt; 3; }
+        
+        glyphTable = new Glyph[numberOfGlyphs];
+        
+        // Decode glyphs first so objects will be created.
+        if (locaOffset != 0) { coder.setPointer(locaOffset); decodeGlyphs(coder, glyfOffset); bytesRead = (coder.getPointer() - locaOffset) &gt;&gt; 3; }
+        if (hmtxOffset != 0) { coder.setPointer(hmtxOffset); decodeHMTX(coder); bytesRead = (coder.getPointer() - hmtxOffset) &gt;&gt; 3; }
+        if (cmapOffset != 0) { coder.setPointer(cmapOffset); decodeCMAP(coder); bytesRead = (coder.getPointer() - cmapOffset) &gt;&gt; 3; }
+   }
+
+    public String getFace() 
+    {
+		return name+(isBold ? &quot; Bold&quot; : &quot;&quot;)+(isItalic ? &quot; Italic&quot; : &quot;&quot;);
+	}
+
+    public String getName() 
+    {
+		return name;
+	}
+
+	public boolean isBold()
+	{
+		return isBold;
+	}
+
+	public boolean isItalic()
+	{
+		return isItalic;
+	}
+
+    public int getEncoding()
+	{
+		return encoding;
+	}
+    
+    public int getKey()
+    {
+    	return key;
+    }
+
+	public float getAscent()
+	{
+		return ascent;
+	}
+
+	public float getDescent()
+	{
+		return descent;
+	}
+
+	public float getLeading()
+	{
+		return leading;
+	}
+
+	public int numberOfGlyphs()
+	{
+		return numberOfGlyphs;
+	}
+
+	public int highestChar()
+	{
+		return highestChar;
+	}
+
+	public int getMissingGlyph()
+	{
+		return missingGlyph;
+	}
+
+	public ArrayList&lt;FSKerning&gt; getKernings()
+	{
+		return kernings;
+	}
+	
+	public FSDefineFont2 defineFont(int identifier, char[] characters)
+	{
+        FSDefineFont2 fontDefinition = null;
+
+        int count = characters.length;
+
+        ArrayList&lt;FSShape&gt; glyphsArray = new ArrayList&lt;FSShape&gt;(count);
+        ArrayList&lt;Integer&gt; codesArray = new ArrayList&lt;Integer&gt;(count);
+        ArrayList&lt;Integer&gt; advancesArray = new ArrayList&lt;Integer&gt;(count);
+        ArrayList&lt;FSBounds&gt; boundsArray = new ArrayList&lt;FSBounds&gt;(count);
+
+        for (int i=0; i&lt;characters.length; i++)
+        {
+            Glyph glyph = glyphTable[charToGlyph[characters[i]]];
+
+            glyphsArray.add(glyph.getShape());
+            codesArray.add(new Integer(characters[i]));
+            advancesArray.add(new Integer(glyph.getAdvance()));
+            
+            if (glyph.getBounds() != null) {
+            	boundsArray.add(glyph.getBounds());
+            }
+        }
+
+        fontDefinition = new FSDefineFont2(identifier, name);
+
+        fontDefinition.setEncoding(encoding);
+        fontDefinition.setItalic(isItalic);
+        fontDefinition.setBold(isBold);
+        fontDefinition.setAscent((int)ascent);
+        fontDefinition.setDescent((int)descent);
+        fontDefinition.setLeading((int)leading);
+        fontDefinition.setShapes(glyphsArray);
+        fontDefinition.setCodes(codesArray);
+        fontDefinition.setAdvances(advancesArray);
+        fontDefinition.setBounds(boundsArray);
+        fontDefinition.setKernings(getKernings());
+
+        return fontDefinition;
+	}
+
+	public Glyph getGlyph(int n)
+	{
+		Glyph glyph = null;
+
+		if (n &lt; glyphTable.length) {
+			glyph = glyphTable[n];
+		}
+		return glyph;
+	}
+
+	public int canDisplay(String aString)
+	{
+		int firstMissingChar = -1;
+
+		for (int i=0; i&lt;aString.length(); i++)
+		{
+			if (canDisplay(aString.charAt(i)) == false) {
+				firstMissingChar = i;
+				break;
+			}
+		}
+		return firstMissingChar;
+	}
+
+	public boolean canDisplay(char c)
+	{
+		boolean canDisplay = false;
+
+		if (c &lt; charToGlyph.length &amp;&amp; (c == ' ' || charToGlyph[c] != 0))
+		{
+			canDisplay = true;
+		}
+
+		return canDisplay;
+	}
+
+	public int glyphForCharacter(char c)
+	{
+		return charToGlyph[c];
+	}
+
+	public char characterForGlyph(int i)
+	{
+		return (char)glyphToChar[i];
+	}
+
+	public int advanceForCharacter(char c)
+	{
+		return glyphTable[charToGlyph[c]].getAdvance();
+	}
+	
+	private int generateKey(String fontName, boolean bold, boolean italic)
+	{
+    	int value = 17;
+    	
+    	value = value*31 + fontName.toLowerCase().hashCode();
+    	value = value*31 + (bold ? 1 : 0);
+    	value = value*31 + (italic ? 1 : 0);
+
+    	return value;
+	}
+    
+    private Rectangle2D transformToEMSquare(java.awt.Font font, FontRenderContext fontContext)
+    {
+        int numGlyphs = font.getNumGlyphs();
+        int characterCode = 0;
+        int glyphIndex = 0;
+
+        double x = 0.0;
+        double y = 0.0;
+        double w = 0.0;
+        double h = 0.0;
+
+        /*
+         * Scan through all the glyphs looking for glyphs that will fall outside 
+         * the left or bottom side of the EM Square once the glyph has been scaled.
+         */
+        while ((glyphIndex &lt; numGlyphs) &amp;&amp; (characterCode &lt; 65535)) 
+        {
+            char currentChar = (char) characterCode;
+
+            if (font.canDisplay(currentChar)) 
+            {
+                GlyphVector glyphVector = font.createGlyphVector(fontContext,
+                    new char[] { currentChar });
+                Rectangle2D bounds = glyphVector.getGlyphOutline(0).getBounds2D();
+    
+                x = Math.min(bounds.getX(), x);
+                y = Math.min(bounds.getY(), y);
+    
+                w = Math.max(bounds.getWidth(), w);
+                h = Math.max(bounds.getHeight(), h);
+    
+                glyphIndex++;
+            }
+            characterCode++;
+        }
+        return new Rectangle2D.Double(x, y, w, h);
+    }
+
+    private FSShape convertShape(java.awt.Shape glyph)
+    {
+        PathIterator pathIter = glyph.getPathIterator(null);
+        Canvas path = new Canvas();
+        
+        double[] coords = new double[6];
+
+        int xOrigin = 0;
+        int yOrigin = 0;
+
+        int currentX = 0;
+        int currentY = 0;
+
+        while (!pathIter.isDone())
+        {
+            int segmentType = pathIter.currentSegment(coords);
+
+            int p1 = (int) (coords[0]);
+            int p2 = (int) (coords[1]);
+            int p3 = (int) (coords[2]);
+            int p4 = (int) (coords[3]);
+            int p5 = (int) (coords[4]);
+            int p6 = (int) (coords[5]);
+
+            switch (segmentType)
+            {
+                case PathIterator.SEG_MOVETO:
+                    path.closePath();
+                    path.move(p1, p2);
+                    break;
+                case PathIterator.SEG_LINETO:
+                    path.line(p1, p2);
+                    break;
+                case PathIterator.SEG_QUADTO:
+                    path.curve(p1, p2, p3, p4);
+                    break;
+                case PathIterator.SEG_CUBICTO:
+                    path.curve(p1, p2, p3, p4, p5, p6);
+                    break;
+                case PathIterator.SEG_CLOSE:
+                    path.closePath();
+                    break;
+            }
+            pathIter.next();
+        }
+                
+        if (path.objects.size() &gt; 0)
+        {
+            FSShapeStyle style = (FSShapeStyle)path.objects.get(0);
+            style.setLineStyle(0);
+            style.setAltFillStyle(1);
+        }
+        return path.shape();
+    }
+
+    private void decodeHEAD(FSCoder coder)
+    {
+        byte[] date = new byte[8];
+    
+        coder.readFixedBits(32, 16); // table version 
+        coder.readFixedBits(32, 16); // font version 
+        coder.readWord(4, false); // checksum adjustment
+        coder.readWord(4, false); // magic number
+        coder.readBits(1, false); // baseline at y=0
+        coder.readBits(1, false); // side bearing at x=0;
+        coder.readBits(1, false); // instructions depend on point size
+        coder.readBits(1, false); // force ppem to integer values
+        coder.readBits(1, false); // instructions may alter advance
+        coder.readBits(11, false);
+        scale = coder.readWord(2, false) / 1024;  // units per em
+
+        if (scale == 0) 
+            scale = 1;
+
+        coder.readBytes(date); // number of seconds since midnight, Jan 01 1904
+        coder.readBytes(date); // number of seconds since midnight, Jan 01 1904
+    
+        coder.readWord(2, true); // xMin for all glyph bounding boxes
+        coder.readWord(2, true); // yMin for all glyph bounding boxes
+        coder.readWord(2, true); // xMax for all glyph bounding boxes
+        coder.readWord(2, true); // yMax for all glyph bounding boxes
+    
+        /*
+         * Next two byte define font appearance on Macs, values are 
+         * specified in the OS/2 table 
+         */ 
+        isBold = coder.readBits(1, false) != 0;
+        isItalic = coder.readBits(1, false) != 0;
+        coder.readBits(14, false); // 
+
+        coder.readWord(2, false);// smallest readable size in pixels
+        coder.readWord(2, true); // font direction hint
+        glyphOffset = coder.readWord(2, true); 
+        coder.readWord(2, true); // glyph data format
+    }
+    
+    private void decodeHHEA(FSCoder coder)
+    {
+        coder.readFixedBits(32, 16); // table version
+    
+        ascent = coder.readWord(2, true);
+        descent = coder.readWord(2, true);
+        leading = coder.readWord(2, true);
+        
+        coder.readWord(2, false); // maximum advance in the htmx table
+        coder.readWord(2, true); // minimum left side bearing in the htmx table
+        coder.readWord(2, true); // minimum right side bearing in the htmx table
+        coder.readWord(2, true); // maximum extent
+        coder.readWord(2, true); // caret slope rise 
+        coder.readWord(2, true); // caret slope run
+        coder.readWord(2, true); // caret offset
+    
+        coder.readWord(2, false); // reserved
+        coder.readWord(2, false); // reserved
+        coder.readWord(2, false); // reserved
+        coder.readWord(2, false); // reserved
+    
+        coder.readWord(2, true); // metric data format 
+        
+        metrics = coder.readWord(2, false);    
+    }
+
+    private void decodeOS_2(FSCoder coder)
+    {
+        byte[] panose = new byte[10];
+        int[] unicodeRange = new int[4];
+        byte[] vendor = new byte[4];
+
+        int version = coder.readWord(2, false); // version
+        coder.readWord(2, true); // average character width
+        
+        switch (coder.readWord(2, false)) // weight class
+        {
+            case FONT_WEIGHT_BOLD: isBold = true; break;
+            default: break;
+        }
+
+        coder.readWord(2, false); // width class
+        coder.readWord(2, false); // embedding licence
+        
+        coder.readWord(2, true); // subscript x size
+        coder.readWord(2, true); // subscript y size
+        coder.readWord(2, true); // subscript x offset
+        coder.readWord(2, true); // subscript y offset
+        coder.readWord(2, true); // superscript x size
+        coder.readWord(2, true); // superscript y size
+        coder.readWord(2, true); // superscript x offset
+        coder.readWord(2, true); // superscript y offset
+        coder.readWord(2, true); // width of strikeout stroke
+        coder.readWord(2, true); // strikeout stroke position
+        coder.readWord(2, true); // font family class
+    
+        coder.readBytes(panose);
+        
+        for (int i=0; i&lt;4; i++)
+            unicodeRange[i] = coder.readWord(4, false);
+            
+        coder.readBytes(vendor); // font vendor identification
+        
+        isItalic = coder.readBits(1, false) != 0;
+        coder.readBits(4, false);
+        isBold = coder.readBits(1, false) != 0;
+        coder.readBits(10, false);
+        
+        coder.readWord(2, false); // first unicode character code
+        coder.readWord(2, false); // last unicode character code
+        
+        ascent = coder.readWord(2, false);
+        descent = coder.readWord(2, false);
+        leading = coder.readWord(2, false);
+    
+        coder.readWord(2, false); // ascent in Windows
+        coder.readWord(2, false); // descent in Windows
+        
+        if (version &gt; 0)
+        {
+            coder.readWord(4, false); // code page range 
+            coder.readWord(4, false); // code page range
+
+            if (version &gt; 1)
+            {
+                coder.readWord(2, true); // height
+                coder.readWord(2, true); // Capitals height
+                missingGlyph = coder.readWord(2, false);
+                coder.readWord(2, false); // break character
+                coder.readWord(2, false); // maximum context
+            }
+        }
+    }
+
+    private void decodeNAME(FSCoder coder)
+    {
+    	int stringTableBase = coder.getPointer() &gt;&gt;&gt; 3;
+    	
+        int format = coder.readWord(2, false);
+        int numberOfNameRecords = coder.readWord(2, false);
+        int stringTable = coder.readWord(2, false) + stringTableBase;
+        
+        for (int i=0; i&lt;numberOfNameRecords; i++) 
+        {
+            int platformId = coder.readWord(2, false);
+            int encodingId = coder.readWord(2, false);
+            int languageId = coder.readWord(2, false);
+            int nameId = coder.readWord(2, false);
+            
+            int stringLength = coder.readWord(2, false);
+            int stringOffset = coder.readWord(2, false);
+            
+            int current = coder.getPointer();
+            
+            coder.setPointer((stringTable+stringOffset) &lt;&lt; 3);
+            byte[] b = new byte[stringLength];
+            coder.readBytes(b);
+            
+            String nameEncoding = &quot;UTF-8&quot;;
+            
+            if (platformId == 0) // Unicode
+            {
+                nameEncoding = &quot;UTF-16&quot;;
+            }
+            else if (platformId == 1) // Macintosh
+            {
+                if (encodingId == 0 &amp;&amp; languageId == 0)
+                    nameEncoding = &quot;ISO8859-1&quot;;
+            }
+            else if (platformId == 3) // Microsoft
+            {
+                switch (encodingId)
+                {
+                    case 1: nameEncoding = &quot;UTF-16&quot;; break;
+                    case 2: nameEncoding = &quot;SJIS&quot;; break;
+                    case 4: nameEncoding = &quot;Big5&quot;; break;
+                }
+            }
+            
+            try
+            {
+                if (nameId == 1)
+                    name = new String(b, nameEncoding);
+            }
+            catch (UnsupportedEncodingException e)
+            {
+                name = new String(b);
+            } 
+            coder.setPointer(current);
+        }
+    }
+
+    private void decodeMAXP(FSCoder coder)
+    {
+        float version = coder.readFixedBits(32, 16);
+        numberOfGlyphs = coder.readWord(2, false);
+        
+        if (version == 1.0)
+        {
+            coder.readWord(2, false); // maximum number of points in a simple glyph
+            coder.readWord(2, false); // maximum number of contours in a simple glyph
+            coder.readWord(2, false); // maximum number of points in a composite glyph
+            coder.readWord(2, false); // maximum number of contours in a composite glyph
+            coder.readWord(2, false); // maximum number of zones
+            coder.readWord(2, false); // maximum number of point in Z0
+            coder.readWord(2, false); // number of storage area locations
+            coder.readWord(2, false); // maximum number of FDEFs
+            coder.readWord(2, false); // maximum number of IDEFs
+            coder.readWord(2, false); // maximum stack depth
+            coder.readWord(2, false); // maximum byte count for glyph instructions
+            coder.readWord(2, false); // maximum number of components for composite glyphs
+            coder.readWord(2, false); // maximum level of recursion
+        }
+    }
+    private void decodeHMTX(FSCoder coder)
+    {
+        int i = 0;
+        
+        for (i=0; i&lt;metrics; i++) 
+        {
+            glyphTable[i].setAdvance((coder.readWord(2, false) / scale));
+            coder.readWord(2, true); // left side bearing
+        }
+        
+        int advance = glyphTable[i-1].getAdvance();
+
+        for (; i&lt;numberOfGlyphs; i++)
+            glyphTable[i].setAdvance(advance);
+
+        for (; i&lt;numberOfGlyphs; i++)
+            coder.readWord(2, true);
+    }
+    
+    private void decodeCMAP(FSCoder coder)
+    {
+        int tableStart = coder.getPointer();
+        
+        int version = coder.readWord(2, false);
+        int numberOfTables = coder.readWord(2, false);
+        
+        int platformId = 0;
+        int encodingId = 0;
+        int offset = 0;
+        int current = 0;
+        
+        int format = 0;
+        int length = 0;
+        int language = 0;
+        
+        int segmentCount = 0;
+        int[] startCount = null;
+        int[] endCount = null;
+        int[] delta = null;
+        int[] range = null;
+        int[] rangeAdr = null;
+        
+        int i = 0;
+        int n = 0;
+        
+        for (i=0; i&lt;numberOfTables; i++)
+        {
+            platformId = coder.readWord(2, false);
+            encodingId = coder.readWord(2, false);
+            offset = coder.readWord(4, false) &lt;&lt; 3;
+            current = coder.getPointer();
+            
+            if (platformId == 0) // Unicode
+            {
+                encoding = FSSpan.Unicode;
+            }
+            else if (platformId == 1) // Macintosh
+            {
+                switch (encodingId)
+                {
+                    case 1: encoding = FSSpan.SJIS; break;
+                    default: encoding = FSSpan.ANSI; break;
+                }
+                    
+            }
+            else if (platformId == 3) // Microsoft
+            {
+                switch (encodingId)
+                {
+                    case 1: encoding = FSSpan.Unicode; break;
+                    case 2: encoding = FSSpan.SJIS; break;
+                    default: encoding = FSSpan.ANSI; break;
+                }
+            }
+
+            coder.setPointer(tableStart+offset);
+            
+            format = coder.readWord(2, false);
+            length = coder.readWord(2, false);
+            language = coder.readWord(2, false);
+            
+            switch (format) 
+            {
+                case 0: 
+                    for (n=0; n&lt;256; n++) {
+                        charToGlyph[n] = (short)coder.readByte();
+                        glyphToChar[charToGlyph[n]] = (short)n;
+                    }
+                    break;
+                case 4:
+                    segmentCount = coder.readWord(2, false) / 2;
+    
+                    coder.readWord(2, false); // search range
+                    coder.readWord(2, false); // entry selector
+                    coder.readWord(2, false); // range shift
+
+                    startCount = new int[segmentCount];
+                    endCount = new int[segmentCount];
+                    delta = new int[segmentCount];
+                    range = new int[segmentCount];
+                    rangeAdr = new int[segmentCount];
+                    
+                    for (n=0; n&lt;segmentCount; n++)
+                        endCount[n] = coder.readWord(2, false);
+
+                    coder.readWord(2, false); // reserved padding
+                
+                    for (n=0; n&lt;segmentCount; n++)
+                        startCount[n] = coder.readWord(2, false);
+                
+                    for (n=0; n&lt;segmentCount; n++)
+                        delta[n] = coder.readWord(2, true);
+                
+                    for (n=0; n&lt;segmentCount; n++)
+                    {
+                        rangeAdr[n] = coder.getPointer() &gt;&gt; 3;
+                        range[n] = coder.readWord(2, true);
+                    }
+
+                    int glyphIndex = 0;
+                    int location = 0;
+                            
+                    for (n=0; n&lt;segmentCount; n++)
+                    {
+                        for (int code=startCount[n]; code&lt;=endCount[n]; code++)
+                        {
+                            if (range[n] != 0)
+                            {
+                                location = rangeAdr[n] + range[n] + ((code - startCount[n]) &lt;&lt; 1);
+                                coder.setPointer(location &lt;&lt; 3);
+                                glyphIndex = coder.readWord(2, false);
+                                
+                                if (glyphIndex != 0)
+                                    glyphIndex = (glyphIndex + delta[n]) % 65536;
+                            }
+                            else
+                                glyphIndex = (delta[n] + code) % 65536;
+
+                            charToGlyph[code] = (short)glyphIndex;
+                            glyphToChar[glyphIndex] = (short)code;
+                        }
+                    }
+                    break;
+                case 2:
+                case 6: 
+                    System.err.println(&quot;Unimplemented encoding table format: &quot; + format); 
+                    break;
+                default: 
+                    System.err.println(&quot;Illegal value for encoding table format: &quot; + format); 
+                    break;
+            }
+            coder.setPointer(current);
+        }
+        encoding = FSSpan.SJIS;
+    }
+    
+    private void decodeGlyphs(FSCoder coder, int glyfOffset)
+    {
+        int numberOfContours = 0;
+        int glyphStart = 0;
+        int start = coder.getPointer();
+        int end = 0;
+        int[] offsets = new int[numberOfGlyphs];
+        
+        if (glyphOffset == ITLF_SHORT)
+            offsets[0] = glyfOffset + (coder.readWord(2, false)*2 &lt;&lt; 3);
+        else
+            offsets[0] = glyfOffset + (coder.readWord(4, false) &lt;&lt; 3);
+
+        for (int i=1; i&lt;numberOfGlyphs; i++)
+        {
+            if (glyphOffset == ITLF_SHORT)
+                offsets[i] = glyfOffset + (coder.readWord(2, false)*2 &lt;&lt; 3);
+            else
+                offsets[i] = glyfOffset + (coder.readWord(4, false) &lt;&lt; 3);
+            
+            if (offsets[i] == offsets[i-1])
+                offsets[i-1] = 0;
+        }
+        
+        end = coder.getPointer();
+            
+        for (int i=0; i&lt;numberOfGlyphs; i++)
+        {
+            if (offsets[i] == 0)
+            {
+                glyphTable[i] = new Glyph(new FSShape(), new FSBounds(0, 0, 0, 0), 0);
+            }
+            else
+            {
+                coder.setPointer(offsets[i]);
+                
+                numberOfContours = coder.readWord(2, true);
+                
+                if (numberOfContours &gt;= 0)
+                    decodeSimpleGlyph(coder, i, numberOfContours);
+            }
+        }
+        
+        coder.setPointer(start);
+
+        for (int i=0; i&lt;numberOfGlyphs; i++)
+        {
+            if (offsets[i] != 0)
+            {
+                coder.setPointer(offsets[i]);
+            
+                if (coder.readWord(2, true) == -1)
+                    decodeCompositeGlyph(coder, i);
+            }
+        }
+        coder.setPointer(end);
+    }
+
+    private void decodeSimpleGlyph(FSCoder coder, int glyphIndex, int numberOfContours)
+    {
+        int xMin = coder.readWord(2, true) / scale;
+        int yMin = coder.readWord(2, true) / scale;
+        int xMax = coder.readWord(2, true) / scale;
+        int yMax = coder.readWord(2, true) / scale;
+        
+        int[] endPtsOfContours = new int[numberOfContours];
+
+        for (int i=0; i&lt;numberOfContours; i++)
+            endPtsOfContours[i] = coder.readWord(2, false);
+
+        int instructionCount = coder.readWord(2, false);   
+        int[] instructions = new int[instructionCount];
+            
+        for (int i=0; i&lt;instructionCount; i++)
+            instructions[i] = coder.readByte();
+                
+        int numberOfPoints = (numberOfContours == 0) ? 0 : endPtsOfContours[endPtsOfContours.length-1]+1;
+        
+        int[] flags = new int[numberOfPoints];
+        int[] xCoordinates = new int[numberOfPoints];
+        int[] yCoordinates = new int[numberOfPoints];
+        boolean[] onCurve = new boolean[numberOfPoints];
+        
+        int repeatCount = 0;
+        int repeatFlag  = 0;
+            
+        for (int i=0; i&lt;numberOfPoints; i++) 
+        {
+            if (repeatCount &gt; 0) 
+            {
+                flags[i] = repeatFlag;
+                repeatCount--;
+            } 
+            else 
+            {
+                flags[i] = coder.readByte();
+                    
+                if ((flags[i] &amp; REPEAT_FLAG) &gt; 0) 
+                {
+                    repeatCount = coder.readByte();
+                    repeatFlag = flags[i];
+                }
+            }
+            onCurve[i] = (flags[i] &amp; ON_CURVE) &gt; 0;
+        }
+
+        int last = 0;
+
+        for (int i=0; i&lt;numberOfPoints; i++) 
+        {        
+            if ((flags[i] &amp; X_SHORT) &gt; 0) 
+            {
+                if ((flags[i] &amp; X_POSITIVE) &gt; 0)
+                    last = xCoordinates[i] = last + coder.readByte();
+                else 
+                    last = xCoordinates[i] = last - coder.readByte();
+            } 
+            else 
+            {
+                if ((flags[i] &amp; X_SAME) &gt; 0)
+                    last = xCoordinates[i] = last;
+                else
+                    last = xCoordinates[i] = last + coder.readWord(2, true);
+            }
+        }
+
+        last = 0;
+
+        for (int i = 0; i &lt; numberOfPoints; i++) 
+        {
+            if ((flags[i] &amp; Y_SHORT) &gt; 0)
+            {
+                if ((flags[i] &amp; Y_POSITIVE) &gt; 0)
+                    last = yCoordinates[i] = last + coder.readByte();
+                else 
+                    last = yCoordinates[i] = last - coder.readByte();
+            } 
+            else 
+            {
+                if ((flags[i] &amp; Y_SAME) &gt; 0)
+                    last = yCoordinates[i] = last;
+                else 
+                    last = yCoordinates[i] = last + coder.readWord(2, true);
+            }
+        }
+            
+        /*
+         * Convert the coordinates into a shape
+         */
+        Canvas path = new Canvas();
+        
+        boolean contourStart = true;
+        boolean offPoint = false;
+        
+        int contour = 0;
+        
+        int x = 0;
+        int y = 0;
+        
+        int prevX = 0;
+        int prevY = 0;
+        
+        int initX = 0;
+        int initY = 0;
+        
+        for (int i=0; i&lt;numberOfPoints; i++)
+        {
+            x = xCoordinates[i] / scale;
+            y = yCoordinates[i] / scale;
+            
+            if (onCurve[i])
+            {
+                if (contourStart)
+                {
+                    path.moveForFont(x, -y);
+                    contourStart = false;
+                    initX = x;
+                    initY = y;
+                }
+                else if (offPoint)
+                {
+                    path.curve(prevX, -prevY, x, -y);
+                    offPoint = false;
+                }
+                else
+                {
+                    path.line(x, -y);
+                }
+            }
+            else
+            {
+                if (offPoint == true)
+                    path.curve(prevX, -prevY, (x+prevX)/2, -(y+prevY)/2);
+
+                prevX = x;
+                prevY = y;
+                offPoint = true;
+            }
+            
+            if (i == endPtsOfContours[contour])
+            {
+                if (offPoint)
+                {
+                    path.curve(x, -y, initX, -initY);
+                }
+                else
+                {
+                    path.closePath();
+                } 
+                contourStart = true;
+                offPoint = false;
+                prevX = 0;
+                prevY = 0;
+                contour++;
+            }
+        }
+        
+        glyphTable[glyphIndex] = new Glyph(path.shape(),new FSBounds(xMin, -yMax, xMax, -yMin), 0);
+
+        //glyphTable[glyphIndex].xCoordinates = xCoordinates;
+        //glyphTable[glyphIndex].yCoordinates = yCoordinates;
+        //glyphTable[glyphIndex].onCurve = onCurve;
+        //glyphTable[glyphIndex].endPoints = endPtsOfContours;
+    }
+ 
+    private void decodeCompositeGlyph(FSCoder coder, int glyphIndex)
+    {
+        FSShape shape = new FSShape();
+        FSCoordTransform transform = null;
+                        
+        int xMin = coder.readWord(2, true);
+        int yMin = coder.readWord(2, true);
+        int xMax = coder.readWord(2, true);
+        int yMax = coder.readWord(2, true);
+        
+        Glyph points = null;
+        
+        int numberOfPoints = 0;
+        
+        int[] endPtsOfContours = null;
+        int[] xCoordinates = null;
+        int[] yCoordinates = null;
+        boolean[] onCurve = null;
+        
+        int flags = 0;
+        int sourceGlyph = 0;
+        
+        int xOffset = 0;
+        int yOffset = 0;
+        
+        int sourceIndex = 0;
+        int destIndex = 0;
+
+        do {
+            transform = new FSCoordTransform();
+            
+            flags = coder.readWord(2, false);
+            sourceGlyph = coder.readWord(2, false);
+            
+            if (sourceGlyph &gt;= glyphTable.length || glyphTable[sourceGlyph] == null)
+            {
+                glyphTable[glyphIndex] = new Glyph(null, new FSBounds(xMin, yMin, xMax, yMax), 0);            
+                return;
+            }
+            
+            points = glyphTable[sourceGlyph];
+            //numberOfPoints = points.xCoordinates.length;
+            
+            //endPtsOfContours = new int[points.endPoints.length];
+            
+            /*
+            for (int i=0; i&lt;endPtsOfContours.length; i++)
+                endPtsOfContours[i] = points.endPoints[i];
+                
+            xCoordinates = new int[numberOfPoints];
+            
+            for (int i=0; i&lt;numberOfPoints; i++)
+                xCoordinates[i] = points.xCoordinates[i];
+                
+            yCoordinates = new int[numberOfPoints];
+            
+            for (int i=0; i&lt;numberOfPoints; i++)
+                yCoordinates[i] = points.yCoordinates[i];
+                
+            onCurve = new boolean[numberOfPoints];
+            
+            for (int i=0; i&lt;numberOfPoints; i++)
+                onCurve[i] = points.onCurve[i];
+            */
+            if ((flags &amp; ARG_1_AND_2_ARE_WORDS) == 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) == 0)
+            {
+                destIndex = coder.readByte();
+                sourceIndex = coder.readByte();
+                
+                //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
+                //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
+                transform.translate(0, 0);
+            }
+            else if ((flags &amp; ARG_1_AND_2_ARE_WORDS) == 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) &gt; 0)
+            {
+                xOffset = (coder.readByte() &lt;&lt; 24) &gt;&gt; 24;
+                yOffset = (coder.readByte() &lt;&lt; 24) &gt;&gt; 24;
+                transform.translate(xOffset, yOffset);
+            }
+            else if ((flags &amp; ARG_1_AND_2_ARE_WORDS) &gt; 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) == 0)
+            {
+                destIndex = coder.readWord(2, false);
+                sourceIndex = coder.readWord(2, false);
+                
+                //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
+                //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
+                transform.translate(0, 0);
+            }
+            else
+            {
+                xOffset = coder.readWord(2, true);
+                yOffset = coder.readWord(2, true);
+                transform.translate(xOffset, yOffset);
+            }
+            
+            
+            if ((flags &amp; WE_HAVE_A_SCALE) &gt; 0) 
+            {
+                float scaleXY = coder.readFixedBits(16, 14);
+                transform.scale(scaleXY, scaleXY);
+            }
+            else if ((flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) &gt; 0)
+            {
+                float scaleX = coder.readFixedBits(16, 14);
+                float scaleY = coder.readFixedBits(16, 14);
+                transform.scale(scaleX, scaleY);
+            }
+            else if ((flags &amp; WE_HAVE_A_TWO_BY_TWO) &gt; 0) 
+            {
+                float scaleX = coder.readFixedBits(16, 14);
+                float scale01 = coder.readFixedBits(16, 14);
+                float scale10 = coder.readFixedBits(16, 14);
+                float scaleY = coder.readFixedBits(16, 14);
+                
+                float[][] matrix = new float[][] { 
+                    {scaleX, scale01, 0.0f}, 
+                    {scale10, scaleY, 0.0f}, 
+                    {0.0f, 0.0f, 1.0f}
+                };
+
+                transform.composite(new FSCoordTransform(matrix));
+            }
+            
+            for (int i=0; i&lt;numberOfPoints; i++)
+            {
+                int[] xy =  transform.transformPoint(xCoordinates[i], yCoordinates[i]);
+                
+                xCoordinates[i] = xy[0];
+                yCoordinates[i] = xy[1];
+            }
+
+            Canvas path = new Canvas();
+        
+            boolean contourStart = true;
+            boolean offPoint = false;
+        
+            int contour = 0;
+        
+            int x = 0;
+            int y = 0;
+        
+            int prevX = 0;
+            int prevY = 0;
+        
+            int initX = 0;
+            int initY = 0;
+        
+            for (int i=0; i&lt;numberOfPoints; i++)
+            {
+                x = xCoordinates[i] / scale;
+                y = yCoordinates[i] / scale;
+            
+                if (onCurve[i])
+                {
+                    if (contourStart)
+                    {
+                        path.moveForFont(x, -y);
+                        contourStart = false;
+                        initX = x;
+                        initY = y;
+                    }
+                    else if (offPoint)
+                    {
+                        path.curve(prevX, -prevY, x, -y);
+                        offPoint = false;
+                    }
+                    else
+                    {
+                        path.line(x, -y);
+                    }
+                }
+                else
+                {
+                    if (offPoint == true)
+                        path.curve(prevX, -prevY, (x+prevX)/2, -(y+prevY)/2);
+
+                    prevX = x;
+                    prevY = y;
+                    offPoint = true;
+                }
+            
+                if (i == endPtsOfContours[contour])
+                {
+                    if (offPoint)
+                    {
+                        path.curve(x, -y, initX, -initY);
+                    }
+                    else
+                    {
+                        path.closePath();
+                    } 
+                    contourStart = true;
+                    offPoint = false;
+                    prevX = 0;
+                    prevY = 0;
+                    contour++;
+                }
+            }
+            shape.getObjects().addAll(path.shape().getObjects());
+              
+        } while ((flags &amp; MORE_COMPONENTS) &gt; 0);
+
+        glyphTable[glyphIndex] = new Glyph(shape, new FSBounds(xMin, yMin, xMax, yMax), 0);
+
+        //glyphTable[glyphIndex].xCoordinates = xCoordinates;
+        //glyphTable[glyphIndex].yCoordinates = yCoordinates;
+        //glyphTable[glyphIndex].onCurve = onCurve;
+        //glyphTable[glyphIndex].endPoints = endPtsOfContours;
+    }
+
+    private byte[] dataFromFile(String filename) throws FileNotFoundException, IOException
+    {
+        File aFile = new File(filename);
+        FileInputStream imageContents = null;
+        
+        byte[] bytes = new byte[(int)aFile.length()];
+        
+        imageContents = new FileInputStream(aFile);            
+        imageContents.read(bytes);
+        imageContents.close();
+
+        return bytes;
+    }
+}
\ No newline at end of file

Added: dev/dev-2-4/src/com/flagstone/transform/util/Glyph.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/Glyph.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/Glyph.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,58 @@
+package com.flagstone.transform.util;
+
+import com.flagstone.transform.FSBounds;
+import com.flagstone.transform.FSShape;
+
+public class Glyph
+{
+	static final int EM_SQUARE = 1024;
+
+	private FSShape shape;
+	private FSBounds bounds;
+	private int advance;
+
+	public Glyph(FSShape shape, FSBounds bounds, int advance)
+	{
+		this.shape = shape;
+		this.bounds = bounds;
+		this.advance = advance;
+	}
+
+	public Glyph(FSShape shape)
+	{
+		this.shape = shape;
+		this.bounds = null;
+		this.advance = 0;
+	}
+
+	public FSShape getShape()
+	{
+		return shape;
+	}
+
+	public void setShape(FSShape shape)
+	{
+		this.shape = shape;
+	}
+
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
+
+	public void setBounds(FSBounds bounds)
+	{
+		this.bounds = bounds;
+	}
+
+	public int getAdvance()
+	{
+		return advance;
+	}
+
+	public void setAdvance(int advance)
+	{
+		this.advance = advance;
+	}
+}
+

Added: dev/dev-2-4/src/com/flagstone/transform/util/Image.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/Image.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/Image.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,531 @@
+/*
+ *  FSImageConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.*;
+import java.util.zip.*;
+
+import com.flagstone.transform.FSDefineObject;
+import com.flagstone.transform.FSDefineImage;
+import com.flagstone.transform.FSDefineImage2;
+import com.flagstone.transform.FSDefineJPEGImage;
+import com.flagstone.transform.FSDefineJPEGImage2;
+import com.flagstone.transform.FSDefineJPEGImage3;
+import com.flagstone.transform.FSDefineShape3;
+
+import com.flagstone.transform.FSMovieObject;
+import com.flagstone.transform.FSShape;
+import com.flagstone.transform.FSCoordTransform;
+import com.flagstone.transform.FSBounds;
+import com.flagstone.transform.FSShapeStyle;
+import com.flagstone.transform.FSLine;
+import com.flagstone.transform.FSLineStyle;
+import com.flagstone.transform.FSFillStyle;
+import com.flagstone.transform.FSBitmapFill;
+
+/**
+ * The FSImageConstructor class is used to generate an image definition object from an image stored
+ * in a file. Currently PNG, BMP and JPEG encoded images are supported. The name of the file containing 
+ * the image can be specified directly in the class constructor:&lt;/p&gt;
+ *
+ * &lt;pre&gt;
+ *     FSImageConstructor imageConstructor = new FSImageConstructor(imageFile);
+  * &lt;/pre&gt;
+ *
+ * A single FSImageConstructor object can also be used to load a series of images:
+ *
+ * &lt;pre&gt;
+ *     imageConstructor.setImageFromFile(imageFile);
+ * &lt;/pre&gt;
+ *
+ * &lt;P&gt;If an error occurs each method will throw either a FileNotFoundException, IOException or 
+ * DataFormatException depending on the error detected.&lt;/P&gt;
+ *
+ * &lt;P&gt;When an image is loaded the getFormat() method identifies the way the image is encoded:&lt;/P&gt;
+ *
+ * &lt;table&gt;
+ * &lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;JPEG&lt;/td&gt;
+ * &lt;td&gt;A JPEG encoded image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;IDX8&lt;/td&gt;
+ * &lt;td&gt;An indexed image where each pixel specifies an index into a colour table containing up to 
+ * 256 24-bit colours. Transparent colours are not supported.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;IDXA&lt;/td&gt;
+ * &lt;td&gt;An indexed image where each pixel specifies an index into a colour table containing up to 
+ * 256 32-bit colours - 8-bits for each colour channel and 8-bits for transparency.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;RGB5&lt;/td&gt;
+ * &lt;td&gt;An true colour image where each pixel specifies a 16-bit colour, with 5-bits per colour
+ * channel. Transparent colours are not supported.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;RGB8&lt;/td&gt;
+ * &lt;td&gt;An true colour image where each pixel specifies a 24-bit colour, with 8-bits per colour
+ * channel. Each pixel occupies 32-bits. Transparent colours are not supported so the first 
+ * (most significant) byte is set to 255 by default.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;RGBA&lt;/td&gt;
+ * &lt;td&gt;An true colour image where each pixel specifies a 32-bit colour, with 8-bits per colour
+ * channel and 8-bits for transparency. The first (most significant) byte contains the 
+ * transparency information.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;/table&gt;
+ *
+ * &lt;P&gt;Once an image is loaded the definition required to add the image to a Flash file is 
+ * generated using the defineImage() method:&lt;/p&gt;
+ *
+ * &lt;pre&gt;
+ *     movie.add(imageConstructor.defineImage(movie.newIdentifier()));
+ * &lt;/pre&gt;
+ *
+ * &lt;P&gt;The defineImage()method returns an FSDefineObject (the abstract base class for all objects used 
+ * to define shapes etc. in a Flash file. The exact class of the object generated depends of the format 
+ * of the image loaded.&lt;/P&gt;
+ *
+ * &lt;table&gt;
+ * &lt;tr&gt;&lt;th&gt;Class&lt;/th&gt;&lt;th&gt;Generated when...&lt;/th&gt;&lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;FSDefineJPEGImage2&lt;/td&gt;
+ * &lt;td&gt;A JPEG encoded image is loaded. The getFormat() method returns the class constant JPEG.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;FSDefineImage&lt;/td&gt;
+ * &lt;td&gt;An indexed BMP or PNG image contains a colour table without transparent colours or 
+ * when a true colour image contains 16-bit or 24-bit colours is loaded. The getFormat() method returns 
+ * the class constants IDX8, RGB5 or RGB8.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;tr&gt;
+ * &lt;td&gt;FSDefineImage2&lt;/td&gt;
+ * &lt;td&gt;A BMP or PNG indexed image contains a colour table with transparent colours is loaded or 
+ * when a true colour image contains 32-bit bit colours. The getFormat() method returns the class 
+ * constants IDXA or RGBA.&lt;/td&gt;
+ * &lt;/tr&gt;
+ *
+ * &lt;/table&gt;
+ * 
+ * &lt;P&gt;Images are displayed in Flash by filling a shape with the image bitmap. The defineEnclosingShape()
+ * method generates a rectangular shape object which wraps the image:
+ *
+ * &lt;pre&gt;
+ *     int imageId = movie.newIdentifier();
+ *     int shapeId = movie.newIdentifier();
+ * 
+ *     int xOrigin = imageConstructor.getWidth()/2;
+ *     int yOrigin = imageConstructor.getHeight()/2;
+ * 
+ *     boolean border = false;
+ * 
+ *     movie.add(imageConstructor.defineImage(imageId));
+ *     movie.add(imageConstructor.defineEnclosingShape(shapeId, imageId, xOrigin, yOrigin, border));
+ * &lt;/pre&gt;
+ * 
+ * &lt;P&gt;Here the origin, used when placing the shape on the screen, is defined as the centre of the shape.
+ * Other points may be defined to suit the alignment of the shape when it is placed on the display list.&lt;/P&gt;
+ * 
+ * &lt;h2&gt;Post Processing&lt;/h2&gt;
+ * 
+ * &lt;P&gt;Once an image has been loaded, FSImageConstructor supports a range of methods to access the colour table 
+ * or image data - depending on the image format. This allows the image data to be processed before the objects
+ * used to add the image to a Flash file are defined.
+ * 
+ * &lt;pre&gt;
+ *     imageConstructor.getColorTable();
+ *     imageConstructor.getIndexedImage();
+ *     imageConstructor.setColorImage();
+ *     imageConstructor.getJPEGImage();
+ * &lt;/pre&gt;
+ * 
+ * &lt;P&gt;The information returned will depend on the image format. If an indexed image is loaded then the 
+ * getColourTable() and getIndexedImage() will return the arrays of bytes for the colour table and image
+ * respectively. If getColorImage() or getJPEGImage() are used on an indexed image then they will return 
+ * null objects.&lt;/P&gt;
+ * 
+ * &lt;P&gt;Once the image data has been processed separate set methods are available depending on the type of 
+ * image:&lt;/P&gt;
+ *
+ * &lt;pre&gt;
+ *     imageConstructor.setIndexedImage(format, imageWidth, imageHeight, colourTable, image);
+ *     imageConstructor.setColorImage(format, imageWidth, imageHeight, image);
+ *     imageConstructor.setJPEGImage(imageWidth, imageHeight, image);
+ * &lt;/pre&gt;
+ */
+public class Image
+{
+    /** Format for JPEG encoded images */
+    public static final int JPEG = 0;
+    /** Format for indexed images containing a colour table with 24-bit colours. */
+    public static final int IDX8 = 1;
+    /** Format for indexed images containing a colour table with 32-bit colours. */
+    public static final int IDXA = 2;
+    /** Format for true colour images containing 16-bit colours, 5-bits for each colour channel. */
+    public static final int RGB5 = 3;
+    /** Format for true colour images containing 24-bit colours, 8-bits for each colour channel. */
+    public static final int RGB8 = 4;
+    /** Format for true colour images containing 32-bit colours, 8-bits for each colour channel plus transparency. */
+    public static final int RGBA = 5; 
+    
+	private static HashMap&lt;String, Class&lt;ImageDecoder&gt;&gt; decoders = new HashMap&lt;String, Class&lt;ImageDecoder&gt;&gt;();
+
+	public static void registerDecoder(String format, Class&lt;ImageDecoder&gt; aClass)
+	{
+		decoders.put(format.toUpperCase(), aClass);
+	}
+    
+    /**
+     * Constructs an FSImageConstructor object with no image.
+     */
+    public Image()
+    {
+    }
+    
+    FSDefineObject defineImage(int identifier, String path) throws FileNotFoundException, IOException, DataFormatException
+    {
+    	FSDefineObject object = null;
+    	
+    	ImageInfo ii = new ImageInfo();
+    	ii.setInput(new RandomAccessFile(path, &quot;r&quot;));
+    	ii.setDetermineImageNumber(true);
+    	
+    	if (!ii.check()) 
+    	{
+    		throw new DataFormatException();
+    	}
+    	
+    	if (decoders.containsKey(ii.getFormatName()))
+    	{
+			try
+			{
+				Class&lt;ImageDecoder&gt; obj = decoders.get(ii.getFormatName());
+				ImageDecoder decoder = (ImageDecoder) obj.newInstance();
+				decoder.decode(path);
+				
+				int format = decoder.getFormat();
+				int width = decoder.getWidth();
+				int height = decoder.getHeight();
+				
+				byte[] colourTable = decoder.getTable();
+				byte[] image = decoder.getImage();
+
+				switch (format)
+	            {
+	                case JPEG: 
+	                	object = new FSDefineJPEGImage2(identifier, image); 
+	                	break;
+	                case IDX8: 
+	                	object = new FSDefineImage(identifier, width, height, colourTable.length, zip(merge(adjustScan(width, height, image), colourTable))); 
+	                	break;
+	                case IDXA: 
+	                	object = new FSDefineImage2(identifier, width, height, colourTable.length, zip(mergeAlpha(adjustScan(width, height, image), colourTable))); 
+	                	break;
+	                case RGB5: 
+	                	object = new FSDefineImage(identifier, width, height, zip(packColours(width, height, image)), 16); 
+	                	break;
+	                case RGB8: 
+	                	orderAlpha(image);
+	                	object = new FSDefineImage(identifier, width, height, zip(image), 24); 
+	                	break;
+	                case RGBA: 
+	                	applyAlpha(image);
+	                	object = new FSDefineImage2(identifier, width, height, zip(image)); 
+	                	break;
+	            }
+			} 
+			catch (Exception e)
+			{
+				throw new DataFormatException();
+			}
+    	}
+    	
+    	return object;
+    }
+    
+    private byte[] adjustScan(int width, int height, byte[] image)
+    {
+        int src = 0;
+        int dst = 0;
+        int row;
+        int col;
+        
+        int scan = 0;
+        byte[] formattedImage = null;
+        
+        scan = (width + 3) &amp; ~3;
+        formattedImage = new byte[scan*height];
+        
+        for (row=0; row&lt;height; row++)
+        {
+            for (col=0; col&lt;width; col++)
+                formattedImage[dst++] = image[src++];
+            
+            for (; col&lt;scan; col++)
+                formattedImage[dst++] = 0;
+        }
+
+        return formattedImage;
+    }
+    
+    private byte[] packColours(int width, int height, byte[] image)
+    {
+        int src = 0;
+        int dst = 0;
+        int row;
+        int col;
+        
+        int scan = width + (width &amp; 1);
+        byte[] formattedImage = new byte[scan*height*2];
+        
+        for (row=0; row&lt;height; row++)
+        {
+            for (col=0; col&lt;width; col++, src++)
+            {
+                int red = (image[src++] &amp; 0xF8) &lt;&lt; 7;
+                int green = (image[src++] &amp; 0xF8) &lt;&lt; 2;
+                int blue = (image[src++] &amp; 0xF8) &gt;&gt; 3;
+                int colour = (red | green | blue) &amp; 0x7FFF;
+                
+                formattedImage[dst++] = (byte) (colour &gt;&gt; 8);
+                formattedImage[dst++] = (byte) colour;
+            }
+
+            for (; col&lt;scan; col++)
+            {
+                formattedImage[dst++] = 0;
+                formattedImage[dst++] = 0;
+            }
+        }
+        return formattedImage;
+    }
+    
+    private void orderAlpha(byte[] image)
+    {
+    	byte alpha;
+    	
+        for (int i=0; i&lt;image.length; i+=4)
+        {
+        	alpha = image[i+3];
+        	
+        	image[i+3] = image[i+2];
+        	image[i+2] = image[i+1];
+        	image[i+1] = image[i];
+        	image[i] = alpha;
+        }
+    }
+
+    private void applyAlpha(byte[] image)
+    {
+    	int alpha; 
+    	
+    	for (int i=0; i&lt;image.length; i+=4)
+    	{
+            alpha = image[i+3] &amp; 0xFF;                
+
+            image[i] =   (byte)(((image[i]   &amp; 0xFF) * alpha) / 255);
+            image[i+1] = (byte)(((image[i+1] &amp; 0xFF) * alpha) / 255);
+            image[i+2] = (byte)(((image[i+2] &amp; 0xFf) * alpha) / 255);
+    	}
+    }
+    
+    private byte[] merge(byte[] image, byte[] table)
+    {
+        byte[] merged = new byte[(table.length/4)*3+image.length];
+        int dst = 0;
+        
+        for (int i=0; i&lt;table.length; i+=4)
+        {
+            merged[dst++] = table[i]; // R
+            merged[dst++] = table[i+1]; // G
+            merged[dst++] = table[i+2]; // B
+        }
+        
+        for (int i=0; i&lt;image.length; i++)
+            merged[dst++] = image[i];
+
+        return merged;
+    }
+
+    
+    private byte[] mergeAlpha(byte[] image, byte[] table)
+    {
+        byte[] merged = new byte[table.length+image.length];
+        int dst = 0;
+        
+        for (int i=0; i&lt;table.length; i++) {
+            merged[dst++] = table[i];
+        }
+        
+        for (int i=0; i&lt;image.length; i++) {
+            merged[dst++] = image[i];
+        }
+        return merged;
+    }
+
+    /**
+     * Generates the shape definition object that is required to display an image in a Flash movie.
+     * The shape is generated with a single fill style (FSBitmapFill object). The origin of the shape
+     * is specified relative to the top left corner of the image.
+     *
+     * The borderStyle argument specifies a border that will be drawn around the image. The style
+     * may be set to null is no border is drawn.
+     * 
+     * @param identifier an unique identifier that is used to reference the shape definition in a  
+     * Flash movie.
+     *
+     * @param imageIdentifier the unique identifier of the image generated using the defineImage() method.
+     * 
+     * @param xOrigin the offset in pixels along the x-axis, relative to the top left corner of 
+     * the image, where the origin (0,0) of the shape will be located.
+     * 
+     * @param yOrigin the offset in pixels along the y-axis, relative to the top left corner of 
+     * the image, where the origin (0,0) of the shape will be located.
+     *
+     * @param borderStyle the style drawn around the border of the image. May be null if no 
+     * border is drawn.
+     */
+    public FSDefineShape3 defineEnclosingShape(int identifier, FSDefineObject image, int xOrigin, int yOrigin, FSLineStyle borderStyle)
+    {
+    	int width = 0;
+    	int height = 0;
+        int lineWidth = 0;
+        
+        switch (image.getType())
+        {
+        	case FSMovieObject.DefineImage:
+        		width = ((FSDefineImage)image).getWidth();
+        		height = ((FSDefineImage)image).getHeight();
+        		break;
+        	case FSMovieObject.DefineImage2:
+        		width = ((FSDefineImage2)image).getWidth();
+        		height = ((FSDefineImage2)image).getHeight();
+        		break;
+        	case FSMovieObject.DefineJPEGImage:
+        		width = ((FSDefineJPEGImage)image).getWidth();
+        		height = ((FSDefineJPEGImage)image).getHeight();
+        		break;
+        	case FSMovieObject.DefineJPEGImage2:
+        		width = ((FSDefineJPEGImage2)image).getWidth();
+        		height = ((FSDefineJPEGImage2)image).getHeight();
+        		break;
+        	case FSMovieObject.DefineJPEGImage3:
+        		width = ((FSDefineJPEGImage3)image).getWidth();
+        		height = ((FSDefineJPEGImage3)image).getHeight();
+        		break;
+        }
+        
+        if (borderStyle != null)
+            lineWidth = borderStyle.getWidth() / 2;
+        
+        FSBounds bounds = new FSBounds(-xOrigin*20-lineWidth, -yOrigin*20-lineWidth, 
+            (width-xOrigin)*20+lineWidth, (height-yOrigin)*20+lineWidth);
+
+        FSShape shape = new FSShape();
+    
+        shape.add(new FSShapeStyle((borderStyle != null) ? 1 : 0, 1, 0, -xOrigin*20, -yOrigin*20));
+        shape.add(new FSLine(width*20, 0));
+        shape.add(new FSLine(0, height*20));
+        shape.add(new FSLine(-width*20, 0));
+        shape.add(new FSLine(0, -height*20));
+        
+        FSDefineShape3 definition = new FSDefineShape3(identifier, bounds, new ArrayList&lt;FSFillStyle&gt;(), new ArrayList&lt;FSLineStyle&gt;(), shape);
+        FSCoordTransform transform = new FSCoordTransform(-xOrigin*20, -yOrigin*20, 20.0, 20.0);
+    
+        if (borderStyle != null)
+            definition.add(borderStyle);
+        
+        definition.add(new FSBitmapFill(FSFillStyle.Clipped, image.getIdentifier(), transform));
+
+        return definition;
+    }
+        
+    private byte[] zip(byte[] image, byte[] table, boolean hasAlpha)
+    {
+        int bytesPerColor = hasAlpha ? 4 : 3;
+        
+        byte[] combinedData = new byte[table.length*bytesPerColor+image.length];
+        int index = 0;
+        
+        /*
+         * Add colour table to start of combined data
+         */
+        for (int i=0; i&lt;table.length; i+=4)
+        {
+            combinedData[index++] = table[i]; // R
+            combinedData[index++] = table[i+1]; // G
+            combinedData[index++] = table[i+2]; // B
+            
+            if (hasAlpha)
+                combinedData[index++] = table[i+3]; // A
+        }
+        
+        /*
+         * Now add image to combined data
+         */
+        for (int i=0; i&lt;image.length; i++)
+            combinedData[index++] = image[i];
+
+        return zip(combinedData);
+    }
+
+    private byte[] zip(byte[] image)
+    {
+        Deflater deflater = new Deflater();
+        deflater.setInput(image);
+        deflater.finish();
+        
+        byte[] compressedData = new byte[image.length*2];
+        int bytesCompressed = deflater.deflate(compressedData);
+
+        byte[] newData = new byte[bytesCompressed];
+        
+        for (int i=0; i&lt;bytesCompressed; i++)
+            newData[i] = compressedData[i];
+            
+        return newData;
+    }
+
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/ImageDecoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/ImageDecoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/ImageDecoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,15 @@
+package com.flagstone.transform.util;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+
+public interface ImageDecoder
+{
+	public int getFormat();
+	public int getWidth();
+	public int getHeight();
+	public byte[] getImage();
+	public byte[] getTable();
+	public void decode(String path) throws FileNotFoundException, IOException, DataFormatException;
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/ImageInfo.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/ImageInfo.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/ImageInfo.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,1232 @@
+package com.flagstone.transform.util;
+
+/*
+ * ImageInfo.java
+ *
+ * Version 1.9
+ *
+ * A Java class to determine image width, height and color depth for
+ * a number of image file formats.
+ *
+ * Written by Marco Schmidt 
+ *
+ * Contributed to the Public Domain.
+ */
+
+import java.io.DataInput;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.util.Vector;
+
+/**
+ * Get file format, image resolution, number of bits per pixel and optionally 
+ * number of images, comments and physical resolution from 
+ * JPEG, GIF, BMP, PCX, PNG, IFF, RAS, PBM, PGM, PPM and PSD files 
+ * (or input streams).
+ * &lt;p&gt;
+ * Use the class like this:
+ * &lt;pre&gt;
+ * ImageInfo ii = new ImageInfo();
+ * ii.setInput(in); // in can be InputStream or RandomAccessFile
+ * ii.setDetermineImageNumber(true); // default is false
+ * ii.setCollectComments(true); // default is false
+ * if (!ii.check()) {
+ *   System.err.println(&quot;Not a supported image file format.&quot;);
+ *   return;
+ * }
+ * System.out.println(ii.getFormatName() + &quot;, &quot; + ii.getMimeType() + 
+ *   &quot;, &quot; + ii.getWidth() + &quot; x &quot; + ii.getHeight() + &quot; pixels, &quot; + 
+ *   ii.getBitsPerPixel() + &quot; bits per pixel, &quot; + ii.getNumberOfImages() +
+ *   &quot; image(s), &quot; + ii.getNumberOfComments() + &quot; comment(s).&quot;);
+ *  // there are other properties, check out the API documentation
+ * &lt;/pre&gt;
+ * You can also use this class as a command line program.
+ * Call it with a number of image file names and URLs as parameters:
+ * &lt;pre&gt;
+ *   java ImageInfo *.jpg *.png *.gif <A HREF="http://somesite.tld/image.jpg">http://somesite.tld/image.jpg</A>
+ * &lt;/pre&gt;
+ * or call it without parameters and pipe data to it:
+ * &lt;pre&gt;
+ *   java ImageInfo &lt; image.jpg  
+ * &lt;/pre&gt;
+ * &lt;p&gt;
+ * Known limitations:
+ * &lt;ul&gt;
+ * &lt;li&gt;When the determination of the number of images is turned off, GIF bits 
+ *  per pixel are only read from the global header.
+ *  For some GIFs, local palettes change this to a typically larger
+ *  value. To be certain to get the correct color depth, call
+ *  setDetermineImageNumber(true) before calling check().
+ *  The complete scan over the GIF file will take additional time.&lt;/li&gt;
+ * &lt;li&gt;Transparency information is not included in the bits per pixel count.
+ *  Actually, it was my decision not to include those bits, so it's a feature! ;-)&lt;/li&gt;
+ * &lt;/ul&gt;
+ * &lt;p&gt;
+ * Requirements:
+ * &lt;ul&gt;
+ * &lt;li&gt;Java 1.1 or higher&lt;/li&gt;
+ * &lt;/ul&gt;
+ * &lt;p&gt;
+ * The latest version can be found at &lt;a href=&quot;<A HREF="http://schmidt.devlib.org/image-info/">http://schmidt.devlib.org/image-info/</A>&quot;&gt;<A HREF="http://schmidt.devlib.org/image-info/&lt;/a">http://schmidt.devlib.org/image-info/&lt;/a</A>&gt;.
+ * &lt;p&gt;
+ * Written by Marco Schmidt.
+ * &lt;p&gt;
+ * This class is contributed to the Public Domain.
+ * Use it at your own risk.
+ * &lt;p&gt;
+ * &lt;a name=&quot;history&quot;&gt;History&lt;/a&gt;:
+ * &lt;ul&gt;
+ * &lt;li&gt;&lt;strong&gt;2001-08-24&lt;/strong&gt; Initial version.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2001-10-13&lt;/strong&gt; Added support for the file formats BMP and PCX.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2001-10-16&lt;/strong&gt; Fixed bug in read(int[], int, int) that returned
+ * &lt;li&gt;&lt;strong&gt;2002-01-22&lt;/strong&gt; Added support for file formats Amiga IFF and Sun Raster (RAS).&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2002-01-24&lt;/strong&gt; Added support for file formats Portable Bitmap / Graymap / Pixmap (PBM, PGM, PPM) and Adobe Photoshop (PSD).
+ *   Added new method getMimeType() to return the MIME type associated with a particular file format.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2002-03-15&lt;/strong&gt; Added support to recognize number of images in file. Only works with GIF.
+ *   Use {@link #setDetermineImageNumber} with &lt;code&gt;true&lt;/code&gt; as argument to identify animated GIFs
+ *   ({@link #getNumberOfImages()} will return a value larger than &lt;code&gt;1&lt;/code&gt;).&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2002-04-10&lt;/strong&gt; Fixed a bug in the feature 'determine number of images in animated GIF' introduced with version 1.1.
+ *   Thanks to Marcelo P. Lima for sending in the bug report. 
+ *   Released as 1.1.1.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2002-04-18&lt;/strong&gt; Added {@link #setCollectComments(boolean)}. 
+ *  That new method lets the user specify whether textual comments are to be  
+ *  stored in an internal list when encountered in an input image file / stream.
+ *  Added two methods to return the physical width and height of the image in dpi: 
+ *   {@link #getPhysicalWidthDpi()} and {@link #getPhysicalHeightDpi()}.
+ *  If the physical resolution could not be retrieved, these methods return &lt;code&gt;-1&lt;/code&gt;.
+ *  &lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2002-04-23&lt;/strong&gt; Added support for the new properties physical resolution and
+ *   comments for some formats. Released as 1.2.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2002-06-17&lt;/strong&gt; Added support for SWF, sent in by Michael Aird.
+ *  Changed checkJpeg() so that other APP markers than APP0 will not lead to a failure anymore.
+ *  Released as 1.3.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2003-07-28&lt;/strong&gt; Bug fix - skip method now takes return values into consideration.
+ *  Less bytes than necessary may have been skipped, leading to flaws in the retrieved information in some cases.
+ *  Thanks to Bernard Bernstein for pointing that out.
+ *  Released as 1.4.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2004-02-29&lt;/strong&gt; Added support for recognizing progressive JPEG and
+ *  interlaced PNG and GIF. A new method {@link #isProgressive()} returns whether ImageInfo
+ *  has found that the storage type is progressive (or interlaced). 
+ *  Thanks to Joe Germuska for suggesting the feature.
+ *  Bug fix: BMP physical resolution is now correctly determined.
+ *  Released as 1.5.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2004-11-30&lt;/strong&gt; Bug fix: recognizing progressive GIFs 
+ * (interlaced in GIF terminology) did not work (thanks to Franz Jeitler for 
+ *   pointing this out). Now it should work, but only if the number of images is determined.
+ *  This is because information on interlacing is stored in a local image header.
+ *  In theory, different images could be stored interlaced and non-interlaced in one 
+ *  file. However, I think  that's unlikely. Right now, the last image in the GIF file 
+ *  that is examined by ImageInfo is used for the &quot;progressive&quot; status.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2005-01-02&lt;/strong&gt; Some code clean up (unused methods and variables
+ *  commented out, missing javadoc comments, etc.). Thanks to George Sexton for a long list.
+ *  Removed usage of Boolean.toString because
+ *  it's a Java 1.4+ feature (thanks to Gregor Dupont).
+ *  Changed delimiter character in compact output from semicolon to tabulator
+ * (for better integration with cut(1) and other Unix tools).
+ *  Added some points to the &lt;a href=&quot;<A HREF="http://schmidt.devlib.org/image-info/index.html#knownissues">http://schmidt.devlib.org/image-info/index.html#knownissues</A>&quot;&gt;'Known
+ *  issues' section of the website&lt;/a&gt;. 
+ *  Released as 1.6.&lt;/li&gt;
+ * &lt;li&gt;&lt;strong&gt;2005-07-26&lt;/strong&gt; Removed code to identify Flash (SWF) files.
+ *  Has repeatedly led to problems and support requests, and I don't know the
+ *  format and don't have the time and interest to fix it myself.
+ *  I repeatedly included fixes by others which didn't work for some people.
+ *  I give up on SWF. Please do not contact me about it anymore.
+ *  Set package of ImageInfo class to org.devlib.schmidt.imageinfo (a package
+ *  was repeatedly requested by some users).
+ *  Released as 1.7.&lt;/li&gt;
+ *  &lt;li&gt;&lt;strong&gt;2006-02-23&lt;/strong&gt; Removed Flash helper methods which weren't used elsewhere.
+ *   Updated skip method which tries &quot;read&quot; whenever &quot;skip(Bytes)&quot; returns a result of 0.
+ *   The old method didn't work with certain input stream types on truncated data streams.
+ *   Thanks to Martin Leidig for reporting this and sending in code.
+ *   Released as 1.8.&lt;/li&gt;
+ *  &lt;/li&gt;
+ *  &lt;li&gt;&lt;strong&gt;2006-11-13&lt;/strong&gt; Removed check that made ImageInfo report JPEG APPx
+ *   markers smaller than 14 bytes as files in unknown format. Such JPEGs seem to be
+ *   generated by Google's Picasa application. First reported with fix by 
+ *   Karl von Randow. Released as 1.9.&lt;/li&gt;  
+ * &lt;/ul&gt;
+ * @author Marco Schmidt
+ */
+public class ImageInfo {
+	/**
+	 * Return value of {@link #getFormat()} for JPEG streams.
+	 * ImageInfo can extract physical resolution and comments
+	 * from JPEGs (only from APP0 headers).
+	 * Only one image can be stored in a file.
+	 * It is determined whether the JPEG stream is progressive 
+	 * (see {@link #isProgressive()}).
+	 */
+	public static final int FORMAT_JPEG = 0;
+
+	/**
+	 * Return value of {@link #getFormat()} for GIF streams.
+	 * ImageInfo can extract comments from GIFs and count the number
+	 * of images (GIFs with more than one image are animations).
+	 * It is determined whether the GIF stream is interlaced (see {@link #isProgressive()}).
+	 */
+	public static final int FORMAT_GIF = 1;
+
+	/**
+	 * Return value of {@link #getFormat()} for PNG streams.
+	 * PNG only supports one image per file.
+	 * Both physical resolution and comments can be stored with PNG,
+	 * but ImageInfo is currently not able to extract those.
+	 * It is determined whether the PNG stream is interlaced (see {@link #isProgressive()}).
+	 */
+	public static final int FORMAT_PNG = 2;
+
+	/**
+	 * Return value of {@link #getFormat()} for BMP streams.
+	 * BMP only supports one image per file.
+	 * BMP does not allow for comments.
+	 * The physical resolution can be stored.
+	 */
+	public static final int FORMAT_BMP = 3;
+
+	/**
+	 * Return value of {@link #getFormat()} for PCX streams.
+	 * PCX does not allow for comments or more than one image per file.
+	 * However, the physical resolution can be stored.
+	 */
+	public static final int FORMAT_PCX = 4;
+
+	/**
+	 * Return value of {@link #getFormat()} for IFF streams.
+	 */
+	public static final int FORMAT_IFF = 5;
+
+	/**
+	 * Return value of {@link #getFormat()} for RAS streams.
+	 * Sun Raster allows for one image per file only and is not able to
+	 * store physical resolution or comments.
+	 */
+	public static final int FORMAT_RAS = 6;
+
+	/** Return value of {@link #getFormat()} for PBM streams. */
+	public static final int FORMAT_PBM = 7;
+
+	/** Return value of {@link #getFormat()} for PGM streams. */
+	public static final int FORMAT_PGM = 8;
+
+	/** Return value of {@link #getFormat()} for PPM streams. */
+	public static final int FORMAT_PPM = 9;
+
+	/** Return value of {@link #getFormat()} for PSD streams. */
+	public static final int FORMAT_PSD = 10;
+
+/*	public static final int COLOR_TYPE_UNKNOWN = -1;
+	public static final int COLOR_TYPE_TRUECOLOR_RGB = 0;
+	public static final int COLOR_TYPE_PALETTED = 1;
+	public static final int COLOR_TYPE_GRAYSCALE= 2;
+	public static final int COLOR_TYPE_BLACK_AND_WHITE = 3;*/
+
+	/**
+	 * The names of all supported file formats.
+	 * The FORMAT_xyz int constants can be used as index values for
+	 * this array.
+	 */
+	private static final String[] FORMAT_NAMES =
+		{&quot;JPEG&quot;, &quot;GIF&quot;, &quot;PNG&quot;, &quot;BMP&quot;, &quot;PCX&quot;, 
+		 &quot;IFF&quot;, &quot;RAS&quot;, &quot;PBM&quot;, &quot;PGM&quot;, &quot;PPM&quot;, 
+		 &quot;PSD&quot;};
+
+	/**
+	 * The names of the MIME types for all supported file formats.
+	 * The FORMAT_xyz int constants can be used as index values for
+	 * this array.
+	 */
+	private static final String[] MIME_TYPE_STRINGS =
+		{&quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/bmp&quot;, &quot;image/pcx&quot;, 
+		 &quot;image/iff&quot;, &quot;image/ras&quot;, &quot;image/x-portable-bitmap&quot;, &quot;image/x-portable-graymap&quot;, &quot;image/x-portable-pixmap&quot;, 
+		 &quot;image/psd&quot;};
+
+	private int width;
+	private int height;
+	private int bitsPerPixel;
+	//private int colorType = COLOR_TYPE_UNKNOWN;
+	private boolean progressive;
+	private int format;
+	private InputStream in;
+	private DataInput din;
+	private boolean collectComments = true;
+	private Vector comments;
+	private boolean determineNumberOfImages;
+	private int numberOfImages;
+	private int physicalHeightDpi;
+	private int physicalWidthDpi;
+
+	private void addComment(String s) {
+		if (comments == null) {
+			comments = new Vector();
+		}
+		comments.addElement(s);
+	}
+
+	/**
+	 * Call this method after you have provided an input stream or file
+	 * using {@link #setInput(InputStream)} or {@link #setInput(DataInput)}.
+	 * If true is returned, the file format was known and information
+	 * on the file's content can be retrieved using the various getXyz methods.
+	 * @return if information could be retrieved from input
+	 */
+	public boolean check() {
+		format = -1;
+		width = -1;
+		height = -1;
+		bitsPerPixel = -1;
+		numberOfImages = 1;
+		physicalHeightDpi = -1;
+		physicalWidthDpi = -1;
+		comments = null;
+		try {
+			int b1 = read() &amp; 0xff;
+			int b2 = read() &amp; 0xff;
+			if (b1 == 0x47 &amp;&amp; b2 == 0x49) {
+				return checkGif();
+			}
+			else
+			if (b1 == 0x89 &amp;&amp; b2 == 0x50) {
+				return checkPng();
+			}
+			else
+			if (b1 == 0xff &amp;&amp; b2 == 0xd8) {
+				return checkJpeg();
+			}
+			else
+			if (b1 == 0x42 &amp;&amp; b2 == 0x4d) {
+				return checkBmp();
+			}
+			else
+			if (b1 == 0x0a &amp;&amp; b2 &lt; 0x06) {
+				return checkPcx();
+			}
+			else
+			if (b1 == 0x46 &amp;&amp; b2 == 0x4f) {
+				return checkIff();
+			}
+			else
+			if (b1 == 0x59 &amp;&amp; b2 == 0xa6) {
+				return checkRas();
+			}
+			else
+			if (b1 == 0x50 &amp;&amp; b2 &gt;= 0x31 &amp;&amp; b2 &lt;= 0x36) {
+				return checkPnm(b2 - '0');
+			}
+			else
+			if (b1 == 0x38 &amp;&amp; b2 == 0x42) {
+				return checkPsd();
+			}
+			else {
+				return false;
+			}
+		} catch (IOException ioe) {
+			return false;
+		}
+	}
+
+	private boolean checkBmp() throws IOException {
+		byte[] a = new byte[44];
+		if (read(a) != a.length) {
+			return false;
+		}
+		width = getIntLittleEndian(a, 16);
+		height = getIntLittleEndian(a, 20);
+		if (width &lt; 1 || height &lt; 1) {
+			return false;
+		}
+		bitsPerPixel = getShortLittleEndian(a, 26);
+		if (bitsPerPixel != 1 &amp;&amp; bitsPerPixel != 4 &amp;&amp;
+		    bitsPerPixel != 8 &amp;&amp; bitsPerPixel != 16 &amp;&amp;
+		    bitsPerPixel != 24 &amp;&amp; bitsPerPixel != 32) {
+		    return false;
+		}
+		int x = (int)(getIntLittleEndian(a, 36) * 0.0254);
+		if (x &gt; 0) {
+			setPhysicalWidthDpi(x);
+		}
+		int y = (int)(getIntLittleEndian(a, 40) * 0.0254);
+		if (y &gt; 0) {
+			setPhysicalHeightDpi(y);
+		}
+		format = FORMAT_BMP;
+		return true;
+	}
+
+	private boolean checkGif() throws IOException {
+		final byte[] GIF_MAGIC_87A = {0x46, 0x38, 0x37, 0x61};
+		final byte[] GIF_MAGIC_89A = {0x46, 0x38, 0x39, 0x61};
+		byte[] a = new byte[11]; // 4 from the GIF signature + 7 from the global header
+		if (read(a) != 11) {
+			return false;
+		}
+		if ((!equals(a, 0, GIF_MAGIC_89A, 0, 4)) &amp;&amp;
+			(!equals(a, 0, GIF_MAGIC_87A, 0, 4))) {
+			return false;
+		}
+		format = FORMAT_GIF;
+		width = getShortLittleEndian(a, 4);
+		height = getShortLittleEndian(a, 6);
+		int flags = a[8] &amp; 0xff;
+		bitsPerPixel = ((flags &gt;&gt; 4) &amp; 0x07) + 1;
+		//progressive = (flags &amp; 0x02) != 0;
+		if (!determineNumberOfImages) {
+			return true;
+		}
+		// skip global color palette
+		if ((flags &amp; 0x80) != 0) {
+			int tableSize = (1 &lt;&lt; ((flags &amp; 7) + 1)) * 3;
+			skip(tableSize);
+		}
+		numberOfImages = 0;
+		int blockType;
+		do
+		{
+			blockType = read();
+			switch(blockType)
+			{
+				case(0x2c): // image separator
+				{
+					if (read(a, 0, 9) != 9) {
+						return false;
+					}
+					flags = a[8] &amp; 0xff;
+					progressive = (flags &amp; 0x40) != 0;
+					/*int locWidth = getShortLittleEndian(a, 4);
+					int locHeight = getShortLittleEndian(a, 6);
+					System.out.println(&quot;LOCAL: &quot; + locWidth + &quot; x &quot; + locHeight);*/
+					int localBitsPerPixel = (flags &amp; 0x07) + 1;
+					if (localBitsPerPixel &gt; bitsPerPixel) {
+						bitsPerPixel = localBitsPerPixel;
+					}
+					if ((flags &amp; 0x80) != 0) {
+						skip((1 &lt;&lt; localBitsPerPixel) * 3);
+					}
+					skip(1); // initial code length
+					int n;
+					do
+					{
+						n = read();
+						if (n &gt; 0) {
+							skip(n);
+						}
+						else
+						if (n == -1) {
+							return false;
+						}
+					}
+					while (n &gt; 0);
+					numberOfImages++;
+					break;
+				}
+				case(0x21): // extension
+				{
+					int extensionType = read();
+					if (collectComments &amp;&amp; extensionType == 0xfe) {
+						StringBuffer sb = new StringBuffer();
+						int n;
+						do
+						{
+							n = read();
+							if (n == -1) {
+								return false;
+							}
+							if (n &gt; 0) {
+								for (int i = 0; i &lt; n; i++) {
+									int ch = read();
+									if (ch == -1) {
+										return false;
+									}
+									sb.append((char)ch);
+								}
+							}
+						}
+						while (n &gt; 0);
+					} else {
+						int n;
+						do
+						{
+							n = read();
+							if (n &gt; 0) {
+								skip(n);
+							}
+							else
+							if (n == -1) {
+								return false;
+							}
+						}
+						while (n &gt; 0);
+					}
+					break;
+				}
+				case(0x3b): // end of file
+				{
+					break;
+				}
+				default:
+				{
+					return false;
+				}
+			}
+		}
+		while (blockType != 0x3b);
+		return true;
+	}
+
+	private boolean checkIff() throws IOException {
+		byte[] a = new byte[10];
+		// read remaining 2 bytes of file id, 4 bytes file size 
+		// and 4 bytes IFF subformat
+		if (read(a, 0, 10) != 10) {
+			return false;
+		}
+		final byte[] IFF_RM = {0x52, 0x4d};
+		if (!equals(a, 0, IFF_RM, 0, 2)) {
+			return false;
+		}
+		int type = getIntBigEndian(a, 6);
+		if (type != 0x494c424d &amp;&amp; // type must be ILBM...
+		    type != 0x50424d20) { // ...or PBM
+		    return false;
+		}
+		// loop chunks to find BMHD chunk
+		do {
+			if (read(a, 0, 8) != 8) {
+				return false;
+			}
+			int chunkId = getIntBigEndian(a, 0);
+			int size = getIntBigEndian(a, 4);
+			if ((size &amp; 1) == 1) {
+				size++;
+			}
+			if (chunkId == 0x424d4844) { // BMHD chunk
+				if (read(a, 0, 9) != 9) {
+					return false;
+				}
+				format = FORMAT_IFF;
+				width = getShortBigEndian(a, 0);
+				height = getShortBigEndian(a, 2);
+				bitsPerPixel = a[8] &amp; 0xff;
+				return (width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; bitsPerPixel &gt; 0 &amp;&amp; bitsPerPixel &lt; 33);
+			} else {
+				skip(size);
+			}
+		} while (true);
+	}
+
+	private boolean checkJpeg() throws IOException {
+		byte[] data = new byte[12];
+		while (true) {
+			if (read(data, 0, 4) != 4) {
+				return false;
+			}
+			int marker = getShortBigEndian(data, 0);
+			int size = getShortBigEndian(data, 2);
+			if ((marker &amp; 0xff00) != 0xff00) {
+				return false; // not a valid marker
+			}
+			if (marker == 0xffe0) { // APPx 
+				if (size &lt; 14) {
+					// not an APPx header as we know it, skip
+					skip(size - 2);
+					continue;
+				}
+				if (read(data, 0, 12) != 12) {
+					return false;
+				}
+				final byte[] APP0_ID = {0x4a, 0x46, 0x49, 0x46, 0x00};
+				if (equals(APP0_ID, 0, data, 0, 5)) {
+					//System.out.println(&quot;data 7=&quot; + data[7]);
+					if (data[7] == 1) {
+						setPhysicalWidthDpi(getShortBigEndian(data, 8));
+						setPhysicalHeightDpi(getShortBigEndian(data, 10));
+					}
+					else
+					if (data[7] == 2) {
+						int x = getShortBigEndian(data, 8);
+						int y = getShortBigEndian(data, 10);
+						setPhysicalWidthDpi((int)(x * 2.54f));
+						setPhysicalHeightDpi((int)(y * 2.54f));
+					}
+				}
+				skip(size - 14);
+			}
+			else
+			if (collectComments &amp;&amp; size &gt; 2 &amp;&amp; marker == 0xfffe) { // comment
+				size -= 2;
+				byte[] chars = new byte[size];
+				if (read(chars, 0, size) != size) {
+					return false;
+				}
+				String comment = new String(chars, &quot;iso-8859-1&quot;);
+				comment = comment.trim();
+				addComment(comment);
+			}
+			else
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) {
+				if (read(data, 0, 6) != 6) {
+					return false;
+				}
+				format = FORMAT_JPEG;
+				bitsPerPixel = (data[0] &amp; 0xff) * (data[5] &amp; 0xff);
+				progressive = marker == 0xffc2 || marker == 0xffc6 ||
+					marker == 0xffca || marker == 0xffce;
+				width = getShortBigEndian(data, 3);
+				height = getShortBigEndian(data, 1);
+				return true;
+			} else {
+				skip(size - 2);
+			}
+		}
+	}
+
+	private boolean checkPcx() throws IOException {
+		byte[] a = new byte[64];
+		if (read(a) != a.length) {
+			return false;
+		}
+		if (a[0] != 1) { // encoding, 1=RLE is only valid value
+			return false;
+		}
+		// width / height
+		int x1 = getShortLittleEndian(a, 2);
+		int y1 = getShortLittleEndian(a, 4);
+		int x2 = getShortLittleEndian(a, 6);
+		int y2 = getShortLittleEndian(a, 8);
+		if (x1 &lt; 0 || x2 &lt; x1 || y1 &lt; 0 || y2 &lt; y1) {
+			return false;
+		}
+		width = x2 - x1 + 1;
+		height = y2 - y1 + 1;
+		// color depth
+		int bits = a[1];
+		int planes = a[63];
+		if (planes == 1 &amp;&amp;
+		    (bits == 1 || bits == 2 || bits == 4 || bits == 8)) {
+			// paletted
+			bitsPerPixel = bits;
+		} else
+		if (planes == 3 &amp;&amp; bits == 8) {
+			// RGB truecolor
+			bitsPerPixel = 24;
+		} else {
+			return false;
+		}
+		setPhysicalWidthDpi(getShortLittleEndian(a, 10));
+		setPhysicalHeightDpi(getShortLittleEndian(a, 10));
+		format = FORMAT_PCX;
+		return true;
+	}
+
+	private boolean checkPng() throws IOException {
+		final byte[] PNG_MAGIC = {0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};
+		byte[] a = new byte[27];
+		if (read(a) != 27) {
+			return false;
+		}
+		if (!equals(a, 0, PNG_MAGIC, 0, 6)) {
+			return false;
+		}
+		format = FORMAT_PNG;
+		width = getIntBigEndian(a, 14);
+		height = getIntBigEndian(a, 18);
+		bitsPerPixel = a[22] &amp; 0xff;
+		int colorType = a[23] &amp; 0xff;
+		if (colorType == 2 || colorType == 6) {
+			bitsPerPixel *= 3;
+		}
+		progressive = (a[26] &amp; 0xff) != 0;
+		return true;
+	}
+
+	private boolean checkPnm(int id) throws IOException {
+		if (id &lt; 1 || id &gt; 6) {
+			return false;
+		}
+		final int[] PNM_FORMATS = {FORMAT_PBM, FORMAT_PGM, FORMAT_PPM};
+		format = PNM_FORMATS[(id - 1) % 3];
+		boolean hasPixelResolution = false;
+		String s;
+		while (true)
+		{
+			s = readLine();
+			if (s != null) {
+				s = s.trim();
+			}
+			if (s == null || s.length() &lt; 1) {
+				continue;
+			}
+			if (s.charAt(0) == '#') { // comment
+				if (collectComments &amp;&amp; s.length() &gt; 1) {
+					addComment(s.substring(1));
+				}
+				continue;
+			}
+			if (!hasPixelResolution) { // split &quot;343 966&quot; into width=343, height=966
+				int spaceIndex = s.indexOf(' ');
+				if (spaceIndex == -1) {
+					return false;
+				}
+				String widthString = s.substring(0, spaceIndex);
+				spaceIndex = s.lastIndexOf(' ');
+				if (spaceIndex == -1) {
+					return false;
+				}
+				String heightString = s.substring(spaceIndex + 1);
+				try {
+					width = Integer.parseInt(widthString);
+					height = Integer.parseInt(heightString);
+				} catch (NumberFormatException nfe) {
+					return false;
+				}
+				if (width &lt; 1 || height &lt; 1) {
+					return false;
+				}
+				if (format == FORMAT_PBM) {
+					bitsPerPixel = 1;
+					return true;
+				}
+				hasPixelResolution = true;
+			}
+			else
+			{
+				int maxSample;
+				try {
+					maxSample = Integer.parseInt(s);
+				} catch (NumberFormatException nfe) {
+					return false;
+				}
+				if (maxSample &lt; 0) {
+					return false;
+				}
+				for (int i = 0; i &lt; 25; i++) {
+					if (maxSample &lt; (1 &lt;&lt; (i + 1))) {
+						bitsPerPixel = i + 1;
+						if (format == FORMAT_PPM) {
+							bitsPerPixel *= 3;
+						}
+						return true;
+					}
+				}
+				return false;
+			}
+		}
+	}
+
+	private boolean checkPsd() throws IOException {
+		byte[] a = new byte[24];
+		if (read(a) != a.length) {
+			return false;
+		}
+		final byte[] PSD_MAGIC = {0x50, 0x53};
+		if (!equals(a, 0, PSD_MAGIC, 0, 2)) {
+			return false;
+		}
+		format = FORMAT_PSD;
+		width = getIntBigEndian(a, 16);
+		height = getIntBigEndian(a, 12);
+		int channels = getShortBigEndian(a, 10);
+		int depth = getShortBigEndian(a, 20);
+		bitsPerPixel = channels * depth;
+		return (width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; bitsPerPixel &gt; 0 &amp;&amp; bitsPerPixel &lt;= 64);
+	}
+
+	private boolean checkRas() throws IOException {
+		byte[] a = new byte[14];
+		if (read(a) != a.length) {
+			return false;
+		}
+		final byte[] RAS_MAGIC = {0x6a, (byte)0x95};
+		if (!equals(a, 0, RAS_MAGIC, 0, 2)) {
+			return false;
+		}
+		format = FORMAT_RAS;
+		width = getIntBigEndian(a, 2);
+		height = getIntBigEndian(a, 6);
+		bitsPerPixel = getIntBigEndian(a, 10);
+		return (width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; bitsPerPixel &gt; 0 &amp;&amp; bitsPerPixel &lt;= 24);
+	}
+
+	/**
+	 * Run over String list, return false iff at least one of the arguments
+	 * equals &lt;code&gt;-c&lt;/code&gt;.
+	 * @param args string list to check
+	 */
+	private static boolean determineVerbosity(String[] args) {
+		if (args != null &amp;&amp; args.length &gt; 0) {
+			for (int i = 0; i &lt; args.length; i++) {
+				if (&quot;-c&quot;.equals(args[i])) {
+					return false;
+				}
+			}
+		}
+		return true;
+	}
+
+	private static boolean equals(byte[] a1, int offs1, byte[] a2, int offs2, int num) {
+		while (num-- &gt; 0) {
+			if (a1[offs1++] != a2[offs2++]) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	/** 
+	 * If {@link #check()} was successful, returns the image's number of bits per pixel.
+	 * Does not include transparency information like the alpha channel.
+	 * @return number of bits per image pixel
+	 */
+	public int getBitsPerPixel() {
+		return bitsPerPixel;
+	}
+
+	/**
+	 * Returns the index'th comment retrieved from the file.
+	 * @param index int index of comment to return
+	 * @throws IllegalArgumentException if index is smaller than 0 or larger than or equal
+	 * to the number of comments retrieved
+	 * @see #getNumberOfComments
+	 */
+	public String getComment(int index) {
+		if (comments == null || index &lt; 0 || index &gt;= comments.size()) {
+			throw new IllegalArgumentException(&quot;Not a valid comment index: &quot; + index);
+		}
+		return (String)comments.elementAt(index);
+	}
+
+	/**
+	 * If {@link #check()} was successful, returns the image format as one
+	 * of the FORMAT_xyz constants from this class.
+	 * Use {@link #getFormatName()} to get a textual description of the file format.
+	 * @return file format as a FORMAT_xyz constant
+	 */
+	public int getFormat() {
+		return format;
+	}
+
+	/**
+	 * If {@link #check()} was successful, returns the image format's name.
+	 * Use {@link #getFormat()} to get a unique number.
+	 * @return file format name
+	 */
+	public String getFormatName() {
+		if (format &gt;= 0 &amp;&amp; format &lt; FORMAT_NAMES.length) {
+			return FORMAT_NAMES[format];
+		} else {
+			return &quot;?&quot;;
+		}
+	}
+
+	/** 
+	 * If {@link #check()} was successful, returns one the image's vertical
+	 * resolution in pixels.
+	 * @return image height in pixels
+	 */
+	public int getHeight() {
+		return height;
+	}
+
+	private static int getIntBigEndian(byte[] a, int offs) {
+		return
+			(a[offs] &amp; 0xff) &lt;&lt; 24 | 
+			(a[offs + 1] &amp; 0xff) &lt;&lt; 16 | 
+			(a[offs + 2] &amp; 0xff) &lt;&lt; 8 | 
+			a[offs + 3] &amp; 0xff;
+	}
+
+	private static int getIntLittleEndian(byte[] a, int offs) {
+		return
+			(a[offs + 3] &amp; 0xff) &lt;&lt; 24 | 
+			(a[offs + 2] &amp; 0xff) &lt;&lt; 16 | 
+			(a[offs + 1] &amp; 0xff) &lt;&lt; 8 | 
+			a[offs] &amp; 0xff;
+	}
+
+	/** 
+	 * If {@link #check()} was successful, returns a String with the
+	 * MIME type of the format.
+	 * @return MIME type, e.g. &lt;code&gt;image/jpeg&lt;/code&gt;
+	 */
+	public String getMimeType() {
+		if (format &gt;= 0 &amp;&amp; format &lt; MIME_TYPE_STRINGS.length) {
+			if (format == FORMAT_JPEG &amp;&amp; progressive)
+			{
+				return &quot;image/pjpeg&quot;;
+			}
+			return MIME_TYPE_STRINGS[format];
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * If {@link #check()} was successful and {@link #setCollectComments(boolean)} was called with
+	 * &lt;code&gt;true&lt;/code&gt; as argument, returns the number of comments retrieved 
+	 * from the input image stream / file.
+	 * Any number &gt;= 0 and smaller than this number of comments is then a
+	 * valid argument for the {@link #getComment(int)} method.
+	 * @return number of comments retrieved from input image
+	 */
+	public int getNumberOfComments()
+	{
+		if (comments == null) {
+			return 0;
+		} else {
+			return comments.size();
+		}
+	}
+
+	/**
+	 * Returns the number of images in the examined file.
+	 * Assumes that &lt;code&gt;setDetermineImageNumber(true);&lt;/code&gt; was called before
+	 * a successful call to {@link #check()}.
+	 * This value can currently be only different from &lt;code&gt;1&lt;/code&gt; for GIF images.
+	 * @return number of images in file
+	 */
+	public int getNumberOfImages()
+	{
+		return numberOfImages;
+	}
+
+	/**
+	 * Returns the physical height of this image in dots per inch (dpi).
+	 * Assumes that {@link #check()} was successful.
+	 * Returns &lt;code&gt;-1&lt;/code&gt; on failure.
+	 * @return physical height (in dpi)
+	 * @see #getPhysicalWidthDpi()
+	 * @see #getPhysicalHeightInch()
+	 */
+	public int getPhysicalHeightDpi() {
+		return physicalHeightDpi;
+	}
+
+	/**
+	 * If {@link #check()} was successful, returns the physical width of this image in dpi (dots per inch)
+	 * or -1 if no value could be found.
+	 * @return physical height (in dpi)
+	 * @see #getPhysicalHeightDpi()
+	 * @see #getPhysicalWidthDpi()
+	 * @see #getPhysicalWidthInch()
+	 */
+	public float getPhysicalHeightInch() {
+		int h = getHeight();
+		int ph = getPhysicalHeightDpi();
+		if (h &gt; 0 &amp;&amp; ph &gt; 0) {
+			return ((float)h) / ((float)ph);
+		} else {
+			return -1.0f;
+		}
+	}
+
+	/**
+	 * If {@link #check()} was successful, returns the physical width of this image in dpi (dots per inch)
+	 * or -1 if no value could be found.
+	 * @return physical width (in dpi)
+	 * @see #getPhysicalHeightDpi()
+	 * @see #getPhysicalWidthInch()
+	 * @see #getPhysicalHeightInch()
+	 */
+	public int getPhysicalWidthDpi() {
+		return physicalWidthDpi;
+	}
+
+	/**
+	 * Returns the physical width of an image in inches, or
+	 * &lt;code&gt;-1.0f&lt;/code&gt; if width information is not available.
+	 * Assumes that {@link #check} has been called successfully.
+	 * @return physical width in inches or &lt;code&gt;-1.0f&lt;/code&gt; on failure
+	 * @see #getPhysicalWidthDpi
+	 * @see #getPhysicalHeightInch
+	 */
+	public float getPhysicalWidthInch() {
+		int w = getWidth();
+		int pw = getPhysicalWidthDpi();
+		if (w &gt; 0 &amp;&amp; pw &gt; 0) {
+			return ((float)w) / ((float)pw);
+		} else {
+			return -1.0f;
+		}
+	}
+
+	private static int getShortBigEndian(byte[] a, int offs) {
+		return
+			(a[offs] &amp; 0xff) &lt;&lt; 8 | 
+			(a[offs + 1] &amp; 0xff);
+	}
+
+	private static int getShortLittleEndian(byte[] a, int offs) {
+		return (a[offs] &amp; 0xff) | (a[offs + 1] &amp; 0xff) &lt;&lt; 8;
+	}
+
+	/** 
+	 * If {@link #check()} was successful, returns one the image's horizontal
+	 * resolution in pixels.
+	 * @return image width in pixels
+	 */
+	public int getWidth() {
+		return width;
+	}
+
+	/**
+	 * Returns whether the image is stored in a progressive (also called: interlaced) way.
+	 * @return true for progressive/interlaced, false otherwise
+	 */
+	public boolean isProgressive()
+	{
+		return progressive;
+	}
+
+	/**
+	 * To use this class as a command line application, give it either 
+	 * some file names as parameters (information on them will be
+	 * printed to standard output, one line per file) or call
+	 * it with no parameters. It will then check data given to it
+	 * via standard input.
+	 * @param args the program arguments which must be file names
+	 */
+	public static void main(String[] args) {
+		ImageInfo imageInfo = new ImageInfo();
+		imageInfo.setDetermineImageNumber(true);
+		boolean verbose = determineVerbosity(args);
+		if (args.length == 0) {
+			run(null, System.in, imageInfo, verbose);
+		} else {
+			int index = 0;
+			while (index &lt; args.length) {
+				InputStream in = null;
+				try {
+					String name = args[index++];
+					System.out.print(name + &quot;;&quot;);
+					if (name.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
+						in = new URL(name).openConnection().getInputStream();
+					} else {
+						in = new FileInputStream(name);
+					}
+					run(name, in, imageInfo, verbose);
+					in.close();
+				} catch (IOException e) {
+					System.out.println(e);
+					try {
+						if (in != null) {
+							in.close();
+						}
+					} catch (IOException ee) {
+					}
+				}
+			}
+		}
+	}
+
+	private static void print(String sourceName, ImageInfo ii, boolean verbose) {
+		if (verbose) {
+			printVerbose(sourceName, ii);
+		} else {
+			printCompact(sourceName, ii);
+		}
+	}
+
+	private static void printCompact(String sourceName, ImageInfo imageInfo) {
+		final String SEP = &quot;\t&quot;;
+		System.out.println(
+			sourceName + SEP + 
+			imageInfo.getFormatName() + SEP +
+			imageInfo.getMimeType() + SEP +
+			imageInfo.getWidth() + SEP +
+			imageInfo.getHeight() + SEP +
+			imageInfo.getBitsPerPixel() + SEP +
+			imageInfo.getNumberOfImages() + SEP +
+			imageInfo.getPhysicalWidthDpi() + SEP +
+			imageInfo.getPhysicalHeightDpi() + SEP +
+			imageInfo.getPhysicalWidthInch() + SEP +
+			imageInfo.getPhysicalHeightInch() + SEP +
+			imageInfo.isProgressive()
+		);
+	}
+
+	private static void printLine(int indentLevels, String text, float value, float minValidValue) {
+		if (value &lt; minValidValue) {
+			return;
+		}
+		printLine(indentLevels, text, Float.toString(value));
+	}
+
+	private static void printLine(int indentLevels, String text, int value, int minValidValue) {
+		if (value &gt;= minValidValue) {
+			printLine(indentLevels, text, Integer.toString(value));
+		}
+	}
+
+	private static void printLine(int indentLevels, String text, String value) {
+		if (value == null || value.length() == 0) {
+			return;
+		}
+		while (indentLevels-- &gt; 0) {
+			System.out.print(&quot;\t&quot;);
+		}
+		if (text != null &amp;&amp; text.length() &gt; 0) {
+			System.out.print(text);
+			System.out.print(&quot; &quot;);
+		}
+		System.out.println(value);
+	}
+
+	private static void printVerbose(String sourceName, ImageInfo ii) {
+		printLine(0, null, sourceName);
+		printLine(1, &quot;File format: &quot;, ii.getFormatName());
+		printLine(1, &quot;MIME type: &quot;, ii.getMimeType());
+		printLine(1, &quot;Width (pixels): &quot;, ii.getWidth(), 1);
+		printLine(1, &quot;Height (pixels): &quot;, ii.getHeight(), 1);
+		printLine(1, &quot;Bits per pixel: &quot;, ii.getBitsPerPixel(), 1);
+		printLine(1, &quot;Progressive: &quot;, ii.isProgressive() ? &quot;yes&quot; : &quot;no&quot;);
+		printLine(1, &quot;Number of images: &quot;, ii.getNumberOfImages(), 1);
+		printLine(1, &quot;Physical width (dpi): &quot;, ii.getPhysicalWidthDpi(), 1);
+		printLine(1, &quot;Physical height (dpi): &quot;, ii.getPhysicalHeightDpi(), 1);
+		printLine(1, &quot;Physical width (inches): &quot;, ii.getPhysicalWidthInch(), 1.0f);
+		printLine(1, &quot;Physical height (inches): &quot;, ii.getPhysicalHeightInch(), 1.0f);
+		int numComments = ii.getNumberOfComments();
+		printLine(1, &quot;Number of textual comments: &quot;, numComments, 1);
+		if (numComments &gt; 0) {
+			for (int i = 0; i &lt; numComments; i++) {
+				printLine(2, null, ii.getComment(i));
+			}
+		}
+	}
+
+	private int read() throws IOException {
+		if (in != null) {
+			return in.read();
+		} else {
+			return din.readByte();
+		}
+	}
+
+	private int read(byte[] a) throws IOException {
+		if (in != null) {
+			return in.read(a);
+		} else {
+			din.readFully(a);
+			return a.length;
+		}
+	}
+
+	private int read(byte[] a, int offset, int num) throws IOException {
+		if (in != null) {
+			return in.read(a, offset, num);
+		} else {
+			din.readFully(a, offset, num);
+			return num;
+		}
+	}
+
+	private String readLine() throws IOException {
+		return readLine(new StringBuffer());
+	}
+
+	private String readLine(StringBuffer sb) throws IOException {
+		boolean finished;
+		do {
+			int value = read();
+			finished = (value == -1 || value == 10);
+			if (!finished) {
+				sb.append((char)value);
+			}
+		} while (!finished);
+		return sb.toString();
+	}
+
+	private static void run(String sourceName, InputStream in, ImageInfo imageInfo, boolean verbose) {
+		imageInfo.setInput(in);
+		imageInfo.setDetermineImageNumber(true);
+		imageInfo.setCollectComments(verbose);
+		if (imageInfo.check()) {
+			print(sourceName, imageInfo, verbose);
+		}
+	}
+
+	/**
+	 * Specify whether textual comments are supposed to be extracted from input.
+	 * Default is &lt;code&gt;false&lt;/code&gt;.
+	 * If enabled, comments will be added to an internal list.
+	 * @param newValue if &lt;code&gt;true&lt;/code&gt;, this class will read comments
+	 * @see #getNumberOfComments
+	 * @see #getComment
+	 */
+	public void setCollectComments(boolean newValue)
+	{
+		collectComments = newValue;
+	}
+
+	/**
+	 * Specify whether the number of images in a file is to be
+	 * determined - default is &lt;code&gt;false&lt;/code&gt;.
+	 * This is a special option because some file formats require running over
+	 * the entire file to find out the number of images, a rather time-consuming
+	 * task.
+	 * Not all file formats support more than one image.
+	 * If this method is called with &lt;code&gt;true&lt;/code&gt; as argument,
+	 * the actual number of images can be queried via 
+	 * {@link #getNumberOfImages()} after a successful call to
+	 * {@link #check()}.
+	 * @param newValue will the number of images be determined?
+	 * @see #getNumberOfImages
+	 */
+	public void setDetermineImageNumber(boolean newValue)
+	{
+		determineNumberOfImages = newValue;
+	}
+
+	/**
+	 * Set the input stream to the argument stream (or file). 
+	 * Note that {@link java.io.RandomAccessFile} implements
+	 * {@link java.io.DataInput}.
+	 * @param dataInput the input stream to read from
+	 */
+	public void setInput(DataInput dataInput) {
+		din = dataInput;
+		in = null;
+	}
+
+	/**
+	 * Set the input stream to the argument stream (or file).
+	 * @param inputStream the input stream to read from
+	 */
+	public void setInput(InputStream inputStream) {
+		in = inputStream;
+		din = null;
+	}
+
+	private void setPhysicalHeightDpi(int newValue) {
+		physicalWidthDpi = newValue;
+	}
+
+	private void setPhysicalWidthDpi(int newValue) {
+		physicalHeightDpi = newValue;
+	}
+
+    private void skip(int num) throws IOException {
+        while (num &gt; 0) {
+            long result;
+            if (in != null) {
+                result = in.skip(num);
+            } else {
+                result = din.skipBytes(num);
+            }
+            if (result &gt; 0) {
+                num -= result;
+            } else {
+                if (in != null) {
+                    result = in.read();
+                } else {
+                    result = din.readByte();
+                }
+                if (result == -1) {
+                	throw new IOException(&quot;Premature end of input.&quot;);
+                } else {
+                	num--;
+                }
+            }
+        }
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/JPGDecoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/JPGDecoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/JPGDecoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,122 @@
+/*
+ *  FSImageConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.zip.*;
+
+import com.flagstone.transform.FSCoder;
+
+public class JPGDecoder implements ImageDecoder
+{
+    private int format;
+    private int width;
+    private int height;
+    private byte[] image;
+     
+    public int getFormat()
+    {
+    	return format;
+    }
+    
+    public int getWidth()
+    {
+    	return width;
+    }
+    
+    public int getHeight()
+    {
+    	return height;
+    }
+    
+    public byte[] getTable() 
+    {
+    	return null;
+    }
+    
+    public byte[] getImage() 
+    {
+    	return image;
+    }
+    
+    public void decode(String path) throws FileNotFoundException, IOException, DataFormatException
+    {
+        format = Image.JPEG;       
+        image = dataFromFile(path);
+
+        if (jpegInfo() == false)
+            throw new DataFormatException();
+    	
+    }
+    
+    private boolean jpegInfo()
+    {
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
+                 
+        if (coder.readWord(2, false) != 0xffd8)
+            return false;
+
+        while (true) 
+        {
+            int marker = coder.readWord(2, false);
+            int size = coder.readWord(2, false);
+            
+            if ((marker &amp; 0xff00) != 0xff00) 
+                return false;
+            
+            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
+            {
+                coder.readByte();
+                height = coder.readWord(2, false);
+                width = coder.readWord(2, false);
+                return true;
+            } 
+            else 
+            {
+                coder.adjustPointer((size - 2) &lt;&lt; 3);
+            }
+        }
+    }
+
+    private byte[] dataFromFile(String filename) throws FileNotFoundException, IOException
+    {
+        File aFile = new File(filename);
+        FileInputStream imageContents = null;
+        
+        byte[] bytes = new byte[(int)aFile.length()];
+        
+        imageContents = new FileInputStream(aFile);            
+        imageContents.read(bytes);
+        imageContents.close();
+
+        return bytes;
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/MP3Decoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/MP3Decoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/MP3Decoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,264 @@
+/*
+ *  FSSoundConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.zip.*;
+import com.flagstone.transform.*;
+
+
+public class MP3Decoder implements SoundDecoder
+{
+    private static final int MPEG1 = 3;  
+    private static final int frameSizeMP3[] = { 576, 576, 576, 1152 };
+    private static final int channelCount[] = { 2, 2, 2, 1 };
+
+    private static final int bitRates[][] =
+    {
+        { -1,  8, 16, 24, 32, 40, 48, 56,  64,  80,  96, 112, 128, 144, 160, -1 }, // MPEG 2.5
+        { -1, -1, -1, -1, -1, -1, -1, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1 }, // Reserved
+        { -1,  8, 16, 24, 32, 40, 48, 56,  64,  80,  96, 112, 128, 144, 160, -1 }, // MPEG 2.0
+        { -1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1 }, // MPEG 1.0
+    };
+
+    private static final int samplingRates[][] =
+    {
+        { 11025, -1, -1, -1 },
+        {    -1, -1, -1, -1 },
+        { 22050, -1, -1, -1 },
+        { 44100, -1, -1, -1 }
+    };
+    
+    private int format;
+    private int numberOfChannels;
+    private int samplesPerChannel;
+    private int sampleRate;
+    private int sampleSize;
+    private byte[] sound = null;
+    
+    private int[][] frameTable = null;
+    private int samplesPerFrame = 0;
+
+    /**
+     * Creates a new uninitialized FSSoundConstructor object.  Use setSound to 
+     * provide the content.
+     */
+    public MP3Decoder() 
+    {
+    }
+
+    public int getFormat()
+    {
+        return format;
+    }
+
+    public int getNumberOfChannels()
+    {
+        return numberOfChannels;
+    }
+
+    public int getSamplesPerChannel()
+    {
+        return samplesPerChannel;
+    }
+
+    public int getSampleRate()
+    {
+        return sampleRate;
+    }
+
+    public int getSampleSize()
+    {
+        return sampleSize;
+    }
+
+    public byte[] getSound()
+    {
+        byte[] bytes = new byte[sound.length];
+        
+        System.arraycopy(sound, 0, bytes, 0, sound.length);
+
+        return bytes;
+    }
+
+    public void decode(String path) throws FileNotFoundException, IOException, DataFormatException
+    {
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, dataFromFile(path));
+        
+        int numberOfFrames = 0;
+        int frameStart = 0;
+
+        format = FSSound.MP3;
+        sampleSize = 2;
+        
+        while (coder.eof() == false)
+        {        
+            if (coder.scanWord(3, false) == 0x494433) // ID3
+            {
+                coder.adjustPointer(24); // ID3 signature                
+                coder.adjustPointer(8); // version number
+                coder.adjustPointer(8); // revision number
+                
+                coder.adjustPointer(1); // unsynchronized
+                coder.adjustPointer(1); // extendedHeader
+                coder.adjustPointer(1); // experimental
+                int hasFooter = coder.readBits(1, false);
+                
+                coder.adjustPointer(4);
+                
+                int totalLength = (hasFooter == 1) ? 10 : 0;
+
+                totalLength += coder.readByte() &lt;&lt; 23;
+                totalLength += coder.readByte() &lt;&lt; 15;
+                totalLength += coder.readByte() &lt;&lt; 7;
+                totalLength += coder.readByte();
+
+                coder.adjustPointer(totalLength&lt;&lt;3);
+            }
+            else if (coder.scanWord(3, false) == 0x544147) // ID3 V1
+            {
+                coder.adjustPointer(128&lt;&lt;3);
+            }
+            else if (coder.scanBits(11, false) == 0x7FF) // MP3 frame
+            {
+                if (numberOfFrames == 0)
+                    frameStart = coder.getPointer();
+                
+                coder.adjustPointer(frameSize(coder) &lt;&lt; 3);
+                numberOfFrames++;
+            }
+            else
+            {
+                /*
+                 * If we get here it means we jumped into the middle of either 
+                 * a frame or tag information. This appears to be a common
+                 * occurrence. Goto the end of the file so we can keep the 
+                 * frames found so far.
+                 */
+                coder.setPointer(coder.getData().length&lt;&lt;3);
+            }
+        }
+
+        int dataLength = coder.getData().length - (frameStart &gt;&gt; 3);
+        
+        sound = new byte[dataLength];
+        
+        System.arraycopy(coder.getData(), frameStart&gt;&gt;3, sound, 0, dataLength);
+        
+        frameTable = new int[numberOfFrames][2];
+        
+        for (int i=0; i&lt;numberOfFrames; i++)
+        {
+            frameTable[i][0] = -1;
+            frameTable[i][1] = 0;
+        }
+
+        coder.setPointer(frameStart);
+        
+        int frameNumber = 0;
+        
+        while (coder.findBits(0x7FF, 11, 8))
+        {
+            frameTable[frameNumber][0] = (coder.getPointer()- frameStart + 16) &gt;&gt; 3;
+            
+            coder.adjustPointer(11); // skip start of frame marker
+
+            int version = coder.readBits(2, false);
+            
+            samplesPerFrame = frameSizeMP3[version];
+            
+            if (coder.readBits(2, false) != 1)
+                throw new DataFormatException(&quot;Flash only supports MPEG Layer 3&quot;);
+                
+            coder.readBits(1, false); // crc follows header
+            
+            int bitRate = bitRates[version][coder.readBits(4, false)];
+            
+            if (bitRate == -1)
+                throw new DataFormatException(&quot;Unsupported Bit-rate&quot;);
+            
+            sampleRate = samplingRates[version][coder.readBits(2, false)];
+            
+            if (sampleRate == -1)
+                throw new DataFormatException(&quot;Unsupported Sampling-rate&quot;);
+            
+            int padding = coder.readBits(1, false);
+            coder.readBits(1, false); // reserved
+
+            numberOfChannels = channelCount[coder.readBits(2, false)];
+
+            coder.adjustPointer(6); // skip modeExtension, copyright, original and emphasis
+            
+            samplesPerChannel += samplesPerFrame;
+            
+            int frameSize = (((version == MPEG1) ? 144 : 72) * bitRate*1000 / sampleRate + padding) - 4;
+            
+            frameTable[frameNumber++][1] = 4 + frameSize;
+    
+            coder.adjustPointer(frameSize &lt;&lt; 3);
+        }
+    }
+    
+    private byte[] dataFromFile(String filename) throws IOException
+    {
+        File aFile = new File(filename);
+        FileInputStream imageContents = null;
+        
+        byte[] bytes = new byte[(int)aFile.length()];
+        
+        imageContents = new FileInputStream(aFile);            
+        imageContents.read(bytes);
+        imageContents.close();
+
+        return bytes;
+    }
+        
+    private int frameSize(FSCoder coder)
+    {
+        int frameSize = 4;
+        
+        coder.adjustPointer(11);
+
+        int version = coder.readBits(2, false);
+            
+        coder.adjustPointer(3);
+            
+        int bitRate = bitRates[version][coder.readBits(4, false)];
+        int samplingRate = samplingRates[version][coder.readBits(2, false)];
+           int padding = coder.readBits(1, false);
+
+        coder.adjustPointer(-23);
+            
+        frameSize += (((version == MPEG1) ? 144 : 72) * bitRate*1000 / samplingRate + padding) - 4;
+        
+        return frameSize;
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/PNGDecoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/PNGDecoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/PNGDecoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,819 @@
+/*
+ *  FSImageConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.zip.*;
+
+import com.flagstone.transform.FSCoder;
+
+public class PNGDecoder
+{
+    /** Format for JPEG encoded images */
+    public static final int JPEG = 0;
+    /** Format for indexed images containing a colour table with 24-bit colours. */
+    public static final int IDX8 = 1;
+    /** Format for indexed images containing a colour table with 32-bit colours. */
+    public static final int IDXA = 2;
+    /** Format for true colour images containing 16-bit colours, 5-bits for each colour channel. */
+    public static final int RGB5 = 3;
+    /** Format for true colour images containing 24-bit colours, 8-bits for each colour channel. */
+    public static final int RGB8 = 4;
+    /** Format for true colour images containing 32-bit colours, 8-bits for each colour channel plus transparency. */
+    public static final int RGBA = 5;
+    
+    // Tables mapping greyscale values onto 8-bit colour channels
+    
+    private static final int[] monochrome = { 0, 255 };
+    private static final int[] greyscale2 = { 0, 85, 170, 255 };
+    private static final int[] greyscale4 = { 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255 };
+    
+    // Constants used for PNG images 
+        
+    private static final int[] pngSignature = { 137, 80, 78, 71, 13, 10, 26, 10 };
+
+    /*
+     * The constants commented out in the following section are defined
+     * for completeness when decoding LNG format images.
+     */
+     
+    // private static final int CRITICAL_CHUNK = 0x20000000;
+    
+    private static final int IHDR = 0x49484452;
+    private static final int PLTE = 0x504c5445;
+    private static final int IDAT = 0x49444154;
+    private static final int IEND = 0x49454e44;
+    private static final int tRNS = 0x74524e53;
+    // private static final int bKGD = 0x624b4744;
+    // private static final int cHRM = 0x6348524d;
+    // private static final int fRAc = 0x66524163;
+    // private static final int gAMA = 0x67414d41;
+    // private static final int gIFg = 0x67494667;
+    // private static final int gIFt = 0x67494674;
+    // private static final int gIFx = 0x67494678;
+    // private static final int hIST = 0x68495354;
+    // private static final int iCCP = 0x69434350;
+    // private static final int iTXt = 0x69545874;
+    // private static final int oFFs = 0x6f464673;
+    // private static final int pCAL = 0x7043414c;
+    // private static final int pHYs = 0x70485973;
+    // private static final int sBIT = 0x73424954;
+    // private static final int sCAL = 0x7343414c;
+    // private static final int sPLT = 0x73504c54;
+    // private static final int sRGB = 0x73524742;
+    // private static final int tEXt = 0x74455874;
+    // private static final int tIME = 0x74494d45;
+    // private static final int zTXt = 0x7a545874;
+    
+    private static final int GREYSCALE = 0;
+    private static final int TRUE_COLOUR = 2;
+    private static final int INDEXED_COLOUR = 3;
+    private static final int ALPHA_GREYSCALE = 4;
+    private static final int ALPHA_TRUECOLOUR = 6;
+    
+    private static final int NO_FILTER = 0;
+    private static final int SUB_FILTER = 1;
+    private static final int UP_FILTER = 2;
+    private static final int AVG_FILTER = 3;
+    private static final int PAETH_FILTER = 4;
+    
+    private static final int[] startRow =        { 0, 0, 4, 0, 2, 0, 1 };
+    private static final int[] startColumn =     { 0, 4, 0, 2, 0, 1, 0 };
+    private static final int[] rowIncrement =    { 8, 8, 8, 4, 4, 2, 2 };
+    private static final int[] columnIncrement = { 8, 8, 4, 4, 2, 2, 1 };
+    
+    // Attributes shred between different image formats
+    private static final int BIT_DEPTH = 0;
+    private static final int COLOUR_COMPONENTS = 1;
+    private static final int COMPRESSION_METHOD = 2;
+    
+    // BMP specific attributes
+    private static final int RED_MASK = 4;
+    private static final int GREEN_MASK = 5;
+    private static final int BLUE_MASK = 6;
+
+    // PNG specific attributes
+    private static final int COLOUR_TYPE = 4;
+    private static final int FILTER_METHOD = 5;
+    private static final int INTERLACE_METHOD = 6;
+    private static final int TRANSPARENT_GREY = 7;
+    private static final int TRANSPARENT_RED = 8;
+    private static final int TRANSPARENT_GREEN = 9;
+    private static final int TRANSPARENT_BLUE = 10;
+    
+    private int format = 0;
+    private int width = 0;
+    private int height = 0;
+
+    private byte[][] colourTable = null;
+    private byte[][] indexedImage = null;
+    private byte[][][] colorImage = null;
+    
+    private int[] attributes = new int[16];
+    private byte[] chunkData = new byte[0];
+    
+    /**
+     * Constructs an FSImageConstructor object with no image.
+     */
+    public PNGDecoder()
+    {
+    }
+    
+    /**
+     * Constructs and FSImageConstructor object and loads the image from the specified file. The FSImageConstructor
+     * class support Windows bitmap (BMP), Portable Network Graphics (PNG) or JPEG encoded images.
+     *
+     * @param filename the name of the file containing the image.
+     *
+     * @throws FileNotFoundException is the file cannot be found.
+     *
+     * @throws IOException if an error occurs while reading the file.
+     *
+     * @throws DataFormatException if the file contains an unsupported image format or if an error occurs 
+     * while decoding the image in the file.
+     */
+    public PNGDecoder(String filename) throws IOException, DataFormatException
+    {
+        setImage(dataFromFile(filename));
+    }   
+    /**
+     * Constructs and FSImageConstructor object and loads the encoded image data. The FSImageConstructor
+     * class support Windows bitmap (BMP), Portable Network Graphics (PNG) or JPEG encoded images.
+     *
+     * @param bytes an array of bytes containing the encoded image.
+     *
+     * @throws DataFormatException if the data contains an unsupported image format or if an error occurs 
+     * while decoding the image.
+     */
+    public PNGDecoder(byte[] bytes) throws DataFormatException
+    {
+        setImage(bytes);
+    }
+    
+    /**
+     * Initialises the FSImageConstructor object with the image data.
+     *
+     * @param bytes an array of bytes containing the encoded image.
+     *
+     * @throws DataFormatException if the data contains an unsupported image format or if an error occurs 
+     * while decoding the image.
+     */
+    public void setImage(byte[] bytes) throws DataFormatException
+    {
+        int signature = ((bytes[0] &amp; 0xFF) &lt;&lt; 8) | (bytes[1] &amp; 0xFF);
+
+        format = 0;
+        width = 0;
+        height = 0;
+    
+        attributes[BIT_DEPTH] = 0;
+        attributes[COLOUR_COMPONENTS] = 0;
+        attributes[COLOUR_TYPE] = 0;
+        attributes[COMPRESSION_METHOD] = 0;
+        attributes[FILTER_METHOD] = 0;
+        attributes[INTERLACE_METHOD] = 0;
+        chunkData = new byte[0];
+
+        attributes[TRANSPARENT_GREY] = -1;    
+        attributes[TRANSPARENT_RED] = -1;
+        attributes[TRANSPARENT_GREEN] = -1;
+        attributes[TRANSPARENT_BLUE] = -1;
+
+        attributes[RED_MASK] = 0;
+        attributes[GREEN_MASK] = 0;
+        attributes[BLUE_MASK] = 0;
+
+        colourTable = null;
+        indexedImage = null;
+        colorImage = null;
+        
+        switch (signature)
+        {
+            case 0x8950: decodePNG(bytes); break;
+            default: 
+                throw new DataFormatException(&quot;Unsupported image format&quot;);  
+        }
+    }
+    
+    /**
+     * Returns a constant identifying the format for the way the pixels are encoded.
+     *
+     * @return the image format.
+     */
+    public int getFormat()
+    {
+        return format;
+    }
+
+    /**
+     * Returns the width of the image in pixels.
+     * 
+     * @return the image width in pixels.
+     */
+    public int getWidth()
+    {
+        return width;
+    }
+    /**
+     * Returns the height of the image in pixels.
+     * 
+     * @return the image height in pixels.
+     */
+    public int getHeight()
+    {
+        return height;
+    }   
+    /**
+     * Returns a copy of the colour table used in an indexed image. Each entry in the 
+     * colour table contains 4 bytes with one byte for the alpha channel and each
+     * of the three colour channels, red, green and blue. The alpha channel occupied the 
+     * most significant byte (3) followed by red, green and blue (the least significant byte).
+     * 
+     * For images in IDX8 format the alpha channel defaults to 255 (completely opaque).
+     * 
+     * If the image format is JPEG or one of the true colour formats (RGB5, RGB8, RGBA)
+     * then the colour table returned is null.
+     *
+     * @return a two-dimensional array of bytes containing the colours used in an indexed image.
+     */
+    public byte[][] getColorTable()
+    {
+        byte[][] table = null;
+        
+        if (colourTable != null)
+        {
+            table = new byte[colourTable.length][4];
+        
+            for (int i=0; i&lt;colourTable.length; i++)
+            {
+                for (int j=0; j&lt;4; j++)
+                    table[i][j] = colourTable[i][j];            
+            }
+        }
+        return table;
+    }
+    /**
+     * Returns a copy of the image data decoded from an indexed image. A two
+     * dimensional array is returned, byte[height][width] with each entry containing an 
+     * index into the colour table.
+     * 
+     * If the image format is JPEG or one of the true colour formats (RGB5, RGB8, RGBA)
+     * then the indexed image returned is null.
+     *
+     * @return a two-dimensional array of bytes (height x width) with each entry containing 
+     * an index into the colour table.
+     */
+    public byte[][] getIndexedImage()
+    {
+        byte[][] image = null;
+        
+        if (indexedImage != null)
+        {
+            image = new byte[height][width];
+        
+            for (int i=0; i&lt;height; i++)
+            {
+                for (int j=0; j&lt;width; j++)
+                    image[i][j] = indexedImage[i][j];            
+            }
+        }
+        return image;
+    }
+    /**
+     * Returns a copy of the image data decoded from a true colour file. A three
+     * dimensional array is returned with four bytes for each pixel in the image,
+     * byte[height][width][4] - one byte for the red [0], green [1], blue [2] and
+     * alpha [3] channels.
+     * 
+     * If the image format is JPEG or an indexed image (IDX8, IDXA) then the image
+     * data returned is null.
+     *
+     * @return an array of bytes containing the colour channels for each pixel in
+     * the image.
+     */
+    public byte[][][] getColorImage()
+    {
+        byte[][][] image = null;
+        
+        if (colorImage != null)
+        {
+            image = new byte[height][width][4];
+
+            for (int h=0; h&lt;height; h++)
+            {
+                for (int w=0; w&lt;width; w++)
+                {
+                    image[h][w][0] = colorImage[h][w][0];    
+                    image[h][w][1] = colorImage[h][w][1];    
+                    image[h][w][2] = colorImage[h][w][2];    
+                    image[h][w][3] = colorImage[h][w][3];    
+                }
+            }
+        }
+        return image;
+    }
+
+    byte[] getImage()
+    {
+        int row = 0;
+        int col = 0;
+        int index = 0;
+        int scanLength = 0;
+        byte[] formattedImage = null;
+        
+        switch (format)
+        {
+            case IDX8:
+            case IDXA: 
+                scanLength = (width + 3) &amp; ~3;
+                formattedImage = new byte[scanLength*height];
+                for (row=0; row&lt;height; row++)
+                {
+                    for (col=0; col&lt;width; col++)
+                        formattedImage[index++] = indexedImage[row][col];
+                    
+                    for (; col&lt;scanLength; col++)
+                        formattedImage[index++] = 0;
+                }
+                break;
+            case RGB5: 
+                scanLength = width + (width &amp; 1);
+                formattedImage = new byte[scanLength*height*2];
+                for (row=0; row&lt;height; row++)
+                {
+                    for (col=0; col&lt;width; col++)
+                    {
+                        int red = (colorImage[row][col][0] &amp; 0xF8) &lt;&lt; 7;
+                        int green = (colorImage[row][col][1] &amp; 0xF8) &lt;&lt; 2;
+                        int blue = (colorImage[row][col][2] &amp; 0xF8) &gt;&gt; 3;
+                        int colour = (red | green | blue) &amp; 0x7FFF;
+                        
+                        formattedImage[index++] = (byte) (colour &gt;&gt; 8);
+                        formattedImage[index++] = (byte) colour;
+                    }
+
+                    for (; col&lt;scanLength; col++)
+                    {
+                        formattedImage[index++] = 0;
+                        formattedImage[index++] = 0;
+                    }
+                }
+                break;
+            case RGB8: 
+                formattedImage = new byte[width*height*4];
+                for (row=0; row&lt;height; row++)
+                {
+                    for (col=0; col&lt;width; col++)
+                    {
+                        formattedImage[index++] = (byte)0xFF;
+                        formattedImage[index++] = colorImage[row][col][0];
+                        formattedImage[index++] = colorImage[row][col][1];
+                        formattedImage[index++] = colorImage[row][col][2];
+                    }
+                }
+                break;
+            case RGBA: 
+                formattedImage = new byte[width*height*4];
+                for (row=0; row&lt;height; row++)
+                {
+                    for (col=0; col&lt;width; col++)
+                    {
+                        int alpha = colorImage[row][col][3] &amp; 0xFF;
+                        int red = ((colorImage[row][col][0] &amp; 0xFF) * alpha) / 255;
+                        int green = ((colorImage[row][col][1] &amp; 0xFF) * alpha) / 255;
+                        int blue = ((colorImage[row][col][2] &amp; 0xFf) * alpha) / 255;
+                            
+                        formattedImage[index++] = (byte)alpha;
+                        formattedImage[index++] = (byte)red;
+                        formattedImage[index++] = (byte)green;
+                        formattedImage[index++] = (byte)blue;
+                    }
+                }
+                break;
+        }
+        return formattedImage;
+    }
+            
+    private void decodePNG(byte[] bytes) throws DataFormatException
+    {
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
+
+        int length = 0;
+        int chunkType = 0;
+        boolean moreChunks = true;
+
+        for (int i=0; i&lt;8; i++)
+        {
+            if (coder.readByte() != pngSignature[i])
+                throw new DataFormatException(&quot;Not a valid PNG file&quot;);
+        }
+        
+        while (moreChunks)
+        {
+            length = coder.readWord(4, false);
+            chunkType = coder.readWord(4, false);
+            
+            int current = coder.getPointer();
+            int next = current + ((length+4) &lt;&lt; 3);
+            
+            switch (chunkType)
+            {
+                case IHDR: decodeIHDR(coder, length); break;
+                case PLTE: decodePLTE(coder, length); break;
+                case tRNS: decodeTRNS(coder, length); break;
+                case IDAT: decodeIDAT(coder, length); break;
+                case IEND: moreChunks = false; coder.adjustPointer(32); break;
+                default:
+                    coder.adjustPointer((length+4) &lt;&lt; 3);
+                    break;
+            }         
+            length += 4; // include CRC at end of chunk
+/*
+            int bytesRead = (coder.getPointer() - current) &gt;&gt; 3;
+            
+            byte[] chars = new byte[4];
+            
+            chars[3] = (byte)chunkType;
+            chars[2] = (byte)(chunkType &gt;&gt; 8);
+            chars[1] = (byte)(chunkType &gt;&gt; 16);
+            chars[0] = (byte)(chunkType &gt;&gt; 24);
+            
+            String chunk = new String(chars);
+            
+            if (bytesRead &lt; length)
+                System.err.println(chunk + &quot; chunk underflowed by &quot; + (length - bytesRead) + &quot; bytes.&quot;);
+            else if (bytesRead &gt; length)
+                System.err.println(chunk + &quot; chunk overflowed by &quot; + (bytesRead - length) + &quot; bytes.&quot;);
+*/
+            coder.setPointer(next);
+            
+            if (coder.eof())
+                moreChunks = false;
+        }    
+        decodeImage();
+    }
+
+    private void decodeIHDR(FSCoder coder, int length)
+    {
+        width = coder.readWord(4, false);
+        height = coder.readWord(4, false);
+        attributes[BIT_DEPTH] = coder.readByte();
+        attributes[COLOUR_TYPE] = coder.readByte();
+        attributes[COMPRESSION_METHOD] = coder.readByte();
+        attributes[FILTER_METHOD] = coder.readByte();
+        attributes[INTERLACE_METHOD] = coder.readByte();
+        
+        coder.readWord(4, false); // crc
+
+        switch (attributes[COLOUR_TYPE])
+        {
+            case GREYSCALE: format = (attributes[TRANSPARENT_GREY] != -1) ? RGBA : RGB8; attributes[COLOUR_COMPONENTS] = 1; break;
+            case TRUE_COLOUR: format = (attributes[TRANSPARENT_RED] != -1) ? RGBA : RGB8; attributes[COLOUR_COMPONENTS] = 3; break;
+            case INDEXED_COLOUR: format = IDX8; attributes[COLOUR_COMPONENTS] = 1; break;
+            case ALPHA_GREYSCALE: format = RGBA; attributes[COLOUR_COMPONENTS] = 2; break;
+            case ALPHA_TRUECOLOUR: format = RGBA; attributes[COLOUR_COMPONENTS] = 4; break;
+        }  
+    }
+
+    private void decodePLTE(FSCoder coder, int length)
+    {
+        if (attributes[COLOUR_TYPE] == 3)
+        {
+            int paletteSize = length / 3;
+            
+            colourTable = new byte[paletteSize][4];
+            
+            for (int i=0; i&lt;paletteSize; i++)
+            {
+                colourTable[i][3] = (byte)0xFF;
+                colourTable[i][2] = (byte)coder.readByte();
+                colourTable[i][1] = (byte)coder.readByte();
+                colourTable[i][0] = (byte)coder.readByte();
+            }
+        }
+        else
+        {
+            coder.adjustPointer(length &lt;&lt; 3);
+        }        
+        coder.readWord(4, false); // crc
+    }
+
+    private void decodeTRNS(FSCoder coder, int length)
+    {
+        switch(attributes[COLOUR_TYPE])
+        {
+            case GREYSCALE:
+                attributes[TRANSPARENT_GREY] = coder.readWord(2, false);
+                break;
+            case TRUE_COLOUR:
+                attributes[TRANSPARENT_RED] = coder.readWord(2, false);
+                attributes[TRANSPARENT_GREEN] = coder.readWord(2, false);
+                attributes[TRANSPARENT_BLUE] = coder.readWord(2, false);
+                break;
+            case INDEXED_COLOUR:
+                format = IDXA;
+                for (int i=0; i&lt;length; i++) 
+                {
+                    colourTable[i][3] = (byte)coder.readByte();
+
+                    if (colourTable[i][3] == 0) {
+                        colourTable[i][0] = 0;
+                        colourTable[i][1] = 0;
+                        colourTable[i][2] = 0;
+                    }
+                }
+                break;
+            default:
+                break;
+        }
+        coder.readWord(4, false); // crc
+    }
+
+    private void decodeIDAT(FSCoder coder, int length)
+    {
+        int currentLength = chunkData.length;
+        int newLength = currentLength + length;
+        
+        byte[] data = new byte[newLength];
+        
+        System.arraycopy(chunkData, 0, data, 0, currentLength);
+
+        for (int i=currentLength; i&lt;newLength; i++)
+            data[i] = (byte)coder.readByte();
+            
+        chunkData = data;
+        
+        coder.readWord(4, false); // crc
+    }
+
+    private void decodeImage() throws DataFormatException
+    {
+        if (format == RGB8 &amp;&amp; attributes[BIT_DEPTH] &lt;= 5)
+            format = RGB5;
+
+        if (format == RGB5 || format == RGB8 || format == RGBA)
+            colorImage = new byte[height][width][4];
+            
+        if (format == IDX8 || format == IDXA)
+            indexedImage = new byte[height][width];
+            
+        byte[] encodedImage = unzip(chunkData);
+        
+        int bitsPerPixel = attributes[BIT_DEPTH]*attributes[COLOUR_COMPONENTS];
+        int bitsPerRow = width * bitsPerPixel;
+        int rowWidth = (bitsPerRow % 8 &gt; 0) ? (bitsPerRow/8)+1 : (bitsPerRow/8);
+        int bytesPerPixel = (bitsPerPixel&lt;8) ? 1 : bitsPerPixel/8;
+        
+        byte[] current = new byte[rowWidth];
+        byte[] previous = new byte[rowWidth];
+        
+        for (int i=0; i&lt;rowWidth; i++)
+            previous[i] = (byte)0;
+            
+        int rowStart = 0;
+        int rowInc = 0;
+        int colStart = 0;
+        int colInc = 0;
+        
+        int imageIndex = 0;
+        int pixelCount = 0;
+        
+        int row = 0;
+        int col = 0;
+        int filter = 0;
+        
+        int scanBits = 0;
+        int scanLength = 0;
+        
+        int numberOfPasses = (attributes[INTERLACE_METHOD] == 1) ? 7 : 1;
+
+        int xc = 0;
+        int xp = 0;
+
+        for (int pass=0; pass&lt;numberOfPasses; pass++)
+        {
+            rowStart = (attributes[INTERLACE_METHOD] == 1) ? startRow[pass] : 0;
+            rowInc = (attributes[INTERLACE_METHOD] == 1) ? rowIncrement[pass] : 1;
+            
+            colStart = (attributes[INTERLACE_METHOD] == 1) ? startColumn[pass] : 0;
+            colInc = (attributes[INTERLACE_METHOD] == 1) ? columnIncrement[pass] : 1;
+            
+            for (row=rowStart; row&lt;height &amp;&amp; imageIndex&lt;encodedImage.length; row+=rowInc)
+            {
+                for (col=colStart, pixelCount=0, scanBits=0; col&lt;width; pixelCount++, col += colInc, scanBits+=bitsPerPixel);
+
+                scanLength = (scanBits%8 &gt; 0) ? (scanBits/8)+1 : (scanBits/8);
+
+                filter = encodedImage[imageIndex++];
+                              
+                for (int i=0; i&lt;scanLength; i++, imageIndex++)
+                    current[i] = (imageIndex &lt; encodedImage.length) ? encodedImage[imageIndex] : previous[i];
+
+                switch (filter) 
+                {
+                    case NO_FILTER:
+                        break;
+                    case SUB_FILTER:
+                        for (xc = bytesPerPixel, xp = 0; xc &lt; scanLength; xc++, xp++)
+                            current[xc] = (byte)(current[xc] + current[xp]);
+                        break;
+                    case UP_FILTER:
+                        for (xc = 0; xc &lt; scanLength; xc++)
+                            current[xc] = (byte)(current[xc] + previous[xc]);
+                        break;
+                    case AVG_FILTER:
+                        for (xc = 0; xc &lt; bytesPerPixel; xc++)
+                            current[xc] = (byte)(current[xc] + (0 + (0xFF &amp; previous[xc])) / 2);
+                        
+                        for (xc = bytesPerPixel, xp = 0; xc &lt; scanLength; xc++, xp++)
+                            current[xc] = (byte)(current[xc] + ((0xFF &amp; current[xp]) + (0xFF &amp; previous[xc])) / 2);
+                        break;
+                    case PAETH_FILTER:
+                        for (xc = 0; xc &lt; bytesPerPixel; xc++)
+                            current[xc] = (byte)(current[xc] + Paeth((byte)0, previous[xc], (byte)0));
+                        
+                        for (xc = bytesPerPixel, xp = 0; xc &lt; scanLength; xc++, xp++)
+                            current[xc] = (byte)(current[xc] + Paeth(current[xp], previous[xc], previous[xp]));
+                        break;
+                }
+        
+                System.arraycopy(current, 0, previous, 0, scanLength);
+                        
+                FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, current);
+                
+                for (col=colStart; col&lt;width; col+=colInc)
+                {
+                    switch (attributes[COLOUR_TYPE])
+                    {
+                        case GREYSCALE: decodeGreyscale(coder, row, col); break;
+                        case TRUE_COLOUR: decodeTrueColour(coder, row, col); break;
+                        case INDEXED_COLOUR: decodeIndexedColour(coder, row, col); break;
+                        case ALPHA_GREYSCALE: decodeAlphaGreyscale(coder, row, col); break;
+                        case ALPHA_TRUECOLOUR: decodeAlphaTrueColour(coder, row, col); break;
+                    }        
+                }
+            }
+        }
+    }
+
+    private int Paeth(byte L, byte u, byte nw)
+    {
+        int a = 0xFF &amp; L;
+        int b = 0xFF &amp; u; 
+        int c = 0xFF &amp; nw; 
+        int p = a + b - c;
+        int pa = p - a; if (pa &lt; 0) pa = -pa;
+        int pb = p - b; if (pb &lt; 0) pb = -pb; 
+        int pc = p - c; if (pc &lt; 0) pc = -pc; 
+        if (pa &lt;= pb &amp;&amp; pa &lt;= pc) return a;
+        if (pb &lt;= pc) return b;
+        return c;
+    }
+
+    private void decodeGreyscale(FSCoder coder, int row, int col)
+    {
+        int pixel = 0;
+        byte colour = 0;
+        
+        switch (attributes[BIT_DEPTH])
+        {
+            case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; break;
+            case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; break;
+            case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; break;
+            case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
+            case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
+        }                    
+
+        colorImage[row][col][0] = colour;
+        colorImage[row][col][1] = colour;
+        colorImage[row][col][2] = colour;
+        colorImage[row][col][3] = (byte)attributes[TRANSPARENT_GREY];
+    }
+    
+    private void decodeTrueColour(FSCoder coder, int row, int col)
+    {
+        int pixel = 0;
+        byte colour = 0;
+        
+        for (int i=0; i&lt;attributes[COLOUR_COMPONENTS]; i++)
+        {
+            switch (attributes[BIT_DEPTH])
+            {
+                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
+                case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
+            }                    
+            colorImage[row][col][i] = colour;
+        }
+        colorImage[row][col][3] = (byte)attributes[TRANSPARENT_RED];
+    }
+    
+    private void decodeIndexedColour(FSCoder coder, int row, int col)
+    {
+        int index = 0;
+        
+        switch (attributes[BIT_DEPTH])
+        {
+            case 1:  index = coder.readBits(1, false); break;
+            case 2:  index = coder.readBits(2, false); break;
+            case 4:  index = coder.readBits(4, false); break;
+            case 8:  index = coder.readByte(); break;
+            case 16: index = coder.readWord(2, false); break;
+        }                    
+        indexedImage[row][col] = (byte)index;
+    }
+    
+    private void decodeAlphaGreyscale(FSCoder coder, int row, int col)
+    {
+        int pixel = 0;
+        byte colour = 0;
+        int alpha = 0;
+        
+        switch (attributes[BIT_DEPTH])
+        {
+            case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; alpha = coder.readBits(1, false); break;
+            case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; alpha = coder.readBits(2, false); break;
+            case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; alpha = coder.readBits(4, false); break;
+            case 8:  pixel = coder.readByte(); colour = (byte) pixel; alpha = coder.readByte(); break;
+            case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); alpha = coder.readWord(2, false) &gt;&gt; 8; break;
+        }                    
+
+        colorImage[row][col][0] = colour;
+        colorImage[row][col][1] = colour;
+        colorImage[row][col][2] = colour;
+        colorImage[row][col][3] = (byte) alpha;
+    }
+    
+    private void decodeAlphaTrueColour(FSCoder coder, int row, int col)
+    {
+        int pixel = 0;
+        byte colour = 0;
+        
+        for (int i=0; i&lt;attributes[COLOUR_COMPONENTS]; i++)
+        {
+            switch (attributes[BIT_DEPTH])
+            {
+                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
+                case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
+            }                    
+            colorImage[row][col][i] = colour;
+        }
+    }
+    
+    private byte[] dataFromFile(String filename) throws FileNotFoundException, IOException
+    {
+        File aFile = new File(filename);
+        FileInputStream imageContents = null;
+        
+        byte[] bytes = new byte[(int)aFile.length()];
+        
+        imageContents = new FileInputStream(aFile);            
+        imageContents.read(bytes);
+        imageContents.close();
+
+        return bytes;
+    }
+    
+    private byte[] unzip(byte[] bytes) throws DataFormatException
+    {
+        byte[] data = new byte[width*height*8];
+        int count = 0;
+        
+        Inflater inflater = new Inflater();
+        inflater.setInput(bytes);
+        count = inflater.inflate(data);
+        
+        byte[] uncompressedData = new byte[count];
+        
+        System.arraycopy(data, 0, uncompressedData, 0, count);
+
+        return uncompressedData;
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/Sound.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/Sound.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/Sound.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,371 @@
+/*
+ *  FSSoundConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.HashMap;
+import java.util.zip.*;
+
+import com.flagstone.transform.*;
+
+/** 
+ * The FSSoundConstructor class is used to generate the objects used to define and 
+ * control the sounds that are played in a Flash movie. The FSSoundConstructor can 
+ * be used to generate definitions for:
+ *
+ * &lt;ul&gt;
+ * &lt;li&gt;Event sounds that are played in response to a particular event such as a button 
+ * being clicked.&lt;/li&gt;
+ * &lt;li&gt;Streaming sound that is played as movie is being displayed.&lt;/li&gt;
+ * &lt;/ul&gt;
+ *
+ * The FSSoundConstructor contains constructors and methods that allow sound data to 
+ * be loaded from an external file simplifying the process of adding sound to a movie. 
+ * The FSSoundConstructor currently supports uncompressed PCM format (with either 
+ * big-endian or little-endian byte ordering) and MP3 format files.
+ *
+ * Once loaded, the PCM sound data should be compressed to ADPCM format as the relatively 
+ * large sizes make PCM coded sounds generally unsuitable for inclusion in a Flash movie. 
+ * ADPCM is a compressed format and Flash supports a modified ADPCM algorithm with 
+ * compressed samples taking 2, 3, 4 or 5 bits. This results in much smaller file sizes 
+ * when a movie is encoded. Code, developed at Centre for Mathematics and Computer Science,
+ * Amsterdam, The Netherlands, is available on Flagstone's web site to perform the 
+ * ADPCM compression.
+ * 
+ * For sounds containing more than one channel, the sound levels for each channel are 
+ * interleaved for each sample. For example a stereo sound the order of the samples and 
+ * channels levels are:
+ *
+ *&lt;pre&gt;
+ * Sample       0          1          2
+ *          +---+---+  +---+---+  +---+---+
+ *          | 1 | 2 |  | 1 | 2 |  | 1 | 2 | ....
+ *          +---+---+  +---+---+  +---+---+
+ *&lt;/pre&gt;
+ *
+ * NOTE: The byte order for the PCM data in WAVE sound files may vary according to the 
+ * platform on which the sound file was created. The FSSoundConstructor currently only
+ * supports WAVE files with little-endian byte order.
+ *
+ * &lt;b&gt;Examples&lt;/b&gt;
+ *
+ * The following code samples illustrate how to use the FSSoundConstructor class to add 
+ * sounds to a Flash file.
+ *
+ * 1. Playing an uncompressed WAVE file.\n
+ *
+ *&lt;pre&gt;
+ * int soundId = movie.newIdentifier();
+ *
+ * // Generate an FSDefineSound object using the attributes defined in the wave file.
+ * // An FSSound object is used to instruct the Flash Player to start playing a sound.
+ *
+ * FSSoundConstructor soundGenerator = new FSSoundGenerator(&quot;sound.wav&quot;);
+ *
+ * movie.add(soundGenerator.defineSound(soundId));
+ * movie.add(new FSSound(soundId, FSSound.Start));
+ *&lt;/pre&gt;
+ *
+ * 2. Streaming Sounds.\n
+ *
+ * Larger sound files may be streamed to the Flash Player - splitting the sound data into a 
+ * sequence of blocks which is synchronised with the frames as they are displayed. Typically 
+ * block of sound data is generated for each frame displayed.
+ *
+ *&lt;pre&gt;
+ * int framesPerSecond = 12;
+ *
+ * FSSoundConstructor soundGenerator = new FSSoundGenerator(&quot;soundTrack.wav&quot;);
+ *   
+ * // Calculate the number of decoded sound samples played for each frame
+ *
+ * int samplesPerBlock = soundGenerator.getSampleRate() / framesPerSecond;
+ * int numberOfBlocks = soundGenerator.getSamplesPerChannel() / samplesPerBlock;
+ *
+ * // An FSSoundStreamHeader2 object defines the attributes of the streaming sound.
+ * 
+ * movie.add(soundGenerator.streamHeader(samplesPerBlock));
+ *
+ * // Add a streaming block for each frame so the sound is played as each frame is displayed.
+ *
+ * for (int i=0; i&lt;numberOfBlocks; i++)
+ * {
+ *     movie.add(soundGenerator.streamBlock(i, samplesPerBlock));
+ *     movie.add(new FSShowFrame());
+ * }
+ * &lt;/pre&gt;
+ *
+ */
+public class Sound
+{  
+    private static final int MPEG1 = 3;  
+
+    private static final int bitRates[][] =
+    {
+        { -1,  8, 16, 24, 32, 40, 48, 56,  64,  80,  96, 112, 128, 144, 160, -1 }, // MPEG 2.5
+        { -1, -1, -1, -1, -1, -1, -1, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1 }, // Reserved
+        { -1,  8, 16, 24, 32, 40, 48, 56,  64,  80,  96, 112, 128, 144, 160, -1 }, // MPEG 2.0
+        { -1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1 }, // MPEG 1.0
+    };
+
+    private static final int samplingRates[][] =
+    {
+        { 11025, -1, -1, -1 },
+        {    -1, -1, -1, -1 },
+        { 22050, -1, -1, -1 },
+        { 44100, -1, -1, -1 }
+    };
+    
+	private static HashMap&lt;String, Class&lt;SoundDecoder&gt;&gt; decoders = new HashMap&lt;String, Class&lt;SoundDecoder&gt;&gt;();
+
+	public static void registerDecoder(String format, Class&lt;SoundDecoder&gt; aClass)
+	{
+		decoders.put(format.toUpperCase(), aClass);
+	}
+
+    FSDefineSound defineSound(int identifier, String path) throws FileNotFoundException, IOException, DataFormatException
+    {
+    	FSDefineSound object = null;
+    	String extension = null;
+    	
+    	if (decoders.containsKey(extension))
+    	{
+			try
+			{
+				Class&lt;SoundDecoder&gt; obj = decoders.get(extension);
+				SoundDecoder decoder = (SoundDecoder) obj.newInstance();
+				decoder.decode(path);
+				
+				int format = decoder.getFormat();
+			    int channels = decoder.getNumberOfChannels();
+			    int samples = decoder.getSamplesPerChannel();
+			    int rate = decoder.getSampleRate();
+			    int size = decoder.getSampleSize();
+			    byte[] sound = decoder.getSound();
+			    byte[] bytes = null;
+
+		        switch (format)
+		        {
+		            case FSSound.PCM:
+		            case FSSound.ADPCM:
+		                bytes = new byte[sound.length];
+		                System.arraycopy(sound, 0, bytes, 0, sound.length);
+		                break;
+		            case FSSound.MP3:
+		                bytes = new byte[2+sound.length];
+		                bytes[0] = 0;
+		                bytes[1] = 0;
+		                System.arraycopy(sound, 0, bytes, 2, sound.length);
+		                break;
+		        }
+		        object = new FSDefineSound(identifier, format, rate, channels, size, samples, bytes);
+			} 
+			catch (Exception e)
+			{
+				throw new DataFormatException();
+			}
+    	}
+    	return object;
+    }
+    
+    public FSSoundStreamHead2 streamHeader(FSDefineSound sound, int frameRate)
+    {
+    	int format = sound.getFormat();
+    	int rate = sound.getPlaybackRate();
+    	int channels = sound.getPlaybackChannels();
+    	int size = sound.getPlaybackSampleSize();
+    	
+        return new FSSoundStreamHead2(format, rate, channels, size, rate, channels, size, rate/frameRate);
+    }
+
+    
+    /** 
+     * Generates an FSSoundStreamBlock object containing a block sound data. This method is 
+     * used to divide the encoded sound into a sequence of blocks to allow a sound to be 
+     * streamed to the Flash Player.
+     *
+     * If the number of samples in the last block to stream is less than the samplesPerBlock,
+     * the size of the FSSoundStreamBlock object is reduced accordingly. It is not padded 
+     * to maintain the specified length.
+     * 
+     * @param blockNumber the nth block of samples.
+     * 
+     * @param samplesPerBlock the number of samples to stream.
+     * 
+     * @return an FSSoundStreamBlock object containing a block of bytes from the encoded 
+     * sound.
+     */
+    public FSSoundStreamBlock[] streamBlock(FSDefineSound sound, int frameRate)
+    {
+        int firstSample = 0;
+        int firstSampleOffset = 0;
+        int bytesPerBlock = 0;
+        int bytesRemaining = 0;
+        int numberOfBytes = 0;
+        
+        int framesToSend = 0;
+        int framesSent = 0;
+        int frameCount = 0;
+        int sampleCount = 0;
+        int seek = 0;
+        
+        byte[] data = sound.getSoundData();
+        byte[] bytes = null;
+
+    	int format = sound.getFormat();
+    	int rate = sound.getPlaybackRate();
+    	int channels = sound.getPlaybackChannels();
+    	int size = sound.getPlaybackSampleSize();
+    	int samples = sound.getSampleCount();
+
+    	int samplesPerBlock = rate/frameRate;
+	 	int numberOfBlocks = samples/samplesPerBlock;
+
+	    int[][] frameTable = null;
+	    int samplesPerFrame = 0;
+	    
+	    FSSoundStreamBlock[] blocks = new FSSoundStreamBlock[numberOfBlocks];
+	    
+	 	switch (format)
+        {
+            case FSSound.PCM:
+        	    for (int i=0; i&lt;numberOfBlocks; i++)
+        	    {
+	                firstSample = i*samplesPerBlock;
+	                firstSampleOffset = firstSample * size * channels;
+	                bytesPerBlock = samplesPerBlock * size * channels;
+	                bytesRemaining = data.length - firstSampleOffset;
+	                
+	                numberOfBytes = (bytesRemaining &lt; bytesPerBlock) ? bytesRemaining : bytesPerBlock;
+	            
+	                bytes = new byte[numberOfBytes];
+	                System.arraycopy(data, firstSampleOffset, bytes, 0, numberOfBytes);
+	                
+	                blocks[i] = new FSSoundStreamBlock(bytes);
+        	    }
+                break;
+            case FSSound.ADPCM:
+                break;
+            case FSSound.MP3:
+                FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
+                
+                coder.findBits(0x7FF, 11, 8);
+                
+                int frameStart = coder.getPointer();
+                int numberOfFrames = 0;
+                
+                while (coder.findBits(0x7FF, 11, 8))
+                {
+                    coder.adjustPointer(MP3FrameSize(coder) &lt;&lt; 3);
+                    numberOfFrames++;
+                }
+                
+                frameTable = new int[numberOfFrames][2];
+                
+                coder.setPointer(frameStart);
+                
+                int frameNumber = 0;
+                
+                while (coder.findBits(0x7FF, 11, 8))
+                {
+                    frameTable[frameNumber][0] = (coder.getPointer()- frameStart + 16) &gt;&gt; 3;
+                    
+                    coder.adjustPointer(11); // skip start of frame marker
+
+                    int version = coder.readBits(2, false);
+                    
+                    coder.adjustPointer(3);
+                    
+                    int bitRate = bitRates[version][coder.readBits(4, false)];
+                    int samplingRate = samplingRates[version][coder.readBits(2, false)];
+                    int padding = coder.readBits(1, false);
+
+                    frameTable[frameNumber++][1] = 4 + (((version == MPEG1) ? 144 : 72) * bitRate*1000 / samplingRate + padding) - 4;
+            
+                    coder.adjustPointer((MP3FrameSize(coder) &lt;&lt; 3)-23);
+                }
+
+                for (int i=0; i&lt;numberOfBlocks; i++)
+        	    {            	
+	                framesToSend = ((i+1) * samplesPerBlock) / samplesPerFrame;
+	                framesSent = (i * samplesPerBlock) / samplesPerFrame;
+	                frameCount = framesToSend - framesSent;
+	                sampleCount = frameCount * samplesPerFrame;
+	                seek = (i * samplesPerBlock) - (framesSent * samplesPerFrame);
+	            
+	                numberOfBytes = 4;
+	                
+	                for (int j=0, k=framesSent; j&lt;frameCount; j++, k++)
+	                     numberOfBytes += frameTable[k][1];
+	                
+	                bytes = new byte[numberOfBytes];
+	            
+	                bytes[0] = (byte)sampleCount;
+	                bytes[1] = (byte)(sampleCount &gt;&gt; 8);
+	                bytes[2] = (byte)seek;
+	                bytes[3] = (byte)(seek &gt;&gt; 8);
+	                
+	                int offset = 4; 
+	                
+	                for (int j=0, k=framesSent; j&lt;frameCount; j++, k++)
+	                {
+	                    System.arraycopy(sound, frameTable[k][0], bytes, offset, frameTable[k][1]);
+	                    offset += frameTable[k][1];
+	                }
+	                
+	                blocks[i] = new FSSoundStreamBlock(bytes);
+        	    }
+                break;
+	    }
+    	return blocks;
+    }
+
+    private int MP3FrameSize(FSCoder coder)
+    {
+        int frameSize = 4;
+        
+        coder.adjustPointer(11);
+
+        int version = coder.readBits(2, false);
+            
+        coder.adjustPointer(3);
+            
+        int bitRate = bitRates[version][coder.readBits(4, false)];
+        int samplingRate = samplingRates[version][coder.readBits(2, false)];
+           int padding = coder.readBits(1, false);
+
+        coder.adjustPointer(-23);
+            
+        frameSize += (((version == MPEG1) ? 144 : 72) * bitRate*1000 / samplingRate + padding) - 4;
+        
+        return frameSize;
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/SoundDecoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/SoundDecoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/SoundDecoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,16 @@
+package com.flagstone.transform.util;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+
+public interface SoundDecoder
+{
+	public int getFormat();
+    public int getNumberOfChannels();
+    public int getSamplesPerChannel();
+    public int getSampleRate();
+    public int getSampleSize();
+    public byte[] getSound();
+	public void decode(String path) throws FileNotFoundException, IOException, DataFormatException;
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/Text.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/Text.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/Text.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,144 @@
+/*
+ *  FSTextConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+ 
+package com.flagstone.transform.util;
+
+import com.flagstone.transform.*;
+
+import java.util.*;
+
+public class Text
+{
+    public FSBounds boundsForText(String text, FSDefineFont2 font, int size)
+    {
+        ArrayList&lt;Integer&gt;codes = font.getCodes();
+        ArrayList&lt;Integer&gt;advances = font.getAdvances();
+       
+        float scale = size/1024.0f;
+        int advance = 0;
+
+        for (int i=0; i&lt;text.length(); i++)
+        {
+    	    for (int j=0; j&lt;codes.size(); j++)
+    	    {
+    		    if (text.charAt(i) == codes.get(j)) 
+    		    {
+    	            advance += (int)(advances.get(j)*scale);    			   
+    		    }
+    	    }
+        }
+        return new FSBounds(0, -(int)(font.getAscent()/scale), advance, (int)(font.getDescent()/scale));
+    }
+
+    public ArrayList&lt;FSCharacter&gt; charactersForText(String text, FSDefineFont2 font, int size)
+    {
+        ArrayList&lt;FSCharacter&gt;characters = new ArrayList&lt;FSCharacter&gt;(text.length());
+        ArrayList&lt;Integer&gt;codes = font.getCodes();
+        ArrayList&lt;Integer&gt;advances = font.getAdvances();
+       
+        float scale = size/1024.0f;
+
+        for (int i=0; i&lt;text.length(); i++)
+        {
+    	    for (int j=0; j&lt;codes.size(); j++)
+    	    {
+    		    if (text.charAt(i) == codes.get(j)) 
+    		    {
+    	            characters.add(new FSCharacter(j, (int)(advances.get(j)*scale)));    			   
+    		    }
+    	    }
+        }
+        return characters;
+    }
+
+	public FSSpan defineSpan(String text, FSDefineFont2 font, int size, FSColor color)
+    {
+        float scale = size/1024.0f;
+        
+        int x = 0;
+        int y = (int)(font.getAscent()/scale);
+
+        return new FSSpan(font.getIdentifier(), color, x, y, size, charactersForText(text, font, size));
+    }
+
+    public FSDefineText2 defineText(int anIdentifier, String text, FSDefineFont2 font, int size, FSColor color)
+    {
+        FSCoordTransform transform = new FSCoordTransform(0, 0);
+        ArrayList&lt;FSSpan&gt; spans = new ArrayList&lt;FSSpan&gt;();
+
+        spans.add(defineSpan(text, font, size, color));
+
+        return new FSDefineText2(anIdentifier, boundsForText(text, font, size), transform, spans);
+    }
+
+    public FSDefineText2 defineTextBlock(int anIdentifier, ArrayList&lt;String&gt; lines, FSDefineFont2 font, int size, FSColor color, int lineSpacing)
+    {
+        FSCoordTransform transform = new FSCoordTransform(0, 0);
+        float scale = size/1024.0f;
+        
+        int xMin = 0;
+        int yMin = 0;
+        int xMax = 0;
+        int yMax = 0;
+        
+        int xOffset = 0;
+        int yOffset = (int)(font.getAscent()/scale);
+        
+        ArrayList&lt;FSSpan&gt; spans = new ArrayList&lt;FSSpan&gt;();
+        String text;
+        
+        int n = 0;
+
+        for (Iterator&lt;String&gt; i = lines.iterator(); i.hasNext(); yOffset += lineSpacing, n++)
+        {
+            text = i.next();
+
+            spans.add(new FSSpan(font.getIdentifier(), color, xOffset, yOffset, size, charactersForText(text, font, size)));
+
+            FSBounds bounds = boundsForText(text, font, size);
+            
+            if (n==0) {
+                yMin = bounds.getMinY();
+                yMax = bounds.getMaxY();
+            }
+            else {
+                yMax += lineSpacing;
+            }
+            
+            if (n==lines.size()-1)
+                yMax += bounds.getHeight();
+            
+            xMin = (xMin &lt; bounds.getMinX()) ? xMin : bounds.getMinX();
+            xMax = (xMax &gt; bounds.getMaxX()) ? xMax : bounds.getMaxX();
+        }
+
+        return new FSDefineText2(anIdentifier, new FSBounds(xMin, yMin, xMax, yMax), transform, spans);
+    }
+}

Added: dev/dev-2-4/src/com/flagstone/transform/util/WAVDecoder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/WAVDecoder.java	2008-03-26 15:32:58 UTC (rev 387)
+++ dev/dev-2-4/src/com/flagstone/transform/util/WAVDecoder.java	2008-03-26 17:51:14 UTC (rev 388)
@@ -0,0 +1,173 @@
+/*
+ *  FSSoundConstructor.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.flagstone.transform.util;
+
+import java.io.*;
+import java.util.zip.*;
+import com.flagstone.transform.*;
+
+public class WAVDecoder implements SoundDecoder
+{
+    private static final int[] riffSignature = { 82, 73, 70, 70 };
+    private static final int[] wavSignature = { 87, 65, 86, 69 };
+
+    private static final int FMT = 0x20746d66;
+    private static final int DATA = 0x61746164;
+    
+    private int format;
+    private int numberOfChannels;
+    private int samplesPerChannel;
+    private int sampleRate;
+    private int sampleSize;
+    private byte[] sound = null;
+
+    public WAVDecoder() 
+    {
+    }
+
+    public int getFormat()
+    {
+        return format;
+    }
+
+    public int getNumberOfChannels()
+    {
+        return numberOfChannels;
+    }
+
+     public int getSamplesPerChannel()
+    {
+        return samplesPerChannel;
+    }
+
+    public int getSampleRate()
+    {
+        return sampleRate;
+    }
+
+    public int getSampleSize()
+    {
+        return sampleSize;
+    }
+
+    public byte[] getSound()
+    {
+        byte[] bytes = new byte[sound.length];
+        
+        System.arraycopy(sound, 0, bytes, 0, sound.length);
+
+        return bytes;
+    }
+
+    public void decode(String filename) throws FileNotFoundException, IOException, DataFormatException
+    {
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, dataFromFile(filename));
+        
+        int length = 0;
+        int chunkType = 0;
+        boolean moreChunks = true;
+
+        for (int i=0; i&lt;4; i++)
+        {
+            if (coder.readByte() != riffSignature[i])
+                throw new DataFormatException(&quot;Not a valid RIFF file&quot;);
+        }
+        
+        coder.readWord(4, false);
+        
+        for (int i=0; i&lt;4; i++)
+        {
+            if (coder.readByte() != wavSignature[i])
+                throw new DataFormatException(&quot;Not a valid WAV file&quot;);
+        }
+       
+        while (moreChunks)
+        {
+            chunkType = coder.readWord(4, false);
+            length = coder.readWord(4, false);
+            
+            int blockStart = coder.getPointer();
+            
+            switch (chunkType)
+            {
+                case FMT: 
+                	decodeFMT(coder); 
+                	break;
+                case DATA: 
+                	decodeDATA(coder, length); 
+                	break;
+                default: 
+                	coder.adjustPointer(length &lt;&lt; 3); 
+                	break;
+            }
+
+            int nextBlock = blockStart + (length &lt;&lt; 3);
+            coder.setPointer(nextBlock);
+            moreChunks = coder.eof() == false;
+        }
+    }
+
+    private void decodeFMT(FSCoder coder) throws DataFormatException
+    {
+        format = FSSound.PCM;
+        
+        if (coder.readWord(2, false) != 1)
+            throw new DataFormatException(&quot;Compressed WAV files are not currently supported.&quot;);
+        
+        numberOfChannels = coder.readWord(2, false);
+        sampleRate = coder.readWord(4, false);
+        coder.readWord(4, false); // total data length
+        coder.readWord(2, false); // total bytes per sample
+        sampleSize = coder.readWord(2, false) / 8;
+    }
+    
+    private void decodeDATA(FSCoder coder, int length)
+    {
+        samplesPerChannel = length / (sampleSize*numberOfChannels);
+
+        sound = new byte[length];
+        coder.readBytes(sound);
+    }
+
+    private byte[] dataFromFile(String filename) throws IOException
+    {
+        File aFile = new File(filename);
+        FileInputStream imageContents = null;
+        
+        byte[] bytes = new byte[(int)aFile.length()];
+        
+        imageContents = new FileInputStream(aFile);            
+        imageContents.read(bytes);
+        imageContents.close();
+
+        return bytes;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000322.html">[Transform-svn] r387 - in dev/dev-2-4/src/com/flagstone/transform:	. util
</A></li>
	<LI>Next message: <A HREF="000323.html">[Transform-svn] r389 - dev/dev-2-4/src/com/flagstone/transform/util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#330">[ date ]</a>
              <a href="thread.html#330">[ thread ]</a>
              <a href="subject.html#330">[ subject ]</a>
              <a href="author.html#330">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/transform-svn">More information about the Transform-svn
mailing list</a><br>
</body></html>
