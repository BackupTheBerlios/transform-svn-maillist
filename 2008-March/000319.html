<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Transform-svn] r383 - in dev/dev-2-4/src/com/flagstone/transform:	. test util
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/transform-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r383%20-%20in%20dev/dev-2-4/src/com/flagstone/transform%3A%0A%09.%20test%20util&In-Reply-To=%3C200803191049.m2JAn1Y9021887%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000318.html">
   <LINK REL="Next"  HREF="000320.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Transform-svn] r383 - in dev/dev-2-4/src/com/flagstone/transform:	. test util</H1>
    <B>smackay at mail.berlios.de</B> 
    <A HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r383%20-%20in%20dev/dev-2-4/src/com/flagstone/transform%3A%0A%09.%20test%20util&In-Reply-To=%3C200803191049.m2JAn1Y9021887%40sheep.berlios.de%3E"
       TITLE="[Transform-svn] r383 - in dev/dev-2-4/src/com/flagstone/transform:	. test util">smackay at mail.berlios.de
       </A><BR>
    <I>Wed Mar 19 11:49:01 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000318.html">[Transform-svn] r382 - dev/dev-2-4/src/com/flagstone/transform
</A></li>
        <LI>Next message: <A HREF="000320.html">[Transform-svn] r384 - in dev/dev-2-4/src/com/flagstone/transform:	. test util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#319">[ date ]</a>
              <a href="thread.html#319">[ thread ]</a>
              <a href="subject.html#319">[ subject ]</a>
              <a href="author.html#319">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: smackay
Date: 2008-03-19 11:47:20 +0100 (Wed, 19 Mar 2008)
New Revision: 383

Removed:
   dev/dev-2-4/src/com/flagstone/transform/FSMorphSolidLine.java
   dev/dev-2-4/src/com/flagstone/transform/FSMovieEvent.java
   dev/dev-2-4/src/com/flagstone/transform/FSMovieListener.java
   dev/dev-2-4/src/com/flagstone/transform/FSSolidLine.java
   dev/dev-2-4/src/com/flagstone/transform/FSTransformObject.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSCodec.java
   dev/dev-2-4/src/com/flagstone/transform/util/TransformUtil.java
Modified:
   dev/dev-2-4/src/com/flagstone/transform/FSAction.java
   dev/dev-2-4/src/com/flagstone/transform/FSActionObject.java
   dev/dev-2-4/src/com/flagstone/transform/FSAudioData.java
   dev/dev-2-4/src/com/flagstone/transform/FSButton.java
   dev/dev-2-4/src/com/flagstone/transform/FSButtonColorTransform.java
   dev/dev-2-4/src/com/flagstone/transform/FSButtonEvent.java
   dev/dev-2-4/src/com/flagstone/transform/FSButtonSound.java
   dev/dev-2-4/src/com/flagstone/transform/FSCall.java
   dev/dev-2-4/src/com/flagstone/transform/FSClipEvent.java
   dev/dev-2-4/src/com/flagstone/transform/FSCurve.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineButton.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineButton2.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineFont.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineFont2.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineImage.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineImage2.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage2.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage3.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineMorphShape.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineMovieClip.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineObject.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineShape.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineShape2.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineShape3.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineSound.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineText.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineText2.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineTextField.java
   dev/dev-2-4/src/com/flagstone/transform/FSDefineVideo.java
   dev/dev-2-4/src/com/flagstone/transform/FSDoAction.java
   dev/dev-2-4/src/com/flagstone/transform/FSExceptionHandler.java
   dev/dev-2-4/src/com/flagstone/transform/FSExport.java
   dev/dev-2-4/src/com/flagstone/transform/FSFontInfo.java
   dev/dev-2-4/src/com/flagstone/transform/FSFontInfo2.java
   dev/dev-2-4/src/com/flagstone/transform/FSFrame.java
   dev/dev-2-4/src/com/flagstone/transform/FSFrameLabel.java
   dev/dev-2-4/src/com/flagstone/transform/FSGetUrl.java
   dev/dev-2-4/src/com/flagstone/transform/FSGetUrl2.java
   dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame.java
   dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame2.java
   dev/dev-2-4/src/com/flagstone/transform/FSGotoLabel.java
   dev/dev-2-4/src/com/flagstone/transform/FSImageBlock.java
   dev/dev-2-4/src/com/flagstone/transform/FSImport.java
   dev/dev-2-4/src/com/flagstone/transform/FSInitialize.java
   dev/dev-2-4/src/com/flagstone/transform/FSLayer.java
   dev/dev-2-4/src/com/flagstone/transform/FSLimitScript.java
   dev/dev-2-4/src/com/flagstone/transform/FSLine.java
   dev/dev-2-4/src/com/flagstone/transform/FSNewFunction.java
   dev/dev-2-4/src/com/flagstone/transform/FSNewFunction2.java
   dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject.java
   dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject2.java
   dev/dev-2-4/src/com/flagstone/transform/FSRegisterVariable.java
   dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject.java
   dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject2.java
   dev/dev-2-4/src/com/flagstone/transform/FSScreenVideoPacket.java
   dev/dev-2-4/src/com/flagstone/transform/FSSerialNumber.java
   dev/dev-2-4/src/com/flagstone/transform/FSSetBackgroundColor.java
   dev/dev-2-4/src/com/flagstone/transform/FSSetTarget.java
   dev/dev-2-4/src/com/flagstone/transform/FSShape.java
   dev/dev-2-4/src/com/flagstone/transform/FSShapeObject.java
   dev/dev-2-4/src/com/flagstone/transform/FSShapeStyle.java
   dev/dev-2-4/src/com/flagstone/transform/FSSound.java
   dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamBlock.java
   dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead.java
   dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead2.java
   dev/dev-2-4/src/com/flagstone/transform/FSStartSound.java
   dev/dev-2-4/src/com/flagstone/transform/FSTabOrder.java
   dev/dev-2-4/src/com/flagstone/transform/FSTable.java
   dev/dev-2-4/src/com/flagstone/transform/FSText.java
   dev/dev-2-4/src/com/flagstone/transform/FSVideo.java
   dev/dev-2-4/src/com/flagstone/transform/FSVideoData.java
   dev/dev-2-4/src/com/flagstone/transform/FSVideoFrame.java
   dev/dev-2-4/src/com/flagstone/transform/FSVideoMetaData.java
   dev/dev-2-4/src/com/flagstone/transform/FSVideoObject.java
   dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame.java
   dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame2.java
   dev/dev-2-4/src/com/flagstone/transform/FSWith.java
   dev/dev-2-4/src/com/flagstone/transform/Transform.java
   dev/dev-2-4/src/com/flagstone/transform/test/FSImageConstructorTest.java
   dev/dev-2-4/src/com/flagstone/transform/test/FSShapeConstructorTest.java
   dev/dev-2-4/src/com/flagstone/transform/test/FSTextConstructorTest.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java
   dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java
Log:
updated to use new class hierarchy and interfaces.

Modified: dev/dev-2-4/src/com/flagstone/transform/FSAction.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSAction.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSAction.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -30,1178 +30,1534 @@
 
 package com.flagstone.transform;
 
-/** 
-The FSAction class is used to represent stack-based actions, defined by simple byte-codes, that 
-are executed by the Flash Player.
- 
-&lt;p&gt;The operations supported by the FSAction class are:&lt;/p&gt;
+/**
+ * The FSAction class is used to represent stack-based actions, defined by
+ * simple byte-codes, that are executed by the Flash Player.
+ * 
+ * &lt;p&gt;
+ * The operations supported by the FSAction class are:
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Stack Manipulation&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Pop&lt;/td&gt;
+ * &lt;td&gt;Pop value from the top of the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Duplicate&lt;/td&gt;
+ * &lt;td&gt;Duplicate the value at the top of the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA -- valueA valueA)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 -- 4 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Swap&lt;/td&gt;
+ * &lt;td&gt;Swap the top two values on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA valueB -- valueB valueA)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 3 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSPush is used to push literals onto the Stack. See also FSRegisterCopy which
+ * copies the value on top of the Stack to one of the Flash Player's internal
+ * registers.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Arithmetic&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Add&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Add: A + B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 7)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Subtract&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Subtract: A - B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Multiply&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Multiply: A * B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 12)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Divide&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Divide: A / B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 1.333)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Modulo&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Modulo: A % B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Increment&lt;/td&gt;
+ * &lt;td&gt;Add 1 to the value on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Decrement&lt;/td&gt;
+ * &lt;td&gt;Subtracted 1 from the value on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Arithmetic add is supported by two actions. IntegerAdd was introduced in
+ * Flash 4. It was replaced in Flash 5 by the more flexible Add action which is
+ * able to add any two numbers and also concatenate strings. If a string and a
+ * number are added then the number is converted to its string representation
+ * before concatenation.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Comparison&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Less&lt;/td&gt;
+ * &lt;td&gt;LessThan: A &lt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringLess&lt;/td&gt;
+ * &lt;td&gt;String compare: stringA &lt; stringB&lt;/td&gt;
+ * &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Equals&lt;/td&gt;
+ * &lt;td&gt;Equals: A == B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(23 23 -- 1 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringEquals&lt;/td&gt;
+ * &lt;td&gt;String compare: stringA == stringB&lt;/td&gt;
+ * &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; &quot;abc&quot; -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StrictEquals&lt;/td&gt;
+ * &lt;td&gt;Equals: A === B, are the types as well as the values equal.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA valueB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;23&quot; 23 -- 0 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Greater&lt;/td&gt;
+ * &lt;td&gt;Greater Than: A &gt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringGreater&lt;/td&gt;
+ * &lt;td&gt;String compare: stringA &gt; stringB&lt;/td&gt;
+ * &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The less than comparison is supported by IntegerLess introduced in Flash 4
+ * and Less introduced in Flash 5. The Less action is more flexible allowing
+ * comparison between any combination of two numbers and strings. In Flash 4
+ * comparisons were only supported on values of the same type using either
+ * IntegerLess or StringLess.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The equals comparison is supported by IntegerEquals introduced in Flash 4 and
+ * Equals introduced in Flash 5. The Equals action is more flexible allowing
+ * comparison between any combination of two numbers and strings. In Flash 4
+ * comparisons were only supported on values of the same type using either
+ * IntegerEquals or StringEquals.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Logical&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;And&lt;/td&gt;
+ * &lt;td&gt;Logical And: A &amp;&amp; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 0 -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Or&lt;/td&gt;
+ * &lt;td&gt;Logical Or: A || B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 0 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Not&lt;/td&gt;
+ * &lt;td&gt;Logical Not: !A&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Bitwise&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;BitwiseAnd&lt;/td&gt;
+ * &lt;td&gt;Bitwise And: A &amp; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(5 4 -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;BitwiseOr&lt;/td&gt;
+ * &lt;td&gt;Bitwise Or: A | B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(5 4 -- 5)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;BitwiseXOr&lt;/td&gt;
+ * &lt;td&gt;Bitwise Exclusive-Or: A ^ B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(5 4 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;LogicalShiftLeft&lt;/td&gt;
+ * &lt;td&gt;Logical Shift Left: A &lt;&lt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 1 -- 8)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;LogicalShiftRight&lt;/td&gt;
+ * &lt;td&gt;Logical Shift Right: A &gt;&gt;&gt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(8 1 -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ArithmeticShiftRight&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Shift Right (sign extension): A &gt;&gt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(-1 1 -- -1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;String&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringAdd&lt;/td&gt;
+ * &lt;td&gt;Concatenate two strings&lt;/td&gt;
+ * &lt;td nowrap&gt;(string string -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;ab&quot; &quot;cd&quot; -- &quot;abcd&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringLength&lt;/td&gt;
+ * &lt;td&gt;Returns the length of a string&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBStringLength&lt;/td&gt;
+ * &lt;td&gt;Returns the length of a string that contains characters from an extended
+ * set such as Unicode.&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringExtract&lt;/td&gt;
+ * &lt;td&gt;Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string starting at
+ * position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBStringExtract&lt;/td&gt;
+ * &lt;td&gt;Multi-byte Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string
+ * starting at position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Type Conversion&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToInteger&lt;/td&gt;
+ * &lt;td&gt;Converts the value to an integer&lt;/td&gt;
+ * &lt;td nowrap&gt; ( num -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt; ( 3.2 -- 3 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToNumber&lt;/td&gt;
+ * &lt;td&gt;Converts the string value to a number.&lt;/td&gt;
+ * &lt;td nowrap&gt; ( string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt; ( &quot;3.2&quot; -- 3.2 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToString&lt;/td&gt;
+ * &lt;td&gt;Converts the value to a string.&lt;/td&gt;
+ * &lt;td nowrap&gt; ( num -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt; ( 3.2 -- &quot;3.2&quot; )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;CharToAscii&lt;/td&gt;
+ * &lt;td&gt;Convert the first character of a string to its ASCII value.&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 97)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBCharToAscii&lt;/td&gt;
+ * &lt;td&gt;Convert the first character of string to its Unicode value.&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 61)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;AsciiToChar&lt;/td&gt;
+ * &lt;td&gt;Convert the ASCII value to the equivalent character.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(97 -- &quot;a&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBAsciiToChar&lt;/td&gt;
+ * &lt;td&gt;Convert a Unicode value to the equivalent character.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(61 -- &quot;a&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Variables&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetVariable&lt;/td&gt;
+ * &lt;td&gt;Push the value for the specified variable on the stack&lt;/td&gt;
+ * &lt;td nowrap&gt;(variableName -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;FlashVersion&quot; -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetVariable&lt;/td&gt;
+ * &lt;td&gt;Set the value of the specified variable&lt;/td&gt;
+ * &lt;td nowrap&gt;(variableName value --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Var1&quot; 123 --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetType&lt;/td&gt;
+ * &lt;td&gt;Returns the type of the object or value at the top of the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value -- value type)&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewVariable&lt;/td&gt;
+ * &lt;td&gt;Create a new user-defined variable.&lt;/td&gt;
+ * &lt;td nowrap&gt;(name --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;x&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;InitVariable&lt;/td&gt;
+ * &lt;td&gt;Create and initialise a user-defined variable.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value name --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(1 &quot;x&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewArray&lt;/td&gt;
+ * &lt;td&gt;Create an array.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value+ count -- array)&lt;/td&gt;
+ * &lt;td nowrap&gt;(1 2 3 4 4 -- array)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;DeleteVariable&lt;/td&gt;
+ * &lt;td&gt;Deletes a variable, returning true if the variable was deleted, false
+ * otherwise.&lt;/td&gt;
+ * &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Delete&lt;/td&gt;
+ * &lt;td&gt;Deletes an object or variable, returning true if the object was deleted,
+ * false otherwise.&lt;/td&gt;
+ * &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Functions&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ExecuteFunction&lt;/td&gt;
+ * &lt;td&gt;Execute the built-in function.&lt;/td&gt;
+ * &lt;td nowrap&gt;(arg* functionName -- result*)&lt;/td&gt;
+ * &lt;td nowrap&gt;(12.3 &quot;isFinite&quot; -- &quot;1&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Return&lt;/td&gt;
+ * &lt;td&gt;Return control from the function.&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Objects&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetAttribute&lt;/td&gt;
+ * &lt;td&gt;Push the value of an objects attribute on the stack&lt;/td&gt;
+ * &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Key&quot; &quot;SPACE&quot; -- 32)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetAttribute&lt;/td&gt;
+ * &lt;td&gt;Set the value of a attribute of an object&lt;/td&gt;
+ * &lt;td nowrap&gt;(variable string value --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&lt;_root&gt; &quot;variable&quot; 1 --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ExecuteMethod&lt;/td&gt;
+ * &lt;td&gt;Execute a method of an object&lt;/td&gt;
+ * &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Key&quot; &quot;getCode&quot; -- num)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewMethod&lt;/td&gt;
+ * &lt;td&gt;Define a new method for an object&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NamedObject&lt;/td&gt;
+ * &lt;td&gt;Construct an instance of a built-in object.&lt;/td&gt;
+ * &lt;td nowrap&gt;(arg* count className -- instance)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;My String&quot; 1 &quot;String&quot; -- instance)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewObject&lt;/td&gt;
+ * &lt;td&gt;Define a new class.&lt;/td&gt;
+ * &lt;td nowrap&gt;((name value)* count -- instance)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Account&quot; &quot;123456&quot; 1 -- value)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Enumerate&lt;/td&gt;
+ * &lt;td&gt;Enumerate through the attributes of the object referenced by the name of
+ * the variable on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;( -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;EnumerateObject&lt;/td&gt;
+ * &lt;td&gt;Enumerate through the attributes of the object on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;( -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Movie Control&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetTarget&lt;/td&gt;
+ * &lt;td&gt;Returns a string representing the path to the movie clip in which the
+ * current action is executed.&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- clipName )&lt;/td&gt;
+ * &lt;td nowrap&gt;( -- &quot;_root/MovieClip&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetTarget2&lt;/td&gt;
+ * &lt;td&gt;Change the context of the Flash Player so subsequent actions are applied
+ * to the movie clip, &lt;i&gt;clipName&lt;/i&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;(clipName -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;MovieClip&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetProperty&lt;/td&gt;
+ * &lt;td&gt;Push the value of the specified property on the stack. Properties are
+ * identified by reserved values, see the FSPush class for more details.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;( &lt;_totalframes&gt; -- 36 )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetProperty&lt;/td&gt;
+ * &lt;td&gt;Set the value of a property&lt;/td&gt;
+ * &lt;td nowrap&gt;(value propertyName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( 8000 &lt;_width&gt; -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;CloneSprite&lt;/td&gt;
+ * &lt;td&gt;Duplicate a movie clip &lt;i&gt;clipName&lt;/i&gt;, on the display list layer
+ * &lt;i&gt;depth&lt;/i&gt; with the name &lt;i&gt;newName&lt;/i&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;( depth clipName newName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( 19 &quot;_root/MovieClip&quot; &quot;newClip&quot; -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;RemoveSprite&lt;/td&gt;
+ * &lt;td&gt;Delete a movie clip&lt;/td&gt;
+ * &lt;td nowrap&gt;( clipName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( &quot;_root/MovieClip&quot; -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StartDrag&lt;/td&gt;
+ * &lt;td&gt;Starts dragging a movie clip with an optional constraining rectangle
+ * defined by the corner points (x1,y1), (x2,y2).&lt;/td&gt;
+ * &lt;td nowrap&gt;( x1 y1 x2 y2 1 clipName --)&lt;br&gt;
+ * &lt;br&gt;( 0 clipName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( 0 0 400 400 1 &quot;movieClip&quot; - )&lt;br&gt;
+ * &lt;br&gt;( 0 &quot;movieClip&quot; - )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;EndDrag&lt;/td&gt;
+ * &lt;td&gt;Stops dragging a movie clip&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NextFrame&lt;/td&gt;
+ * &lt;td&gt;Go to the next frame of the current movie&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;PreviousFrame&lt;/td&gt;
+ * &lt;td&gt;Go to the previous frame of the current movie&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- )&lt;/td&nbsp;&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Play&lt;/td&gt;
+ * &lt;td&gt;Start playing the current movie at the current frame&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Stop&lt;/td&gt;
+ * &lt;td&gt;Stop playing the current movie&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToggleQuality&lt;/td&gt;
+ * &lt;td&gt;Toggle the movie between high and low quality&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StopSounds&lt;/td&gt;
+ * &lt;td&gt;Stop playing all sounds&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;ActionScript 2.0&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Starting with Flash 6 Macromedia extended the syntax of ActionScript to make
+ * it more object-oriented, moving the language closer to Java than JavaScript.
+ * Several actions were added to support the new keywords introduced into
+ * ActionScript 2.0.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;InstanceOf&lt;/td&gt;
+ * &lt;td&gt;Return true or false to the stack if the object can be created using the
+ * constructor function.&lt;/td&gt;
+ * &lt;td nowrap&gt;( object function -- true | false)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Implements&lt;/td&gt;
+ * &lt;td&gt;Identifies a class implements a defined interface.&lt;/td&gt;
+ * &lt;td nowrap&gt;( (function) count function --)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Extends&lt;/td&gt;
+ * &lt;td&gt;Identifies that a class inherits from a class - used to increase the
+ * execution speed of ActionScript code.&lt;/td&gt;
+ * &lt;td nowrap&gt;( subclass superclass --)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Cast&lt;/td&gt;
+ * &lt;td&gt;Casts the type of an object on the stack, returning the object if it is
+ * the same type as the constructor function, null otherwise.&lt;/td&gt;
+ * &lt;td nowrap&gt;(function object -- object | null)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Throw&lt;/td&gt;
+ * &lt;td&gt;Throw an exception.&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Miscellaneous&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Trace&lt;/td&gt;
+ * &lt;td&gt;Append value to debugging window&lt;/td&gt;
+ * &lt;td nowrap&gt;(value --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;X = 3&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetTime&lt;/td&gt;
+ * &lt;td&gt;Push the number of milliseconds that have elapsed since the player
+ * started on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- 1274832)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;RandomNumber&lt;/td&gt;
+ * &lt;td&gt;Push a random number on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(maximumValue -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(10 -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Notes&lt;/b&gt;
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The Add action was updated in Flash 5 so it can be used to perform
+ * arithmetic add and string concatenation depending on whether the values on
+ * the stack can be interpreted as numeric values or strings. The original add
+ * action (Code = 10) should not be used.&lt;/li&gt;
+ * 
+ * &lt;li&gt;For the division operation, if a divide by zero error occurs then the
+ * string &quot;#ERROR&quot; is pushed onto the stack.&lt;/li&gt;
+ * 
+ * &lt;li&gt;The Equals and Less actions were updated in Flash 5 so it can be used to
+ * perform arithmetic and string comparison depending on whether the values on
+ * the stack can be interpreted as numeric values or strings. The original Less
+ * action (code = 15) and Equals action (code = 14) should not be used.&lt;/li&gt;
+ * 
+ * &lt;li&gt;Type conversion of string characters is now handled by the String
+ * object, introduced in Flash 5. The ToInteger action is now supported by the
+ * Math object also introduced in Flash 5. The type conversion functions are
+ * only included for completeness.&lt;/li&gt;
+ * 
+ * &lt;li&gt;Flash version 5 supports built-in and user defined objects. For a full
+ * description of the objects supported please consult an ActionScript 5
+ * reference guide.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSActionObject class defines a series of constants that lists the type of
+ * actions supported in the current release. Actions may be created by
+ * specifying the action type in the constructor:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSAction anAction = new FSAction(FSAction.Add);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPush class is used to push values onto the Flash Player's stack before
+ * an action is executed. For example to execute the expression (1+2)*3 when a
+ * frame is displayed the following sequence of actions are created:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction frameAction = new FSDoAction();
+ * 
+ * frameAction.add(new FSPush(1));
+ * frameAction.add(new FSPush(2));
+ * frameAction.add(new FSAction(FSAction.Add));
+ * frameAction.add(new FSPush(3));
+ * frameAction.add(new FSAction(FSAction.Multiply));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The Flash Player also supported classes and object that represent different
+ * complex data types and system resources such as the mouse. These objects and
+ * the functions they support are referenced by name. String containing the
+ * names and the values (and number) of the arguments required are pushed onto
+ * the stack:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(aValue));
+ * frameAction.add(new FSPush(aValue));
+ * frameAction.add(new FSPush(2));
+ * 
+ * // Place the name on the stack then execute the function.
+ * 
+ * frameAction.add(new FSPush(&quot;FunctionName&quot;));
+ * frameAction.add(new FSAction(FSAction.ExecuteFunction));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To execute a method on a given object a reference to the object is retrieved
+ * and the name of the method and any arguments are specified. For example to
+ * play a movie clip starting at a named frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(&quot;frameName&quot;));
+ * frameAction.add(new FSPush(1));
+ * 
+ * // Get a reference to the object.
+ * 
+ * frameAction.add(new FSPush(&quot;_root&quot;));
+ * frameAction.add(new FSPush(&quot;movieClip&quot;));
+ * frameAction.add(new FSAction(FSAction.GetAttribute));
+ * 
+ * // Place the name of the method on the stack then execute it.
+ * 
+ * frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * frameAction.add(new FSAction(FSAction.ExecuteMethod));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Note: The FSPush class allows more than one value to be pushed onto the stack
+ * at a time. In the above examples separate FSPush objects are created to make
+ * the code a little more readable.
+ * &lt;/p&gt;
+ * 
+ */
+public class FSAction extends FSActionObject
+{
+	private static final FSAction[] actions =
+	{
+		new FSAction(FSAction.End), // 0;
+		new FSAction(1),
+		new FSAction(2),
+		new FSAction(3),
+		new FSAction(FSAction.NextFrame), // 4;
+		new FSAction(FSAction.PrevFrame), // 5;
+		new FSAction(FSAction.Play), // 6;
+		new FSAction(FSAction.Stop), // 7;
+		new FSAction(FSAction.ToggleQuality), // 8;
+		new FSAction(FSAction.StopSounds), // 9;
+		new FSAction(FSAction.IntegerAdd), // 10;
+		new FSAction(FSAction.Subtract), // 11;
+		new FSAction(FSAction.Multiply), // 12;
+		new FSAction(FSAction.Divide), // 13;
+		new FSAction(FSAction.IntegerEquals), // 14;
+		new FSAction(FSAction.IntegerLess), // 15;
+		new FSAction(FSAction.And), // 16;
+		new FSAction(FSAction.Or), // 17;
+		new FSAction(FSAction.Not), // 18;
+		new FSAction(FSAction.StringEquals), // 19;
+		new FSAction(FSAction.StringLength), // 20;
+		new FSAction(FSAction.StringExtract), // 21;
+		new FSAction(22),
+		new FSAction(FSAction.Pop), // 23;
+		new FSAction(FSAction.ToInteger), // 24;
+		new FSAction(25),
+		new FSAction(26),
+		new FSAction(27),
+		new FSAction(FSAction.GetVariable), // 28;
+		new FSAction(FSAction.SetVariable), // 29;
+		new FSAction(30),
+		new FSAction(31),
+		new FSAction(FSAction.SetTarget2), // 32;
+		new FSAction(FSAction.StringAdd), // 33;
+		new FSAction(FSAction.GetProperty), // 34;
+		new FSAction(FSAction.SetProperty), // 35;
+		new FSAction(FSAction.CloneSprite), // 36;
+		new FSAction(FSAction.RemoveSprite), // 37;
+		new FSAction(FSAction.Trace), // 38;
+		new FSAction(FSAction.StartDrag), // 39;
+		new FSAction(FSAction.EndDrag), // 40;
+		new FSAction(FSAction.StringLess), // 41;
+		new FSAction(FSAction.Throw), // 42;
+		new FSAction(FSAction.Cast), // 43;
+		new FSAction(FSAction.Implements), // 44;
+		new FSAction(45),
+		new FSAction(46),
+		new FSAction(47),
+		new FSAction(FSAction.RandomNumber), // 48;
+		new FSAction(FSAction.MBStringLength), // 49;
+		new FSAction(FSAction.CharToAscii), // 50;
+		new FSAction(FSAction.AsciiToChar), // 51;
+		new FSAction(FSAction.GetTime), // 52;
+		new FSAction(FSAction.MBStringExtract), // 53;
+		new FSAction(FSAction.MBCharToAscii), // 54;
+		new FSAction(FSAction.MBAsciiToChar), // 55;
+		new FSAction(56),
+		new FSAction(57),
+		new FSAction(FSAction.DeleteVariable), // 58;
+		new FSAction(FSAction.Delete), // 59;
+		new FSAction(FSAction.InitVariable), // 60;
+		new FSAction(FSAction.ExecuteFunction), // 61;
+		new FSAction(FSAction.Return), // 62;
+		new FSAction(FSAction.Modulo), // 63;
+		new FSAction(FSAction.NamedObject), // 64;
+		new FSAction(FSAction.NewVariable), // 65;
+		new FSAction(FSAction.NewArray), // 66;
+		new FSAction(FSAction.NewObject), // 67;
+		new FSAction(FSAction.GetType), // 68;
+		new FSAction(FSAction.GetTarget), // 69;
+		new FSAction(FSAction.Enumerate), // 70;
+		new FSAction(FSAction.Add), // 71;
+		new FSAction(FSAction.Less), // 72;
+		new FSAction(FSAction.Equals), // 73;
+		new FSAction(FSAction.ToNumber), // 74;
+		new FSAction(FSAction.ToString), // 75;
+		new FSAction(FSAction.Duplicate), // 76;
+		new FSAction(FSAction.Swap), // 77;
+		new FSAction(FSAction.GetAttribute), // 78;
+		new FSAction(FSAction.SetAttribute), // 79;
+		new FSAction(FSAction.Increment), // 80;
+		new FSAction(FSAction.Decrement), // 81;
+		new FSAction(FSAction.ExecuteMethod), // 82;
+		new FSAction(FSAction.NewMethod), // 83;
+		new FSAction(FSAction.InstanceOf), // 84;
+		new FSAction(FSAction.EnumerateObject), // 85;
+		new FSAction(86),
+		new FSAction(87),
+		new FSAction(88),
+		new FSAction(89),
+		new FSAction(90),
+		new FSAction(91),
+		new FSAction(92),
+		new FSAction(93),
+		new FSAction(94),
+		new FSAction(95),
+		new FSAction(FSAction.BitwiseAnd), // 96;
+		new FSAction(FSAction.BitwiseOr), // 97;
+		new FSAction(FSAction.BitwiseXOr), // 98;
+		new FSAction(FSAction.LogicalShiftLeft), // 99;
+		new FSAction(FSAction.ArithmeticShiftRight), // 100;
+		new FSAction(FSAction.LogicalShiftRight), // 101;
+		new FSAction(FSAction.StrictEquals), // 102;
+		new FSAction(FSAction.Greater), // 103;
+		new FSAction(FSAction.StringGreater), // 104;
+		new FSAction(FSAction.Extends), // 105;
+		new FSAction(106), new FSAction(107), new FSAction(108),
+		new FSAction(109), new FSAction(110), new FSAction(111),
+		new FSAction(112), new FSAction(113), new FSAction(114),
+		new FSAction(115), new FSAction(116), new FSAction(117),
+		new FSAction(118), new FSAction(119), new FSAction(120),
+		new FSAction(121), new FSAction(122), new FSAction(123),
+		new FSAction(124), new FSAction(125), new FSAction(126),
+		new FSAction(127), // 127
+	};
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Stack Manipulation&lt;/h1&gt;
+	public static FSAction getInstance(int type)
+	{
+		return actions[type];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	/**
+	 * Factory method for generating an FSAction object representing the end of
+	 * a sequence of actions.
+	 */
+	public static FSAction End()
+	{
+		return actions[FSAction.End];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Factory method for generating an FSAction object representing a NextFrame
+	 * action.
+	 */
+	public static FSAction NextFrame()
+	{
+		return actions[FSAction.NextFrame];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Pop&lt;/td&gt;
-    &lt;td&gt;Pop value from the top of the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA -- )&lt;/td&gt;
-    &lt;td nowrap&gt;(4 -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Duplicate&lt;/td&gt;
-    &lt;td&gt;Duplicate the value at the top of the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA -- valueA valueA)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 -- 4 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Swap&lt;/td&gt;
-    &lt;td&gt;Swap the top two values on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA valueB -- valueB valueA)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 3 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Factory method for generating an FSAction object representing a PrevFrame
+	 * action.
+	 */
+	public static FSAction PrevFrame()
+	{
+		return actions[FSAction.PrevFrame];
+	}
 
-&lt;p&gt;FSPush is used to push literals onto the Stack. See also FSRegisterCopy which 
-copies the value on top of the Stack to one of the Flash Player's internal 
-registers.&lt;/p&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Arithmetic&lt;/h1&gt;
+	/**
+	 * Factory method for generating an FSAction object representing a Play
+	 * action.
+	 */
+	public static FSAction Play()
+	{
+		return actions[FSAction.Play];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	/**
+	 * Factory method for generating an FSAction object representing a Stop
+	 * action.
+	 */
+	public static FSAction Stop()
+	{
+		return actions[FSAction.Stop];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Factory method for generating an FSAction object representing a
+	 * ToggleQuality action.
+	 */
+	public static FSAction ToggleQuality()
+	{
+		return actions[FSAction.ToggleQuality];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Add&lt;/td&gt;
-    &lt;td&gt;Arithmetic Add: A + B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 7)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Subtract&lt;/td&gt;
-    &lt;td&gt;Arithmetic Subtract: A - B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Multiply&lt;/td&gt;
-    &lt;td&gt;Arithmetic Multiply: A * B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 12)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Divide&lt;/td&gt;
-    &lt;td&gt;Arithmetic Divide: A / B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 1.333)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Modulo&lt;/td&gt;
-    &lt;td&gt;Arithmetic Modulo: A % B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Increment&lt;/td&gt;
-    &lt;td&gt;Add 1 to the value on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Decrement&lt;/td&gt;
-    &lt;td&gt;Subtracted 1 from the value on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Factory method for generating an FSAction object representing a
+	 * StopSounds action.
+	 */
+	public static FSAction StopSounds()
+	{
+		return actions[FSAction.StopSounds];
+	}
 
-&lt;p&gt;Arithmetic add is supported by two actions. IntegerAdd was introduced in Flash 4. 
-It was replaced in Flash 5 by the more flexible Add action which is able to add 
-any two numbers and also concatenate strings. If a string and a number are added 
-then the number is converted to its string representation before concatenation.&lt;/p&gt;
+	// Flash 4
+	// / Factory method for generating an FSAction object representing a
+	// Subtract action.
+	public static FSAction Subtract()
+	{
+		return actions[FSAction.Subtract];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Comparison&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// Multiply action.
+	public static FSAction Multiply()
+	{
+		return actions[FSAction.Multiply];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a Divide
+	// action.
+	public static FSAction Divide()
+	{
+		return actions[FSAction.Divide];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a And
+	// action.
+	public static FSAction And()
+	{
+		return actions[FSAction.And];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Less&lt;/td&gt;
-    &lt;td&gt;LessThan: A &lt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringLess&lt;/td&gt;
-    &lt;td&gt;String compare: stringA &lt; stringB&lt;/td&gt;
-    &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Equals&lt;/td&gt;
-    &lt;td&gt;Equals: A == B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(23 23 -- 1 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringEquals&lt;/td&gt;
-    &lt;td&gt;String compare: stringA == stringB&lt;/td&gt;
-    &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; &quot;abc&quot; -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StrictEquals&lt;/td&gt;
-    &lt;td&gt;Equals: A === B, are the types as well as the values equal.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA valueB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;23&quot; 23 -- 0 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Greater&lt;/td&gt;
-    &lt;td&gt;Greater Than: A &gt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringGreater&lt;/td&gt;
-    &lt;td&gt;String compare: stringA &gt; stringB&lt;/td&gt;
-    &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a Or
+	// action.
+	public static FSAction Or()
+	{
+		return actions[FSAction.Or];
+	}
 
-&lt;p&gt;The less than comparison is supported by IntegerLess introduced in Flash 4 
-and Less introduced in Flash 5. The Less action is more flexible allowing comparison 
-between any combination of two numbers and strings. In Flash 4 comparisons were 
-only supported on values of the same type using either IntegerLess or StringLess.&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a Not
+	// action.
+	public static FSAction Not()
+	{
+		return actions[FSAction.Not];
+	}
 
-&lt;p&gt;The equals comparison is supported by IntegerEquals introduced in Flash 4 and 
-Equals introduced in Flash 5. The Equals action is more flexible allowing 
-comparison between any combination of two numbers and strings. In Flash 4 
-comparisons were only supported on values of the same type using either
-IntegerEquals or StringEquals.&lt;/p&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Logical&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StringEquals action.
+	public static FSAction StringEquals()
+	{
+		return actions[FSAction.StringEquals];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StringLength action.
+	public static FSAction StringLength()
+	{
+		return actions[FSAction.StringLength];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StringExtract action.
+	public static FSAction StringExtract()
+	{
+		return actions[FSAction.StringExtract];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;And&lt;/td&gt;
-    &lt;td&gt;Logical And: A &amp;&amp; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 0 -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Or&lt;/td&gt;
-    &lt;td&gt;Logical Or: A || B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 0 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Not&lt;/td&gt;
-    &lt;td&gt;Logical Not: !A&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Bitwise&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a Pop
+	// action.
+	public static FSAction Pop()
+	{
+		return actions[FSAction.Pop];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// ToInteger action.
+	public static FSAction ToInteger()
+	{
+		return actions[FSAction.ToInteger];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a
+	// GetVariable action.
+	public static FSAction GetVariable()
+	{
+		return actions[FSAction.GetVariable];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;BitwiseAnd&lt;/td&gt;
-    &lt;td&gt;Bitwise And: A &amp; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(5 4 -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;BitwiseOr&lt;/td&gt;
-    &lt;td&gt;Bitwise Or: A | B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(5 4 -- 5)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;BitwiseXOr&lt;/td&gt;
-    &lt;td&gt;Bitwise Exclusive-Or: A ^ B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(5 4 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;LogicalShiftLeft&lt;/td&gt;
-    &lt;td&gt;Logical Shift Left: A &lt;&lt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 1 -- 8)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;LogicalShiftRight&lt;/td&gt;
-    &lt;td&gt;Logical Shift Right: A &gt;&gt;&gt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(8 1 -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ArithmeticShiftRight&lt;/td&gt;
-    &lt;td&gt;Arithmetic Shift Right (sign extension): A &gt;&gt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(-1 1 -- -1)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a
+	// SetVariable action.
+	public static FSAction SetVariable()
+	{
+		return actions[FSAction.SetVariable];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;String&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// SetTarget2 action.
+	public static FSAction SetTarget2()
+	{
+		return actions[FSAction.SetTarget2];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StringAdd action.
+	public static FSAction StringAdd()
+	{
+		return actions[FSAction.StringAdd];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a
+	// GetProperty action.
+	public static FSAction GetProperty()
+	{
+		return actions[FSAction.GetProperty];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringAdd&lt;/td&gt;
-    &lt;td&gt;Concatenate two strings&lt;/td&gt;
-    &lt;td nowrap&gt;(string string -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;ab&quot; &quot;cd&quot; -- &quot;abcd&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringLength&lt;/td&gt;
-    &lt;td&gt;Returns the length of a string&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBStringLength&lt;/td&gt;
-    &lt;td&gt;Returns the length of a string that contains characters from an extended set such as Unicode.&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringExtract&lt;/td&gt;
-    &lt;td&gt;Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string starting at position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBStringExtract&lt;/td&gt;
-    &lt;td&gt;Multi-byte Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string starting at position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a
+	// SetProperty action.
+	public static FSAction SetProperty()
+	{
+		return actions[FSAction.SetProperty];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Type Conversion&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// CloneSprite action.
+	public static FSAction CloneSprite()
+	{
+		return actions[FSAction.CloneSprite];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// RemoveSprite action.
+	public static FSAction RemoveSprite()
+	{
+		return actions[FSAction.RemoveSprite];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a Trace
+	// action.
+	public static FSAction Trace()
+	{
+		return actions[FSAction.Trace];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToInteger&lt;/td&gt;
-    &lt;td&gt;Converts the value to an integer&lt;/td&gt;
-    &lt;td nowrap&gt; ( num -- num)&lt;/td&gt;
-    &lt;td nowrap&gt; ( 3.2 -- 3 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToNumber&lt;/td&gt;
-    &lt;td&gt;Converts the string value to a number.&lt;/td&gt;
-    &lt;td nowrap&gt; ( string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt; ( &quot;3.2&quot; -- 3.2 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToString&lt;/td&gt;
-    &lt;td&gt;Converts the value to a string.&lt;/td&gt;
-    &lt;td nowrap&gt; ( num -- string)&lt;/td&gt;
-    &lt;td nowrap&gt; ( 3.2 -- &quot;3.2&quot; )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;CharToAscii&lt;/td&gt;
-    &lt;td&gt;Convert the first character of a string to its ASCII value.&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 97)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBCharToAscii&lt;/td&gt;
-    &lt;td&gt;Convert the first character of string to its Unicode value.&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 61)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;AsciiToChar&lt;/td&gt;
-    &lt;td&gt;Convert the ASCII value to the equivalent character.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(97 -- &quot;a&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBAsciiToChar&lt;/td&gt;
-    &lt;td&gt;Convert a Unicode value to the equivalent character.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(61 -- &quot;a&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StartDrag action.
+	public static FSAction StartDrag()
+	{
+		return actions[FSAction.StartDrag];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Variables&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a EndDrag
+	// action.
+	public static FSAction EndDrag()
+	{
+		return actions[FSAction.EndDrag];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StringLess action.
+	public static FSAction StringLess()
+	{
+		return actions[FSAction.StringLess];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a
+	// RandomNumber action.
+	public static FSAction RandomNumber()
+	{
+		return actions[FSAction.RandomNumber];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetVariable&lt;/td&gt;
-    &lt;td&gt;Push the value for the specified variable on the stack&lt;/td&gt;
-    &lt;td nowrap&gt;(variableName -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;FlashVersion&quot; -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetVariable&lt;/td&gt;
-    &lt;td&gt;Set the value of the specified variable&lt;/td&gt;
-    &lt;td nowrap&gt;(variableName value --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Var1&quot; 123 --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetType&lt;/td&gt;
-    &lt;td&gt;Returns the type of the object or value at the top of the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(value -- value type)&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewVariable&lt;/td&gt;
-    &lt;td&gt;Create a new user-defined variable.&lt;/td&gt;
-    &lt;td nowrap&gt;(name --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;x&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;InitVariable&lt;/td&gt;
-    &lt;td&gt;Create and initialise a user-defined variable.&lt;/td&gt;
-    &lt;td nowrap&gt;(value name --)&lt;/td&gt;
-    &lt;td nowrap&gt;(1 &quot;x&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewArray&lt;/td&gt;
-    &lt;td&gt;Create an array.&lt;/td&gt;
-    &lt;td nowrap&gt;(value+ count -- array)&lt;/td&gt;
-    &lt;td nowrap&gt;(1 2 3 4 4 -- array)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;DeleteVariable&lt;/td&gt;
-    &lt;td&gt;Deletes a variable, returning true if the variable was deleted, false otherwise.&lt;/td&gt;
-    &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Delete&lt;/td&gt;
-    &lt;td&gt;Deletes an object or variable, returning true if the object was deleted, false otherwise.&lt;/td&gt;
-    &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a
+	// MBStringLength action.
+	public static FSAction MBStringLength()
+	{
+		return actions[FSAction.MBStringLength];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Functions&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// CharToAscii action.
+	public static FSAction CharToAscii()
+	{
+		return actions[FSAction.CharToAscii];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// AsciiToChar action.
+	public static FSAction AsciiToChar()
+	{
+		return actions[FSAction.AsciiToChar];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a GetTime
+	// action.
+	public static FSAction GetTime()
+	{
+		return actions[FSAction.GetTime];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ExecuteFunction&lt;/td&gt;
-    &lt;td&gt;Execute the built-in function.&lt;/td&gt;
-    &lt;td nowrap&gt;(arg* functionName -- result*)&lt;/td&gt;
-    &lt;td nowrap&gt;(12.3 &quot;isFinite&quot; -- &quot;1&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Return&lt;/td&gt;
-    &lt;td&gt;Return control from the function.&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a
+	// MBStringExtract action.
+	public static FSAction MBStringExtract()
+	{
+		return actions[FSAction.MBStringExtract];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Objects&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// MBCharToAscii action.
+	public static FSAction MBCharToAscii()
+	{
+		return actions[FSAction.MBCharToAscii];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// MBAsciiToChar action.
+	public static FSAction MBAsciiToChar()
+	{
+		return actions[FSAction.MBAsciiToChar];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// Flash 5
+	// / Factory method for generating an FSAction object representing a
+	// DeleteVariable action.
+	public static FSAction DeleteVariable()
+	{
+		return actions[FSAction.DeleteVariable];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetAttribute&lt;/td&gt;
-    &lt;td&gt;Push the value of an objects attribute on the stack&lt;/td&gt;
-    &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Key&quot; &quot;SPACE&quot; -- 32)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetAttribute&lt;/td&gt;
-    &lt;td&gt;Set the value of a attribute of an object&lt;/td&gt;
-    &lt;td nowrap&gt;(variable string value --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&lt;_root&gt; &quot;variable&quot; 1 --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ExecuteMethod&lt;/td&gt;
-    &lt;td&gt;Execute a method of an object&lt;/td&gt;
-    &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Key&quot; &quot;getCode&quot; -- num)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewMethod&lt;/td&gt;
-    &lt;td&gt;Define a new method for an object&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NamedObject&lt;/td&gt;
-    &lt;td&gt;Construct an instance of a built-in object.&lt;/td&gt;
-    &lt;td nowrap&gt;(arg* count className -- instance)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;My String&quot; 1 &quot;String&quot; -- instance)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewObject&lt;/td&gt;
-    &lt;td&gt;Define a new class.&lt;/td&gt;
-    &lt;td nowrap&gt;((name value)* count -- instance)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Account&quot; &quot;123456&quot; 1 -- value)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Enumerate&lt;/td&gt;
-    &lt;td&gt;Enumerate through the attributes of the object referenced by the name of the variable on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
-    &lt;td nowrap&gt;( -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;EnumerateObject&lt;/td&gt;
-    &lt;td&gt;Enumerate through the attributes of the object on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
-    &lt;td nowrap&gt;( -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a Delete
+	// action.
+	public static FSAction Delete()
+	{
+		return actions[FSAction.Delete];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Movie Control&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// InitVariable action.
+	public static FSAction InitVariable()
+	{
+		return actions[FSAction.InitVariable];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// ExecuteFunction action.
+	public static FSAction ExecuteFunction()
+	{
+		return actions[FSAction.ExecuteFunction];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a Return
+	// action.
+	public static FSAction Return()
+	{
+		return actions[FSAction.Return];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetTarget&lt;/td&gt;
-    &lt;td&gt;Returns a string representing the path to the movie clip in which the current action is executed.&lt;/td&gt;
-    &lt;td nowrap&gt;(-- clipName )&lt;/td&gt;
-    &lt;td nowrap&gt;( -- &quot;_root/MovieClip&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetTarget2&lt;/td&gt;
-    &lt;td&gt;Change the context of the Flash Player so subsequent actions are applied to the movie clip, &lt;i&gt;clipName&lt;/i&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;(clipName -- )&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;MovieClip&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetProperty&lt;/td&gt;
-    &lt;td&gt;Push the value of the specified property on the stack. Properties are identified by reserved values, see the FSPush class for more details.&lt;/td&gt;
-    &lt;td nowrap&gt;(value -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;( &lt;_totalframes&gt; -- 36 )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetProperty&lt;/td&gt;
-    &lt;td&gt;Set the value of a property&lt;/td&gt;
-    &lt;td nowrap&gt;(value propertyName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( 8000 &lt;_width&gt; -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;CloneSprite&lt;/td&gt;
-    &lt;td&gt;Duplicate a movie clip &lt;i&gt;clipName&lt;/i&gt;, on the display list layer &lt;i&gt;depth&lt;/i&gt; with the name &lt;i&gt;newName&lt;/i&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;( depth clipName newName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( 19 &quot;_root/MovieClip&quot; &quot;newClip&quot; -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;RemoveSprite&lt;/td&gt;
-    &lt;td&gt;Delete a movie clip&lt;/td&gt;
-    &lt;td nowrap&gt;( clipName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( &quot;_root/MovieClip&quot; -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StartDrag&lt;/td&gt;
-    &lt;td&gt;Starts dragging a movie clip with an optional constraining rectangle defined by the corner points (x1,y1), (x2,y2).&lt;/td&gt;
-    &lt;td nowrap&gt;( x1 y1 x2 y2 1 clipName --)&lt;br&gt;&lt;br&gt;( 0 clipName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( 0 0 400 400 1 &quot;movieClip&quot; - )&lt;br&gt;&lt;br&gt;( 0 &quot;movieClip&quot; - )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;EndDrag&lt;/td&gt;
-    &lt;td&gt;Stops dragging a movie clip&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NextFrame&lt;/td&gt;
-    &lt;td&gt;Go to the next frame of the current movie&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;PreviousFrame&lt;/td&gt;
-    &lt;td&gt;Go to the previous frame of the current movie&lt;/td&gt;
-    &lt;td nowrap&gt;(-- )&lt;/td&nbsp;&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Play&lt;/td&gt;
-    &lt;td&gt;Start playing the current movie at the current frame&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Stop&lt;/td&gt;
-    &lt;td&gt;Stop playing the current movie&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToggleQuality&lt;/td&gt;
-    &lt;td&gt;Toggle the movie between high and low quality&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StopSounds&lt;/td&gt;
-    &lt;td&gt;Stop playing all sounds&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;    
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;ActionScript 2.0&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a Modulo
+	// action.
+	public static FSAction Modulo()
+	{
+		return actions[FSAction.Modulo];
+	}
 
-&lt;p&gt;Starting with Flash 6 Macromedia extended the syntax of ActionScript to make 
-it more object-oriented, moving the language closer to Java than JavaScript. 
-Several actions were added to support the new keywords introduced into ActionScript 
-2.0.&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a
+	// NamedObject action.
+	public static FSAction NamedObject()
+	{
+		return actions[FSAction.NamedObject];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a
+	// NewVariable action.
+	public static FSAction NewVariable()
+	{
+		return actions[FSAction.NewVariable];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a
+	// NewArray action.
+	public static FSAction NewArray()
+	{
+		return actions[FSAction.NewArray];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;InstanceOf&lt;/td&gt;
-    &lt;td&gt;Return true or false to the stack if the object can be created using the constructor function.&lt;/td&gt;
-    &lt;td nowrap&gt;( object function -- true | false)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Implements&lt;/td&gt;
-    &lt;td&gt;Identifies a class implements a defined interface.&lt;/td&gt;
-    &lt;td nowrap&gt;( (function) count function --)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Extends&lt;/td&gt;
-    &lt;td&gt;Identifies that a class inherits from a class - used to increase the execution speed of ActionScript code.&lt;/td&gt;
-    &lt;td nowrap&gt;( subclass superclass --)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Cast&lt;/td&gt;
-    &lt;td&gt;Casts the type of an object on the stack, returning the object if it is the same type as the constructor function, null otherwise.&lt;/td&gt;
-    &lt;td nowrap&gt;(function object -- object | null)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Throw&lt;/td&gt;
-    &lt;td&gt;Throw an exception.&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Miscellaneous&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a
+	// NewObject action.
+	public static FSAction NewObject()
+	{
+		return actions[FSAction.NewObject];
+	}
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Factory method for generating an FSAction object representing a GetType
+	// action.
+	public static FSAction GetType()
+	{
+		return actions[FSAction.GetType];
+	}
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Factory method for generating an FSAction object representing a
+	// GetTarget action.
+	public static FSAction GetTarget()
+	{
+		return actions[FSAction.GetTarget];
+	}
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Trace&lt;/td&gt;
-    &lt;td&gt;Append value to debugging window&lt;/td&gt;
-    &lt;td nowrap&gt;(value --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;X = 3&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetTime&lt;/td&gt;
-    &lt;td&gt;Push the number of milliseconds that have elapsed since the player started on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(-- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(-- 1274832)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;RandomNumber&lt;/td&gt;
-    &lt;td&gt;Push a random number on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(maximumValue -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(10 -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Factory method for generating an FSAction object representing a
+	// Enumerate action.
+	public static FSAction Enumerate()
+	{
+		return actions[FSAction.Enumerate];
+	}
 
-&lt;p&gt;&lt;b&gt;Notes&lt;/b&gt;&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a Add
+	// action.
+	public static FSAction Add()
+	{
+		return actions[FSAction.Add];
+	}
 
-&lt;ul&gt;
-&lt;li&gt;The Add action was updated in Flash 5 so it can be used to perform arithmetic add and string concatenation depending on whether the values on the stack can be interpreted as numeric values or strings. The original add action (Code = 10) should not be used.&lt;/li&gt;
+	// / Factory method for generating an FSAction object representing a Less
+	// action.
+	public static FSAction Less()
+	{
+		return actions[FSAction.Less];
+	}
 
-&lt;li&gt;For the division operation, if a divide by zero error occurs then the string &quot;#ERROR&quot; is pushed onto the stack.&lt;/li&gt;
+	// / Factory method for generating an FSAction object representing a Equals
+	// action.
+	public static FSAction Equals()
+	{
+		return actions[FSAction.Equals];
+	}
 
-&lt;li&gt;The Equals and Less actions were updated in Flash 5 so it can be used to perform arithmetic and string comparison depending on whether the values on the stack can be interpreted as numeric values or strings. The original Less action (code = 15) and Equals action (code = 14) should not be used.&lt;/li&gt;
+	// / Factory method for generating an FSAction object representing a
+	// ToNumber action.
+	public static FSAction ToNumber()
+	{
+		return actions[FSAction.ToNumber];
+	}
 
-&lt;li&gt;Type conversion of string characters is now handled by the String object, introduced in Flash 5. The ToInteger action is now supported by the Math object also introduced in Flash 5. The type conversion functions are only included for completeness.&lt;/li&gt;
+	// / Factory method for generating an FSAction object representing a
+	// ToString action.
+	public static FSAction ToString()
+	{
+		return actions[FSAction.ToString];
+	}
 
-&lt;li&gt;Flash version 5 supports built-in and user defined objects. For a full description of the objects supported please consult an ActionScript 5 reference guide.&lt;/li&gt;
-&lt;/ul&gt;
+	// / Factory method for generating an FSAction object representing a
+	// Duplicate action.
+	public static FSAction Duplicate()
+	{
+		return actions[FSAction.Duplicate];
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	// / Factory method for generating an FSAction object representing a Swap
+	// action.
+	public static FSAction Swap()
+	{
+		return actions[FSAction.Swap];
+	}
 
-&lt;p&gt;The FSActionObject class defines a series of constants that lists the type of actions supported in the current release. Actions may be created by specifying the action type in the constructor:&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a
+	// GetAttribute action.
+	public static FSAction GetAttribute()
+	{
+		return actions[FSAction.GetAttribute];
+	}
 
-&lt;pre&gt;
-FSAction anAction = new FSAction(FSAction.Add);
-&lt;/pre&gt;
+	// / Factory method for generating an FSAction object representing a
+	// SetAttribute action.
+	public static FSAction SetAttribute()
+	{
+		return actions[FSAction.SetAttribute];
+	}
 
-&lt;p&gt;The FSPush class is used to push values onto the Flash Player's stack before an action is executed. For example to execute the expression (1+2)*3 when a frame is displayed the following sequence of actions are created:&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a
+	// Increment action.
+	public static FSAction Increment()
+	{
+		return actions[FSAction.Increment];
+	}
 
-&lt;pre&gt;
-FSDoAction frameAction = new FSDoAction();
+	// / Factory method for generating an FSAction object representing a
+	// Decrement action.
+	public static FSAction Decrement()
+	{
+		return actions[FSAction.Decrement];
+	}
 
-frameAction.add(new FSPush(1));
-frameAction.add(new FSPush(2));
-frameAction.add(new FSAction(FSAction.Add));
-frameAction.add(new FSPush(3));
-frameAction.add(new FSAction(FSAction.Multiply));
-&lt;/pre&gt;
+	// / Factory method for generating an FSAction object representing a
+	// ExecuteMethod action.
+	public static FSAction ExecuteMethod()
+	{
+		return actions[FSAction.ExecuteMethod];
+	}
 
-&lt;p&gt;The Flash Player also supported classes and object that represent different complex data types and system resources such as the mouse. These objects and the functions they support are referenced by name. String containing the names and the values (and number) of the arguments required are pushed onto the stack:&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a
+	// NewMethod action.
+	public static FSAction NewMethod()
+	{
+		return actions[FSAction.NewMethod];
+	}
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+	// / Factory method for generating an FSAction object representing a
+	// BitwiseAnd action.
+	public static FSAction BitwiseAnd()
+	{
+		return actions[FSAction.BitwiseAnd];
+	}
 
-frameAction.add(new FSPush(aValue));
-frameAction.add(new FSPush(aValue));
-frameAction.add(new FSPush(2));
+	// / Factory method for generating an FSAction object representing a
+	// BitwiseOr action.
+	public static FSAction BitwiseOr()
+	{
+		return actions[FSAction.BitwiseOr];
+	}
 
-// Place the name on the stack then execute the function.
+	// / Factory method for generating an FSAction object representing a
+	// BitwiseXOr action.
+	public static FSAction BitwiseXOr()
+	{
+		return actions[FSAction.BitwiseXOr];
+	}
 
-frameAction.add(new FSPush(&quot;FunctionName&quot;));
-frameAction.add(new FSAction(FSAction.ExecuteFunction));
-&lt;/pre&gt;
+	// / Factory method for generating an FSAction object representing a
+	// LogicalShiftLeft action.
+	public static FSAction LogicalShiftLeft()
+	{
+		return actions[FSAction.LogicalShiftLeft];
+	}
 
-&lt;p&gt;To execute a method on a given object a reference to the object is retrieved and the name of the method and any arguments are specified. For example to play a movie clip starting at a named frame:&lt;/p&gt;
+	// / Factory method for generating an FSAction object representing a
+	// ArithmeticShiftRight action.
+	public static FSAction ArithmeticShiftRight()
+	{
+		return actions[FSAction.ArithmeticShiftRight];
+	}
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+	// / Factory method for generating an FSAction object representing a
+	// LogicalShiftRight action.
+	public static FSAction LogicalShiftRight()
+	{
+		return actions[FSAction.LogicalShiftRight];
+	}
 
-frameAction.add(new FSPush(&quot;frameName&quot;));
-frameAction.add(new FSPush(1));
+	// Flash 6
+	// / Factory method for generating an FSAction object representing a
+	// InstanceOf action.
+	public static FSAction InstanceOf()
+	{
+		return actions[FSAction.InstanceOf];
+	}
 
-// Get a reference to the object.
+	// / Factory method for generating an FSAction object representing a
+	// EnumerateObject action.
+	public static FSAction EnumerateObject()
+	{
+		return actions[FSAction.EnumerateObject];
+	}
 
-frameAction.add(new FSPush(&quot;_root&quot;));
-frameAction.add(new FSPush(&quot;movieClip&quot;));
-frameAction.add(new FSAction(FSAction.GetAttribute));
+	// / Factory method for generating an FSAction object representing a Greater
+	// action.
+	public static FSAction Greater()
+	{
+		return actions[FSAction.Greater];
+	}
 
-// Place the name of the method on the stack then execute it.
+	// / Factory method for generating an FSAction object representing a
+	// StringGreater action.
+	public static FSAction StringGreater()
+	{
+		return actions[FSAction.StringGreater];
+	}
 
-frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
-frameAction.add(new FSAction(FSAction.ExecuteMethod));
-&lt;/pre&gt;
+	// / Factory method for generating an FSAction object representing a
+	// StrictEquals action.
+	public static FSAction StrictEquals()
+	{
+		return actions[FSAction.StrictEquals];
+	}
 
-&lt;p&gt;Note: The FSPush class allows more than one value to be pushed onto the stack at a time. In the above examples separate FSPush objects are created to make the code a little more readable.&lt;/p&gt;
+	// Flash 7
+	// / Factory method for generating an FSAction object representing a Cast
+	// action.
+	public static FSAction Cast()
+	{
+		return actions[FSAction.Cast];
+	}
 
-*/  
-public class FSAction extends FSActionObject
-{
-    /** Type identifying the end of a sequence of actions. */
-    public static final int End              = 0;
-    /** Type identifying a NextFrame stack-based action. */
-    public static final int NextFrame        = 4;
-    /** Type identifying a PrevFrame stack-based action. */
-    public static final int PrevFrame        = 5;
-    /** Type identifying a Play stack-based action. */
-    public static final int Play             = 6;
-    /** Type identifying a Stop stack-based action. */
-    public static final int Stop             = 7;
-    /** Type identifying a ToggleQuality stack-based action. */
-    public static final int ToggleQuality    = 8;
-    /** Type identifying a StopSounds stack-based action. */
-    public static final int StopSounds       = 9;
-// Flash 4
-    /// Type identifying an IntegerAdd stack-based action.
-    public static final int IntegerAdd       = 10;
-    /// Type identifying a Subtract stack-based action.
-    public static final int Subtract         = 11;
-    /// Type identifying a Multiply stack-based action.
-    public static final int Multiply         = 12;
-    /// Type identifying a Divide stack-based action.
-    public static final int Divide           = 13;
-    /// Type identifying an IntegerEquals stack-based action.
-    public static final int IntegerEquals    = 14;
-    /// Type identifying an IntegerLess stack-based action.
-    public static final int IntegerLess      = 15;
-    /// Type identifying an And stack-based action.
-    public static final int And              = 16;
-    /// Type identifying an Or stack-based action.
-    public static final int Or               = 17;
-    /// Type identifying a Not stack-based action.
-    public static final int Not              = 18;
-    /// Type identifying a StringEquals stack-based action.
-    public static final int StringEquals     = 19;
-    /// Type identifying a StringLength stack-based action. 
-    public static final int StringLength     = 20;
-    /// Type identifying a StringExtract stack-based action.
-    public static final int StringExtract    = 21;
-    /// Type identifying a Pop stack-based action.
-    public static final int Pop              = 23;
-    /// Type identifying a ToInteger stack-based action.
-    public static final int ToInteger        = 24;
-    /// Type identifying a GetVariable stack-based action.
-    public static final int GetVariable      = 28;
-    /// Type identifying a SetVariable stack-based action.
-    public static final int SetVariable      = 29;
-    /// Type identifying a SetTarget2 stack-based action.
-    public static final int SetTarget2       = 32;
-    /// Type identifying a StringAdd stack-based action.
-    public static final int StringAdd        = 33;
-    /// Type identifying a GetProperty stack-based action.
-    public static final int GetProperty      = 34;
-    /// Type identifying a SetProperty stack-based action.
-    public static final int SetProperty      = 35;
-    /// Type identifying a CloneSprite stack-based action.
-    public static final int CloneSprite      = 36;
-    /// Type identifying a RemoveSprite stack-based action.
-    public static final int RemoveSprite     = 37;
-    /// Type identifying a Trace stack-based action.
-    public static final int Trace            = 38;
-    /// Type identifying a StartDrag stack-based action.
-    public static final int StartDrag        = 39;
-    /// Type identifying a EndDrag stack-based action.
-    public static final int EndDrag          = 40;
-    /// Type identifying a StringLess stack-based action.
-    public static final int StringLess       = 41;
-    /// Type identifying a RandomNumber stack-based action.
-    public static final int RandomNumber     = 48;
-    /// Type identifying a MBStringLength stack-based action.
-    public static final int MBStringLength   = 49;
-    /// Type identifying a CharToAscii stack-based action.
-    public static final int CharToAscii      = 50;
-    /// Type identifying a AsciiToChar stack-based action.
-    public static final int AsciiToChar      = 51;
-    /// Type identifying a GetTime stack-based action.
-    public static final int GetTime          = 52;
-    /// Type identifying an MBStringExtract stack-based action.
-    public static final int MBStringExtract  = 53;
-    /// Type identifying an MBCharToAscii stack-based action.
-    public static final int MBCharToAscii    = 54;
-    /// Type identifying an MBAsciiToChar stack-based action.
-    public static final int MBAsciiToChar    = 55;
-// Flash 5
-    /// Type identifying a DeleteVariable stack-based action.
-    public static final int DeleteVariable   = 58;
-    /// Type identifying a Delete stack-based action.
-    public static final int Delete             = 59;
-    /// Type identifying a InitVariable stack-based action.
-    public static final int InitVariable     = 60;
-    /// Type identifying a ExecuteFunction stack-based action.
-    public static final int ExecuteFunction  = 61;
-    /// Type identifying a Return stack-based action.
-    public static final int Return           = 62;
-    /// Type identifying a Modulo stack-based action.
-    public static final int Modulo             = 63;
-    /// Type identifying a NamedObject stack-based action.
-    public static final int NamedObject      = 64;
-    /// Type identifying a NewVariable stack-based action.
-    public static final int NewVariable      = 65;
-    /// Type identifying a NewArray stack-based action.
-    public static final int NewArray         = 66;
-    /// Type identifying a NewObject stack-based action.
-    public static final int NewObject        = 67;
-    /// Type identifying a GetType stack-based action.
-    public static final int GetType          = 68;
-    /// Type identifying a GetTarget stack-based action.
-    public static final int GetTarget        = 69;
-    /// Type identifying an Enumerate stack-based action.
-    public static final int Enumerate        = 70;
-    /// Type identifying an Add stack-based action.
-    public static final int Add              = 71;
-    /// Type identifying a Less stack-based action.
-    public static final int Less             = 72;
-    /// Type identifying an Equals stack-based action.
-    public static final int Equals           = 73;
-    /// Type identifying a ToNumber stack-based action.
-    public static final int ToNumber         = 74;
-    /// Type identifying a ToString stack-based action.
-    public static final int ToString         = 75;
-    /// Type identifying a Duplicate stack-based action.
-    public static final int Duplicate        = 76;
-    /// Type identifying a Swap stack-based action.
-    public static final int Swap             = 77;
-    /// Type identifying a GetAttribute stack-based action.
-    public static final int GetAttribute     = 78;
-    /// Type identifying a SetAttribute stack-based action.
-    public static final int SetAttribute     = 79;
-    /// Type identifying an Increment stack-based action.
-    public static final int Increment        = 80;
-    /// Type identifying a Decrement stack-based action.
-    public static final int Decrement        = 81;
-    /// Type identifying an ExecuteMethod stack-based action.
-    public static final int ExecuteMethod    = 82;
-    /// Type identifying a NewMethod stack-based action.
-    public static final int NewMethod        = 83;
-    /// Type identifying a BitwiseAnd stack-based action.
-    public static final int BitwiseAnd       = 96;
-    /// Type identifying a BitwiseOr stack-based action.
-    public static final int BitwiseOr        = 97;
-    /// Type identifying a BitwiseXOr stack-based action.
-    public static final int BitwiseXOr       = 98;
-    /// Type identifying a LogicalShiftLeft stack-based action.
-    public static final int LogicalShiftLeft = 99;
-    /// Type identifying an ArithmeticShiftRight stack-based action.
-    public static final int ArithmeticShiftRight = 100;
-    /// Type identifying a LogicalShiftRight stack-based action.
-    public static final int LogicalShiftRight    = 101;
-// Flash 6
-    /// Type identifying an InstanceOf stack-based action.
-    public static final int InstanceOf      = 84;
-    /// Type identifying an EnumerateObject stack-based action.
-    public static final int EnumerateObject = 85;
-    /// Type identifying a StrictEquals stack-based action.
-    public static final int StrictEquals    = 102;
-    /// Type identifying a Greater stack-based action.
-    public static final int Greater         = 103;
-    /// Type identifying a StringGreater stack-based action.
-    public static final int StringGreater   = 104;
-// Flash 7
-    /// Type identifying a Throw stack-based action.
-    public static final int Throw      = 42;
-    /// Type identifying a Cast stack-based action.
-    public static final int Cast       = 43;
-    /// Type identifying an Implements stack-based action.
-    public static final int Implements = 44;
-    /// Type identifying an Extends stack-based action.
-    public static final int Extends    = 105;
-    
-    static String[] names = {
-        &quot;End&quot;,              // 0
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;NextFrame&quot;,        // 4;
-        &quot;PrevFrame&quot;,        // 5;
-        &quot;Play&quot;,             // 6;
-        &quot;Stop&quot;,             // 7;
-        &quot;ToggleQuality&quot;,    // 8;
-        &quot;StopSounds&quot;,       // 9;
-        &quot;IntegerAdd&quot;,       // 10;
-        &quot;Subtract&quot;,         // 11;
-        &quot;Multiply&quot;,         // 12;
-        &quot;Divide&quot;,           // 13;
-        &quot;IntegerEquals&quot;,    // 14;
-        &quot;IntegerLess&quot;,      // 15;
-        &quot;And&quot;,              // 16;
-        &quot;Or&quot;,               // 17;
-        &quot;Not&quot;,              // 18;
-        &quot;StringEquals&quot;,     // 19;
-        &quot;StringLength&quot;,     // 20;
-        &quot;StringExtract&quot;,    // 21;
-        &quot;&quot;, 
-        &quot;Pop&quot;,              // 23;
-        &quot;ToInteger&quot;,        // 24;
-        &quot;&quot;,
-        &quot;&quot;, 
-        &quot;&quot;,
-        &quot;GetVariable&quot;,      // 28;
-        &quot;SetVariable&quot;,      // 29;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;SetTarget2&quot;,       // 32;
-        &quot;StringAdd&quot;,        // 33;
-        &quot;GetProperty&quot;,      // 34;
-        &quot;SetProperty&quot;,      // 35;
-        &quot;CloneSprite&quot;,      // 36;
-        &quot;RemoveSprite&quot;,     // 37;
-        &quot;Trace&quot;,            // 38;
-        &quot;StartDrag&quot;,        // 39;
-        &quot;EndDrag&quot;,          // 40;
-        &quot;StringLess&quot;,       // 41;
-        &quot;Throw&quot;,            // 42;
-        &quot;Cast&quot;,             // 43;
-        &quot;Implements&quot;,       // 44;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;RandomNumber&quot;,     // 48;
-        &quot;MBStringLength&quot;,   // 49;
-        &quot;CharToAscii&quot;,      // 50;
-        &quot;AsciiToChar&quot;,      // 51;
-        &quot;GetTime&quot;,          // 52;
-        &quot;MBStringExtract&quot;,  // 53;
-        &quot;MBCharToAscii&quot;,    // 54;
-        &quot;MBAsciiToChar&quot;,    // 55;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;DeleteVariable&quot;,   // 58;
-        &quot;Delete&quot;,            // 59;
-        &quot;InitVariable&quot;,     // 60;
-        &quot;ExecuteFunction&quot;,  // 61;
-        &quot;Return&quot;,           // 62;
-        &quot;Modulo&quot;,           // 63;
-        &quot;NamedObject&quot;,      // 64;
-        &quot;NewVariable&quot;,      // 65;
-        &quot;NewArray&quot;,         // 66;
-        &quot;NewObject&quot;,        // 67;
-        &quot;GetType&quot;,          // 68;
-        &quot;GetTarget&quot;,        // 69;
-        &quot;Enumerate&quot;,        // 70;
-        &quot;Add&quot;,              // 71;
-        &quot;Less&quot;,             // 72;
-        &quot;Equals&quot;,           // 73;
-        &quot;ToNumber&quot;,         // 74;
-        &quot;ToString&quot;,         // 75;
-        &quot;Duplicate&quot;,        // 76;
-        &quot;Swap&quot;,             // 77;
-        &quot;GetAttribute&quot;,     // 78;
-        &quot;SetAttribute&quot;,     // 79;
-        &quot;Increment&quot;,        // 80;
-        &quot;Decrement&quot;,        // 81;
-        &quot;ExecuteMethod&quot;,    // 82;
-        &quot;NewMethod&quot;,        // 83;
-        &quot;InstanceOf&quot;,       // 84;
-        &quot;EnumerateObject&quot;,  // 85;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;BitwiseAnd&quot;,           // 96;
-        &quot;BitwiseOr&quot;,            // 97;
-        &quot;BitwiseXOr&quot;,           // 98;
-        &quot;LogicalShiftLeft&quot;,     // 99;
-        &quot;ArithmeticShiftRight&quot;, // 100;
-        &quot;LogicalShiftRight&quot;,    // 101;
-        &quot;StrictEquals&quot;,         // 102;
-        &quot;Greater&quot;,              // 103;
-        &quot;StringGreater&quot;,        // 104;
-        &quot;Extends&quot;,              // 105;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,  // 127
-    };
+	// / Factory method for generating an FSAction object representing a
+	// Implements action.
+	public static FSAction Implements()
+	{
+		return actions[FSAction.Implements];
+	}
 
-    private static final FSAction[] actions = {
-        new FSAction(FSAction.End),              // 0;
-        new FSAction(1),
-        new FSAction(2),
-        new FSAction(3),
-        new FSAction(FSAction.NextFrame),        // 4;
-        new FSAction(FSAction.PrevFrame),        // 5;
-        new FSAction(FSAction.Play),             // 6;
-        new FSAction(FSAction.Stop),             // 7;
-        new FSAction(FSAction.ToggleQuality),    // 8;
-        new FSAction(FSAction.StopSounds),       // 9;
-        new FSAction(FSAction.IntegerAdd),       // 10;
-        new FSAction(FSAction.Subtract),         // 11;
-        new FSAction(FSAction.Multiply),         // 12;
-        new FSAction(FSAction.Divide),           // 13;
-        new FSAction(FSAction.IntegerEquals),    // 14;
-        new FSAction(FSAction.IntegerLess),      // 15;
-        new FSAction(FSAction.And),              // 16;
-        new FSAction(FSAction.Or),               // 17;
-        new FSAction(FSAction.Not),              // 18;
-        new FSAction(FSAction.StringEquals),     // 19;
-        new FSAction(FSAction.StringLength),     // 20;
-        new FSAction(FSAction.StringExtract),    // 21;
-        new FSAction(22), 
-        new FSAction(FSAction.Pop),              // 23;
-        new FSAction(FSAction.ToInteger),        // 24;
-        new FSAction(25),
-        new FSAction(26), 
-        new FSAction(27),
-        new FSAction(FSAction.GetVariable),      // 28;
-        new FSAction(FSAction.SetVariable),      // 29;
-        new FSAction(30),
-        new FSAction(31),
-        new FSAction(FSAction.SetTarget2),       // 32;
-        new FSAction(FSAction.StringAdd),        // 33;
-        new FSAction(FSAction.GetProperty),      // 34;
-        new FSAction(FSAction.SetProperty),      // 35;
-        new FSAction(FSAction.CloneSprite),      // 36;
-        new FSAction(FSAction.RemoveSprite),     // 37;
-        new FSAction(FSAction.Trace),            // 38;
-        new FSAction(FSAction.StartDrag),        // 39;
-        new FSAction(FSAction.EndDrag),          // 40;
-        new FSAction(FSAction.StringLess),       // 41;
-        new FSAction(FSAction.Throw),            // 42;
-        new FSAction(FSAction.Cast),             // 43;
-        new FSAction(FSAction.Implements),       // 44;
-        new FSAction(45),
-        new FSAction(46),
-        new FSAction(47),
-        new FSAction(FSAction.RandomNumber),     // 48;
-        new FSAction(FSAction.MBStringLength),   // 49;
-        new FSAction(FSAction.CharToAscii),      // 50;
-        new FSAction(FSAction.AsciiToChar),      // 51;
-        new FSAction(FSAction.GetTime),          // 52;
-        new FSAction(FSAction.MBStringExtract),  // 53;
-        new FSAction(FSAction.MBCharToAscii),    // 54;
-        new FSAction(FSAction.MBAsciiToChar),    // 55;
-        new FSAction(56),
-        new FSAction(57),
-        new FSAction(FSAction.DeleteVariable),   // 58;
-        new FSAction(FSAction.Delete),           // 59;
-        new FSAction(FSAction.InitVariable),     // 60;
-        new FSAction(FSAction.ExecuteFunction),  // 61;
-        new FSAction(FSAction.Return),           // 62;
-        new FSAction(FSAction.Modulo),           // 63;
-        new FSAction(FSAction.NamedObject),      // 64;
-        new FSAction(FSAction.NewVariable),      // 65;
-        new FSAction(FSAction.NewArray),         // 66;
-        new FSAction(FSAction.NewObject),        // 67;
-        new FSAction(FSAction.GetType),          // 68;
-        new FSAction(FSAction.GetTarget),        // 69;
-        new FSAction(FSAction.Enumerate),        // 70;
-        new FSAction(FSAction.Add),              // 71;
-        new FSAction(FSAction.Less),             // 72;
-        new FSAction(FSAction.Equals),           // 73;
-        new FSAction(FSAction.ToNumber),         // 74;
-        new FSAction(FSAction.ToString),         // 75;
-        new FSAction(FSAction.Duplicate),        // 76;
-        new FSAction(FSAction.Swap),             // 77;
-        new FSAction(FSAction.GetAttribute),     // 78;
-        new FSAction(FSAction.SetAttribute),     // 79;
-        new FSAction(FSAction.Increment),        // 80;
-        new FSAction(FSAction.Decrement),        // 81;
-        new FSAction(FSAction.ExecuteMethod),    // 82;
-        new FSAction(FSAction.NewMethod),        // 83;
-        new FSAction(FSAction.InstanceOf),       // 84;
-        new FSAction(FSAction.EnumerateObject),  // 85;
-        new FSAction(86),
-        new FSAction(87),
-        new FSAction(88),
-        new FSAction(89),
-        new FSAction(90),
-        new FSAction(91),
-        new FSAction(92),
-        new FSAction(93),
-        new FSAction(94),
-        new FSAction(95),
-        new FSAction(FSAction.BitwiseAnd),           // 96;
-        new FSAction(FSAction.BitwiseOr),            // 97;
-        new FSAction(FSAction.BitwiseXOr),           // 98;
-        new FSAction(FSAction.LogicalShiftLeft),     // 99;
-        new FSAction(FSAction.ArithmeticShiftRight), // 100;
-        new FSAction(FSAction.LogicalShiftRight),    // 101;
-        new FSAction(FSAction.StrictEquals),         // 102;
-        new FSAction(FSAction.Greater),              // 103;
-        new FSAction(FSAction.StringGreater),        // 104;
-        new FSAction(FSAction.Extends),              // 105;
-        new FSAction(106),
-        new FSAction(107),
-        new FSAction(108),
-        new FSAction(109),
-        new FSAction(110),
-        new FSAction(111),
-        new FSAction(112),
-        new FSAction(113),
-        new FSAction(114),
-        new FSAction(115),
-        new FSAction(116),
-        new FSAction(117),
-        new FSAction(118),
-        new FSAction(119),
-        new FSAction(120),
-        new FSAction(121),
-        new FSAction(122),
-        new FSAction(123),
-        new FSAction(124),
-        new FSAction(125),
-        new FSAction(126),
-        new FSAction(127),  // 127
-    };
+	// / Factory method for generating an FSAction object representing a Throw
+	// action.
+	public static FSAction Throw()
+	{
+		return actions[FSAction.Throw];
+	}
 
-    static FSAction getInstance(int type) { return actions[type]; }
+	// / Factory method for generating an FSAction object representing a Extends
+	// action.
+	public static FSAction Extends()
+	{
+		return actions[FSAction.Extends];
+	}
 
-    /** Factory method for generating an FSAction object representing the end of a sequence of actions. */
-    public static FSAction End() { return actions[FSAction.End]; }
-    /** Factory method for generating an FSAction object representing a NextFrame action. */
-    public static FSAction NextFrame() { return actions[FSAction.NextFrame]; }
-    /** Factory method for generating an FSAction object representing a PrevFrame action. */
-    public static FSAction PrevFrame() { return actions[FSAction.PrevFrame]; }
-    /** Factory method for generating an FSAction object representing a Play action. */
-    public static FSAction Play() { return actions[FSAction.Play]; }
-    /** Factory method for generating an FSAction object representing a Stop action. */
-    public static FSAction Stop() { return actions[FSAction.Stop]; }
-    /** Factory method for generating an FSAction object representing a ToggleQuality action. */
-    public static FSAction ToggleQuality() { return actions[FSAction.ToggleQuality]; }
-    /** Factory method for generating an FSAction object representing a StopSounds action. */
-    public static FSAction StopSounds() { return actions[FSAction.StopSounds]; }
-// Flash 4    
-    /// Factory method for generating an FSAction object representing a Subtract action.
-    public static FSAction Subtract() { return actions[FSAction.Subtract]; }
-    /// Factory method for generating an FSAction object representing a Multiply action.
-    public static FSAction Multiply() { return actions[FSAction.Multiply]; }
-    /// Factory method for generating an FSAction object representing a Divide action.
-    public static FSAction Divide() { return actions[FSAction.Divide]; }
-    /// Factory method for generating an FSAction object representing a And action.
-    public static FSAction And() { return actions[FSAction.And]; }
-    /// Factory method for generating an FSAction object representing a Or action.
-    public static FSAction Or() { return actions[FSAction.Or]; }
-    /// Factory method for generating an FSAction object representing a Not action.
-    public static FSAction Not() { return actions[FSAction.Not]; }
-    /// Factory method for generating an FSAction object representing a StringEquals action.
-    public static FSAction StringEquals() { return actions[FSAction.StringEquals]; }
-    /// Factory method for generating an FSAction object representing a StringLength action.
-    public static FSAction StringLength() { return actions[FSAction.StringLength]; }
-    /// Factory method for generating an FSAction object representing a StringExtract action.
-    public static FSAction StringExtract() { return actions[FSAction.StringExtract]; }
-    /// Factory method for generating an FSAction object representing a Pop action.
-    public static FSAction Pop() { return actions[FSAction.Pop]; }
-    /// Factory method for generating an FSAction object representing a ToInteger action.
-    public static FSAction ToInteger() { return actions[FSAction.ToInteger]; }
-    /// Factory method for generating an FSAction object representing a GetVariable action.
-    public static FSAction GetVariable() { return actions[FSAction.GetVariable]; }
-    /// Factory method for generating an FSAction object representing a SetVariable action.
-    public static FSAction SetVariable() { return actions[FSAction.SetVariable]; }
-    /// Factory method for generating an FSAction object representing a SetTarget2 action.
-    public static FSAction SetTarget2() { return actions[FSAction.SetTarget2]; }
-    /// Factory method for generating an FSAction object representing a StringAdd action.
-    public static FSAction StringAdd() { return actions[FSAction.StringAdd]; }
-    /// Factory method for generating an FSAction object representing a GetProperty action.
-    public static FSAction GetProperty() { return actions[FSAction.GetProperty]; }
-    /// Factory method for generating an FSAction object representing a SetProperty action.
-    public static FSAction SetProperty() { return actions[FSAction.SetProperty]; }
-    /// Factory method for generating an FSAction object representing a CloneSprite action.
-    public static FSAction CloneSprite() { return actions[FSAction.CloneSprite]; }
-    /// Factory method for generating an FSAction object representing a RemoveSprite action.
-    public static FSAction RemoveSprite() { return actions[FSAction.RemoveSprite]; }
-    /// Factory method for generating an FSAction object representing a Trace action.
-    public static FSAction Trace() { return actions[FSAction.Trace]; }
-    /// Factory method for generating an FSAction object representing a StartDrag action.
-    public static FSAction StartDrag() { return actions[FSAction.StartDrag]; }
-    /// Factory method for generating an FSAction object representing a EndDrag action.
-    public static FSAction EndDrag() { return actions[FSAction.EndDrag]; }
-    /// Factory method for generating an FSAction object representing a StringLess action.
-    public static FSAction StringLess() { return actions[FSAction.StringLess]; }
-    /// Factory method for generating an FSAction object representing a RandomNumber action.
-    public static FSAction RandomNumber() { return actions[FSAction.RandomNumber]; }
-    /// Factory method for generating an FSAction object representing a MBStringLength action.
-    public static FSAction MBStringLength() { return actions[FSAction.MBStringLength]; }
-    /// Factory method for generating an FSAction object representing a CharToAscii action.
-    public static FSAction CharToAscii() { return actions[FSAction.CharToAscii]; }
-    /// Factory method for generating an FSAction object representing a AsciiToChar action.
-    public static FSAction AsciiToChar() { return actions[FSAction.AsciiToChar]; }
-    /// Factory method for generating an FSAction object representing a GetTime action.
-    public static FSAction GetTime() { return actions[FSAction.GetTime]; }
-    /// Factory method for generating an FSAction object representing a MBStringExtract action.
-    public static FSAction MBStringExtract() { return actions[FSAction.MBStringExtract]; }
-    /// Factory method for generating an FSAction object representing a MBCharToAscii action.
-    public static FSAction MBCharToAscii() { return actions[FSAction.MBCharToAscii]; }
-    /// Factory method for generating an FSAction object representing a MBAsciiToChar action.
-    public static FSAction MBAsciiToChar() { return actions[FSAction.MBAsciiToChar]; }
-// Flash 5
-    /// Factory method for generating an FSAction object representing a DeleteVariable action.
-    public static FSAction DeleteVariable() { return actions[FSAction.DeleteVariable]; }
-    /// Factory method for generating an FSAction object representing a Delete action.
-    public static FSAction Delete() { return actions[FSAction.Delete]; }
-    /// Factory method for generating an FSAction object representing a InitVariable action.
-    public static FSAction InitVariable() { return actions[FSAction.InitVariable]; }
-    /// Factory method for generating an FSAction object representing a ExecuteFunction action.
-    public static FSAction ExecuteFunction() { return actions[FSAction.ExecuteFunction]; }
-    /// Factory method for generating an FSAction object representing a Return action.
-    public static FSAction Return() { return actions[FSAction.Return]; }
-    /// Factory method for generating an FSAction object representing a Modulo action.
-    public static FSAction Modulo() { return actions[FSAction.Modulo]; }
-    /// Factory method for generating an FSAction object representing a NamedObject action.
-    public static FSAction NamedObject() { return actions[FSAction.NamedObject]; }
-    /// Factory method for generating an FSAction object representing a NewVariable action.
-    public static FSAction NewVariable() { return actions[FSAction.NewVariable]; }
-    /// Factory method for generating an FSAction object representing a NewArray action.
-    public static FSAction NewArray() { return actions[FSAction.NewArray]; }
-    /// Factory method for generating an FSAction object representing a NewObject action.
-    public static FSAction NewObject() { return actions[FSAction.NewObject]; }
-    /// Factory method for generating an FSAction object representing a GetType action.
-    public static FSAction GetType() { return actions[FSAction.GetType]; }
-    /// Factory method for generating an FSAction object representing a GetTarget action.
-    public static FSAction GetTarget() { return actions[FSAction.GetTarget]; }
-    /// Factory method for generating an FSAction object representing a Enumerate action.
-    public static FSAction Enumerate() { return actions[FSAction.Enumerate]; }
-    /// Factory method for generating an FSAction object representing a Add action.
-    public static FSAction Add() { return actions[FSAction.Add]; }
-    /// Factory method for generating an FSAction object representing a Less action.
-    public static FSAction Less() { return actions[FSAction.Less]; }
-    /// Factory method for generating an FSAction object representing a Equals action.
-    public static FSAction Equals() { return actions[FSAction.Equals]; }
-    /// Factory method for generating an FSAction object representing a ToNumber action.
-    public static FSAction ToNumber() { return actions[FSAction.ToNumber]; }
-    /// Factory method for generating an FSAction object representing a ToString action.
-    public static FSAction ToString() { return actions[FSAction.ToString]; }
-    /// Factory method for generating an FSAction object representing a Duplicate action.
-    public static FSAction Duplicate() { return actions[FSAction.Duplicate]; }
-    /// Factory method for generating an FSAction object representing a Swap action.
-    public static FSAction Swap() { return actions[FSAction.Swap]; }
-    /// Factory method for generating an FSAction object representing a GetAttribute action.
-    public static FSAction GetAttribute() { return actions[FSAction.GetAttribute]; }
-    /// Factory method for generating an FSAction object representing a SetAttribute action.
-    public static FSAction SetAttribute() { return actions[FSAction.SetAttribute]; }
-    /// Factory method for generating an FSAction object representing a Increment action.
-    public static FSAction Increment() { return actions[FSAction.Increment]; }
-    /// Factory method for generating an FSAction object representing a Decrement action.
-    public static FSAction Decrement() { return actions[FSAction.Decrement]; }
-    /// Factory method for generating an FSAction object representing a ExecuteMethod action.
-    public static FSAction ExecuteMethod() { return actions[FSAction.ExecuteMethod]; }
-    /// Factory method for generating an FSAction object representing a NewMethod action.
-    public static FSAction NewMethod() { return actions[FSAction.NewMethod]; }
-    /// Factory method for generating an FSAction object representing a BitwiseAnd action.
-    public static FSAction BitwiseAnd() { return actions[FSAction.BitwiseAnd]; }
-    /// Factory method for generating an FSAction object representing a BitwiseOr action.
-    public static FSAction BitwiseOr() { return actions[FSAction.BitwiseOr]; }
-    /// Factory method for generating an FSAction object representing a BitwiseXOr action.
-    public static FSAction BitwiseXOr() { return actions[FSAction.BitwiseXOr]; }
-    /// Factory method for generating an FSAction object representing a LogicalShiftLeft action.
-    public static FSAction LogicalShiftLeft() { return actions[FSAction.LogicalShiftLeft]; }
-    /// Factory method for generating an FSAction object representing a ArithmeticShiftRight action.
-    public static FSAction ArithmeticShiftRight() { return actions[FSAction.ArithmeticShiftRight]; }
-    /// Factory method for generating an FSAction object representing a LogicalShiftRight action.
-    public static FSAction LogicalShiftRight() { return actions[FSAction.LogicalShiftRight]; }
-// Flash 6
-    /// Factory method for generating an FSAction object representing a InstanceOf action.
-    public static FSAction InstanceOf() { return actions[FSAction.InstanceOf]; }
-    /// Factory method for generating an FSAction object representing a EnumerateObject action.
-    public static FSAction EnumerateObject() { return actions[FSAction.EnumerateObject]; }
-    /// Factory method for generating an FSAction object representing a Greater action.
-    public static FSAction Greater() { return actions[FSAction.Greater]; }
-    /// Factory method for generating an FSAction object representing a StringGreater action.
-    public static FSAction StringGreater() { return actions[FSAction.StringGreater]; }
-    /// Factory method for generating an FSAction object representing a StrictEquals action.
-    public static FSAction StrictEquals() { return actions[FSAction.StrictEquals]; }
-// Flash 7
-    /// Factory method for generating an FSAction object representing a Cast action.
-    public static FSAction Cast() { return actions[FSAction.Cast]; }
-    /// Factory method for generating an FSAction object representing a Implements action.
-    public static FSAction Implements() { return actions[FSAction.Implements]; }
-    /// Factory method for generating an FSAction object representing a Throw action.
-    public static FSAction Throw() { return actions[FSAction.Throw]; }
-    /// Factory method for generating an FSAction object representing a Extends action.
-    public static FSAction Extends() { return actions[FSAction.Extends]; }
-    
-    /**
-     * Construct an FSAction object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSAction(FSCoder coder)
-    {
-        super(0);
-        decode(coder);
-    }
-    /** 
-     * Constructs a stack-based action with the specified type.
-     * 
-     * @param aType the code used to denote the type of action performed.
-     */
-    public FSAction(int aType)
-    {
-        super(aType);
-    }
-    /**
-     * Constructs an FSAction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSAction object.
-     */
-    public FSAction(FSAction obj)
-    {
-        super(obj);
-    }    
-    /**
-     * Returns a string identifying the type of stack-based action that the 
-     * object represents.
-     * 
-     * @return a string containing the name of the action.
-     */
-    public String name()
-    {
-        return names[type];
-    }
+	/**
+	 * Construct an FSAction object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSAction(FSCoder coder)
+	{
+		super(0);
+		decode(coder);
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        coder.endObject(name());
-    }
+	/**
+	 * Constructs a stack-based action with the specified type.
+	 * 
+	 * @param aType
+	 *            the code used to denote the type of action performed.
+	 */
+	public FSAction(int aType)
+	{
+		super(aType);
+	}
+
+	/**
+	 * Constructs an FSAction object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSAction object.
+	 */
+	public FSAction(FSAction obj)
+	{
+		super(obj);
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSActionObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSActionObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSActionObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -30,146 +30,892 @@
 
 package com.flagstone.transform;
 
-/** The FSActionObject is a base class for the classes that represent the different types 
- * of actions defined in the Flash file format specification. The function of the class 
- * is the same as the FSMovieObject class however the format of the encoded binary data 
- * is different.
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+
+/**
+ * The FSActionObject is a base class for the classes that represent the
+ * different types of actions defined in the Flash file format specification.
+ * The function of the class is the same as the FSMovieObject class however the
+ * format of the encoded binary data is different.
  * 
- * This class is primarily used internally in the library however the getType() method is 
- * useful when manipulating decoded Flash files. Rather than use run-time type inspection 
- * provided by the programming environment the method can be used to identify the action that a 
- * given object represents. The getType() method is essential when examining FSAction objects
- * which represent a large number byte-codes which perform stack-based operations such as 
- * add, subtract, etc.
+ * This class is primarily used internally in the library however the getType()
+ * method is useful when manipulating decoded Flash files. Rather than use
+ * run-time type inspection provided by the programming environment the method
+ * can be used to identify the action that a given object represents. The
+ * getType() method is essential when examining FSAction objects which represent
+ * a large number byte-codes which perform stack-based operations such as add,
+ * subtract, etc.
  */
-public abstract class FSActionObject extends FSTransformObject
+public abstract class FSActionObject implements Cloneable, Codeable
 {
-    /** Type identifying a GotoFrame action. */
-    public static final int GotoFrame     = 129;
-    /** Type identifying a GetUrl action. */
-    public static final int GetUrl        = 131;
-// Flash 3
-    /// Type identifying a WaitForFrame action.
-    public static final int WaitForFrame  = 138;
-    /// Type identifying a SetTarget action.
-    public static final int SetTarget     = 139;
-    /// Type identifying a GotoLabel action.
-    public static final int GotoLabel     = 140;
-// Flash 4
-    /// Type identifying a WaitForFrame2 action.
-    public static final int WaitForFrame2 = 141;
-    /// Type identifying a Push action.
-    public static final int Push          = 150;
-    /// Type identifying a Jump action.
-    public static final int Jump          = 153;
-    /// Type identifying a GetUrl2 action.
-    public static final int GetUrl2       = 154;
-    /// Type identifying an If action.
-    public static final int If            = 157;
-    /// Type identifying a Call action.
-    public static final int Call          = 158;
-    /// Type identifying a GotoFrame2 action.
-    public static final int GotoFrame2    = 159;
-// Flash 5
-    /// Type identifying a RegisterCopy action.
-    public static final int RegisterCopy  = 135;
-    /// Type identifying a Table action.
-    public static final int Table         = 136;
-    /// Type identifying a With action.
-    public static final int With          = 148;
-    /// Type identifying a NewFunction action.
-    public static final int NewFunction   = 155;
-// Flash 7
-    /// Type identifying a NewFunction2 action.
-    public static final int NewFunction2     = 142;
-    /// Type identifying a ExceptionHandler action.
-    public static final int ExceptionHandler = 143;
+	/** Type identifying the end of a sequence of actions. */
+	public static final int End = 0;
 
-    protected int type = 0;
-    protected int length = 0;
-    
-    protected FSActionObject(int aType)
-    {
-        type = aType;
-    }
-    protected FSActionObject(FSActionObject obj)
-    {
-        type = obj.type;
-        length = obj.length;
-    }  
-    /** Gets the code used that identifies the type of the action when it is encoded. 
+	/** Type identifying a NextFrame stack-based action. */
+	public static final int NextFrame = 4;
 
-        @return the code used to denote the type of action performed.
-        */
-    public int getType() 
-    {
-        return type;
-    }
+	/** Type identifying a PrevFrame stack-based action. */
+	public static final int PrevFrame = 5;
 
-    int getLength() 
-    {
-        return length;
-    }
-    
-    /**
-     * Length is used to calculate the then of the action when it is encoded to 
-     * the binary Flash file format. This method can be used to calculate the size 
-     * of offsets and jumps for FSIf and FSJump actions.
-     *
-     * @return the length of the encoded action in bytes.
-     */
-    public int length()
-    {
-        int encodedLength = (type &gt; 128) ? 3 : 1;
-        
-        encodedLength += length(new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]));
-        
-        return encodedLength;
-    }
+	/** Type identifying a Play stack-based action. */
+	public static final int Play = 6;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false; 
-        
-        if (super.equals(anObject))
-        {
-            result = type == ((FSActionObject)anObject).type;
-        }
-        return result;
-    }
+	/** Type identifying a Stop stack-based action. */
+	public static final int Stop = 7;
 
-    public int length(FSCoder coder)
-    {
-        length = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
-        coder.writeWord(type, 1);
+	/** Type identifying a ToggleQuality stack-based action. */
+	public static final int ToggleQuality = 8;
 
-        if (type &gt;= 128)
-            coder.writeWord(length, 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        coder.beginObject(name());
-        
-        type = coder.readWord(1, false);
-        
-        if (type &gt;= 128)
-            length = coder.readWord(2, false);
-        else
-            length = 0;
-    }
+	/** Type identifying a StopSounds stack-based action. */
+	public static final int StopSounds = 9;
+
+	// Flash 4
+	// / Type identifying an IntegerAdd stack-based action.
+	public static final int IntegerAdd = 10;
+
+	// / Type identifying a Subtract stack-based action.
+	public static final int Subtract = 11;
+
+	// / Type identifying a Multiply stack-based action.
+	public static final int Multiply = 12;
+
+	// / Type identifying a Divide stack-based action.
+	public static final int Divide = 13;
+
+	// / Type identifying an IntegerEquals stack-based action.
+	public static final int IntegerEquals = 14;
+
+	// / Type identifying an IntegerLess stack-based action.
+	public static final int IntegerLess = 15;
+
+	// / Type identifying an And stack-based action.
+	public static final int And = 16;
+
+	// / Type identifying an Or stack-based action.
+	public static final int Or = 17;
+
+	// / Type identifying a Not stack-based action.
+	public static final int Not = 18;
+
+	// / Type identifying a StringEquals stack-based action.
+	public static final int StringEquals = 19;
+
+	// / Type identifying a StringLength stack-based action.
+	public static final int StringLength = 20;
+
+	// / Type identifying a StringExtract stack-based action.
+	public static final int StringExtract = 21;
+
+	// / Type identifying a Pop stack-based action.
+	public static final int Pop = 23;
+
+	// / Type identifying a ToInteger stack-based action.
+	public static final int ToInteger = 24;
+
+	// / Type identifying a GetVariable stack-based action.
+	public static final int GetVariable = 28;
+
+	// / Type identifying a SetVariable stack-based action.
+	public static final int SetVariable = 29;
+
+	// / Type identifying a SetTarget2 stack-based action.
+	public static final int SetTarget2 = 32;
+
+	// / Type identifying a StringAdd stack-based action.
+	public static final int StringAdd = 33;
+
+	// / Type identifying a GetProperty stack-based action.
+	public static final int GetProperty = 34;
+
+	// / Type identifying a SetProperty stack-based action.
+	public static final int SetProperty = 35;
+
+	// / Type identifying a CloneSprite stack-based action.
+	public static final int CloneSprite = 36;
+
+	// / Type identifying a RemoveSprite stack-based action.
+	public static final int RemoveSprite = 37;
+
+	// / Type identifying a Trace stack-based action.
+	public static final int Trace = 38;
+
+	// / Type identifying a StartDrag stack-based action.
+	public static final int StartDrag = 39;
+
+	// / Type identifying a EndDrag stack-based action.
+	public static final int EndDrag = 40;
+
+	// / Type identifying a StringLess stack-based action.
+	public static final int StringLess = 41;
+
+	// / Type identifying a RandomNumber stack-based action.
+	public static final int RandomNumber = 48;
+
+	// / Type identifying a MBStringLength stack-based action.
+	public static final int MBStringLength = 49;
+
+	// / Type identifying a CharToAscii stack-based action.
+	public static final int CharToAscii = 50;
+
+	// / Type identifying a AsciiToChar stack-based action.
+	public static final int AsciiToChar = 51;
+
+	// / Type identifying a GetTime stack-based action.
+	public static final int GetTime = 52;
+
+	// / Type identifying an MBStringExtract stack-based action.
+	public static final int MBStringExtract = 53;
+
+	// / Type identifying an MBCharToAscii stack-based action.
+	public static final int MBCharToAscii = 54;
+
+	// / Type identifying an MBAsciiToChar stack-based action.
+	public static final int MBAsciiToChar = 55;
+
+	// Flash 5
+	// / Type identifying a DeleteVariable stack-based action.
+	public static final int DeleteVariable = 58;
+
+	// / Type identifying a Delete stack-based action.
+	public static final int Delete = 59;
+
+	// / Type identifying a InitVariable stack-based action.
+	public static final int InitVariable = 60;
+
+	// / Type identifying a ExecuteFunction stack-based action.
+	public static final int ExecuteFunction = 61;
+
+	// / Type identifying a Return stack-based action.
+	public static final int Return = 62;
+
+	// / Type identifying a Modulo stack-based action.
+	public static final int Modulo = 63;
+
+	// / Type identifying a NamedObject stack-based action.
+	public static final int NamedObject = 64;
+
+	// / Type identifying a NewVariable stack-based action.
+	public static final int NewVariable = 65;
+
+	// / Type identifying a NewArray stack-based action.
+	public static final int NewArray = 66;
+
+	// / Type identifying a NewObject stack-based action.
+	public static final int NewObject = 67;
+
+	// / Type identifying a GetType stack-based action.
+	public static final int GetType = 68;
+
+	// / Type identifying a GetTarget stack-based action.
+	public static final int GetTarget = 69;
+
+	// / Type identifying an Enumerate stack-based action.
+	public static final int Enumerate = 70;
+
+	// / Type identifying an Add stack-based action.
+	public static final int Add = 71;
+
+	// / Type identifying a Less stack-based action.
+	public static final int Less = 72;
+
+	// / Type identifying an Equals stack-based action.
+	public static final int Equals = 73;
+
+	// / Type identifying a ToNumber stack-based action.
+	public static final int ToNumber = 74;
+
+	// / Type identifying a ToString stack-based action.
+	public static final int ToString = 75;
+
+	// / Type identifying a Duplicate stack-based action.
+	public static final int Duplicate = 76;
+
+	// / Type identifying a Swap stack-based action.
+	public static final int Swap = 77;
+
+	// / Type identifying a GetAttribute stack-based action.
+	public static final int GetAttribute = 78;
+
+	// / Type identifying a SetAttribute stack-based action.
+	public static final int SetAttribute = 79;
+
+	// / Type identifying an Increment stack-based action.
+	public static final int Increment = 80;
+
+	// / Type identifying a Decrement stack-based action.
+	public static final int Decrement = 81;
+
+	// / Type identifying an ExecuteMethod stack-based action.
+	public static final int ExecuteMethod = 82;
+
+	// / Type identifying a NewMethod stack-based action.
+	public static final int NewMethod = 83;
+
+	// / Type identifying a BitwiseAnd stack-based action.
+	public static final int BitwiseAnd = 96;
+
+	// / Type identifying a BitwiseOr stack-based action.
+	public static final int BitwiseOr = 97;
+
+	// / Type identifying a BitwiseXOr stack-based action.
+	public static final int BitwiseXOr = 98;
+
+	// / Type identifying a LogicalShiftLeft stack-based action.
+	public static final int LogicalShiftLeft = 99;
+
+	// / Type identifying an ArithmeticShiftRight stack-based action.
+	public static final int ArithmeticShiftRight = 100;
+
+	// / Type identifying a LogicalShiftRight stack-based action.
+	public static final int LogicalShiftRight = 101;
+
+	// Flash 6
+	// / Type identifying an InstanceOf stack-based action.
+	public static final int InstanceOf = 84;
+
+	// / Type identifying an EnumerateObject stack-based action.
+	public static final int EnumerateObject = 85;
+
+	// / Type identifying a StrictEquals stack-based action.
+	public static final int StrictEquals = 102;
+
+	// / Type identifying a Greater stack-based action.
+	public static final int Greater = 103;
+
+	// / Type identifying a StringGreater stack-based action.
+	public static final int StringGreater = 104;
+
+	// Flash 7
+	// / Type identifying a Throw stack-based action.
+	public static final int Throw = 42;
+
+	// / Type identifying a Cast stack-based action.
+	public static final int Cast = 43;
+
+	// / Type identifying an Implements stack-based action.
+	public static final int Implements = 44;
+
+	// / Type identifying an Extends stack-based action.
+	public static final int Extends = 105;
+
+	/** Type identifying a GotoFrame action. */
+	public static final int GotoFrame = 129;
+
+	/** Type identifying a GetUrl action. */
+	public static final int GetUrl = 131;
+
+	// Flash 3
+	// / Type identifying a WaitForFrame action.
+	public static final int WaitForFrame = 138;
+
+	// / Type identifying a SetTarget action.
+	public static final int SetTarget = 139;
+
+	// / Type identifying a GotoLabel action.
+	public static final int GotoLabel = 140;
+
+	// Flash 4
+	// / Type identifying a WaitForFrame2 action.
+	public static final int WaitForFrame2 = 141;
+
+	// / Type identifying a Push action.
+	public static final int Push = 150;
+
+	// / Type identifying a Jump action.
+	public static final int Jump = 153;
+
+	// / Type identifying a GetUrl2 action.
+	public static final int GetUrl2 = 154;
+
+	// / Type identifying an If action.
+	public static final int If = 157;
+
+	// / Type identifying a Call action.
+	public static final int Call = 158;
+
+	// / Type identifying a GotoFrame2 action.
+	public static final int GotoFrame2 = 159;
+
+	// Flash 5
+	// / Type identifying a RegisterCopy action.
+	public static final int RegisterCopy = 135;
+
+	// / Type identifying a Table action.
+	public static final int Table = 136;
+
+	// / Type identifying a With action.
+	public static final int With = 148;
+
+	// / Type identifying a NewFunction action.
+	public static final int NewFunction = 155;
+
+	// Flash 7
+	// / Type identifying a NewFunction2 action.
+	public static final int NewFunction2 = 142;
+
+	// / Type identifying a ExceptionHandler action.
+	public static final int ExceptionHandler = 143;
+
+	static String[] name =
+	{
+		&quot;End&quot;, // 0
+		&quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;NextFrame&quot;, // 4;
+		&quot;PrevFrame&quot;, // 5;
+		&quot;Play&quot;, // 6;
+		&quot;Stop&quot;, // 7;
+		&quot;ToggleQuality&quot;, // 8;
+		&quot;StopSounds&quot;, // 9;
+		&quot;IntegerAdd&quot;, // 10;
+		&quot;Subtract&quot;, // 11;
+		&quot;Multiply&quot;, // 12;
+		&quot;Divide&quot;, // 13;
+		&quot;IntegerEquals&quot;, // 14;
+		&quot;IntegerLess&quot;, // 15;
+		&quot;And&quot;, // 16;
+		&quot;Or&quot;, // 17;
+		&quot;Not&quot;, // 18;
+		&quot;StringEquals&quot;, // 19;
+		&quot;StringLength&quot;, // 20;
+		&quot;StringExtract&quot;, // 21;
+		&quot;&quot;,
+		&quot;Pop&quot;, // 23;
+		&quot;ToInteger&quot;, // 24;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;GetVariable&quot;, // 28;
+		&quot;SetVariable&quot;, // 29;
+		&quot;&quot;, &quot;&quot;,
+		&quot;SetTarget2&quot;, // 32;
+		&quot;StringAdd&quot;, // 33;
+		&quot;GetProperty&quot;, // 34;
+		&quot;SetProperty&quot;, // 35;
+		&quot;CloneSprite&quot;, // 36;
+		&quot;RemoveSprite&quot;, // 37;
+		&quot;Trace&quot;, // 38;
+		&quot;StartDrag&quot;, // 39;
+		&quot;EndDrag&quot;, // 40;
+		&quot;StringLess&quot;, // 41;
+		&quot;Throw&quot;, // 42;
+		&quot;Cast&quot;, // 43;
+		&quot;Implements&quot;, // 44;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;RandomNumber&quot;, // 48;
+		&quot;MBStringLength&quot;, // 49;
+		&quot;CharToAscii&quot;, // 50;
+		&quot;AsciiToChar&quot;, // 51;
+		&quot;GetTime&quot;, // 52;
+		&quot;MBStringExtract&quot;, // 53;
+		&quot;MBCharToAscii&quot;, // 54;
+		&quot;MBAsciiToChar&quot;, // 55;
+		&quot;&quot;, &quot;&quot;,
+		&quot;DeleteVariable&quot;, // 58;
+		&quot;Delete&quot;, // 59;
+		&quot;InitVariable&quot;, // 60;
+		&quot;ExecuteFunction&quot;, // 61;
+		&quot;Return&quot;, // 62;
+		&quot;Modulo&quot;, // 63;
+		&quot;NamedObject&quot;, // 64;
+		&quot;NewVariable&quot;, // 65;
+		&quot;NewArray&quot;, // 66;
+		&quot;NewObject&quot;, // 67;
+		&quot;GetType&quot;, // 68;
+		&quot;GetTarget&quot;, // 69;
+		&quot;Enumerate&quot;, // 70;
+		&quot;Add&quot;, // 71;
+		&quot;Less&quot;, // 72;
+		&quot;Equals&quot;, // 73;
+		&quot;ToNumber&quot;, // 74;
+		&quot;ToString&quot;, // 75;
+		&quot;Duplicate&quot;, // 76;
+		&quot;Swap&quot;, // 77;
+		&quot;GetAttribute&quot;, // 78;
+		&quot;SetAttribute&quot;, // 79;
+		&quot;Increment&quot;, // 80;
+		&quot;Decrement&quot;, // 81;
+		&quot;ExecuteMethod&quot;, // 82;
+		&quot;NewMethod&quot;, // 83;
+		&quot;InstanceOf&quot;, // 84;
+		&quot;EnumerateObject&quot;, // 85;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;BitwiseAnd&quot;, // 96;
+		&quot;BitwiseOr&quot;, // 97;
+		&quot;BitwiseXOr&quot;, // 98;
+		&quot;LogicalShiftLeft&quot;, // 99;
+		&quot;ArithmeticShiftRight&quot;, // 100;
+		&quot;LogicalShiftRight&quot;, // 101;
+		&quot;StrictEquals&quot;, // 102;
+		&quot;Greater&quot;, // 103;
+		&quot;StringGreater&quot;, // 104;
+		&quot;Extends&quot;, // 105;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, // 127
+	};
+
+	static FSActionObject decodeAction(FSCoder coder)
+	{
+		FSActionObject anAction = null;
+
+		int objStart = coder.getPointer();
+		int type = coder.scanWord(1, false);
+		int length = 0;
+		int start = coder.getPointer() + 8;
+		int next = start;
+
+		if (type &gt; 128)
+		{
+			coder.adjustPointer(8);
+			length = coder.scanWord(2, false);
+			start = coder.getPointer() + 16;
+			next = start + (length &lt;&lt; 3);
+			coder.adjustPointer(-8);
+		}
+
+		switch (type)
+		{
+			case FSAction.End:
+			case FSAction.NextFrame:
+			case FSAction.PrevFrame:
+			case FSAction.Play:
+			case FSAction.Stop:
+			case FSAction.ToggleQuality:
+			case FSAction.StopSounds:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.GetUrl:
+				anAction = new FSGetUrl(coder);
+				break;
+			// Flash 3
+			case FSActionObject.GotoFrame:
+				anAction = new FSGotoFrame(coder);
+				break;
+			// Flash 4
+			case FSActionObject.GotoLabel:
+				anAction = new FSGotoLabel(coder);
+				break;
+			case FSActionObject.SetTarget:
+				anAction = new FSSetTarget(coder);
+				break;
+			case FSActionObject.WaitForFrame:
+				anAction = new FSWaitForFrame(coder);
+				break;
+			case FSAction.IntegerAdd:
+			case FSAction.Subtract:
+			case FSAction.IntegerEquals:
+			case FSAction.IntegerLess:
+			case FSAction.Multiply:
+			case FSAction.Divide:
+			case FSAction.And:
+			case FSAction.Or:
+			case FSAction.Not:
+			case FSAction.StringEquals:
+			case FSAction.StringLength:
+			case FSAction.StringExtract:
+			case FSAction.Pop:
+			case FSAction.ToInteger:
+			case FSAction.GetVariable:
+			case FSAction.SetVariable:
+			case FSAction.SetTarget2:
+			case FSAction.StringAdd:
+			case FSAction.GetProperty:
+			case FSAction.SetProperty:
+			case FSAction.CloneSprite:
+			case FSAction.RemoveSprite:
+			case FSAction.Trace:
+			case FSAction.StartDrag:
+			case FSAction.EndDrag:
+			case FSAction.StringLess:
+			case FSAction.RandomNumber:
+			case FSAction.MBStringLength:
+			case FSAction.CharToAscii:
+			case FSAction.AsciiToChar:
+			case FSAction.GetTime:
+			case FSAction.MBStringExtract:
+			case FSAction.MBCharToAscii:
+			case FSAction.MBAsciiToChar:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.Call:
+				anAction = FSCall.getInstance();
+				coder.setPointer(next);
+				break;
+			case FSActionObject.Push:
+				anAction = new FSPush(coder);
+				break;
+			case FSActionObject.WaitForFrame2:
+				anAction = new FSWaitForFrame2(coder);
+				break;
+			case FSActionObject.Jump:
+				anAction = new FSJump(coder);
+				break;
+			case FSActionObject.If:
+				anAction = new FSIf(coder);
+				break;
+			case FSActionObject.GetUrl2:
+				anAction = new FSGetUrl2(coder);
+				break;
+			case FSActionObject.GotoFrame2:
+				anAction = new FSGotoFrame2(coder);
+				break;
+			// Flash 5
+			case FSAction.Add:
+			case FSAction.Equals:
+			case FSAction.Less:
+			case FSAction.Modulo:
+			case FSAction.Enumerate:
+			case FSAction.Duplicate:
+			case FSAction.Swap:
+			case FSAction.ExecuteMethod:
+			case FSAction.NewMethod:
+			case FSAction.ExecuteFunction:
+			case FSAction.GetAttribute:
+			case FSAction.SetAttribute:
+			case FSAction.Increment:
+			case FSAction.Decrement:
+			case FSAction.LogicalShiftLeft:
+			case FSAction.LogicalShiftRight:
+			case FSAction.ArithmeticShiftRight:
+			case FSAction.BitwiseAnd:
+			case FSAction.BitwiseOr:
+			case FSAction.BitwiseXOr:
+			case FSAction.NamedObject:
+			case FSAction.NewArray:
+			case FSAction.NewObject:
+			case FSAction.DeleteVariable:
+			case FSAction.Delete:
+			case FSAction.Return:
+			case FSAction.ToNumber:
+			case FSAction.ToString:
+			case FSAction.GetType:
+			case FSAction.GetTarget:
+			case FSAction.NewVariable:
+			case FSAction.InitVariable:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.Table:
+				anAction = new FSTable(coder);
+				length = anAction.length;
+				next = start + (length &lt;&lt; 3);
+				break;
+			case FSActionObject.RegisterCopy:
+				anAction = new FSRegisterCopy(coder);
+				break;
+			case FSActionObject.NewFunction:
+				anAction = new FSNewFunction(coder);
+				length = anAction.length;
+				next = start + (length &lt;&lt; 3);
+				break;
+			case FSActionObject.With:
+				anAction = new FSWith(coder);
+				length = anAction.length;
+				next = start + (length &lt;&lt; 3);
+				break;
+			// Flash 6
+			case FSAction.InstanceOf:
+			case FSAction.EnumerateObject:
+			case FSAction.Greater:
+			case FSAction.StringGreater:
+			case FSAction.StrictEquals:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			// Flash 7
+			case FSAction.Cast:
+			case FSAction.Extends:
+			case FSAction.Implements:
+			case FSAction.Throw:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.ExceptionHandler:
+				anAction = new FSExceptionHandler(coder);
+				break;
+			case FSActionObject.NewFunction2:
+				anAction = new FSNewFunction2(coder);
+				length = anAction.length;
+				next = start + (length &lt;&lt; 3);
+				break;
+			default:
+				Integer key = new Integer(type);
+
+				if (table.containsKey(key))
+				{
+					try
+					{
+						Class&lt;FSActionObject&gt; obj = table.get(key);
+						anAction = (FSActionObject) obj.newInstance();
+						anAction.decode(coder);
+						length = anAction.length;
+						next = start + (length &lt;&lt; 3);
+					} catch (Exception e)
+					{
+						anAction = new FSUnknownAction(coder);
+					}
+				} else
+				{
+					anAction = new FSUnknownAction(coder);
+				}
+				break;
+		}
+
+		int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+		if (delta != 0)
+		{
+			coder.context[FSCoder.CodingError] = 1;
+			coder.context[FSCoder.TypeInError] = anAction.getType();
+			coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+			coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+			coder.context[FSCoder.Delta] = delta;
+		}
+
+		coder.setPointer(next);
+
+		return anAction;
+	}
+
+	static ArrayList&lt;FSActionObject&gt; decodeActions(byte[] encodedActions)
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, encodedActions);
+		int length = encodedActions.length;
+
+		return decodeActions(coder, length);
+	}
+
+	static ArrayList&lt;FSActionObject&gt; decodeActions(FSCoder coder, int length)
+	{
+		ArrayList&lt;FSActionObject&gt; array = new ArrayList&lt;FSActionObject&gt;();
+		int start;
+
+		while (length &gt; 0)
+		{
+			start = coder.getPointer();
+			array.add(decodeAction(coder));
+			length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+		}
+		return array;
+	}
+
+	static void encode(FSCoder coder, ArrayList&lt;FSActionObject&gt; array)
+	{
+		if (array != null)
+		{
+			FSActionObject action;
+			int start;
+			int next;
+			int delta;
+
+			for (Iterator&lt;FSActionObject&gt; i = array.iterator(); i.hasNext();)
+			{
+				action = i.next();
+
+				start = coder.getPointer();
+				next = start + ((action.getType() &gt; 128) ? 24 : 8);
+				next = next + (action.getLength() &lt;&lt; 3);
+
+				action.encode(coder);
+
+				delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = start &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - start) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+				coder.setPointer(next);
+			}
+		}
+	}
+
+	static ArrayList&lt;FSActionObject&gt; copy(ArrayList&lt;FSActionObject&gt; array)
+	{
+		ArrayList&lt;FSActionObject&gt; copy = null;
+
+		if (array != null)
+		{
+			copy = new ArrayList&lt;FSActionObject&gt;(array.size());
+
+			for (Iterator&lt;FSActionObject&gt; i = array.iterator(); i.hasNext();)
+				copy.add((FSActionObject) i.next().clone());
+		}
+		return copy;
+	}
+
+	static int length(ArrayList&lt;FSActionObject&gt; array)
+	{
+		int length = 0;
+		FSActionObject action;
+
+		if (array != null)
+		{
+			for (Iterator&lt;FSActionObject&gt; i = array.iterator(); i.hasNext();)
+			{
+				action = i.next();
+
+				length += action.getLength();
+				length += (action.getType() &gt; 128) ? 3 : 1;
+			}
+		}
+		return length;
+	}
+
+	private static HashMap&lt;Integer, Class&lt;FSActionObject&gt;&gt; table = new HashMap&lt;Integer, Class&lt;FSActionObject&gt;&gt;();
+
+	/**
+	 * This method allows you to extend the Transform framework by adding new
+	 * classes to decode the actions that are not currently supported.
+	 * 
+	 * To add support for a new action simply sub-class FSActionObject and
+	 * implement the following methods:
+	 * 
+	 * public int length(FSCoder coder) public void encode(FSCoder coder) public
+	 * void decode(FSCoder coder)
+	 * 
+	 * In addition you must implement the nullary or empty constructor so that
+	 * the object can be instantiated correctly.
+	 * 
+	 * When the an object encounters an action it does not support it will use
+	 * the type to perform a table lookup for any registered class. If a class
+	 * is found an object will be instantiated and then the data structure will
+	 * be decoded by calling the decode() method.
+	 * 
+	 * If no object has been registered then the data structure will be decoded
+	 * as an FSBinaryAction.
+	 * 
+	 * @param type
+	 *            the type used to identify the type of action encoded in the
+	 *            flash file.
+	 * 
+	 * @param aClass
+	 *            the Class object that will be instantiated and used to decode
+	 *            the action.
+	 */
+	public static void registerClass(int type, Class&lt;FSActionObject&gt; aClass)
+	{
+		table.put(new Integer(type), aClass);
+	}
+
+	protected int type;
+
+	protected int length;
+
+	protected FSActionObject(int aType)
+	{
+		type = aType;
+	}
+
+	protected FSActionObject(FSActionObject obj)
+	{
+		type = obj.type;
+		length = obj.length;
+	}
+
+	/**
+	 * Gets the code used that identifies the type of the action when it is
+	 * encoded.
+	 * 
+	 * @return the code used to denote the type of action performed.
+	 */
+	public int getType()
+	{
+		return type;
+	}
+
+	/**
+	 * Length is used to calculate the then of the action when it is encoded to
+	 * the binary Flash file format. This method can be used to calculate the
+	 * size of offsets and jumps for FSIf and FSJump actions.
+	 * 
+	 * @return the length of the encoded action in bytes.
+	 */
+	public int getLength()
+	{
+		int encodedLength = (type &gt; 128) ? 3 : 1;
+
+		encodedLength += length(new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]));
+
+		return encodedLength;
+	}
+
+	/**
+	 * Creates a deep copy of the entire object.
+	 * 
+	 * @return a copy of the object.
+	 */
+	public Object clone()
+	{
+		Object anObject = null;
+
+		try
+		{
+			anObject = super.clone();
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
+		return anObject;
+	}
+
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @param obj
+	 *            the reference object with which to compare.
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object obj)
+	{
+		boolean result = false;
+
+		if (obj == null)
+		{
+			return false;
+		}
+
+		if (obj == this)
+		{
+			return true;
+		}
+
+		if (obj instanceof FSActionObject)
+		{
+			result = type == ((FSActionObject) obj).type;
+		}
+		return result;
+	}
+
+	public String toString()
+	{
+		return name[type];
+	}
+
+	public int length(FSCoder coder)
+	{
+		length = 0;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeByte(type);
+
+		if (type &gt;= 128)
+			coder.writeWord(length, 2);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		type = coder.readByte();
+		length = type &lt; 128 ? 0 : coder.readWord(2, false);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSAudioData.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSAudioData.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSAudioData.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -29,8 +29,8 @@
  */
 package com.flagstone.transform;
 
-/** 
- * FSAudioData is used to define sounds for a Flash Video (flv) file. It is 
+/**
+ * FSAudioData is used to define sounds for a Flash Video (flv) file. It is
  * similar in function to the FSDefineSound class.
  * 
  * &lt;table class=&quot;datasheet&quot;&gt;
@@ -39,20 +39,22 @@
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
- * &lt;td&gt;&lt;a name=&quot;FSAudioData_0&quot;&gt;timestamp&lt;/a&gt;&lt;/td&gt;
- * &lt;td&gt;The time in milliseconds at which the sound will be played. The timestamp 
- * is used exclusively for determining when sound or video will be played. Any 
- * internal timing information in the audio or video data is ignored.&lt;/td&gt;
+ * &lt;td&gt;timestamp&lt;/td&gt;
+ * &lt;td&gt;The time in milliseconds at which the sound will be played. The
+ * timestamp is used exclusively for determining when sound or video will be
+ * played. Any internal timing information in the audio or video data is
+ * ignored.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;format&lt;/td&gt;
- * &lt;td&gt;The format of the sound data - PCM, ADPCM,  MP3, NATIVE_PCM or NELLYMOSER.&lt;/td&gt;
+ * &lt;td&gt;The format of the sound data - PCM, ADPCM, MP3, NATIVE_PCM or
+ * NELLYMOSER.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;playbackRate&lt;/td&gt;
- * &lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100. 
+ * &lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100.
  * Note: sounds encoded using the Nellymoser have a fixed playback rate of 8KHz.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
@@ -67,7 +69,7 @@
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
- * &lt;td&gt;&lt;a name=&quot;FSAudioData_5&quot;&gt;sound&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;sound&lt;/td&gt;
  * &lt;td&gt;The sampled sound data.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
@@ -76,284 +78,309 @@
  * Five encoded formats for the sound data are supported:
  * 
  * &lt;ul&gt;
- * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 
- * bytes. For two-byte samples the byte order is dependent on the platform on which 
- * the Flash Player is hosted. Sounds created on a platform which supports big-endian 
- * byte order will not be played correctly when listened to on a platform which 
- * supports little-endian byte order.&lt;/li&gt;
+ * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or
+ * 2 bytes. For two-byte samples the byte order is dependent on the platform on
+ * which the Flash Player is hosted. Sounds created on a platform which supports
+ * big-endian byte order will not be played correctly when listened to on a
+ * platform which supports little-endian byte order.&lt;/li&gt;
  * 
- * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes 
- * with the latter presented in Little-Endian byte order. This ensures that sounds 
- * can be played across different platforms.&lt;/li&gt;
+ * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes
+ * with the latter presented in Little-Endian byte order. This ensures that
+ * sounds can be played across different platforms.&lt;/li&gt;
  * 
- * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded and 
- * compressed by comparing the difference between successive sound sample which 
- * dramatically reduces the size of the encoded sound when compared to the 
+ * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded
+ * and compressed by comparing the difference between successive sound sample
+ * which dramatically reduces the size of the encoded sound when compared to the
  * uncompressed PCM formats. Use this format whenever possible.&lt;/li&gt;
  * 
  * &lt;li&gt;MP3 - compressed MPEG Audio Layer-3.&lt;/li&gt;
  * 
- * &lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate sound 
- * for improving synchronisation between the sound and frame rate of movies.&lt;/li&gt;
+ * &lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate
+ * sound for improving synchronisation between the sound and frame rate of
+ * movies.&lt;/li&gt;
  * &lt;/ul&gt;
  * 
  * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&lt;
  * 
- * &lt;p&gt;The FSAudioData class represents the FLV Tag with the Audio Data section 
- * from Macromedia's Flash (SWF) File Format Specification. It was added in 
- * Flash Video 1.&lt;/p&gt;
- */  
+ * &lt;p&gt;
+ * The FSAudioData class represents the FLV Tag with the Audio Data section from
+ * Macromedia's Flash (SWF) File Format Specification. It was added in Flash
+ * Video 1.
+ * &lt;/p&gt;
+ */
 public final class FSAudioData extends FSVideoObject
 {
-	private int format = 0;
-	private int playbackRate = 5512;
-	private int playbackChannels = 1;
-	private int playbackSampleSize = 1;
-	private byte[] soundData = null;
+	private int format;
+	private int playbackRate;
+	private int playbackChannels;
+	private int playbackSampleSize;
+	private byte[] soundData;
 
-	FSAudioData(FSCoder coder)
+	public FSAudioData(FSCoder coder)
 	{
-        super(FSVideoObject.AudioData, 0);
+		super(FSVideoObject.AudioData, 0);
 		decode(coder);
 	}
 
-    /** 
-     * Constructs an FSAudioData object specifying the parameters required to 
-     * describe the sound.
-     * 
-     * @param timestamp time in milliseconds from the start of the file that the 
-     * sound will be played..
-     * @param aFormat the encoding format for the sound, either FSSound.NATIVE_PCM, 
-     * FSSound.PCM, FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
-     * @param rate the number of samples per second that the sound is played at, 
-     * either 5512, 11025, 22050 or 44100.
-     * @param channels the number of channels in the sound, either 1 (Mono) or 
-     * 2 (Stereo).
-     * @param sampleSize the size of an uncompressed sound sample in bits, 
-     * either 8 or 16.
-     * @param bytes the sound data.
-     */
+	/**
+	 * Constructs an FSAudioData object specifying the parameters required to
+	 * describe the sound.
+	 * 
+	 * @param timestamp
+	 *            time in milliseconds from the start of the file that the sound
+	 *            will be played..
+	 * @param aFormat
+	 *            the encoding format for the sound, either FSSound.NATIVE_PCM,
+	 *            FSSound.PCM, FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
+	 * @param rate
+	 *            the number of samples per second that the sound is played at,
+	 *            either 5512, 11025, 22050 or 44100.
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 * @param sampleSize
+	 *            the size of an uncompressed sound sample in bits, either 8 or
+	 *            16.
+	 * @param bytes
+	 *            the sound data.
+	 */
 	public FSAudioData(int timestamp, int aFormat, int rate, int channels, int sampleSize, byte[] bytes)
 	{
 		super(FSVideoObject.AudioData, timestamp);
 		setFormat(aFormat);
 		setPlaybackRate(rate);
-        setPlaybackChannels(channels);
+		setPlaybackChannels(channels);
 		setPlaybackSampleSize(sampleSize);
 		setSoundData(bytes);
 	}
 
-    /**	
-     * Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM, 
-     * FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
-     * 
-     * @return a constant defining the type of compression.
-     */
-    public int getFormat() 
-    {
-        return format;
-    }
+	/**
+	 * Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM,
+	 * FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
+	 * 
+	 * @return a constant defining the type of compression.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-    /** 
-     * Sets the encoding format used, either FSSound.NATIVE_PCM, FSSound.PCM, 
-     * FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
-     * 
-     * @param encoding the format for the sound.
-     */
-    public void setFormat(int encoding)
+	/**
+	 * Sets the encoding format used, either FSSound.NATIVE_PCM, FSSound.PCM,
+	 * FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
+	 * 
+	 * @param encoding
+	 *            the format for the sound.
+	 */
+	public void setFormat(int encoding)
 	{
 		format = encoding;
 	}
 
-    /** 
-     * Gets the rate at which the sound will be played, in Hertz: 5512, 11025, 
-     * 22050 or 44100. Note that the playback rate for Nellymoser encoded audio 
-     * is fixed at 8Khz so the playback rate attribute has no effect.
-     * 
-     * @return the rate at which the sound was sampled.
-     */
-    public int getPlaybackRate()
-    {
-        return playbackRate;
-    }
+	/**
+	 * Gets the rate at which the sound will be played, in Hertz: 5512, 11025,
+	 * 22050 or 44100. Note that the playback rate for Nellymoser encoded audio
+	 * is fixed at 8Khz so the playback rate attribute has no effect.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-    /** 
-     * Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or 
-     * 44100.
-     * 
-     * @param rate the rate at which the sounds is played in Hz.
-     */
-    public void setPlaybackRate(int rate)
+	/**
+	 * Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or
+	 * 44100.
+	 * 
+	 * @param rate
+	 *            the rate at which the sounds is played in Hz.
+	 */
+	public void setPlaybackRate(int rate)
 	{
 		playbackRate = rate;
 	}
 
-    /** 
-     * Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
-     * 
-     * @return the number of channels.
-     */
-    public int getPlaybackChannels()
-    {
-        return playbackChannels;
-    }
+	/**
+	 * Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
+	 * 
+	 * @return the number of channels.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-    /** 
-     * Sets the number of channels defined in the sound.
-     * 
-     * @param channels the number of channels in the sound, either 1 (Mono) or 
-     * 2 (Stereo).
-     */
-    public void setPlaybackChannels(int channels)
-    {
-        playbackChannels = channels;
-    }
+	/**
+	 * Sets the number of channels defined in the sound.
+	 * 
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 */
+	public void setPlaybackChannels(int channels)
+	{
+		playbackChannels = channels;
+	}
 
-    /** 
-     * Gets the size of an uncompressed sample in bytes.
-     * 
-     * @return the number of bytes per sample when the sound is uncompressed.
-     */
-    public int getPlaybackSampleSize() 
-    {
-        return playbackSampleSize;
-    }
+	/**
+	 * Gets the size of an uncompressed sample in bytes.
+	 * 
+	 * @return the number of bytes per sample when the sound is uncompressed.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-    /** 
-     * Sets the sample size in bytes. Must be either 1 or 2.
-     * 
-     * @param sampleSize the size of sound samples in bytes.
-     */
-    public void setPlaybackSampleSize(int sampleSize)
+	/**
+	 * Sets the sample size in bytes. Must be either 1 or 2.
+	 * 
+	 * @param sampleSize
+	 *            the size of sound samples in bytes.
+	 */
+	public void setPlaybackSampleSize(int sampleSize)
 	{
 		playbackSampleSize = sampleSize;
 	}
 
-    /** 
-     * Gets the sound data.
-     * 
-     * @return an array of bytes containing the sampled sound.
-     */
-    public byte[] getSoundData()
-    {
-        return soundData;
-    }
+	/**
+	 * Gets the sound data.
+	 * 
+	 * @return an array of bytes containing the sampled sound.
+	 */
+	public byte[] getSoundData()
+	{
+		return soundData;
+	}
 
-    /** 
-     * Sets the sound data.
-     * 
-     * @param bytes the sound data.
-     */
-    public void setSoundData(byte[] bytes)
+	/**
+	 * Sets the sound data.
+	 * 
+	 * @param bytes
+	 *            the sound data.
+	 * 
+	 * @throws NullPointerException if the argument is null.
+	 */
+	public void setSoundData(byte[] bytes)
 	{
+		if (bytes == null) {
+			throw new NullPointerException(&quot;Sound data cannot be null&quot;);
+		}
 		soundData = bytes;
 	}
 
-    public Object clone()
+	public Object clone()
 	{
-        FSAudioData anObject = (FSAudioData)super.clone();
-        
-        anObject.soundData = Transform.clone(soundData);
-        
-		return anObject;
+		FSAudioData obj = (FSAudioData)super.clone();
+
+		obj.soundData = new byte[soundData.length];
+		
+		for (int i=0; i&lt;soundData.length; i++) {
+			obj.soundData[i] = soundData[i];
+		}
+
+		return obj;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSAudioData typedObject = (FSAudioData)anObject;
-            
-            result = format == typedObject.format;
-            result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-            result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-            result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-            result = result &amp;&amp; Transform.equals(soundData, typedObject.soundData);
-        }
+		{
+			FSAudioData typedObject = (FSAudioData) anObject;
+
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			
+			result = result &amp;&amp; soundData.length == typedObject.soundData.length;
+
+			if (result)
+				for (int i=0; i&lt;soundData.length; i++)
+					if (soundData[i] != typedObject.soundData[i])
+						result = false;
+		}
 		return result;
 	}
 
-	public void appendDescription(StringBuffer buffer, int depth)
+	public String toString()
 	{
-		buffer.append(name());
+		StringBuffer buffer = new StringBuffer();
+
+		buffer.append(&quot;FSAudioData: { &quot;);
+		buffer.append(&quot;timestamp = &quot;).append(timestamp).append(&quot;; &quot;);
+		buffer.append(&quot;format = &quot;).append(format).append(&quot;; &quot;);
+		buffer.append(&quot;playbackRate = &quot;).append(playbackRate).append(&quot;; &quot;);
+		buffer.append(&quot;playbackChannels = &quot;).append(playbackChannels).append(&quot;; &quot;);
+		buffer.append(&quot;playbackSampleSize = &quot;).append(playbackSampleSize).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 		
-		if (depth &gt; 0)
-		{
-			buffer.append(&quot;: { &quot;);
-			Transform.append(buffer, &quot;format&quot;, format);
-			Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-			Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-			Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-			buffer.append(&quot;}&quot;);
-		}
-		else
-		{
-			buffer.append(name());
-		}
+		return buffer.toString();
 	}
 
-	int length(FSCoder coder)
+	public int length(FSCoder coder)
 	{
 		super.length(coder);
-	
+
 		length += 1 + soundData.length;
-	
+
 		return length;
 	}
-	
-	void encode(FSCoder coder)
+
+	public void encode(FSCoder coder)
 	{
-        super.encode(coder);
-		
+		super.encode(coder);
+
 		coder.writeBits(format, 4);
-        
-        switch (playbackRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(playbackSampleSize-1, 1);
-		coder.writeBits(playbackChannels-1, 1);
+
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
 		coder.writeBytes(soundData);
 	}
-	
-	void decode(FSCoder coder)
+
+	public void decode(FSCoder coder)
 	{
 		super.decode(coder);
-		
+
 		format = coder.readBits(4, false);
 
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                playbackRate = 5512;
-                break;
-            case 1:
-                playbackRate = 11025;
-                break;
-            case 2:
-                playbackRate = 22050;
-                break;
-            case 3:
-                playbackRate = 44100;
-                break;
-        }
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
 
-        playbackSampleSize = coder.readBits(1, false)+1;
-		playbackChannels = coder.readBits(1, false)+1;	
-		soundData = new byte[length-1];
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
+		soundData = new byte[length - 1];
 		coder.readBytes(soundData);
 	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSButton.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSButton.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSButton.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,344 +31,501 @@
 package com.flagstone.transform;
 
 /**
-FSButton identifies the shape that is drawn when a button is in a particular state.
-
-&lt;p&gt;Shapes can be drawn for each of three button states, Over, Up and Down. Creating a button with more than one FSButton object each referencing a different shape allows the button to be animated as it is clicked.&lt;/p&gt;
-
-&lt;p&gt;A shape is also used to define active area of the button. When defining the active area the outline of the shape defines the boundary of the area. The shape is not drawn when the button is displayed. The button will only respond to mouse events when the cursor is placed inside the active area.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_0&quot;&gt;state&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;the state(s) the button is in when the shape will be drawn, either Up, Over or Down. Active is used to denote when a shape defined the active area of a button.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_1&quot;&gt;identifier&lt;a/&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the object that contains the definition of the shape that is drawn.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The layer number defines the order in which shapes are displayed. Shapes with a higher layer number are displayed in front of those on a lower layer. Complex buttons can be created by displaying more than one shape for a given button state. The layer number may be in the range 1..65535 - the range is determined by the size of the field when the value is encoded to a Flash file - however the vast majority of buttons will typically only use layer numbers less than 10.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an FSCoordTransform object that defines a coordinate transform that will be applied to the shape when it is displayed. The transform is most commonly used to offset shapes to create a 3-D appearance. The size may also be changed allowing a single shape definition to be used to display buttons in a range of sizes while still maintaining the same look and feel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_3&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an optional FSColorTransform object that can be used to change the shape's
-colour when it is drawn.&lt;/td&gt;
-&lt;/tr&gt;
-
-
-&lt;/table&gt;
-
-&lt;p&gt;An FSButton can define the appearance of the button for more than one state. Multiple states can be defined by bitwise Or-ing individual state codes together:&lt;/p&gt;
-
-&lt;pre&gt;
-int buttonState = FSButton.Up | FSButton.Over;
-&lt;/pre&gt;
-
-&lt;p&gt;The purpose of the layer attribute is to define the order in which shapes are displayed for a given button state. This is analogous to the layer number in the Flash Player's display list - specified using objects such as FSPlaceObject. When a button is displayed it is placed on a single layer in the display list and the layer numbers assigned to shapes in a FSButton object do not interfere with shapes assigned to the same layer in the display list.&lt;/p&gt;
-
-&lt;p&gt;The coordinate transform is used to change the appearance of the button without changing the original shape definitions. If it is omitted then a unity transform will be encoded which does not change the way the shape is drawn.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSButton class represents the ButtonRecord structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
-
+ * FSButton identifies the shape that is drawn when a button is in a particular
+ * state.
+ * 
+ * &lt;p&gt;
+ * Shapes can be drawn for each of three button states, Over, Up and Down.
+ * Creating a button with more than one FSButton object each referencing a
+ * different shape allows the button to be animated as it is clicked.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * A shape is also used to define active area of the button. When defining the
+ * active area the outline of the shape defines the boundary of the area. The
+ * shape is not drawn when the button is displayed. The button will only respond
+ * to mouse events when the cursor is placed inside the active area.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;state&lt;/td&gt;
+ * &lt;td&gt;the state(s) the button is in when the shape will be drawn, either Up,
+ * Over or Down. Active is used to denote when a shape defined the active area
+ * of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;a/&gt;&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the object that contains the
+ * definition of the shape that is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The layer number defines the order in which shapes are displayed. Shapes
+ * with a higher layer number are displayed in front of those on a lower layer.
+ * Complex buttons can be created by displaying more than one shape for a given
+ * button state. The layer number may be in the range 1..65535 - the range is
+ * determined by the size of the field when the value is encoded to a Flash file -
+ * however the vast majority of buttons will typically only use layer numbers
+ * less than 10.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;an FSCoordTransform object that defines a coordinate transform that will
+ * be applied to the shape when it is displayed. The transform is most commonly
+ * used to offset shapes to create a 3-D appearance. The size may also be
+ * changed allowing a single shape definition to be used to display buttons in a
+ * range of sizes while still maintaining the same look and feel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;an optional FSColorTransform object that can be used to change the
+ * shape's colour when it is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * An FSButton can define the appearance of the button for more than one state.
+ * Multiple states can be defined by bitwise Or-ing individual state codes
+ * together:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int buttonState = FSButton.Up | FSButton.Over;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The purpose of the layer attribute is to define the order in which shapes are
+ * displayed for a given button state. This is analogous to the layer number in
+ * the Flash Player's display list - specified using objects such as
+ * FSPlaceObject. When a button is displayed it is placed on a single layer in
+ * the display list and the layer numbers assigned to shapes in a FSButton
+ * object do not interfere with shapes assigned to the same layer in the display
+ * list.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The coordinate transform is used to change the appearance of the button
+ * without changing the original shape definitions. If it is omitted then a
+ * unity transform will be encoded which does not change the way the shape is
+ * drawn.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButton class represents the ButtonRecord structure from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ * 
  */
-public class FSButton extends FSTransformObject
+public class FSButton implements Cloneable, Codeable
 {
-    /** Code for the button in the up state. */
-    public static final int Up = 1;
-    /** Code for the state of the button when the mouse is over the active area. */
-    public static final int Over = 2;
-    /** Code for the state of the button when the mouse is clicked the active area. */
-    public static final int Down = 4;
-    /** Code for the active area of the button. */
-    public static final int Active = 8;
+	/** Code for the button in the up state. */
+	public static final int Up = 1;
 
-    private int state = 0;
-    private int identifier = 0;
-    private int layer = 0;
+	/** Code for the state of the button when the mouse is over the active area. */
+	public static final int Over = 2;
 
-    private FSCoordTransform transform = null;
-    private FSColorTransform colorTransform = null;
+	/**
+	 * Code for the state of the button when the mouse is clicked the active
+	 * area.
+	 */
+	public static final int Down = 4;
 
-    /**
-     * Construct an FSButton object, initalizing it with values decoded from
-     * an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButton(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**  Constructs an FSButton object without a coordinate or colour transform that will be applied to the shape drawn for the button states. The transforms default to unity transforms which do not change the location of colour of the shape for the button.
+	/** Code for the active area of the button. */
+	public static final int Active = 8;
 
-        @param aState the state of the button when the shape is drawn.
-        @param anIdentifier the identifier of an FSDefineShape, FSDefineShape2 or FSDefineShape3 object.
-        @param aLayer the layer in the display list on which the shape is drawn.
-        */
-    public FSButton(int aState, int anIdentifier, int aLayer)
-    {
-        setState(aState);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(0,0));
-        setColorTransform(new FSColorTransform());
-    }
+	private int state = 0;
 
-    /**  Constructs an FSButton object with a coordinate transform that will be applied to the shape drawn for the button states.
+	private int identifier = 0;
 
-        @param aState the state of the button when the shape is drawn.
-        @param anIdentifier the identifier of an FSDefineShape, FSDefineShape2 or FSDefineShape3 object.
-        @param aLayer the layer in the display list on which the shape is drawn.
-        @param aTransform an FSCoordTransform object that changes the appearance of the shape when it is drawn.
-        */
-    public FSButton(int aState, int anIdentifier, int aLayer, FSCoordTransform aTransform)
-    {
-        setState(aState);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(new FSColorTransform());
-    }
+	private int layer = 0;
 
-    /**  Constructs an FSButton object with a coordinate and colour transform that will be applied to the shape drawn for the button states.
+	private FSCoordTransform transform = null;
 
-        @param aState the state of the button when the shape is drawn.
-        @param anIdentifier the identifier of an FSDefineShape, FSDefineShape2 or FSDefineShape3 object.
-        @param aLayer the layer in the display list on which the shape is drawn.
-        @param aTransform an FSCoordTransform object that changes the appearance of the shape when it is drawn.
-        @param aColorTransform an FSColorTransform object that changes the colour of the shape when it is drawn.
-        */
-    public FSButton(int aState, int anIdentifier, int aLayer, FSCoordTransform aTransform, FSColorTransform aColorTransform)
-    {
-        setState(aState);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(aColorTransform);
-    }
-    /**
-     * Constructs an FSButton object by copying values from an existing object.
-     *
-     * @param obj an FSButton object.
-     */
-    public FSButton(FSButton obj)
-    {
-        state = obj.state;
-        identifier = obj.identifier;
-        layer = obj.layer;
-        transform = new FSCoordTransform(obj.transform);
+	private FSColorTransform colorTransform = null;
 
-        if (obj.colorTransform != null)
-            colorTransform = new FSColorTransform(obj.colorTransform);
-    }
+	/**
+	 * Construct an FSButton object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButton(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    /** Get the state(s) of the button when the shape is drawn.
+	/**
+	 * Constructs an FSButton object without a coordinate or colour transform
+	 * that will be applied to the shape drawn for the button states. The
+	 * transforms default to unity transforms which do not change the location
+	 * of colour of the shape for the button.
+	 * 
+	 * @param aState
+	 *            the state of the button when the shape is drawn.
+	 * @param anIdentifier
+	 *            the identifier of an FSDefineShape, FSDefineShape2 or
+	 *            FSDefineShape3 object.
+	 * @param aLayer
+	 *            the layer in the display list on which the shape is drawn.
+	 */
+	public FSButton(int aState, int anIdentifier, int aLayer)
+	{
+		setState(aState);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(0, 0));
+		setColorTransform(new FSColorTransform());
+	}
 
-        @return the state of the button when the shape is drawn.
-        */
-    public int getState() { return state; }
+	/**
+	 * Constructs an FSButton object with a coordinate transform that will be
+	 * applied to the shape drawn for the button states.
+	 * 
+	 * @param aState
+	 *            the state of the button when the shape is drawn.
+	 * @param anIdentifier
+	 *            the identifier of an FSDefineShape, FSDefineShape2 or
+	 *            FSDefineShape3 object.
+	 * @param aLayer
+	 *            the layer in the display list on which the shape is drawn.
+	 * @param aTransform
+	 *            an FSCoordTransform object that changes the appearance of the
+	 *            shape when it is drawn.
+	 */
+	public FSButton(int aState, int anIdentifier, int aLayer,
+					FSCoordTransform aTransform)
+	{
+		setState(aState);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(new FSColorTransform());
+	}
 
-    /** Does the Button Record defines a shape for the button's active area.
+	/**
+	 * Constructs an FSButton object with a coordinate and colour transform that
+	 * will be applied to the shape drawn for the button states.
+	 * 
+	 * @param aState
+	 *            the state of the button when the shape is drawn.
+	 * @param anIdentifier
+	 *            the identifier of an FSDefineShape, FSDefineShape2 or
+	 *            FSDefineShape3 object.
+	 * @param aLayer
+	 *            the layer in the display list on which the shape is drawn.
+	 * @param aTransform
+	 *            an FSCoordTransform object that changes the appearance of the
+	 *            shape when it is drawn.
+	 * @param aColorTransform
+	 *            an FSColorTransform object that changes the colour of the
+	 *            shape when it is drawn.
+	 */
+	public FSButton(int aState, int anIdentifier, int aLayer,
+					FSCoordTransform aTransform,
+					FSColorTransform aColorTransform)
+	{
+		setState(aState);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(aColorTransform);
+	}
 
-        @return a boolean flag indicating whether the button record defines the button's active area.
-        */
-    public boolean isActive() { return ((state &amp; Active) != 0) ? true : false; }
+	/**
+	 * Constructs an FSButton object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSButton object.
+	 */
+	public FSButton(FSButton obj)
+	{
+		state = obj.state;
+		identifier = obj.identifier;
+		layer = obj.layer;
+		transform = new FSCoordTransform(obj.transform);
 
-    /** Does the Button Record define a shape for the button's 'down' state.
+		if (obj.colorTransform != null)
+			colorTransform = new FSColorTransform(obj.colorTransform);
+	}
 
-        @return a boolean flag indicating whether the button record defines the shape for the button's 'down' state.
-        */
-    public boolean isDown() { return ((state &amp; Down) != 0) ? true : false; }
+	/**
+	 * Get the state(s) of the button when the shape is drawn.
+	 * 
+	 * @return the state of the button when the shape is drawn.
+	 */
+	public int getState()
+	{
+		return state;
+	}
 
-    /** Does the Button Record define a shape for the button's 'over' state.
+	/**
+	 * Does the Button Record defines a shape for the button's active area.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         button's active area.
+	 */
+	public boolean isActive()
+	{
+		return ((state &amp; Active) != 0) ? true : false;
+	}
 
-        @return a boolean flag indicating whether the button record defines the shape for the button's 'over' state.
-        */
-    public boolean isOver() { return ((state &amp; Over) != 0) ? true : false; }
+	/**
+	 * Does the Button Record define a shape for the button's 'down' state.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         shape for the button's 'down' state.
+	 */
+	public boolean isDown()
+	{
+		return ((state &amp; Down) != 0) ? true : false;
+	}
 
-    /** Does the Button Record define a shape for the button's 'up' state.
+	/**
+	 * Does the Button Record define a shape for the button's 'over' state.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         shape for the button's 'over' state.
+	 */
+	public boolean isOver()
+	{
+		return ((state &amp; Over) != 0) ? true : false;
+	}
 
-        @return a boolean flag indicating whether the button record defines the shape for the button's 'up' state.
-        */
-    public boolean isUp() { return ((state &amp; Up) != 0) ? true : false; }
+	/**
+	 * Does the Button Record define a shape for the button's 'up' state.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         shape for the button's 'up' state.
+	 */
+	public boolean isUp()
+	{
+		return ((state &amp; Up) != 0) ? true : false;
+	}
 
-    /** Gets the identifier of the shape that this FSButton applies to.
+	/**
+	 * Gets the identifier of the shape that this FSButton applies to.
+	 * 
+	 * @return the identifier of the shape.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-        @return the identifier of the shape.
-        */
-    public int getIdentifier() { return identifier; }
+	/**
+	 * Gets the layer that the button will be displayed on.
+	 * 
+	 * @return the layer on which the shape is displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-    /** Gets the layer that the button will be displayed on.
+	/**
+	 * Gets the coordinate transform that will be applied to the button.
+	 * 
+	 * @return the coordinate transform that is applied to the shape.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-        @return the layer on which the shape is displayed.
-        */
-    public int getLayer() { return layer; }
+	/**
+	 * Gets the colour transform that will be applied to the button.
+	 * 
+	 * @return the colour transform that is applied to the shape.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-    /** Gets the coordinate transform that will be applied to the button.
+	/**
+	 * Set the state(s) of the button when the shape is drawn. The shape may be
+	 * drawn for more than one state. Multiple states can be defined by
+	 * bitwise-OR'ing individual states together, e.g. Up | Over.
+	 * 
+	 * @param aNumber
+	 *            the state of the button when the shape is drawn.
+	 */
+	public void setState(int aNumber)
+	{
+		state = aNumber;
+	}
 
-        @return the coordinate transform that is applied to the shape.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+	/**
+	 * Sets the identifier of the FSDefineShape, FSDefineShape2 or
+	 * FSDefineShape3 object that defines the appearance of the button when it
+	 * is in the specified state(s).
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the shape object that defines the shape's
+	 *            appearance.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /** Gets the colour transform that will be applied to the button.
+	/**
+	 * Sets the layer in the display list that the shape will be displayed on.
+	 * 
+	 * @param aNumber
+	 *            the number of the layer in the display list where the shape is
+	 *            drawn.
+	 */
+	public void setLayer(int aNumber)
+	{
+		layer = aNumber;
+	}
 
-        @return the colour transform that is applied to the shape.
-        */
-    public FSColorTransform getColorTransform() { return colorTransform; }
+	/**
+	 * Sets the coordinate transform that will be applied to the shape to change
+	 * it's appearance.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the shape.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-    /** Set the state(s) of the button when the shape is drawn. The shape may be drawn for more than one state. Multiple states can be defined by bitwise-OR'ing individual states together, e.g.  Up | Over.
+	/**
+	 * Sets the colour transform that will be applied to the shape to change
+	 * it's colour.
+	 * 
+	 * @param aTransform
+	 *            an FSColorTransform object that will be applied to the shape.
+	 */
+	public void setColorTransform(FSColorTransform aTransform)
+	{
+		colorTransform = aTransform;
+	}
 
-        @param aNumber the state of the button when the shape is drawn.
-        */
-    public void setState(int aNumber) { state = aNumber; }
+	public Object clone()
+	{
+		FSButton anObject = null;
 
-    /** Sets the identifier of the  FSDefineShape, FSDefineShape2 or FSDefineShape3 object that defines the appearance of the button when it is in the specified state(s).
+		try {
+			anObject = (FSButton)super.clone();
 
-        @param anIdentifier the identifier of the shape object that defines the shape's appearance.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+			anObject.transform = (transform != null) ? (FSCoordTransform) transform
+							.clone() : null;
+			anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+							.clone()
+							: null;
+		} 
+		catch (CloneNotSupportedException e) {
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-    /** Sets the layer in the display list that the shape will be displayed on.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aNumber the number of the layer in the display list where the shape is drawn.
-        */
-    public void setLayer(int aNumber)
-    {
-        layer = aNumber;
-    }
+		if (super.equals(anObject))
+		{
+			FSButton typedObject = (FSButton) anObject;
 
-    /** Sets the coordinate transform that will be applied to the shape to change it's appearance.
+			result = state == typedObject.state;
+			result = result &amp;&amp; identifier == typedObject.identifier;
+			result = result &amp;&amp; layer == typedObject.layer;
 
-        @param aTransform an FSCoordTransform object that will be applied to the shape.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-    /** Sets the colour transform that will be applied to the shape to change it's colour.
+			if (colorTransform != null)
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
+			else
+				result = result &amp;&amp; colorTransform == typedObject.colorTransform;
+		}
+		return result;
+	}
 
-        @param aTransform an FSColorTransform object that will be applied to the shape.
-        */
-    public void setColorTransform(FSColorTransform aTransform)
-    {
-        colorTransform = aTransform;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    public Object clone()
-    {
-        FSButton anObject = (FSButton)super.clone();
+		buffer.append(&quot;FSButton: { &quot;);
+		buffer.append(&quot;state = &quot;).append(state).append(&quot;; &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;layer = &quot;).append(layer).append(&quot;; &quot;);
+		buffer.append(&quot;transform = &quot;).append(transform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;colorTransform = &quot;).append(colorTransform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        anObject = (FSButton)super.clone();
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
+		return buffer.toString();
+	}
 
-        return anObject;
-    }
+	public int length(FSCoder coder)
+	{
+		int length = 0;
 
-    /**
-     * Returns true if anObject is equal to this one. Objects are considered
-     * equal if they would generate identical binary data when they are encoded
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+		length += 5;
+		length += transform.length(coder);
+		// Flash 3
+		if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
+			length += colorTransform.length(coder);
+		// End Flash 3
+		return length;
+	}
 
-        if (super.equals(anObject))
-        {
-            FSButton typedObject = (FSButton)anObject;
+	public void encode(FSCoder coder)
+	{
+		coder.writeBits(0, 4);
+		coder.writeBits(state, 4);
+		coder.writeWord(identifier, 2);
+		coder.writeWord(layer, 2);
+		transform.encode(coder);
+		// Flash 3
+		if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
+			colorTransform.encode(coder);
+		// End Flash 3
+	}
 
-            result = state == typedObject.state;
-            result = result &amp;&amp; identifier == typedObject.identifier;
-            result = result &amp;&amp; layer == typedObject.layer;
+	public void decode(FSCoder coder)
+	{
+		coder.readBits(4, false);
 
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
+		state = coder.readBits(4, false);
+		identifier = coder.readWord(2, false);
+		layer = coder.readWord(2, false);
 
-            if (colorTransform != null)
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-            else
-                result = result &amp;&amp; colorTransform == typedObject.colorTransform;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;state&quot;, state);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 0;
-
-        length += 5;
-        length += transform.length(coder);
-// Flash 3
-         if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
-            length += colorTransform.length(coder);
-// End Flash 3
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        coder.writeBits(0, 4);
-        coder.writeBits(state, 4);
-        coder.writeWord(identifier, 2);
-        coder.writeWord(layer, 2);
-        transform.encode(coder);
-// Flash 3
-        if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
-            colorTransform.encode(coder);
-// End Flash 3
-    }
-
-    public void decode(FSCoder coder)
-    {
-        coder.readBits(4, false);
-
-        state = coder.readBits(4, false);
-        identifier = coder.readWord(2, false);
-        layer = coder.readWord(2, false);
-
-        transform = new FSCoordTransform(coder);
-// Flash 3
-        if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
-            colorTransform = new FSColorTransform(coder);
-// End Flash 3
-    }
+		transform = new FSCoordTransform(coder);
+		// Flash 3
+		if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
+			colorTransform = new FSColorTransform(coder);
+		// End Flash 3
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSButtonColorTransform.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSButtonColorTransform.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSButtonColorTransform.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,173 +31,213 @@
 package com.flagstone.transform;
 
 /**
-FSButtonColorTransform defines the colour transform that is applied to each shape 
-that is used to draw a button.
- 
-&lt;p&gt;This class is only used in conjunction with FSDefineButton. FSDefineButton2 allows colour transforms to be specified in the FSButtonRecord object that identifies each shape that is displayed for a given button state.&lt;/p&gt;
+ * FSButtonColorTransform defines the colour transform that is applied to each
+ * shape that is used to draw a button.
+ * 
+ * &lt;p&gt;
+ * This class is only used in conjunction with FSDefineButton. FSDefineButton2
+ * allows colour transforms to be specified in the FSButtonRecord object that
+ * identifies each shape that is displayed for a given button state.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;the identifier for the FSDefineButton or FSDefineButton2 object that
+ * defines the appearance and behaviour of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;An FSColorTransform object that describes how the colours are changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButtonColorTransform class represents the DefineButtonCXForm structure
+ * from the Macromedia Flash (SWF) File Format Specification. It was introduced
+ * in Flash 2.
+ * &lt;/p&gt;
+ */
+public class FSButtonColorTransform extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private FSColorTransform colorTransform = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSButtonColorTransform object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButtonColorTransform(FSCoder coder)
+	{
+		super(ButtonColorTransform);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonColorTransform_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonColorTransform object with a colour transform for
+	 * the specified button.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a button that this FSButtonColorTransform
+	 *            applies to.
+	 * @param aColorTransform
+	 *            an FSColorTransform object that will be applied to the button.
+	 */
+	public FSButtonColorTransform(int anIdentifier,
+									FSColorTransform aColorTransform)
+	{
+		super(ButtonColorTransform);
+		setIdentifier(anIdentifier);
+		setColorTransform(aColorTransform);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonColorTransform_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;the identifier for the FSDefineButton or FSDefineButton2 object that defines the appearance and behaviour of a button.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonColorTransform object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSButtonColorTransform object.
+	 */
+	public FSButtonColorTransform(FSButtonColorTransform obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonColorTransform_2&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColorTransform object that describes how the colours are changed.&lt;/td&gt;
-&lt;/tr&gt;
+		identifier = obj.identifier;
+		colorTransform = new FSColorTransform(obj.colorTransform);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the identifier of the button that this FSButtonColorTransform object
+	 * applies to.
+	 * 
+	 * @return the identifier of the button that the transform will be applied
+	 *         to.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the colour transform that will be applied to the FSDefineButton
+	 * object.
+	 * 
+	 * @return the colour transform that will be applied to the button.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-&lt;p&gt;The FSButtonColorTransform class represents the DefineButtonCXForm structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSButtonColorTransform extends FSMovieObject
-{
-    private int identifier = 0;
-    private FSColorTransform colorTransform = null;
+	/**
+	 * Sets the identifier of the button that the transform applies to.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the FSDefineButton object that the transform
+	 *            will be applied to.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /**
-     * Construct an FSButtonColorTransform object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButtonColorTransform(FSCoder coder)
-    {
-        super(ButtonColorTransform);
-        decode(coder);
-    }
+	/**
+	 * Sets the colour transform.
+	 * 
+	 * @param aTransform
+	 *            the colour transform object that will be applied to the
+	 *            button.
+	 */
+	public void setColorTransform(FSColorTransform aTransform)
+	{
+		colorTransform = aTransform;
+	}
 
-    /** Constructs an FSButtonColorTransform object with a colour transform for the specified button.
+	public Object clone()
+	{
+		FSButtonColorTransform anObject = (FSButtonColorTransform) super
+						.clone();
 
-        @param anIdentifier    the identifier of a button that this FSButtonColorTransform applies to.
-        @param aColorTransform an FSColorTransform object that will be applied to the button.
-        */
-    public FSButtonColorTransform(int anIdentifier, FSColorTransform aColorTransform)
-    {
-        super(ButtonColorTransform);
-        setIdentifier(anIdentifier);
-        setColorTransform(aColorTransform);
-    }
-    /**
-     * Constructs an FSButtonColorTransform object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSButtonColorTransform object.
-     */
-    public FSButtonColorTransform(FSButtonColorTransform obj)
-    {
-        super(obj);
-        
-        identifier = obj.identifier;
-        colorTransform = new FSColorTransform(obj.colorTransform);
-    }
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-    /** Gets the identifier of the button that this FSButtonColorTransform object applies to. 
+		return anObject;
+	}
 
-        @return the identifier of the button that the transform will be applied to.
-        */
-    public int getIdentifier() { return identifier; }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the colour transform that will be applied to the FSDefineButton object.
+		if (super.equals(anObject))
+		{
+			FSButtonColorTransform typedObject = (FSButtonColorTransform) anObject;
 
-        @return the colour transform that will be applied to the button.
-        */ 
-    public FSColorTransform getColorTransform() { return colorTransform; }
+			result = identifier == typedObject.identifier;
 
-    /** Sets the identifier of the button that the transform applies to.
+			if (colorTransform == null)
+				result = result &amp;&amp; (typedObject.colorTransform == null);
+			else
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
+		}
+		return result;
+	}
 
-        @param anIdentifier the identifier of the FSDefineButton object that the transform will be applied to.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Sets the colour transform.
+		buffer.append(&quot;FSButtonColorTransform: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;colorTransform = &quot;).append(colorTransform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;};&quot;);
 
-        @param aTransform the colour transform object that will be applied to the button.
-        */ 
-    public void setColorTransform(FSColorTransform aTransform)
-    {
-        colorTransform = aTransform;
-    }
+		return buffer.toString();
+	}
 
-    public Object clone()
-    {
-        FSButtonColorTransform anObject = (FSButtonColorTransform)super.clone();
-        
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
-        
-        return anObject;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSButtonColorTransform typedObject = (FSButtonColorTransform)anObject;
-            
-            result = identifier == typedObject.identifier;
+		length += 2;
+		length += colorTransform.length(coder);
 
-            if (colorTransform == null)
-                result = result &amp;&amp; (typedObject.colorTransform == null);
-            else
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-        }
-        return result;
-    }
+		return length;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            buffer.append(&quot;};&quot;);
-        }
-    }
+		coder.writeWord(identifier, 2);
+		colorTransform.encode(coder);
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        length += colorTransform.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        colorTransform.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        colorTransform = new FSColorTransform(coder);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		identifier = coder.readWord(2, false);
+		colorTransform = new FSColorTransform(coder);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSButtonEvent.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSButtonEvent.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSButtonEvent.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -32,453 +32,706 @@
 
 import java.util.*;
 
-/** 
-FSButtonEvent is used to define the actions that a button will execute in response 
-to a particular event.
- 
-&lt;p&gt;The events that a button responds to are:&lt;/p&gt;
+/**
+ * FSButtonEvent is used to define the actions that a button will execute in
+ * response to a particular event.
+ * 
+ * &lt;p&gt;
+ * The events that a button responds to are:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves over the active area of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves out of the active area of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Press&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is over
+ * the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Release&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and released while the mouse
+ * cursor is over the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * out of the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged
+ * into the active area of the button and the mouse button is released.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * When a button is configured as a menu item (FSDefineButton2 objects only)
+ * then three additional events can occur:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MenuDragOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * into the active area of the menu item.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MenuDragOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * out of the active area of the menu item.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;ReleaseOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * into the active area of the menu item.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In addition to responding to mouse events, buttons also respond to keys being
+ * pressed on the keyboard. Keyboard events are defined by the character key
+ * being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;, etc. For control keys a number of reserved
+ * names are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Left&gt;&lt;/td&gt;
+ * &lt;td&gt;Left arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Right&gt;&lt;/td&gt;
+ * &lt;td&gt;Right arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Home&gt;&lt;/td&gt;
+ * &lt;td&gt;Home key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;End&gt;&lt;/td&gt;
+ * &lt;td&gt;End key&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Insert&gt;&lt;/td&gt;
+ * &lt;td&gt;Insert key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Delete&gt;&lt;/td&gt;
+ * &lt;td&gt;Delete key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Backspace&gt;&lt;/td&gt;
+ * &lt;td&gt;Backspace key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Enter&gt;&lt;/td&gt;
+ * &lt;td&gt;Enter (return) key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Up&gt;&lt;/td&gt;
+ * &lt;td&gt;Up arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Down&gt;&lt;/td&gt;
+ * &lt;td&gt;Down arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Pageup&gt;&lt;/td&gt;
+ * &lt;td&gt;Page up key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Pagedown&gt;&lt;/td&gt;
+ * &lt;td&gt;Page down key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Tab&gt;&lt;/td&gt;
+ * &lt;td&gt;Tab key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Escape&gt;&lt;/td&gt;
+ * &lt;td&gt;Escape key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Space&gt;&lt;/td&gt;
+ * &lt;td&gt;Space bar.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Since the event code allows multiple events, the code for compound events can
+ * be created by performing a bit-wise Or of the individual codes:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  int eventCode = FSButtonEvent.RollOver | FSButtonEvent.Press;&quot;;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The class method &lt;b&gt;codeForKey&lt;/b&gt; returns the event code that identifies
+ * when a specific key is pressed:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int eventCode = FSButtonEvent.codeForKey('J');
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Control keys are identified using one of the reserved ButtonEvent values:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int eventCode = FSButtonEvent.Enter | FSButtonEvent.PageUp;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * However while multiple mouse events can be defined for a button only one
+ * keyboard event can be defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;event&lt;/td&gt;
+ * &lt;td&gt;a code identifying the different types of button events that the actions
+ * defined in this object will be executed in response to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of action objects that are executed when the events defined in
+ * the event code occur.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButtonEvent class represents the ButtonCondAction data structure from
+ * the Macromedia Flash (SWF) File Format Specification. It was introduced in
+ * Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSButtonEvent implements Cloneable, Codeable
+{
+	/**
+	 * Defines the button event that occurs when the mouse cursor moves over the
+	 * active area of a button.
+	 */
+	public static final int RollOver = 1;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;RollOver&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves over the active area of a button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;RollOut&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves out of the active area of a button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Press&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is over the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Release&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and released while the mouse cursor is over the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOut&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged out of the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOver&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged into the active area of the button and the mouse button is released.&lt;/td&gt;&lt;/tr&gt;
-&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the mouse cursor moves out of
+	 * the active area of a button.
+	 */
+	public static final int RollOut = 2;
 
-&lt;p&gt;When a button is configured as a menu item (FSDefineButton2 objects only) then three additional events can occur:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked
+	 * while the mouse cursor is over the active area of the button.
+	 */
+	public static final int Press = 4;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;MenuDragOver&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the menu item.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MenuDragOut&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse
-cursor is dragged out of the active area of the menu item.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;ReleaseOut&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the menu item.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * released while the mouse cursor is over the active area of the button.
+	 */
+	public static final int Release = 8;
 
-&lt;p&gt;In addition to responding to mouse events, buttons also respond to keys being pressed on the keyboard. Keyboard events are defined by the character key being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;, etc. For control keys a number of reserved names are supported:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged out of the active area of the button.
+	 */
+	public static final int DragOut = 16;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Left&gt;&lt;/td&gt;&lt;td&gt;Left arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Right&gt;&lt;/td&gt;&lt;td&gt;Right arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Home&gt;&lt;/td&gt;&lt;td&gt;Home key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;End&gt;&lt;/td&gt;&lt;td&gt;End key&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Insert&gt;&lt;/td&gt;&lt;td&gt;Insert key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Delete&gt;&lt;/td&gt;&lt;td&gt;Delete key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Backspace&gt;&lt;/td&gt;&lt;td&gt;Backspace key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Enter&gt;&lt;/td&gt;&lt;td&gt;Enter (return) key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Up&gt;&lt;/td&gt;&lt;td&gt;Up arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Down&gt;&lt;/td&gt;&lt;td&gt;Down arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Pageup&gt;&lt;/td&gt;&lt;td&gt;Page up key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Pagedown&gt;&lt;/td&gt;&lt;td&gt;Page down key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Tab&gt;&lt;/td&gt;&lt;td&gt;Tab key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Escape&gt;&lt;/td&gt;&lt;td&gt;Escape key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Space&gt;&lt;/td&gt;&lt;td&gt;Space bar.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged into the active area of the button.
+	 */
+	public static final int DragOver = 32;
 
-&lt;p&gt;Since the event code allows multiple events, the code for compound events can be created by performing a bit-wise Or of the individual codes:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked,
+	 * the mouse cursor is dragged into the active area of the button and the
+	 * mouse button is released.
+	 */
+	public static final int ReleaseOut = 64;
 
-&lt;pre&gt;
-int eventCode = FSButtonEvent.RollOver | FSButtonEvent.Press;&quot;;
-&lt;/pre&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged into the active area of the menu item.
+	 */
+	public static final int MenuDragOver = 128;
 
-&lt;p&gt;The class method &lt;b&gt;codeForKey&lt;/b&gt; returns the event code that identifies when a specific key is pressed:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged out of the active area of the menu item.
+	 */
+	public static final int MenuDragOut = 256;
 
-&lt;pre&gt;
-int eventCode = FSButtonEvent.codeForKey('J');
-&lt;/pre&gt;
+	/**
+	 * Defines the button event that occurs when the left arrow key is pressed
+	 * on the keyboard.
+	 */
+	public static final int Left = 512;
 
-&lt;p&gt;Control keys are identified using one of the reserved ButtonEvent values:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the right arrow key is pressed
+	 * on the keyboard.
+	 */
+	public static final int Right = 1024;
 
-&lt;pre&gt;
-int eventCode = FSButtonEvent.Enter | FSButtonEvent.PageUp;
-&lt;/pre&gt;
+	/**
+	 * Defines the button event that occurs when the home key is pressed on the
+	 * keyboard.
+	 */
+	public static final int Home = 1536;
 
-&lt;p&gt;However while multiple mouse events can be defined for a button only one keyboard event can be defined.&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the end key is pressed on the
+	 * keyboard.
+	 */
+	public static final int End = 2048;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Defines the button event that occurs when the insert key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Insert = 2560;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Defines the button event that occurs when the delete key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Delete = 3072;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonEvent_0&quot;&gt;event&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;a code identifying the different types of button events that the actions defined in this object will be executed in response to.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Defines the button event that occurs when the backspace key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Backspace = 4096;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSButtonEvent_1&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of action objects that are executed when the events defined in the event code occur.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Defines the button event that occurs when the enter key is pressed on the
+	 * keyboard.
+	 */
+	public static final int Enter = 6656;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSButtonEvent_2&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded actions are typically generated by the parser in the Translate framework. The actions array and encodedActions cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the up arrow key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Up = 7168;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Defines the button event that occurs when the down arrow key is pressed
+	 * on the keyboard.
+	 */
+	public static final int Down = 7680;
 
-&lt;p&gt;The FSButtonEvent class represents the ButtonCondAction data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt; */  
-public class FSButtonEvent extends FSTransformObject
-{
-    /** Defines the button event that occurs when the mouse cursor moves over the active area of a button. */
-    public static final int RollOver = 1;
-    /** Defines the button event that occurs when the mouse cursor moves out of the active area of a button. */
-    public static final int RollOut = 2;
-    /** Defines the button event that occurs when the mouse button is clicked while the mouse cursor is over the active area of the button. */
-    public static final int Press = 4;
-    /** Defines the button event that occurs when the mouse button is clicked and released while the mouse cursor is over the active area of the button. */
-    public static final int Release = 8;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged out of the active area of the button. */
-    public static final int DragOut = 16;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the button. */
-    public static final int DragOver = 32;
-    /** Defines the button event that occurs when the mouse button is clicked, the mouse cursor is dragged into the active area of the button and the mouse button is released. */
-    public static final int ReleaseOut = 64;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the menu item. */
-    public static final int MenuDragOver = 128;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged out of the active area of the menu item. */
-    public static final int MenuDragOut = 256;
+	/**
+	 * Defines the button event that occurs when the page up key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Pageup = 8192;
 
-    /** Defines the button event that occurs when the left arrow key is pressed on the keyboard. */
-    public static final int Left = 512;
-    /** Defines the button event that occurs when the right arrow key is pressed on the keyboard. */
-    public static final int Right = 1024;
-    /** Defines the button event that occurs when the home key is pressed on the keyboard. */
-    public static final int Home = 1536;
-    /** Defines the button event that occurs when the end key is pressed on the keyboard. */
-    public static final int End = 2048;
-    /** Defines the button event that occurs when the insert key is pressed on the keyboard. */
-    public static final int Insert = 2560;
-    /** Defines the button event that occurs when the delete key is pressed on the keyboard. */
-    public static final int Delete = 3072;
-    /** Defines the button event that occurs when the backspace key is pressed on the keyboard. */
-    public static final int Backspace = 4096;
-    /** Defines the button event that occurs when the enter key is pressed on the keyboard. */
-    public static final int Enter = 6656;
-    /** Defines the button event that occurs when the up arrow key is pressed on the keyboard. */
-    public static final int Up = 7168;
-    /** Defines the button event that occurs when the down arrow key is pressed on the keyboard. */
-    public static final int Down = 7680;
-    /** Defines the button event that occurs when the page up key is pressed on the keyboard. */
-    public static final int Pageup = 8192;
-    /** Defines the button event that occurs when the page down key is pressed on the keyboard. */
-    public static final int Pagedown = 8704;
-    /** Defines the button event that occurs when the tab key is pressed on the keyboard. */
-    public static final int Tab = 9216;
-    /** Defines the button event that occurs when the escape key is pressed on the keyboard. */
-    public static final int Escape = 9728;
-    /** Defines the button event that occurs when the space bar is pressed on the keyboard. */
-    public static final int Space = 16384;
+	/**
+	 * Defines the button event that occurs when the page down key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Pagedown = 8704;
 
-    /** Generates the code identifying a particular event using the name of the event.
+	/**
+	 * Defines the button event that occurs when the tab key is pressed on the
+	 * keyboard.
+	 */
+	public static final int Tab = 9216;
 
-        @param c a keyboard character.
-        @return the event code corresponding to the specified event.
-        */
-    public static int codeForKey(char c)
-    {
-        return c &lt;&lt; 9;
-    }
+	/**
+	 * Defines the button event that occurs when the escape key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Escape = 9728;
 
-    private int event = 0;
-    private int length = 0;
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-   
-    /**
-     * Construct an FSButtonEvent object, initializing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButtonEvent(FSCoder coder, int len)
-    {
-        length = len-2;
-        decode(coder);
-    }
-    /** Constructs an FSButtonEvent object that defines the array of actions that will be executed when a particular event occurs.
+	/**
+	 * Defines the button event that occurs when the space bar is pressed on the
+	 * keyboard.
+	 */
+	public static final int Space = 16384;
 
-        @param aNumber the event code.
-        @param anArray the array of action objects that will be executed when the specified event(s) occur.
-        */
-    public FSButtonEvent(int aNumber, ArrayList anArray)
-    {
-        setEvent(aNumber);
-        setActions(anArray);
-    }
-    /** 
-     * Constructs an FSButtonEvent object that defines the array of actions that 
-     * will be executed when a particular event occurs.
-     * 
-     * @param aNumber the event code.
-     * @param bytes an array of encoded action objects.
-     */
-    public FSButtonEvent(int aNumber, byte[] bytes)
-    {
-        setEvent(aNumber);
-        setEncodedActions(bytes);
-    }
-    /**
-     * Constructs an FSButtonEvent object by copying values from an existing object.
-     *
-     * @param obj an FSButtonEvent object.
-     */
-    public FSButtonEvent(FSButtonEvent obj)
-    {
-        event = obj.event;
-        
-        if (obj.actions != null)
-        {
-            actions = new ArrayList();
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }
+	/**
+	 * Generates the code identifying a particular event using the name of the
+	 * event.
+	 * 
+	 * @param c
+	 *            a keyboard character.
+	 * @return the event code corresponding to the specified event.
+	 */
+	public static int codeForKey(char c)
+	{
+		return c &lt;&lt; 9;
+	}
 
+	private int event = 0;
 
-    /** Add an action to the end of the actions array.
-        
-        @param anAction an object derived from the base class FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+	private int length = 0;
 
-    /** Gets the event code that this FSButtonEvent defines actions for.
+	private ArrayList actions = null;
 
-        @return the compound event code.
-        */
-    public int getEvent()
-    {
-        return event;
-    }
+	private byte[] encodedActions = null;
 
-    /** Gets the array of actions that are executed by the button in response to specified event(s).
+	/**
+	 * Construct an FSButtonEvent object, initializing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButtonEvent(FSCoder coder, int len)
+	{
+		length = len - 2;
+		decode(coder);
+	}
 
-        @return the array of action objects that will be executed when the specified event(s) occur.
-        */   
-    public ArrayList getActions()
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+	/**
+	 * Constructs an FSButtonEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param aNumber
+	 *            the event code.
+	 * @param anArray
+	 *            the array of action objects that will be executed when the
+	 *            specified event(s) occur.
+	 */
+	public FSButtonEvent(int aNumber, ArrayList anArray)
+	{
+		setEvent(aNumber);
+		setActions(anArray);
+	}
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** Sets the event code that this FSButtonEvent defines actions for.
+	/**
+	 * Constructs an FSButtonEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param aNumber
+	 *            the event code.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSButtonEvent(int aNumber, byte[] bytes)
+	{
+		setEvent(aNumber);
+		setEncodedActions(bytes);
+	}
 
-        @param aNumber the event code.
-        */
-    public void setEvent(int aNumber)
-    {
-        event = aNumber;
-    }
+	/**
+	 * Constructs an FSButtonEvent object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSButtonEvent object.
+	 */
+	public FSButtonEvent(FSButtonEvent obj)
+	{
+		event = obj.event;
 
-    /** Sets the array of actions that are executed by the button in response to specified event(s).
+		if (obj.actions != null)
+		{
+			actions = new ArrayList();
 
-        @param anArray the array of action objects that will be executed when the specified event(s) occur.
-        */  
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-   }
+	/**
+	 * Add an action to the end of the actions array.
+	 * 
+	 * @param anAction
+	 *            an object derived from the base class FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-    public Object clone()
-    {
-        FSButtonEvent anObject = (FSButtonEvent)super.clone();
+	/**
+	 * Gets the event code that this FSButtonEvent defines actions for.
+	 * 
+	 * @return the compound event code.
+	 */
+	public int getEvent()
+	{
+		return event;
+	}
 
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+	/**
+	 * Gets the array of actions that are executed by the button in response to
+	 * specified event(s).
+	 * 
+	 * @return the array of action objects that will be executed when the
+	 *         specified event(s) occur.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSButtonEvent typedObject = (FSButtonEvent)anObject;
-            
-            result = event == typedObject.event;                
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-            if (actions != null)
-                result = actions.equals(typedObject.actions);
-            else
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+	/**
+	 * Sets the event code that this FSButtonEvent defines actions for.
+	 * 
+	 * @param aNumber
+	 *            the event code.
+	 */
+	public void setEvent(int aNumber)
+	{
+		event = aNumber;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	/**
+	 * Sets the array of actions that are executed by the button in response to
+	 * specified event(s).
+	 * 
+	 * @param anArray
+	 *            the array of action objects that will be executed when the
+	 *            specified event(s) occur.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;event&quot;, event);
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+	public Object clone()
+	{
+		FSButtonEvent anObject = null;
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    {
-        length = 2;
-    
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+		try {
+		    anObject = (FSButtonEvent) super.clone();
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(event, 2);
+			if (actions != null)
+			{
+				anObject.actions = new ArrayList();
 
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int length = action.getLength();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (length &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+				for (Iterator i = actions.iterator(); i.hasNext();)
+					anObject.actions.add(((FSActionObject) i.next()).clone());
+			} else
+			{
+				anObject.encodedActions = Transform.clone(encodedActions);
+			}
+		} 
+		catch (CloneNotSupportedException e) {
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        event = coder.readWord(2, false);
-        
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-            int start;
-            
-            while (length &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length];
-            coder.readBytes(encodedActions);
-        }
-    }
+		if (super.equals(anObject))
+		{
+			FSButtonEvent typedObject = (FSButtonEvent) anObject;
+
+			result = event == typedObject.event;
+
+			if (actions != null)
+				result = actions.equals(typedObject.actions);
+			else
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+		}
+		return result;
+	}
+
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
+
+		buffer.append(&quot;FSButtonEvent: { &quot;);
+		buffer.append(&quot;event = &quot;).append(event).append(&quot;; &quot;);
+
+		if (actions != null)
+			buffer.append(&quot;actions = &quot;).append(actions.toString()).append(&quot;; &quot;);
+		else
+			buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+
+		buffer.append(&quot;}&quot;);
+
+		return buffer.toString();
+	}
+
+	public int length(FSCoder coder)
+	{
+		length = 2;
+
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
+
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
+
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(event, 2);
+
+		if (actions != null)
+		{
+			FSActionObject action = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int length = action.getLength();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (length &lt;&lt; 3);
+
+				action.encode(coder);
+				coder.setPointer(next);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		event = coder.readWord(2, false);
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
+
+			int start;
+
+			while (length &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSActionObject.decodeAction(coder));
+				length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[length];
+			coder.readBytes(encodedActions);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSButtonSound.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSButtonSound.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSButtonSound.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,281 +31,327 @@
 package com.flagstone.transform;
 
 /**
-FSButtonSound defines the sounds that are played when an event occurs in a button. 
- 
-&lt;p&gt;A sound is played for only a subset of the events that a button responds to:&lt;/p&gt;
+ * FSButtonSound defines the sounds that are played when an event occurs in a
+ * button.
+ * 
+ * &lt;p&gt;
+ * A sound is played for only a subset of the events that a button responds to:
+ * &lt;/p&gt;
+ * 
+ * &lt;table&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;rollOut&lt;/td&gt;
+ * &lt;td&gt;The cursor exits the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;rollOver&lt;/td&gt;
+ * &lt;td&gt;The cursor enters the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;press&lt;/td&gt;
+ * &lt;td&gt;The mouse button is clicked and the cursor is inside the active area of
+ * the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;release&lt;/td&gt;
+ * &lt;td&gt;The mouse button is released while the cursor is inside the active area
+ * of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;table&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;the identifier of an FSDefineButton or FSDefineButton2 object that
+ * define the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[rollOut]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * rollOver event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[rollOver]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * rollOver event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[press]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * press event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[release]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * release event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Important:&lt;/b&gt; If the identifier in the FSSound object for an event is
+ * set to zero then the corresponding FSSound object will not be encoded when
+ * the object is encoded to a Flash file. This compresses the object when the
+ * sounds for only a sub-set of the events are defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButtonSound class represents the DefineButtonSound structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
+ */
+public class FSButtonSound extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;table&gt;
-&lt;tr&gt;&lt;td&gt;rollOut&lt;/td&gt;&lt;td&gt;The cursor exits the active area of the button.&lt;/td&gt;&lt;/tr&gt; 
-&lt;tr&gt;&lt;td&gt;rollOver&lt;/td&gt;&lt;td&gt;The cursor enters the active area of the button.&lt;/td&gt;&lt;/tr&gt; 
-&lt;tr&gt;&lt;td&gt;press&lt;/td&gt;&lt;td&gt;The mouse button is clicked and the cursor is inside the active area of the button.&lt;/td&gt;&lt;/tr&gt; 
-&lt;tr&gt;&lt;td&gt;release&lt;/td&gt;&lt;td&gt;The mouse button is released while the cursor is inside the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	private FSSound[] sound = new FSSound[]
+	{
+		null, null, null, null };
 
-&lt;table&gt;
+	/**
+	 * Construct an FSButtonSound object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButtonSound(FSCoder coder)
+	{
+		super(ButtonSound);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonSound object that defines the sound played for a
+	 * single button event.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the FSDefineButton or FSDefineButton2 object
+	 *            that defines the button.
+	 * @param eventCode
+	 *            the event that identifies when the sound id played, must be
+	 *            either FSButtonEvent.rollOver, FSButtonEvent.rollOut,
+	 *            FSButtonEvent.press or FSButtonEvent.release.
+	 * @param aSound
+	 *            an FSSound object that identifies a sound and controls how it
+	 *            is played.
+	 */
+	public FSButtonSound(int anIdentifier, int eventCode, FSSound aSound)
+	{
+		super(ButtonSound);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+		setIdentifier(anIdentifier);
+		setSoundForEvent(eventCode, aSound);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;the identifier of an FSDefineButton or FSDefineButton2 object that define the button.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonSound object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSButtonSound object.
+	 */
+	public FSButtonSound(FSButtonSound obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_3&quot;&gt;sound[rollOut]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a rollOver event.&lt;/td&gt;
-&lt;/tr&gt;
+		identifier = obj.identifier;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_2&quot;&gt;sound[rollOver]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a rollOver event.&lt;/td&gt;
-&lt;/tr&gt;
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (obj.sound[i] != null)
+				sound[i] = new FSSound(obj.sound[i]);
+		}
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_4&quot;&gt;sound[press]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a press event.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the button that this object applies to.
+	 * 
+	 * @return the identifier of the button.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_5&quot;&gt;sound[release]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a release event.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the FSSound object for the specified event.
+	 * 
+	 * @param eventCode
+	 *            the code representing the button event, must be either
+	 *            FSButtonEvent.rollOver, FSButtonEvent.rollOut,
+	 *            FSButtonEvent.press or FSButtonEvent.release.
+	 * @return the FSSound that identifies and controls the sound that will be
+	 *         played for the event.
+	 */
+	public FSSound getSoundForEvent(int eventCode)
+	{
+		FSSound aSound = null;
 
-&lt;/table&gt;
+		if (eventCode == FSButtonEvent.RollOut)
+			aSound = sound[0];
+		else if (eventCode == FSButtonEvent.RollOver)
+			aSound = sound[1];
+		else if (eventCode == FSButtonEvent.Press)
+			aSound = sound[2];
+		else
+			aSound = sound[3];
 
-&lt;p&gt;&lt;b&gt;Important:&lt;/b&gt; If the identifier in the FSSound object for an event is set to zero then the corresponding FSSound object will not be encoded when the object is encoded to a Flash file. This compresses the object when the sounds for only a sub-set of the events are defined.&lt;/p&gt;
+		return aSound;
+	}
 
- &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the identifier of the button that this object applies to.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the button which this object applies to.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;p&gt;The FSButtonSound class represents the DefineButtonSound structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSButtonSound extends FSMovieObject
-{
-    private int identifier = 0;
-    private FSSound[] sound = new FSSound[] {null, null, null, null};
-    
-    /**
-     * Construct an FSButtonSound object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButtonSound(FSCoder coder)
-    {
-        super(ButtonSound);
-        decode(coder);
-    }
-    /**  Constructs an FSButtonSound object that defines the sound played for a single button event.
+	/**
+	 * Sets the FSSound object for the specified button event.
+	 * 
+	 * @param eventCode
+	 *            the code representing the button event, must be either
+	 *            FSButtonEvent.rollOver, FSButtonEvent.rollOut,
+	 *            FSButtonEvent.press or FSButtonEvent.release.
+	 * @param aSound
+	 *            an FSSound object that identifies and controls how the sound
+	 *            is played.
+	 */
+	public void setSoundForEvent(int eventCode, FSSound aSound)
+	{
+		if (eventCode == FSButtonEvent.RollOut)
+			sound[0] = aSound;
+		else if (eventCode == FSButtonEvent.RollOver)
+			sound[1] = aSound;
+		else if (eventCode == FSButtonEvent.Press)
+			sound[2] = aSound;
+		else
+			sound[3] = aSound;
+	}
 
-        @param anIdentifier the identifier of the FSDefineButton or FSDefineButton2 object that defines the button.
-        @param eventCode the event that identifies when the sound id played, must be either FSButtonEvent.rollOver, FSButtonEvent.rollOut, FSButtonEvent.press or FSButtonEvent.release.
-        @param aSound an FSSound object that identifies a sound and controls how it is played.
-        */
-    public FSButtonSound(int anIdentifier, int eventCode, FSSound aSound)
-    {
-        super(ButtonSound);
-        
-        setIdentifier(anIdentifier);
-        setSoundForEvent(eventCode, aSound);
-    }
-    /**
-     * Constructs an FSButtonSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSButtonSound object.
-     */
-    public FSButtonSound(FSButtonSound obj)
-    {
-        super(obj);
-        
-        identifier = obj.identifier;
-        
-        for (int i=0; i&lt;4; i++)
-        {
-            if (obj.sound[i] != null)
-                sound[i] = new FSSound(obj.sound[i]);
-        }
-    }
+	public Object clone()
+	{
+		FSButtonSound anObject = (FSButtonSound) super.clone();
 
-    /** Gets the identifier of the button that this object applies to.
+		for (int i = 0; i &lt; 4; i++)
+		{
+			anObject.sound[i] = (sound[i] != null) ? (FSSound) sound[i].clone()
+							: null;
+		}
 
-        @return the identifier of the button.
-        */
-    public int getIdentifier() { return identifier; }
+		return anObject;
+	}
 
-    /** Gets the FSSound object for the specified event.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param eventCode the code representing the button event, must be either FSButtonEvent.rollOver, FSButtonEvent.rollOut, FSButtonEvent.press or FSButtonEvent.release.
-        @return the FSSound that identifies and controls the sound that will be played for the event.
-        */
-    public FSSound getSoundForEvent(int eventCode)
-    {
-        FSSound aSound = null;
-        
-        if (eventCode == FSButtonEvent.RollOut)
-            aSound = sound[0];
-        else if (eventCode == FSButtonEvent.RollOver)
-            aSound = sound[1];
-        else if (eventCode == FSButtonEvent.Press)
-            aSound = sound[2];
-        else
-            aSound = sound[3];
-            
-        return aSound;
-    }
+		if (super.equals(anObject))
+		{
+			FSButtonSound typedObject = (FSButtonSound) anObject;
 
-    /** Sets the identifier of the button that this object applies to.
+			result = identifier == typedObject.identifier;
 
-        @param anIdentifier the identifier of the button which this object applies to.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+			for (int i = 0; i &lt; 4; i++)
+			{
+				if (sound[i] != null)
+					result = result &amp;&amp; sound[i].equals(typedObject.sound[i]);
+				else
+					result = result &amp;&amp; sound[i] == typedObject.sound[i];
+			}
+		}
+		return result;
+	}
 
-    /** Sets the FSSound object for the specified button event. 
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param eventCode the code representing the button event, must be either FSButtonEvent.rollOver, FSButtonEvent.rollOut, FSButtonEvent.press or FSButtonEvent.release.
-        @param aSound an FSSound object that identifies and controls how the sound is played.
-        */
-    public void setSoundForEvent(int eventCode, FSSound aSound)
-    {
-        if (eventCode == FSButtonEvent.RollOut)
-            sound[0] = aSound;
-        else if (eventCode == FSButtonEvent.RollOver)
-            sound[1] = aSound;
-        else if (eventCode == FSButtonEvent.Press)
-            sound[2] = aSound;
-        else
-            sound[3] = aSound;
-    }
+		buffer.append(&quot;FSButtonSound: {&quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
 
-    public Object clone()
-    {
-        FSButtonSound anObject = (FSButtonSound)super.clone();
-                
-        for (int i=0; i&lt;4; i++)
-        {
-            anObject.sound[i] = (sound[i] != null) ? (FSSound)sound[i].clone() : null;
-        }
+		for (int i=0; i&lt;4; i++) {
+			buffer.append(&quot;sound[&quot;+i+&quot;] =&quot;).append(sound[i]);
+		}
 
-        return anObject;
-    }
+		buffer.append(&quot;}&quot;);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSButtonSound typedObject = (FSButtonSound)anObject;
-            
-            result = identifier == typedObject.identifier;
+		return buffer.toString();
+	}
 
-            for (int i=0; i&lt;4; i++)
-            {
-                if (sound[i] != null)
-                    result = result &amp;&amp; sound[i].equals(typedObject.sound[i]);
-                else
-                    result = result &amp;&amp; sound[i] == typedObject.sound[i];
-            }
-        }
-        return result;
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(name() + &quot;: {&quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
+		length += 2;
 
-            if (depth-1 &gt; 0)
-            {
-                for (int i=0; i&lt;4; i++)
-                {
-                    buffer.append(&quot;sound[&quot; + i + &quot;] = &quot;);
-                
-                    if (sound[i] != null)
-                        sound[i].appendDescription(buffer, depth);
-                    else
-                        buffer.append(&quot;null; &quot;);
-                }
-            }
-            else
-            {    
-                for (int i=0; i&lt;4; i++)
-                {
-                    buffer.append(&quot;sound[&quot; + i + &quot;] =&quot;);
-                
-                    if (sound[i] != null)
-                        Transform.append(buffer, sound[i].name(), depth);
-                    else
-                        buffer.append(&quot;null&quot;);
-                }
-            }
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
+				length += sound[i].length(coder);
+			else
+				length += 2;
+		}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 2;
-        
-        for (int i=0; i&lt;4; i++)
-        {
-            if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
-                length += sound[i].length(coder);
-            else
-                length += 2;
-        }
-        
-        return length;
-    }
+		return length;
+	}
 
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        for (int i=0; i&lt;4; i++)
-        {
-            if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
-                sound[i].encode(coder);
-            else
-                coder.writeWord(0, 2);
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        int start = coder.getPointer();
+		coder.writeWord(identifier, 2);
 
-        identifier = coder.readWord(2, false);
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
+				sound[i].encode(coder);
+			else
+				coder.writeWord(0, 2);
+		}
+	}
 
-        for (int i=0; i&lt;4; i++)
-        {
-            if (coder.scanWord(2, false) &gt; 0)
-                sound[i] = new FSSound(coder);
-            else
-                coder.readWord(2, false);
-            
-            if (((coder.getPointer() - start) &gt;&gt;&gt; 3) == length)
-                break;
-        }
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		int start = coder.getPointer();
+
+		identifier = coder.readWord(2, false);
+
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (coder.scanWord(2, false) &gt; 0)
+				sound[i] = new FSSound(coder);
+			else
+				coder.readWord(2, false);
+
+			if (((coder.getPointer() - start) &gt;&gt;&gt; 3) == length)
+				break;
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSCall.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSCall.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSCall.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,101 +31,101 @@
 package com.flagstone.transform;
 
 /**
-FSCall is used to execute the actions previously assigned to a given frame with an FSDoAction object.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSCall is used to execute the actions previously assigned to a given frame
+ * with an FSDoAction object.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;type&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSCall is a stack-based action, the value for the &lt;i&gt;frame name&lt;/i&gt; or
+ * &lt;i&gt;frame number&lt;/i&gt; is retrieved from the top of the stack when it is
+ * executed.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The following code fragment show how to execute the actions associated with a
+ * given frame number from a Flash movie:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(12));
+ * actions.add(new FSCall());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Alternatively if the frame has been assigned a name using an FSFrameLabel
+ * object then the associated actions may be executed by using the name as a
+ * reference:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+ * ...
+ * actions.add(new FSPush(&quot;FirstFrame&quot;));
+ * actions.add(new FSCall());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCall class represents the ActionCall action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSCall extends FSActionObject
+{
+	private static final FSCall instance = new FSCall();
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Returns a canonical FSCall object.
+	 * 
+	 * @return an object that can safely be shared among objects.
+	 */
+	public static FSCall getInstance()
+	{
+		return instance;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCall_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSCall object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSCall(FSCoder coder)
+	{
+		super(Call);
+		decode(coder);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSCall object.
+	 */
+	public FSCall()
+	{
+		super(Call);
+	}
 
-&lt;p&gt;FSCall is a stack-based action, the value for the &lt;i&gt;frame name&lt;/i&gt; or &lt;i&gt;frame number&lt;/i&gt; is retrieved from the top of the stack when it is executed.&lt;/p&gt;
-
-&lt;p&gt;The following code fragment show how to execute the actions associated with a given frame number from a Flash movie:&lt;/p&gt;
-
-&lt;pre&gt;
-actions.add(new FSPush(12));
-actions.add(new FSCall());
-&lt;/pre&gt;
-
-&lt;p&gt;Alternatively if the frame has been assigned a name using an FSFrameLabel object then the associated actions may be executed by using the name as a reference:&lt;/p&gt;
-
-&lt;pre&gt;
-movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
-...
-actions.add(new FSPush(&quot;FirstFrame&quot;));
-actions.add(new FSCall());
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSCall class represents the ActionCall action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSCall extends FSActionObject
-{
-    private static final FSCall instance = new FSCall();
-    
-    /**
-     * Returns a canonical FSCall object.
-     * 
-     * @return an object that can safely be shared among objects.
-     */
-    public static FSCall getInstance()
-    {
-        return instance;
-    }
-    /**
-     * Construct an FSCall object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSCall(FSCoder coder)
-    {
-        super(Call);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSCall object. 
-     */
-    public FSCall()
-    {
-        super(Call);
-    }
-    /**
-     * Constructs an FSCall object by copying values from an existing object.
-     *
-     * @param obj an FSCall object.
-     */
-    public FSCall(FSCall obj)
-    {
-        super(obj);
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
-    
-    public int length(FSCoder coder)
-    {
-        return super.length(coder);
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        coder.endObject(name());
-    }
+	/**
+	 * Constructs an FSCall object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSCall object.
+	 */
+	public FSCall(FSCall obj)
+	{
+		super(obj);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSClipEvent.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSClipEvent.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSClipEvent.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,609 +33,828 @@
 import java.util.*;
 
 /**
-FSClipEvent is used to define the actions that a movie clip will execute in response 
-to a particular event.
+ * FSClipEvent is used to define the actions that a movie clip will execute in
+ * response to a particular event.
+ * 
+ * &lt;p&gt;
+ * FSClipEvent objects are added to an FSPlaceObject2 object and the actions are
+ * registered with the Flash Player when the movie clip is added to the display
+ * list.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;event&lt;/td&gt;
+ * &lt;td&gt;A code representing one or more events that the movie clip will respond
+ * to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of actions that will be executed when one or more of the
+ * specified events occur.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The events that a movie clip responds to are:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr bgcolor=&quot;#CCCCFF&quot; valign=&quot;top&quot;&gt;
+ * &lt;th align=&quot;left&quot;&gt;Event&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Load&lt;/td&gt;
+ * &lt;td&gt;occurs when the movie clip is finished loading.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Unload&lt;/td&gt;
+ * &lt;td&gt;occurs when the movie clip is unloaded from the parent movie.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;EnterFrame&lt;/td&gt;
+ * &lt;td&gt;occurs when each frame in the movie clip is played.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MouseMove&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse pointer is moved.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MouseDown&lt;/td&gt;
+ * &lt;td&gt;occurs when the left mouse button is pressed while the cursor is outside
+ * of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MouseUp&lt;/td&gt;
+ * &lt;td&gt;occurs when the left mouse button is pressed and released while the
+ * cursor is outside of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;KeyDown&lt;/td&gt;
+ * &lt;td&gt;occurs when any key is pressed on the keyboard. From Flash 6 a key code
+ * can be specified to identify a specific key rather than testing for the value
+ * inside the actions that are executed in response to the event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;KeyUp&lt;/td&gt;
+ * &lt;td&gt;occurs when any key being pressed on the keyboard is released.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Data&lt;/td&gt;
+ * &lt;td&gt;occurs when an FSGetUrl2 action is executed with the movie clip
+ * specified as a target.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Starting with Flash 6 movie clips also respond to the same set of events that
+ * buttons do:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves over the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves out of the bounding rectangle of the
+ * movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Press&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is inside
+ * bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Release&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and released while the mouse
+ * cursor is inside bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;ReleaseOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is released
+ * outside of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * out of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged
+ * into the bounding rectangle of the movie clip and the mouse button is
+ * released.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Initialize&lt;/td&gt;
+ * &lt;td&gt;occurs when a movie clip is initialized using the FSInitialize class.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Movie clips now also respond to keys being pressed on the keyboard. Keyboard
+ * events are defined by the character key being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;,
+ * etc. The ASCII code for the key is used to identify which key was pressed.
+ * Note that while multiple mouse events can be defined for a button only one
+ * keyboard event can be defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * In Flash 7 a new construct event was added.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Construct&lt;/td&gt;
+ * &lt;td&gt;The function of this event is undocumented.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * IMPORTANT: The FSClipEvent object supports both the Flash 5, Flash 6 and
+ * Flash 7 event models. The events that are encoded to a file are determined by
+ * the version of the FSMovie in which the object is contained. The codes
+ * assigned to the different types of event ensure that the same value can be
+ * used to encode the object for each version of Flash.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For the KeyDown and KeyUp events, Flash ActionScript provides the Key object
+ * which contains the getCode() and isDown() functions that allow code to be
+ * written to test which key was pressed. Note that ActionScript is a high-level
+ * interpreted language similar to JavaScript. Transform supports actions that
+ * represent the compiled version of the ActionScript code. To create and
+ * compile ActionScript code then use Transform's sister product, Translate.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Each type of event is defined by a constant, for example, Load, EnterFrame,
+ * etc. An FSClipEvent object can define the actions that will be executed in
+ * response to multiple events. There are two ways to respond to multiple
+ * events. If the same set of actions should be executed then the event code
+ * that flags which events should be responded to can be generated by bitwise
+ * OR-ing together the individual constants:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int loadAndMouseMove = FSClipEvent.Load | FSClipEvent.MouseMove;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * If different actions should be executed then an FSClipEvent object is created
+ * for each different set of events. The FSPlaceObject2 object that is used to
+ * register the actions for a movie clip with the Flash Player supports an array
+ * of FSClipEvent objects.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The array of actions may be empty. Although this situation does not perform
+ * any useful operation it is valid and may be encountered when parsing Flash
+ * files generated by a third party.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following simplified code fragments illustrate how the FSClipEvent class
+ * can be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Defining the actions for a single event.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  FSClipEvent clipEvent(FSClipEvent.MouseDown);
+ * 
+ *  clipEvent.add(anAction);
+ *  ...
+ * 
+ *  FSPlaceObject2 placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400);
+ * 
+ *  placeClip.add(clipEvent);
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(placeClip);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Defining the actions for a compound event.&lt;br/&gt; If a movie clip should
+ * execute the same set of actions for different types of event then the code
+ * for the compound event can be created by bitwise-OR'ing individual event
+ * codes.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  FSClipEvent clipEvent(FSClipEvent.MouseDown | FSClipEvent.KeyDown, actions);
+ *  ...
+ *  FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+ * 
+ *  placeClip.add(clipEvent);
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(placeClip);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Defining different sets of actions for events.&lt;br/&gt; An FSClipEvent object
+ * is created for each set of events that a movie clip must respond to.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineMovieClip* movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ *  FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+ * 
+ *  FSClipEvent mouseEvent(FSClipEvent.MouseDown, mouseActions);
+ *  ...
+ *  placeClip.add(clipEvent);
+ * 
+ *  FSClipEvent keyEvent(FSClipEvent.KeyDown, keyActions);
+ *  ...
+ *  placeClip.add(keyEvent);
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(placeClip);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSClipEvent class represents the ClipEvent data structure tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5. The event model was extended in Flash 6 to support the set of events that
+ * Buttons respond to. In Flash 7 the Construct event was added.
+ * &lt;/p&gt;
+ */
+public class FSClipEvent implements Cloneable, Codeable
+{
+	/** Code for a load event. */
+	public static final int Load = 1;
 
-&lt;p&gt;FSClipEvent objects are added to an FSPlaceObject2 object and the actions are registered with the Flash Player when the movie clip is added to the display list.&lt;/p&gt;
+	/** Code for an enter frame event. */
+	public static final int EnterFrame = 2;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Code for an unload event. */
+	public static final int Unload = 4;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Code for a mouse move event. */
+	public static final int MouseMove = 8;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSClipEvent_0&quot;&gt;event&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A code representing one or more events that the movie clip will respond to.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSClipEvent_0&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An array of actions that will be executed when one or more of the specified events occur.&lt;/td&gt;&lt;/tr&gt;
+	/** Code for a mouse down event. */
+	public static final int MouseDown = 16;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSClipEvent_2&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded actions are typically generated by the parser in the Translate framework. The actions array and encodedActions cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Code for a mouse up event. */
+	public static final int MouseUp = 32;
 
-&lt;/table&gt;
+	/** Code for a key down event. */
+	public static final int KeyDown = 64;
 
-&lt;p&gt;The events that a movie clip responds to are:&lt;/p&gt;
+	/** Code for a key up event. */
+	public static final int KeyUp = 128;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr bgcolor=&quot;#CCCCFF&quot; valign=&quot;top&quot;&gt;&lt;th align=&quot;left&quot;&gt;Event&lt;/th&gt;
-&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Load&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the movie clip is finished loading.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Unload&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the movie clip is unloaded from the parent movie.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;EnterFrame&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when each frame in the movie clip is played.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MouseMove&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse pointer is moved.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MouseDown&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the left mouse button is pressed while the cursor is outside of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MouseUp&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the left mouse button is pressed  and released while the cursor is outside of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;KeyDown&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when any key is pressed on the keyboard. From Flash 6  a key code can be specified to identify a specific key rather than testing for the value inside the actions that are executed in response to the event.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;KeyUp&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when any key being pressed on the keyboard is released.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Data&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when an FSGetUrl2 action is executed with the movie clip specified as a target.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Code for a data event. */
+	public static final int Data = 256;
 
-&lt;p&gt;Starting with Flash 6 movie clips also respond to the same set of events that buttons do:&lt;/p&gt;
+	// Flash 6
+	// / Code for an initialize event.
+	public static final int Initialize = 512;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;RollOver&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves over the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;RollOut&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves out of the bounding rectangle  of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Press&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is inside bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Release&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and released while the mouse cursor is inside bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;ReleaseOut&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is released outside of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOut&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged out of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOver&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged into the bounding rectangle of the movie clip and the mouse button is released.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Initialize&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when a movie clip is initialized using the FSInitialize class.&lt;/td&gt;&lt;/tr&gt;
-&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Code for a press event.
+	public static final int Press = 1024;
 
-&lt;p&gt;Movie clips now also respond to keys being pressed on the keyboard. Keyboard events are defined by the character key being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;, etc. The ASCII code for the key is used to identify which key was pressed. Note that while multiple mouse events can be defined for a button only one keyboard event can be defined.&lt;/p&gt;
+	// / Code for a release event.
+	public static final int Release = 2048;
 
-&lt;p&gt;In Flash 7 a new construct event was added.&lt;/p&gt;
-    
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;Construct&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The function of this event is undocumented.&lt;/td&gt;&lt;/tr&gt;
-&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Code for a release outside event.
+	public static final int ReleaseOut = 4096;
 
-&lt;p&gt;IMPORTANT: The FSClipEvent object supports both the Flash 5, Flash 6 and Flash 7 event models. The events that are encoded to a file are determined by the version of the FSMovie in which the object is contained. The codes assigned to the different types of event ensure that the same value can be used to encode the object for each version of Flash.&lt;/p&gt;
+	// / Code for a roll over event.
+	public static final int RollOver = 8192;
 
-&lt;p&gt;For the KeyDown and KeyUp events, Flash ActionScript provides the Key object which contains the getCode() and isDown() functions that allow code to be written to test which key was pressed. Note that ActionScript is a high-level interpreted language similar to JavaScript. Transform supports actions that represent the compiled version of the ActionScript code. To create and compile ActionScript code then use Transform's sister product, Translate.&lt;/p&gt;
+	// / Code for a roll out event.
+	public static final int RollOut = 16384;
 
-&lt;p&gt;Each type of event is defined by a constant, for example, Load, EnterFrame, etc. An FSClipEvent object can define the actions that will be executed in response to multiple events. There are two ways to respond to multiple events. If the same set of actions should be executed then the event code that flags which events should be responded to can be generated by bitwise OR-ing together the individual constants:&lt;/p&gt;
+	// / Code for a drag over event.
+	public static final int DragOver = 32768;
 
-&lt;pre&gt;
-int loadAndMouseMove = FSClipEvent.Load | FSClipEvent.MouseMove;
-&lt;/pre&gt;
+	// / Code for a drag out event.
+	public static final int DragOut = 65536;
 
-&lt;p&gt;If different actions should be executed then an FSClipEvent object is created for each different set of events. The FSPlaceObject2 object that is used to register the actions for a movie clip with the Flash Player supports an array of FSClipEvent objects.&lt;/p&gt;
+	// / Code for a key press event, where the code for the key is specified.
+	public static final int KeyPress = 131072;
 
-&lt;p&gt;The array of actions may be empty. Although this situation does not perform any useful operation it is valid and may be encountered when parsing Flash files generated by a third party.&lt;/p&gt;
+	// Flash 7
+	// / Code for a construct event.
+	public static final int Construct = 262144;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	private int event = 0;
 
-&lt;p&gt;The following simplified code fragments illustrate how the FSClipEvent class can be used.&lt;/p&gt;
+	private int keyCode = 0; // Flash 6+
 
-&lt;p&gt;1. Defining the actions for a single event.&lt;/p&gt;
+	private ArrayList actions = null;
 
-&lt;pre&gt;
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+	private byte[] encodedActions = null;
 
-FSClipEvent clipEvent(FSClipEvent.MouseDown);
+	/**
+	 * Construct an FSClipEvent object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSClipEvent(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-clipEvent.add(anAction);
-...
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param eventCode
+	 *            the code representing one or more events.
+	 * @param anArray
+	 *            the array of actions that will be executed when the specified
+	 *            event occurs.
+	 */
+	public FSClipEvent(int eventCode, ArrayList anArray)
+	{
+		setEvent(eventCode);
+		setActions(anArray);
+	}
 
-FSPlaceObject2 placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400);
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param eventCode
+	 *            the event code.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSClipEvent(int eventCode, byte[] bytes)
+	{
+		setEvent(eventCode);
+		setEncodedActions(bytes);
+	}
 
-placeClip.add(clipEvent);
+	// Flash 6
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs or when the specified key
+	 * is pressed.
+	 * 
+	 * @param eventCode
+	 *            the code representing one or more events.
+	 * @param keyCode
+	 *            the ASCII code for the key pressed on the keyboard.
+	 * @param anArray
+	 *            the array of actions that will be executed when the specified
+	 *            event occurs.
+	 */
+	public FSClipEvent(int eventCode, int keyCode, ArrayList anArray)
+	{
+		setEvent(eventCode);
+		setKeyCode(keyCode);
+		setActions(anArray);
+	}
 
-movie.add(movieClip);
-movie.add(placeClip);
-&lt;/pre&gt;
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs or when the specified key
+	 * is pressed. The array of bytes contained the encoded actions and is
+	 * typically generated using the classes in the Translate framework.
+	 * 
+	 * @param eventCode
+	 *            the code representing one or more events.
+	 * @param keyCode
+	 *            the ASCII code for the key pressed on the keyboard.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSClipEvent(int eventCode, int keyCode, byte[] bytes)
+	{
+		setEvent(eventCode);
+		setKeyCode(keyCode);
+		setEncodedActions(bytes);
+	}
 
-&lt;p&gt;2. Defining the actions for a compound event.&lt;br/&gt;
-If a movie clip should execute the same set of actions for different types of event then the code for the compound event can be created by bitwise-OR'ing individual event codes.&lt;/p&gt;
+	// End Flash 6
+	/**
+	 * Constructs an FSCall object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSCall object.
+	 */
+	public FSClipEvent(FSClipEvent obj)
+	{
+		event = obj.event;
+		keyCode = obj.keyCode;
 
-&lt;pre&gt;
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+		if (actions != null)
+		{
+			actions = new ArrayList();
 
-FSClipEvent clipEvent(FSClipEvent.MouseDown | FSClipEvent.KeyDown, actions);
-...
-FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-placeClip.add(clipEvent);
+	/**
+	 * Adds an action to the array of actions.
+	 * 
+	 * @param anAction
+	 *            a pointer to an action object.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-movie.add(movieClip);
-movie.add(placeClip);
-&lt;/pre&gt;
+	/**
+	 * Sets the event code that this FSClipEvent defines actions for.
+	 * 
+	 * @param aNumber
+	 *            the code representing one or more events.
+	 */
+	public void setEvent(int aNumber)
+	{
+		event = aNumber;
+	}
 
-&lt;p&gt;3. Defining different sets of actions for events.&lt;br/&gt;
-An FSClipEvent object is created for each set of events that a movie clip must respond to.&lt;/p&gt;
+	/**
+	 * Gets the event code that this FSClipEvent defines actions for.
+	 * 
+	 * @return the eventCode representing the events that the FSClipEvent object
+	 *         will respond to.
+	 */
+	public int getEvent()
+	{
+		return event;
+	}
 
-&lt;pre&gt;
-FSDefineMovieClip* movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
-FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+	// Flash 6
+	/**
+	 * Gets the code for the key that triggers the event when pressed. The code
+	 * is typically the ASCII code for standard western keyboards.
+	 * 
+	 * @return the code for the key that triggers the event.
+	 */
+	public int getKeyCode()
+	{
+		return keyCode;
+	}
 
-FSClipEvent mouseEvent(FSClipEvent.MouseDown, mouseActions);
-...
-placeClip.add(clipEvent);
+	/**
+	 * Sets the code for the key that triggers the event when pressed. The code
+	 * is typically the ASCII code for standard western keyboards.
+	 * 
+	 * @param code
+	 *            the ASCII code for the key that triggers the event.
+	 */
+	public void setKeyCode(int code)
+	{
+		keyCode = code;
+	}
 
-FSClipEvent keyEvent(FSClipEvent.KeyDown, keyActions);
-...
-placeClip.add(keyEvent);
+	// End Flash 6
 
-movie.add(movieClip);
-movie.add(placeClip);
-&lt;/pre&gt;
+	/**
+	 * Sets the array of actions that are executed by the movie clip in response
+	 * to specified event(s).
+	 * 
+	 * @param anArray
+	 *            the array of actions that will be executed when the specified
+	 *            event occurs.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the array of actions that are executed by the movie clip in response
+	 * to specified event(s).
+	 * 
+	 * @return the array of actions that will be executed when the specified
+	 *         event occurs.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-&lt;p&gt;The FSClipEvent class represents the ClipEvent data structure tag from the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5. 
-The event model was extended in Flash 6 to support the set of events that Buttons 
-respond to. In Flash 7 the Construct event was added.&lt;/p&gt;
- */  
-public class FSClipEvent extends FSTransformObject
-{
-/** Code for a load event.*/
-    public static final int Load = 1;
-/** Code for an enter frame event.*/
-    public static final int EnterFrame = 2;
-/** Code for an unload event.*/
-    public static final int Unload = 4;
-/** Code for a mouse move event.*/
-    public static final int MouseMove = 8;
-/** Code for a mouse down event.*/
-    public static final int MouseDown = 16;
-/** Code for a mouse up event.*/
-    public static final int MouseUp = 32;
-/** Code for a key down event.*/
-    public static final int KeyDown = 64;
-/** Code for a key up event.*/
-    public static final int KeyUp = 128;
-/** Code for a data event.*/
-    public static final int Data = 256;
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-// Flash 6
-    /// Code for an initialize event.
-    public static final int Initialize = 512;
-    /// Code for a press event.
-    public static final int Press = 1024;
-    /// Code for a release event.
-    public static final int Release = 2048;
-    /// Code for a release outside event.
-    public static final int ReleaseOut = 4096;
-    /// Code for a roll over event.
-    public static final int RollOver = 8192;
-    /// Code for a roll out event.
-    public static final int RollOut = 16384;
-    /// Code for a drag over event.
-    public static final int DragOver = 32768;
-    /// Code for a drag out event.
-    public static final int DragOut = 65536;
-    /// Code for a key press event, where the code for the key is specified.
-    public static final int KeyPress = 131072;
-// Flash 7
-    /// Code for a construct event.
-    public static final int Construct = 262144;
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
+	public Object clone()
+	{
+		FSClipEvent anObject = null;
 
-    private int event = 0;
-    private int keyCode = 0; // Flash 6+
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-    
-    /**
-     * Construct an FSClipEvent object, initalizing it with values decoded from 
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSClipEvent(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSClipEvent object that defines the array of actions that will be executed when a particular event occurs.
+		try {
+			anObject = (FSClipEvent)super.clone();
 
-        @param eventCode the code representing one or more events.
-        @param anArray the array of actions that will be executed when the specified event occurs.
-        */
-    public FSClipEvent(int eventCode, ArrayList anArray)
-    {
-        setEvent(eventCode);
-        setActions(anArray);
-    }
+			if (actions != null)
+			{
+				anObject.actions = new ArrayList();
 
-    /** 
-     * Constructs an FSClipEvent object that defines the array of actions that 
-     * will be executed when a particular event occurs.
-     * 
-     * @param eventCode the event code.
-     * @param bytes an array of encoded action objects.
-     */
-    public FSClipEvent(int eventCode, byte[] bytes)
-    {
-        setEvent(eventCode);
-        setEncodedActions(bytes);
-    }
+				for (Iterator i = actions.iterator(); i.hasNext();)
+					anObject.actions.add(((FSActionObject) i.next()).clone());
+			} else
+			{
+				anObject.encodedActions = Transform.clone(encodedActions);
+			}
+		} 
+		catch (CloneNotSupportedException e) {
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-// Flash 6
-    /** Constructs an FSClipEvent object that defines the array of actions that will be 
-     *  executed when a particular event occurs or when the specified key is pressed. 
-     * 
-     *  @param eventCode the code representing one or more events.
-     *  @param keyCode the ASCII code for the key pressed on the keyboard.
-     *  @param anArray the array of actions that will be executed when the specified event occurs.
-     */ 
-    public FSClipEvent(int eventCode, int keyCode, ArrayList anArray)
-    {
-        setEvent(eventCode);
-        setKeyCode(keyCode);
-        setActions(anArray);
-    }
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Constructs an FSClipEvent object that defines the array of actions that will be 
-     *  executed when a particular event occurs or when the specified key is pressed.
-     *  The array of bytes contained the encoded actions and is typically generated
-     *  using the classes in the Translate framework.
-     * 
-     *  @param eventCode the code representing one or more events.
-     *  @param keyCode the ASCII code for the key pressed on the keyboard.
-     *  @param bytes an array of encoded action objects.
-     */
-    public FSClipEvent(int eventCode, int keyCode, byte[] bytes)
-    {
-        setEvent(eventCode);
-        setKeyCode(keyCode);
-        setEncodedActions(bytes);
-    }
-// End Flash 6
-    /**
-     * Constructs an FSCall object by copying values from an existing object.
-     *
-     * @param obj an FSCall object.
-     */
-    public FSClipEvent(FSClipEvent obj)
-    {
-        event = obj.event;
-        keyCode = obj.keyCode;
-        
-        if (actions != null)
-        {
-            actions = new ArrayList();
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }
+		if (super.equals(anObject))
+		{
+			FSClipEvent typedObject = (FSClipEvent) anObject;
 
-    /** Adds an action to the array of actions.
-        
-        @param anAction a pointer to an action object.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+			result = event == typedObject.event;
+			// Flash 6
+			result = result &amp;&amp; keyCode == typedObject.keyCode;
+			// End Flash 6
+			if (actions != null)
+				result = actions.equals(typedObject.actions);
+			else
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+		}
+		return result;
+	}
 
-    /** Sets the event code that this FSClipEvent defines actions for.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param aNumber the code representing one or more events.
-        */
-    public void setEvent(int aNumber)
-    {
-        event = aNumber;
-    }
+		buffer.append(&quot;FSClipEvent: { &quot;);
+		buffer.append(&quot;event = &quot;).append(event).append(&quot;; &quot;);
+		// Flash 6
+		buffer.append(&quot;keyCode = &quot;).append(keyCode).append(&quot;; &quot;);
+		// End Flash 6
+		if (actions != null)
+			buffer.append(&quot;actions = &quot;).append(actions.toString()).append(&quot;; &quot;);
+		else
+			buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    /** Gets the event code that this FSClipEvent defines actions for.
+		buffer.append(&quot;}&quot;);
 
-        @return the eventCode representing the events that the FSClipEvent object will respond to.
-        */
-    public int getEvent()
-    {
-        return event;
-    }
+		return buffer.toString();
+	}
 
-// Flash 6
-    /** Gets the code for the key that triggers the event when pressed. The code 
-     *  is typically the ASCII code for standard western keyboards.
-     * 
-     *  @return the code for the key that triggers the event.
-     */
-    public int getKeyCode()
-    {
-        return keyCode;
-    }
+	public int length(FSCoder coder)
+	{
+		int length = 4 + ((coder.context[FSCoder.Version] &gt; 5) ? 4 : 2);
 
-    /** Sets the code for the key that triggers the event when pressed. The code 
-     *  is typically the ASCII code for standard western keyboards.
-     * 
-     *  @param code the ASCII code for the key that triggers the event.
-     */
-    public void setKeyCode(int code)
-    {
-        keyCode = code;
-    }
-// End Flash 6
+		// Flash 6
+		length += ((event &amp; KeyPress) != 0) ? 1 : 0;
+		// End Flash 6
 
-    /** Sets the array of actions that are executed by the movie clip in response to specified event(s).
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-        @param anArray the array of actions that will be executed when the specified event occurs.
-        */  
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-    /** Gets the array of actions that are executed by the movie clip in response to specified event(s).
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-        @return the array of actions that will be executed when the specified event occurs.
-        */   
-    public ArrayList getActions()
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-   }
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSClipEvent anObject = (FSClipEvent)super.clone();
-        
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSClipEvent typedObject = (FSClipEvent)anObject;
-            
-            result = event == typedObject.event;              
-// Flash 6
-            result = result &amp;&amp; keyCode == typedObject.keyCode;              
-// End Flash 6
-            if (actions != null)
-                result = actions.equals(typedObject.actions);
-            else
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+		int offset = 0;
 
-     public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;event&quot;, event);
-// Flash 6
-            Transform.append(buffer, &quot;keyCode&quot;, keyCode);
-// End Flash 6
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
-                
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-    public int length(FSCoder coder)
-    {
-        int length = 4 + ((coder.context[FSCoder.Version] &gt; 5) ? 4 : 2);
-    
-// Flash 6
-        length += ((event &amp; KeyPress) != 0) ? 1 : 0;
-// End Flash 6
-    
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+				offset += currentAction.getLength();
+				offset += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
-        
-        int offset = 0;
-        
-        if (actions != null)
-        {       
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-            	currentAction = (FSActionObject)i.next();
-            
-                offset += currentAction.getLength();
-                offset += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	offset += 1;
-            }
-        }
-        else
-        {
-            offset += encodedActions.length;
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				offset += 1;
+			}
+		} else
+		{
+			offset += encodedActions.length;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	offset += 1;
-            }
-        }
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				offset += 1;
+			}
+		}
 
-// Flash 6
-        offset += ((event &amp; KeyPress) != 0) ? 1 : 0;
-// End Flash 6
-            
-        coder.writeWord(event, eventSize);
-        coder.writeWord(offset, 4);
-            
-// Flash 6
-        if ((event &amp; KeyPress) != 0)
-            coder.writeWord(keyCode, 1);
-// End Flash 6
-        
-        if (actions != null)
-        { 
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int length = action.getLength();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (length &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-           coder.writeBytes(encodedActions);
+		// Flash 6
+		offset += ((event &amp; KeyPress) != 0) ? 1 : 0;
+		// End Flash 6
 
-           if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-               coder.writeWord(0, 1);
-           }
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
+		coder.writeWord(event, eventSize);
+		coder.writeWord(offset, 4);
 
-        event = coder.readWord(eventSize, false);
-        int length = coder.readWord(4, false);
+		// Flash 6
+		if ((event &amp; KeyPress) != 0)
+			coder.writeWord(keyCode, 1);
+		// End Flash 6
 
-// Flash 6
-        if ((event &amp; KeyPress) != 0) {
-            keyCode = coder.readWord(1, false);
-            length -= 1;
-        }
-// End Flash 6
-    
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            FSActionObject action;
-            int start;
-            
-            actions = new ArrayList();
-            
-            while (length &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                action = FSMovie.decodeAction(coder);                
-                actions.add(action);
-                length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-                
-                /*
-                 * The following code is to fix an apparent bug in Flash CS3
-                 * where the offset to the next clip event is 1 byte larger 
-                 * than it should be.
-                 */
-                
-                if (action.getType() == FSAction.End &amp;&amp; length == 1) {
-                	break;
-                }
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length];
-            coder.readBytes(encodedActions);
-        }
-    }
+		if (actions != null)
+		{
+			FSActionObject action = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int length = action.getLength();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (length &lt;&lt; 3);
+
+				action.encode(coder);
+				coder.setPointer(next);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
+
+		event = coder.readWord(eventSize, false);
+		int length = coder.readWord(4, false);
+
+		// Flash 6
+		if ((event &amp; KeyPress) != 0)
+		{
+			keyCode = coder.readByte();
+			length -= 1;
+		}
+		// End Flash 6
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			FSActionObject action;
+			int start;
+
+			actions = new ArrayList();
+
+			while (length &gt; 0)
+			{
+				start = coder.getPointer();
+
+				action = FSActionObject.decodeAction(coder);
+				actions.add(action);
+				length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+
+				/*
+				 * The following code is to fix an apparent bug in Flash CS3
+				 * where the offset to the next clip event is 1 byte larger than
+				 * it should be.
+				 */
+
+				if (action.getType() == FSAction.End &amp;&amp; length == 1)
+				{
+					break;
+				}
+			}
+		} else
+		{
+			encodedActions = new byte[length];
+			coder.readBytes(encodedActions);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSCurve.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSCurve.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSCurve.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -99,7 +99,7 @@
  * (SWF) File Format Specification. It was introduced in Flash 1.
  * &lt;/p&gt;
  */
-public class FSCurve extends FSShapeObject implements Cloneable, Codeable
+public class FSCurve extends FSShapeObject
 {
 	private int controlX = 0;
 
@@ -353,24 +353,6 @@
 		return result;
 	}
 
-	/**
-	 * Creates a deep copy of the entire object.
-	 * 
-	 * @return a copy of the object.
-	 */
-	public Object clone()
-	{
-		Object anObject = null;
-
-		try {
-			anObject = super.clone();
-		} 
-		catch (CloneNotSupportedException e) {
-			throw new InternalError();
-		}
-		return anObject;
-	}
-
 	public String toString()
 	{
 		StringBuffer buffer = new StringBuffer();

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineButton.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineButton.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineButton.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,455 +33,530 @@
 import java.util.*;
 
 /**
-FSDefineButton defines the appearance of a button and the actions performed when the 
-button is clicked.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSDefineButton defines the appearance of a button and the actions performed
+ * when the button is clicked.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonRecords&lt;/td&gt;
+ * &lt;td&gt;an array of FSButton objects that define the appearance of the button in
+ * each of its states. The array must contain at least one FSButton object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;an array of action objects that are executed when the button is clicked.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * A FSDefineButton object must contain at least one FSButton object. If more
+ * than one button record is defined for a given button state then each shape
+ * will be displayed by the button. The order in which the shapes are displayed
+ * is determined by the layer assigned to each FSButton object.
+ * &lt;/P&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Define a simple button that highlights itself when the mouse is move over
+ * it. No actions are performed when the button is clicked.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape normal = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape);
+ * FSDefineShape highlight = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, highlightShape);
+ * 
+ * ArrayList records = new ArrayList();
+ * ArrayList actions = new ArrayList();
+ * 
+ * records.add(new FSButton(FSButton.Up, normal.getIdentifier(), 1));
+ * records.add(new FSButton(FSButton.Over, highlight.getIdentifier(), 2));
+ * 
+ * FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records,
+ * 				actions);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Define a &quot;complex&quot; button that highlights itself when the mouse is move
+ * over it and actions are executed when the button is clicked.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape1);
+ * FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape2);
+ * FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape3);
+ * 
+ * ArrayList records = new ArrayList();
+ * records.add(new FSButton(FSButton.Up, upShape.getIdentifier(), 1));
+ * records.add(new FSButton(FSButton.Over, overShape.getIdentifier(), 2));
+ * records.add(new FSButton(FSButton.Down, downShape.getIdentifier(), 3));
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(action);
+ * actions.add(action);
+ * actions.add(action);
+ * 
+ * FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records,
+ * 				actions);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. If more than one button record is defined for a state then the layer
+ * number defines the order the shapes are displayed. This allows buttons to be
+ * &quot;reused&quot; with only the label on the button being changed.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape1);
+ * FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape2);
+ * FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape3);
+ * 
+ * // The label shape contains the &quot;text&quot; for the button. Note the text must be 
+ * // drawn as a shape.
+ * 
+ * FSDefineShape label = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape4);
+ * 
+ * ArrayList records = new ArrayList();
+ * 
+ * // Note that the label defined for all of the button's states. This ensures the 
+ * // label is visible at all times when the mouse is moved over the button.
+ * 
+ * records.add(FSButton(FSButton.Up, upShape.getIdentifier(), 1));
+ * records.add(FSButton(FSButton.Up, label.getIdentifier(), 2));
+ * records.add(FSButton(FSButton.Over, overShape.getIdentifier(), 3));
+ * records.add(FSButton(FSButton.Over, label.getIdentifier(), 4));
+ * records.add(FSButton(FSButton.Down, downShape.getIdentifier(), 5));
+ * records.add(FSButton(FSButton.Down, label.getIdentifier(), 6));
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(action);
+ * actions.add(action);
+ * actions.add(action);
+ * 
+ * FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records,
+ * 				actions);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineButton class represents the DefineButton structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineButton extends FSDefineObject
+{
+	private ArrayList buttonRecords = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private ArrayList actions = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSAction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	private byte[] encodedActions = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton_2&quot;&gt;buttonRecords&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an array of FSButton objects that define the appearance of the button in each of its states. The array must contain at least one FSButton object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineButton object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineButton(FSCoder coder)
+	{
+		super(DefineButton, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton_3&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an array of action objects that are executed when the button is clicked.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object with the identifier, button records
+	 * and actions.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param actionArray
+	 *            and array of action objects.
+	 */
+	public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray,
+							ArrayList actionArray)
+	{
+		super(DefineButton, anIdentifier);
+		setButtonRecords(buttonRecordArray);
+		setActions(actionArray);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineButton_4&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded actions are typically generated by the parser in the Translate framework. The actions array and encodedActions cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineButton object.
+	 */
+	public FSDefineButton(FSDefineButton obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		buttonRecords = new ArrayList();
 
-&lt;p&gt;A FSDefineButton object must contain at least one FSButton object. If more than one button record is defined for a given button state then each shape will be displayed by the button. The order in which the shapes are displayed is determined by the layer assigned to each FSButton object.&lt;/P&gt;
+		for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
+			buttonRecords.add(((FSButton) i.next()).clone());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		if (actions != null)
+		{
+			actions = new ArrayList();
 
-&lt;p&gt;1. Define a simple button that highlights itself when the mouse is move over it. No actions are performed when the button is clicked.&lt;/p&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-&lt;pre&gt;
-FSDefineShape normal = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape);
-FSDefineShape highlight = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, highlightShape);
+	/**
+	 * Constructs an FSDefineButton object with the identifier, button records
+	 * and encoded actions.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray,
+							byte[] bytes)
+	{
+		super(DefineButton, anIdentifier);
+		setButtonRecords(buttonRecordArray);
+		setEncodedActions(bytes);
+	}
 
-ArrayList records = new ArrayList();
-ArrayList actions = new ArrayList();
+	/**
+	 * Adds the button record object to the array of button records.
+	 * 
+	 * @param aButtonRecord
+	 *            an FSButton object.
+	 */
+	public void add(FSButton aButtonRecord)
+	{
+		buttonRecords.add(aButtonRecord);
+	}
 
-records.add(new FSButton(FSButton.Up, normal.getIdentifier(), 1));
-records.add(new FSButton(FSButton.Over, highlight.getIdentifier(), 2));
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records, actions);
-&lt;/pre&gt;
+	/**
+	 * Gets the array of button records defined for this button.
+	 * 
+	 * @return the array of FSButton objects defined for this button.
+	 */
+	public ArrayList getButtonRecords()
+	{
+		return buttonRecords;
+	}
 
-&lt;p&gt;2. Define a &quot;complex&quot; button that highlights itself when the mouse is move over it and actions are executed when the button is clicked.&lt;/p&gt;
+	/**
+	 * Gets the array of actions that will be executed when the button is
+	 * clicked and released.
+	 * 
+	 * @return the array of action objects defined for this button.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-&lt;pre&gt;
-FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape1);
-FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape2);
-FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape3);
+	/**
+	 * Sets the array of button records defined for this button.
+	 * 
+	 * @param anArray
+	 *            an array of FSButton objects.
+	 */
+	public void setButtonRecords(ArrayList anArray)
+	{
+		buttonRecords = anArray;
+	}
 
-ArrayList records = new ArrayList();
-records.add(new FSButton(FSButton.Up, upShape.getIdentifier(), 1));
-records.add(new FSButton(FSButton.Over, overShape.getIdentifier(), 2));
-records.add(new FSButton(FSButton.Down, downShape.getIdentifier(), 3));
+	/**
+	 * Sets the array of actions that will be executed when the button is
+	 * clicked and released.
+	 * 
+	 * @param anArray
+	 *            and array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-actions.add(action);
-actions.add(action);
-actions.add(action);
+	/**
+	 * Set the array of encoded actions that will be executed when the button is
+	 * clicked and released. The encoded actions are typically generated by the
+	 * classes in the Translate framework. If the object already contains an
+	 * array of actions then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records, actions);
-&lt;/pre&gt;
+	public Object clone()
+	{
+		FSDefineButton anObject = (FSDefineButton) super.clone();
 
-&lt;p&gt;3. If more than one button record is defined for a state then the layer number defines the order the shapes are displayed. This allows buttons to be &quot;reused&quot; with only the label on the button being changed.&lt;/p&gt;
+		anObject.buttonRecords = new ArrayList();
 
-&lt;pre&gt;
-FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape1);
-FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape2);
-FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape3);
+		for (Iterator i = buttonRecords.iterator(); i.hasNext();)
+			anObject.buttonRecords.add(((FSButton) i.next()).clone());
 
-// The label shape contains the &quot;text&quot; for the button. Note the text must be 
-// drawn as a shape.
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-FSDefineShape label = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape4);
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
 
-ArrayList records = new ArrayList();
+		return anObject;
+	}
 
-// Note that the label defined for all of the button's states. This ensures the 
-// label is visible at all times when the mouse is moved over the button.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-records.add(FSButton(FSButton.Up, upShape.getIdentifier(), 1));
-records.add(FSButton(FSButton.Up, label.getIdentifier(), 2));
-records.add(FSButton(FSButton.Over, overShape.getIdentifier(), 3));
-records.add(FSButton(FSButton.Over, label.getIdentifier(), 4));
-records.add(FSButton(FSButton.Down, downShape.getIdentifier(), 5));
-records.add(FSButton(FSButton.Down, label.getIdentifier(), 6));
+		if (super.equals(anObject))
+		{
+			FSDefineButton typedObject = (FSDefineButton) anObject;
 
-ArrayList actions = new ArrayList();
+			if (buttonRecords != null)
+				result = buttonRecords.equals(typedObject.buttonRecords);
+			else
+				result = buttonRecords == typedObject.buttonRecords;
 
-actions.add(action);
-actions.add(action);
-actions.add(action);
+			if (actions != null)
+				result = actions.equals(typedObject.actions);
+			else
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+		}
+		return result;
+	}
 
-FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records, actions);
-&lt;/pre&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		buffer.append(&quot;FSDefineButton: { &quot;);
+		buffer.append(&quot;buttonRecords = &quot;).append(buttonRecords.toString()).append(&quot;; &quot;);
 
-&lt;p&gt;The FSDefineButton class represents the DefineButton structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineButton extends FSDefineObject
-{
-    private ArrayList buttonRecords = null;
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
+		if (actions != null)
+			buffer.append(&quot;actions = &quot;).append(actions.toString()).append(&quot;; &quot;);
+		else
+			buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    /**
-     * Construct an FSDefineButton object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineButton(FSCoder coder)
-    {
-        super(DefineButton, 0);
-        decode(coder);
-    }
-    /**  Constructs an FSDefineButton object with the identifier, button records and actions.
+		buffer.append(&quot;}&quot;);
 
-        @param anIdentifier a unique identifier for this button.
-        @param buttonRecordArray an array of FSButton objects.
-        @param actionArray and array of action objects.
-        */
-    public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray, ArrayList actionArray)
-    {
-        super(DefineButton, anIdentifier);
-        setButtonRecords(buttonRecordArray);
-        setActions(actionArray);
-    }
-    /**
-     * Constructs an FSDefineButton object by copying values from an existing object.
-     *
-     * @param obj an FSDefineButton object.
-     */
-    public FSDefineButton(FSDefineButton obj)
-    {
-        super(obj);
-        
-        buttonRecords = new ArrayList();
-        
-        for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
-            buttonRecords.add(((FSButton)i.next()).clone());
+		return buffer.toString();
+	}
 
-        if (actions != null)
-        {
-            actions = new ArrayList();
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /**  
-     * Constructs an FSDefineButton object with the identifier, button records and 
-     * encoded actions.
-     * 
-     * @param anIdentifier a unique identifier for this button.
-     * @param buttonRecordArray an array of FSButton objects.
-     * @param bytes an array of encoded action objects.
-     */
-    public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray, byte[] bytes)
-    {
-        super(DefineButton, anIdentifier);
-        setButtonRecords(buttonRecordArray);
-        setEncodedActions(bytes);
-    }
+		for (Iterator&lt;Codeable&gt; buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();)
+			length += buttonIterator.next().length(coder);
 
-    /** Adds the button record object to the array of button records.
+		length += 1;
 
-        @param aButtonRecord an FSButton object.
-        */
-    public void add(FSButton aButtonRecord)
-    {
-        buttonRecords.add(aButtonRecord);
-    }
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-    /** Adds the action object to the array of actions.
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-    /** Gets the array of button records defined for this button.
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-        @return the array of FSButton objects defined for this button.
-        */
-    public ArrayList getButtonRecords() { return buttonRecords; }
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
 
-    /** Gets the array of actions that will be executed when the button is clicked and released.
+		return length;
+	}
 
-        @return the array of action objects defined for this button.
-        */
-    public ArrayList getActions() 
-    { 
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the array of button records defined for this button.
+		for (Iterator&lt;Codeable&gt; buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();)
+			buttonIterator.next().encode(coder);
 
-        @param anArray an array of FSButton objects.
-        */
-    public void setButtonRecords(ArrayList anArray)
-    {
-        buttonRecords = anArray;
-    }
+		coder.writeWord(0, 1);
 
-    /** Sets the array of actions that will be executed when the button is clicked and released.
+		if (actions != null)
+		{
+			FSActionObject action = null;
 
-        @param anArray and array of action objects.
-        */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions that will be executed when the button is 
-     * clicked and released. The encoded actions are typically generated by the 
-     * classes in the Translate framework. If the object already contains an 
-     * array of actions then they will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-   }
+				int objStart = coder.getPointer();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (action.getLength() &lt;&lt; 3);
 
-    public Object clone()
-    {
-        FSDefineButton anObject = (FSDefineButton)super.clone();
-        
-        anObject.buttonRecords = new ArrayList();
-            
-        for (Iterator i = buttonRecords.iterator(); i.hasNext();)
-            anObject.buttonRecords.add(((FSButton)i.next()).clone());
+				action.encode(coder);
+				coder.setPointer(next);
 
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        
-        return anObject;
-    }
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineButton typedObject = (FSDefineButton)anObject;
-            
-            if (buttonRecords != null)
-                result = buttonRecords.equals(typedObject.buttonRecords);
-            else
-                result = buttonRecords == typedObject.buttonRecords;
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
 
-            if (actions != null)
-                result = actions.equals(typedObject.actions);
-            else
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;buttonRecords&quot;, buttonRecords, depth);
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
 
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		int start = coder.getPointer() - 16;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();) 
-            length += ((FSTransformObject)buttonIterator.next()).length(coder);
+		buttonRecords = new ArrayList();
 
-        length += 1;
-    
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+		while (coder.scanWord(1, false) != 0)
+			buttonRecords.add(new FSButton(coder));
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
+		coder.readByte(); // character end
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();) 
-            ((FSTransformObject)buttonIterator.next()).encode(coder);
+		int actionsLength = length - ((coder.getPointer() - start) &gt;&gt;&gt; 3);
 
-        coder.writeWord(0, 1);
-    
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                    
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-                
-                action.encode(coder);
-                coder.setPointer(next);
-                
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-                
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        int start = coder.getPointer() - 16;
-        
-        buttonRecords = new ArrayList();
-        
-        while (coder.scanWord(1, false) != 0)
-            buttonRecords.add(new FSButton(coder));
-            
-        coder.readWord(1, false); // character end
-        
-        int actionsLength = length - ((coder.getPointer()-start) &gt;&gt;&gt; 3);
-        
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
-            
-            while (actionsLength &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                actionsLength -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[actionsLength];
-            coder.readBytes(encodedActions);
-        }
-        coder.endObject(name());
-    }
+			while (actionsLength &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSActionObject.decodeAction(coder));
+				actionsLength -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[actionsLength];
+			coder.readBytes(encodedActions);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineButton2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineButton2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineButton2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,446 +33,534 @@
 import java.util.*;
 
 /**
-FSDefineButton2 defines the appearance and actions of push and menu buttons. 
- 
-&lt;p&gt;It provides a more sophisticated model for creating buttons:&lt;/p&gt;
+ * FSDefineButton2 defines the appearance and actions of push and menu buttons.
+ * 
+ * &lt;p&gt;
+ * It provides a more sophisticated model for creating buttons:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;Two types of button are supported, &lt;B&gt;Push&lt;/B&gt; and &lt;B&gt;Menu&lt;/B&gt;.&lt;/li&gt;
+ * &lt;li&gt;The number of events that a button can respond to is increased.&lt;/li&gt;
+ * &lt;li&gt;Actions can be executed for any button event.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * Push and Menu buttons behave slightly differently in tracking mouse movements
+ * when the button is clicked. A Push button 'captures' the mouse so if the
+ * cursor is dragged outside of the active area of the button and the mouse
+ * click is released then the Release Outside event is still sent to the button.
+ * A Menu button does not 'capture' the mouse so if the cursor is dragged out of
+ * the active area the button returns to its 'inactive' state.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonType&lt;/td&gt;
+ * &lt;td&gt;Whether the button is a Push button or a Menu button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonRecords&lt;/td&gt;
+ * &lt;td&gt;An array of FSButton objects that describe the appearance of the button
+ * in each of its states.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonEvents&lt;/td&gt;
+ * &lt;td&gt;An array of FSButtonEvent objects that define the actions that are
+ * executed for each type of button event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedEvents&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded button events can also be set. The
+ * encoded objects are typically generated by the parser in the Translate
+ * framework. The buttonEvents array and encodedEvents cannot both be valid at
+ * the same time. Accessor methods used to set either of the attributes will set
+ * the other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * An FSDefineButton2 object must contain at least one FSButton object. If more
+ * than one button record is defined for a given button state then each shape
+ * will be displayed by the button. The order in which the shapes are displayed
+ * is determined by the layer assigned to each button record.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Each FSButton object can contain an FSColorTransform object which can be used
+ * to change the colour of the shape being displayed without changing the
+ * original definition.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Actions do not need to be specified for every button event. Indeed actions do
+ * not need to be specified at all.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * 1. Define a button that highlights itself when the mouse is move over it and
+ * actions are executed when the button is clicked.
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape1);
+ * FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape2);
+ * FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape3);
+ * 
+ * ArrayList records = new ArrayList();
+ * ArrayList events = new ArrayList();
+ * 
+ * records.add(FSButtonRecord(FSButton.Up, upShape.getIdentifier(), 1));
+ * records.add(FSButtonRecord(FSButton.Over, overShape.getIdentifier(), 2));
+ * records.add(FSButtonRecord(FSButton.Down, downShape.getIdentifier(), 3));
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(action);
+ * actions.add(action);
+ * actions.add(action);
+ * 
+ * events.add(FSButtonEvent(FSButtonEvent.Press, actions));
+ * 
+ * FSDefineButton2 button = new FSDefineButton2(movie.newIdentifier(),
+ * 				FSDefineButton2.Push, records, events);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineButton2 class represents the DefineButton2 structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineButton2 extends FSDefineObject
+{
+	/**
+	 * Defines whether a FSDefineButton2 object is configured as a momentary,
+	 * push button.
+	 */
+	public static final int Push = 0;
 
-&lt;ul&gt;
-&lt;li&gt;Two types of button are supported, &lt;B&gt;Push&lt;/B&gt; and &lt;B&gt;Menu&lt;/B&gt;.&lt;/li&gt;
-&lt;li&gt;The number of events that a button can respond to is increased.&lt;/li&gt;
-&lt;li&gt;Actions can be executed for any button event.&lt;/li&gt;
-&lt;/ul&gt;
+	/** Defines whether a FSDefineButton2 object is configured as a menu button. */
+	public static final int Menu = 1;
 
-&lt;p&gt;Push and Menu buttons behave slightly differently in tracking mouse movements when the button is clicked. A Push button 'captures' the mouse so if the cursor is dragged outside of the active area of the button and the mouse click is released then the Release Outside event is still sent to the button. A Menu button does not 'capture' the mouse so if the cursor is dragged out of the active area the button returns to its 'inactive' state.&lt;/p&gt;
+	private int buttonType = Push;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private ArrayList buttonRecords = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private ArrayList buttonEvents = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private byte[] encodedEvents = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineButton2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineButton2(FSCoder coder)
+	{
+		super(DefineButton2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_2&quot;&gt;buttonType&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether the button is a Push button or a Menu button.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object, specifying the unique identifier,
+	 * the type of button to be created, the button records that describe the
+	 * button's appearance and the actions that are performed in response to
+	 * each button event.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonType
+	 *            the type of button - push or menu.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param buttonEventArray
+	 *            an array of FSButtonEvent objects.
+	 */
+	public FSDefineButton2(int anIdentifier, int buttonType,
+							ArrayList buttonRecordArray,
+							ArrayList buttonEventArray)
+	{
+		super(DefineButton2, anIdentifier);
+		setButtonType(buttonType);
+		setButtonRecords(buttonRecordArray);
+		setButtonEvents(buttonEventArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_3&quot;&gt;buttonRecords&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSButton objects that describe the appearance of the button in each of its states.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object, specifying the unique identifier,
+	 * the type of button to be created, the button records that describe the
+	 * button's appearance and the encoded actions that are performed in
+	 * response to each button event.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonType
+	 *            the type of button - push or menu.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param bytes
+	 *            an array containing the encoded FSButtonEvent objects.
+	 */
+	public FSDefineButton2(int anIdentifier, int buttonType,
+							ArrayList buttonRecordArray, byte[] bytes)
+	{
+		super(DefineButton2, anIdentifier);
+		setButtonType(buttonType);
+		setButtonRecords(buttonRecordArray);
+		setEncodedEvents(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_4&quot;&gt;buttonEvents&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSButtonEvent objects that define the actions that are executed for each type of button event.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineButton2 object.
+	 */
+	public FSDefineButton2(FSDefineButton2 obj)
+	{
+		super(obj);
+		buttonType = obj.buttonType;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineButton2_5&quot;&gt;encodedEvents&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded button events can also be set. The encoded objects are typically generated by the parser in the Translate framework. The buttonEvents array and encodedEvents cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+		buttonRecords = new ArrayList();
 
-&lt;/table&gt;
+		for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
+			buttonRecords.add(((FSButton) i.next()).clone());
 
-&lt;p&gt;An FSDefineButton2 object must contain at least one FSButton object. If more than one button record is defined for a given button state then each shape will be displayed by the button. The order in which the shapes are displayed is determined by the layer assigned to each button record.&lt;/p&gt;
+		if (buttonEvents != null)
+		{
+			buttonEvents = new ArrayList();
 
-&lt;p&gt;Each FSButton object can contain an FSColorTransform object which can be used to change the colour of the shape being displayed without changing the original definition.&lt;/p&gt;
+			for (Iterator i = obj.buttonEvents.iterator(); i.hasNext();)
+				buttonEvents.add(((FSButtonEvent) i.next()).clone());
+		} else
+		{
+			encodedEvents = Transform.clone(obj.encodedEvents);
+		}
+	}
 
-&lt;p&gt;Actions do not need to be specified for every button event. Indeed actions do not need to be specified at all.&lt;/p&gt;
+	/**
+	 * Adds an FSButton to the array of button records.
+	 * 
+	 * @param aButton
+	 *            a button record.
+	 */
+	public void add(FSButton aButton)
+	{
+		buttonRecords.add(aButton);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Adds a button event object to the array of button events.
+	 * 
+	 * @param aButtonEvent
+	 *            a button event.
+	 */
+	public void add(FSButtonEvent aButtonEvent)
+	{
+		if (buttonEvents == null)
+			buttonEvents = new ArrayList();
 
-1. Define a button that highlights itself when the mouse is move over it and actions are executed when the button is clicked.
+		buttonEvents.add(aButtonEvent);
+		encodedEvents = null;
+	}
 
-&lt;pre&gt;
-FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape1);
-FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape2);
-FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape3);
+	/**
+	 * Gets the button type - push or menu.
+	 * 
+	 * @return the type of button.
+	 */
+	public int getButtonType()
+	{
+		return buttonType;
+	}
 
-ArrayList records = new ArrayList();
-ArrayList events = new ArrayList();
+	/**
+	 * Gets the array of button records defined for this button.
+	 * 
+	 * @return the array of button records.
+	 */
+	public ArrayList getButtonRecords()
+	{
+		return buttonRecords;
+	}
 
-records.add(FSButtonRecord(FSButton.Up, upShape.getIdentifier(), 1));
-records.add(FSButtonRecord(FSButton.Over, overShape.getIdentifier(), 2));
-records.add(FSButtonRecord(FSButton.Down, downShape.getIdentifier(), 3));
+	/**
+	 * Gets the array of button records defined for this button.
+	 * 
+	 * @return the array of button events.
+	 */
+	public ArrayList getButtonEvents()
+	{
+		return buttonEvents;
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Sets the button type.
+	 * 
+	 * @param aType
+	 *            the type of button - push or menu.
+	 */
+	public void setButtonType(int aType)
+	{
+		buttonType = aType;
+	}
 
-actions.add(action);
-actions.add(action);
-actions.add(action);
+	/**
+	 * Sets the array of button records defined for this button.
+	 * 
+	 * @param anArray
+	 *            an array of FSButtonRecord objects.
+	 */
+	public void setButtonRecords(ArrayList anArray)
+	{
+		buttonRecords = anArray;
+	}
 
-events.add(FSButtonEvent(FSButtonEvent.Press, actions));
+	/**
+	 * Sets the array of button events defined for this button. If the object
+	 * contains encodedEvents then they will be deleted.
+	 * 
+	 * @param anArray
+	 *            and array of FSButtonEvent objects.
+	 */
+	public void setButtonEvents(ArrayList anArray)
+	{
+		buttonEvents = anArray;
 
-FSDefineButton2 button = new FSDefineButton2(movie.newIdentifier(), FSDefineButton2.Push, records, events);
-&lt;/pre&gt;
+		if (encodedEvents != null)
+			encodedEvents = null;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Set the encoded button event objects generated by the classes in the
+	 * Translate framework. If the object already contains an array of button
+	 * events objects then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded button events.
+	 */
+	public void setEncodedEvents(byte[] bytes)
+	{
+		encodedEvents = bytes;
+		buttonEvents = null;
+	}
 
-&lt;p&gt;The FSDefineButton2 class represents the DefineButton2 structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineButton2 extends FSDefineObject
-{
-/** Defines whether a FSDefineButton2 object is configured as a momentary, push button. */
-    public static final int Push = 0;
-    
-/** Defines whether a FSDefineButton2 object is configured as a menu button. */
-    public static final int Menu = 1;
-    
-    private int buttonType = Push;
-    private ArrayList buttonRecords = null;
-    private ArrayList buttonEvents = null;
-    private byte[] encodedEvents = null;
-    
-    /**
-     * Construct an FSDefineButton2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineButton2(FSCoder coder)
-    {
-        super(DefineButton2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineButton object, specifying the unique identifier, the type of button to be created, the button records that describe the button's appearance and the actions that are performed in response to each button event.
+	public Object clone()
+	{
+		FSDefineButton2 anObject = (FSDefineButton2) super.clone();
 
-        @param anIdentifier a unique identifier for this button.
-        @param buttonType the type of button - push or menu.
-        @param buttonRecordArray an array of FSButton objects.
-        @param buttonEventArray an array of FSButtonEvent objects.
-        */
-    public FSDefineButton2(int anIdentifier, int buttonType, ArrayList buttonRecordArray, ArrayList buttonEventArray)
-    {
-        super(DefineButton2, anIdentifier);
-        setButtonType(buttonType);
-        setButtonRecords(buttonRecordArray);
-        setButtonEvents(buttonEventArray);
-    }
+		anObject.buttonRecords = new ArrayList();
 
-    /** 
-     * Constructs an FSDefineButton object, specifying the unique identifier, the 
-     * type of button to be created, the button records that describe the button's 
-     * appearance and the encoded actions that are performed in response to each 
-     * button event.
-     * 
-     * @param anIdentifier a unique identifier for this button.
-     * @param buttonType the type of button - push or menu.
-     * @param buttonRecordArray an array of FSButton objects.
-     * @param bytes an array containing the encoded FSButtonEvent objects.
-     */
-    public FSDefineButton2(int anIdentifier, int buttonType, ArrayList buttonRecordArray, byte[] bytes)
-    {
-        super(DefineButton2, anIdentifier);
-        setButtonType(buttonType);
-        setButtonRecords(buttonRecordArray);
-        setEncodedEvents(bytes);
-    }
-    /**
-     * Constructs an FSDefineButton2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineButton2 object.
-     */
-    public FSDefineButton2(FSDefineButton2 obj)
-    {
-        super(obj);
-        buttonType = obj.buttonType;
-        
-        buttonRecords = new ArrayList();
-            
-        for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
-            buttonRecords.add(((FSButton)i.next()).clone());
+		for (Iterator i = buttonRecords.iterator(); i.hasNext();)
+			anObject.buttonRecords.add(((FSButton) i.next()).clone());
 
-        if (buttonEvents != null)
-        {
-            buttonEvents = new ArrayList();
-            
-            for (Iterator i = obj.buttonEvents.iterator(); i.hasNext();)
-                buttonEvents.add(((FSButtonEvent)i.next()).clone());
-        }
-        else
-        {
-            encodedEvents = Transform.clone(obj.encodedEvents);
-        }
-    }
+		if (buttonEvents != null)
+		{
+			anObject.buttonEvents = new ArrayList();
 
-    /** Adds an FSButton to the array of button records.
+			for (Iterator i = buttonEvents.iterator(); i.hasNext();)
+				anObject.buttonEvents.add(((FSButtonEvent) i.next()).clone());
+		} else
+		{
+			anObject.encodedEvents = Transform.clone(encodedEvents);
+		}
+		return anObject;
+	}
 
-        @param aButton a button record.
-        */
-    public void add(FSButton aButton) { buttonRecords.add(aButton); }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Adds a button event object to the array of button events.
+		if (super.equals(anObject))
+		{
+			FSDefineButton2 typedObject = (FSDefineButton2) anObject;
 
-        @param aButtonEvent a button event.
-        */
-    public void add(FSButtonEvent aButtonEvent) 
-    { 
-        if (buttonEvents == null)
-            buttonEvents = new ArrayList();
-            
-        buttonEvents.add(aButtonEvent); 
-        encodedEvents = null;
-    }
+			result = buttonType == typedObject.buttonType;
 
-    /** Gets the button type - push or menu.
+			if (buttonRecords != null)
+				result = result
+								&amp;&amp; buttonRecords
+												.equals(typedObject.buttonRecords);
+			else
+				result = result &amp;&amp; buttonRecords == typedObject.buttonRecords;
 
-        @return the type of button.
-        */
-    public int getButtonType() { return buttonType; }
+			if (buttonEvents != null)
+				result = buttonEvents.equals(typedObject.buttonEvents);
+			else
+				result = Transform.equals(encodedEvents,
+								typedObject.encodedEvents);
+		}
+		return result;
+	}
 
-    /** Gets the array of button records defined for this button.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @return the array of button records.
-        */
-    public ArrayList getButtonRecords() { return buttonRecords; }
+		buffer.append(&quot;FSDefineButon2: { &quot;);
+		buffer.append(&quot;buttonRecords = &quot;).append(buttonRecords.toString()).append(&quot;; &quot;);
 
-    /** Gets the array of button records defined for this button.
+		if (buttonEvents != null)
+			buffer.append(&quot;buttonEvents = &quot;).append(buttonEvents.toString()).append(&quot;; &quot;);
+		else
+			buffer.append(&quot;buttonEvents = &lt;data&gt;; &quot;);
 
-        @return the array of button events.
-        */
-    public ArrayList getButtonEvents() { return buttonEvents; }
+		buffer.append(&quot;}&quot;);
 
-    /** Sets the button type.
+		return buffer.toString();
+	}
 
-        @param aType the type of button - push or menu.
-        */
-    public void setButtonType(int aType)
-    {
-        buttonType = aType;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the array of button records defined for this button.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @param anArray an array of FSButtonRecord objects.
-        */
-    public void setButtonRecords(ArrayList anArray)
-    {
-        buttonRecords = anArray;
-    }
+		length += 3;
 
-    /** 
-     * Sets the array of button events defined for this button. If the object
-     * contains encodedEvents then they will be deleted.
-     * 
-     * @param anArray and array of FSButtonEvent objects.
-     */
-    public void setButtonEvents(ArrayList anArray)
-    {
-        buttonEvents = anArray;
-        
-        if (encodedEvents != null)
-            encodedEvents = null;
-    }
+		for (Iterator&lt;Codeable&gt; buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();)
+			length += buttonIterator.next().length(coder);
 
-    /** 
-     * Set the encoded button event objects generated by the classes in the Translate 
-     * framework. If the object already contains an array of button events objects
-     * then they will be deleted.
-     * 
-     * @param bytes the array of encoded button events.
-     */
-    public void setEncodedEvents(byte[] bytes)
-    {
-        encodedEvents = bytes;
-        buttonEvents = null;
-    }
+		length += 1;
 
-    public Object clone()
-    {
-        FSDefineButton2 anObject = (FSDefineButton2)super.clone();
-        
-        anObject.buttonRecords = new ArrayList();
-            
-        for (Iterator i = buttonRecords.iterator(); i.hasNext();)
-            anObject.buttonRecords.add(((FSButton)i.next()).clone());
+		if (buttonEvents != null)
+		{
+			for (Iterator&lt;Codeable&gt; eventIterator = buttonEvents.iterator(); eventIterator.hasNext();)
+			{
+				length += 2;
+				length += eventIterator.next().length(coder);
+			}
+		} else
+		{
+			length += encodedEvents.length;
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
 
-        if (buttonEvents != null)
-        {
-            anObject.buttonEvents = new ArrayList();
-            
-            for (Iterator i = buttonEvents.iterator(); i.hasNext();)
-                anObject.buttonEvents.add(((FSButtonEvent)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedEvents = Transform.clone(encodedEvents);
-        }
-        return anObject;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineButton2 typedObject = (FSDefineButton2)anObject;
-            
-            result = buttonType == typedObject.buttonType;
+	public void encode(FSCoder coder)
+	{
+		int offsetStart = 0;
+		int offsetEnd = 0;
+		int currentCursor = 0;
 
-            if (buttonRecords != null)
-                result = result &amp;&amp; buttonRecords.equals(typedObject.buttonRecords);
-            else
-                result = result &amp;&amp; buttonRecords == typedObject.buttonRecords;
+		super.encode(coder);
 
-            if (buttonEvents != null)
-                result = buttonEvents.equals(typedObject.buttonEvents);
-            else
-                result = Transform.equals(encodedEvents, typedObject.encodedEvents);
-        }
-        return result;
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;buttonRecords&quot;, buttonRecords, depth);
+		coder.writeWord(buttonType, 1);
 
-            if (buttonEvents != null)
-                Transform.append(buffer, &quot;buttonEvents&quot;, buttonEvents, depth);
-            else
-                buffer.append(&quot;buttonEvents = &lt;data&gt;; &quot;);
+		offsetStart = coder.getPointer();
+		coder.writeWord(0, 2);
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		for (Iterator&lt;Codeable&gt; buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();)
+			buttonIterator.next().encode(coder);
 
-    public int length(FSCoder coder)
-    {    
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+		coder.writeWord(0, 1);
 
-        length += 3;
-    
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();)
-            length += ((FSTransformObject)buttonIterator.next()).length(coder);
+		// Write actions offset
 
-        length += 1;
-    
-        if (buttonEvents != null)
-        {
-            for (Iterator eventIterator = buttonEvents.iterator(); eventIterator.hasNext();)
-            {
-                length += 2;
-                length += ((FSTransformObject)eventIterator.next()).length(coder);
-            }        
-        }
-        else
-        {
-            length += encodedEvents.length;
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int offsetStart = 0;
-        int offsetEnd = 0;
-        int currentCursor = 0;
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+		currentCursor = coder.getPointer();
+		offsetEnd = (currentCursor - offsetStart) &gt;&gt; 3;
+		coder.setPointer(offsetStart);
+		coder.writeWord(offsetEnd, 2);
+		coder.setPointer(currentCursor);
 
-        coder.writeWord(buttonType, 1);
-        
-        offsetStart = coder.getPointer();
-        coder.writeWord(0, 2);
-    
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();) 
-            ((FSTransformObject)buttonIterator.next()).encode(coder);
-    
-        coder.writeWord(0, 1);
+		if (buttonEvents != null)
+		{
+			for (Iterator&lt;FSButtonEvent&gt; eventIterator = buttonEvents.iterator(); eventIterator.hasNext();)
+			{
+				FSButtonEvent anEvent = eventIterator.next();
 
-        // Write actions offset
-        
-        currentCursor = coder.getPointer();
-        offsetEnd = (currentCursor - offsetStart) &gt;&gt; 3;
-        coder.setPointer(offsetStart);
-        coder.writeWord(offsetEnd, 2);
-        coder.setPointer(currentCursor);
-    
-        if (buttonEvents != null)
-        {
-            for (Iterator eventIterator = buttonEvents.iterator(); eventIterator.hasNext();)
-            {
-                FSButtonEvent anEvent = (FSButtonEvent)eventIterator.next();
+				offsetStart = coder.getPointer();
+				coder.writeWord(anEvent.length(coder) + 2, 2);
+				anEvent.encode(coder);
+			}
+			// Write offset of zero for last Action Condition
 
-                offsetStart = coder.getPointer();
-                coder.writeWord(anEvent.length(coder) + 2, 2);
-                anEvent.encode(coder);
-            }
-            // Write offset of zero for last Action Condition
-        
-            currentCursor = coder.getPointer();
-            coder.setPointer(offsetStart);
-            coder.writeWord(0, 2);
-            coder.setPointer(currentCursor);
-        }
-        else
-        {
-            coder.writeBytes(encodedEvents);
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int offsetToNext = 0;
-        
-        buttonEvents = new ArrayList();
+			currentCursor = coder.getPointer();
+			coder.setPointer(offsetStart);
+			coder.writeWord(0, 2);
+			coder.setPointer(currentCursor);
+		} else
+		{
+			coder.writeBytes(encodedEvents);
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 
-        super.decode(coder);
-        
-        int start = coder.getPointer()-16;
+	public void decode(FSCoder coder)
+	{
+		int offsetToNext = 0;
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		buttonEvents = new ArrayList();
 
-        buttonType = coder.readWord(1, false);
-        offsetToNext = coder.readWord(2, false);
+		super.decode(coder);
 
-        buttonRecords = new ArrayList();
-        
-        while (coder.scanWord(1, false) != 0)
-            buttonRecords.add(new FSButton(coder));
-            
-        coder.readWord(1, false);
+		int start = coder.getPointer() - 16;
 
-        if (offsetToNext != 0)
-        {
-            buttonEvents = new ArrayList();
-                
-            do {
-                offsetToNext = coder.readWord(2, false);
-                
-                if (offsetToNext != 0)
-                {
-                    buttonEvents.add(new FSButtonEvent(coder, offsetToNext-2));
-                }
-                else
-                {
-                    buttonEvents.add(new FSButtonEvent(coder, length - ((coder.getPointer()-start) &gt;&gt;&gt; 3)));
-                }
-            } while (offsetToNext != 0);
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
+		buttonType = coder.readByte();
+		offsetToNext = coder.readWord(2, false);
+
+		buttonRecords = new ArrayList();
+
+		while (coder.scanWord(1, false) != 0)
+			buttonRecords.add(new FSButton(coder));
+
+		coder.readByte();
+
+		if (offsetToNext != 0)
+		{
+			buttonEvents = new ArrayList();
+
+			do
+			{
+				offsetToNext = coder.readWord(2, false);
+
+				if (offsetToNext != 0)
+				{
+					buttonEvents
+									.add(new FSButtonEvent(coder,
+													offsetToNext - 2));
+				} else
+				{
+					buttonEvents.add(new FSButtonEvent(coder, length
+									- ((coder.getPointer() - start) &gt;&gt;&gt; 3)));
+				}
+			} while (offsetToNext != 0);
+
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineFont.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineFont.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineFont.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,220 +33,253 @@
 import java.util.*;
 
 /**
-FSDefineFont defines the glyphs that are drawn when text characters are rendered in a particular font.
+ * FSDefineFont defines the glyphs that are drawn when text characters are
+ * rendered in a particular font.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shapes&lt;/td&gt;
+ * &lt;td&gt;An array of FSShape objects contain the sequences of FSLine, FSCurve and
+ * FSShapeStyle objects used to trace the outlines for each glyph.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * A complete definition of a font is created using the FSDefineFont object for
+ * the glyphs along with an FSFontInfo object which contains the name of the
+ * font, whether the font face is bold or italics and a table that maps
+ * character codes to the glyphs that is drawn to represent the character.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When defining a font only the glyphs used from a particular font are
+ * included. Unused glyphs can be omitted greatly reducing the amount of
+ * information that is encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;h2 class=&quot;datasheet&quot;&gt;History&lt;/h2&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineFont class represents the DefineFont structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineFont extends FSDefineObject
+{
+	private ArrayList&lt;FSShape&gt; shapes = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSCall object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineFont(FSCoder coder)
+	{
+		super(FSMovieObject.DefineFont, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineFont object setting the unique identifier for the
+	 * object and the array of glyphs used to render the characters used from
+	 * the font.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param anArray
+	 *            an array of FSShape objects that define the outlines for each
+	 *            glyph in the font.
+	 */
+	public FSDefineFont(int anIdentifier, ArrayList&lt;FSShape&gt; anArray)
+	{
+		super(FSMovieObject.DefineFont, anIdentifier);
+		setShapes(anArray);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineFont_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineFont object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineFont object.
+	 */
+	public FSDefineFont(FSDefineFont obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		shapes = new ArrayList&lt;FSShape&gt;();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont_2&quot;&gt;shapes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSShape objects contain the sequences of FSLine, FSCurve and FSShapeStyle objects used to trace the outlines for each glyph.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator&lt;FSShape&gt; i = obj.shapes.iterator(); i.hasNext();)
+			shapes.add((FSShape)i.next().clone());
+	}
 
-&lt;/table&gt;
+	/**
+	 * Add a shape to the array of shapes.
+	 * 
+	 * @param anObject
+	 *            a shape.
+	 */
+	public void add(FSShape anObject)
+	{
+		shapes.add(anObject);
+	}
 
-&lt;p&gt;A complete definition of a font is created using the FSDefineFont object for the glyphs along with an FSFontInfo object which contains the name of the font, whether the font face is bold or italics and a table that maps character codes to the glyphs that is drawn to represent the character.&lt;/p&gt;
+	/**
+	 * Gets the array of shapes that define the outline for each glyph.
+	 * 
+	 * @return an array of FSShape objects.
+	 */
+	public ArrayList&lt;FSShape&gt; getShapes()
+	{
+		return shapes;
+	}
 
-&lt;p&gt;When defining a font only the glyphs used from a particular font are included. Unused glyphs can be omitted greatly reducing the amount of information that is encoded.&lt;/p&gt;
+	/**
+	 * Sets the array of shapes that describe each glyph.
+	 * 
+	 * @param anArray
+	 *            an array of FSShape objects that define the outlines for each
+	 *            glyph in the font.
+	 */
+	public void setShapes(ArrayList&lt;FSShape&gt; anArray)
+	{
+		shapes = anArray;
+	}
 
-&lt;h2 class=&quot;datasheet&quot;&gt;History&lt;/h2&gt;
+	public Object clone()
+	{
+		FSDefineFont anObject = (FSDefineFont)super.clone();
 
-&lt;p&gt;The FSDefineFont class represents the DefineFont structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineFont extends FSDefineObject
-{
-    private ArrayList shapes = null;
-    
-    /**
-     * Construct an FSCall object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineFont(FSCoder coder)
-    {
-        super(FSMovieObject.DefineFont, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineFont object setting the unique identifier for the object and the array of glyphs used to render the characters used from the font.
+		anObject.shapes = new ArrayList&lt;FSShape&gt;();
 
-        @param anIdentifier the unique identifier for this object.
-        @param anArray an array of FSShape objects that define the outlines for each glyph in the font.
-        */
-    public FSDefineFont(int anIdentifier, ArrayList anArray)
-    {
-        super(FSMovieObject.DefineFont, anIdentifier);
-        setShapes(anArray);
-    }
-    /**
-     * Constructs an FSDefineFont object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineFont object.
-     */
-    public FSDefineFont(FSDefineFont obj)
-    {
-        super(obj);
+		for (Iterator&lt;FSShape&gt; i = shapes.iterator(); i.hasNext();)
+			anObject.shapes.add((FSShape) i.next().clone());
 
-        shapes = new ArrayList();
-        
-        for (Iterator i = obj.shapes.iterator(); i.hasNext();)
-            shapes.add(((FSShape)i.next()).clone());
-    }
+		return anObject;
+	}
 
-    /** Add a shape to the array of shapes.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anObject a shape.
-        */
-    public void add(FSShape anObject)
-    {
-        shapes.add(anObject);
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineFont typedObject = (FSDefineFont) anObject;
 
-    /**    Gets the array of shapes that define the outline for each glyph.
+			if (shapes != null)
+				result = shapes.equals(typedObject.shapes);
+			else
+				result = shapes == typedObject.shapes;
+		}
+		return result;
+	}
 
-        @return an array of FSShape objects.
-        */
-    public ArrayList getShapes() { return shapes; }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Sets the array of shapes that describe each glyph.
+		buffer.append(&quot;FSDefineFont: { &quot;);
+		buffer.append(&quot;shapes = &quot;).append(shapes.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @param anArray an array of FSShape objects that define the outlines for each glyph in the font.
-        */
-    public void setShapes(ArrayList anArray)
-    {
-        shapes = anArray;
-    }
+		return buffer.toString();
+	}
 
-    public Object clone()
-    {
-        FSDefineFont anObject = (FSDefineFont)super.clone();
-        
-        anObject.shapes = new ArrayList();
-            
-        for (Iterator i = shapes.iterator(); i.hasNext();)
-            anObject.shapes.add(((FSShape)i.next()).clone());
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        return anObject;
-    }
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineFont typedObject = (FSDefineFont)anObject;
-            
-            if (shapes != null)
-                result = shapes.equals(typedObject.shapes);
-            else
-                result = shapes == typedObject.shapes;
-        }
-        return result;
-    }
+		length += shapes.size() * 2;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;shapes&quot;, shapes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		for (Iterator&lt;FSShape&gt; shapeIterator = shapes.iterator(); shapeIterator.hasNext();)
+			length += shapeIterator.next().length(coder);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-        length += shapes.size()*2;
-        
-        for (Iterator shapeIterator = shapes.iterator(); shapeIterator.hasNext();) 
-            length += ((FSTransformObject)shapeIterator.next()).length(coder);
+		return length;
+	}
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		int currentLocation;
+		int offset;
 
-        int currentLocation;
-        int offset;
-        
-        int tableStart = coder.getPointer();
-        int tableEntry = tableStart;
-   
-        for (int i=0; i&lt;shapes.size(); i++)
-            coder.writeWord(0, 2);
+		int tableStart = coder.getPointer();
+		int tableEntry = tableStart;
 
-        for (Iterator i=shapes.iterator(); i.hasNext(); tableEntry += 16) 
-        {
-            currentLocation = coder.getPointer();
-            offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
-            
-            coder.setPointer(tableEntry);
-            coder.writeWord(offset, 2);
-            coder.setPointer(currentLocation);
-            
-            ((FSTransformObject)i.next()).encode(coder);
-        }
+		for (int i = 0; i &lt; shapes.size(); i++)
+			coder.writeWord(0, 2);
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		for (Iterator&lt;FSShape&gt; i = shapes.iterator(); i.hasNext(); tableEntry += 16)
+		{
+			currentLocation = coder.getPointer();
+			offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        shapes = new ArrayList();
-        
-        super.decode(coder);
-        
-        int offsetStart = coder.getPointer();
-        int shapeCount = coder.scanWord(2, false) / 2;        
-        
-        coder.setPointer(offsetStart);
+			coder.setPointer(tableEntry);
+			coder.writeWord(offset, 2);
+			coder.setPointer(currentLocation);
 
-        int[] offset = new int[shapeCount+1];
-        
-        for (int i=0; i&lt;shapeCount; i++)
-            offset[i] = coder.readWord(2, false);
-        
-        offset[shapeCount] = length-2;
-            
-        for (int i=0; i&lt;shapeCount; i++) {
-            coder.setPointer(offsetStart+(offset[i]&lt;&lt;3));
-            
-            if (coder.context[FSCoder.DecodeGlyphs] == 1)
-                shapes.add(new FSShape(coder));
-            else   
-                shapes.add(new FSShape(coder, offset[i+1]-offset[i]));
-        }
-        
-        coder.endObject(name());
-    }
+			i.next().encode(coder);
+		}
+
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+	}
+
+	public void decode(FSCoder coder)
+	{
+		shapes = new ArrayList();
+
+		super.decode(coder);
+
+		int offsetStart = coder.getPointer();
+		int shapeCount = coder.scanWord(2, false) / 2;
+
+		coder.setPointer(offsetStart);
+
+		int[] offset = new int[shapeCount + 1];
+
+		for (int i = 0; i &lt; shapeCount; i++)
+			offset[i] = coder.readWord(2, false);
+
+		offset[shapeCount] = length - 2;
+
+		for (int i = 0; i &lt; shapeCount; i++)
+		{
+			coder.setPointer(offsetStart + (offset[i] &lt;&lt; 3));
+
+			if (coder.context[FSCoder.DecodeGlyphs] == 1)
+				shapes.add(new FSShape(coder));
+			else
+				shapes.add(new FSShape(coder, offset[i + 1] - offset[i]));
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineFont2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineFont2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineFont2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,911 +33,1037 @@
 import java.util.*;
 
 /**
-FSDefineFont2 defines the shapes and layout of the glyphs used in a font. 
- 
-&lt;p&gt;It extends the functionality provided by the FSDefineFont class by:&lt;/p&gt;
+ * FSDefineFont2 defines the shapes and layout of the glyphs used in a font.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by the FSDefineFont class by:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;allowing more than 65535 glyphs in a particular font.&lt;/li&gt;
+ * &lt;li&gt;including the functionality provided by the FontInfo class.&lt;/li&gt;
+ * &lt;li&gt;specifying ascent, descent and leading layout information for the font.&lt;/li&gt;
+ * &lt;li&gt;specifying advances for each glyph.&lt;/li&gt;
+ * &lt;li&gt;specifying bounding rectangles for each glyph.&lt;/li&gt;
+ * &lt;li&gt;specifying kerning pairs defining the distance between pairs of glyphs.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineFont2 class combines the attributes of the FSFontInfo and
+ * FSDefineFont classes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier for this object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encoding&lt;/td&gt;
+ * &lt;td&gt;Specifies whether the font codes are ANSI, SJIS or Unicode.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;language&lt;/td&gt;
+ * &lt;td&gt;Identifies the spoken language for the font, either FSText.Japanese,
+ * FSText.Korean, FSText.Latin, FSText.SimplifiedChinese,
+ * FSText.TraditionalChinese. This attribute is used when displaying text fields
+ * and assists in determining language-appropriate line breaks.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;italic&lt;/td&gt;
+ * &lt;td&gt;Whether the font is italicised.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Whether the font is bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;small&lt;/td&gt;
+ * &lt;td&gt;Small point size fonts will be drawn aligned to pixel boundaries to
+ * improve rendering.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shapes&lt;/td&gt;
+ * &lt;td&gt;An array of FSShape objects that define the outline for each glyph.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;codes&lt;/td&gt;
+ * &lt;td&gt;An array mapping a glyph index to a particular character code in the
+ * font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Additional layout information for the glyphs in the font can also be
+ * specified through the following set of attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;ascent&lt;/td&gt;
+ * &lt;td&gt;The maximum ascent for the font in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;descent&lt;/td&gt;
+ * &lt;td&gt;The maximum descent for the font in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;leading&lt;/td&gt;
+ * &lt;td&gt;The leading for the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;advances&lt;/td&gt;
+ * &lt;td&gt;An array of integers that define the advance for each glyph in the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;An array of FSBounds object that define the bounding rectangle for each
+ * glyph in the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;kernings&lt;/td&gt;
+ * &lt;td&gt;An array of FSKerning objects that define adjustment to the advance for
+ * particular pairs of glyphs in the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The default values for the ascent, descent and leading attributes is zero and
+ * the arrays containing the advances, bounds and kernings are empty. If the
+ * attributes all set to their default values then the layout information will
+ * not be encoded. All the values must be set and the arrays must contain the
+ * same number of entries as there are glyphs before the layout information will
+ * be encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineFont2 class represents the DefineFont2 structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2. Support for spoken languages was added in Flash 6. Support for small point
+ * size fonts was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSDefineFont2 extends FSDefineObject
+{
+	private int encoding = FSText.Unicode;
+	private boolean small = false;
+	private boolean italic = false;
+	private boolean bold = false;
+	private int language = 0;
+	private String name = &quot;&quot;;
+	private ArrayList&lt;FSShape&gt; shapes = new ArrayList&lt;FSShape&gt;();
+	private ArrayList&lt;Integer&gt; codes = new ArrayList&lt;Integer&gt;();
+	private int ascent = 0;
+	private int descent = 0;
+	private int leading = 0;
+	private ArrayList&lt;Integer&gt; advances;
+	private ArrayList&lt;FSBounds&gt; bounds;
+	private ArrayList&lt;FSKerning&gt; kernings;
 
-&lt;ul&gt;
-&lt;li&gt;allowing more than 65535 glyphs in a particular font.&lt;/li&gt;
-&lt;li&gt;including the functionality provided by the FontInfo class.&lt;/li&gt;
-&lt;li&gt;specifying ascent, descent and leading layout information for the font.&lt;/li&gt;
-&lt;li&gt;specifying advances for each glyph.&lt;/li&gt;
-&lt;li&gt;specifying bounding rectangles for each glyph.&lt;/li&gt;
-&lt;li&gt;specifying kerning pairs defining the distance between pairs of glyphs.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Construct an FSDefineFont2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineFont2(FSCoder coder)
+	{
+		super(DefineFont2, 0);
+		decode(coder);
+	}
 
-&lt;p&gt;The FSDefineFont2 class combines the attributes of the FSFontInfo and FSDefineFont classes:&lt;/p&gt;
+	/**
+	 * Constructs an FSDefineFont2 object specifying only the name of the font.
+	 * 
+	 * If none of the remaining attributes are set the Flash Player will load
+	 * the font from the system on which it is running or substitute a suitable
+	 * font if the specified font cannot be found. This is particularly useful
+	 * when defining fonts that will be used to display text in
+	 * FSDefineTextField objects.
+	 * 
+	 * The font will be defined to use Unicode encoding. The flags which define
+	 * the font's face will be set to false. The arrays of glyphs which define
+	 * the shapes and the code which map the character codes to a particular
+	 * glyph will remain empty since the font is loaded from the system on which
+	 * it is displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param name
+	 *            the name of the font.
+	 */
+	public FSDefineFont2(int anIdentifier, String name)
+	{
+		super(DefineFont2, anIdentifier);
+		setName(name);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSDefineFont2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineFont2 object.
+	 */
+	public FSDefineFont2(FSDefineFont2 obj)
+	{
+		super(obj);
+		encoding = obj.encoding;
+		small = obj.small;
+		italic = obj.italic;
+		bold = obj.bold;
+		language = obj.language;
+		name = new String(obj.name);
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		shapes = new ArrayList&lt;FSShape&gt;();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator&lt;FSShape&gt; i = obj.shapes.iterator(); i.hasNext();)
+			shapes.add((FSShape) i.next().clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier for this object.&lt;/td&gt;
-&lt;/tr&gt;
+		codes = new ArrayList&lt;Integer&gt;();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_2&quot;&gt;encoding&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Specifies whether the font codes are ANSI, SJIS or Unicode.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator&lt;Integer&gt; i = obj.codes.iterator(); i.hasNext();)
+			codes.add(new Integer(i.next().intValue()));
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_3&quot;&gt;language&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the spoken language for the font, either FSText.Japanese, FSText.Korean, 
-FSText.Latin, FSText.SimplifiedChinese, FSText.TraditionalChinese. This attribute 
-is used when displaying text fields and assists in determining language-appropriate
-line breaks.&lt;/td&gt;
-&lt;/tr&gt;
+		ascent = obj.ascent;
+		descent = obj.descent;
+		leading = obj.leading;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_4&quot;&gt;italic&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether the font is italicised.&lt;/td&gt;
-&lt;/tr&gt;
+		if (advances != null)
+		{
+			advances = new ArrayList&lt;Integer&gt;();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_5&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether the font is bold.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator&lt;Integer&gt; i = obj.advances.iterator(); i.hasNext();)
+				advances.add(new Integer(i.next().intValue()));
+		}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_6&quot;&gt;small&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Small point size fonts will be drawn aligned to pixel boundaries to improve rendering.&lt;/td&gt;
-&lt;/tr&gt;
+		if (bounds != null)
+		{
+			bounds = new ArrayList&lt;FSBounds&gt;();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_7&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of the font.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator&lt;FSBounds&gt; i = obj.bounds.iterator(); i.hasNext();)
+				bounds.add((FSBounds) i.next().clone());
+		}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_8&quot;&gt;shapes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSShape objects that define the outline for each glyph.&lt;/td&gt;
-&lt;/tr&gt;
+		if (kernings != null)
+		{
+			kernings = new ArrayList&lt;FSKerning&gt;();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_9&quot;&gt;codes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array mapping a glyph index to a particular character code in the font.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator&lt;FSKerning&gt; i = obj.kernings.iterator(); i.hasNext();)
+				kernings.add((FSKerning) i.next().clone());
+		}
+	}
 
-&lt;/table&gt;
+	/**
+	 * Add a shape to the array of shapes.
+	 * 
+	 * @param anObject
+	 *            a shape.
+	 */
+	public void add(FSShape anObject)
+	{
+		shapes.add(anObject);
+	}
 
-&lt;p&gt;Additional layout information for the glyphs in the font can also be specified through the following set of attributes:&lt;/p&gt;
+	/**
+	 * Add a code to the array of codes.
+	 * 
+	 * @param aCode
+	 *            a code for a glyph.
+	 */
+	public void addCode(int aCode)
+	{
+		codes.add(new Integer(aCode));
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Add an advance to the array of advances.
+	 * 
+	 * @param anAdvance
+	 *            an advance for a glyph.
+	 */
+	public void addAdvance(int anAdvance)
+	{
+		advances.add(new Integer(anAdvance));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_10&quot;&gt;ascent&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum ascent for the font in twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a bounds object to the array of bounds for each glyph.
+	 * 
+	 * @param anObject
+	 *            an FSBounds.
+	 */
+	public void add(FSBounds anObject)
+	{
+		bounds.add(anObject);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_11&quot;&gt;descent&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum descent for the font in twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a kerning object to the array of kernings for pairs of glyphs.
+	 * 
+	 * @param anObject
+	 *            an FSKerning.
+	 */
+	public void add(FSKerning anObject)
+	{
+		kernings.add(anObject);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_12&quot;&gt;leading&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The leading for the font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the encoding used for the font codes, either FSText.ASCII,
+	 * FSText.SJIS or FSText.Unicode.
+	 * 
+	 * @return the encoding used to represent characters rendered in the font.
+	 */
+	public int getEncoding()
+	{
+		return encoding;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_13&quot;&gt;advances&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of integers that define the advance for each glyph in the font.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 7
+	/**
+	 * Does the font have a small point size. This is used only with a Unicode
+	 * font encoding.
+	 * 
+	 * @return a boolean indicating whether the font will be aligned on pixel
+	 *         boundaries.
+	 */
+	public boolean isSmall()
+	{
+		return small;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_14&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSBounds object that define the bounding rectangle for each glyph in the font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the font is small. Used only with Unicode fonts.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating the font will be aligned on pixel
+	 *            boundaries.
+	 */
+	public void setSmall(boolean aBool)
+	{
+		small = aBool;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_15&quot;&gt;kernings&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSKerning objects that define adjustment to the advance for particular pairs of glyphs in the font.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	// End Flash 7
 
-&lt;p&gt;The default values for the ascent, descent and leading attributes is zero and the arrays containing the advances, bounds and kernings are empty. If the attributes all set to their default values then the layout information will not be encoded. All the values must be set and the arrays must contain the same number of entries as there are glyphs before the layout information will be encoded.&lt;/p&gt;
+	/**
+	 * Is the font italicised.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in italics.
+	 */
+	public boolean isItalic()
+	{
+		return italic;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Is the font bold.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in a bold face.
+	 */
+	public boolean isBold()
+	{
+		return bold;
+	}
 
-&lt;p&gt;The FSDefineFont2 class represents the DefineFont2 structure from the Macromedia 
-Flash (SWF) File Format Specification. It was introduced in Flash 2. Support for
-spoken languages was added in Flash 6. Support for small point size fonts was 
-added in Flash 7.&lt;/p&gt;
- */
-public class FSDefineFont2 extends FSDefineObject
-{
-    private int encoding = FSText.Unicode;
-    private boolean small = false;
-    private boolean italic = false;
-    private boolean bold = false;
-    private int language = 0;
-    private String name = &quot;&quot;;
-    private ArrayList  shapes = new ArrayList();
-    private ArrayList  codes = new ArrayList();
-    private int ascent = 0;
-    private int descent = 0;
-    private int leading = 0;
-    private ArrayList advances = null;
-    private ArrayList bounds = null;
-    private ArrayList kernings = null;
-    
-    /**
-     * Construct an FSDefineFont2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineFont2(FSCoder coder)
-    {
-        super(DefineFont2, 0);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSDefineFont2 object specifying only the name of the font. 
-     *
-     * If none of the remaining attributes are set the Flash Player will load the font from the system
-     * on which it is running or substitute a suitable font if the specified font cannot be found. This 
-     * is particularly useful when defining fonts that will be used to display text in FSDefineTextField 
-     * objects.
-     *
-     * The font will be defined to use Unicode encoding. The flags which define the font's face will be 
-     * set to false. The arrays  of glyphs which define the shapes and the code which map the character 
-     * codes to a particular glyph will remain empty since the font is loaded from the system on which 
-     * it is displayed.
-     *
-     * @param anIdentifier the unique identifier for this object.
-     * @param name the name of the font.
-     */
-    public FSDefineFont2(int anIdentifier, String name)
-    {
-        super(DefineFont2, anIdentifier);
-        setName(name);
-    }
-    /**
-     * Constructs an FSDefineFont2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineFont2 object.
-     */
-    public FSDefineFont2(FSDefineFont2 obj)
-    {
-        super(obj);
-        encoding = obj.encoding;
-        small = obj.small;
-        italic = obj.italic;
-        bold = obj.bold;
-        language = obj.language;
-        name = new String(obj.name);
-        
-        shapes = new ArrayList();
-        
-        for (Iterator i = obj.shapes.iterator(); i.hasNext();)
-            shapes.add(((FSShape)i.next()).clone());
+	// Flash 6
+	/**
+	 * Gets the language code identifying the type of spoken language for the
+	 * font either FSText.Japanese, FSText.Korean, FSText.Latin,
+	 * FSText.SimplifiedChinese or FSText.TraditionalChinese.
+	 * 
+	 * @return the language code used to determine how line-breaks are inserted
+	 *         into text rendered using the font. Returns 0 if the object was
+	 *         decoded from a movie contains Flash 5 or less.
+	 */
+	public int getLanguage()
+	{
+		return language;
+	}
 
-        codes = new ArrayList();
-            
-        for (Iterator i = obj.codes.iterator(); i.hasNext();)
-            codes.add(new Integer(((Integer)i.next()).intValue()));
+	/**
+	 * Sets the language code used to determine the position of line-breaks in
+	 * text rendered using the font.
+	 * 
+	 * NOTE: The language attribute is ignored if the object is encoded in a
+	 * Flash 5 movie.
+	 * 
+	 * @param code
+	 *            the code identifying the spoken language either
+	 *            FSText.Japanese, FSText.Korean, FSText.Latin,
+	 *            FSText.SimplifiedChinese or FSText.TraditionalChinese.
+	 */
+	public void setLanguage(int code)
+	{
+		language = code;
+	}
 
-        ascent = obj.ascent;
-        descent = obj.descent;
-        leading = obj.leading;
-        
-        if (advances != null)
-        {
-            advances = new ArrayList();
-            
-            for (Iterator i = obj.advances.iterator(); i.hasNext();)
-                advances.add(new Integer(((Integer)i.next()).intValue()));
-        }
+	// End Flash 6
 
-        if (bounds != null)
-        {
-            bounds = new ArrayList();
-            
-            for (Iterator i = obj.bounds.iterator(); i.hasNext();)
-                bounds.add(((FSBounds)i.next()).clone());
-        }
+	/**
+	 * Gets the name of the font family.
+	 * 
+	 * @return the name of the font.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-        if (kernings != null)
-        {
-            kernings = new ArrayList();
-            
-            for (Iterator i = obj.kernings.iterator(); i.hasNext();)
-                kernings.add(((FSKerning)i.next()).clone());
-        }
-    }
+	/**
+	 * Gets the array of shapes used to define the outlines of each font glyph.
+	 * 
+	 * @return an array of FSShape objects
+	 */
+	public ArrayList getShapes()
+	{
+		return shapes;
+	}
 
-    /** Add a shape to the array of shapes.
+	/**
+	 * Gets the array of codes used to identify each glyph in the font. The
+	 * ordinal position of each Integer representing a code identifies a
+	 * particular glyph in the shapes array.
+	 * 
+	 * @return an array of Integer objects that contain the character codes for
+	 *         each glyph in the font.
+	 */
+	public ArrayList getCodes()
+	{
+		return codes;
+	}
 
-        @param anObject a shape.
-        */
-    public void add(FSShape anObject) { shapes.add(anObject); }
+	/**
+	 * Gets the ascent for the font in twips.
+	 * 
+	 * @return the ascent for the font.
+	 */
+	public int getAscent()
+	{
+		return ascent;
+	}
 
-    /** Add a code to the array of codes.
+	/**
+	 * Gets the descent for the font in twips.
+	 * 
+	 * @return the descent for the font.
+	 */
+	public int getDescent()
+	{
+		return descent;
+	}
 
-        @param aCode a code for a glyph.
-        */
-    public void addCode(int aCode) { codes.add(new Integer(aCode)); }
+	/**
+	 * Gets the leading for the font in twips.
+	 * 
+	 * @return the leading for the font.
+	 */
+	public int getLeading()
+	{
+		return leading;
+	}
 
-    /** Add an advance to the array of advances.
+	/**
+	 * Gets the array of advances defined for each glyph in the font.
+	 * 
+	 * @return an array of Integer objects that contain the advance for each
+	 *         glyph in the font.
+	 */
+	public ArrayList getAdvances()
+	{
+		return advances;
+	}
 
-        @param anAdvance an advance for a glyph.
-        */
-    public void addAdvance(int anAdvance) { advances.add(new Integer(anAdvance)); }
+	/**
+	 * Gets the array of bounding rectangles defined for each glyph in the font.
+	 * 
+	 * @return an array of FSBounds objects.
+	 */
+	public ArrayList getBounds()
+	{
+		return bounds;
+	}
 
-    /** Add a bounds object to the array of bounds for each glyph.
+	/**
+	 * Gets the array of kerning records that define the spacing between glyph
+	 * pairs.
+	 * 
+	 * @return an array of FSKerning objects that define the spacing adjustment
+	 *         between pairs of glyphs.
+	 */
+	public ArrayList getKernings()
+	{
+		return kernings;
+	}
 
-        @param anObject an FSBounds.
-        */
-    public void add(FSBounds anObject) { bounds.add(anObject); }
+	/**
+	 * Sets the encoding for the font character codes.
+	 * 
+	 * @param aType
+	 *            the encoding scheme used to denote characters, either
+	 *            FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	 */
+	public void setEncoding(int aType)
+	{
+		encoding = aType;
+	}
 
-    /** Add a kerning object to the array of kernings for pairs of glyphs.
+	/**
+	 * Set the font is italicised.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            italics
+	 */
+	public void setItalic(boolean aBool)
+	{
+		italic = aBool;
+	}
 
-        @param anObject an FSKerning.
-        */
-    public void add(FSKerning anObject) { kernings.add(anObject); }
+	/**
+	 * Set the font is bold.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            bold face.
+	 */
+	public void setBold(boolean aBool)
+	{
+		bold = aBool;
+	}
 
-    /** Gets the encoding used for the font codes, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	/**
+	 * Set the name of the font.
+	 * 
+	 * @param aString
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-        @return the encoding used to represent characters rendered in the font.
-        */
-    public int getEncoding()
-    {
-        return encoding;
-    }
+	/**
+	 * Set the array of shape records that define the outlines of the characters
+	 * used from the font.
+	 * 
+	 * @param anArray
+	 *            an array of FSShape objects that define the glyphs for the
+	 *            font.
+	 */
+	public void setShapes(ArrayList anArray)
+	{
+		shapes = anArray;
+	}
 
-// Flash 7
-    /** Does the font have a small point size. This is used only with a Unicode font encoding.
-     * 
-     *  @return a boolean indicating whether the font will be aligned on pixel boundaries.
-     */
-    public boolean isSmall() 
-    {
-        return small;
-    }
+	/**
+	 * Sets the codes used to identify each glyph in the font.
+	 * 
+	 * @param anArray
+	 *            sets the code table that maps a particular glyph to a
+	 *            character code.
+	 */
+	public void setCodes(ArrayList anArray)
+	{
+		codes = anArray;
+	}
 
-    /** Sets the font is small. Used only with Unicode fonts.
-     *
-     * @param aBool a boolean flag indicating the font will be aligned on pixel boundaries.
-     */
-    public void setSmall(boolean aBool)
-    {
-        small = aBool;
-    }
-// End Flash 7
+	/**
+	 * Sets the ascent for the font in twips.
+	 * 
+	 * @param aNumber
+	 *            the ascent for the font.
+	 */
+	public void setAscent(int aNumber)
+	{
+		ascent = aNumber;
+	}
 
-    /** Is the font italicised.
+	/**
+	 * Sets the descent for the font in twips.
+	 * 
+	 * @param aNumber
+	 *            the descent for the font.
+	 */
+	public void setDescent(int aNumber)
+	{
+		descent = aNumber;
+	}
 
-        @return a boolean indicating whether the font is rendered in italics.
-        */
-    public boolean isItalic() 
-    {
-        return italic;
-    }
+	/**
+	 * Sets the leading for the font in twips.
+	 * 
+	 * @param aNumber
+	 *            the descent for the font.
+	 */
+	public void setLeading(int aNumber)
+	{
+		leading = aNumber;
+	}
 
-    /** Is the font bold.
+	/**
+	 * Sets the array of advances for each glyph in the font.
+	 * 
+	 * @param anArray
+	 *            of Integer objects that define the spacing between glyphs.
+	 */
+	public void setAdvances(ArrayList anArray)
+	{
+		advances = anArray;
+	}
 
-        @return a boolean indicating whether the font is rendered in a bold face.
-        */
-    public boolean isBold() 
-    {
-        return bold;
-    }
+	/**
+	 * Sets the array of bounding rectangles for each glyph in the font.
+	 * 
+	 * @param anArray
+	 *            an array of FSBounds objects that define the bounding
+	 *            rectangles that enclose each glyph in the font.
+	 */
+	public void setBounds(ArrayList anArray)
+	{
+		bounds = anArray;
+	}
 
-// Flash 6
-    /** Gets the language code identifying the type of spoken language for the font
-     *  either FSText.Japanese, FSText.Korean, FSText.Latin, FSText.SimplifiedChinese 
-     *  or FSText.TraditionalChinese.
-     * 
-     *  @return the language code used to determine how line-breaks are inserted 
-     *  into text rendered using the font. Returns 0 if the object was decoded 
-     *  from a movie contains Flash 5 or less.
-     */
-    public int getLanguage()
-    {
-        return language;
-    }
+	/**
+	 * Sets the array of kerning records for pairs of glyphs in the font.
+	 * 
+	 * @param anArray
+	 *            an array of FSKerning objects that define an adjustment
+	 *            applied to the spacing between pairs of glyphs.
+	 */
+	public void setKernings(ArrayList anArray)
+	{
+		kernings = anArray;
+	}
 
-    /** Sets the language code used to determine the position of line-breaks in 
-     *  text rendered using the font.
-     * 
-     *  NOTE: The language attribute is ignored if the object is encoded in a Flash 5 movie.
-     * 
-     *  @param code the code identifying the spoken language either FSText.Japanese, 
-     * FSText.Korean, FSText.Latin, FSText.SimplifiedChinese or FSText.TraditionalChinese.
-     */
-    public void setLanguage(int code)
-    {
-        language = code;
-    }
-// End Flash 6
 
-    /** Gets the name of the font family.
+	public Object clone()
+	{
+		FSDefineFont2 anObject = (FSDefineFont2) super.clone();
 
-        @return the name of the font.
-        */
-    public String getName()
-    {
-        return name; 
-    }
+		anObject.shapes = new ArrayList&lt;FSShape&gt;();
 
-    /** Gets the array of shapes used to define the outlines of each font glyph.
+		for (Iterator&lt;FSShape&gt; i = shapes.iterator(); i.hasNext();)
+			anObject.shapes.add((FSShape) i.next().clone());
 
-        @return an array of FSShape objects
-        */
-    public ArrayList getShapes()
-    {
-        return shapes;
-    }
+		anObject.codes = new ArrayList&lt;Integer&gt;();
 
-    /** Gets the array of codes used to identify each glyph in the font. The ordinal position of each Integer representing a code identifies a particular glyph in the shapes array.
+		for (Iterator&lt;Integer&gt; i = codes.iterator(); i.hasNext();)
+			anObject.codes.add(new Integer(i.next().intValue()));
 
-        @return an array of Integer objects that contain the character codes for each glyph in the font.
-        */
-    public ArrayList getCodes()
-    {
-        return codes;
-    }
+		if (advances != null)
+		{
+			anObject.advances = new ArrayList&lt;Integer&gt;();
 
-    /** Gets the ascent for the font in twips.
+			for (Iterator&lt;Integer&gt; i = advances.iterator(); i.hasNext();)
+				anObject.advances.add(new Integer(i.next().intValue()));
+		}
 
-        @return the ascent for the font.
-        */
-    public int getAscent()
-    {
-        return ascent;
-    }
+		if (bounds != null)
+		{
+			anObject.bounds = new ArrayList&lt;FSBounds&gt;();
 
-    /** Gets the descent for the font in twips.
+			for (Iterator&lt;FSBounds&gt; i = bounds.iterator(); i.hasNext();)
+				anObject.bounds.add((FSBounds) i.next().clone());
+		}
 
-        @return the descent for the font.
-        */
-    public int getDescent()
-    {
-        return descent;
-    }
+		if (kernings != null)
+		{
+			anObject.kernings = new ArrayList&lt;FSKerning&gt;();
 
-    /** Gets the leading for the font in twips.
+			for (Iterator&lt;FSKerning&gt; i = kernings.iterator(); i.hasNext();)
+				anObject.kernings.add((FSKerning) i.next().clone());
+		}
 
-        @return the leading for the font.
-        */
-    public int getLeading()
-    {
-        return leading;
-    }
+		return anObject;
+	}
 
-    /** Gets the array of advances defined for each glyph in the font.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return an array of Integer objects that contain the advance for each glyph in the font.
-        */
-    public ArrayList getAdvances()
-    {
-        return advances;
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineFont2 typedObject = (FSDefineFont2) anObject;
 
-    /** Gets the array of bounding rectangles defined for each glyph in the font.
+			result = encoding == typedObject.encoding;
+			// Flash 7
+			result = result &amp;&amp; small == typedObject.small;
+			// End Flash 7
+			result = result &amp;&amp; italic == typedObject.italic;
+			result = result &amp;&amp; bold == typedObject.bold;
+			// Flash 6
+			result = result &amp;&amp; language == typedObject.language;
+			// End Flash 6
 
-        @return an array of FSBounds objects.
-        */
-    public ArrayList getBounds()
-    {
-        return bounds;
-    }
+			if (name != null)
+				result = result &amp;&amp; name.equals(typedObject.name);
+			else
+				result = result &amp;&amp; name == typedObject.name;
 
-    /** Gets the array of kerning records that define the spacing between glyph pairs.
+			if (shapes != null)
+				result = result &amp;&amp; shapes.equals(typedObject.shapes);
+			else
+				result = result &amp;&amp; shapes == typedObject.shapes;
 
-        @return an array of FSKerning objects that define the spacing adjustment between pairs of glyphs.
-        */
-    public ArrayList getKernings()
-    {
-        return kernings;
-    }
+			if (codes != null)
+				result = result &amp;&amp; codes.equals(typedObject.codes);
+			else
+				result = result &amp;&amp; codes == typedObject.codes;
 
-    /** Sets the encoding for the font character codes.
+			if (containsLayoutInfo())
+			{
+				result = result &amp;&amp; ascent == typedObject.ascent;
+				result = result &amp;&amp; descent == typedObject.descent;
+				result = result &amp;&amp; leading == typedObject.leading;
 
-        @param aType the encoding scheme used to denote characters, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
-        */
-    public void setEncoding(int aType)
-    {
-        encoding = aType;
-    }
+				if (advances != null)
+					result = result &amp;&amp; advances.equals(typedObject.advances);
+				else
+					result = result &amp;&amp; advances == typedObject.advances;
 
-    /** Set the font is italicised.
+				if (bounds != null)
+					result = result &amp;&amp; bounds.equals(typedObject.bounds);
+				else
+					result = result &amp;&amp; bounds == typedObject.bounds;
 
-        @param aBool a boolean flag indicating whether the font will be rendered in italics */
-    public void setItalic(boolean aBool)
-    {
-        italic = aBool;
-    }
+				if (kernings != null)
+					result = result &amp;&amp; kernings.equals(typedObject.kernings);
+				else
+					result = result &amp;&amp; kernings == typedObject.kernings;
+			}
+		}
+		return result;
+	}
 
-    /** Set the font is bold.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param aBool a boolean flag indicating whether the font will be rendered in bold face.
-        */
-    public void setBold(boolean aBool)
-    {
-        bold = aBool;
-    }
+		buffer.append(&quot;FSDefineFont2: { &quot;);
+		buffer.append(&quot;encoding = &quot;).append(encoding).append(&quot;; &quot;);
+		// Flash 7
+		buffer.append(&quot;small = &quot;).append(small).append(&quot;; &quot;);
+		// End Flash 7
+		buffer.append(&quot;italic = &quot;).append(italic).append(&quot;; &quot;);
+		buffer.append(&quot;bold = &quot;).append(bold).append(&quot;; &quot;);
+		// Flash 6
+		buffer.append(&quot;language = &quot;).append(language).append(&quot;; &quot;);
+		// End Flash 6
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
+		buffer.append(&quot;shapes = &quot;).append(shapes.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;codes = &quot;).append(codes.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;ascent = &quot;).append(ascent).append(&quot;; &quot;);
+		buffer.append(&quot;descent = &quot;).append(descent).append(&quot;; &quot;);
+		buffer.append(&quot;leading = &quot;).append(leading).append(&quot;; &quot;);
+		buffer.append(&quot;advances = &quot;).append(advances.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;kernings = &quot;).append(kernings.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Set the name of the font.
+		return buffer.toString();
+	}
 
-        @param aString the name assigned to the font, identifying the font family.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+	public int length(FSCoder coder)
+	{
+		boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
+		int wideCodes = 0;
 
-    /** Set the array of shape records that define the outlines of the characters used from the font.
+		if (coder.context[FSCoder.Version] &gt; 5)
+			wideCodes = 1;
+		else
+			wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
 
-        @param anArray an array of FSShape objects that define the glyphs for the font.
-        */
-    public void setShapes(ArrayList anArray)
-    {
-        shapes = anArray;
-    }
+		super.length(coder);
 
-    /** Sets the codes used to identify each glyph in the font.
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = wideCodes;
+		length += 3;
+		length += FSCoder.strlen(name, false);
+		length += 2;
+		length += shapes.size() * (wideOffsets ? 4 : 2);
+		length += wideOffsets ? 4 : 2;
 
-        @param anArray sets the code table that maps a particular glyph to a character code.
-        */
-    public void setCodes(ArrayList anArray)
-    {
-        codes = anArray;
-    }
+		for (Iterator&lt;FSShape&gt; shapeIterator = shapes.iterator(); shapeIterator.hasNext();)
+			length += shapeIterator.next().length(coder);
 
-    /** Sets the ascent for the font in twips.
+		length += shapes.size() * ((wideCodes == 1) ? 2 : 1);
 
-        @param aNumber the ascent for the font.
-        */
-    public void setAscent(int aNumber)
-    {
-        ascent = aNumber;
-    }
+		if (containsLayoutInfo())
+		{
+			length += 6;
+			length += shapes.size() * 2;
 
-    /** Sets the descent for the font in twips.
+			for (Iterator&lt;FSBounds&gt; boundsIterator = bounds.iterator(); boundsIterator.hasNext();)
+				length += boundsIterator.next().length(coder);
 
-        @param aNumber the descent for the font.
-        */
-    public void setDescent(int aNumber)
-    {
-        descent = aNumber;
-    }
+			length += 2;
+			length += kernings.size() * ((wideCodes == 1) ? 6 : 4);
+		}
 
-    /** Sets the leading for the font in twips.
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = 0;
 
-        @param aNumber the descent for the font.
-        */
-    public void setLeading(int aNumber)
-    {
-        leading = aNumber;
-    }
+		return length;
+	}
 
-    /** Sets the array of advances for each glyph in the font.
+	public void encode(FSCoder coder)
+	{
+		boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
+		int wideCodes = 0;
+		int format = 0;
 
-        @param anArray of Integer objects that define the spacing between glyphs.
-        */
-    public void setAdvances(ArrayList anArray)
-    {
-        advances = anArray;
-    }
+		if (coder.context[FSCoder.Version] &gt; 5)
+			wideCodes = 1;
+		else
+			wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
 
-    /** Sets the array of bounding rectangles for each glyph in the font.
+		if (encoding == FSText.ANSI)
+			format = 1;
+		// Flash 7
+		else if (small)
+			format = 2;
+		// End Flash 7
+		else if (encoding == FSText.SJIS)
+			format = 4;
 
-        @param anArray an array of FSBounds objects that define the bounding rectangles that enclose each glyph in the font.
-        */
-    public void setBounds(ArrayList anArray)
-    {
-        bounds = anArray;
-    }
+		super.encode(coder);
 
-    /** Sets the array of kerning records for pairs of glyphs in the font.
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = wideCodes;
 
-        @param anArray an array of FSKerning objects that define an adjustment applied to the spacing between pairs of glyphs.
-        */
-    public void setKernings(ArrayList anArray)
-    {
-        kernings = anArray;
-    }
+		coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
+		coder.writeBits(format, 3);
+		coder.writeBits(wideOffsets ? 1 : 0, 1);
+		coder.writeBits(wideCodes, 1);
+		coder.writeBits(italic ? 1 : 0, 1);
+		coder.writeBits(bold ? 1 : 0, 1);
+		coder.writeWord(coder.context[FSCoder.Version] &gt; 5 ? language : 0, 1);
+		coder.writeWord(coder.strlen(name, false), 1);
 
-    public Object clone()
-    {    
-        FSDefineFont2 anObject = (FSDefineFont2)super.clone();
-        
-        anObject.shapes = new ArrayList();
-            
-        for (Iterator i = shapes.iterator(); i.hasNext();)
-            anObject.shapes.add(((FSShape)i.next()).clone());
+		coder.writeString(name);
+		coder.writeWord(shapes.size(), 2);
 
-        anObject.codes = new ArrayList();
-            
-        for (Iterator i = codes.iterator(); i.hasNext();)
-            anObject.codes.add(new Integer(((Integer)i.next()).intValue()));
+		int currentLocation;
+		int offset;
 
-        if (advances != null)
-        {
-            anObject.advances = new ArrayList();
-            
-            for (Iterator i = advances.iterator(); i.hasNext();)
-                anObject.advances.add(new Integer(((Integer)i.next()).intValue()));
-        }
+		int tableStart = coder.getPointer();
+		int tableEntry = tableStart;
+		int entrySize = wideOffsets ? 4 : 2;
 
-        if (bounds != null)
-        {
-            anObject.bounds = new ArrayList();
-            
-            for (Iterator i = bounds.iterator(); i.hasNext();)
-                anObject.bounds.add(((FSBounds)i.next()).clone());
-        }
+		for (int i = 0; i &lt;= shapes.size(); i++)
+			coder.writeWord(0, entrySize);
 
-        if (kernings != null)
-        {
-            anObject.kernings = new ArrayList();
-            
-            for (Iterator i = kernings.iterator(); i.hasNext();)
-                anObject.kernings.add(((FSKerning)i.next()).clone());
-        }
-                
-        return anObject;
-    }
+		for (Iterator&lt;FSShape&gt; i = shapes.iterator(); i.hasNext(); tableEntry += entrySize &lt;&lt; 3)
+		{
+			currentLocation = coder.getPointer();
+			offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineFont2 typedObject = (FSDefineFont2)anObject;
-            
-            result = encoding == typedObject.encoding;
-// Flash 7
-            result = result &amp;&amp; small == typedObject.small;
-// End Flash 7
-            result = result &amp;&amp; italic == typedObject.italic;
-            result = result &amp;&amp; bold == typedObject.bold;
-// Flash 6
-            result = result &amp;&amp; language == typedObject.language;
-// End Flash 6
+			coder.setPointer(tableEntry);
+			coder.writeWord(offset, entrySize);
+			coder.setPointer(currentLocation);
 
-            if (name != null)
-                result = result &amp;&amp; name.equals(typedObject.name);
-            else
-                result = result &amp;&amp; name == typedObject.name;
+			i.next().encode(coder);
+		}
 
-            if (shapes != null)
-                result = result &amp;&amp; shapes.equals(typedObject.shapes);
-            else
-                result = result &amp;&amp; shapes == typedObject.shapes;
+		currentLocation = coder.getPointer();
+		offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
 
-            if (codes != null)
-                result = result &amp;&amp; codes.equals(typedObject.codes);
-            else
-                result = result &amp;&amp; codes == typedObject.codes;
-            
-            if (containsLayoutInfo())
-            {
-                result = result &amp;&amp; ascent == typedObject.ascent;
-                result = result &amp;&amp; descent == typedObject.descent;
-                result = result &amp;&amp; leading == typedObject.leading;
-                
-                if (advances != null)
-                    result = result &amp;&amp; advances.equals(typedObject.advances);
-                else
-                    result = result &amp;&amp; advances == typedObject.advances;
-    
-                if (bounds != null)
-                    result = result &amp;&amp; bounds.equals(typedObject.bounds);
-                else
-                    result = result &amp;&amp; bounds == typedObject.bounds;
-    
-                if (kernings != null)
-                    result = result &amp;&amp; kernings.equals(typedObject.kernings);
-                else
-                    result = result &amp;&amp; kernings == typedObject.kernings;
-            }
-        }
-        return result;
-    }
+		coder.setPointer(tableEntry);
+		coder.writeWord(offset, entrySize);
+		coder.setPointer(currentLocation);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encoding&quot;, encoding);
-// Flash 7
-            Transform.append(buffer, &quot;small&quot;, small);
-// End Flash 7
-            Transform.append(buffer, &quot;italic&quot;, italic);
-            Transform.append(buffer, &quot;bold&quot;, bold);
-// Flash 6
-            Transform.append(buffer, &quot;language&quot;, language);
-// End Flash 6
-            Transform.append(buffer, &quot;name&quot;, name);
-            Transform.append(buffer, &quot;shapes&quot;, shapes, depth);
-            Transform.append(buffer, &quot;codes&quot;, codes, depth);
-            Transform.append(buffer, &quot;ascent&quot;, ascent);
-            Transform.append(buffer, &quot;descent&quot;, descent);
-            Transform.append(buffer, &quot;leading&quot;, leading);
-            Transform.append(buffer, &quot;advances&quot;, advances, depth);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;kernings&quot;, kernings, depth);        
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+			coder.writeWord(((Integer) codesIterator.next()).intValue(),
+							(wideCodes == 1) ? 2 : 1);
 
-    public int length(FSCoder coder)
-    {
-        boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
-        int wideCodes = 0;
-        
-        if (coder.context[FSCoder.Version] &gt; 5)
-            wideCodes = 1;
-        else
-            wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
+		if (containsLayoutInfo())
+		{
+			coder.writeWord(ascent, 2);
+			coder.writeWord(descent, 2);
+			coder.writeWord(leading, 2);
 
-        super.length(coder);
-        
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = wideCodes;
-        length += 3;
-        length += coder.strlen(name, false);
-        length += 2;
-        length += shapes.size()*(wideOffsets ? 4 : 2);
-        length += wideOffsets ? 4 : 2;
-    
-        for (Iterator shapeIterator = shapes.iterator(); shapeIterator.hasNext();) 
-            length += ((FSTransformObject)shapeIterator.next()).length(coder);
-    
-        length += shapes.size()*((wideCodes == 1) ? 2 : 1);
-    
-        if (containsLayoutInfo())
-        {
-            length += 6;
-            length += shapes.size()*2;
-        
-            for (Iterator boundsIterator = bounds.iterator(); boundsIterator.hasNext();) 
-                length += ((FSTransformObject)boundsIterator.next()).length(coder);
-        
-            length += 2;
-            length += kernings.size()*((wideCodes == 1) ? 6 : 4);
-        }
+			for (Iterator advancesIterator = advances.iterator(); advancesIterator
+							.hasNext();)
+				coder.writeWord(((Integer) advancesIterator.next()).intValue(),
+								2);
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = 0;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
-        int wideCodes = 0;
-        int format = 0;
-        
-        if (coder.context[FSCoder.Version] &gt; 5)
-            wideCodes = 1;
-        else
-            wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
-            
-        if (encoding == FSText.ANSI)
-            format = 1;
-// Flash 7
-        else if (small)
-           format = 2;
-// End Flash 7
-        else if (encoding == FSText.SJIS)
-            format = 4;
-        
-        super.encode(coder);
+			for (Iterator&lt;FSBounds&gt; boundsIterator = bounds.iterator(); boundsIterator
+							.hasNext();)
+				boundsIterator.next().encode(coder);
 
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = wideCodes;
-        
-        coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
-        coder.writeBits(format, 3);
-        coder.writeBits(wideOffsets ? 1 : 0, 1);
-        coder.writeBits(wideCodes, 1);
-        coder.writeBits(italic ? 1 : 0, 1);
-        coder.writeBits(bold ? 1 : 0, 1);
-        coder.writeWord(coder.context[FSCoder.Version] &gt; 5 ? language : 0, 1);
-        coder.writeWord(coder.strlen(name, false), 1);
+			coder.writeWord(kernings.size(), 2);
 
-        coder.writeString(name);
-        coder.writeWord(shapes.size(), 2);
+			for (Iterator&lt;FSKerning&gt; kerningIterator = kernings.iterator(); kerningIterator
+							.hasNext();)
+				kerningIterator.next().encode(coder);
+		}
 
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = 0;
+	}
 
-        int currentLocation;
-        int offset;
-        
-        int tableStart = coder.getPointer();
-        int tableEntry = tableStart;
-        int entrySize = wideOffsets ? 4 : 2;
-   
-        for (int i=0; i&lt;=shapes.size(); i++)
-            coder.writeWord(0, entrySize);
+	public void decode(FSCoder coder)
+	{
+		boolean containsWideOffsets = false;
+		boolean containsWideCodes = false;
+		boolean containsLayout = false;
 
-        for (Iterator i=shapes.iterator(); i.hasNext(); tableEntry += entrySize &lt;&lt; 3) 
-        {
-            currentLocation = coder.getPointer();
-            offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
-            
-            coder.setPointer(tableEntry);
-            coder.writeWord(offset, entrySize);
-            coder.setPointer(currentLocation);
+		int glyphCount = 0;
+		int kerningCount = 0;
+		int nameLength = 0;
 
-            ((FSTransformObject)i.next()).encode(coder);
-        }
+		super.decode(coder);
 
-        currentLocation = coder.getPointer();
-        offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
-        
-        coder.setPointer(tableEntry);
-        coder.writeWord(offset, entrySize);
-        coder.setPointer(currentLocation);
+		containsLayout = coder.readBits(1, false) != 0 ? true : false;
+		int format = coder.readBits(3, false);
 
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-            coder.writeWord(((Integer)codesIterator.next()).intValue(), (wideCodes == 1) ? 2 : 1);
-    
-        if (containsLayoutInfo())
-        {
-            coder.writeWord(ascent, 2);
-            coder.writeWord(descent, 2);
-            coder.writeWord(leading, 2);
-    
-            for (Iterator advancesIterator = advances.iterator(); advancesIterator.hasNext();)
-                coder.writeWord(((Integer)advancesIterator.next()).intValue(), 2);
+		encoding = FSText.Unicode;
 
-            for (Iterator boundsIterator = bounds.iterator(); boundsIterator.hasNext();)
-                ((FSTransformObject)boundsIterator.next()).encode(coder);
+		if (format == 1)
+			encoding = FSText.ANSI;
+		// Flash 7
+		else if (format == 2)
+			small = true;
+		// End Flash 7
+		else if (format == 4)
+			encoding = FSText.SJIS;
 
-            coder.writeWord(kernings.size(), 2);
-    
-            for (Iterator kerningIterator = kernings.iterator(); kerningIterator.hasNext();)
-                ((FSTransformObject)kerningIterator.next()).encode(coder);
-        }
+		containsWideOffsets = coder.readBits(1, false) != 0 ? true : false;
+		containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = 0;
+		coder.context[FSCoder.WideCodes] = containsWideCodes ? 1 : 0;
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsWideOffsets = false;
-        boolean containsWideCodes = false;
-        boolean containsLayout = false;
-        
-        int glyphCount = 0;
-        int kerningCount = 0;
-        int nameLength = 0;
-        
-        super.decode(coder);
-        
-        containsLayout = coder.readBits(1, false) != 0 ? true : false;
-        int format = coder.readBits(3, false);
-        
-        encoding = FSText.Unicode;
+		italic = coder.readBits(1, false) != 0 ? true : false;
+		bold = coder.readBits(1, false) != 0 ? true : false;
+		language = coder.readBits(8, false);
+		nameLength = coder.readByte();
+		name = coder.readString(nameLength);
 
-        if (format == 1)
-            encoding = FSText.ANSI;
-// Flash 7
-        else if (format == 2)
-            small = true;
-// End Flash 7
-        else if (format == 4)
-            encoding = FSText.SJIS;
-        
-        containsWideOffsets = coder.readBits(1, false) != 0 ? true : false;
-        containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
+		if (name.length() &gt; 0)
+		{
+			while (name.charAt(name.length() - 1) == 0)
+			{
+				name = name.substring(0, name.length() - 1);
+			}
+		}
 
-        coder.context[FSCoder.WideCodes] = containsWideCodes ? 1 : 0;
+		glyphCount = coder.readWord(2, false);
 
-        italic = coder.readBits(1, false) != 0 ? true : false;
-        bold = coder.readBits(1, false) != 0 ? true : false;
-        language = coder.readBits(8, false);
-        nameLength = coder.readWord(1, false);
-        name = coder.readString(nameLength);
-        
-        if (name.length() &gt; 0)
-        {
-            while (name.charAt(name.length()-1) == 0) {
-            	name = name.substring(0, name.length()-1);
-            }
-        }
-        
-        glyphCount = coder.readWord(2, false);
+		int offsetStart = coder.getPointer();
+		int[] offset = new int[glyphCount + 1];
 
-        int offsetStart = coder.getPointer();
-        int[] offset = new int[glyphCount+1];
-        
-        for (int i=0; i&lt;glyphCount; i++)
-            offset[i] = coder.readWord((containsWideOffsets) ? 4 : 2, false);
+		for (int i = 0; i &lt; glyphCount; i++)
+			offset[i] = coder.readWord((containsWideOffsets) ? 4 : 2, false);
 
-        offset[glyphCount] = coder.readWord((containsWideOffsets) ? 4 : 2, false);
+		offset[glyphCount] = coder.readWord((containsWideOffsets) ? 4 : 2,
+						false);
 
-        for (int i=0; i&lt;glyphCount; i++)
-        {
-            coder.setPointer(offsetStart+(offset[i]&lt;&lt;3));
-            
-            if (coder.context[FSCoder.DecodeGlyphs] == 1)
-                shapes.add(new FSShape(coder));
-            else   
-                shapes.add(new FSShape(coder, offset[i+1]-offset[i]));
-                
-        }
+		for (int i = 0; i &lt; glyphCount; i++)
+		{
+			coder.setPointer(offsetStart + (offset[i] &lt;&lt; 3));
 
-        for (int i=0; i&lt;glyphCount; i++)
-            codes.add(new Integer(coder.readWord((containsWideCodes) ? 2 : 1, false)));
+			if (coder.context[FSCoder.DecodeGlyphs] == 1)
+				shapes.add(new FSShape(coder));
+			else
+				shapes.add(new FSShape(coder, offset[i + 1] - offset[i]));
 
-        if (containsLayout)
-        {
-            ascent = coder.readWord(2, true);
-            descent = coder.readWord(2, true);
-            leading = coder.readWord(2, true);
-            
-            advances = new ArrayList();
-            bounds = new ArrayList();
-            kernings = new ArrayList();
+		}
 
-            for (int i=0; i&lt;glyphCount; i++)
-                advances.add(new Integer(coder.readWord(2, true)));
+		for (int i = 0; i &lt; glyphCount; i++)
+			codes.add(new Integer(coder.readWord((containsWideCodes) ? 2 : 1,
+							false)));
 
-            for (int i=0; i&lt;glyphCount; i++)
-                bounds.add(new FSBounds(coder));
+		if (containsLayout)
+		{
+			ascent = coder.readWord(2, true);
+			descent = coder.readWord(2, true);
+			leading = coder.readWord(2, true);
 
-            kerningCount = coder.readWord(2, false);
+			advances = new ArrayList();
+			bounds = new ArrayList();
+			kernings = new ArrayList();
 
-            for (int i=0; i&lt;kerningCount; i++)
-                kernings.add(new FSKerning(coder));
-        }
+			for (int i = 0; i &lt; glyphCount; i++)
+				advances.add(new Integer(coder.readWord(2, true)));
 
-        coder.context[FSCoder.WideCodes] = 0;
+			for (int i = 0; i &lt; glyphCount; i++)
+				bounds.add(new FSBounds(coder));
 
-        coder.endObject(name());
-    }
+			kerningCount = coder.readWord(2, false);
 
-    private boolean containsLayoutInfo()
-    {
-        boolean layout = false;
-        
-        layout = layout || ascent != 0;
-        layout = layout || descent != 0;
-        layout = layout || leading != 0;
-        layout = layout || ((advances != null) &amp;&amp; advances.size() &gt; 0);
-        layout = layout || ((bounds != null) &amp;&amp; bounds.size() &gt; 0);
-        layout = layout || ((kernings != null) &amp;&amp; kernings.size() &gt; 0);
-        
-        return layout;
-    }
-    
-    private boolean wideOffsetsForIndexedArray(ArrayList anArray, FSCoder coder)
-    {
-        boolean wideOffsets = false;
-        
-        int glyphLength = 0;
+			for (int i = 0; i &lt; kerningCount; i++)
+				kernings.add(new FSKerning(coder));
+		}
 
-        for (Iterator i=anArray.iterator(); i.hasNext();)
-            glyphLength += ((FSTransformObject)i.next()).length(coder);
-        
-        if ((anArray.size()*2 + glyphLength) &gt; 65535)
-            wideOffsets = true;
+		coder.context[FSCoder.WideCodes] = 0;
+	}
 
-        return wideOffsets;
-    }
+	private boolean containsLayoutInfo()
+	{
+		boolean layout = false;
+
+		layout = layout || ascent != 0;
+		layout = layout || descent != 0;
+		layout = layout || leading != 0;
+		layout = layout || ((advances != null) &amp;&amp; advances.size() &gt; 0);
+		layout = layout || ((bounds != null) &amp;&amp; bounds.size() &gt; 0);
+		layout = layout || ((kernings != null) &amp;&amp; kernings.size() &gt; 0);
+
+		return layout;
+	}
+
+	private boolean wideOffsetsForIndexedArray(ArrayList&lt;FSShape&gt; anArray, FSCoder coder)
+	{
+		boolean wideOffsets = false;
+
+		int glyphLength = 0;
+
+		for (Iterator&lt;FSShape&gt; i = anArray.iterator(); i.hasNext();)
+			glyphLength += i.next().length(coder);
+
+		if ((anArray.size() * 2 + glyphLength) &gt; 65535)
+			wideOffsets = true;
+
+		return wideOffsets;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineImage.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineImage.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineImage.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -34,373 +34,458 @@
 import java.util.zip.Inflater;
 
 /**
-FSDefineImage is used to define an image compressed using the lossless zlib compression algorithm.
-
-&lt;p&gt;The class supports colour-mapped images where the image data contains an index into a colour table or images where the image data specifies the colour directly.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineImage_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_2&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_3&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Height of the image in pixels, NOT twips.  1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_4&quot;&gt;pixelSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bits per pixel, either 16 or 24.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_4&quot;&gt;tableSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of entries in the colour table - which is compressed as part of the image. Each entry in the colour table contains one byte each for the red, green and blue colour channels. The colour table is only used for indexed colour images. The table is not used when the colour is specified directly in each pixel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_5&quot;&gt;compressedData&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;For colour-mapped images the colour table contains up to 256, 24-bit colours. The image contains one byte for each pixel which is an index into the table to specify the colour for that pixel. The colour table and the image data are compressed as a single block, with the colour table placed before the image.&lt;/p&gt;
-
-&lt;p&gt;For images where the colour is specified directly, the image data contains either 16 or 24 bit colour values. For 16-bit colour values the most significant bit is zero followed by three, 5-bit fields for the red, green and blue channels:&lt;/p&gt;
-
-&lt;pre&gt;
-            +-+--------+--------+--------+
-            |0|   Red  |  Green |  Blue  |
-            +-+--------+--------+--------+
-           15                            0
-&lt;/pre&gt;
-
-&lt;p&gt;Four bytes are used to represent 24-bit colours. The first byte is always set to zero and the following bytes contain the colour values for the red, green and blue colour channels.&lt;/p&gt;
-
-&lt;p&gt;The number of bytes in each row of an image must be aligned to a 32-bit word boundary. For example if an image if an icon is 25 pixels wide, then for an 8-bit colour mapped image an additional three bytes (0x00) must be used to pad each row; for a 16-bit direct mapped colour image an additional two bytes must be used as padding.&lt;/p&gt;
-
-&lt;p&gt;The image data is stored in zlib compressed form within the object. For colour-mapped images the compressed data contains the colour table followed by the image data. The colour table is omitted for direct-mapped images.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSDefineImage class represents the DefineBitsLossless tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
+ * FSDefineImage is used to define an image compressed using the lossless zlib
+ * compression algorithm.
+ * 
+ * &lt;p&gt;
+ * The class supports colour-mapped images where the image data contains an
+ * index into a colour table or images where the image data specifies the colour
+ * directly.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;width&lt;/td&gt;
+ * &lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;Height of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;pixelSize&lt;/td&gt;
+ * &lt;td&gt;The number of bits per pixel, either 16 or 24.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;tableSize&lt;/td&gt;
+ * &lt;td&gt;The number of entries in the colour table - which is compressed as part
+ * of the image. Each entry in the colour table contains one byte each for the
+ * red, green and blue colour channels. The colour table is only used for
+ * indexed colour images. The table is not used when the colour is specified
+ * directly in each pixel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;compressedData&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * For colour-mapped images the colour table contains up to 256, 24-bit colours.
+ * The image contains one byte for each pixel which is an index into the table
+ * to specify the colour for that pixel. The colour table and the image data are
+ * compressed as a single block, with the colour table placed before the image.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For images where the colour is specified directly, the image data contains
+ * either 16 or 24 bit colour values. For 16-bit colour values the most
+ * significant bit is zero followed by three, 5-bit fields for the red, green
+ * and blue channels:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  +-+--------+--------+--------+
+ *  |0|   Red  |  Green |  Blue  |
+ *  +-+--------+--------+--------+
+ *  15                            0
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Four bytes are used to represent 24-bit colours. The first byte is always set
+ * to zero and the following bytes contain the colour values for the red, green
+ * and blue colour channels.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The number of bytes in each row of an image must be aligned to a 32-bit word
+ * boundary. For example if an image if an icon is 25 pixels wide, then for an
+ * 8-bit colour mapped image an additional three bytes (0x00) must be used to
+ * pad each row; for a 16-bit direct mapped colour image an additional two bytes
+ * must be used as padding.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The image data is stored in zlib compressed form within the object. For
+ * colour-mapped images the compressed data contains the colour table followed
+ * by the image data. The colour table is omitted for direct-mapped images.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineImage class represents the DefineBitsLossless tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
  */
 public class FSDefineImage extends FSDefineObject
 {
-    private int width = 0;
-    private int height = 0;
+	private int width = 0;
 
-    private int pixelSize = 8;
-    private int tableSize = 0;
+	private int height = 0;
 
-    private byte[] compressedData = null;
+	private int pixelSize = 8;
 
-    /**
-     * Construct an FSDefineImage object, initalizing it with values decoded
-     * from an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineImage(FSCoder coder)
-    {
-        super(DefineImage, 0);
-        extendLength = true;
-        decode(coder);
-    }
-    /** Constructs an FSDefineImage object defining a colour-mapped image.
+	private int tableSize = 0;
 
-        @param anIdentifier    the unique identifier for this object
-        @param width the width of the image.
-        @param height the height of the image.
-        @param tableSize the number of entries in the colour table in the compressed data. Each entry is 24 bits.
-        @param compressedBytes the zlib compressed colour table and image data.
-        */
-    public FSDefineImage(int anIdentifier, int width, int height, int tableSize, byte[] compressedBytes)
-    {
-        super(DefineImage, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(8);
-        setTableSize(tableSize);
-        setCompressedData(compressedBytes);
-    }
+	private byte[] compressedData = null;
 
-    /** Constructs an FSDefineImage object defining an image that specifies the colour directly.
+	/**
+	 * Construct an FSDefineImage object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineImage(FSCoder coder)
+	{
+		super(DefineImage, 0);
+		extendLength = true;
+		decode(coder);
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param width the width of the image.
-        @param height the height of the image.
-        @param compressedBytes the zlib compressed image data.
-        @param aPixelSize the size of each pixel, either 16 or 24 bits.
-        */
-    public FSDefineImage(int anIdentifier, int width, int height, byte[] compressedBytes, int aPixelSize)
-    {
-        super(DefineImage, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(aPixelSize);
-        setTableSize(0);
-        setCompressedData(compressedBytes);
-    }
-    /**
-     * Constructs an FSDefineImage object by copying values from an existing
-     * object.
-     *
-     * @param obj an FSDefineImage object.
-     */
-    public FSDefineImage(FSDefineImage obj)
-    {
-        super(obj);
-        width = obj.width;
-        height = obj.height;
-        pixelSize = obj.pixelSize;
-        tableSize = obj.tableSize;
-        compressedData = Transform.clone(obj.compressedData);
-    }
+	/**
+	 * Constructs an FSDefineImage object defining a colour-mapped image.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param tableSize
+	 *            the number of entries in the colour table in the compressed
+	 *            data. Each entry is 24 bits.
+	 * @param compressedBytes
+	 *            the zlib compressed colour table and image data.
+	 */
+	public FSDefineImage(int anIdentifier, int width, int height,
+							int tableSize, byte[] compressedBytes)
+	{
+		super(DefineImage, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(8);
+		setTableSize(tableSize);
+		setCompressedData(compressedBytes);
+	}
 
-    /** Gets the width of the image.
+	/**
+	 * Constructs an FSDefineImage object defining an image that specifies the
+	 * colour directly.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param compressedBytes
+	 *            the zlib compressed image data.
+	 * @param aPixelSize
+	 *            the size of each pixel, either 16 or 24 bits.
+	 */
+	public FSDefineImage(int anIdentifier, int width, int height,
+							byte[] compressedBytes, int aPixelSize)
+	{
+		super(DefineImage, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(aPixelSize);
+		setTableSize(0);
+		setCompressedData(compressedBytes);
+	}
 
-        @return the width of the image.
-        */
-    public int getWidth()
-    {
-        return width;
-    }
+	/**
+	 * Constructs an FSDefineImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineImage object.
+	 */
+	public FSDefineImage(FSDefineImage obj)
+	{
+		super(obj);
+		width = obj.width;
+		height = obj.height;
+		pixelSize = obj.pixelSize;
+		tableSize = obj.tableSize;
+		compressedData = Transform.clone(obj.compressedData);
+	}
 
-    /** Gets the height of the image.
+	/**
+	 * Gets the width of the image.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-        @return the height of the image in pixels.
-        */
-    public int getHeight()
-    {
-        return height;
-    }
+	/**
+	 * Gets the height of the image.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-    /** Gets the number of bits used to represent each pixel. Either 8, 16 or 24 bits. The pixel size is 8-bits for colour-mapped images and 16 or 24 bits for images where the colour is specified directly.
+	/**
+	 * Gets the number of bits used to represent each pixel. Either 8, 16 or 24
+	 * bits. The pixel size is 8-bits for colour-mapped images and 16 or 24 bits
+	 * for images where the colour is specified directly.
+	 * 
+	 * @return the number of bits per pixel: 8, 16 or 24.
+	 */
+	public int getPixelSize()
+	{
+		return pixelSize;
+	}
 
-        @return the number of bits per pixel: 8, 16 or 24.
-        */
-    public int getPixelSize()
-    {
-        return pixelSize;
-    }
+	/**
+	 * Gets the number of entries in the colour table encoded the compressed
+	 * image. For images where the colour is specified directly in the image
+	 * then the table size is zero.
+	 * 
+	 * @return the number of entries in the colour table.
+	 */
+	public int getTableSize()
+	{
+		return tableSize;
+	}
 
-    /** Gets the number of entries in the colour table encoded the compressed image. For images where the colour is specified directly in the image then the table size is zero.
+	/**
+	 * Gets the compressed colour table and image.
+	 * 
+	 * @return an array of bytes containing the compressed colour table and
+	 *         image.
+	 */
+	public byte[] getCompressedData()
+	{
+		return compressedData;
+	}
 
-        @return the number of entries in the colour table.
-        */
-    public int getTableSize()
-    {
-        return tableSize;
-    }
+	/**
+	 * Sets the width of the image
+	 * 
+	 * @param aNumber
+	 *            the width of the image.
+	 */
+	public void setWidth(int aNumber)
+	{
+		width = aNumber;
+	}
 
-    /** Gets the compressed colour table and image.
+	/**
+	 * Sets the height of the image.
+	 * 
+	 * @param aNumber
+	 *            the height of the image in pixels.
+	 */
+	public void setHeight(int aNumber)
+	{
+		height = aNumber;
+	}
 
-        @return an array of bytes containing the compressed colour table and image.
-        */
-    public byte[] getCompressedData()
-    {
-        return compressedData;
-    }
+	/**
+	 * Sets the size of the pixel in bits: 8, 16 or 32. The pixel size is 8-bits
+	 * for colour-mapped images and 16 or 24 bits for images where the colour is
+	 * specified directly.
+	 * 
+	 * @param aNumber
+	 *            the size of each pixel in bits: 8, 16 or 24.
+	 */
+	public void setPixelSize(int aNumber)
+	{
+		pixelSize = aNumber;
+	}
 
-    /** Sets the width of the image
+	/**
+	 * Sets the number of entries in the colour table in the compressed image.
+	 * For images where the colour is specified directly in the image then the
+	 * table size should be zero.
+	 * 
+	 * @param aNumber
+	 *            the number of entries in the colour table in the compressed
+	 *            image.
+	 */
+	public void setTableSize(int aNumber)
+	{
+		tableSize = aNumber;
+	}
 
-        @param aNumber the width of the image.
-        */
-    public void setWidth(int aNumber)
-    {
-        width = aNumber;
-    }
+	/**
+	 * Sets the compressed image data using compressed data.
+	 * 
+	 * @param bytes
+	 *            byte array containing zlib compressed colour table and image.
+	 */
+	public void setCompressedData(byte[] bytes)
+	{
+		compressedData = bytes;
+	}
 
-    /** Sets the height of the image.
+	public Object clone()
+	{
+		FSDefineImage anObject = (FSDefineImage) super.clone();
 
-        @param aNumber the height of the image in pixels.
-        */
-    public void setHeight(int aNumber)
-    {
-        height = aNumber;
-    }
+		anObject.compressedData = Transform.clone(compressedData);
 
-    /** Sets the size of the pixel in bits: 8, 16 or 32. The pixel size is 8-bits for colour-mapped images and 16 or 24 bits for images where the colour is specified directly.
+		return anObject;
+	}
 
-        @param aNumber the size of each pixel in bits: 8, 16 or 24.
-        */
-    public void setPixelSize(int aNumber)
-    {
-        pixelSize = aNumber;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the number of entries in the colour table in the compressed image. For images where the colour is specified directly in the image then the table size should be zero.
+		if (super.equals(anObject))
+		{
+			FSDefineImage typedObject = (FSDefineImage) anObject;
 
-        @param aNumber the number of entries in the colour table in the compressed image.
-        */
-    public void setTableSize(int aNumber)
-    {
-        tableSize = aNumber;
-    }
+			result = pixelSize == typedObject.pixelSize;
+			result = result &amp;&amp; width == typedObject.width;
+			result = result &amp;&amp; height == typedObject.height;
+			result = result &amp;&amp; tableSize == typedObject.tableSize;
 
-    /** Sets the compressed image data using compressed data.
+			try
+			{
+				result = result
+								&amp;&amp; Transform
+												.equals(
+																unzip(compressedData),
+																unzip(typedObject.compressedData));
+			} catch (DataFormatException e)
+			{
+				result = false;
+			}
+		}
+		return result;
+	}
 
-        @param bytes byte array containing zlib compressed colour table and image.
-        */
-    public void setCompressedData(byte[] bytes)
-    {
-        compressedData = bytes;
-    }
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		byte[] data = new byte[width * height * 8];
+		int count = 0;
 
-    public Object clone()
-    {
-        FSDefineImage anObject = (FSDefineImage)super.clone();
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes);
+		count = inflater.inflate(data);
 
-        anObject.compressedData = Transform.clone(compressedData);
+		byte[] uncompressedData = new byte[count];
 
-        return anObject;
-    }
+		System.arraycopy(data, 0, uncompressedData, 0, count);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+		return uncompressedData;
+	}
 
-        if (super.equals(anObject))
-        {
-            FSDefineImage typedObject = (FSDefineImage)anObject;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-            result = pixelSize == typedObject.pixelSize;
-            result = result &amp;&amp; width == typedObject.width;
-            result = result &amp;&amp; height == typedObject.height;
-            result = result &amp;&amp; tableSize == typedObject.tableSize;
+		buffer.append(&quot;FSDefineImage: { &quot;);
+		buffer.append(&quot;pixelSize = &quot;).append(pixelSize).append(&quot;; &quot;);
+		buffer.append(&quot;width = &quot;).append(width).append(&quot;; &quot;);
+		buffer.append(&quot;height = &quot;).append(height).append(&quot;; &quot;);
+		buffer.append(&quot;tableSize = &quot;).append(tableSize).append(&quot;; &quot;);
+		buffer.append(&quot;compressedData = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-            try
-            {
-            	result = result &amp;&amp; Transform.equals(unzip(compressedData), unzip(typedObject.compressedData));
-            }
-            catch (DataFormatException e)
-            {
-            	result = false;
-            }
-        }
-        return result;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*8];
-        int count = 0;
+		length += 5;
+		length += (pixelSize == 8) ? 1 : 0;
+		length += compressedData.length;
 
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
+		return length;
+	}
 
-        byte[] uncompressedData = new byte[count];
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        System.arraycopy(data, 0, uncompressedData, 0, count);
+		switch (pixelSize)
+		{
+			case 8:
+				coder.writeWord(3, 1);
+				break;
+			case 16:
+				coder.writeWord(4, 1);
+				break;
+			case 24:
+				coder.writeWord(5, 1);
+				break;
+		}
 
-        return uncompressedData;
-    }
+		coder.writeWord(width, 2);
+		coder.writeWord(height, 2);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		if (pixelSize == 8)
+			coder.writeWord(tableSize - 1, 1);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;pixelSize&quot;, pixelSize);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;tableSize&quot;, tableSize);
-            Transform.append(buffer, &quot;compressedData&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.writeBytes(compressedData);
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        length += 5;
-        length += (pixelSize == 8) ? 1 : 0;
-        length += compressedData.length;
+		switch (coder.readByte())
+		{
+			case 3:
+				pixelSize = 8;
+				break;
+			case 4:
+				pixelSize = 16;
+				break;
+			case 5:
+				pixelSize = 24;
+				break;
+		}
 
-        return length;
-    }
+		width = coder.readWord(2, false);
+		height = coder.readWord(2, false);
 
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
-
-        super.encode(coder);
-
-        switch (pixelSize)
-        {
-            case 8:
-                coder.writeWord(3, 1);
-                break;
-            case 16:
-                coder.writeWord(4, 1);
-                break;
-            case 24:
-                coder.writeWord(5, 1);
-                break;
-        }
-
-        coder.writeWord(width, 2);
-        coder.writeWord(height, 2);
-
-        if (pixelSize == 8)
-            coder.writeWord(tableSize-1, 1);
-
-        coder.writeBytes(compressedData);
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        switch (coder.readWord(1, false))
-        {
-            case 3:
-                pixelSize = 8;
-                break;
-            case 4:
-                pixelSize = 16;
-                break;
-            case 5:
-                pixelSize = 24;
-                break;
-        }
-
-        width = coder.readWord(2, false);
-        height = coder.readWord(2, false);
-
-        if (pixelSize == 8)
-        {
-            tableSize = coder.readWord(1, false) + 1;
-            compressedData = new byte[length-8];
-            coder.readBytes(compressedData);
-        }
-        else
-        {
-            compressedData = new byte[length-7];
-            coder.readBytes(compressedData);
-        }
-        coder.endObject(name());
-    }
+		if (pixelSize == 8)
+		{
+			tableSize = coder.readByte() + 1;
+			compressedData = new byte[length - 8];
+			coder.readBytes(compressedData);
+		} else
+		{
+			compressedData = new byte[length - 7];
+			coder.readBytes(compressedData);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineImage2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineImage2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineImage2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -34,356 +34,432 @@
 import java.util.zip.Inflater;
 
 /**
-FSDefineImage2 is used to define a transparent image compressed using the lossless 
-zlib compression algorithm. 
- 
-&lt;p&gt;The class supports colour-mapped images where the image data contains an index into a colour table or images where the image data specifies the colour directly. It extends FSDefineImage by including alpha channel information for the colour table and pixels in the image.&lt;/p&gt;
+ * FSDefineImage2 is used to define a transparent image compressed using the
+ * lossless zlib compression algorithm.
+ * 
+ * &lt;p&gt;
+ * The class supports colour-mapped images where the image data contains an
+ * index into a colour table or images where the image data specifies the colour
+ * directly. It extends FSDefineImage by including alpha channel information for
+ * the colour table and pixels in the image.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For colour-mapped images the colour table contains up to 256, 32-bit colours.
+ * The image contains one byte for each pixel which is an index into the table
+ * to specify the colour for that pixel. The colour table and the image data are
+ * compressed as a single block, with the colour table placed before the image.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For images where the colour is specified directly, the image data contains 32
+ * bit colour values.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;width&lt;/td&gt;
+ * &lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;Height of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;pixelSize&lt;/td&gt;
+ * &lt;td&gt;The number of bits per pixel, either 8 or 32. 8-bit pixels are used for
+ * indexed images where the colour table contains the colours for each pixel.
+ * 32-bit pixels are used to specify the colour and transparency directly.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;tableSize&lt;/td&gt;
+ * &lt;td&gt;The number of entries in the colour table - which is compressed as part
+ * of the image. Each entry in the colour table contains one byte each for the
+ * red, green and blue colour channels. The colour table is only used for
+ * indexed colour images. The table is not used when the colour is specified
+ * directly in each pixel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;compressedData&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The image data is stored in zlib compressed form within the object. For
+ * colour-mapped images the compressed data contains the colour table followed
+ * by the image data.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineImage2 class represents the DefineBitsLossless2 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineImage2 extends FSDefineObject
+{
+	private int width = 0;
 
-&lt;p&gt;For colour-mapped images the colour table contains up to 256, 32-bit colours. The image contains one byte for each pixel which is an index into the table to specify the colour for that pixel. The colour table and the image data are compressed as a single block, with the colour table placed before the image.&lt;/p&gt;
+	private int height = 0;
 
-&lt;p&gt;For images where the colour is specified directly, the image data contains 32 bit colour values.&lt;/p&gt;
+	private int pixelSize = 8;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int tableSize = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private byte[] compressedData = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineImage2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSCall object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineImage2(FSCoder coder)
+	{
+		super(DefineImage2, 0);
+		extendLength = true;
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineImage2 object defining a colour-mapped image.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param tableSize
+	 *            the number of entries in the colour table in the compressed
+	 *            data. Each entry is 32 bits.
+	 * @param compressedBytes
+	 *            the zlib compressed colour table and image data.
+	 */
+	public FSDefineImage2(int anIdentifier, int width, int height,
+							int tableSize, byte[] compressedBytes)
+	{
+		super(DefineImage2, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(8);
+		setTableSize(tableSize);
+		setCompressedData(compressedBytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_2&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineImage object defining an image that specifies the
+	 * colour directly. Each pixel in the image is 32 bits - 8 bits for the red,
+	 * green, blue and alpha colour channels.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param compressedBytes
+	 *            the zlib compressed image data.
+	 */
+	public FSDefineImage2(int anIdentifier, int width, int height,
+							byte[] compressedBytes)
+	{
+		super(DefineImage2, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(32);
+		setTableSize(0);
+		setCompressedData(compressedBytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_3&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Height of the image in pixels, NOT twips.  1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineImage2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineImage2 object.
+	 */
+	public FSDefineImage2(FSDefineImage2 obj)
+	{
+		super(obj);
+		width = obj.width;
+		height = obj.height;
+		pixelSize = obj.pixelSize;
+		tableSize = obj.tableSize;
+		compressedData = Transform.clone(obj.compressedData);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_4&quot;&gt;pixelSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bits per pixel, either 8 or 32. 8-bit pixels are used for indexed images where the colour table contains the colours for each pixel. 32-bit pixels are used to specify the colour and transparency directly.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the width of the image.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_5&quot;&gt;tableSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of entries in the colour table - which is compressed as part of the image. Each entry in the colour table contains one byte each for the red, green and blue colour channels. The colour table is only used for indexed colour images. The table is not used when the colour is specified directly in each pixel.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the height of the image.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_5&quot;&gt;compressedData&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the number of bits used to represent each pixel. Either 8 or 32
+	 * bits. The pixel size is 8-bits for colour-mapped images and 32 bits for
+	 * images where the colour is specified directly.
+	 * 
+	 * @return the number of bits per pixel: 8 or 32.
+	 */
+	public int getPixelSize()
+	{
+		return pixelSize;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the number of entries in the colour table encoded the compressed
+	 * image. For images where the colour is specified directly in the image
+	 * then the table size is zero.
+	 * 
+	 * @return the number of entries in the colour table.
+	 */
+	public int getTableSize()
+	{
+		return tableSize;
+	}
 
-&lt;p&gt;The image data is stored in zlib compressed form within the object. For colour-mapped images the compressed data contains the colour table followed by the image data.&lt;/p&gt;
+	/**
+	 * Gets the compressed colour table and image.
+	 * 
+	 * @return an array of bytes containing the compressed colour table and
+	 *         image.
+	 */
+	public byte[] getCompressedData()
+	{
+		return compressedData;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the width of the image
+	 * 
+	 * @param aNumber
+	 *            the width of the image.
+	 */
+	public void setWidth(int aNumber)
+	{
+		width = aNumber;
+	}
 
-&lt;p&gt;The FSDefineImage2 class represents the DefineBitsLossless2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineImage2 extends FSDefineObject
-{
-    private int width = 0;
-    private int height = 0;
+	/**
+	 * Sets the height of the image.
+	 * 
+	 * @param aNumber
+	 *            the height of the image in pixels.
+	 */
+	public void setHeight(int aNumber)
+	{
+		height = aNumber;
+	}
 
-    private int pixelSize = 8;
-    private int tableSize = 0;
-    
-    private byte[] compressedData = null;
+	/**
+	 * Sets the size of the pixel in bits: 8 for colour-mapped images, 32 for
+	 * direct images.
+	 * 
+	 * @param aNumber
+	 *            the size of each pixel in bits: 8 or 32.
+	 */
+	public void setPixelSize(int aNumber)
+	{
+		pixelSize = aNumber;
+	}
 
-    /**
-     * Construct an FSCall object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineImage2(FSCoder coder)
-    {
-        super(DefineImage2, 0);
-        extendLength = true;
-        decode(coder);
-    }
-    /** Constructs an FSDefineImage2 object defining a colour-mapped image.
+	/**
+	 * Sets the number of entries in the colour table in the compressed image.
+	 * For images where the colour is specified directly in the image then the
+	 * table size should be zero.
+	 * 
+	 * @param aNumber
+	 *            the number of entries in the colour table in the compressed
+	 *            image.
+	 */
+	public void setTableSize(int aNumber)
+	{
+		tableSize = aNumber;
+	}
 
-    @param anIdentifier    the unique identifier for this object
-    @param width the width of the image.
-    @param height the height of the image.
-    @param tableSize the number of entries in the colour table in the compressed data. Each entry is 32 bits.
-    @param compressedBytes the zlib compressed colour table and image data.
-    */
-    public FSDefineImage2(int anIdentifier, int width, int height, int tableSize, byte[] compressedBytes)
-    {
-        super(DefineImage2, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(8);
-        setTableSize(tableSize);
-        setCompressedData(compressedBytes);
-    }
+	/**
+	 * Sets the compressed image data using compressed data.
+	 * 
+	 * @param bytes
+	 *            byte array containing zlib compressed colour table and image.
+	 */
+	public void setCompressedData(byte[] bytes)
+	{
+		compressedData = bytes;
+	}
 
-    /** Constructs an FSDefineImage object defining an image that specifies the colour directly. Each pixel in the image is 32 bits - 8 bits for the red, green, blue and alpha colour channels.
+	public Object clone()
+	{
+		FSDefineImage2 anObject = (FSDefineImage2) super.clone();
 
-    @param anIdentifier    the unique identifier for this object
-    @param width the width of the image.
-    @param height the height of the image.
-    @param compressedBytes the zlib compressed image data.
-    */
-    public FSDefineImage2(int anIdentifier, int width, int height, byte[] compressedBytes)
-    { 
-        super(DefineImage2, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(32);
-        setTableSize(0);
-        setCompressedData(compressedBytes);
-    }
-    /**
-     * Constructs an FSDefineImage2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineImage2 object.
-     */
-    public FSDefineImage2(FSDefineImage2 obj)
-    {
-        super(obj);
-        width = obj.width;
-        height = obj.height;
-        pixelSize = obj.pixelSize;
-        tableSize = obj.tableSize;
-        compressedData = Transform.clone(obj.compressedData);        
-    }
+		anObject.compressedData = Transform.clone(compressedData);
 
-    /** Gets the width of the image. 
+		return anObject;
+	}
 
-        @return the width of the image.
-        */
-    public int getWidth()
-    {
-        return width; 
-    }    
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the height of the image.
+		if (super.equals(anObject))
+		{
+			FSDefineImage2 typedObject = (FSDefineImage2) anObject;
 
-        @return the height of the image in pixels.
-        */
-    public int getHeight()
-    {
-        return height;
-    }
+			result = pixelSize == typedObject.pixelSize;
+			result = result &amp;&amp; width == typedObject.width;
+			result = result &amp;&amp; height == typedObject.height;
+			result = result &amp;&amp; tableSize == typedObject.tableSize;
 
-    /** Gets the number of bits used to represent each pixel. Either 8 or 32 bits. The pixel size is 8-bits for colour-mapped images and 32 bits for images where the colour is specified directly.
+			try
+			{
+				result = result
+								&amp;&amp; Transform
+												.equals(
+																unzip(compressedData),
+																unzip(typedObject.compressedData));
+			} catch (DataFormatException e)
+			{
+				result = false;
+			}
+		}
+		return result;
+	}
 
-    @return the number of bits per pixel: 8 or 32.
-    */
-    public int getPixelSize()
-    {
-        return pixelSize;
-    }
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		byte[] data = new byte[width * height * 8];
+		int count = 0;
 
-    /** Gets the number of entries in the colour table encoded the compressed image. For images where the colour is specified directly in the image then the table size is zero.
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes);
+		count = inflater.inflate(data);
 
-        @return the number of entries in the colour table.
-        */
-    public int getTableSize()
-    {
-        return tableSize;
-    }
+		byte[] uncompressedData = new byte[count];
 
-    /** Gets the compressed colour table and image.
+		System.arraycopy(data, 0, uncompressedData, 0, count);
 
-        @return an array of bytes containing the compressed colour table and image.
-        */
-    public byte[] getCompressedData()
-    {
-        return compressedData;
-    }
+		return uncompressedData;
+	}
 
-    /** Sets the width of the image
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param aNumber the width of the image.
-        */
-    public void setWidth(int aNumber)
-    {
-        width = aNumber;
-    }
+		buffer.append(&quot;FSDefineImage2: { &quot;);
+		buffer.append(&quot;pixelSize = &quot;).append(pixelSize).append(&quot;; &quot;);
+		buffer.append(&quot;width = &quot;).append(width).append(&quot;; &quot;);
+		buffer.append(&quot;height = &quot;).append(height).append(&quot;; &quot;);
+		buffer.append(&quot;tableSize = &quot;).append(tableSize).append(&quot;; &quot;);
+		buffer.append(&quot;compressedData = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Sets the height of the image.
+		return buffer.toString();
+	}
 
-        @param aNumber the height of the image in pixels.
-        */
-    public void setHeight(int aNumber)
-    {
-        height = aNumber;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the size of the pixel in bits: 8 for colour-mapped images, 32 for direct images.
+		length += 5;
+		length += (pixelSize == 8) ? 1 : 0;
+		length += compressedData.length;
 
-    @param aNumber the size of each pixel in bits: 8 or 32.
-    */
-    public void setPixelSize(int aNumber) 
-    { 
-        pixelSize = aNumber; 
-    }
-    
-    /** Sets the number of entries in the colour table in the compressed image. For images where the colour is specified directly in the image then the table size should be zero.
+		return length;
+	}
 
-        @param aNumber the number of entries in the colour table in the compressed image.
-        */
-    public void setTableSize(int aNumber)
-    {
-        tableSize = aNumber;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the compressed image data using compressed data.
+		switch (pixelSize)
+		{
+			case 8:
+				coder.writeWord(3, 1);
+				break;
+			case 32:
+				coder.writeWord(5, 1);
+				break;
+		}
 
-        @param bytes byte array containing zlib compressed colour table and image.
-        */
-    public void setCompressedData(byte[] bytes)
-    {
-        compressedData = bytes;
-    }
+		coder.writeWord(width, 2);
+		coder.writeWord(height, 2);
 
-    public Object clone()
-    {
-        FSDefineImage2 anObject = (FSDefineImage2)super.clone();
-        
-        anObject.compressedData = Transform.clone(compressedData);
-        
-        return anObject;
-    }
+		if (pixelSize == 8)
+			coder.writeWord(tableSize - 1, 1);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineImage2 typedObject = (FSDefineImage2)anObject;
-            
-            result = pixelSize == typedObject.pixelSize;
-            result = result &amp;&amp; width == typedObject.width;
-            result = result &amp;&amp; height == typedObject.height;
-            result = result &amp;&amp; tableSize == typedObject.tableSize;
+		coder.writeBytes(compressedData);
+	}
 
-            try
-            {
-            	result = result &amp;&amp; Transform.equals(unzip(compressedData), unzip(typedObject.compressedData));
-            }
-            catch (DataFormatException e)
-            {
-            	result = false;
-            }
-        }
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*8];
-        int count = 0;
+		switch (coder.readByte())
+		{
+			case 3:
+				pixelSize = 8;
+				break;
+			case 5:
+				pixelSize = 32;
+				break;
+		}
 
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
+		width = coder.readWord(2, false);
+		height = coder.readWord(2, false);
 
-        byte[] uncompressedData = new byte[count];
-
-        System.arraycopy(data, 0, uncompressedData, 0, count);
-
-        return uncompressedData;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;pixelSize&quot;, pixelSize);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;tableSize&quot;, tableSize);
-            Transform.append(buffer, &quot;compressedData&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += 5;
-        length += (pixelSize == 8) ? 1 : 0;
-        length += compressedData.length;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
-
-        super.encode(coder);
-
-        switch (pixelSize)
-        {
-            case 8:
-                coder.writeWord(3, 1);
-                break;
-            case 32:
-                coder.writeWord(5, 1);
-                break;
-        }
-        
-        coder.writeWord(width, 2);
-        coder.writeWord(height, 2);
-
-        if (pixelSize == 8)
-            coder.writeWord(tableSize-1, 1);
-        
-        coder.writeBytes(compressedData);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        switch (coder.readWord(1, false))
-        {
-            case 3:
-                pixelSize = 8;
-                break;
-            case 5:
-                pixelSize = 32;
-                break;
-        }
-        
-        width = coder.readWord(2, false);
-        height = coder.readWord(2, false);
-
-        if (pixelSize == 8)
-        {
-            tableSize = coder.readWord(1, false) + 1;
-            compressedData = new byte[length-8];
-            coder.readBytes(compressedData);
-        }
-        else
-        {
-            compressedData = new byte[length-7];
-            coder.readBytes(compressedData);
-        }
-        coder.endObject(name());
-    }
+		if (pixelSize == 8)
+		{
+			tableSize = coder.readByte() + 1;
+			compressedData = new byte[length - 8];
+			coder.readBytes(compressedData);
+		} else
+		{
+			compressedData = new byte[length - 7];
+			coder.readBytes(compressedData);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,228 +31,269 @@
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage is used to define a JPEG encoded image. 
- 
-&lt;p&gt;FSDefineJPEGImage objects only contain the image data, the encoding table for the image is defined in a FSJPEGEncodingTable object. All images using a shared FSJPEGEncodingTable object to represent the encoding table have the same compression ratio.&lt;/p&gt;
+ * FSDefineJPEGImage is used to define a JPEG encoded image.
+ * 
+ * &lt;p&gt;
+ * FSDefineJPEGImage objects only contain the image data, the encoding table for
+ * the image is defined in a FSJPEGEncodingTable object. All images using a
+ * shared FSJPEGEncodingTable object to represent the encoding table have the
+ * same compression ratio.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;image&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Images can only be displayed inside a shape using the FSBitmapFill class.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The image data may be taken directly from a JPEG image file. No further
+ * decoding is necessary.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Although the FSDefineJPEGImage class is supposed to be used with the
+ * FSJPEGEncodingTable class which defines the encoding table for the images it
+ * is not essential. If an FSJPEGEncodingTable object is created with an empty
+ * encoding table then the Flash Player will still display the JPEG image
+ * correctly.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSJPEGEncodingTable and FSDefineJPEGImage classes
+ * to define JPEG encoded images is to create an empty encoding table then
+ * construct the FSDefineJPEGImage object with the image data from a file:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSJPEGEncodingTable());
+ * movie.add(new FSDefineJPEGImage(movie.newIdentifier(), bytes));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineJPEGImage class represents the DefineBits data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineJPEGImage extends FSDefineObject
+{
+	private byte[] image = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int width;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private int height;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineJPEGImage object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineJPEGImage(FSCoder coder)
+	{
+		super(FSMovieObject.DefineJPEGImage, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object with the identifier and JPEG data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param bytes
+	 *            the JPEG encoded image data.
+	 */
+	public FSDefineJPEGImage(int anIdentifier, byte[] bytes)
+	{
+		super(FSMovieObject.DefineJPEGImage, anIdentifier);
+		setImage(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage_2&quot;&gt;image&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage object.
+	 */
+	public FSDefineJPEGImage(FSDefineJPEGImage obj)
+	{
+		super(obj);
+		width = obj.width;
+		height = obj.height;
+		image = Transform.clone(obj.image);
+	}
 
-&lt;p&gt;Images can only be displayed inside a shape using the FSBitmapFill class.&lt;/p&gt;
+	/**
+	 * Gets the width of the image in pixels.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;p&gt;The image data may be taken directly from a JPEG image file. No further decoding is necessary.&lt;/p&gt;
+	/**
+	 * Gets the height of the image in pixels.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;p&gt;Although the FSDefineJPEGImage class is supposed to be used with the FSJPEGEncodingTable class which defines the encoding table for the images it is not essential. If an FSJPEGEncodingTable object is created with an empty encoding table then the Flash Player will still display the JPEG image correctly.&lt;/p&gt;
+	/**
+	 * Gets the image data.
+	 * 
+	 * @return the array of bytes containing the image data.
+	 */
+	public byte[] getImage()
+	{
+		return image;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	/**
+	 * Sets the image data. The image data may be taken directly from a file
+	 * containing a JPEG encoded image.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the image data.
+	 */
+	public void setImage(byte[] bytes)
+	{
+		image = bytes;
+		decodeInfo();
+	}
 
-&lt;p&gt;The simplest way to use the FSJPEGEncodingTable and FSDefineJPEGImage classes to define JPEG encoded images is to create an empty encoding table then construct the FSDefineJPEGImage object with the image data from a file:&lt;/p&gt;
+	public Object clone()
+	{
+		FSDefineJPEGImage anObject = (FSDefineJPEGImage) super.clone();
 
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
+		anObject.image = Transform.clone(image);
+		anObject.width = width;
+		anObject.height = height;
 
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);            
-    imageContents.read(bytes);
-    imageContents.close();
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
+		return anObject;
+	}
 
-movie.add(new FSJPEGEncodingTable());
-movie.add(new FSDefineJPEGImage(movie.newIdentifier(), bytes));
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSDefineJPEGImage typedObject = (FSDefineJPEGImage) anObject;
 
-&lt;p&gt;The FSDefineJPEGImage class represents the DefineBits data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineJPEGImage extends FSDefineObject
-{
-    private byte[] image = null;
-    private int width;
-    private int height;
-    
-    /**
-     * Construct an FSDefineJPEGImage object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineJPEGImage(FSCoder coder)
-    {
-        super(FSMovieObject.DefineJPEGImage, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineJPEGImage object with the identifier and JPEG data.
+			result = Transform.equals(image, typedObject.image);
+		}
+		return result;
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param bytes the JPEG encoded image data.
-        */
-    public FSDefineJPEGImage(int anIdentifier, byte[] bytes)
-    {
-        super(FSMovieObject.DefineJPEGImage, anIdentifier);
-        setImage(bytes);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineJPEGImage object.
-     */
-    public FSDefineJPEGImage(FSDefineJPEGImage obj)
-    {
-        super(obj);
-        width = obj.width;
-        height = obj.height;
-        image = Transform.clone(obj.image);
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** 
-     * Gets the width of the image in pixels. 
-     * 
-     * @return the width of the image.
-     */
-    public int getWidth()
-    {
-        return width; 
-    }    
-    /** 
-     * Gets the height of the image in pixels.
-     * 
-     * @return the height of the image in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }
+		buffer.append(&quot;FSDefineJPEGImage: { &quot;);
+		buffer.append(&quot;image = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Gets the image data.
+		return buffer.toString();
+	}
 
-        @return the array of bytes containing the image data.
-        */
-    public byte[] getImage() { return image; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** 
-     * Sets the image data. The image data may be taken directly from a file
-     * containing a JPEG encoded image.
+		length += image.length;
 
-        @param bytes an array of bytes containing the image data.
-        */
-    public void setImage(byte[] bytes)
-    {
-        image = bytes;
-        decodeInfo();
-    }
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSDefineJPEGImage anObject = (FSDefineJPEGImage)super.clone();
-        
-        anObject.image = Transform.clone(image);
-        anObject.width = width;
-        anObject.height = height;
-        
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(image);
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineJPEGImage typedObject = (FSDefineJPEGImage)anObject;
-            
-            result = Transform.equals(image, typedObject.image);
-        }
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		byte[] data = new byte[length - 2];
+		coder.readBytes(data);
+		setImage(data);
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	private boolean decodeInfo()
+	{
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += image.length;
+		if (coder.readWord(2, false) != 0xffd8)
+			return false;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(image);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);    
-        byte[] data = new byte[length-2];    
-        coder.readBytes(data);
-        setImage(data);
-        coder.endObject(name());
-    }
-    private boolean decodeInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
+		while (true)
+		{
+			int marker = coder.readWord(2, false);
+			int size = coder.readWord(2, false);
 
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readWord(1, false);
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
+			if ((marker &amp; 0xff00) != 0xff00)
+				return false;
+
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4
+							&amp;&amp; marker != 0xffc8)
+			{
+				coder.readByte();
+				height = coder.readWord(2, false);
+				width = coder.readWord(2, false);
+				return true;
+			} else
+			{
+				coder.adjustPointer((size - 2) &lt;&lt; 3);
+			}
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,307 +31,357 @@
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage2 is used to define a JPEG encoded image with an integrated
-encoding table.
+ * FSDefineJPEGImage2 is used to define a JPEG encoded image with an integrated
+ * encoding table.
+ * 
+ * &lt;p&gt;
+ * It extends the FSDefineJPEGImage class by including a separate encoding
+ * table, rather than using an FSJPEGEncodingTable object to store the encoding
+ * table. This allows multiple JPEG images with different amounts of compression
+ * to be included within a Flash file.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;image&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodingTable&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the encoding table. May be set to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although the encoding table defines how the image is compressed it is not
+ * essential. If an FSDefineJPEGImage3 object is created with an empty encoding
+ * table then the Flash Player will still display the JPEG image correctly. The
+ * empty encoding table is not a null object. It contains four bytes: 0xFF,
+ * 0xD8, 0xFF, 0xD9. For convenience passing a null reference to any of the
+ * constructors or to the setEncodingTable method will create an empty table.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSDefineJPEGImage2 class is to use the
+ * constructor that specifies the JPEG file to initialise the object:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSDefineJPEGImage2(movie.newIdentifier(), bytes));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This generates an object with an empty encoding table, however the image will
+ * still be displayed correctly.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineJPEGImage2 class represents the DefineBitsJPEG2 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
+ */
+public class FSDefineJPEGImage2 extends FSDefineObject
+{
+	private int width;
 
-&lt;p&gt;It extends the FSDefineJPEGImage class by including a separate encoding table,
-rather than using an FSJPEGEncodingTable object to store the encoding table.
-This allows multiple JPEG images with different amounts of compression to be
-included within a Flash file.&lt;/p&gt;
+	private int height;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private byte[] image = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private byte[] encodingTable = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineJPEGImage2 object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineJPEGImage2(FSCoder coder)
+	{
+		super(DefineJPEGImage2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the
-image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image
+	 * data and JPEG encoding table data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param imageBytes
+	 *            the JPEG encoded image data.
+	 * @param encodingBytes
+	 *            the JPEG encoded encoding table.
+	 */
+	public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes,
+								byte[] encodingBytes)
+	{
+		super(DefineJPEGImage2, anIdentifier);
+		setImage(imageBytes);
+		setEncodingTable(encodingBytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_2&quot;&gt;image&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image
+	 * data and JPEG encoding table data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param imageBytes
+	 *            the JPEG encoded image data.
+	 */
+	public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes)
+	{
+		super(DefineJPEGImage2, anIdentifier);
+		setImage(imageBytes);
+		setEncodingTable(null);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_3&quot;&gt;encodingTable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the encoding table. May be set to null.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage2 object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage2 object.
+	 */
+	public FSDefineJPEGImage2(FSDefineJPEGImage2 obj)
+	{
+		super(obj);
+		image = Transform.clone(obj.image);
+		width = obj.width;
+		height = obj.height;
+		encodingTable = Transform.clone(obj.encodingTable);
+	}
 
-&lt;p&gt;Although the encoding table defines how the image is compressed it is not
-essential. If an FSDefineJPEGImage3 object is created with an empty encoding
-table then the Flash Player will still display the JPEG image correctly. The
-empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8,
-0xFF, 0xD9. For convenience passing a null reference to any of the constructors
-or to the setEncodingTable method will create an empty table.&lt;/p&gt;
+	/**
+	 * Gets the width of the image in pixels.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the height of the image in pixels.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;p&gt;The simplest way to use the FSDefineJPEGImage2 class is to use the constructor
-that specifies the JPEG file to initialise the object:&lt;/p&gt;
+	/**
+	 * Gets the image data.
+	 * 
+	 * @return the array of bytes containing the image data.
+	 */
+	public byte[] getImage()
+	{
+		return image;
+	}
 
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
+	/**
+	 * Gets the encoding table.
+	 * 
+	 * @return the array of bytes containing the encoding table.
+	 */
+	public byte[] getEncodingTable()
+	{
+		return encodingTable;
+	}
 
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);
-    imageContents.read(bytes);
-    imageContents.close();
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
+	/**
+	 * Sets the image data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the image data.
+	 */
+	public void setImage(byte[] bytes)
+	{
+		image = bytes;
+		decodeInfo();
+	}
 
-movie.add(new FSDefineJPEGImage2(movie.newIdentifier(), bytes));
-&lt;/pre&gt;
+	/**
+	 * Sets the encoding table.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the encoding table.
+	 */
+	public void setEncodingTable(byte[] bytes)
+	{
+		if (bytes == null)
+		{
+			bytes = new byte[] { (byte) 0xFF, (byte) 0xD9, (byte) 0xFF, (byte) 0xD8 };
+		}
+		encodingTable = bytes;
+	}
 
-&lt;p&gt;This generates an object with an empty encoding table, however the image will still be displayed correctly.&lt;/p&gt;
+	public Object clone()
+	{
+		FSDefineJPEGImage2 anObject = (FSDefineJPEGImage2) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.image = Transform.clone(image);
+		anObject.width = width;
+		anObject.height = height;
+		anObject.encodingTable = Transform.clone(encodingTable);
 
-&lt;p&gt;The FSDefineJPEGImage2 class represents the DefineBitsJPEG2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSDefineJPEGImage2 extends FSDefineObject
-{
-    private int width;
-    private int height;
-    private byte[] image = null;
-    private byte[] encodingTable = null;
+		return anObject;
+	}
 
-    /**
-     * Construct an FSDefineJPEGImage2 object, initalizing it with values decoded
-     * from an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineJPEGImage2(FSCoder coder)
-    {
-        super(DefineJPEGImage2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image data and JPEG encoding table data.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anIdentifier    the unique identifier for this object
-        @param imageBytes the JPEG encoded image data.
-        @param encodingBytes the JPEG encoded encoding table.
-        */
-    public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes, byte[] encodingBytes)
-    {
-        super(DefineJPEGImage2, anIdentifier);
-        setImage(imageBytes);
-        setEncodingTable(encodingBytes);
-    }
-    /** Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image data and JPEG encoding table data.
+		if (super.equals(anObject))
+		{
+			FSDefineJPEGImage2 typedObject = (FSDefineJPEGImage2) anObject;
 
-        @param anIdentifier    the unique identifier for this object
-        @param imageBytes the JPEG encoded image data.
-        */
-    public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes)
-    {
-        super(DefineJPEGImage2, anIdentifier);
-        setImage(imageBytes);
-        setEncodingTable(null);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage2 object by copying values from an
-     * existing object.
-     *
-     * @param obj an FSDefineJPEGImage2 object.
-     */
-    public FSDefineJPEGImage2(FSDefineJPEGImage2 obj)
-    {
-        super(obj);
-        image = Transform.clone(obj.image);
-        width = obj.width;
-        height = obj.height;
-        encodingTable = Transform.clone(obj.encodingTable);
-    }
+			result = Transform.equals(image, typedObject.image);
+			result = result
+							&amp;&amp; Transform.equals(encodingTable,
+											typedObject.encodingTable);
+		}
+		return result;
+	}
 
-    /** 
-     * Gets the width of the image in pixels. 
-     * 
-     * @return the width of the image.
-     */
-    public int getWidth()
-    {
-        return width; 
-    }    
-    /** 
-     * Gets the height of the image in pixels.
-     * 
-     * @return the height of the image in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }
-    /** Gets the image data.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @return the array of bytes containing the image data.
-        */
-    public byte[] getImage() { return image; }
+		buffer.append(&quot;FSDefineJPEGImage2 : { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;encodingTable = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;image = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Gets the encoding table.
+		return buffer.toString();
+	}
 
-        @return the array of bytes containing the encoding table.
-        */
-    public byte[] getEncodingTable()  { return encodingTable; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the image data.
+		length += encodingTable.length;
+		length += image.length;
 
-        @param bytes an array of bytes containing the image data.
-        */
-    public void setImage(byte[] bytes)
-    {
-        image = bytes;
-        decodeInfo();
-    }
+		return length;
+	}
 
-    /** Sets the encoding table.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(encodingTable);
+		coder.writeBytes(image);
+	}
 
-        @param bytes an array of bytes containing the encoding table.
-        */
-    public void setEncodingTable(byte[] bytes)
-    {
-        if (bytes == null) {
-            bytes = new byte[] { (byte)0xFF, (byte)0xD9, (byte)0xFF, (byte)0xD8 };
-        }
-        encodingTable = bytes;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		setEncodingTable(readJPEGStream(coder));
+		byte[] data = new byte[length - encodingTable.length - 2];
+		coder.readBytes(data);
+		setImage(data);
+	}
 
-    public Object clone()
-    {
-        FSDefineJPEGImage2 anObject = (FSDefineJPEGImage2)super.clone();
+	private byte[] readJPEGStream(FSCoder coder)
+	{
+		byte bytes[] = null;
 
-        anObject.image = Transform.clone(image);
-        anObject.width = width;
-        anObject.height = height;
-        anObject.encodingTable = Transform.clone(encodingTable);
+		int start = coder.getPointer();
+		int end = start + ((length - 2) &lt;&lt; 3);
+		int word = coder.readBits(16, false);
+		int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
 
-        return anObject;
-    }
+		do
+		{
+			word = coder.scanBits(16, false);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+			if (word == eoi)
+			{
+				end = coder.getPointer() + 16;
+				break;
+			}
+			coder.adjustPointer(8);
+		} while (coder.getPointer() &lt; end);
 
-        if (super.equals(anObject))
-        {
-            FSDefineJPEGImage2 typedObject = (FSDefineJPEGImage2)anObject;
+		int len = (end - start) &gt;&gt;&gt; 3;
 
-            result = Transform.equals(image, typedObject.image);
-            result = result &amp;&amp; Transform.equals(encodingTable, typedObject.encodingTable);
-        }
-        return result;
-    }
+		coder.setPointer(start);
+		bytes = new byte[len];
+		coder.readBytes(bytes);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		return bytes;
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
-            Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	private boolean decodeInfo()
+	{
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		if (coder.readWord(2, false) != 0xffd8)
+			return false;
 
-        length += encodingTable.length;
-        length += image.length;
+		while (true)
+		{
+			int marker = coder.readWord(2, false);
+			int size = coder.readWord(2, false);
 
-        return length;
-    }
+			if ((marker &amp; 0xff00) != 0xff00)
+				return false;
 
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(encodingTable);
-        coder.writeBytes(image);
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        setEncodingTable(readJPEGStream(coder));
-        byte[] data = new byte[length-encodingTable.length-2];
-        coder.readBytes(data);
-        setImage(data);
-        coder.endObject(name());
-    }
-
-    private byte[] readJPEGStream(FSCoder coder)
-    {
-        byte bytes[] = null;
-        
-        int start = coder.getPointer();
-        int end = start + ((length-2) &lt;&lt; 3);
-        int word = coder.readBits(16, false);
-        int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
-
-        do {
-            word = coder.scanBits(16, false);
-
-            if (word == eoi)
-            {
-                end = coder.getPointer()+16;
-                break;
-            }
-            coder.adjustPointer(8);
-        }
-        while (coder.getPointer() &lt; end);
-
-        int len = (end-start) &gt;&gt;&gt; 3;
-
-        coder.setPointer(start);
-        bytes = new byte[len];
-        coder.readBytes(bytes);
-
-        return bytes;
-    }
-
-    private boolean decodeInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
-
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readWord(1, false);
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4
+							&amp;&amp; marker != 0xffc8)
+			{
+				coder.readByte();
+				height = coder.readWord(2, false);
+				width = coder.readWord(2, false);
+				return true;
+			} else
+			{
+				coder.adjustPointer((size - 2) &lt;&lt; 3);
+			}
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage3.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage3.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineJPEGImage3.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,356 +31,409 @@
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage3 is used to define a transparent JPEG encoded image.
+ * FSDefineJPEGImage3 is used to define a transparent JPEG encoded image.
+ * 
+ * &lt;p&gt;
+ * It extends the FSDefineJPEGImage3 class by including a separate zlib
+ * compressed table of alpha channel values. This allows the transparency of
+ * existing JPEG encoded images to be changed without re-encoding the original
+ * image.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;image&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodingTable&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the encoding table.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;alpha&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the zlib encoded alpha channel data for
+ * each pixel in the image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although the encoding table defines how the image is compressed it is not
+ * essential. If an FSDefineJPEGImage3 object is created with an empty encoding
+ * table then the Flash Player will still display the JPEG image correctly. The
+ * empty encoding table is not a null object. It contains four bytes: 0xFF,
+ * 0xD8, 0xFF, 0xD9. For convenience passing a null reference to any of the
+ * constructors or to the setEncodingTable method will create an empty table.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSDefineJPEGImage3 class is to use the
+ * constructor that specifies the JPEG file to initialise the object:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * byte[] alpha = new byte[width * height];
+ * byte[] compressedAlpha = null;
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * 
+ * 	// Set the level of transparency;
+ * 
+ * 	for (int i = 0; i &lt; bytes.length; i++)
+ * 		alpha[i] = (byte) 128;
+ * 
+ * 	Deflater deflater = new Deflater();
+ * 
+ * 	byte[] tmp = new byte[alpha.length];
+ * 
+ * 	deflater.setInput(alpha);
+ * 	deflater.finish();
+ * 
+ * 	int bytesCompressed = deflater.deflate(tmp);
+ * 
+ * 	compressedAlpha = new byte[bytesCompressed];
+ * 
+ * 	for (int i = 0; i &lt; bytesCompressed; i++)
+ * 		compressedAlpha[i] = tmp[i];
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSDefineJPEGImage3(movie.newIdentifier(), bytes, null,
+ * 				compressedAlpha));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This generates an object with an empty encoding table, however the image will
+ * still be displayed correctly. The empty encoding table is not a null object.
+ * The alpha channel data is set so the image is completely opaque.
+ * &lt;/P&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineJPEGImage3 class represents the DefineBitsJPEG3 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineJPEGImage3 extends FSDefineObject
+{
+	private int width;
 
-&lt;p&gt;It extends the FSDefineJPEGImage3 class by including a separate zlib compressed table of alpha channel values. This allows the transparency of existing JPEG encoded images to be changed without re-encoding the original image.&lt;/p&gt;
+	private int height;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private byte[] image = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private byte[] encodingTable = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	private byte[] alpha = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineJPEGImage3 object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineJPEGImage3(FSCoder coder)
+	{
+		super(DefineJPEGImage3, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_2&quot;&gt;image&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage3 object with the specified image data,
+	 * encoding table and alpha channel data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param imageBytes
+	 *            byte array containing the image data
+	 * @param encodingBytes
+	 *            byte array containing the encoding table
+	 * @param alphaBytes
+	 *            byte array containing the zlib compressed alpha channel data
+	 */
+	public FSDefineJPEGImage3(int anIdentifier, byte[] imageBytes,
+								byte[] encodingBytes, byte[] alphaBytes)
+	{
+		super(DefineJPEGImage3, anIdentifier);
+		setImage(imageBytes);
+		setEncodingTable(encodingBytes);
+		setCompressedAlpha(alphaBytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_3&quot;&gt;encodingTable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the encoding table.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage object.
+	 */
+	public FSDefineJPEGImage3(FSDefineJPEGImage3 obj)
+	{
+		super(obj);
+		image = Transform.clone(obj.image);
+		width = obj.width;
+		height = obj.height;
+		encodingTable = Transform.clone(obj.encodingTable);
+		alpha = Transform.clone(obj.alpha);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_3&quot;&gt;alpha&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the zlib encoded alpha channel data for each
-pixel in the image.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the encoding table.
+	 * 
+	 * @return the array of bytes containing the encoding table.
+	 */
+	public byte[] getEncodingTable()
+	{
+		return encodingTable;
+	}
 
-&lt;p&gt;Although the encoding table defines how the image is compressed it is not
-essential. If an FSDefineJPEGImage3 object is created with an empty encoding
-table then the Flash Player will still display the JPEG image correctly. The
-empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8,
-0xFF, 0xD9. For convenience passing a null reference to any of the constructors
-or to the setEncodingTable method will create an empty table.&lt;/p&gt;
+	/**
+	 * Gets the width of the image in pixels.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;p&gt;The simplest way to use the FSDefineJPEGImage3 class is to use the constructor
-that specifies the JPEG file to initialise the object:&lt;/p&gt;
+	/**
+	 * Gets the height of the image in pixels.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
-byte[] alpha = new byte[width*height];
-byte[] compressedAlpha = null;
+	/**
+	 * Gets the image data.
+	 * 
+	 * @return the array of bytes containing the image data.
+	 */
+	public byte[] getImage()
+	{
+		return image;
+	}
 
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);
-    imageContents.read(bytes);
-    imageContents.close();
+	/**
+	 * Gets the alpha channel data.
+	 * 
+	 * @return the array of bytes containing the zlib compressed alpha data.
+	 */
+	public byte[] getCompressedAlpha()
+	{
+		return alpha;
+	}
 
-    // Set the level of transparency;
+	/**
+	 * Sets the encoding table.
+	 * 
+	 * @param bytes
+	 *            byte array containing the encoding table.
+	 */
+	public void setEncodingTable(byte[] bytes)
+	{
+		if (bytes == null || bytes.length == 0)
+		{
+			bytes = new byte[] {(byte) 0xFF, (byte) 0xD8, (byte) 0xFF, (byte) 0xD9 };
+		}
+		encodingTable = bytes;
+	}
 
-    for (int i=0; i&lt;bytes.length; i++)
-        alpha[i] = (byte)128;
+	/**
+	 * Sets the image data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the image table.
+	 */
+	public void setImage(byte[] bytes)
+	{
+		image = bytes;
+		decodeInfo();
+	}
 
-    Deflater deflater = new Deflater();
+	/**
+	 * Sets the alpha channel data with the zlib compressed data.
+	 * 
+	 * @param bytes
+	 *            array of bytes containing zlib encoded alpha channel.
+	 */
+	public void setCompressedAlpha(byte[] bytes)
+	{
+		alpha = bytes;
+	}
 
-    byte[] tmp = new byte[alpha.length];
+	public Object clone()
+	{
+		FSDefineJPEGImage3 anObject = (FSDefineJPEGImage3) super.clone();
 
-    deflater.setInput(alpha);
-    deflater.finish();
+		anObject.image = Transform.clone(image);
+		anObject.encodingTable = Transform.clone(encodingTable);
+		anObject.alpha = Transform.clone(alpha);
 
-    int bytesCompressed = deflater.deflate(tmp);
+		return anObject;
+	}
 
-    compressedAlpha = new byte[bytesCompressed];
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    for (int i=0; i&lt;bytesCompressed; i++)
-        compressedAlpha[i] = tmp[i];
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
+		if (super.equals(anObject))
+		{
+			FSDefineJPEGImage3 typedObject = (FSDefineJPEGImage3) anObject;
 
-movie.add(new FSDefineJPEGImage3(movie.newIdentifier(), bytes, null, compressedAlpha));
-&lt;/pre&gt;
+			result = Transform.equals(image, typedObject.image);
+			result = result
+							&amp;&amp; Transform.equals(encodingTable,
+											typedObject.encodingTable);
+			result = result &amp;&amp; Transform.equals(alpha, typedObject.alpha);
+		}
+		return result;
+	}
 
-&lt;p&gt;This generates an object with an empty encoding table, however the image will
-still be displayed correctly. The empty encoding table is not a null object. The
-alpha channel data is set so the image is completely opaque.&lt;/P&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		buffer.append(&quot;FSDefineJPEGImage3: { &quot;);
+		buffer.append(&quot;encodingTable = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;image = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;alpha = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-&lt;p&gt;The FSDefineJPEGImage3 class represents the DefineBitsJPEG3 tag from the
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */
-public class FSDefineJPEGImage3 extends FSDefineObject
-{
-    private int width;
-    private int height;
-    private byte[] image = null;
-    private byte[] encodingTable = null;
-    private byte[] alpha = null;
+		return buffer.toString();
+	}
 
-    /**
-     * Construct an FSDefineJPEGImage3 object, initalizing it with values
-     * decoded from an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineJPEGImage3(FSCoder coder)
-    {
-        super(DefineJPEGImage3, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineJPEGImage3 object with the specified image data, encoding table and
-        alpha channel data.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anIdentifier    the unique identifier for this object
-        @param imageBytes byte array containing the image data
-        @param encodingBytes byte array containing the encoding table
-        @param alphaBytes byte array containing the zlib compressed alpha channel data
-        */
-    public FSDefineJPEGImage3(int anIdentifier, byte[] imageBytes, byte[] encodingBytes, byte[] alphaBytes)
-    {
-        super(DefineJPEGImage3, anIdentifier);
-        setImage(imageBytes);
-        setEncodingTable(encodingBytes);
-        setCompressedAlpha(alphaBytes);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing
-     * object.
-     *
-     * @param obj an FSDefineJPEGImage object.
-     */
-    public FSDefineJPEGImage3(FSDefineJPEGImage3 obj)
-    {
-        super(obj);
-        image = Transform.clone(obj.image);
-        width = obj.width;
-        height = obj.height;
-        encodingTable = Transform.clone(obj.encodingTable);
-        alpha = Transform.clone(obj.alpha);
-    }
+		length += 4;
+		length += encodingTable.length;
+		length += image.length;
+		length += (alpha == null) ? 0 : alpha.length;
 
-    /** Gets the encoding table.
+		return length;
+	}
 
-        @return the array of bytes containing the encoding table.
-        */
-    public byte[] getEncodingTable()  { return encodingTable; }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** 
-     * Gets the width of the image in pixels. 
-     * 
-     * @return the width of the image.
-     */
-    public int getWidth()
-    {
-        return width; 
-    }    
-    /** 
-     * Gets the height of the image in pixels.
-     * 
-     * @return the height of the image in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }
+		coder.writeWord(encodingTable.length + image.length, 4);
+		coder.writeBytes(encodingTable);
+		coder.writeBytes(image);
 
-    /** Gets the image data.
+		if (alpha != null)
+			coder.writeBytes(alpha);
+	}
 
-        @return the array of bytes containing the image data.
-        */
-    public byte[] getImage() { return image; }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    /** Gets the alpha channel data.
+		int offset = coder.readWord(4, false);
 
-        @return the array of bytes containing the zlib compressed alpha data.
-        */
-    public byte[] getCompressedAlpha()  { return alpha; }
+		setEncodingTable(readJPEGStream(coder));
+		byte[] imageIn = new byte[offset - encodingTable.length];
+		coder.readBytes(imageIn);
+		setImage(imageIn);
+		byte[] alphaIn = new byte[length - offset - 6];
+		coder.readBytes(alphaIn);
+		setCompressedAlpha(alphaIn);
+	}
 
-    /** Sets the encoding table.
+	private byte[] readJPEGStream(FSCoder coder)
+	{
+		byte bytes[] = null;
 
-        @param bytes byte array containing the encoding table.
-        */
-    public void setEncodingTable(byte[] bytes)
-    {
-        if (bytes == null) {
-            bytes = new byte[] { (byte)0xFF, (byte)0xD9, (byte)0xFF, (byte)0xD8 };
-        }
-        encodingTable = bytes;
-    }
+		int start = coder.getPointer();
+		int end = start + ((length - 2) &lt;&lt; 3);
+		int word = coder.readBits(16, false);
+		int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
 
-    /** Sets the image data.
+		do
+		{
+			word = coder.scanBits(16, false);
 
-        @param bytes an array of bytes containing the image table.
-        */
-    public void setImage(byte[] bytes)
-    {
-        image = bytes;
-        decodeInfo();
-    }
+			if (word == eoi)
+			{
+				end = coder.getPointer() + 16;
+				break;
+			}
+			coder.adjustPointer(8);
+		} while (coder.getPointer() &lt; end);
 
-    /** Sets the alpha channel data with the zlib compressed data.
+		int len = (end - start) &gt;&gt;&gt; 3;
 
-        @param bytes array of bytes containing zlib encoded alpha channel.
-        */
-    public void setCompressedAlpha(byte[] bytes)
-    {
-        alpha = bytes;
-    }
+		coder.setPointer(start);
+		bytes = new byte[len];
+		coder.readBytes(bytes);
 
-    public Object clone()
-    {
-        FSDefineJPEGImage3 anObject = (FSDefineJPEGImage3)super.clone();
+		return bytes;
+	}
 
-        anObject.image = Transform.clone(image);
-        anObject.encodingTable = Transform.clone(encodingTable);
-        anObject.alpha = Transform.clone(alpha);
+	private boolean decodeInfo()
+	{
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
 
-        return anObject;
-    }
+		if (coder.readWord(2, false) != 0xffd8)
+			return false;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+		while (true)
+		{
+			int marker = coder.readWord(2, false);
+			int size = coder.readWord(2, false);
 
-        if (super.equals(anObject))
-        {
-            FSDefineJPEGImage3 typedObject = (FSDefineJPEGImage3)anObject;
+			if ((marker &amp; 0xff00) != 0xff00)
+				return false;
 
-            result = Transform.equals(image, typedObject.image);
-            result = result &amp;&amp; Transform.equals(encodingTable, typedObject.encodingTable);
-            result = result &amp;&amp; Transform.equals(alpha, typedObject.alpha);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
-            Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
-            Transform.append(buffer, &quot;alpha&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += 4;
-        length += encodingTable.length;
-        length += image.length;
-
-        length += (alpha == null) ? 0 : alpha.length;
-
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(encodingTable.length+image.length, 4);
-        coder.writeBytes(encodingTable);
-        coder.writeBytes(image);
-
-        if (alpha != null)
-            coder.writeBytes(alpha);
-
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int offset = coder.readWord(4, false);
-
-        setEncodingTable(readJPEGStream(coder));
-        byte[] imageIn = new byte[offset-encodingTable.length];
-        coder.readBytes(imageIn);
-        setImage(imageIn);
-        byte[] alphaIn = new byte[length-offset-6];
-        coder.readBytes(alphaIn);
-         setCompressedAlpha(alphaIn);
-
-        coder.endObject(name());
-    }
-
-    private byte[] readJPEGStream(FSCoder coder)
-    {
-        byte bytes[] = null;
-        
-        int start = coder.getPointer();
-        int end = start + ((length-2) &lt;&lt; 3);
-        int word = coder.readBits(16, false);
-        int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
-
-        do {
-            word = coder.scanBits(16, false);
-
-            if (word == eoi)
-            {
-                end = coder.getPointer()+16;
-                break;
-            }
-            coder.adjustPointer(8);
-        }
-        while (coder.getPointer() &lt; end);
-
-        int len = (end-start) &gt;&gt;&gt; 3;
-
-        coder.setPointer(start);
-        bytes = new byte[len];
-        coder.readBytes(bytes);
-
-        return bytes;
-    }
-    private boolean decodeInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
-
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readWord(1, false);
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4
+							&amp;&amp; marker != 0xffc8)
+			{
+				coder.readByte();
+				height = coder.readWord(2, false);
+				width = coder.readWord(2, false);
+				return true;
+			} else
+			{
+				coder.adjustPointer((size - 2) &lt;&lt; 3);
+			}
+		}
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineMorphShape.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineMorphShape.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineMorphShape.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,567 +33,683 @@
 import java.util.*;
 
 /**
-FSDefineMorphShape defines a shape that will morph from one form into another. 
- 
-&lt;p&gt;Only the start and end shapes are defined the Flash Player will perform the interpolation that transforms the shape at each staging in the morphing process.&lt;/p&gt;
+ * FSDefineMorphShape defines a shape that will morph from one form into
+ * another.
+ * 
+ * &lt;p&gt;
+ * Only the start and end shapes are defined the Flash Player will perform the
+ * interpolation that transforms the shape at each staging in the morphing
+ * process.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Morphing can be applied to any shape, however there are a few restrictions:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The start and end shapes must have the same number of edges (FSLine and
+ * FSCurve objects).&lt;/li&gt;
+ * &lt;li&gt;The fill style (Solid, Bitmap or Gradient) must be the same in the start
+ * and end shape.&lt;/li&gt;
+ * &lt;li&gt;If a bitmap fill style is used then the same image must be used in the
+ * start and end shapes.&lt;/li&gt;
+ * &lt;li&gt;If a gradient fill style is used then the gradient must contain the same
+ * number of points in the start and end shape.&lt;/li&gt;
+ * &lt;li&gt;The start and end shape must contain the same set of FSShapeStyle
+ * objects.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * To perform the morphing of a shape the shape is placed in the display list
+ * using a FSPlaceObject2 object. The ratio attribute in the FSPlaceObject2
+ * object defines the progress of the morphing process. The ratio ranges between
+ * 0.0 and 1.0 where 0 represents the start of the morphing process and 1.0, the
+ * end.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startBounds&lt;/td&gt;
+ * &lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is
+ * drawn at the start of the morph process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;endBounds&lt;/td&gt;
+ * &lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is
+ * drawn at the end of the morph process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startShape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe the shape at the start of the morphing
+ * process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;endShape&lt;/td&gt;
+ * &lt;td&gt;The shape at the end of the morphing process containing the FSLine and
+ * FSCurve objects that define the edges of the shape.FSShapeStyle objects may
+ * only be included if they are used to move the current point and may &lt;b&gt;not&lt;/b&gt;
+ * change the style being used to draw the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The edges may change their type when a shape is morphed. Straight edges can
+ * become curves and vice versa.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This simple example morphs a rectangle into a square. While this example is
+ * trivial it illustrates how the FSDefineMorphShape class is used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * This rectangle is 200 twips wide and 100 twips high, drawing using a black
+ * outline 1 twip wide and filled with a transparent red colour. The square is
+ * 150 x 150 twips. The origin of the shape is at the bottom left corner of the
+ * rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Create the bounding rectangle for the start shape (rectangle).
+ *  FSBounds startBounds = new FSBounds(0, 0, 200, 100);
+ * 
+ *  // Create the bounding rectangle for the end shape (square).
+ *  FSBounds endBounds = new FSBounds(0, 0, 150, 150);
+ * 
+ *  // Define the styles for the shape.
+ * 
+ *  ArrayList fillStyles = new ArrayList();
+ *  ArrayList lineStyles = new ArrayList();
+ * 
+ *  fillStyles.push_back(new FSSolidFill(new FSColor((FSColorTable.red)));
+ * 
+ *  lineStyles.push_back(new FSLineStyle(1, FColor.black()));
+ * 
+ *  // Draw the rectangle.
+ * 
+ *  FSShape rectangle = new FSShape();
+ * 
+ *  rectangle.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ *  rectangle.add(new FSLine(200,0));
+ *  rectangle.add(new FSLine(0,100));
+ *  rectangle.add(new FSLine(-200,0));
+ *  rectangle.add(new FSLine(0,-100));
+ * 
+ *  // Draw the square.
+ * 
+ *  FSShape square = new FSShape();
+ * 
+ *  square.add(new FSLine(150,0));
+ *  square.add(new FSLine(0,150));
+ *  square.add(new FSLine(-150,0));
+ *  square.add(new FSLine(0,-150));
+ * 
+ *  FSDefineMorphShape shape = FSDefineMorphShape(movie.newIdentifier(), startBounds, endBounds, fillStyles, lineStyles, rectangle, square);
+ * 
+ *  // The morphing process is controlled by the FSPlaceObject2 class using the ratio attribute.
+ *  // Place the shape on layer 1 of the display list at coordinates (0,0).
+ * 
+ *  movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 0,0));
+ *  movie.add(new FSShowFrame());
+ * 
+ *  // Morph the shape over 5 steps without changing its location.
+ * 
+ *  for (float i=0.2; i&lt;1.0; i+= 0.2)
+ *  {
+ *  movie.add(new FSPlaceObject2(1, i, 0,0));
+ *  movie.add(new FSShowFrame());
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineMorphShape class represents the DefineMorphShape tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineMorphShape extends FSDefineObject
+{
+	private FSBounds startBounds = null;
 
-&lt;p&gt;Morphing can be applied to any shape, however there are a few restrictions:&lt;/p&gt;
+	private FSBounds endBounds = null;
 
-&lt;ul&gt;
-&lt;li&gt;The start and end shapes must have the same number of edges (FSLine and FSCurve objects).&lt;/li&gt;
-&lt;li&gt;The fill style (Solid, Bitmap or Gradient) must be the same in the start and end shape.&lt;/li&gt;
-&lt;li&gt;If a bitmap fill style is used then the same image must be used in the start and end shapes.&lt;/li&gt;
-&lt;li&gt;If a gradient fill style is used then the gradient must contain the same number of points in the start and end shape.&lt;/li&gt;
-&lt;li&gt;The start and end shape must contain the same set of FSShapeStyle objects.&lt;/li&gt;
-&lt;/ul&gt;
+	private ArrayList fillStyles = null;
 
-&lt;p&gt;To perform the morphing of a shape the shape is placed in the display list using a FSPlaceObject2 object. The ratio attribute in the FSPlaceObject2 object defines the progress of the morphing process. The ratio ranges between 0.0 and 1.0 where 0 represents the start of the morphing process and 1.0, the end.&lt;/p&gt;
+	private ArrayList lineStyles = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private FSShape startShape = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private FSShape endShape = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineJPEGImage object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineMorphShape(FSCoder coder)
+	{
+		super(DefineMorphShape, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineMorphShape object.
+	 * 
+	 * @param anIdentifier
+	 *            an unique identifier for this object.
+	 * @param startBounds
+	 *            the bounding rectangle enclosing the start shape.
+	 * @param endBounds
+	 *            the bounding rectangle enclosing the end shape.
+	 * @param fillStyleArray
+	 *            an array of FSMorphSolidFill, FSMorphBitmapFill and
+	 *            FSMorphGradientFill objects.
+	 * @param lineStyleArray
+	 *            an array of FSMorphLineStyle objects.
+	 * @param startShape
+	 *            the shape at the start of the morphing process.
+	 * @param endShape
+	 *            the shape at the end of the morphing process.
+	 */
+	public FSDefineMorphShape(int anIdentifier, FSBounds startBounds,
+								FSBounds endBounds, ArrayList fillStyleArray,
+								ArrayList lineStyleArray, FSShape startShape,
+								FSShape endShape)
+	{
+		super(DefineMorphShape, anIdentifier);
+		setStartBounds(startBounds);
+		setEndBounds(endBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setStartShape(startShape);
+		setEndShape(endShape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_2&quot;&gt;startBounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is drawn at the start of the morph process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage object.
+	 */
+	public FSDefineMorphShape(FSDefineMorphShape obj)
+	{
+		super(obj);
+		startBounds = new FSBounds(obj.startBounds);
+		endBounds = new FSBounds(obj.endBounds);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_3&quot;&gt;endBounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is drawn at the end of the morph process.&lt;/td&gt;
-&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_4&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_5&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles.&lt;/td&gt;
-&lt;/tr&gt;
+		lineStyles = new ArrayList();
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_6&quot;&gt;startShape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle objects) that describe the shape at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_7&quot;&gt;endShape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The shape at the end of the morphing process containing the FSLine and FSCurve objects that define the edges of the shape.FSShapeStyle objects may only be included if they are used to move the current point and may &lt;b&gt;not&lt;/b&gt; change the style being used to draw the shape.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		startShape = new FSShape(obj.startShape);
+		endShape = new FSShape(obj.endShape);
+	}
 
-&lt;p&gt;The edges may change their type when a shape is morphed. Straight edges can become curves and vice versa.&lt;/p&gt;
+	/**
+	 * Add a FSLineStyle object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSLineStyle object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            an FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-&lt;p&gt;This simple example morphs a rectangle into a square. While this example is trivial it illustrates how the FSDefineMorphShape class is used.&lt;/p&gt;
+	/**
+	 * Gets the FSBounds object that defines the bounding rectangle enclosing
+	 * the start shape.
+	 * 
+	 * @return the bounds of the start shape.
+	 */
+	public FSBounds getStartBounds()
+	{
+		return startBounds;
+	}
 
-&lt;p&gt;This rectangle is 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a transparent red colour. The square is 150 x 150 twips. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Gets the FSBounds object that defines the bounding rectangle enclosing
+	 * the end shape.
+	 * 
+	 * @return the bounds of the end shape.
+	 */
+	public FSBounds getEndBounds()
+	{
+		return endBounds;
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the start shape (rectangle).
-FSBounds startBounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Gets the array of FSMorphSolidFill, FSMorphBitmapFill and
+	 * FSMorphGradientFill objects that define the fill styles for the shapes.
+	 * 
+	 * @return the array morph fill styles.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-// Create the bounding rectangle for the end shape (square).
-FSBounds endBounds = new FSBounds(0, 0, 150, 150);
+	/**
+	 * Gets the array of FSMorphLineStyle objects that define the line styles
+	 * for the shapes.
+	 * 
+	 * @return the array morph line styles.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Gets the starting shape.
+	 * 
+	 * @return the start shape.
+	 */
+	public FSShape getStartShape()
+	{
+		return startShape;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Gets the ending shape.
+	 * 
+	 * @return the end shape.
+	 */
+	public FSShape getEndShape()
+	{
+		return endShape;
+	}
 
-fillStyles.push_back(new FSSolidFill(new FSColor((FSColorTable.red)));
+	/**
+	 * Sets the starting bounds of the shape.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the start shape.
+	 */
+	public void setStartBounds(FSBounds aBounds)
+	{
+		startBounds = aBounds;
+	}
 
-lineStyles.push_back(new FSSolidLine(1, FColor.black()));
+	/**
+	 * Sets the ending bounds of the shape.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the end shape.
+	 */
+	public void setEndBounds(FSBounds aBounds)
+	{
+		endBounds = aBounds;
+	}
 
-// Draw the rectangle.
+	/**
+	 * Sets the array of morph fill styles.
+	 * 
+	 * @param anArray
+	 *            an array of FSMorphSolidFill, FSMorphBitmapFill and
+	 *            FSMorphGradientFill objects.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-FSShape rectangle = new FSShape();
+	/**
+	 * Sets the array of morph line styles.
+	 * 
+	 * @param anArray
+	 *            an array of FSMorphLineStyle objects.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-rectangle.add(new FSShapeStyle(1, 1, 0, 0, 0));
-rectangle.add(new FSLine(200,0));
-rectangle.add(new FSLine(0,100));
-rectangle.add(new FSLine(-200,0));
-rectangle.add(new FSLine(0,-100));
+	/**
+	 * Sets the starting shape.
+	 * 
+	 * @param aShape
+	 *            the shape at the start of the morphing process.
+	 */
+	public void setStartShape(FSShape aShape)
+	{
+		startShape = aShape;
+	}
 
-// Draw the square.
+	/**
+	 * Sets the ending shape.
+	 * 
+	 * @param aShape
+	 *            the shape at the end of the morphing process.
+	 */
+	public void setEndShape(FSShape aShape)
+	{
+		endShape = aShape;
+	}
 
-FSShape square = new FSShape();
+	public Object clone()
+	{
+		FSDefineMorphShape anObject = (FSDefineMorphShape) super.clone();
 
-square.add(new FSLine(150,0));
-square.add(new FSLine(0,150));
-square.add(new FSLine(-150,0));
-square.add(new FSLine(0,-150));
+		anObject.startBounds = (startBounds != null) ? (FSBounds) startBounds
+						.clone() : null;
+		anObject.endBounds = (endBounds != null) ? (FSBounds) endBounds.clone()
+						: null;
 
-FSDefineMorphShape shape = FSDefineMorphShape(movie.newIdentifier(), startBounds, endBounds, fillStyles, lineStyles, rectangle, square);
+		anObject.fillStyles = new ArrayList();
 
-// The morphing process is controlled by the FSPlaceObject2 class using the ratio attribute.
-// Place the shape on layer 1 of the display list at coordinates (0,0).
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 0,0));
-movie.add(new FSShowFrame());
+		anObject.lineStyles = new ArrayList();
 
-// Morph the shape over 5 steps without changing its location.
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-for (float i=0.2; i&lt;1.0; i+= 0.2)
-{
-    movie.add(new FSPlaceObject2(1, i, 0,0));
-    movie.add(new FSShowFrame());
-}
-&lt;/pre&gt;
+		anObject.startShape = (startShape != null) ? (FSShape) startShape
+						.clone() : null;
+		anObject.endShape = (endShape != null) ? (FSShape) endShape.clone()
+						: null;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		return anObject;
+	}
 
-&lt;p&gt;The FSDefineMorphShape class represents the DefineMorphShape tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineMorphShape extends FSDefineObject
-{
-    private FSBounds startBounds = null;
-    private FSBounds endBounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape startShape = null;
-    private FSShape endShape = null;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Construct an FSDefineJPEGImage object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineMorphShape(FSCoder coder)
-    {
-        super(DefineMorphShape, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineMorphShape object.
+		if (super.equals(anObject))
+		{
+			FSDefineMorphShape typedObject = (FSDefineMorphShape) anObject;
 
-        @param anIdentifier an unique identifier for this object.
-        @param startBounds the bounding rectangle enclosing the start shape.
-        @param endBounds the bounding rectangle enclosing the end shape.
-        @param fillStyleArray an array of FSMorphSolidFill, FSMorphBitmapFill and FSMorphGradientFill objects.
-        @param lineStyleArray an array of FSMorphLineStyle objects.
-        @param startShape the shape at the start of the morphing process.
-        @param endShape the shape at the end of the morphing process.
-        */
-    public FSDefineMorphShape(int anIdentifier, FSBounds startBounds, FSBounds endBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape startShape, FSShape endShape)
-    {
-        super(DefineMorphShape, anIdentifier);
-        setStartBounds(startBounds);
-        setEndBounds(endBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setStartShape(startShape);
-        setEndShape(endShape);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineJPEGImage object.
-     */
-    public FSDefineMorphShape(FSDefineMorphShape obj)
-    {
-        super(obj);
-        startBounds = new FSBounds(obj.startBounds);
-        endBounds = new FSBounds(obj.endBounds);
+			if (startBounds != null)
+				result = startBounds.equals(typedObject.startBounds);
+			else
+				result = startBounds == typedObject.startBounds;
 
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+			if (endBounds != null)
+				result = result &amp;&amp; endBounds.equals(typedObject.endBounds);
+			else
+				result = result &amp;&amp; endBounds == typedObject.endBounds;
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-        startShape = new FSShape(obj.startShape);
-        endShape = new FSShape(obj.endShape);
-    }
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-    /** Add a FSSolidLine object to the array of line styles.
+			if (startShape != null)
+				result = result &amp;&amp; startShape.equals(typedObject.startShape);
+			else
+				result = result &amp;&amp; startShape == typedObject.startShape;
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+			if (endShape != null)
+				result = result &amp;&amp; endShape.equals(typedObject.endShape);
+			else
+				result = result &amp;&amp; endShape == typedObject.endShape;
+		}
+		return result;
+	}
 
-    /** Add the fill style object to the array of fill styles.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param aFillStyle an FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+		buffer.append(&quot;FSDefineMorphShape: { &quot;);
+		buffer.append(&quot;startBounds = &quot;).append(startBounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;endBounds = &quot;).append(endBounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;fillStyles = &quot;).append(fillStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;lineStyles = &quot;).append(lineStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;startShape = &quot;).append(startShape.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;endShape = &quot;).append(endShape.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Gets the FSBounds object that defines the bounding rectangle enclosing the start shape.
+		return buffer.toString();
+	}
 
-        @return the bounds of the start shape.
-        */
-    public FSBounds getStartBounds() { return startBounds; }
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Gets the FSBounds object that defines the bounding rectangle enclosing the end shape.
+		super.length(coder);
 
-        @return the bounds of the end shape.
-        */
-    public FSBounds getEndBounds() { return endBounds; }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Gets the array of FSMorphSolidFill, FSMorphBitmapFill and FSMorphGradientFill objects that define the fill styles for the shapes.
+		length += startBounds.length(coder);
+		length += endBounds.length(coder);
+		length += 4;
 
-        @return the array morph fill styles.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+		length += (fillStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Gets the array of FSMorphLineStyle objects that define the line styles for the shapes.
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-        @return the array morph line styles.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		length += (lineStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Gets the starting shape.
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-        @return the start shape.
-        */
-    public FSShape getStartShape() { return startShape; }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    /** Gets the ending shape.
+		length += startShape.length(coder);
 
-        @return the end shape.
-        */
-    public FSShape getEndShape() { return endShape; }
+		// Number of Fill and Line bits is zero for end shape.
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    /** Sets the starting bounds of the shape.
+		length += endShape.length(coder);
 
-        @param aBounds the bounding rectangle enclosing the start shape.
-        */
-    public void setStartBounds(FSBounds aBounds)
-    {
-        startBounds = aBounds;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.TransparentColors] = 0;
 
-    /** Sets the ending bounds of the shape.
+		return length;
+	}
 
-        @param aBounds the bounding rectangle enclosing the end shape.
-        */
-    public void setEndBounds(FSBounds aBounds)
-    {
-        endBounds = aBounds;
-    }
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Sets the array of morph fill styles.
+		super.encode(coder);
 
-        @param anArray an array of FSMorphSolidFill, FSMorphBitmapFill and FSMorphGradientFill objects.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Sets the array of morph line styles.
+		startBounds.encode(coder);
+		endBounds.encode(coder);
 
-        @param anArray an array of FSMorphLineStyle objects.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		int offsetStart = coder.getPointer();
+		coder.writeWord(0, 4);
 
-    /** Sets the starting shape.
+		if (fillStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(fillStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(fillStyles.size(), 1);
+		}
 
-        @param aShape the shape at the start of the morphing process.
-        */
-    public void setStartShape(FSShape aShape)
-    {
-        startShape = aShape;
-    }
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			styleIterator.next().encode(coder);
 
-    /** Sets the ending shape.
+		if (lineStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(lineStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(lineStyles.size(), 1);
+		}
 
-        @param aShape the shape at the end of the morphing process.
-        */
-    public void setEndShape(FSShape aShape)
-    {
-        endShape = aShape;
-    }
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			 styleIterator.next().encode(coder);
 
-    public Object clone()
-    {
-        FSDefineMorphShape anObject = (FSDefineMorphShape)super.clone();
-        
-        anObject.startBounds = (startBounds != null) ? (FSBounds)startBounds.clone() : null;
-        anObject.endBounds = (endBounds != null) ? (FSBounds)endBounds.clone() : null;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		startShape.encode(coder);
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		int offsetEnd = (coder.getPointer() - offsetStart) &gt;&gt; 3;
+		int currentCursor = coder.getPointer();
 
-        anObject.startShape = (startShape != null) ? (FSShape)startShape.clone() : null;
-        anObject.endShape = (endShape != null) ? (FSShape)endShape.clone() : null;
-        
-        return anObject;
-    }
+		coder.setPointer(offsetStart);
+		coder.writeWord(offsetEnd - 4, 4);
+		coder.setPointer(currentCursor);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineMorphShape typedObject = (FSDefineMorphShape)anObject;
-            
-            if (startBounds != null)
-                result = startBounds.equals(typedObject.startBounds);
-            else
-                result = startBounds == typedObject.startBounds;
+		// Number of Fill and Line bits is zero for end shape.
 
-            if (endBounds != null)
-                result = result &amp;&amp; endBounds.equals(typedObject.endBounds);
-            else
-                result = result &amp;&amp; endBounds == typedObject.endBounds;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		endShape.encode(coder);
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 
-            if (startShape != null)
-                result = result &amp;&amp; startShape.equals(typedObject.startShape);
-            else
-                result = result &amp;&amp; startShape == typedObject.startShape;
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-            if (endShape != null)
-                result = result &amp;&amp; endShape.equals(typedObject.endShape);
-            else
-                result = result &amp;&amp; endShape == typedObject.endShape;
-        }
-        return result;
-    }
+		super.decode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startBounds&quot;, startBounds, depth);
-            Transform.append(buffer, &quot;endBounds&quot;, endBounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;startShape&quot;, startShape, depth);
-            Transform.append(buffer, &quot;endShape&quot;, endShape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+		int start = coder.getPointer() - 16;
 
-        length += startBounds.length(coder);
-        length += endBounds.length(coder);
-        length += 4;
-        
-        length += (fillStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        length += (lineStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += startShape.length(coder);
+		startBounds = new FSBounds(coder);
+		endBounds = new FSBounds(coder);
 
-        // Number of Fill and Line bits is zero for end shape.
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		int offset = coder.readWord(4, false);
+		int first = coder.getPointer();
 
-        length += endShape.length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+		fillStyleCount = coder.readByte();
 
-        startBounds.encode(coder);
-        endBounds.encode(coder);
-    
-        int offsetStart = coder.getPointer();
-        coder.writeWord(0, 4);
+		if (coder.context[FSCoder.ArrayCountExtended] != 0
+						&amp;&amp; fillStyleCount == 0xFF)
+			fillStyleCount = coder.readWord(2, false);
 
-        if (fillStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(fillStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(fillStyles.size(), 1);
-        }
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        if (lineStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(lineStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(lineStyles.size(), 1);
-        }
-                
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        startShape.encode(coder);
+		fillStyles = new ArrayList(fillStyleCount);
 
-        int offsetEnd = (coder.getPointer() - offsetStart) &gt;&gt; 3;
-        int currentCursor = coder.getPointer();
-        
-        coder.setPointer(offsetStart);
-        coder.writeWord(offsetEnd-4, 4);
-        coder.setPointer(currentCursor);
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSMorphSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSMorphGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSMorphGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSMorphBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSMorphBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        // Number of Fill and Line bits is zero for end shape.
-        
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		lineStyleCount = coder.readByte();
 
-        endShape.encode(coder);
+		if (coder.context[FSCoder.ArrayCountExtended] != 0
+						&amp;&amp; lineStyleCount == 0xFF)
+			lineStyleCount = coder.readWord(2, false);
 
-         coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.TransparentColors] = 0;
+		lineStyles = new ArrayList(lineStyleCount);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSMorphLineStyle(coder));
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        
-        int start = coder.getPointer()-16;
-        
-        startBounds = new FSBounds(coder);
-        endBounds = new FSBounds(coder);
-        
-        int offset = coder.readWord(4, false);
-        int first = coder.getPointer();
+		int bytesDecoded = (coder.getPointer() - first) &gt;&gt; 3;
 
-        fillStyleCount = coder.readWord(1, false);
+		startShape = new FSShape(coder, offset - bytesDecoded);
 
-        if (coder.context[FSCoder.ArrayCountExtended] != 0 &amp;&amp; fillStyleCount == 0xFF)
-            fillStyleCount = coder.readWord(2, false);
-            
-        fillStyles = new ArrayList(fillStyleCount);
+		bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSMorphSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSMorphGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSMorphGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSMorphBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSMorphBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
+		endShape = new FSShape(coder, length - bytesDecoded);
 
-        if (coder.context[FSCoder.ArrayCountExtended] != 0 &amp;&amp; lineStyleCount == 0xFF)
-            lineStyleCount = coder.readWord(2, false);
-
-        lineStyles = new ArrayList(lineStyleCount);
-
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSMorphSolidLine(coder));
-        
-        int bytesDecoded = (coder.getPointer()-first) &gt;&gt; 3;
-
-        startShape = new FSShape(coder, offset-bytesDecoded);
-
-        bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
-
-        endShape = new FSShape(coder, length-bytesDecoded);
-
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        
-        coder.endObject(name());
-    }
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineMovieClip.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineMovieClip.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineMovieClip.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,219 +33,249 @@
 import java.util.*;
 
 /**
-FSDefineMovieClip defines a movie clip that animates shapes within a movie. 
- 
-&lt;p&gt;It contains an array of movie objects that define the placement of shapes, buttons, text and images and the order in which they are displayed through a time-line that is separate from the parent movie.&lt;/p&gt;
+ * FSDefineMovieClip defines a movie clip that animates shapes within a movie.
+ * 
+ * &lt;p&gt;
+ * It contains an array of movie objects that define the placement of shapes,
+ * buttons, text and images and the order in which they are displayed through a
+ * time-line that is separate from the parent movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, for the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSMovieObject objects that define the commands that are
+ * executed by the Flash Player to animate the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although a movie clip contains the commands that instructs the Flash Player
+ * on how to animate the clip it cannot contain any new definitions of objects.
+ * All definitions must be in the main movie. All objects referred to by the
+ * movie clip must be also defined in the main movie before they can be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When using the FSDefineMovieClip object can only contain objects from the
+ * following classes: FSShowFrame, FSPlaceObject, FSPlaceObject2,
+ * FSRemoveObject, FSRemoveObject2, FSDoAction, FSStartSound, FSFrameLabel,
+ * FSSoundStreamHead, FSSoundStreamHead2 or FSSoundStreamBlock. Other objects
+ * are not allowed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineMovieClip class represents the DefineSprite tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineMovieClip extends FSDefineObject
+{
+	private ArrayList objects = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineMovieClip object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineMovieClip(FSCoder coder)
+	{
+		super(DefineMovieClip, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineMovieClip object with the unique identifier. The
+	 * Array of objects used to control the movie is empty.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for the movie clip.
+	 */
+	public FSDefineMovieClip(int anIdentifier)
+	{
+		super(DefineMovieClip, anIdentifier);
+		setObjects(new ArrayList());
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMovieClip_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineMovieClip object with the unique identifier and
+	 * array of movie objects.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for the movie clip.
+	 * @param anArray
+	 *            the array of movie objects.
+	 */
+	public FSDefineMovieClip(int anIdentifier, ArrayList anArray)
+	{
+		super(DefineMovieClip, anIdentifier);
+		setObjects(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMovieClip_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, for the movie clip.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineMovieClip(FSDefineMovieClip obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMovieClip_2&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSMovieObject objects that define the commands that are executed by the Flash Player to animate the movie clip.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		objects = new ArrayList();
 
-&lt;p&gt;Although a movie clip contains the commands that instructs the Flash Player on how to animate the clip it cannot contain any new definitions of objects. All definitions must be in the main movie. All objects referred to by the movie clip must be also defined in the main movie before they can be used.&lt;/p&gt;
+		for (Iterator i = obj.objects.iterator(); i.hasNext();)
+			objects.add(((FSMovieObject) i.next()).clone());
+	}
 
-&lt;p&gt;When using the FSDefineMovieClip object can only contain objects from the following classes: FSShowFrame, FSPlaceObject, FSPlaceObject2, FSRemoveObject, FSRemoveObject2, FSDoAction, FSStartSound, FSFrameLabel, FSSoundStreamHead, FSSoundStreamHead2 or FSSoundStreamBlock. Other objects are not allowed.&lt;/p&gt;
+	/**
+	 * Adds the movie object to the array of actions.
+	 * 
+	 * @param anObject
+	 *            an object belonging to a class derived from FSMovieObject.
+	 */
+	public void add(FSMovieObject anObject)
+	{
+		objects.add(anObject);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the array of movie objects.
+	 * 
+	 * @return the array of movie objects.
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-&lt;p&gt;The FSDefineMovieClip class represents the DefineSprite tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineMovieClip extends FSDefineObject
-{
-    private ArrayList objects = null;
+	/**
+	 * Sets the array of movie objects.
+	 * 
+	 * @param anArray
+	 *            the array of movie objects.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-    /**
-     * Construct an FSDefineMovieClip object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineMovieClip(FSCoder coder)
-    {
-        super(DefineMovieClip, 0);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSDefineMovieClip object with the unique identifier. The 
-     * Array of objects used to control the movie is empty.
-     * 
-     * @param anIdentifier a unique identifier for the movie clip.
-     */
-    public FSDefineMovieClip(int anIdentifier)
-    {
-        super(DefineMovieClip, anIdentifier);
-        setObjects(new ArrayList());
-    }
-    /** Constructs an FSDefineMovieClip object with the unique identifier and array of movie objects.
+	/**
+	 * Gets the total number of frames in the movie clip.
+	 * 
+	 * @return the number of frames.
+	 */
+	public int getFrameCount()
+	{
+		return numberOfFrames();
+	}
 
-        @param anIdentifier a unique identifier for the movie clip.
-        @param anArray the array of movie objects.
-        */
-    public FSDefineMovieClip(int anIdentifier, ArrayList anArray)
-    {
-        super(DefineMovieClip, anIdentifier);
-        setObjects(anArray);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineMovieClip(FSDefineMovieClip obj)
-    {
-        super(obj);
+	public Object clone()
+	{
+		FSDefineMovieClip anObject = (FSDefineMovieClip) super.clone();
 
-        objects = new ArrayList();
-        
-        for (Iterator i = obj.objects.iterator(); i.hasNext();)
-            objects.add(((FSMovieObject)i.next()).clone());
-    }
+		anObject.objects = new ArrayList();
 
-    /** Adds the movie object to the array of actions.
+		for (Iterator i = objects.iterator(); i.hasNext();)
+			anObject.objects.add(((FSMovieObject) i.next()).clone());
 
-        @param anObject an object belonging to a class derived from FSMovieObject.
-        */
-    public void add(FSMovieObject anObject)
-    {
-        objects.add(anObject);
-    }
+		return anObject;
+	}
 
-    /** Gets the array of movie objects.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the array of movie objects.
-        */
-    public ArrayList getObjects()  { return objects; }
+		if (super.equals(anObject))
+		{
+			FSDefineMovieClip typedObject = (FSDefineMovieClip) anObject;
 
-    /** Sets the array of movie objects.
+			if (objects != null)
+				result = objects.equals(typedObject.objects);
+			else
+				result = objects == typedObject.objects;
+		}
+		return result;
+	}
 
-        @param anArray the array of movie objects.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Gets the total number of frames in the movie clip.
+		buffer.append(&quot;FSDefineMovieClip: { &quot;);
+		buffer.append(&quot;objects = &quot;).append(objects.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @return the number of frames.
-        */
-    public int getFrameCount()
-    {
-        return numberOfFrames();
-    }
+		return buffer.toString();
+	}
 
-    public Object clone()
-    {
-        FSDefineMovieClip anObject = (FSDefineMovieClip)super.clone();
-        
-        anObject.objects = new ArrayList();
-            
-        for (Iterator i = objects.iterator(); i.hasNext();)
-            anObject.objects.add(((FSMovieObject)i.next()).clone());
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		
+		length += 4;
+		length += FSMovieObject.length(coder, objects);
+		
+		return length;
+	}
 
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineMovieClip typedObject = (FSDefineMovieClip)anObject;
-            
-            if (objects != null)
-                result = objects.equals(typedObject.objects);
-            else
-                result = objects == typedObject.objects;
-        }
-        return result;
-    }
+		coder.writeWord(numberOfFrames(), 2);
+		FSMovieObject.encode(coder, objects);
+		coder.writeWord(0, 2);
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-            
-        length += 4;
-    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
-            
-            int objectLength = object.length(coder);
-            
-            length += (object.getExtendLength() || objectLength &gt;= 63) ? objectLength+6 : objectLength+2;
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(numberOfFrames(), 2);        
-        FSMovie.encodeObjects(coder, objects);
-        coder.writeWord(0, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+		/* frameCount */coder.readWord(2, false);
 
-        /* frameCount */ coder.readWord(2, false);
-    
-        objects = new ArrayList();
+		objects = new ArrayList();
 
-        FSMovieObject object = null; 
-        
-        while ((object = FSMovie.decodeObject(coder)) != null)
-        {
-            objects.add(object);
-        }
+		FSMovieObject object = null;
 
-        coder.endObject(name());
-    }
-    
-    private int numberOfFrames() 
-    {
-        int numberOfFrames = 0;
-        
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject currentObject = (FSMovieObject)i.next();
-            
-            if (currentObject.getType() == FSMovieObject.ShowFrame)
-                numberOfFrames += 1;
-        }
-        return numberOfFrames;
-    }
+		while ((object = FSMovieObject.decodeObject(coder)) != null)
+		{
+			objects.add(object);
+		}
+	}
+
+	private int numberOfFrames()
+	{
+		int numberOfFrames = 0;
+
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject currentObject = (FSMovieObject) i.next();
+
+			if (currentObject.getType() == FSMovieObject.ShowFrame)
+				numberOfFrames += 1;
+		}
+		return numberOfFrames;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,77 +31,77 @@
 package com.flagstone.transform;
 
 /**
-The FSDefineObject is a base class for the different types of object used to 
-create images, buttons, shapes and sounds. Each such object contains a unique 
-identifier that is used to reference the object when performing operations 
-such as placing it in the display list using the FSPlaceObject class, etc. 
-The FSDefineObject manages the encoding and decoding of this identifier.
-
-Identifiers are unique within a given movie. The FSMovie class is maintains an 
-internal counter which is used to generate the identifiers that are assigned 
-to classes derived from FSDefineObject.
-
-Two accessor methods, getIdentifier() and setIdentifier() are used to retrieve 
-and update the unique identifier assigned to an object.
-*/
+ * The FSDefineObject is a base class for the different types of object used to
+ * create images, buttons, shapes and sounds. Each such object contains a unique
+ * identifier that is used to reference the object when performing operations
+ * such as placing it in the display list using the FSPlaceObject class, etc.
+ * The FSDefineObject manages the encoding and decoding of this identifier.
+ * 
+ * Identifiers are unique within a given movie. The FSMovie class is maintains
+ * an internal counter which is used to generate the identifiers that are
+ * assigned to classes derived from FSDefineObject.
+ * 
+ * Two accessor methods, getIdentifier() and setIdentifier() are used to
+ * retrieve and update the unique identifier assigned to an object.
+ */
 public abstract class FSDefineObject extends FSMovieObject
 {
-    protected int identifier = 0; 
-    
-    FSDefineObject(int type, int anIdentifier)
-    {
-        super(type);
-        setIdentifier(anIdentifier);
-    }
-    protected FSDefineObject(FSDefineObject obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-    }
-    
-    /** Returns the unique identifier assigned to this Define tag. 
+	protected int identifier = 0;
 
-        @return the unique identifier for the object.
-        */     
-    public int getIdentifier() 
-    {
-        return identifier;
-    }
+	FSDefineObject(int type, int anIdentifier)
+	{
+		super(type);
+		setIdentifier(anIdentifier);
+	}
 
-    /** Sets the identifier used to uniquely identify the object within a given FSMovie.
+	protected FSDefineObject(FSDefineObject obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+	}
 
-        @param anIdentifier a unique identifier for the object. 
-        */     
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        Transform.append(buffer, &quot;identifier&quot;, identifier);
-    }
+	/**
+	 * Returns the unique identifier assigned to this Define tag.
+	 * 
+	 * @return the unique identifier for the object.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-    }
+	/**
+	 * Sets the identifier used to uniquely identify the object within a given
+	 * FSMovie.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for the object.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 2;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(identifier, 2);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		identifier = coder.readWord(2, false);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineShape.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineShape.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineShape.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,411 +33,472 @@
 import java.util.*;
 
 /**
-FSDefineShape defines a shape to be displayed.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSDefineShape defines a shape to be displayed.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The shape defines a path containing a mix of straight and curved edges and
+ * pen move actions. A path need not be contiguous. When the shape is drawn the
+ * FSShapeStyle object selects the line and fill styles, from the respective
+ * array, to be used. FSShapeStyle objects can be defined in the shape at any
+ * time to change the styles being used. The fill style used can either be a
+ * solid colour, a bitmap image or a gradient. The line style specifies the
+ * colour and thickness of the line drawn around the shape outline.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For both line and fill styles the selected style may be undefined, allowing
+ * the shape to be drawn without an outline or left unfilled.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This example creates a simple rectangle, 200 twips wide and 100 twips high,
+ * drawing using a black outline 1 twip wide and filled with a solid red colour.
+ * The origin of the shape is at the bottom left corner of the rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. The values also specify
+ * // the coordinate range of the shape.
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, 200, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+ * 
+ * lineStyles.add(new FSLineStyle(1, new FSColor(0, 0, 0)));
+ * 
+ * // Draw the shape.
+ * 
+ * FSShape shape = new FSShape();
+ * 
+ * // Define the line, fill styles and move to the shape's origin.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(200, 0));
+ * shape.add(new FSLine(0, 100));
+ * shape.add(new FSLine(-200, 0));
+ * shape.add(new FSLine(0, -100));
+ * 
+ * FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineShape class represents the DefineShape tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineShape extends FSDefineObject
+{
+	private FSBounds bounds = null;
 
-&lt;tr&gt;
-&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
-&lt;/tr&gt;
+	private ArrayList fillStyles = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private ArrayList lineStyles = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	private FSShape shape = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineShape object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineShape(FSCoder coder)
+	{
+		super(FSMovieObject.DefineShape, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_3&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the shape in the range 1..65535.
+	 * @param aBounds
+	 *            the bounding rectangle for the shape.
+	 * @param fillStyleArray
+	 *            the array of fill styles used in the shape.
+	 * @param lineStyleArray
+	 *            the array of line styles used in the shape.
+	 * @param aShape
+	 *            the shape to be drawn.
+	 */
+	public FSDefineShape(int anIdentifier, FSBounds aBounds,
+							ArrayList fillStyleArray, ArrayList lineStyleArray,
+							FSShape aShape)
+	{
+		super(FSMovieObject.DefineShape, anIdentifier);
+		setBounds(aBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setShape(aShape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_4&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineShape(FSDefineShape obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_5&quot;&gt;shape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle 
-objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
-&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;/table&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;p&gt;The shape defines a path containing a mix of straight and curved edges and pen move actions. A path need not be contiguous. When the shape is drawn the FSShapeStyle object selects the line and fill styles, from the respective array, to be used. FSShapeStyle objects can be defined in the shape at any time to change the styles being used. The fill style used can either be a solid colour, a bitmap image or a gradient. The line style specifies the colour and thickness of the line drawn around the shape outline.&lt;/p&gt;
+		lineStyles = new ArrayList();
 
-&lt;p&gt;For both line and fill styles the selected style may be undefined, allowing the shape to be drawn without an outline or left unfilled.&lt;/p&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		shape = new FSShape(obj.shape);
+	}
 
-&lt;p&gt;This example creates a simple rectangle, 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a solid red colour. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Add a FSLineStyle object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSLineStyle object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. The values also specify
-// the coordinate range of the shape.
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-FSBounds bounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Gets the bounding rectangle for the shape.
+	 * 
+	 * @return the bounding rectangle for the shape.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Gets the array fill styles.
+	 * 
+	 * @return the fill styles used in the shape.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Gets the array line styles.
+	 * 
+	 * @return the line styles used in the shape.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+	/**
+	 * Gets the shape.
+	 * 
+	 * @return the shape to be drawn.
+	 */
+	public FSShape getShape()
+	{
+		return shape;
+	}
 
-lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0)));
+	/**
+	 * Sets the bounding rectangle.
+	 * 
+	 * @param aBounds
+	 *            set the bounding rectangle for the shape.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-// Draw the shape.
+	/**
+	 * Sets the fill styles.
+	 * 
+	 * @param anArray
+	 *            set the fill styles for the shape.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-FSShape shape = new FSShape();
+	/**
+	 * Sets the line styles.
+	 * 
+	 * @param anArray
+	 *            set the line styles for the shape.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-// Define the line, fill styles and move to the shape's origin.
+	/**
+	 * Sets the shape.
+	 * 
+	 * @param aShape
+	 *            set the shape to be drawn.
+	 */
+	public void setShape(FSShape aShape)
+	{
+		shape = aShape;
+	}
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(200,0));
-shape.add(new FSLine(0,100));
-shape.add(new FSLine(-200,0));
-shape.add(new FSLine(0,-100));
+	public Object clone()
+	{
+		FSDefineShape anObject = (FSDefineShape) super.clone();
 
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
-&lt;/pre&gt;
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.fillStyles = new ArrayList();
 
-&lt;p&gt;The FSDefineShape class represents the DefineShape tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineShape extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape shape = null;
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-    /**
-     * Construct an FSDefineShape object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineShape(FSCoder coder)
-    {
-        super(FSMovieObject.DefineShape, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineShape object.
+		anObject.lineStyles = new ArrayList();
 
-        @param anIdentifier the unique identifier for the shape in the range 1..65535.
-        @param aBounds the bounding rectangle for the shape.
-        @param fillStyleArray the array of fill styles used in the shape.
-        @param lineStyleArray the array of line styles used in the shape.
-        @param aShape the shape to be drawn.
-        */
-    public FSDefineShape(int anIdentifier, FSBounds aBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape aShape)
-    {
-        super(FSMovieObject.DefineShape, anIdentifier);
-        setBounds(aBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setShape(aShape);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineShape(FSDefineShape obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+		anObject.shape = (shape != null) ? (FSShape) shape.clone() : null;
 
-        shape = new FSShape(obj.shape);
-    }
-    
-    /** Add a FSSolidLine object to the array of line styles.
+		return anObject;
+	}
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Add the fill style object to the array of fill styles.
+		if (super.equals(anObject))
+		{
+			FSDefineShape typedObject = (FSDefineShape) anObject;
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-    /** Gets the bounding rectangle for the shape.
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-        @return the bounding rectangle for the shape.
-        */
-    public FSBounds getBounds() { return bounds; }
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-    /** Gets the array fill styles.
+			if (shape != null)
+				result = result &amp;&amp; shape.equals(typedObject.shape);
+			else
+				result = result &amp;&amp; shape == typedObject.shape;
+		}
+		return result;
+	}
 
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Gets the array line styles.
+		buffer.append(&quot;FSDefineShape: { &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;fillStyles = &quot;).append(fillStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;lineStyles = &quot;).append(lineStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;shape = &quot;).append(shape.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		return buffer.toString();
+	}
 
-    /** Gets the shape.
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-        @return the shape to be drawn.
-        */
-    public FSShape getShape() { return shape; }
+		super.length(coder);
 
-    /** Sets the bounding rectangle.
+		length += bounds.length(coder);
+		length += 1;
 
-        @param aBounds set the bounding rectangle for the shape.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-    /** Sets the fill styles.
+		length += 1;
 
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-    /** Sets the line styles.
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		length += shape.length(coder);
 
-    /** Sets the shape.
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-        @param aShape set the shape to be drawn.
-        */
-    public void setShape(FSShape aShape)
-    {
-        shape = aShape;
-    }
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSDefineShape anObject = (FSDefineShape)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		super.encode(coder);
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		bounds.encode(coder);
 
-         anObject.shape = (shape != null) ? (FSShape)shape.clone() : null;
-        
-        return anObject;
-    }
+		coder.writeWord(fillStyles.size(), 1);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineShape typedObject = (FSDefineShape)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+		 styleIterator.next().encode(coder);
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		coder.writeWord(lineStyles.size(), 1);
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			styleIterator.next().encode(coder);
 
-            if (shape != null)
-                result = result &amp;&amp; shape.equals(typedObject.shape);
-            else
-                result = result &amp;&amp; shape == typedObject.shape;
-        }
-        return result;
-    }
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;shape&quot;, shape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		shape.encode(coder);
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.length(coder);
-    
-        length += bounds.length(coder);
-        length += 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-        
-        length += 1;
-        
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += shape.length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+	}
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-        bounds.encode(coder);
-        
-        coder.writeWord(fillStyles.size(), 1);
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.writeWord(lineStyles.size(), 1);
+		super.decode(coder);
 
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		int start = coder.getPointer() - 16; // account for identifier
 
-        shape.encode(coder);
+		bounds = new FSBounds(coder);
+		fillStyleCount = coder.readByte();
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		fillStyles = new ArrayList(fillStyleCount);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
-        
-        int start = coder.getPointer()-16; // account for identifier
+		fillStyles = new ArrayList();
 
-        bounds = new FSBounds(coder);
-        fillStyleCount = coder.readWord(1, false);
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        fillStyles = new ArrayList(fillStyleCount);
+		lineStyleCount = coder.readByte();
 
-        fillStyles = new ArrayList();
+		lineStyles = new ArrayList(lineStyleCount);
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }        
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSLineStyle(coder));
 
-        lineStyles = new ArrayList(lineStyleCount);
-        
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSSolidLine(coder));
-        
-        int bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
+		int bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        if (coder.context[FSCoder.DecodeShapes] == 1)
-            shape = new FSShape(coder);
-        else
-            shape = new FSShape(coder, length-bytesDecoded);
-
-        coder.endObject(name());
-    }
+		if (coder.context[FSCoder.DecodeShapes] == 1)
+			shape = new FSShape(coder);
+		else
+			shape = new FSShape(coder, length - bytesDecoded);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineShape2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineShape2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineShape2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,443 +33,503 @@
 import java.util.*;
 
 /**
-FSDefineShape2 defines a shape to be displayed. 
- 
-&lt;p&gt;It extends the functionality of the FSDefineShape class by allowing more than 255 fill or line styles to be specified.&lt;/p&gt;
+ * FSDefineShape2 defines a shape to be displayed.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality of the FSDefineShape class by allowing more than
+ * 255 fill or line styles to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The shape defines a path containing a mix of straight and curved edges and
+ * pen move actions. A path need not be contiguous. When the shape is drawn the
+ * FSShapeStyle object selects the line and fill styles, from the respective
+ * array, to be used. FSShapeStyle objects can be defined in the shape at any
+ * time to change the styles being used. The fill style used can either be a
+ * solid colour, a bitmap image or a gradient. The line style specifies the
+ * colour and thickness of the line drawn around the shape outline. For both
+ * line and fill styles the selected style may be undefined, allowing the shape
+ * to be drawn without an outline or left unfilled.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This example creates a simple rectangle, 200 twips wide and 100 twips high,
+ * drawing using a black outline 1 twip wide and filled with a solid red colour.
+ * The origin of the shape is at the bottom left corner of the rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. The values also specify
+ * // the coordinate range of the shape.
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, 200, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+ * 
+ * lineStyles.add(new FSLineStyle(1, new FSColor(0, 0, 0)));
+ * 
+ * // Draw the shape.
+ * 
+ * FSShape shape = new FSShape();
+ * 
+ * // Define the line, fill styles and move to the shape's origin.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(200, 0));
+ * shape.add(new FSLine(0, 100));
+ * shape.add(new FSLine(-200, 0));
+ * shape.add(new FSLine(0, -100));
+ * 
+ * FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineShape2 class represents the DefineShape2 data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
+ */
+public class FSDefineShape2 extends FSDefineObject
+{
+	private FSBounds bounds = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private ArrayList fillStyles = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private ArrayList lineStyles = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineShape2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private FSShape shape = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineShape2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineShape2(FSCoder coder)
+	{
+		super(DefineShape2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape2 object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the shape.
+	 * @param aBounds
+	 *            the bounding rectangle for the shape.
+	 * @param fillStyleArray
+	 *            the array of fill styles used in the shape.
+	 * @param lineStyleArray
+	 *            the array of line styles used in the shape.
+	 * @param aShape
+	 *            the shape to be drawn.
+	 */
+	public FSDefineShape2(int anIdentifier, FSBounds aBounds,
+							ArrayList fillStyleArray, ArrayList lineStyleArray,
+							FSShape aShape)
+	{
+		super(DefineShape2, anIdentifier);
+		setBounds(aBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setShape(aShape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_3&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineShape2(FSDefineShape2 obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_4&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineShape2_5&quot;&gt;shape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle 
-objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;p&gt;The shape defines a path containing a mix of straight and curved edges and pen 
-move actions. A path need not be contiguous. When the shape is drawn the FSShapeStyle 
-object selects the line and fill styles, from the respective array, to be used. 
-FSShapeStyle objects can be defined in the shape at any time to change the styles 
-being used. The fill style used can either be a solid colour, a bitmap image or a 
-gradient. The line style specifies the colour and thickness of the line drawn around 
-the shape outline. For both line and fill styles the selected style may be undefined, 
-allowing the shape to be drawn without an outline or left unfilled.&lt;/p&gt;
+		lineStyles = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;p&gt;This example creates a simple rectangle, 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a solid red colour. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+		shape = new FSShape(obj.shape);
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. The values also specify
-// the coordinate range of the shape.
+	/**
+	 * Add a FSLineStyle object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSLineStyle object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-FSBounds bounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Gets the bounding rectangle for the shape.
+	 * 
+	 * @return the bounding rectangle for the shape.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Gets the array fill styles.
+	 * 
+	 * @return the fill styles used in the shape.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+	/**
+	 * Gets the array line styles.
+	 * 
+	 * @return the line styles used in the shape.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0)));
+	/**
+	 * Gets the shape.
+	 * 
+	 * @return the shape to be drawn.
+	 */
+	public FSShape getShape()
+	{
+		return shape;
+	}
 
-// Draw the shape.
+	/**
+	 * Sets the bounding rectangle.
+	 * 
+	 * @param aBounds
+	 *            set the bounding rectangle for the shape.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-FSShape shape = new FSShape();
+	/**
+	 * Sets the fill styles.
+	 * 
+	 * @param anArray
+	 *            set the fill styles for the shape.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-// Define the line, fill styles and move to the shape's origin.
+	/**
+	 * Sets the line styles.
+	 * 
+	 * @param anArray
+	 *            set the line styles for the shape.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(200,0));
-shape.add(new FSLine(0,100));
-shape.add(new FSLine(-200,0));
-shape.add(new FSLine(0,-100));
+	/**
+	 * Sets the shape.
+	 * 
+	 * @param aShape
+	 *            set the shape to be drawn.
+	 */
+	public void setShape(FSShape aShape)
+	{
+		shape = aShape;
+	}
 
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
-&lt;/pre&gt;
+	public Object clone()
+	{
+		FSDefineShape2 anObject = (FSDefineShape2) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
 
-&lt;p&gt;The FSDefineShape2 class represents the DefineShape2 data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSDefineShape2 extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape shape = null;
+		anObject.fillStyles = new ArrayList();
 
-    /**
-     * Construct an FSDefineShape2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineShape2(FSCoder coder)
-    {
-        super(DefineShape2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineShape2 object.
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-        @param anIdentifier the unique identifier for the shape.
-        @param aBounds the bounding rectangle for the shape.
-        @param fillStyleArray the array of fill styles used in the shape.
-        @param lineStyleArray the array of line styles used in the shape.
-        @param aShape the shape to be drawn.
-    */
-    public FSDefineShape2(int anIdentifier, FSBounds aBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape aShape)
-    {
-        super(DefineShape2, anIdentifier);
-        setBounds(aBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setShape(aShape);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineShape2(FSDefineShape2 obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+		anObject.lineStyles = new ArrayList();
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-        shape = new FSShape(obj.shape);
-    }
-    
-    /** Add a FSSolidLine object to the array of line styles.
+		anObject.shape = (shape != null) ? (FSShape) shape.clone() : null;
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+		return anObject;
+	}
 
-    /** Add the fill style object to the array of fill styles.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineShape2 typedObject = (FSDefineShape2) anObject;
 
-    /** Gets the bounding rectangle for the shape.
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-        @return the bounding rectangle for the shape.
-        */
-    public FSBounds getBounds() { return bounds; }
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-    /** Gets the array fill styles.
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+			if (shape != null)
+				result = result &amp;&amp; shape.equals(typedObject.shape);
+			else
+				result = result &amp;&amp; shape == typedObject.shape;
+		}
+		return result;
+	}
 
-    /** Gets the array line styles.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		buffer.append(&quot;FSDefineShape2: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;fillStyles = &quot;).append(fillStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;lineStyles = &quot;).append(lineStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;shape = &quot;).append(shape.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Gets the shape.
+		return buffer.toString();
+	}
 
-        @return the shape to be drawn.
-        */
-    public FSShape getShape() { return shape; }
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Sets the bounding rectangle.
+		super.length(coder);
 
-        @param aBounds set the bounding rectangle for the shape.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		length += bounds.length(coder);
+		length += (fillStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Sets the fill styles.
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		length += (lineStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Sets the line styles.
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    /** Sets the shape.
+		length += shape.length(coder);
 
-        @param aShape set the shape to be drawn.
-        */
-    public void setShape(FSShape aShape)
-    {
-        shape = aShape;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    public Object clone()
-    {
-        FSDefineShape2 anObject = (FSDefineShape2)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
+		return length;
+	}
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		super.encode(coder);
 
-         anObject.shape = (shape != null) ? (FSShape)shape.clone() : null;
-        
-        return anObject;
-    }
+		bounds.encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineShape2 typedObject = (FSDefineShape2)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		if (fillStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(fillStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(fillStyles.size(), 1);
+		}
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			styleIterator.next().encode(coder);
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		if (lineStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(lineStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(lineStyles.size(), 1);
+		}
 
-            if (shape != null)
-                result = result &amp;&amp; shape.equals(typedObject.shape);
-            else
-                result = result &amp;&amp; shape == typedObject.shape;
-        }
-        return result;
-    }
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			styleIterator.next().encode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;shape&quot;, shape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.length(coder);
-    
-        length += bounds.length(coder);
-        length += (fillStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-        
-        length += (lineStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += shape.length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		shape.encode(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+	}
 
-        bounds.encode(coder);
-        
-        if (fillStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(fillStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(fillStyles.size(), 1);
-        }
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        if (lineStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(lineStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(lineStyles.size(), 1);
-        }
-                    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-        shape.encode(coder);
+		super.decode(coder);
 
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		int start = coder.getPointer() - 16; // account for identifier
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
+		bounds = new FSBounds(coder);
+		fillStyleCount = coder.readByte();
 
-        int start = coder.getPointer()-16; // account for identifier
+		if (fillStyleCount == 0xFF)
+			fillStyleCount = coder.readWord(2, false);
 
-        bounds = new FSBounds(coder);
-        fillStyleCount = coder.readWord(1, false);
+		fillStyles = new ArrayList(fillStyleCount);
 
-        if (fillStyleCount == 0xFF)
-            fillStyleCount = coder.readWord(2, false);
-            
-        fillStyles = new ArrayList(fillStyleCount);
+		fillStyles = new ArrayList();
 
-        fillStyles = new ArrayList();
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }        
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
+		lineStyleCount = coder.readByte();
 
-        if (lineStyleCount == 0xFF)
-            lineStyleCount = coder.readWord(2, false);
+		if (lineStyleCount == 0xFF)
+			lineStyleCount = coder.readWord(2, false);
 
-        lineStyles = new ArrayList(lineStyleCount);
-        
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSSolidLine(coder));
+		lineStyles = new ArrayList(lineStyleCount);
 
-        coder.context[FSCoder.ArrayCountExtended] = 1;
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSLineStyle(coder));
 
-        int bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
 
-        if (coder.context[FSCoder.DecodeShapes] == 1)
-            shape = new FSShape(coder);
-        else
-            shape = new FSShape(coder, length-bytesDecoded);
+		int bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        coder.context[FSCoder.ArrayCountExtended] = 0;
+		if (coder.context[FSCoder.DecodeShapes] == 1)
+			shape = new FSShape(coder);
+		else
+			shape = new FSShape(coder, length - bytesDecoded);
 
-        coder.endObject(name());
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineShape3.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineShape3.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineShape3.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,447 +33,514 @@
 import java.util.*;
 
 /**
-FSDefineShape3 defines a transparent shape to be displayed. 
+ * FSDefineShape3 defines a transparent shape to be displayed.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality of the FSDefineShape2 class by supporting
+ * transparent colours.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The shape defines a path containing a mix of straight and curved edges and
+ * pen move actions. A path need not be contiguous. When the shape is drawn the
+ * FSShapeStyle object selects the line and fill styles, from the respective
+ * array, to be used. FSShapeStyle objects can be defined in the shape at any
+ * time to change the styles being used. The fill style used can either be an
+ * area of pure colour, a bitmap image or a gradient. The line style specifies
+ * the colour and thickness of the line drawn around the shape outline. For both
+ * line and fill styles the selected style may be undefined, allowing the shape
+ * to be drawn without an outline or left unfilled.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This example creates a simple rectangle, 200 twips wide and 100 twips high,
+ * drawing using a black outline 1 twip wide and filled with a transparent red
+ * colour. The origin of the shape is at the bottom left corner of the
+ * rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. The values also specify
+ * // the coordinate range of the shape.
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, 200, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0, 128)));
+ * 
+ * lineStyles.add(new FSLineStyle(1, new FSColor(0, 0, 0, 128)));
+ * 
+ * // Draw the shape.
+ * 
+ * FSShape shape = new FSShape();
+ * 
+ * // Define the line, fill styles and move to the shape's origin.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(200, 0));
+ * shape.add(new FSLine(0, 100));
+ * shape.add(new FSLine(-200, 0));
+ * shape.add(new FSLine(0, -100));
+ * 
+ * FSDefineShape3 shape = new FSDefineShape3(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineShape3 class represents the DefineShape3 tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineShape3 extends FSDefineObject
+{
+	private FSBounds bounds = null;
 
-&lt;p&gt;It extends the functionality of the FSDefineShape2 class by supporting transparent colours.&lt;/p&gt;
+	private ArrayList fillStyles = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private ArrayList lineStyles = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private FSShape shape = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineShape3_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineShape3 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineShape3(FSCoder coder)
+	{
+		super(DefineShape3, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape3 object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the shape.
+	 * @param aBounds
+	 *            the bounding rectangle for the shape.
+	 * @param fillStyleArray
+	 *            the array of fill styles used in the shape.
+	 * @param lineStyleArray
+	 *            the array of line styles used in the shape.
+	 * @param aShape
+	 *            the shape to be drawn.
+	 */
+	public FSDefineShape3(int anIdentifier, FSBounds aBounds,
+							ArrayList fillStyleArray, ArrayList lineStyleArray,
+							FSShape aShape)
+	{
+		super(DefineShape3, anIdentifier);
+		setBounds(aBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setShape(aShape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineShape3(FSDefineShape3 obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_3&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_4&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_5&quot;&gt;shape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		lineStyles = new ArrayList();
 
-&lt;p&gt;The shape defines a path containing a mix of straight and curved edges and pen move actions. A path need not be contiguous. When the shape is drawn the FSShapeStyle object selects the line and fill styles, from the respective array, to be used. FSShapeStyle objects can be defined in the shape at any time to change the styles being used. The fill style used can either be an area of pure colour, a bitmap image or a gradient. The line style specifies the colour and thickness of the line drawn around the shape outline. For both line and fill styles the selected style may be undefined, allowing the shape to be drawn without an outline or left unfilled.&lt;/p&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		shape = new FSShape(obj.shape);
+	}
 
-&lt;p&gt;This example creates a simple rectangle, 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a transparent red colour. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Add a FSLineStyle object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSLineStyle object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. The values also specify
-// the coordinate range of the shape.
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-FSBounds bounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Gets the bounding rectangle for the shape.
+	 * 
+	 * @return the bounding rectangle for the shape.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Gets the array fill styles.
+	 * 
+	 * @return the fill styles used in the shape.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Gets the array line styles.
+	 * 
+	 * @return the line styles used in the shape.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0, 128)));
+	/**
+	 * Gets the shape.
+	 * 
+	 * @return the shape to be drawn.
+	 */
+	public FSShape getShape()
+	{
+		return shape;
+	}
 
-lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0, 128)));
+	/**
+	 * Sets the bounding rectangle.
+	 * 
+	 * @param aBounds
+	 *            set the bounding rectangle for the shape.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-// Draw the shape.
+	/**
+	 * Sets the fill styles.
+	 * 
+	 * @param anArray
+	 *            set the fill styles for the shape.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-FSShape shape = new FSShape();
+	/**
+	 * Sets the line styles.
+	 * 
+	 * @param anArray
+	 *            set the line styles for the shape.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-// Define the line, fill styles and move to the shape's origin.
+	/**
+	 * Sets the shape.
+	 * 
+	 * @param aShape
+	 *            set the shape to be drawn.
+	 */
+	public void setShape(FSShape aShape)
+	{
+		shape = aShape;
+	}
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(200,0));
-shape.add(new FSLine(0,100));
-shape.add(new FSLine(-200,0));
-shape.add(new FSLine(0,-100));
+	public Object clone()
+	{
+		FSDefineShape3 anObject = (FSDefineShape3) super.clone();
 
-FSDefineShape3 shape = new FSDefineShape3(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
-&lt;/pre&gt;
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.fillStyles = new ArrayList();
 
-&lt;p&gt;The FSDefineShape3 class represents the DefineShape3 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineShape3 extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape shape = null;
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-    /**
-     * Construct an FSDefineShape3 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineShape3(FSCoder coder)
-    {
-        super(DefineShape3, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineShape3 object.
+		anObject.lineStyles = new ArrayList();
 
-        @param anIdentifier the unique identifier for the shape.
-        @param aBounds the bounding rectangle for the shape.
-        @param fillStyleArray the array of fill styles used in the shape.
-        @param lineStyleArray the array of line styles used in the shape.
-        @param aShape the shape to be drawn.
-        */
-    public FSDefineShape3(int anIdentifier, FSBounds aBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape aShape)
-    {
-        super(DefineShape3, anIdentifier);
-        setBounds(aBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setShape(aShape);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineShape3(FSDefineShape3 obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+		anObject.shape = (shape != null) ? (FSShape) shape.clone() : null;
 
-        shape = new FSShape(obj.shape);
-    }
+		return anObject;
+	}
 
-    /** Add a FSSolidLine object to the array of line styles.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineShape3 typedObject = (FSDefineShape3) anObject;
 
-    /** Add the fill style object to the array of fill styles.
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-    /** Gets the bounding rectangle for the shape.
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-        @return the bounding rectangle for the shape.
-        */
-    public FSBounds getBounds() { return bounds; }
+			if (shape != null)
+				result = result &amp;&amp; shape.equals(typedObject.shape);
+			else
+				result = result &amp;&amp; shape == typedObject.shape;
+		}
+		return result;
+	}
 
-    /** Gets the array fill styles.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+		buffer.append(&quot;FSDefineShape3: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;fillStyles = &quot;).append(fillStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;lineStyles = &quot;).append(lineStyles.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;shape = &quot;).append(shape.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Gets the array line styles.
+		return buffer.toString();
+	}
 
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Gets the shape.
+		super.length(coder);
 
-        @return the shape to be drawn.
-        */
-    public FSShape getShape() { return shape; }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Sets the bounding rectangle.
+		length += bounds.length(coder);
 
-        @param aBounds set the bounding rectangle for the shape.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		length += (fillStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Sets the fill styles.
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		length += (lineStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Sets the line styles.
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += styleIterator.next().length(coder);
 
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    /** Sets the shape.
+		length += shape.length(coder);
 
-        @param aShape set the shape to be drawn.
-        */
-    public void setShape(FSShape aShape)
-    {
-        shape = aShape;
-    }
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    public Object clone()
-    {
-        FSDefineShape3 anObject = (FSDefineShape3)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		return length;
+	}
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-         anObject.shape = (shape != null) ? (FSShape)shape.clone() : null;
-        
-        return anObject;
-    }
+		super.encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineShape3 typedObject = (FSDefineShape3)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		bounds.encode(coder);
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		if (fillStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(fillStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(fillStyles.size(), 1);
+		}
 
-            if (shape != null)
-                result = result &amp;&amp; shape.equals(typedObject.shape);
-            else
-                result = result &amp;&amp; shape == typedObject.shape;
-        }
-        return result;
-    }
+		for (Iterator&lt;FSFillStyle&gt; styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			styleIterator.next().encode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;shape&quot;, shape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (lineStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(lineStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(lineStyles.size(), 1);
+		}
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
+		for (Iterator&lt;FSLineStyle&gt; styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			styleIterator.next().encode(coder);
 
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-        length += bounds.length(coder);
+		shape.encode(coder);
 
-        length += (fillStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-        
-        length += (lineStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += shape.length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.ArrayCountExtended] = 0;
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
+		super.decode(coder);
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		int start = coder.getPointer() - 16; // account for identifier
 
-        bounds.encode(coder);
-        
-        if (fillStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(fillStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(fillStyles.size(), 1);
-        }
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-       if (lineStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(lineStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(lineStyles.size(), 1);
-        }
-                
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        shape.encode(coder);
+		bounds = new FSBounds(coder);
+		fillStyleCount = coder.readByte();
 
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.TransparentColors] = 0;
+		if (fillStyleCount == 0xFF)
+			fillStyleCount = coder.readWord(2, false);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
+		fillStyles = new ArrayList(fillStyleCount);
 
-        int start = coder.getPointer()-16; // account for identifier
+		fillStyles = new ArrayList();
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        bounds = new FSBounds(coder);
-        fillStyleCount = coder.readWord(1, false);
+		lineStyleCount = coder.readByte();
 
-        if (fillStyleCount == 0xFF)
-            fillStyleCount = coder.readWord(2, false);
-            
-        fillStyles = new ArrayList(fillStyleCount);
+		if (lineStyleCount == 0xFF)
+			lineStyleCount = coder.readWord(2, false);
 
-        fillStyles = new ArrayList();
+		lineStyles = new ArrayList(lineStyleCount);
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }        
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSLineStyle(coder));
 
-        if (lineStyleCount == 0xFF)
-            lineStyleCount = coder.readWord(2, false);
+		coder.context[FSCoder.ArrayCountExtended] = 1;
 
-        lineStyles = new ArrayList(lineStyleCount);
-        
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSSolidLine(coder));
+		int bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        coder.context[FSCoder.ArrayCountExtended] = 1;
+		if (coder.context[FSCoder.DecodeShapes] == 1)
+			shape = new FSShape(coder);
+		else
+			shape = new FSShape(coder, length - bytesDecoded);
 
-        int bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
-
-        if (coder.context[FSCoder.DecodeShapes] == 1)
-            shape = new FSShape(coder);
-        else
-            shape = new FSShape(coder, length-bytesDecoded);
-
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-
-        coder.endObject(name());
-    }
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineSound.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineSound.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineSound.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -34,365 +34,446 @@
 import java.util.Iterator;
 
 /**
-FSDefineSound is used to define a sound that will be played when a given event occurs. 
+ * FSDefineSound is used to define a sound that will be played when a given
+ * event occurs.
+ * 
+ * &lt;p&gt;
+ * Three different types of object are used to play an event sound:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The FSDefineSound object that contains the sampled sound.&lt;/li&gt;
+ * &lt;li&gt;A FSSound object that defines how the sound fades in and out, whether it
+ * repeats and also defines an envelope for more sophisticated control over how
+ * the sound is played.&lt;/li&gt;
+ * &lt;li&gt;A FSStartSound object that signals the Flash Player to begin playing the
+ * sound.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * An FSDefineSound object contains the following attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt; format&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The format of the sound data - FSSound.NATIVE_PCM, FSSound.ADPCM,
+ * FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackRate&lt;/td&gt;
+ * &lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackChannels&lt;/td&gt;
+ * &lt;td&gt;The number of channels in the sound, typically 1 (mono) or 2 (stereo).&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackSampleSize&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in a sample: 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sampleCount&lt;/td&gt;
+ * &lt;td&gt;The number of samples in the sound.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;soundLength&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in the sound data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound&lt;/td&gt;
+ * &lt;td&gt;The encoded sound data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Five encoded formats for the sound data are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or
+ * 2 bytes. For two-byte samples the byte order is dependent on the platform on
+ * which the Flash Player is hosted. Sounds created on a platform which supports
+ * big-endian byte order will not be played correctly when listened to on a
+ * platform which supports little-endian byte order.&lt;/li&gt;
+ * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes
+ * with the latter presented in Little-Endian byte order. This ensures that
+ * sounds can be played across different platforms.&lt;/li&gt;
+ * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded
+ * and compressed by comparing the difference between successive sound sample
+ * which dramatically reduces the size of the encoded sound when compared to the
+ * uncompressed PCM formats. Use this format whenever possible.&lt;/li&gt;
+ * &lt;li&gt;MP3 - compressed MPEG Audio Layer-3.&lt;/li&gt;
+ * &lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate
+ * sound for improving synchronisation between the sound and frame rate of
+ * movies.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * Constants representing the different formats are defined in the FSSound
+ * class.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineSound class represents the DefineSound structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1. Flash 3 added support for MP3 and the Nellymoser Asao format was added in
+ * Flash 6.
+ * &lt;/p&gt;
+ */
+public class FSDefineSound extends FSDefineObject
+{
+	private int format = 0;
 
-&lt;p&gt;Three different types of object are used to play an event sound:&lt;/p&gt;
+	private int playbackRate = 5512;
 
-&lt;ul&gt;
-&lt;li&gt;The FSDefineSound object that contains the sampled sound.&lt;/li&gt;
-&lt;li&gt;A FSSound object that defines how the sound fades in and out, whether it repeats and also defines an envelope for more sophisticated control over how the sound is played.&lt;/li&gt;
-&lt;li&gt;A FSStartSound object that signals the Flash Player to begin playing the sound.&lt;/li&gt;
-&lt;/ul&gt;
+	private int playbackChannels = 1;
 
-&lt;p&gt;An FSDefineSound object contains the following attributes:&lt;/p&gt;
+	private int playbackSampleSize = 1;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int sampleCount = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private byte[] soundData = null;
 
+	/**
+	 * Construct an FSDefineSound object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineSound(FSCoder coder)
+	{
+		super(FSMovieObject.DefineSound, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineSound_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineSound object specifying the unique identifier and
+	 * all the parameters required to describe the sound.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this sound.
+	 * @param aFormat
+	 *            the encoding format for the sound. For Flash 1 the formats may
+	 *            be FSSound.NATIVE_PCM, FSSound.PCM or FSSound.ADPCM. For Flash
+	 *            4 or later include FSSound.MP3 and Flash 6 or later include
+	 *            FSSound.NELLYMOSER.
+	 * @param rate
+	 *            the number of samples per second that the sound is played at ,
+	 *            either 5512, 11025, 22050 or 44100.
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 * @param sampleSize
+	 *            the size of an uncompressed sound sample in bits, either 8 or
+	 *            16.
+	 * @param count
+	 *            the number of samples in the sound data.
+	 * @param bytes
+	 *            the sound data.
+	 */
+	public FSDefineSound(int anIdentifier, int aFormat, int rate, int channels,
+							int sampleSize, int count, byte[] bytes)
+	{
+		super(FSMovieObject.DefineSound, anIdentifier);
+		setFormat(aFormat);
+		setPlaybackRate(rate);
+		setPlaybackChannels(channels);
+		setPlaybackSampleSize(sampleSize);
+		setSampleCount(count);
+		setSoundData(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineSound object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineSound object.
+	 */
+	public FSDefineSound(FSDefineSound obj)
+	{
+		super(obj);
+		format = obj.format;
+		playbackRate = obj.playbackRate;
+		playbackChannels = obj.playbackChannels;
+		playbackSampleSize = obj.playbackSampleSize;
+		sampleCount = obj.sampleCount;
+		soundData = Transform.clone(obj.soundData);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;
-&lt;a name=&quot;FSDefineSound_2&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The format of the sound data - FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER&lt;/td&gt;&lt;/tr&gt;
+	/**
+	 * Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM
+	 * or FSSound.ADPCM (all Flash 1), FSSound.MP3 (Flash 4+) or
+	 * FSSound.NELLYMOSER (Flash 6+).
+	 * 
+	 * @return a constant defining the type of compression.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_3&quot;&gt;playbackRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the rate at which the sound will be played, in Hz: 5512, 11025,
+	 * 22050 or 44100.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_4&quot;&gt;playbackChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of channels in the sound, typically 1 (mono) or 2 (stereo).&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
+	 * 
+	 * @return the number of channels.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_5&quot;&gt;playbackSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in a sample: 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the size of an uncompressed sample in bytes.
+	 * 
+	 * @return the number of bytes per sample when the sound is uncompressed.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_6&quot;&gt;sampleCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of samples in the sound.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the number of samples in the sound data.
+	 * 
+	 * @return the number of sound samples.
+	 */
+	public int getSampleCount()
+	{
+		return sampleCount;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_7&quot;&gt;soundLength&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in the sound data.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the sound data.
+	 * 
+	 * @return an array of bytes containing the sampled sound.
+	 */
+	public byte[] getSoundData()
+	{
+		return soundData;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_8&quot;&gt;sound&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded sound data.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the compression format used, either FSSound.NATIVE_PCM,
+	 * FSSound.ADPCM or FSSound.PCM from Flash 1 onwards, FSSound.MP3 from Flash
+	 * 4 onwards, or FSSound.NELLYMOSER from Flash 6 onwards.
+	 * 
+	 * @param encoding
+	 *            the format for the sound.
+	 */
+	public void setFormat(int encoding)
+	{
+		format = encoding;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or
+	 * 44100.
+	 * 
+	 * @param rate
+	 *            the rate at which the sounds is played in Hz.
+	 */
+	public void setPlaybackRate(int rate)
+	{
+		playbackRate = rate;
+	}
 
-&lt;p&gt;Five encoded formats for the sound data are supported:&lt;/p&gt;
+	/**
+	 * Sets the number of channels defined in the sound.
+	 * 
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 */
+	public void setPlaybackChannels(int channels)
+	{
+		playbackChannels = channels;
+	}
 
-&lt;ul&gt;
-&lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes. For two-byte samples the byte order is dependent on the platform on which the Flash Player is hosted. Sounds created on a platform which supports big-endian byte order will not be played correctly when listened to on a platform which supports little-endian byte order.&lt;/li&gt;
-&lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes with 
-the latter presented in Little-Endian byte order. This ensures that sounds can be played across different platforms.&lt;/li&gt;
-&lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded and compressed
-by comparing the difference between successive sound sample which dramatically reduces
-the size of the encoded sound when compared to the uncompressed PCM formats. Use this 
-format whenever possible.&lt;/li&gt;
-&lt;li&gt;MP3 - compressed MPEG Audio Layer-3.&lt;/li&gt;
-&lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate sound for improving synchronisation between the sound and frame rate of movies.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Sets the sample size in bytes. Must be either 1 or 2.
+	 * 
+	 * @param sampleSize
+	 *            the size of sound samples in bytes.
+	 */
+	public void setPlaybackSampleSize(int sampleSize)
+	{
+		playbackSampleSize = sampleSize;
+	}
 
-&lt;p&gt;Constants representing the different formats are defined in the FSSound class.&lt;/p&gt;
+	/**
+	 * Sets the number of samples in the sound data.
+	 * 
+	 * @param count
+	 *            the number of samples for the sound.
+	 */
+	public void setSampleCount(int count)
+	{
+		sampleCount = count;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the sound data.
+	 * 
+	 * @param bytes
+	 *            the sound data.
+	 */
+	public void setSoundData(byte[] bytes)
+	{
+		soundData = bytes;
+	}
 
-&lt;p&gt;The FSDefineSound class represents the DefineSound structure from the Macromedia 
-Flash (SWF) File Format Specification. It was introduced in Flash 1. Flash 3 added 
-support for MP3 and the Nellymoser Asao format was added in Flash 6.&lt;/p&gt;
- */  
-public class FSDefineSound extends FSDefineObject
-{
-    private int format = 0;
-    private int playbackRate = 5512;
-    private int playbackChannels = 1;
-    private int playbackSampleSize = 1;
-    private int sampleCount = 0;
-    private byte[] soundData = null;
+	public Object clone()
+	{
+		FSDefineSound anObject = (FSDefineSound) super.clone();
 
-    /**
-     * Construct an FSDefineSound object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineSound(FSCoder coder)
-    {
-        super(FSMovieObject.DefineSound, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineSound object specifying the unique identifier and all the parameters required to describe the sound.
+		anObject.soundData = Transform.clone(soundData);
 
-        @param anIdentifier the unique identifier for this sound.
-        @param aFormat the encoding format for the sound.  For Flash 1 the formats may be FSSound.NATIVE_PCM, FSSound.PCM or FSSound.ADPCM. For Flash 4 or later include FSSound.MP3 and Flash 6 or later include FSSound.NELLYMOSER.
-        @param rate the number of samples per second that the sound is played at , either 5512, 11025, 22050 or 44100.
-        @param channels the number of channels in the sound, either 1 (Mono) or 2 (Stereo).
-        @param sampleSize the size of an uncompressed sound sample in bits, either 8 or 16.
-        @param count the number of samples in the sound data.
-        @param bytes the sound data.
-        */
-    public FSDefineSound(int anIdentifier, int aFormat, int rate, int channels, int sampleSize, int count, byte[] bytes)
-    {
-        super(FSMovieObject.DefineSound, anIdentifier);
-        setFormat(aFormat);
-        setPlaybackRate(rate);
-        setPlaybackChannels(channels);
-        setPlaybackSampleSize(sampleSize);
-        setSampleCount(count);
-        setSoundData(bytes);
-    }
-    /**
-     * Constructs an FSDefineSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineSound object.
-     */
-    public FSDefineSound(FSDefineSound obj)
-    {
-        super(obj);
-        format = obj.format;
-        playbackRate = obj.playbackRate;
-        playbackChannels = obj.playbackChannels;
-        playbackSampleSize = obj.playbackSampleSize;
-        sampleCount = obj.sampleCount;
-        soundData = Transform.clone(obj.soundData);
-    }
+		return anObject;
+	}
 
-    /**    Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM or FSSound.ADPCM (all Flash 1), FSSound.MP3 (Flash 4+) or FSSound.NELLYMOSER (Flash 6+).
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return a constant defining the type of compression.
-        */
-    public int getFormat() 
-    {
-        return format;
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineSound typedObject = (FSDefineSound) anObject;
 
-    /** Gets the rate at which the sound will be played, in Hz: 5512, 11025, 22050 or 44100.
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result &amp;&amp; sampleCount == typedObject.sampleCount;
+			result = result
+							&amp;&amp; Transform.equals(soundData,
+											typedObject.soundData);
+		}
+		return result;
+	}
 
-     @return the rate at which the sound was sampled.
-     */
-    public int getPlaybackRate()
-    {
-        return playbackRate;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
+		buffer.append(&quot;FSDefineSound: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;format = &quot;).append(format).append(&quot;; &quot;);
+		buffer.append(&quot;playbackRate = &quot;).append(playbackRate).append(&quot;; &quot;);
+		buffer.append(&quot;playbackChannels = &quot;).append(playbackChannels)
+						.append(&quot;; &quot;);
+		buffer.append(&quot;playbackSampleSize = &quot;).append(playbackSampleSize)
+						.append(&quot;; &quot;);
+		buffer.append(&quot;sampleCount = &quot;).append(sampleCount).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-     @return the number of channels.
-     */
-    public int getPlaybackChannels()
-    {
-        return playbackChannels;
-    }
+		return buffer.toString();
+	}
 
-    /** Gets the size of an uncompressed sample in bytes.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @return the number of bytes per sample when the sound is uncompressed.
-        */
-    public int getPlaybackSampleSize() 
-    {
-        return playbackSampleSize;
-    }
+		length += 5;
+		length += soundData.length;
 
-    /** Gets the number of samples in the sound data.
+		return length;
+	}
 
-     @return the number of sound samples.
-     */
-    public int getSampleCount()
-    {
-        return sampleCount;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Gets the sound data.
+		coder.writeBits(format, 4);
 
-     @return an array of bytes containing the sampled sound.
-     */
-    public byte[] getSoundData()
-    {
-        return soundData;
-    }
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
+		coder.writeWord(sampleCount, 4);
 
-    /**    Sets the compression format used, either FSSound.NATIVE_PCM, FSSound.ADPCM or FSSound.PCM from Flash 1 onwards, FSSound.MP3 from Flash 4 onwards, or FSSound.NELLYMOSER from Flash 6 onwards.
+		coder.writeBytes(soundData);
+	}
 
-        @param encoding the format for the sound.
-        */
-    public void setFormat(int encoding)
-    {
-        format = encoding;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    /** Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or 44100.
+		format = coder.readBits(4, false);
 
-        @param rate the rate at which the sounds is played in Hz.
-        */
-    public void setPlaybackRate(int rate)
-    {
-        playbackRate = rate;
-    }
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
 
-    /** Sets the number of channels defined in the sound.
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
+		sampleCount = coder.readWord(4, false);
 
-        @param channels the number of channels in the sound, either 1 (Mono) or 2 (Stereo).
-        */
-    public void setPlaybackChannels(int channels)
-    {
-        playbackChannels = channels;
-    }
-
-    /** Sets the sample size in bytes. Must be either 1 or 2.
-
-        @param sampleSize the size of sound samples in bytes.
-        */
-    public void setPlaybackSampleSize(int sampleSize)
-    {
-        playbackSampleSize = sampleSize;
-    }
-
-    /** Sets the number of samples in the sound data.
-
-     @param count the number of samples for the sound.
-     */
-    public void setSampleCount(int count)
-    {
-        sampleCount = count;
-    }
-
-    /** Sets the sound data.
-
-        @param bytes the sound data.
-        */
-    public void setSoundData(byte[] bytes)
-    {
-        soundData = bytes;
-    }
-
-    public Object clone()
-    {
-        FSDefineSound anObject = (FSDefineSound)super.clone();
-        
-        anObject.soundData = Transform.clone(soundData);
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineSound typedObject = (FSDefineSound)anObject;
-            
-            result = format == typedObject.format;
-            result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-            result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-            result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-            result = result &amp;&amp; sampleCount == typedObject.sampleCount;
-            result = result &amp;&amp; Transform.equals(soundData, typedObject.soundData);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;format&quot;, format);
-            Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-            Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-            Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-            Transform.append(buffer, &quot;sampleCount&quot;, sampleCount);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 5;
-        length += soundData.length;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeBits(format, 4);
-        
-        switch (playbackRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(playbackSampleSize-1, 1);
-        coder.writeBits(playbackChannels-1, 1);
-        coder.writeWord(sampleCount, 4);
-
-        coder.writeBytes(soundData);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        format = coder.readBits(4, false);
-
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                playbackRate = 5512;
-                break;
-            case 1:
-                playbackRate = 11025;
-                break;
-            case 2:
-                playbackRate = 22050;
-                break;
-            case 3:
-                playbackRate = 44100;
-                break;
-        }
-
-        playbackSampleSize = coder.readBits(1, false)+1;
-        playbackChannels = coder.readBits(1, false)+1;
-        sampleCount = coder.readWord(4, false);
-        
-        soundData = new byte[length-7];
-        coder.readBytes(soundData);
-        coder.endObject(name());
-    }
+		soundData = new byte[length - 7];
+		coder.readBytes(soundData);
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineText.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineText.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineText.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,381 +33,453 @@
 import java.util.*;
 
 /**
-FSDefineText defines one or more lines of text.
- 
-&lt;p&gt;The characters, style and layout information is defined using FSText objects. The FSDefineText class acts as a container for the text, defining the bounding rectangle that encloses the text along with a coordinate transform that can be used to change the size and orientation of the text when it is displayed.&lt;/p&gt;
+ * FSDefineText defines one or more lines of text.
+ * 
+ * &lt;p&gt;
+ * The characters, style and layout information is defined using FSText objects.
+ * The FSDefineText class acts as a container for the text, defining the
+ * bounding rectangle that encloses the text along with a coordinate transform
+ * that can be used to change the size and orientation of the text when it is
+ * displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;A coordinate transform describing the placement, size and rotation of
+ * the text block.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSText objects describing the characters to be displayed and
+ * their attributes.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The bounding rectangle and transform controls how the text is laid out. Each
+ * FSText object in the textRecords array specifies an offset from the left and
+ * bottom edges of the bounding rectangle, allowing successive lines of text to
+ * be arranged as a block or paragraph. The coordinate transform can be used to
+ * control the size and orientation of the text when it is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Creating a simple string. The creation and layout of the glyphs to create the
+ * text is too onerous to perform from scratch. It is easier and more convenient
+ * to use existing font definitions either by parsing an existing Flash file or
+ * by converting a font definition from a specification such as TrueType in
+ * order to obtain the glyphs and layout information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * This examples assumes a font definition that contains glyphs for the
+ * following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font
+ * used fixed size for the spacing between glyphs .e.g. Courier.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int fontSize = 240;
+ * int leading = 80;
+ * 
+ * ArrayList characters = new ArrayList();
+ * ArrayList lines = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
+ * // the text is not indented or offset.
+ * 
+ * lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize,
+ * 				characters);
+ * 
+ * // Calculate the bounding rectangle that encloses the text.
+ * // The width of the text by summing all the advances.
+ * 
+ * int width = 0;
+ * int height = fontSize + leading;
+ * 
+ * for (Iterator i = characters.iterator(); i.hasNext();)
+ * 	width += ((FSCharacter) i.next()).getAdvance();
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, width, height);
+ * 
+ * // Define the text with no coordinate transformation (use the default unity transform which leaves
+ * // the text unchanged.
+ * 
+ * FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds,
+ * 				new FSCoordTransform(), lines);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineText class represents the DefineText tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineText extends FSDefineObject
+{
+	private FSBounds bounds = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private FSCoordTransform transform = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private ArrayList objects = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineText object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineText(FSCoder coder)
+	{
+		super(FSMovieObject.DefineText, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText object with the specified bounding rectangle,
+	 * coordinate transform and text records.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object. Must be in the range
+	 *            1..65535
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text. Must not be null.
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text. Must not be null.
+	 * @param array
+	 *            an array of FSText objects that define the text to be
+	 *            displayed. Must not be null.
+	 */
+	public FSDefineText(int anIdentifier, FSBounds aBounds,
+						FSCoordTransform aTransform, ArrayList array)
+	{
+		super(FSMovieObject.DefineText, anIdentifier);
+		setBounds(aBounds);
+		setTransform(aTransform);
+		setObjects(array);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineText object.
+	 */
+	public FSDefineText(FSDefineText obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A coordinate transform describing the placement, size and rotation of the text block.&lt;/td&gt;
-&lt;/tr&gt;
+		objects = new ArrayList(obj.objects.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_4&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSText objects describing the characters to be displayed and their attributes.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		for (Iterator i = obj.objects.iterator(); i.hasNext();)
+			objects.add(((FSText) i.next()).clone());
+	}
 
-&lt;p&gt;The bounding rectangle and transform controls how the text is laid out. Each FSText object in the textRecords array specifies an offset from the left and bottom edges of the bounding rectangle, allowing successive lines of text to be arranged as a block or paragraph. The coordinate transform can be used to control the size and orientation of the text when it is displayed.&lt;/p&gt;
+	/**
+	 * Add a FSText object to the array of text records.
+	 * 
+	 * @param anObject
+	 *            an FSText object.
+	 */
+	public void add(FSText anObject)
+	{
+		objects.add(anObject);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the bounding rectangle that completely encloses the text to be
+	 * displayed.
+	 * 
+	 * @return the bounding rectangle of the text.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;p&gt;Creating a simple string. The creation and layout of the glyphs to create the text is too onerous to perform from scratch. It is easier and more convenient to use existing font definitions either by parsing an existing Flash file or by converting a font definition from a specification such as TrueType in order to obtain the glyphs and layout information.&lt;/p&gt;
+	/**
+	 * Gets the coordinate transform that controls how the text is displayed.
+	 * 
+	 * @return the coordinate transform.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;p&gt;This examples assumes a font definition that contains glyphs for the following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font used fixed size for the spacing between glyphs .e.g. Courier.&lt;/p&gt;
+	/**
+	 * Gets the array of text records that define the text to be displayed as
+	 * its attributes.
+	 * 
+	 * @return the array of text records (FSTextStyle and FSText objects).
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-&lt;pre&gt;
-int fontSize = 240;
-int leading = 80;
+	/**
+	 * Sets the bounding rectangle that encloses the text being displayed.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-ArrayList characters = new ArrayList();
-ArrayList lines = new ArrayList();
+	/**
+	 * Sets the coordinate transform that changes the orientation and size of
+	 * the text displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+	/**
+	 * Sets the array of text records that define the text to be displayed.
+	 * 
+	 * @param anArray
+	 *            an array of FSText objects that define the text to be
+	 *            displayed.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-// Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
-// the text is not indented or offset.
+	public Object clone()
+	{
+		FSDefineText anObject = (FSDefineText) super.clone();
 
-lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize, characters);
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
 
-// Calculate the bounding rectangle that encloses the text.
-// The width of the text by summing all the advances.
+		anObject.objects = new ArrayList(objects.size());
 
-int width = 0;
-int height = fontSize + leading;
+		for (Iterator i = objects.iterator(); i.hasNext();)
+			anObject.objects.add(((FSText) i.next()).clone());
 
-for (Iterator i = characters.iterator(); i.hasNext();)
-    width += ((FSCharacter)i.next()).getAdvance();
+		return anObject;
+	}
 
-FSBounds bounds = new FSBounds(0, 0, width, height);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-// Define the text with no coordinate transformation (use the default unity transform which leaves
-// the text unchanged.
+		if (super.equals(anObject))
+		{
+			FSDefineText typedObject = (FSDefineText) anObject;
 
-FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds, new FSCoordTransform(), lines);
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-&lt;/pre&gt;
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			if (objects != null)
+				result = result &amp;&amp; objects.equals(typedObject.objects);
+			else
+				result = result &amp;&amp; objects == typedObject.objects;
+		}
+		return result;
+	}
 
-&lt;p&gt;The FSDefineText class represents the DefineText tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineText extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private FSCoordTransform transform = null;
-    private ArrayList objects = null;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /**
-     * Construct an FSDefineText object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineText(FSCoder coder)
-    {
-        super(FSMovieObject.DefineText, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineText object with the specified bounding rectangle, coordinate transform and text records.
+		buffer.append(&quot;FSDefineText: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;transform = &quot;).append(transform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;objects = array[&quot;).append(objects.size()).append(&quot;]; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @param anIdentifier the unique identifier for this object. Must be in the range 1..65535
-        @param aBounds the bounding rectangle enclosing the text. Must not be null.
-        @param aTransform an FSCoordTransform to change the size and orientation of 
-        the text. Must not be null.
-        @param array an array of FSText objects that define the text to be displayed.
-        Must not be null.
-        */
-    public FSDefineText(int anIdentifier, FSBounds aBounds, FSCoordTransform aTransform, ArrayList array)
-    {
-        super(FSMovieObject.DefineText, anIdentifier);
-        setBounds(aBounds);
-        setTransform(aTransform);
-        setObjects(array);
-    }
-    /**
-     * Constructs an FSDefineText object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineText object.
-     */
-    public FSDefineText(FSDefineText obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        transform = new FSCoordTransform(obj.transform);
-        
-        objects = new ArrayList(obj.objects.size());
-        
-        for (Iterator i = obj.objects.iterator(); i.hasNext();)
-            objects.add(((FSText)i.next()).clone());
-    }    
+		return buffer.toString();
+	}
 
-    /** Add a FSText object to the array of text records.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anObject an FSText object.
-        */
-    public void add(FSText anObject) { objects.add(anObject); }
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-    /** Gets the bounding rectangle that completely encloses the text to be displayed.
+		length += bounds.length(coder);
+		length += transform.length(coder);
+		length += 2;
 
-        @return the bounding rectangle of the text.
-        */
-    public FSBounds  getBounds() { return bounds; }
+		for (Iterator&lt;FSText&gt; recordIterator = objects.iterator(); recordIterator.hasNext();)
+			length += recordIterator.next().length(coder);
 
-    /** Gets the coordinate transform that controls how the text is displayed.
+		length += 1;
 
-        @return the coordinate transform.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
 
-    /** Gets the array of text records that define the text to be displayed as its attributes.
+		return length;
+	}
 
-        @return the array of text records (FSTextStyle and FSText objects).
-        */
-    public ArrayList getObjects() 
-    {
-        return objects;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the bounding rectangle that encloses the text being displayed.
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-        @param aBounds the bounding rectangle enclosing the text.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		bounds.encode(coder);
+		transform.encode(coder);
 
-    /** Sets the coordinate transform that changes the orientation and size of the text displayed.
+		coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
+		coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
 
-        @param aTransform an FSCoordTransform to change the size and orientation of the text.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+		for (Iterator&lt;FSText&gt; recordIterator = objects.iterator(); recordIterator.hasNext();)
+			recordIterator.next().encode(coder);
 
-    /** Sets the array of text records that define the text to be displayed.
+		coder.writeWord(0, 1);
 
-        @param anArray an array of FSText objects that define the text to be displayed.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+	}
 
-    public Object clone()
-    {
-        FSDefineText anObject = (FSDefineText)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        
-        anObject.objects = new ArrayList(objects.size());
-                    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-            anObject.objects.add(((FSText)i.next()).clone());
+	public void decode(FSCoder coder)
+	{
+		int glyphBits = 0;
+		int advanceBits = 0;
 
-         return anObject;
-    }
+		super.decode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineText typedObject = (FSDefineText)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		// Mark the start of the tag body
 
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
+		/* location */coder.getPointer();
 
-            if (objects != null)
-                result = result &amp;&amp; objects.equals(typedObject.objects);
-            else
-                result = result &amp;&amp; objects == typedObject.objects;
-        }
-        return result;
-    }
+		bounds = new FSBounds(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		// This code is used to get round a bug in Flash - sometimes 16,
+		// 8-bit zeroes are written out before the transform. The root
+		// cause in Flash is unknown but seems to be related to the
+		// bounds not being set - all values are zero.
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		boolean bytesAreZero = true;
+		int start = coder.getPointer();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		for (int i = 0; i &lt; 16; i++)
+		{
+			if (coder.scanWord(1, false) != 0)
+				bytesAreZero = false;
 
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+			coder.adjustPointer(8);
+		}
 
-        length += bounds.length(coder);
-        length += transform.length(coder);
-        length += 2;
-            
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            length += ((FSTransformObject)recordIterator.next()).length(coder);
-    
-        length += 1;
+		coder.setPointer(start);
 
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		if (bytesAreZero)
+		{
+			for (int i = 0; i &lt; 16; i++)
+			{
+				coder.scanWord(1, false);
+				coder.adjustPointer(8);
+			}
+		}
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		// Back to reading the rest of the tag
 
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		transform = new FSCoordTransform(coder);
 
-        bounds.encode(coder);
-        transform.encode(coder);
-    
-        coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
-        coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
-    
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            ((FSTransformObject)recordIterator.next()).encode(coder);
+		glyphBits = coder.readByte();
+		advanceBits = coder.readByte();
 
-        coder.writeWord(0, 1);
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
 
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int glyphBits = 0;
-        int advanceBits = 0;
-        
-        super.decode(coder);
+		/*
+		 * Set the instance variable directly since Flash files can contain
+		 * FSDefineText objects with no text records - this appears to be a bug
+		 * in the Flash file.
+		 */
+		objects = new ArrayList();
 
-        // Mark the start of the tag body
-        
-        /* location */ coder.getPointer();
+		while (coder.scanBits(8, false) != 0)
+			objects.add(new FSText(coder));
 
-        bounds = new FSBounds(coder);
+		coder.readBits(8, false);
 
-        // This code is used to get round a bug in Flash - sometimes 16, 
-        // 8-bit zeroes are written out before the transform. The root 
-        // cause in Flash is unknown but seems to be related to the 
-        // bounds not being set - all values are zero.
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+	}
 
-        boolean bytesAreZero = true;
-        int start = coder.getPointer();
-        
-        for (int i=0; i&lt;16; i++)
-        {
-            if (coder.scanWord(1, false) != 0)
-                 bytesAreZero = false;
-                 
-             coder.adjustPointer(8);
-        }
-        
-        coder.setPointer(start);
-        
-        if (bytesAreZero)
-        {
-            for (int i=0; i&lt;16; i++)
-            {
-                coder.scanWord(1, false);
-                coder.adjustPointer(8);
-            }
-        }
- 
-        // Back to reading the rest of the tag
+	private int glyphBits()
+	{
+		int numberOfBits = 0;
 
-        transform = new FSCoordTransform(coder);
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).glyphBits());
 
-        glyphBits = coder.readWord(1, false);
-        advanceBits = coder.readWord(1, false);
+		return numberOfBits;
+	}
 
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
-        
-        /*
-         * Set the instance variable directly since Flash files can contain
-         * FSDefineText objects with no text records - this appears to be a 
-         * bug in the Flash file.
-         */
-        objects = new ArrayList();
-        
-        while (coder.scanBits(8, false) != 0)
-            objects.add(new FSText(coder));
+	private int advanceBits()
+	{
+		int numberOfBits = 1;
 
-        coder.readBits(8, false);
-        
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    private int glyphBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).glyphBits());
-            
-        return numberOfBits;
-    }
-    
-    private int advanceBits()
-    {
-        int numberOfBits = 1;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).advanceBits());
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).advanceBits());
 
-        return numberOfBits;
-    }
+		return numberOfBits;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineText2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineText2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineText2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,384 +33,461 @@
 import java.util.*;
 
 /**
-FSDefineText2 defines one or more lines of transparent text. 
- 
-&lt;p&gt;It extends the functionality provided by the FSDefineText class by supporting transparent colours. The characters, style and layout information is defined using FSText objects. The FSDefineText2 class acts as a container for the text, defining the bounding rectangle that encloses the text along with a coordinate transform that can be used to change the size and orientation of the text when it is displayed.&lt;/p&gt;
+ * FSDefineText2 defines one or more lines of transparent text.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by the FSDefineText class by supporting
+ * transparent colours. The characters, style and layout information is defined
+ * using FSText objects. The FSDefineText2 class acts as a container for the
+ * text, defining the bounding rectangle that encloses the text along with a
+ * coordinate transform that can be used to change the size and orientation of
+ * the text when it is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;A coordinate transform describing the placement, size and rotation of
+ * the text block.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSText objects describing the characters to be displayed and
+ * their attributes.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The bounding rectangle and transform controls how the text is laid out. Each
+ * FSText object in the textRecords array specifies an offset from the left and
+ * bottom edges of the bounding rectangle, allowing successive lines of text to
+ * be arranged as a block or paragraph. The coordinate transform can be used to
+ * control the size and orientation of the text when it is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Creating a simple string. The creation and layout of the glyphs to create the
+ * text is too onerous to perform from scratch. It is easier and more convenient
+ * to use existing font definitions either by parsing an existing Flash file or
+ * by converting a font definition from a specification such as TrueType in
+ * order to obtain the glyphs and layout information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * This examples assumes a font definition that contains glyphs for the
+ * following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font
+ * used fixed size for the spacing between glyphs .e.g. Courier.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int fontSize = 240;
+ * int leading = 80;
+ * 
+ * ArrayList characters = new ArrayList();
+ * ArrayList lines = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
+ * // the text is not indented or offset.
+ * 
+ * lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize,
+ * 				characters);
+ * 
+ * // Calculate the bounding rectangle that encloses the text.
+ * // The width of the text by summing all the advances.
+ * 
+ * int width = 0;
+ * int height = fontSize + leading;
+ * 
+ * for (Iterator i = characters.iterator(); i.hasNext();)
+ * 	width += ((FSCharacter) i.next()).getAdvance();
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, width, height);
+ * 
+ * // Define the text with no coordinate transformation (use the default unity transform which leaves
+ * // the text unchanged.
+ * 
+ * FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds,
+ * 				new FSCoordTransform(), lines);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineText2 class represents the DefineText2 tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineText2 extends FSDefineObject
+{
+	private FSBounds bounds = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private FSCoordTransform transform = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private ArrayList objects = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineText2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineText2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineText2(FSCoder coder)
+	{
+		super(DefineText2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText2 object with the specified bounding rectangle,
+	 * coordinate transform and text records.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text.
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text.
+	 * @param textRecordArray
+	 *            an array of text record (FSTextStyle and FSText) object that
+	 *            define the text to be displayed.
+	 */
+	public FSDefineText2(int anIdentifier, FSBounds aBounds,
+							FSCoordTransform aTransform,
+							ArrayList textRecordArray)
+	{
+		super(DefineText2, anIdentifier);
+		setBounds(aBounds);
+		setTransform(aTransform);
+		setObjects(textRecordArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineText object.
+	 */
+	public FSDefineText2(FSDefineText2 obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A coordinate transform describing the placement, size and rotation of the text block.&lt;/td&gt;
-&lt;/tr&gt;
+		objects = new ArrayList(obj.objects.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_4&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSText objects describing the characters to be displayed and their attributes.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		for (Iterator i = obj.objects.iterator(); i.hasNext();)
+			objects.add(((FSText) i.next()).clone());
+	}
 
-&lt;p&gt;The bounding rectangle and transform controls how the text is laid out. Each FSText object in the textRecords array specifies an offset from the left and bottom edges of the bounding rectangle, allowing successive lines of text to be arranged as a block or paragraph. The coordinate transform can be used to control the size and orientation of the text when it is displayed.&lt;/p&gt;
+	/**
+	 * Add a FSText object to the array of text records.
+	 * 
+	 * @param anObject
+	 *            an FSText object.
+	 */
+	public void add(FSText anObject)
+	{
+		objects.add(anObject);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the bounding rectangle that completely encloses the text to be
+	 * displayed.
+	 * 
+	 * @return the bounding rectangle of the text.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;p&gt;Creating a simple string. The creation and layout of the glyphs to create the text is too onerous to perform from scratch. It is easier and more convenient to use existing font definitions either by parsing an existing Flash file or by converting a font definition from a specification such as TrueType in order to obtain the glyphs and layout information.&lt;/p&gt;
+	/**
+	 * Gets the coordinate transform that controls how the text is displayed.
+	 * 
+	 * @return the coordinate transform.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;p&gt;This examples assumes a font definition that contains glyphs for the following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font used fixed size for the spacing between glyphs .e.g. Courier.&lt;/p&gt;
+	/**
+	 * Gets the array of text records that define the text to be displayed as
+	 * its attributes.
+	 * 
+	 * @return the array of text records (FSTextStyle and FSText objects).
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-&lt;pre&gt;
-int fontSize = 240;
-int leading = 80;
+	/**
+	 * Sets the bounding rectangle that encloses the text being displayed.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-ArrayList characters = new ArrayList();
-ArrayList lines = new ArrayList();
+	/**
+	 * Sets the coordinate transform that changes the orientation and size of
+	 * the text displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+	/**
+	 * Sets the array of text records that define the text to be displayed.
+	 * 
+	 * @param anArray
+	 *            an array of FSText objects that define the text to be
+	 *            displayed.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-// Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
-// the text is not indented or offset.
+	public Object clone()
+	{
+		FSDefineText2 anObject = (FSDefineText2) super.clone();
 
-lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize, characters);
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
 
-// Calculate the bounding rectangle that encloses the text.
-// The width of the text by summing all the advances.
+		anObject.objects = new ArrayList(objects.size());
 
-int width = 0;
-int height = fontSize + leading;
+		for (Iterator i = objects.iterator(); i.hasNext();)
+			anObject.objects.add(((FSText) i.next()).clone());
 
-for (Iterator i = characters.iterator(); i.hasNext();)
-    width += ((FSCharacter)i.next()).getAdvance();
+		return anObject;
+	}
 
-FSBounds bounds = new FSBounds(0, 0, width, height);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-// Define the text with no coordinate transformation (use the default unity transform which leaves
-// the text unchanged.
+		if (super.equals(anObject))
+		{
+			FSDefineText2 typedObject = (FSDefineText2) anObject;
 
-FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds, new FSCoordTransform(), lines);
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-&lt;/pre&gt;
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			if (objects != null)
+				result = result &amp;&amp; objects.equals(typedObject.objects);
+			else
+				result = result &amp;&amp; objects == typedObject.objects;
+		}
+		return result;
+	}
 
-&lt;p&gt;The FSDefineText2 class represents the DefineText2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineText2 extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private FSCoordTransform transform = null;
-    private ArrayList objects = null;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /**
-     * Construct an FSDefineText2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineText2(FSCoder coder)
-    {
-        super(DefineText2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineText2 object with the specified bounding rectangle, coordinate transform and text records.
+		buffer.append(&quot;FSDefineText2: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;transform = &quot;).append(transform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;objects = &quot;).append(objects.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    @param anIdentifier the unique identifier for this object.
-    @param aBounds the bounding rectangle enclosing the text.
-    @param aTransform an FSCoordTransform to change the size and orientation of the text.
-    @param textRecordArray an array of text record (FSTextStyle and FSText) object that define the text to be displayed.
-    */
-    public FSDefineText2(int anIdentifier, FSBounds aBounds, FSCoordTransform aTransform, ArrayList textRecordArray)
-    {
-        super(DefineText2, anIdentifier);
-        setBounds(aBounds);
-        setTransform(aTransform);
-        setObjects(textRecordArray);
-    }
-    /**
-     * Constructs an FSDefineText object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineText object.
-     */
-    public FSDefineText2(FSDefineText2 obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        transform = new FSCoordTransform(obj.transform);
-        
-        objects = new ArrayList(obj.objects.size());
-        
-        for (Iterator i = obj.objects.iterator(); i.hasNext();)
-            objects.add(((FSText)i.next()).clone());
-    }    
-    
-    /** Add a FSText object to the array of text records.
+		return buffer.toString();
+	}
 
-        @param anObject an FSText object.
-        */
-    public void add(FSText anObject) { objects.add(anObject); }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the bounding rectangle that completely encloses the text to be displayed.
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-        @return the bounding rectangle of the text.
-        */
-    public FSBounds  getBounds() { return bounds; }
+		length += bounds.length(coder);
+		length += transform.length(coder);
+		length += 2;
 
-    /** Gets the coordinate transform that controls how the text is displayed.
+		for (Iterator&lt;Codeable&gt; recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			length += recordIterator.next().length(coder);
 
-        @return the coordinate transform.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+		length += 1;
 
-    /** Gets the array of text records that define the text to be displayed as its attributes.
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
 
-        @return the array of text records (FSTextStyle and FSText objects).
-        */
-    public ArrayList getObjects() 
-    {
-        return objects;
-    }
+		return length;
+	}
 
-    /** Sets the bounding rectangle that encloses the text being displayed.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param aBounds the bounding rectangle enclosing the text.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-    /** Sets the coordinate transform that changes the orientation and size of the text displayed.
+		bounds.encode(coder);
+		transform.encode(coder);
 
-        @param aTransform an FSCoordTransform to change the size and orientation of the text.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+		coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
+		coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
 
-    /** Sets the array of text records that define the text to be displayed.
+		for (Iterator&lt;Codeable&gt; recordIterator = objects.iterator(); recordIterator.hasNext();)
+			recordIterator.next().encode(coder);
 
-        @param anArray an array of FSText objects that define the text to be displayed.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		coder.writeWord(0, 1);
 
-    public Object clone()
-    {
-        FSDefineText2 anObject = (FSDefineText2)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        
-        anObject.objects = new ArrayList(objects.size());
-                    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-            anObject.objects.add(((FSText)i.next()).clone());
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+	}
 
-        return anObject;
-    }
+	public void decode(FSCoder coder)
+	{
+		int glyphBits = 0;
+		int advanceBits = 0;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineText2 typedObject = (FSDefineText2)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		super.decode(coder);
 
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
+		// Mark the start of the tag body
 
-            if (objects != null)
-                result = result &amp;&amp; objects.equals(typedObject.objects);
-            else
-                result = result &amp;&amp; objects == typedObject.objects;
-        }
-        return result;
-    }
+		/* location */coder.getPointer();
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		bounds = new FSBounds(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		// This code is used to get round a bug in Flash - sometimes 16,
+		// 8-bit zeroes are written out before the transform. The root
+		// cause in Flash is unknown but seems to be related to the
+		// bounds not being set - all values are zero.
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		boolean bytesAreZero = true;
+		int start = coder.getPointer();
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		for (int i = 0; i &lt; 16; i++)
+		{
+			if (coder.scanWord(1, false) != 0)
+				bytesAreZero = false;
 
-        length += bounds.length(coder);
-        length += transform.length(coder);
-        length += 2;
-            
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            length += ((FSTransformObject)recordIterator.next()).length(coder);
-    
-        length += 1;
+			coder.adjustPointer(8);
+		}
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		coder.setPointer(start);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		if (bytesAreZero)
+		{
+			for (int i = 0; i &lt; 16; i++)
+			{
+				coder.scanWord(1, false);
+				coder.adjustPointer(8);
+			}
+		}
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		// Back to reading the rest of the tag
 
-        bounds.encode(coder);
-        transform.encode(coder);
-    
-        coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
-        coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
-    
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            ((FSTransformObject)recordIterator.next()).encode(coder);
+		transform = new FSCoordTransform(coder);
 
-        coder.writeWord(0, 1);
+		glyphBits = coder.readByte();
+		advanceBits = coder.readByte();
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int glyphBits = 0;
-        int advanceBits = 0;
-        
-        super.decode(coder);
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
 
-        // Mark the start of the tag body
-        
-        /* location */ coder.getPointer();
+		/*
+		 * Set the instance variable directly since Flash files can contain
+		 * FSDefineText objects with no text records - this appears to be a bug
+		 * in the Flash file.
+		 */
+		objects = new ArrayList();
 
-        bounds = new FSBounds(coder);
+		while (coder.scanBits(8, false) != 0)
+			objects.add(new FSText(coder));
 
-        // This code is used to get round a bug in Flash - sometimes 16, 
-        // 8-bit zeroes are written out before the transform. The root 
-        // cause in Flash is unknown but seems to be related to the 
-        // bounds not being set - all values are zero.
+		coder.readBits(8, false);
 
-        boolean bytesAreZero = true;
-        int start = coder.getPointer();
-        
-        for (int i=0; i&lt;16; i++)
-        {
-            if (coder.scanWord(1, false) != 0)
-                bytesAreZero = false;
-                 
-            coder.adjustPointer(8);
-        }
-        
-        coder.setPointer(start);
-        
-        if (bytesAreZero)
-        {
-            for (int i=0; i&lt;16; i++)
-            {
-                coder.scanWord(1, false);
-                coder.adjustPointer(8);
-            }
-        }
- 
-        // Back to reading the rest of the tag
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+	}
 
-        transform = new FSCoordTransform(coder);
+	private int glyphBits()
+	{
+		int numberOfBits = 0;
 
-        glyphBits = coder.readWord(1, false);
-        advanceBits = coder.readWord(1, false);
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).glyphBits());
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
-        
-        /*
-         * Set the instance variable directly since Flash files can contain
-         * FSDefineText objects with no text records - this appears to be a 
-         * bug in the Flash file.
-         */
-        objects = new ArrayList();
-        
-        while (coder.scanBits(8, false) != 0)
-            objects.add(new FSText(coder));
+		return numberOfBits;
+	}
 
-        coder.readBits(8, false);
-        
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    private int glyphBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).glyphBits());
-            
-        return numberOfBits;
-    }
-    
-    private int advanceBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).advanceBits());
+	private int advanceBits()
+	{
+		int numberOfBits = 0;
 
-        return numberOfBits;
-    }
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).advanceBits());
+
+		return numberOfBits;
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineTextField.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineTextField.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineTextField.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,1089 +33,1268 @@
 import java.util.*;
 
 /**
-FSDefineTextField defines an editable text field. 
- 
-&lt;p&gt;The value entered into the text field is assigned to a specified variable 
-allowing the creation of forms to accept values entered by a person viewing the 
-Flash file.&lt;/p&gt;
+ * FSDefineTextField defines an editable text field.
+ * 
+ * &lt;p&gt;
+ * The value entered into the text field is assigned to a specified variable
+ * allowing the creation of forms to accept values entered by a person viewing
+ * the Flash file.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The class contains a complex set of attributes which allows a high degree of
+ * control over how a text field is displayed:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding rectangle for the text field.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;wordWrap&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text should be wrapped.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;multiline&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field contains multiple lines.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;password&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field will be used to display a password.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;readOnly&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field is read only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;selectable&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field is selectable.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;bordered&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field is bordered.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;HTML&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field contains HTML.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;fontIdentifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the font displayed in the text field.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;The height of the characters in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;useFontGlyphs&lt;/td&gt;
+ * &lt;td&gt;Use either the glyphs defined in the movie to display the text or load
+ * the specified from the platform on which the Flash Player is hosted.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;autosize&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field will resize automatically to fit the
+ * text entered.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;colour&lt;/td&gt;
+ * &lt;td&gt;The colour of the text. If set to null then the text colour defaults to
+ * black.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;maxLength&lt;/td&gt;
+ * &lt;td&gt;The maximum length of the text field. May be set to zero is not maximum
+ * length is defined.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;variableName&lt;/td&gt;
+ * &lt;td&gt;The name of the variable the text will be assigned to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;initialText&lt;/td&gt;
+ * &lt;td&gt;The default text displayed in the text field.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Additional layout information for the spacing of the text relative to the
+ * text field borders can also be specified through the following set of
+ * attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;alignment&lt;/td&gt;
+ * &lt;td&gt;Whether the text in the field is left-aligned, right-aligned, centred.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;leftMargin&lt;/td&gt;
+ * &lt;td&gt;Left margin in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;rightMargin&lt;/td&gt;
+ * &lt;td&gt;Right margin in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;indent&lt;/td&gt;
+ * &lt;td&gt;Text indentation in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;leading&lt;/td&gt;
+ * &lt;td&gt;Leading in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The default values for the alignment is AlignLeft while the leftMargin,
+ * rightMargin indent and leading attributes are set to the constant
+ * Transform.VALUE_NOT_SET. If the attributes remain unchanged then the layout
+ * information will not be encoded. If any of the values in this group are set
+ * then they must all have values assigned for the field to be displayed
+ * correctly otherwise default values of 0 will be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;HTML Support&lt;/b&gt;&lt;br/&gt; Setting the HTML flag to true allows text marked
+ * up with a limited set of HTML tags to be displayed in the text field. The
+ * following tags are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits a paragraph. Only the align attribute is supported:&lt;br&gt;
+ * &lt;p [align = left | right | center ]&gt;
+ * &lt;/p&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;br&gt;&lt;/td&gt;
+ * &lt;td&gt;Inserts a line break.&gt;
+ * &lt;/p&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Define a hyperlink. Two attributes are supported:
+ * &lt;ul&gt;
+ * &lt;li&gt;href - the URL of the link.&lt;/li&gt;
+ * &lt;li&gt;target - name of a window or frame. (optional)&lt;/li&gt;
+ * &lt;/ul&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;font&gt;&lt;/font&gt;&lt;/td&gt;
+ * &lt;td&gt;Format enclosed text using the font. Three attributes are supported:
+ * &lt;ul&gt;
+ * &lt;li&gt;name - must match the name of a font defined using the FSDefineFont2
+ * class.&lt;/li&gt;
+ * &lt;li&gt;size - the height of the font in twips.&lt;/li&gt;
+ * &lt;li&gt;color - the colour of the text in the hexadecimal format #RRGGBB.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits text that should be displayed in bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits text that should be displayed in italics.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits text that should be displayed underlined.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;li&gt;&lt;/li&gt;&lt;/td&gt;
+ * &lt;td&gt;Display bulleted paragraph. Strictly speaking this is not an HTML list.
+ * The &lt;ul&gt; tag is not required and no other list format is supported.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSDefineTextField class represents the DefineTextField from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSDefineTextField extends FSDefineObject
+{
+	/** Key used to identify the wordWrapped attribute. */
+	public static final String WordWrapped = &quot;WordWrapped&quot;;
 
-&lt;p&gt;The class contains a complex set of attributes which allows a high degree of 
-control over how a text field is displayed:&lt;/p&gt;
+	/** Key used to identify the multiline attribute. */
+	public static final String Multiline = &quot;Multiline&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Key used to identify the password attribute. */
+	public static final String Password = &quot;Password&quot;;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Key used to identify the readOnly attribute. */
+	public static final String ReadOnly = &quot;ReadOnly&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the selectable attribute. */
+	public static final String Selectable = &quot;Selectable&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding rectangle for the text field.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_3&quot;&gt;wordWrap&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text should be wrapped.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_4&quot;&gt;multiline&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field contains multiple lines.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_5&quot;&gt;password&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field will be used to display a password.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_6&quot;&gt;readOnly&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field is read only.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_7&quot;&gt;selectable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field is selectable.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_8&quot;&gt;bordered&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field is bordered.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_9&quot;&gt;HTML&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field contains HTML.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_10&quot;&gt;fontIdentifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the font displayed in the text field.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_11&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The height of the characters in twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_12&quot;&gt;useFontGlyphs&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Use either the glyphs defined in the movie to display the text or load the 
-specified from the platform on which the Flash Player is hosted.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_13&quot;&gt;autosize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field will resize automatically to fit the text 
-entered.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_14&quot;&gt;colour&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour of the text. If set to null then the text colour defaults to 
-black.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_15&quot;&gt;maxLength&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum length of the text field. May be set to zero is not maximum 
-length is defined.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_16&quot;&gt;variableName&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of the variable the text will be assigned to.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_17&quot;&gt;initialText&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The default text displayed in the text field.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/** Key used to identify the bordered attribute. */
+	public static final String Bordered = &quot;Bordered&quot;;
 
-&lt;p&gt;Additional layout information for the spacing of the text relative to the 
-text field borders can also be specified through the following set of 
-attributes:&lt;/p&gt;
+	/** Key used to identify the bordered attribute. */
+	public static final String HTML = &quot;HTML&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Key used to identify the useFontGlyphs attribute. */
+	public static final String UseFontGlyphs = &quot;UseFontGlyphs&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_17&quot;&gt;alignment&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the text in the 
-field is left-aligned, right-aligned, centred.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_18&quot;&gt;leftMargin&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Left margin in 
-twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_19&quot;&gt;rightMargin&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Right margin in 
-twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_20&quot;&gt;indent&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Text indentation in 
-twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_21&quot;&gt;leading&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Leading in twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	// Flash 6
+	/** Key used to identify the autoSize attribute. */
+	public static final String AutoSize = &quot;AutoSize&quot;;
 
-&lt;p&gt;The default values for the alignment is AlignLeft while the leftMargin, 
-rightMargin indent and leading attributes are set to the constant
-Transform.VALUE_NOT_SET. If the attributes remain unchanged then the layout 
-information will not be encoded. If any of the values in this group are set then 
-they must all have values assigned for the field to be displayed correctly
-otherwise default values of 0 will be used.&lt;/p&gt;
+	// End Flash 6
+	/** Key used to identify the identifier attribute. */
+	public static final String FontIdentifier = &quot;FontIdentifier&quot;;
 
-&lt;p&gt;&lt;b&gt;HTML Support&lt;/b&gt;&lt;br/&gt;
-Setting the HTML flag to true allows text marked up with a limited set of HTML 
-tags to be displayed in the text field. The following tags are supported:&lt;/p&gt;
+	/** Key used to identify the fontHeight attribute. */
+	public static final String FontHeight = &quot;FontHeight&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;
-&lt;td&gt;Delimits a paragraph. Only the align attribute is supported:&lt;br&gt;
-&lt;p [align = left | right | center ]&gt;&lt;/p&gt;
-&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the color attribute. */
+	public static final String Color = &quot;Color&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;br&gt;&lt;/td&gt;
-&lt;td&gt;Inserts a line break.&gt;&lt;/p&gt;&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the maxLength attribute. */
+	public static final String MaxLength = &quot;MaxLength&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a&gt;&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Define a hyperlink. Two attributes are supported:
-&lt;ul&gt;
-&lt;li&gt;href - the URL of the link.&lt;/li&gt;
-&lt;li&gt;target - name of a window or frame. (optional)&lt;/li&gt;
-&lt;/ul&gt;
-&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the leftMargin attribute. */
+	public static final String LeftMargin = &quot;LeftMargin&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;font&gt;&lt;/font&gt;&lt;/td&gt;
-&lt;td&gt;Format enclosed text using the font. Three attributes are supported:
-&lt;ul&gt;
-&lt;li&gt;name - must match the name of a font defined using the FSDefineFont2 class.&lt;/li&gt;
-&lt;li&gt;size - the height of the font in twips.&lt;/li&gt;
-&lt;li&gt;color - the colour of the text in the hexadecimal format #RRGGBB.&lt;/li&gt;
-&lt;/ul&gt;
-&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the rightMargin attribute. */
+	public static final String RightMargin = &quot;RightMargin&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
-&lt;td&gt;Delimits text that should be displayed in bold.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the indent attribute. */
+	public static final String Indent = &quot;Indent&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
-&lt;td&gt;Delimits text that should be displayed in italics.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the leading attribute. */
+	public static final String Leading = &quot;Leading&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
-&lt;td&gt;Delimits text that should be displayed underlined.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the variableName attribute. */
+	public static final String VariableName = &quot;VariableName&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;li&gt;&lt;/li&gt;&lt;/td&gt;
-&lt;td&gt;Display bulleted paragraph. Strictly speaking this is not an HTML list. 
-The &lt;ul&gt; tag is not required and no other list format is supported.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the initialText attribute. */
+	public static final String InitialText = &quot;InitialText&quot;;
 
-&lt;/table&gt;
+	/** Defines that the text displayed in a text field is left aligned. */
+	public static final int AlignLeft = 0;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/** Defines that the text displayed in a text field is right aligned. */
+	public static final int AlignRight = 1;
 
-&lt;p&gt;FSDefineTextField class represents the DefineTextField from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSDefineTextField extends FSDefineObject
-{
-/** Key used to identify the wordWrapped attribute. */
-    public static final String WordWrapped = &quot;WordWrapped&quot;;
-/** Key used to identify the multiline attribute. */
-    public static final String Multiline = &quot;Multiline&quot;;
-/** Key used to identify the password attribute. */
-    public static final String Password = &quot;Password&quot;;
-/** Key used to identify the readOnly attribute. */
-    public static final String ReadOnly = &quot;ReadOnly&quot;;
-/** Key used to identify the selectable attribute. */
-    public static final String Selectable = &quot;Selectable&quot;;
-/** Key used to identify the bordered attribute. */
-    public static final String Bordered = &quot;Bordered&quot;;
-/** Key used to identify the bordered attribute. */
-    public static final String HTML = &quot;HTML&quot;;
-/** Key used to identify the useFontGlyphs attribute. */
-    public static final String UseFontGlyphs = &quot;UseFontGlyphs&quot;;
-// Flash 6
-/** Key used to identify the autoSize attribute. */
-    public static final String AutoSize = &quot;AutoSize&quot;;
-// End Flash 6
-/** Key used to identify the identifier attribute. */
-    public static final String FontIdentifier = &quot;FontIdentifier&quot;;
-/** Key used to identify the fontHeight attribute. */
-    public static final String FontHeight = &quot;FontHeight&quot;;
-/** Key used to identify the color attribute. */
-    public static final String Color = &quot;Color&quot;;
-/** Key used to identify the maxLength attribute. */
-    public static final String MaxLength = &quot;MaxLength&quot;;
-/** Key used to identify the leftMargin attribute. */
-    public static final String LeftMargin = &quot;LeftMargin&quot;;
-/** Key used to identify the rightMargin attribute. */
-    public static final String RightMargin = &quot;RightMargin&quot;;
-/** Key used to identify the indent attribute. */
-    public static final String Indent = &quot;Indent&quot;;
-/** Key used to identify the leading attribute. */
-    public static final String Leading = &quot;Leading&quot;;
-/** Key used to identify the variableName attribute. */
-    public static final String VariableName = &quot;VariableName&quot;;
-/** Key used to identify the initialText attribute. */
-    public static final String InitialText = &quot;InitialText&quot;;
+	/** Defines that the text displayed in a text field is centre aligned. */
+	public static final int AlignCenter = 2;
 
+	/** Defines that the text displayed in a text field is justified. */
+	public static final int AlignJustify = 3;
 
-/** Defines that the text displayed in a text field is left aligned. */
-    public static final int AlignLeft = 0;
-/** Defines that the text displayed in a text field is right aligned. */
-    public static final int AlignRight = 1;
-/** Defines that the text displayed in a text field is centre aligned. */
-    public static final int AlignCenter = 2;
-/** Defines that the text displayed in a text field is justified. */
-    public static final int AlignJustify = 3;
-    
-    private FSBounds bounds = null;
-    private boolean wordWrapped = false;
-    private boolean multiline = false;
-    private boolean password = false;
-    private boolean readOnly = false;
-    private int reserved1 = 0;
-    private boolean selectable = false;
-    private boolean bordered = false;
-    private boolean reserved2 = false;
-    private boolean html = false;
-    private boolean useFontGlyphs = false;
-    private boolean autoSize = false;
-    private int fontIdentifier = 0;
-    private int fontHeight = 0;
-    private FSColor color = null;
-    private int maxLength = 0;
-    private int alignment = Transform.VALUE_NOT_SET;
-    private int leftMargin = Transform.VALUE_NOT_SET;
-    private int rightMargin = Transform.VALUE_NOT_SET;
-    private int indent = Transform.VALUE_NOT_SET;
-    private int leading = Transform.VALUE_NOT_SET;
-    private String variableName = &quot;&quot;;
-    private String initialText = &quot;&quot;;
+	private FSBounds bounds = null;
 
-    /**
-     * Construct an FSDefineTextField object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineTextField(FSCoder coder)
-    {
-        super(DefineTextField, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineTextField object with the specified identifier and with the size defined by the bounding rectangle. All other attributes are set to their default values which will result in a blank, single-line, editable text field. Any values entered will not be assigned to a variable. Since no font is specified the text will be displayed in a non-spaced font 20 twips in height.
+	private boolean wordWrapped = false;
 
-        @param anIdentifier the unique identifier for this object.
-        @param aBounds the bounding rectangle for the field which defines its size.
-        */
-    public FSDefineTextField(int anIdentifier, FSBounds aBounds)
-    {
-        super(DefineTextField, anIdentifier);
-        setBounds(aBounds);
-    }
-    /** Constructs an FSDefineTextField object setting the attributes added to the Hashtable. Each entry consists of a key-value pair. The key is one of the pre-defined attribute names while the value is an instance of a wrapper class (Boolean, Integer or String) that will be assigned to the specified attribute.
+	private boolean multiline = false;
 
-        @param anIdentifier the unique identifier for this object.
-        @param aBounds the bounding rectangle for the field which defines its size.
-        @param attributes a collection of key-value pairs identifying the attributes to be set.
-        */
-    public FSDefineTextField(int anIdentifier, FSBounds aBounds, Hashtable attributes)
-    {
-        super(DefineTextField, anIdentifier);
-        setBounds(aBounds);
-        setAttributes(attributes);
-    }
-    /**
-     * Constructs an FSDefineText object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineText object.
-     */
-    public FSDefineTextField(FSDefineTextField obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        wordWrapped = obj.wordWrapped;
-        multiline = obj.multiline;
-        password = obj.password;
-        readOnly = obj.readOnly;
-        reserved1 = obj.reserved1;
-        selectable = obj.selectable;
-        bordered = obj.bordered;
-        reserved2 = obj.reserved2;
-        html = obj.html;
-        useFontGlyphs = obj.useFontGlyphs;
-        autoSize = obj.autoSize;
-        fontIdentifier = obj.fontIdentifier;
-        fontHeight = obj.fontHeight;
-        color = new FSColor(obj.color);
-        maxLength = obj.maxLength;
-        alignment = obj.alignment;
-        leftMargin = obj.leftMargin;
-        rightMargin = obj.rightMargin;
-        indent = obj.indent;
-        leading = obj.leading;
-        variableName = new String(obj.variableName);
-        initialText = new String(obj.initialText);
-    }    
+	private boolean password = false;
 
-    /** Gets the bounding rectangle that completely encloses the text field.
+	private boolean readOnly = false;
 
-        @return the bounding rectangle for the text field.
-        */
-    public FSBounds getBounds()
-    {
-        return bounds;
-    }
+	private int reserved1 = 0;
 
-    /** Does the text field support word wrapping.
+	private boolean selectable = false;
 
-        @return a flag indicating whether the text in the field will be wrapped.
-        */
-    public boolean isWordWrapped()
-    {
-        return wordWrapped;
-    }
+	private boolean bordered = false;
 
-    /** Does the text field support multiple lines of text.
+	private boolean reserved2 = false;
 
-        @return a flag indicating whether the text in the field will contain multiple lines.
-        */
-    public boolean  isMultiline()
-    {
-        return multiline;
-    }
+	private boolean html = false;
 
-    /** Does the text field protect passwords being entered.
+	private boolean useFontGlyphs = false;
 
-        @return a flag indicating whether the text in the field represents a password.
-        */
-    public boolean isPassword()
-    {
-        return password;
-    }
+	private boolean autoSize = false;
 
-    /** Is the text field read-only.
+	private int fontIdentifier = 0;
 
-        @return a flag indicating whether the text in the field is read-only.
-        */
-    public boolean isReadOnly()
-    {
-        return readOnly;
-    }
+	private int fontHeight = 0;
 
-    /** Is the text field selectable.
+	private FSColor color = null;
 
-        @return a flag indicating whether the text in the field is selectable.
-        */
-    public boolean isSelectable()
-    {
-        return selectable;
-    }
+	private int maxLength = 0;
 
-    /** Is the text field bordered.
+	private int alignment = Transform.VALUE_NOT_SET;
 
-        @return a flag indicating whether the text in the field is bordered.
-        */
-    public boolean isBordered()
-    {
-        return bordered;
-    }
+	private int leftMargin = Transform.VALUE_NOT_SET;
 
-    /** Does the text field contain HTML.
+	private int rightMargin = Transform.VALUE_NOT_SET;
 
-        @return a flag indicating whether the text in the field contains HTML.
-        */
-    public boolean isHTML()
-    {
-        return html;
-    }
+	private int indent = Transform.VALUE_NOT_SET;
 
-// Flash 6
-    /** Does the text field resize to fit the contents.
-    
-        @return a flag indicating whether the text field will resize automatically. 
-      */
-    public boolean isAutoSize()
-    {
-        return autoSize;
-    }
-// End Flash 6
-    /** Sets whether the text field will resize to fit the contents.
-     *
-     * @param aFlag indicate whether the text field will resize automatically.
-     */
-    public void setAutoSize(boolean aFlag)
-    {
-        autoSize = aFlag;
-    }
+	private int leading = Transform.VALUE_NOT_SET;
 
-    /** 
-     * Indicates whether the test will be displayed using the font defined in the movie or 
-     * whether a font defined on the host platform will be used.
-     *
-     * @return true if the text will be displayed using the glyphs from the font defined 
-     * in the movie, false if the glyphs will be loaded from the platform on which the 
-     * Flash Player is hosted.
-     */
-    public boolean useFontGlyphs()
-    {
-        return useFontGlyphs;
-    }
+	private String variableName = &quot;&quot;;
 
-    /** Gets the identifier of the font used to display the characters.
+	private String initialText = &quot;&quot;;
 
-        @return the font identifier.
-        */
-    public int getFontIdentifier()
-    {
-        return fontIdentifier;
-    }
+	/**
+	 * Construct an FSDefineTextField object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineTextField(FSCoder coder)
+	{
+		super(DefineTextField, 0);
+		decode(coder);
+	}
 
-    /** Gets the height of the characters.
+	/**
+	 * Constructs an FSDefineTextField object with the specified identifier and
+	 * with the size defined by the bounding rectangle. All other attributes are
+	 * set to their default values which will result in a blank, single-line,
+	 * editable text field. Any values entered will not be assigned to a
+	 * variable. Since no font is specified the text will be displayed in a
+	 * non-spaced font 20 twips in height.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param aBounds
+	 *            the bounding rectangle for the field which defines its size.
+	 */
+	public FSDefineTextField(int anIdentifier, FSBounds aBounds)
+	{
+		super(DefineTextField, anIdentifier);
+		setBounds(aBounds);
+	}
 
-        @return the height of the font.
-        */
-    public int getFontHeight()
-    {
-        return fontHeight;
-    }
+	/**
+	 * Constructs an FSDefineTextField object setting the attributes added to
+	 * the Hashtable. Each entry consists of a key-value pair. The key is one of
+	 * the pre-defined attribute names while the value is an instance of a
+	 * wrapper class (Boolean, Integer or String) that will be assigned to the
+	 * specified attribute.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param aBounds
+	 *            the bounding rectangle for the field which defines its size.
+	 * @param attributes
+	 *            a collection of key-value pairs identifying the attributes to
+	 *            be set.
+	 */
+	public FSDefineTextField(int anIdentifier, FSBounds aBounds,
+								Hashtable attributes)
+	{
+		super(DefineTextField, anIdentifier);
+		setBounds(aBounds);
+		setAttributes(attributes);
+	}
 
-    /** Gets the text color.
+	/**
+	 * Constructs an FSDefineText object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineText object.
+	 */
+	public FSDefineTextField(FSDefineTextField obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
+		wordWrapped = obj.wordWrapped;
+		multiline = obj.multiline;
+		password = obj.password;
+		readOnly = obj.readOnly;
+		reserved1 = obj.reserved1;
+		selectable = obj.selectable;
+		bordered = obj.bordered;
+		reserved2 = obj.reserved2;
+		html = obj.html;
+		useFontGlyphs = obj.useFontGlyphs;
+		autoSize = obj.autoSize;
+		fontIdentifier = obj.fontIdentifier;
+		fontHeight = obj.fontHeight;
+		color = new FSColor(obj.color);
+		maxLength = obj.maxLength;
+		alignment = obj.alignment;
+		leftMargin = obj.leftMargin;
+		rightMargin = obj.rightMargin;
+		indent = obj.indent;
+		leading = obj.leading;
+		variableName = new String(obj.variableName);
+		initialText = new String(obj.initialText);
+	}
 
-        @return the color of the text.
-        */
-    public FSColor getColor()
-    {
-        return color;
-    }
+	/**
+	 * Gets the bounding rectangle that completely encloses the text field.
+	 * 
+	 * @return the bounding rectangle for the text field.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-    /** Gets the maximum length of the text displayed.
+	/**
+	 * Does the text field support word wrapping.
+	 * 
+	 * @return a flag indicating whether the text in the field will be wrapped.
+	 */
+	public boolean isWordWrapped()
+	{
+		return wordWrapped;
+	}
 
-        @return the maximum number of characters displayed.
-        */
-    public int getMaxLength()
-    {
-        return maxLength;
-    }
+	/**
+	 * Does the text field support multiple lines of text.
+	 * 
+	 * @return a flag indicating whether the text in the field will contain
+	 *         multiple lines.
+	 */
+	public boolean isMultiline()
+	{
+		return multiline;
+	}
 
-    /** Gets the alignment of the text, either AlignLeft, AlignRight, AlignCenter or AlignJustify.
+	/**
+	 * Does the text field protect passwords being entered.
+	 * 
+	 * @return a flag indicating whether the text in the field represents a
+	 *         password.
+	 */
+	public boolean isPassword()
+	{
+		return password;
+	}
 
-        @return the alignment code.
-        */
-    public int getAlignment()
-    {
-        return alignment;
-    }
+	/**
+	 * Is the text field read-only.
+	 * 
+	 * @return a flag indicating whether the text in the field is read-only.
+	 */
+	public boolean isReadOnly()
+	{
+		return readOnly;
+	}
 
-    /** Gets the left margin in twips.
+	/**
+	 * Is the text field selectable.
+	 * 
+	 * @return a flag indicating whether the text in the field is selectable.
+	 */
+	public boolean isSelectable()
+	{
+		return selectable;
+	}
 
-        @return the left margin.
-        */
-    public int getLeftMargin() 
-    {    
-        return leftMargin;
-    }
+	/**
+	 * Is the text field bordered.
+	 * 
+	 * @return a flag indicating whether the text in the field is bordered.
+	 */
+	public boolean isBordered()
+	{
+		return bordered;
+	}
 
-    /** Gets the right margin in twips.
+	/**
+	 * Does the text field contain HTML.
+	 * 
+	 * @return a flag indicating whether the text in the field contains HTML.
+	 */
+	public boolean isHTML()
+	{
+		return html;
+	}
 
-        @return the right margin.
-        */
-    public int getRightMargin() 
-    {
-        return rightMargin;
-    }
+	// Flash 6
+	/**
+	 * Does the text field resize to fit the contents.
+	 * 
+	 * @return a flag indicating whether the text field will resize
+	 *         automatically.
+	 */
+	public boolean isAutoSize()
+	{
+		return autoSize;
+	}
 
-    /** Gets the indentation of the first line of text in twips.
+	// End Flash 6
+	/**
+	 * Sets whether the text field will resize to fit the contents.
+	 * 
+	 * @param aFlag
+	 *            indicate whether the text field will resize automatically.
+	 */
+	public void setAutoSize(boolean aFlag)
+	{
+		autoSize = aFlag;
+	}
 
-        @return the indentation of the first line.
-        */
-    public int getIndent()
-    {
-        return indent;
-    }
+	/**
+	 * Indicates whether the test will be displayed using the font defined in
+	 * the movie or whether a font defined on the host platform will be used.
+	 * 
+	 * @return true if the text will be displayed using the glyphs from the font
+	 *         defined in the movie, false if the glyphs will be loaded from the
+	 *         platform on which the Flash Player is hosted.
+	 */
+	public boolean useFontGlyphs()
+	{
+		return useFontGlyphs;
+	}
 
-    /** Gets the leading in twips.
+	/**
+	 * Gets the identifier of the font used to display the characters.
+	 * 
+	 * @return the font identifier.
+	 */
+	public int getFontIdentifier()
+	{
+		return fontIdentifier;
+	}
 
-        @return the leading.
-        */
-    public int getLeading()
-    {
-        return leading;
-    }
+	/**
+	 * Gets the height of the characters.
+	 * 
+	 * @return the height of the font.
+	 */
+	public int getFontHeight()
+	{
+		return fontHeight;
+	}
 
-    /** Gets the name of the variable the value in the text field will be assigned to.
+	/**
+	 * Gets the text color.
+	 * 
+	 * @return the color of the text.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-        @return the name of the variable.
-        */
-    public String getVariableName()
-    {
-        return variableName;
-    }
+	/**
+	 * Gets the maximum length of the text displayed.
+	 * 
+	 * @return the maximum number of characters displayed.
+	 */
+	public int getMaxLength()
+	{
+		return maxLength;
+	}
 
-    /** Gets the default text displayed in the field.
+	/**
+	 * Gets the alignment of the text, either AlignLeft, AlignRight, AlignCenter
+	 * or AlignJustify.
+	 * 
+	 * @return the alignment code.
+	 */
+	public int getAlignment()
+	{
+		return alignment;
+	}
 
-        @return the default value displayed in the field.
-    */
-    public String getInitialText()
-    {
-        return initialText;
-    }
+	/**
+	 * Gets the left margin in twips.
+	 * 
+	 * @return the left margin.
+	 */
+	public int getLeftMargin()
+	{
+		return leftMargin;
+	}
 
-    /** Gets the list of attributes for the object. The Hashtable contains a list of key-value pairs. The key is one of the pre-defined attribute names while the value is an instance of a wrapper class (Boolean, Integer or String) that contains the corresponding object attribute.
+	/**
+	 * Gets the right margin in twips.
+	 * 
+	 * @return the right margin.
+	 */
+	public int getRightMargin()
+	{
+		return rightMargin;
+	}
 
-        @return the list of attributes for the object.
-        */
-    public Hashtable getAttributes()
-    {
-        Hashtable attributes = new Hashtable();
-        
-        attributes.put(WordWrapped, new Boolean(isWordWrapped()));
-        attributes.put(Multiline, new Boolean(isMultiline()));
-        attributes.put(Password, new Boolean(isPassword()));
-        attributes.put(ReadOnly, new Boolean(isReadOnly()));
-// Flash 6
-        attributes.put(AutoSize, new Boolean(isAutoSize()));
-// End Flash 6
-        attributes.put(Selectable, new Boolean(isSelectable()));
-        attributes.put(Bordered, new Boolean(isBordered()));
-        attributes.put(HTML, new Boolean(isHTML()));
-        attributes.put(UseFontGlyphs, new Boolean(useFontGlyphs()));
-        attributes.put(FontIdentifier, new Integer(getFontIdentifier()));
-        attributes.put(FontHeight, new Integer(getFontHeight()));
-        attributes.put(Color, getColor());
-        attributes.put(MaxLength, new Integer(getMaxLength()));
-        attributes.put(LeftMargin, new Integer(getLeftMargin()));
-        attributes.put(RightMargin, new Integer(getRightMargin()));
-        attributes.put(Indent, new Integer(getIndent()));
-        attributes.put(Leading, new Integer(getLeading()));
-        attributes.put(VariableName, getVariableName());
-        attributes.put(InitialText, getInitialText());
-        
-        return attributes;
-    }
+	/**
+	 * Gets the indentation of the first line of text in twips.
+	 * 
+	 * @return the indentation of the first line.
+	 */
+	public int getIndent()
+	{
+		return indent;
+	}
 
-    /** Sets the bounding rectangle of the text field.
+	/**
+	 * Gets the leading in twips.
+	 * 
+	 * @return the leading.
+	 */
+	public int getLeading()
+	{
+		return leading;
+	}
 
-        @param aBounds the bounding rectangle enclosing the text field.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+	/**
+	 * Gets the name of the variable the value in the text field will be
+	 * assigned to.
+	 * 
+	 * @return the name of the variable.
+	 */
+	public String getVariableName()
+	{
+		return variableName;
+	}
 
-    /** Set whether the text field supports word wrapping.
+	/**
+	 * Gets the default text displayed in the field.
+	 * 
+	 * @return the default value displayed in the field.
+	 */
+	public String getInitialText()
+	{
+		return initialText;
+	}
 
-        @param aFlag set whether the text field is word wrapped.
-        */
-    public void setWordWrapped(boolean aFlag)
-    {
-        wordWrapped = aFlag;
-    }
+	/**
+	 * Gets the list of attributes for the object. The Hashtable contains a list
+	 * of key-value pairs. The key is one of the pre-defined attribute names
+	 * while the value is an instance of a wrapper class (Boolean, Integer or
+	 * String) that contains the corresponding object attribute.
+	 * 
+	 * @return the list of attributes for the object.
+	 */
+	public Hashtable getAttributes()
+	{
+		Hashtable attributes = new Hashtable();
 
-    /** Set whether the text field contains multiple lines of text.
+		attributes.put(WordWrapped, new Boolean(isWordWrapped()));
+		attributes.put(Multiline, new Boolean(isMultiline()));
+		attributes.put(Password, new Boolean(isPassword()));
+		attributes.put(ReadOnly, new Boolean(isReadOnly()));
+		// Flash 6
+		attributes.put(AutoSize, new Boolean(isAutoSize()));
+		// End Flash 6
+		attributes.put(Selectable, new Boolean(isSelectable()));
+		attributes.put(Bordered, new Boolean(isBordered()));
+		attributes.put(HTML, new Boolean(isHTML()));
+		attributes.put(UseFontGlyphs, new Boolean(useFontGlyphs()));
+		attributes.put(FontIdentifier, new Integer(getFontIdentifier()));
+		attributes.put(FontHeight, new Integer(getFontHeight()));
+		attributes.put(Color, getColor());
+		attributes.put(MaxLength, new Integer(getMaxLength()));
+		attributes.put(LeftMargin, new Integer(getLeftMargin()));
+		attributes.put(RightMargin, new Integer(getRightMargin()));
+		attributes.put(Indent, new Integer(getIndent()));
+		attributes.put(Leading, new Integer(getLeading()));
+		attributes.put(VariableName, getVariableName());
+		attributes.put(InitialText, getInitialText());
 
-        @param aFlag set whether the text field is multiline.
-        */
-    public void setMultiline(boolean aFlag)
-    {
-        multiline = aFlag;
-    }
+		return attributes;
+	}
 
-    /** Set whether the text field should protect passwords entered.
+	/**
+	 * Sets the bounding rectangle of the text field.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text field.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-        @param aFlag set whether the text field is password protected.
-        */
-    public void setPassword(boolean aFlag)
-    {
-        password = aFlag;
-    }
+	/**
+	 * Set whether the text field supports word wrapping.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is word wrapped.
+	 */
+	public void setWordWrapped(boolean aFlag)
+	{
+		wordWrapped = aFlag;
+	}
 
-    /** Set whether the text field is read-only.
+	/**
+	 * Set whether the text field contains multiple lines of text.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is multiline.
+	 */
+	public void setMultiline(boolean aFlag)
+	{
+		multiline = aFlag;
+	}
 
-        @param aFlag set whether the text field is read-only.
-        */
-    public void setReadOnly(boolean aFlag)
-    {
-        readOnly = aFlag;
-    }
+	/**
+	 * Set whether the text field should protect passwords entered.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is password protected.
+	 */
+	public void setPassword(boolean aFlag)
+	{
+		password = aFlag;
+	}
 
-    /** Set whether the text field is selectable.
+	/**
+	 * Set whether the text field is read-only.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is read-only.
+	 */
+	public void setReadOnly(boolean aFlag)
+	{
+		readOnly = aFlag;
+	}
 
-        @param aFlag set whether the text field is selectable.
-        */
-    public void setSelectable(boolean aFlag)
-    {
-        selectable = !aFlag;
-    }
+	/**
+	 * Set whether the text field is selectable.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is selectable.
+	 */
+	public void setSelectable(boolean aFlag)
+	{
+		selectable = !aFlag;
+	}
 
-    /** Set whether the text field is bordered.
+	/**
+	 * Set whether the text field is bordered.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is bordered.
+	 */
+	public void setBordered(boolean aFlag)
+	{
+		bordered = aFlag;
+	}
 
-        @param aFlag set whether the text field is bordered.
-        */
-    public void setBordered(boolean aFlag)
-    {
-        bordered = aFlag;
-    }
+	/**
+	 * Set whether the text field contains HTML.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field contains HTML.
+	 */
+	public void setHTML(boolean aFlag)
+	{
+		html = aFlag;
+	}
 
-    /** Set whether the text field contains HTML.
+	/**
+	 * Set whether the text field characters are displayed using the font
+	 * defined in the movie or whether the Flash Player uses a font definition
+	 * loaded from the platform on which it is hosted.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field characters will be drawn using the
+	 *            font in the movie (true) or use a font loaded by the Flash
+	 *            Player (false).
+	 */
+	public void setUseFontGlyphs(boolean aFlag)
+	{
+		useFontGlyphs = aFlag;
+	}
 
-        @param aFlag set whether the text field contains HTML.
-        */
-    public void setHTML(boolean aFlag)
-    {
-        html = aFlag;
-    }
+	/**
+	 * Sets the identifier of the font used to display the characters.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier for the font that the text will be rendered in.
+	 */
+	public void setFontIdentifier(int anIdentifier)
+	{
+		fontIdentifier = anIdentifier;
+	}
 
-    /** 
-     * Set whether the text field characters are displayed using the font defined in the movie 
-     * or whether the Flash Player uses a font definition loaded from the platform on which it 
-     * is hosted.
-     *
-     * @param aFlag set whether the text field characters will be drawn using the font in the 
-     * movie (true) or use a font loaded by the Flash Player (false).
-        */
-    public void setUseFontGlyphs(boolean aFlag)
-    {
-        useFontGlyphs = aFlag;
-    }
+	/**
+	 * Sets the height of the characters.
+	 * 
+	 * @param aNumber
+	 *            the height of the font.
+	 */
+	public void setFontHeight(int aNumber)
+	{
+		fontHeight = aNumber;
+	}
 
-    /** Sets the identifier of the font used to display the characters.
+	/**
+	 * Sets the text color. If set to null then the text color defaults to
+	 * black.
+	 * 
+	 * @param aColor
+	 *            the colour object that defines the text colour.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-        @param anIdentifier the identifier for the font that the text will be rendered in.
-        */
-    public void setFontIdentifier(int anIdentifier)
-    {
-        fontIdentifier = anIdentifier;
-    }
+	/**
+	 * Sets the maximum length of the text displayed. May be set to zero if no
+	 * maximum length is defined.
+	 * 
+	 * @param aNumber
+	 *            the maximum number of characters displayed in the field.
+	 */
+	public void setMaxLength(int aNumber)
+	{
+		maxLength = aNumber;
+	}
 
-    /** Sets the height of the characters.
+	/**
+	 * Sets the alignment of the text, either AlignLeft, AlignRight, AlignCenter
+	 * or AlignJustify.
+	 * 
+	 * @param aType
+	 *            the type of alignment.
+	 */
+	public void setAlignment(int aType)
+	{
+		alignment = aType;
+	}
 
-        @param aNumber the height of the font.
-        */
-    public void setFontHeight(int aNumber)
-    {
-        fontHeight = aNumber;
-    }
+	/**
+	 * Sets the left margin in twips.
+	 * 
+	 * @param aNumber
+	 *            the width of the left margin.
+	 */
+	public void setLeftMargin(int aNumber)
+	{
+		leftMargin = aNumber;
+	}
 
-    /** Sets the text color. If set to null then the text color defaults to black.
+	/**
+	 * Sets the right margin in twips.
+	 * 
+	 * @param aNumber
+	 *            the width of the right margin.
+	 */
+	public void setRightMargin(int aNumber)
+	{
+		rightMargin = aNumber;
+	}
 
-        @param aColor the colour object that defines the text colour.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+	/**
+	 * Gets the indentation of the first line of text in twips.
+	 * 
+	 * @param aNumber
+	 *            the indentation for the first line.
+	 */
+	public void setIndent(int aNumber)
+	{
+		indent = aNumber;
+	}
 
-    /** Sets the maximum length of the text displayed. May be set to zero if no maximum length is defined.
+	/**
+	 * Sets the leading in twips.
+	 * 
+	 * @param aNumber
+	 *            the value for the leading.
+	 */
+	public void setLeading(int aNumber)
+	{
+		leading = aNumber;
+	}
 
-        @param aNumber the maximum number of characters displayed in the field.
-        */
-    public void setMaxLength(int aNumber)
-    {
-        maxLength = aNumber;
-    }
+	/**
+	 * Sets the name of the variable the value in the text field will be
+	 * assigned to.
+	 * 
+	 * @param aString
+	 *            the name of the variable.
+	 */
+	public void setVariableName(String aString)
+	{
+		variableName = aString;
+	}
 
-    /** Sets the alignment of the text, either AlignLeft, AlignRight, AlignCenter or AlignJustify.
+	/**
+	 * Sets the value that will initially be displayed in the text field.
+	 * 
+	 * @param aString
+	 *            the initial text displayed.
+	 */
+	public void setInitialText(String aString)
+	{
+		initialText = aString;
+	}
 
-        @param aType the type of alignment.
-        */
-    public void setAlignment(int aType)
-    {
-        alignment = aType;
-    }
+	/**
+	 * Sets the attributes for the object. The Hashtable contains a list of
+	 * key-value pairs. The key is one of the pre-defined attribute names while
+	 * the value is an instance of a wrapper class (Boolean, Integer or String)
+	 * that will be assigned to the specified attribute.
+	 * 
+	 * @param attributes
+	 *            the list of attributes for the object.
+	 */
+	public void setAttributes(Hashtable attributes)
+	{
+		if (attributes.get(WordWrapped) != null)
+			setWordWrapped(((Boolean) attributes.get(WordWrapped))
+							.booleanValue());
+		if (attributes.get(Multiline) != null)
+			setMultiline(((Boolean) attributes.get(Multiline)).booleanValue());
+		if (attributes.get(Password) != null)
+			setPassword(((Boolean) attributes.get(Password)).booleanValue());
+		if (attributes.get(ReadOnly) != null)
+			setReadOnly(((Boolean) attributes.get(ReadOnly)).booleanValue());
+		if (attributes.get(Selectable) != null)
+			setSelectable(((Boolean) attributes.get(Selectable)).booleanValue());
+		if (attributes.get(Bordered) != null)
+			setBordered(((Boolean) attributes.get(Bordered)).booleanValue());
+		if (attributes.get(HTML) != null)
+			setHTML(((Boolean) attributes.get(HTML)).booleanValue());
+		// Flash 6
+		if (attributes.get(AutoSize) != null)
+			setAutoSize(((Boolean) attributes.get(AutoSize)).booleanValue());
+		// End Flash 6
+		if (attributes.get(UseFontGlyphs) != null)
+			setUseFontGlyphs(((Boolean) attributes.get(UseFontGlyphs))
+							.booleanValue());
+		if (attributes.get(FontIdentifier) != null)
+			setFontIdentifier(((Integer) attributes.get(FontIdentifier))
+							.intValue());
+		if (attributes.get(FontHeight) != null)
+			setFontHeight(((Integer) attributes.get(FontHeight)).intValue());
+		if (attributes.get(Color) != null)
+			setColor((FSColor) attributes.get(Color));
+		if (attributes.get(MaxLength) != null)
+			setMaxLength(((Integer) attributes.get(MaxLength)).intValue());
+		if (attributes.get(LeftMargin) != null)
+			setLeftMargin(((Integer) attributes.get(LeftMargin)).intValue());
+		if (attributes.get(RightMargin) != null)
+			setRightMargin(((Integer) attributes.get(RightMargin)).intValue());
+		if (attributes.get(Indent) != null)
+			setIndent(((Integer) attributes.get(Indent)).intValue());
+		if (attributes.get(Leading) != null)
+			setLeading(((Integer) attributes.get(Leading)).intValue());
+		if (attributes.get(VariableName) != null)
+			setVariableName((String) attributes.get(VariableName));
+		if (attributes.get(InitialText) != null)
+			setInitialText((String) attributes.get(InitialText));
+	}
 
-    /** Sets the left margin in twips.
+	public Object clone()
+	{
+		FSDefineTextField anObject = (FSDefineTextField) super.clone();
 
-        @param aNumber the width of the left margin.
-        */
-    public void setLeftMargin(int aNumber)
-    {
-        leftMargin = aNumber;
-    }
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-    /** Sets the right margin in twips.
+		return anObject;
+	}
 
-        @param aNumber the width of the right margin.
-        */
-    public void setRightMargin(int aNumber)
-    {
-        rightMargin = aNumber;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the indentation of the first line of text in twips.
+		if (super.equals(anObject))
+		{
+			FSDefineTextField typedObject = (FSDefineTextField) anObject;
 
-        @param aNumber the indentation for the first line.
-        */
-    public void setIndent(int aNumber)
-    {
-        indent = aNumber;
-    }
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-    /** Sets the leading in twips.
+			result = result &amp;&amp; wordWrapped == typedObject.wordWrapped;
+			result = result &amp;&amp; multiline == typedObject.multiline;
+			result = result &amp;&amp; password == typedObject.password;
+			result = result &amp;&amp; readOnly == typedObject.readOnly;
+			result = result &amp;&amp; reserved1 == typedObject.reserved1;
+			// Flash 6
+			result = result &amp;&amp; autoSize == typedObject.autoSize;
+			// End Flash 6
+			result = result &amp;&amp; selectable == typedObject.selectable;
+			result = result &amp;&amp; bordered == typedObject.bordered;
+			result = result &amp;&amp; reserved2 == typedObject.reserved2;
+			result = result &amp;&amp; html == typedObject.html;
+			result = result &amp;&amp; useFontGlyphs == typedObject.useFontGlyphs;
+			result = result &amp;&amp; fontIdentifier == typedObject.fontIdentifier;
+			result = result &amp;&amp; fontHeight == typedObject.fontHeight;
 
-        @param aNumber the value for the leading.
-        */
-    public void setLeading(int aNumber)
-    {
-        leading = aNumber;
-    }
+			if (color != null)
+				result = result &amp;&amp; color.equals(typedObject.color);
+			else
+				result = result &amp;&amp; color == typedObject.color;
 
-    /** Sets the name of the variable the value in the text field will be assigned to.
+			result = result &amp;&amp; maxLength == typedObject.maxLength;
 
-        @param aString the name of the variable.
-        */
-    public void setVariableName(String aString)
-    {
-        variableName = aString;
-    }
+			if (containsLayoutInfo())
+			{
+				result = result &amp;&amp; alignment == typedObject.alignment;
+				result = result &amp;&amp; leftMargin == typedObject.leftMargin;
+				result = result &amp;&amp; rightMargin == typedObject.rightMargin;
+				result = result &amp;&amp; indent == typedObject.indent;
+				result = result &amp;&amp; leading == typedObject.leading;
+			}
 
-    /** Sets the value that will initially be displayed in the text field.
+			if (variableName != null)
+				result = result
+								&amp;&amp; variableName
+												.equals(typedObject.variableName);
+			else
+				result = result &amp;&amp; variableName == typedObject.variableName;
 
-        @param aString the initial text displayed.
-        */
-    public void setInitialText(String aString)
-    {
-        initialText = aString;
-    }
+			if (initialText != null)
+				result = result &amp;&amp; initialText.equals(typedObject.initialText);
+			else
+				result = result &amp;&amp; initialText == typedObject.initialText;
+		}
+		return result;
+	}
 
-    /** Sets the attributes for the object. The Hashtable contains a list of key-value pairs. The key is one of the pre-defined attribute names while the value is an instance of a wrapper class (Boolean, Integer or String) that will be assigned to the specified attribute.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param attributes the list of attributes for the object.
-        */
-    public void setAttributes(Hashtable attributes)
-    {
-        if (attributes.get(WordWrapped) != null)
-            setWordWrapped(((Boolean)attributes.get(WordWrapped)).booleanValue());
-        if (attributes.get(Multiline) != null)
-            setMultiline(((Boolean)attributes.get(Multiline)).booleanValue());
-        if (attributes.get(Password) != null)
-            setPassword(((Boolean)attributes.get(Password)).booleanValue());
-        if (attributes.get(ReadOnly) != null)
-            setReadOnly(((Boolean)attributes.get(ReadOnly)).booleanValue());
-        if (attributes.get(Selectable) != null)
-            setSelectable(((Boolean)attributes.get(Selectable)).booleanValue());
-        if (attributes.get(Bordered) != null)
-            setBordered(((Boolean)attributes.get(Bordered)).booleanValue());
-        if (attributes.get(HTML) != null)
-            setHTML(((Boolean)attributes.get(HTML)).booleanValue());
-// Flash 6
-        if (attributes.get(AutoSize) != null)
-            setAutoSize(((Boolean)attributes.get(AutoSize)).booleanValue());
-// End Flash 6
-        if (attributes.get(UseFontGlyphs) != null)
-            setUseFontGlyphs(((Boolean)attributes.get(UseFontGlyphs)).booleanValue());
-        if (attributes.get(FontIdentifier) != null)
-            setFontIdentifier(((Integer)attributes.get(FontIdentifier)).intValue());
-        if (attributes.get(FontHeight) != null)
-            setFontHeight(((Integer)attributes.get(FontHeight)).intValue());
-        if (attributes.get(Color) != null)
-            setColor((FSColor)attributes.get(Color));
-        if (attributes.get(MaxLength) != null)
-            setMaxLength(((Integer)attributes.get(MaxLength)).intValue());
-        if (attributes.get(LeftMargin) != null)
-            setLeftMargin(((Integer)attributes.get(LeftMargin)).intValue());
-        if (attributes.get(RightMargin) != null)
-            setRightMargin(((Integer)attributes.get(RightMargin)).intValue());
-        if (attributes.get(Indent) != null)
-            setIndent(((Integer)attributes.get(Indent)).intValue());
-        if (attributes.get(Leading) != null)
-            setLeading(((Integer)attributes.get(Leading)).intValue());
-        if (attributes.get(VariableName) != null)
-            setVariableName((String)attributes.get(VariableName));
-        if (attributes.get(InitialText) != null)
-            setInitialText((String)attributes.get(InitialText));
-    }
+		buffer.append(&quot;FSDefineTextField: { &quot;);
+		buffer.append(&quot;bounds = &quot;).append(bounds.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;wordWrapped = &quot;).append(wordWrapped).append(&quot;; &quot;);
+		buffer.append(&quot;multiline = &quot;).append(multiline).append(&quot;; &quot;);
+		buffer.append(&quot;password = &quot;).append(password).append(&quot;; &quot;);
+		buffer.append(&quot;readOnly = &quot;).append(readOnly).append(&quot;; &quot;);
+		// Flash 6
+		buffer.append(&quot;autoSize = &quot;).append(autoSize).append(&quot;; &quot;);
+		// End Flash 6
+		buffer.append(&quot;selectable = &quot;).append(selectable).append(&quot;; &quot;);
+		buffer.append(&quot;bordered = &quot;).append(bordered).append(&quot;; &quot;);
+		buffer.append(&quot;HTML = &quot;).append(html).append(&quot;; &quot;);
+		buffer.append(&quot;useFontGlyphs = &quot;).append(useFontGlyphs).append(&quot;; &quot;);
+		buffer.append(&quot;fontIdentifier = &quot;).append(fontIdentifier).append(&quot;;&quot;);
+		buffer.append(&quot;fontHeight = &quot;).append(fontHeight).append(&quot;; &quot;);
+		buffer.append(&quot;color = &quot;).append(color.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;maxLength = &quot;).append(maxLength).append(&quot;; &quot;);
+		buffer.append(&quot;alignment = &quot;).append(alignment).append(&quot;; &quot;);
+		buffer.append(&quot;leftMargin = &quot;).append(leftMargin).append(&quot;; &quot;);
+		buffer.append(&quot;rightMargin = &quot;).append(rightMargin).append(&quot;; &quot;);
+		buffer.append(&quot;indent = &quot;).append(indent).append(&quot;; &quot;);
+		buffer.append(&quot;leading = &quot;).append(leading).append(&quot;; &quot;);
+		buffer.append(&quot;variableName = &quot;).append(variableName).append(&quot;; &quot;);
+		buffer.append(&quot;initalText = &quot;).append(initialText).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    public Object clone()
-    {
-        FSDefineTextField anObject = (FSDefineTextField)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
+		return buffer.toString();
+	}
 
-        return anObject;
-    }
+	public int length(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsMaxLength = containsMaxLength();
+		boolean _containsText = containsText();
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineTextField typedObject = (FSDefineTextField)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		super.length(coder);
 
-            result = result &amp;&amp; wordWrapped == typedObject.wordWrapped;
-            result = result &amp;&amp; multiline == typedObject.multiline;
-            result = result &amp;&amp; password == typedObject.password;
-            result = result &amp;&amp; readOnly == typedObject.readOnly;
-            result = result &amp;&amp; reserved1 == typedObject.reserved1;
-// Flash 6
-            result = result &amp;&amp; autoSize == typedObject.autoSize;
-// End Flash 6
-            result = result &amp;&amp; selectable == typedObject.selectable;
-            result = result &amp;&amp; bordered == typedObject.bordered;
-            result = result &amp;&amp; reserved2 == typedObject.reserved2;
-            result = result &amp;&amp; html == typedObject.html;
-            result = result &amp;&amp; useFontGlyphs == typedObject.useFontGlyphs;
-            result = result &amp;&amp; fontIdentifier == typedObject.fontIdentifier;
-            result = result &amp;&amp; fontHeight == typedObject.fontHeight;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
+		length += bounds.length(coder);
+		length += 2;
+		length += (_containsFont) ? 4 : 0;
+		length += (_containsColor) ? color.length(coder) : 0;
+		length += (_containsMaxLength) ? 2 : 0;
+		length += (containsLayoutInfo()) ? 9 : 0;
+		length += coder.strlen(variableName, true);
+		length += (_containsText) ? coder.strlen(initialText, true) : 0;
 
-            result = result &amp;&amp; maxLength == typedObject.maxLength;
-            
-            if (containsLayoutInfo())
-            {
-                result = result &amp;&amp; alignment == typedObject.alignment;
-                result = result &amp;&amp; leftMargin == typedObject.leftMargin;
-                result = result &amp;&amp; rightMargin == typedObject.rightMargin;
-                result = result &amp;&amp; indent == typedObject.indent;
-                result = result &amp;&amp; leading == typedObject.leading;
-            }
+		coder.context[FSCoder.TransparentColors] = 0;
 
-            if (variableName != null)
-                result = result &amp;&amp; variableName.equals(typedObject.variableName);
-            else
-                result = result &amp;&amp; variableName == typedObject.variableName;
-                
-            if (initialText != null)
-                result = result &amp;&amp; initialText.equals(typedObject.initialText);
-            else
-                result = result &amp;&amp; initialText == typedObject.initialText;
-       }
-        return result;
-    }
+		return length;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;wordWrapped&quot;, wordWrapped);
-            Transform.append(buffer, &quot;multiline&quot;, multiline);
-            Transform.append(buffer, &quot;password&quot;, password);
-            Transform.append(buffer, &quot;readOnly&quot;, readOnly);
-// Flash 6
-            Transform.append(buffer, &quot;autoSize&quot;, autoSize);
-// End Flash 6
-            Transform.append(buffer, &quot;selectable&quot;, selectable);
-            Transform.append(buffer, &quot;bordered&quot;, bordered);
-            Transform.append(buffer, &quot;HTML&quot;, html);
-            Transform.append(buffer, &quot;useFontGlyphs&quot;, useFontGlyphs);
-            Transform.append(buffer, &quot;fontIdentifier&quot;, fontIdentifier);
-            Transform.append(buffer, &quot;fontHeight&quot;, fontHeight);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            Transform.append(buffer, &quot;maxLength&quot;, maxLength);
-            Transform.append(buffer, &quot;alignment&quot;, alignment);
-            Transform.append(buffer, &quot;leftMargin&quot;, leftMargin);
-            Transform.append(buffer, &quot;rightMargin&quot;, rightMargin);
-            Transform.append(buffer, &quot;indent&quot;, indent);
-            Transform.append(buffer, &quot;leading&quot;, leading);
-            Transform.append(buffer, &quot;variableName&quot;, variableName);
-            Transform.append(buffer, &quot;initalText&quot;, initialText);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void encode(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsMaxLength = containsMaxLength();
+		boolean _containsText = containsText();
 
-    public int length(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsMaxLength = containsMaxLength();
-        boolean _containsText = containsText();
-        
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+		super.encode(coder);
 
-        length += bounds.length(coder);
-        length += 2;
-        length += (_containsFont) ? 4 : 0;
-        length += (_containsColor) ? color.length(coder) : 0;
-        length += (_containsMaxLength) ? 2 : 0;
-        length += (containsLayoutInfo()) ? 9 : 0;
-        length += coder.strlen(variableName, true);
-        length += (_containsText) ? coder.strlen(initialText, true) : 0;
-        
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsMaxLength = containsMaxLength();
-        boolean _containsText = containsText();
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        bounds.encode(coder);
-        coder.writeBits(_containsText ? 1 : 0, 1);
-        coder.writeBits(wordWrapped ? 1 : 0, 1);
-        coder.writeBits(multiline ? 1 : 0, 1);
-        coder.writeBits(password ? 1 : 0, 1);
-        coder.writeBits(readOnly ? 1 : 0, 1);
-        coder.writeBits(_containsColor ? 1 : 0, 1);
-        coder.writeBits(_containsMaxLength ? 1 : 0, 1);
-        coder.writeBits(_containsFont ? 1 : 0, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(autoSize ? 1 : 0, 1);
-        coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
-        coder.writeBits(selectable ? 1 : 0, 1);
-        coder.writeBits(bordered ? 1 : 0, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(html ? 1 : 0, 1);
-        coder.writeBits(useFontGlyphs ? 1 : 0, 1);
-    
-        if (_containsFont)
-        {
-            coder.writeWord(fontIdentifier, 2);
-            coder.writeWord(fontHeight, 2);
-        }
-    
-        if (_containsColor)
-            color.encode(coder);
-    
-        if (_containsMaxLength)
-            coder.writeWord(maxLength, 2);
-    
-        if (containsLayoutInfo())
-        {
-            coder.writeWord((alignment != Transform.VALUE_NOT_SET) ? alignment : 0, 1);
-            coder.writeWord((leftMargin != Transform.VALUE_NOT_SET) ? leftMargin : 0, 2);
-            coder.writeWord((rightMargin != Transform.VALUE_NOT_SET) ? rightMargin : 0, 2);
-            coder.writeWord((indent != Transform.VALUE_NOT_SET) ? indent : 0, 2);
-            coder.writeWord((leading != Transform.VALUE_NOT_SET) ? leading : 0, 2);
-        }
-    
-        coder.writeString(variableName);
-        coder.writeWord(0, 1);
-    
-        if (_containsText)
-        {
-            coder.writeString(initialText);
-            coder.writeWord(0, 1);
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean _containsFont = false;
-        boolean _containsColor = false;
-        boolean _containsMaxLength = false;
-        boolean _containsText = false;
-        boolean _containsLayout = false;
+		bounds.encode(coder);
+		coder.writeBits(_containsText ? 1 : 0, 1);
+		coder.writeBits(wordWrapped ? 1 : 0, 1);
+		coder.writeBits(multiline ? 1 : 0, 1);
+		coder.writeBits(password ? 1 : 0, 1);
+		coder.writeBits(readOnly ? 1 : 0, 1);
+		coder.writeBits(_containsColor ? 1 : 0, 1);
+		coder.writeBits(_containsMaxLength ? 1 : 0, 1);
+		coder.writeBits(_containsFont ? 1 : 0, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(autoSize ? 1 : 0, 1);
+		coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
+		coder.writeBits(selectable ? 1 : 0, 1);
+		coder.writeBits(bordered ? 1 : 0, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(html ? 1 : 0, 1);
+		coder.writeBits(useFontGlyphs ? 1 : 0, 1);
 
-        super.decode(coder);
+		if (_containsFont)
+		{
+			coder.writeWord(fontIdentifier, 2);
+			coder.writeWord(fontHeight, 2);
+		}
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		if (_containsColor)
+			color.encode(coder);
 
-        bounds = new FSBounds(coder);
+		if (_containsMaxLength)
+			coder.writeWord(maxLength, 2);
 
-        _containsText = coder.readBits(1, false) != 0 ? true : false;
-        wordWrapped = coder.readBits(1, false) != 0 ? true : false;
-        multiline = coder.readBits(1, false) != 0 ? true : false;
-        password = coder.readBits(1, false) != 0 ? true : false;
-        readOnly = coder.readBits(1, false) != 0 ? true : false;
-        _containsColor = coder.readBits(1, false) != 0 ? true : false;
-        _containsMaxLength = coder.readBits(1, false) != 0 ? true : false;
-        _containsFont = coder.readBits(1, false) != 0 ? true : false;
-        reserved1 = coder.readBits(1, false);
-        autoSize = coder.readBits(1, false) != 0 ? true : false;
-        _containsLayout = coder.readBits(1, false) != 0 ? true : false;
-        selectable = coder.readBits(1, false) != 0 ? true : false;
-        bordered = coder.readBits(1, false) != 0 ? true : false;
-        reserved2 = coder.readBits(1, false) != 0 ? true : false;
-        html = coder.readBits(1, false) != 0 ? true : false;
-        useFontGlyphs = coder.readBits(1, false) != 0 ? true : false;
-        
-        if (_containsFont)
-        {
-             fontIdentifier = coder.readWord(2, false);
-             fontHeight = coder.readWord(2, false);
-        }
+		if (containsLayoutInfo())
+		{
+			coder.writeWord((alignment != Transform.VALUE_NOT_SET) ? alignment
+							: 0, 1);
+			coder
+							.writeWord(
+											(leftMargin != Transform.VALUE_NOT_SET) ? leftMargin
+															: 0, 2);
+			coder
+							.writeWord(
+											(rightMargin != Transform.VALUE_NOT_SET) ? rightMargin
+															: 0, 2);
+			coder
+							.writeWord(
+											(indent != Transform.VALUE_NOT_SET) ? indent
+															: 0, 2);
+			coder.writeWord((leading != Transform.VALUE_NOT_SET) ? leading : 0,
+							2);
+		}
 
-        if (_containsColor)
-            color = new FSColor(coder);
+		coder.writeString(variableName);
+		coder.writeWord(0, 1);
 
-        if (_containsMaxLength)
-            maxLength = coder.readWord(2, false);
+		if (_containsText)
+		{
+			coder.writeString(initialText);
+			coder.writeWord(0, 1);
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 
-        if (_containsLayout)
-        {
-            alignment = coder.readWord(1, false);
-            leftMargin = coder.readWord(2, false);
-            rightMargin = coder.readWord(2, false);
-            indent = coder.readWord(2, false);
-            leading = coder.readWord(2, true);
-        }
+	public void decode(FSCoder coder)
+	{
+		boolean _containsFont = false;
+		boolean _containsColor = false;
+		boolean _containsMaxLength = false;
+		boolean _containsText = false;
+		boolean _containsLayout = false;
 
-        variableName = coder.readString();
+		super.decode(coder);
 
-        if (_containsText)
-            initialText = coder.readString();
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    private boolean containsColor()
-    {
-        return color != null;
-    }
-    
-    private boolean containsFont()
-    {
-        return fontIdentifier != 0 &amp;&amp; fontHeight != 0;
-    }
-    
-    private boolean containsMaxLength()
-    {
-        return maxLength &gt; 0;
-    }
-    
-    private boolean containsLayoutInfo()
-    {
-        boolean layout = false;
-        
-        layout = alignment != Transform.VALUE_NOT_SET;
-        layout = layout || leftMargin != Transform.VALUE_NOT_SET;
-        layout = layout || rightMargin != Transform.VALUE_NOT_SET;
-        layout = layout || indent != Transform.VALUE_NOT_SET;
-        layout = layout || leading != Transform.VALUE_NOT_SET;
-        
-        return layout;
-    }
+		bounds = new FSBounds(coder);
 
-    private boolean containsText()
-    {
-        return initialText != null &amp;&amp; initialText.length() &gt; 0;
-    }    
+		_containsText = coder.readBits(1, false) != 0 ? true : false;
+		wordWrapped = coder.readBits(1, false) != 0 ? true : false;
+		multiline = coder.readBits(1, false) != 0 ? true : false;
+		password = coder.readBits(1, false) != 0 ? true : false;
+		readOnly = coder.readBits(1, false) != 0 ? true : false;
+		_containsColor = coder.readBits(1, false) != 0 ? true : false;
+		_containsMaxLength = coder.readBits(1, false) != 0 ? true : false;
+		_containsFont = coder.readBits(1, false) != 0 ? true : false;
+		reserved1 = coder.readBits(1, false);
+		autoSize = coder.readBits(1, false) != 0 ? true : false;
+		_containsLayout = coder.readBits(1, false) != 0 ? true : false;
+		selectable = coder.readBits(1, false) != 0 ? true : false;
+		bordered = coder.readBits(1, false) != 0 ? true : false;
+		reserved2 = coder.readBits(1, false) != 0 ? true : false;
+		html = coder.readBits(1, false) != 0 ? true : false;
+		useFontGlyphs = coder.readBits(1, false) != 0 ? true : false;
+
+		if (_containsFont)
+		{
+			fontIdentifier = coder.readWord(2, false);
+			fontHeight = coder.readWord(2, false);
+		}
+
+		if (_containsColor)
+			color = new FSColor(coder);
+
+		if (_containsMaxLength)
+			maxLength = coder.readWord(2, false);
+
+		if (_containsLayout)
+		{
+			alignment = coder.readByte();
+			leftMargin = coder.readWord(2, false);
+			rightMargin = coder.readWord(2, false);
+			indent = coder.readWord(2, false);
+			leading = coder.readWord(2, true);
+		}
+
+		variableName = coder.readString();
+
+		if (_containsText)
+			initialText = coder.readString();
+
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
+
+	private boolean containsColor()
+	{
+		return color != null;
+	}
+
+	private boolean containsFont()
+	{
+		return fontIdentifier != 0 &amp;&amp; fontHeight != 0;
+	}
+
+	private boolean containsMaxLength()
+	{
+		return maxLength &gt; 0;
+	}
+
+	private boolean containsLayoutInfo()
+	{
+		boolean layout = false;
+
+		layout = alignment != Transform.VALUE_NOT_SET;
+		layout = layout || leftMargin != Transform.VALUE_NOT_SET;
+		layout = layout || rightMargin != Transform.VALUE_NOT_SET;
+		layout = layout || indent != Transform.VALUE_NOT_SET;
+		layout = layout || leading != Transform.VALUE_NOT_SET;
+
+		return layout;
+	}
+
+	private boolean containsText()
+	{
+		return initialText != null &amp;&amp; initialText.length() &gt; 0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDefineVideo.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDefineVideo.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDefineVideo.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -34,355 +34,404 @@
 import java.util.Iterator;
 
 /**
-The FSDefineVideo class is used to display video within a Flash file. 
- 
-&lt;p&gt;Video objects contain a unique identifier and are treated in the same way as shapes, buttons, images, etc. The video data displayed is define using the FSVideoFrame class. Each frame of video is displayed whenever display list is updated using the FSShowFrame object - any timing information stored within the video data is ignored.&lt;/p&gt;
+ * The FSDefineVideo class is used to display video within a Flash file.
+ * 
+ * &lt;p&gt;
+ * Video objects contain a unique identifier and are treated in the same way as
+ * shapes, buttons, images, etc. The video data displayed is define using the
+ * FSVideoFrame class. Each frame of video is displayed whenever display list is
+ * updated using the FSShowFrame object - any timing information stored within
+ * the video data is ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * An FSDefineVideo is defined with the following information:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the video from other objects, e.g. when adding or removing from the display
+ * list.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameCount&lt;/td&gt;
+ * &lt;td&gt;The number of frames that will be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;width&lt;/td&gt;
+ * &lt;td&gt;Width of each frame in pixels&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;Height of each frame in pixels.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;deblocking&lt;/td&gt;
+ * &lt;td&gt;Whether a filter is used when assembling the blocks of video data into a
+ * frame. This may be set to Off to turn off the deblock filter in the Flash
+ * Player; On to turn on the Flash Player's filter or UseVideo to allow the
+ * video data to specify whether the deblocking filter is used.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;smoothing&lt;/td&gt;
+ * &lt;td&gt;Controls whether the Flash Player performs smoothing to increase the
+ * quality of the image displayed albeit at the price of performance.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr &gt;
+ * &lt;td&gt;codec&lt;/td&gt;
+ * &lt;td&gt;Identifies the format of the video data either FSDefineVideo.H263 for
+ * data encoded using the Sorenson modified H263 format or
+ * FSDefineVideo.ScreenVideo for data encoded using Macromedia's Screen Video
+ * format.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The ScreenVideo format was introduced in Flash 7, only the H263 format was
+ * supported in Flash 6.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineVideo class represents the DefineVideo of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 6. The
+ * ScreenVideo format was introduced in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSDefineVideo extends FSDefineObject
+{
+	// / The video data was encoded using the Sorenson modified H263 format.
+	public static final int H263 = 2;
 
-&lt;p&gt;An FSDefineVideo is defined with the following information:&lt;/p&gt;
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+	// Flash 7
+	// / The video data was encoded using Macromedia's ScreenVideo format.
+	public static final int ScreenVideo = 3;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	// End Flash 7
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Instruct the Flash Player to use the deblocking value specified in the
+	 * video data.
+	 */
+	public static final int UseVideo = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the video 
-from other objects, e.g. when adding or removing from the display list.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Instruct the Flash Player to turn the deblocking filter off. */
+	public static final int Off = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_2&quot;&gt;frameCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of frames that will be displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Instruct the Flash Player to turn the deblocking filter on. */
+	public static final int On = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_3&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Width of each frame in pixels&lt;/td&gt;
-&lt;/tr&gt;
+	private int frameCount = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_4&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Height of each frame in pixels.&lt;/td&gt;
-&lt;/tr&gt;
+	private int width = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_5&quot;&gt;deblocking&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether a filter is used when assembling the blocks of video data into a frame. 
-This may be set to Off to turn off the deblock filter in the Flash Player; On to 
-turn on the Flash Player's filter or UseVideo to allow the video data to specify 
-whether the deblocking filter is used.&lt;/td&gt;
-&lt;/tr&gt;
+	private int height = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_6&quot;&gt;smoothing&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Controls whether the Flash Player performs smoothing to increase the quality 
-of the image displayed albeit at the price of performance.&lt;/td&gt;
-&lt;/tr&gt;
+	private int deblocking = 0;
 
-&lt;tr
-&gt;&lt;td&gt;&lt;a name=&quot;FSDefineVideo_7&quot;&gt;codec&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the format of the video data either FSDefineVideo.H263 for data encoded 
-using the Sorenson modified H263 format or FSDefineVideo.ScreenVideo for data 
-encoded using Macromedia's Screen Video format.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	private boolean smoothing = false;
 
-&lt;p&gt;The ScreenVideo format was introduced in Flash 7, only the H263 format was supported in Flash 6.&lt;/p&gt;
+	private int codec = 0;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Construct an FSDefineVideo object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineVideo(FSCoder coder)
+	{
+		super(DefineVideo, 0);
+		decode(coder);
+	}
 
-&lt;p&gt;The FSDefineVideo class represents the DefineVideo of the Macromedia Flash (SWF) 
-File Format Specification. It was introduced in Flash 6. The ScreenVideo format 
-was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSDefineVideo extends FSDefineObject
-{
-    /// The video data was encoded using the Sorenson modified H263 format.
-    public static final int H263 = 2;
-    
-// Flash 7
-    /// The video data was encoded using Macromedia's ScreenVideo format.
-    public static final int ScreenVideo = 3;
-// End Flash 7
-    
-/** Instruct the Flash Player to use the deblocking value specified in the video data. */
-    public static final int UseVideo = 0;
-/** Instruct the Flash Player to turn the deblocking filter off. */
-    public static final int Off = 1;
-/** Instruct the Flash Player to turn the deblocking filter on. */
-    public static final int On  = 2;
-    
-    private int frameCount = 0;
-    private int width = 0;
-    private int height = 0;
-    private int deblocking = 0;
-    private boolean smoothing = false;
-    private int codec = 0;
+	/**
+	 * Constructs an FSDefineVideo object with the specified parameters.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param count
+	 *            the number of video frames.
+	 * @param width
+	 *            the width of each frame in pixels.
+	 * @param height
+	 *            the height of each frame in pixels.
+	 * @param deblocking
+	 *            controls whether the Flash Player's deblocking filter is used,
+	 *            either Off, On or UseVideo to allow the video data to specify
+	 *            whether the deblocking filter is used.
+	 * @param smoothing
+	 *            turns smoothing on or off to improve the quality of the
+	 *            displayed image.
+	 * @param codec
+	 *            the format of the video data. Flash 6 supports
+	 *            FSDefineVideo.H263. Support for Macromedia's ScreenVideo
+	 *            format was added in Flash 7.
+	 */
+	public FSDefineVideo(int anIdentifier, int count, int width, int height,
+							int deblocking, boolean smoothing, int codec)
+	{
+		super(DefineVideo, anIdentifier);
+		setFrameCount(count);
+		setWidth(width);
+		setHeight(height);
+		setDeblocking(deblocking);
+		setSmoothing(smoothing);
+		setCodec(codec);
+	}
 
-    /**
-     * Construct an FSDefineVideo object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineVideo(FSCoder coder)
-    {
-        super(DefineVideo, 0);
-        decode(coder);
-    }
-    /**
-     * Constructs an FSDefineVideo object with the specified parameters.
-     *
-     * @param anIdentifier the unique identifier for this object
-     * @param count the number of video frames.
-     * @param width the width of each frame in pixels.
-     * @param height the height of each frame in pixels.
-     * @param deblocking controls whether the Flash Player's deblocking filter is used, either Off, On or UseVideo to allow the video data to specify whether the deblocking filter is used. 
-     * @param smoothing turns smoothing on or off to improve the quality of the displayed image.
-     * @param codec the format of the video data. Flash 6 supports FSDefineVideo.H263. Support for Macromedia's 
-     * ScreenVideo format was added in Flash 7.
-     */
-    public FSDefineVideo(int anIdentifier, int count, int width, int height, int deblocking, boolean smoothing, int codec)
-    {
-        super(DefineVideo, anIdentifier);
-        setFrameCount(count);
-        setWidth(width);
-        setHeight(height);
-        setDeblocking(deblocking);
-        setSmoothing(smoothing);
-        setCodec(codec);
-    }
-    /**
-     * Constructs an FSDefineVideo object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineVideo object.
-     */
-    public FSDefineVideo(FSDefineVideo obj)
-    {
-        super(obj);
-        frameCount = obj.frameCount;
-        width = obj.width;
-        height = obj.height;
-        deblocking = obj.deblocking;
-        smoothing = obj.smoothing;
-        codec = obj.codec;
-    }    
+	/**
+	 * Constructs an FSDefineVideo object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineVideo object.
+	 */
+	public FSDefineVideo(FSDefineVideo obj)
+	{
+		super(obj);
+		frameCount = obj.frameCount;
+		width = obj.width;
+		height = obj.height;
+		deblocking = obj.deblocking;
+		smoothing = obj.smoothing;
+		codec = obj.codec;
+	}
 
-    /**
-     * Gets the number of frames in the video.
-     * 
-     * @return the number of video frames.
-     */ 
-    public int getFrameCount()
-    {
-        return frameCount;
-    }
+	/**
+	 * Gets the number of frames in the video.
+	 * 
+	 * @return the number of video frames.
+	 */
+	public int getFrameCount()
+	{
+		return frameCount;
+	}
 
-    /**
-     * Sets the number of frames in the video.
-     * 
-     * @param count the number of video frames.
-     */ 
-    public void setFrameCount(int count)
-    {
-        frameCount = count;
-    }
-    
-    /**
-     * Gets the width of each frame in pixels.
-     * 
-     * @return the width of the frame.
-     */ 
-    public int getWidth() 
-    {
-        return width;
-    }
+	/**
+	 * Sets the number of frames in the video.
+	 * 
+	 * @param count
+	 *            the number of video frames.
+	 */
+	public void setFrameCount(int count)
+	{
+		frameCount = count;
+	}
 
-    /**
-     * Sets the width of each frame in pixels.
-     * 
-     * @param width the width of the frame.
-     */ 
-    public void setWidth(int width)
-    {
-        this.width = width;
-    }
-    
-    /**
-     * Gets the height of each frame in pixels.
-     * 
-     * @return the height of the frame.
-     */ 
-    public int getHeight() 
-    {
-        return height;
-    }
+	/**
+	 * Gets the width of each frame in pixels.
+	 * 
+	 * @return the width of the frame.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-    /**
-     * Sets the height of each frame in pixels.
-     * 
-     * @param height the height of the frame.
-     */ 
-    public void setHeight(int height)
-    {
-        this.height = height;
-    }
-    
-    /**
-     * Gets the method used to control the Flash Player's deblocking filter.
-     * 
-     * @return the deblocking filter control, either FSDefineVideo.Off, FSDefineVideo.On or
-     * FSDefineVideo.UseVideo to allow the video data to specify whether the deblocking 
-     * filter is used.
-     */ 
-    public int getDeblocking() 
-    {
-        return deblocking;
-    }
+	/**
+	 * Sets the width of each frame in pixels.
+	 * 
+	 * @param width
+	 *            the width of the frame.
+	 */
+	public void setWidth(int width)
+	{
+		this.width = width;
+	}
 
-    /**
-     * Sets the method used to control the Flash Player's deblocking filter.
-     * 
-     * @param deblocking the deblocking filter control, either FSDefineVideo.Off, FSDefineVideo.On
-     * or FSDefineVideo.UseVideo to allow the video data to specify whether the deblocking filter 
-     * is used.
-     */ 
-    public void setDeblocking(int deblocking)
-    {
-        this.deblocking = deblocking;
-    }
+	/**
+	 * Gets the height of each frame in pixels.
+	 * 
+	 * @return the height of the frame.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-    /**
-     * Gets the method used to control Flash Player's smoothing filter.
-     * 
-     * @return true if smoothing is turned on, false if it is turned off.
-     */
-    public boolean getSmoothing() 
-    {
-        return smoothing;
-    }
+	/**
+	 * Sets the height of each frame in pixels.
+	 * 
+	 * @param height
+	 *            the height of the frame.
+	 */
+	public void setHeight(int height)
+	{
+		this.height = height;
+	}
 
-    /**
-     * Sets the method used to control Flash Player's smoothing filter.
-     * 
-     * @param smoothing true if smoothing is turned on, false if it is turned off.
-     */
-    public void setSmoothing(boolean smoothing)
-    {
-        this.smoothing = smoothing;
-    }
+	/**
+	 * Gets the method used to control the Flash Player's deblocking filter.
+	 * 
+	 * @return the deblocking filter control, either FSDefineVideo.Off,
+	 *         FSDefineVideo.On or FSDefineVideo.UseVideo to allow the video
+	 *         data to specify whether the deblocking filter is used.
+	 */
+	public int getDeblocking()
+	{
+		return deblocking;
+	}
 
-    /**
-     * Get the format used to encode the video data, either FSDefineVideo.H263 for data 
-     * encoded using the Sorenson modified H263 format or FSDefineVideo.ScreenVideo (Flash 7 only) 
-     * for data encoded using Macromedia's Screen Video format.
-     *
-     * @return the codec used to encode the video, either FSDefineVideo.H263 or FSDefineVideo.ScreenVideo.
-     */
-    public int getCodec() 
-    {
-        return codec;
-    }
+	/**
+	 * Sets the method used to control the Flash Player's deblocking filter.
+	 * 
+	 * @param deblocking
+	 *            the deblocking filter control, either FSDefineVideo.Off,
+	 *            FSDefineVideo.On or FSDefineVideo.UseVideo to allow the video
+	 *            data to specify whether the deblocking filter is used.
+	 */
+	public void setDeblocking(int deblocking)
+	{
+		this.deblocking = deblocking;
+	}
 
-    /**
-     * Set the format used to encode the video data, either FSDefineVideo.H263 for data encoded 
-     * using the Sorenson modified H263 format or FSDefineVideo.ScreenVideo (Flash 7 only) for 
-     * data encoded using Macromedia's Screen Video format.
-     *
-     * @param codec the format used encode the video, either FSDefineVideo.H263 or FSDefineVideo.ScreenVideo.
-     */
-    public void setCodec(int codec)
-    {
-        this.codec = codec;
-    }
+	/**
+	 * Gets the method used to control Flash Player's smoothing filter.
+	 * 
+	 * @return true if smoothing is turned on, false if it is turned off.
+	 */
+	public boolean getSmoothing()
+	{
+		return smoothing;
+	}
 
-    public Object clone()
-    {
-        FSDefineVideo anObject = (FSDefineVideo)super.clone();
-        
-        return anObject;
-    }
+	/**
+	 * Sets the method used to control Flash Player's smoothing filter.
+	 * 
+	 * @param smoothing
+	 *            true if smoothing is turned on, false if it is turned off.
+	 */
+	public void setSmoothing(boolean smoothing)
+	{
+		this.smoothing = smoothing;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineVideo typedObject = (FSDefineVideo)anObject;
-            
-            result = frameCount == typedObject.frameCount;
-            result = result &amp;&amp; width == typedObject.width;
-            result = result &amp;&amp; height == typedObject.height;
-            result = result &amp;&amp; deblocking == typedObject.deblocking;
-            result = result &amp;&amp; smoothing == typedObject.smoothing;
-            result = result &amp;&amp; codec == typedObject.codec;
-        }
-        return result;
-    }
+	/**
+	 * Get the format used to encode the video data, either FSDefineVideo.H263
+	 * for data encoded using the Sorenson modified H263 format or
+	 * FSDefineVideo.ScreenVideo (Flash 7 only) for data encoded using
+	 * Macromedia's Screen Video format.
+	 * 
+	 * @return the codec used to encode the video, either FSDefineVideo.H263 or
+	 *         FSDefineVideo.ScreenVideo.
+	 */
+	public int getCodec()
+	{
+		return codec;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	/**
+	 * Set the format used to encode the video data, either FSDefineVideo.H263
+	 * for data encoded using the Sorenson modified H263 format or
+	 * FSDefineVideo.ScreenVideo (Flash 7 only) for data encoded using
+	 * Macromedia's Screen Video format.
+	 * 
+	 * @param codec
+	 *            the format used encode the video, either FSDefineVideo.H263 or
+	 *            FSDefineVideo.ScreenVideo.
+	 */
+	public void setCodec(int codec)
+	{
+		this.codec = codec;
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;frameCount&quot;, frameCount);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;deblocking&quot;, deblocking);
-            Transform.append(buffer, &quot;smoothing&quot;, smoothing);
-            Transform.append(buffer, &quot;codec&quot;, codec);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public Object clone()
+	{
+		FSDefineVideo anObject = (FSDefineVideo) super.clone();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 8;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(frameCount, 2);
-        coder.writeWord(width, 2);
-        coder.writeWord(height, 2);
-        coder.writeBits(0, 5);
-        coder.writeBits(deblocking, 2);
-        coder.writeBits(smoothing ? 1 : 0, 1);
-        coder.writeWord(codec, 1);
+		return anObject;
+	}
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        frameCount = coder.readWord(2, false);
-        width = coder.readWord(2, false);
-        height = coder.readWord(2, false);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        coder.readBits(5, false);
-        deblocking = coder.readBits(2, false);
-        smoothing = coder.readBits(1, false) == 1 ? true : false;
-        
-        codec = coder.readWord(1, false);
+		if (super.equals(anObject))
+		{
+			FSDefineVideo typedObject = (FSDefineVideo) anObject;
 
-        coder.endObject(name());
-    }
+			result = frameCount == typedObject.frameCount;
+			result = result &amp;&amp; width == typedObject.width;
+			result = result &amp;&amp; height == typedObject.height;
+			result = result &amp;&amp; deblocking == typedObject.deblocking;
+			result = result &amp;&amp; smoothing == typedObject.smoothing;
+			result = result &amp;&amp; codec == typedObject.codec;
+		}
+		return result;
+	}
+
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
+
+		buffer.append(&quot;FSDefineVideo: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;frameCount = &quot;).append(frameCount).append(&quot;; &quot;);
+		buffer.append(&quot;width = &quot;).append(width).append(&quot;; &quot;);
+		buffer.append(&quot;height = &quot;).append(height).append(&quot;; &quot;);
+		buffer.append(&quot;deblocking = &quot;).append(deblocking).append(&quot;; &quot;);
+		buffer.append(&quot;smoothing = &quot;).append(smoothing).append(&quot;; &quot;);
+		buffer.append(&quot;codec = &quot;).append(codec).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+
+		return buffer.toString();
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 8;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(frameCount, 2);
+		coder.writeWord(width, 2);
+		coder.writeWord(height, 2);
+		coder.writeBits(0, 5);
+		coder.writeBits(deblocking, 2);
+		coder.writeBits(smoothing ? 1 : 0, 1);
+		coder.writeWord(codec, 1);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		frameCount = coder.readWord(2, false);
+		width = coder.readWord(2, false);
+		height = coder.readWord(2, false);
+
+		coder.readBits(5, false);
+		deblocking = coder.readBits(2, false);
+		smoothing = coder.readBits(1, false) == 1 ? true : false;
+
+		codec = coder.readByte();
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSDoAction.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSDoAction.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSDoAction.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,344 +33,372 @@
 import java.util.*;
 
 /**
-FSDoAction is used to specify a sequence of actions that are executed when a 
-frame is displayed.
+ * FSDoAction is used to specify a sequence of actions that are executed when a
+ * frame is displayed.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of FSActionObjects which are executed by the Flash Player when
+ * the current frame is displayed. The actions are executed in the order they
+ * appear in the array.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To define the actions for a given frame the FSDoAction object should be added
+ * to a movie after the previous frame is displayed but before the FSShowFrame
+ * object that displays the 'current' frame and triggers the actions to be
+ * executed.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Only one FSDoAction object can be used to specify the actions for a given
+ * frame. If more than one FSDoAction object is added in a single frame only the
+ * actions contained in the last FSDoAction object (before the FSShowFrame
+ * object) will be executed when the frame is displayed. The other FSDoAction
+ * objects will be ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;_root&quot;));
+ *  actions.add(new FSAction(FSAction.GetVariable));
+ *  ...
+ * 
+ *  movie.add(new FSShowFrame()); // previous frame
+ *  ...
+ * 
+ *  movie.add(new FSDoAction(actions));
+ *  movie.add(new FSShowFrame()); // frame where actions will be executed
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDoAction class represents the DoAction tag from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSDoAction extends FSMovieObject
+{
+	private ArrayList actions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private byte[] encodedActions = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSDoAction object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDoAction(FSCoder coder)
+	{
+		super(FSMovieObject.DoAction);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDoAction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDoAction object with an array of actions.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public FSDoAction(ArrayList anArray)
+	{
+		super(FSMovieObject.DoAction);
+		setActions(anArray);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDoAction_1&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSActionObjects which are executed by the Flash Player when the 
-current frame is displayed. The actions are executed in the order they appear in 
-the array.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDoAction object with an array of encoded actions
+	 * generated by the classes in Translate.
+	 * 
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSDoAction(byte[] bytes)
+	{
+		super(FSMovieObject.DoAction);
+		setEncodedActions(bytes);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDoAction_2&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded 
-actions are typically generated by the parser in the Translate framework. The 
-actions array and encodedActions cannot both be valid at the same time. Accessor 
-methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDoAction object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDoAction object.
+	 */
+	public FSDoAction(FSDoAction obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-&lt;p&gt;To define the actions for a given frame the FSDoAction object should be added 
-to a movie after the previous frame is displayed but before the FSShowFrame 
-object that displays the 'current' frame and triggers the actions to be executed.&lt;/p&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-&lt;p&gt;Only one FSDoAction object can be used to specify the actions for a given 
-frame. If more than one FSDoAction object is added in a single frame only the 
-actions contained in the last FSDoAction object (before the FSShowFrame object) 
-will be executed when the frame is displayed. The other FSDoAction objects will 
-be ignored.&lt;/p&gt;
+	/**
+	 * Adds the action object to the array of actions. If the object already
+	 * contains encoded actions then they will be deleted.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Get the array of actions that are executed when the frame is displayed.
+	 * 
+	 * @return the array of action objects.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-&lt;pre&gt;
-ArrayList actions = new ArrayList();
+	/**
+	 * Set the array of actions that will be executed when the next ShowFrame
+	 * tag is executed by the Flash Player. If the object already contains
+	 * encoded actions then they will be deleted.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(new FSAction(FSAction.GetVariable));
-...
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-movie.add(new FSShowFrame()); // previous frame
-...
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-movie.add(new FSDoAction(actions));
-movie.add(new FSShowFrame()); // frame where actions will be executed
-&lt;/pre&gt;
+	public Object clone()
+	{
+		FSDoAction anObject = (FSDoAction) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-&lt;p&gt;The FSDoAction class represents the DoAction tag from the Macromedia Flash 
-(SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDoAction extends FSMovieObject
-{
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-    
-    /**
-     * Construct an FSDoAction object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDoAction(FSCoder coder)
-    {
-        super(FSMovieObject.DoAction);
-        decode(coder);
-    }
-    /** Constructs an FSDoAction object with an array of actions.
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
+		return anObject;
+	}
 
-        @param anArray the array of action objects.
-        */
-    public FSDoAction(ArrayList anArray)
-    {
-        super(FSMovieObject.DoAction);
-        setActions(anArray);
-    }
-    /**
-     * Constructs an FSDoAction object with an array of encoded actions
-     * generated by the classes in Translate.
-     * 
-     * @param bytes an array of encoded action objects.
-     */
-    public FSDoAction(byte[] bytes)
-    {
-        super(FSMovieObject.DoAction);
-        setEncodedActions(bytes);
-    }
-    /**
-     * Constructs an FSDoAction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDoAction object.
-     */
-    public FSDoAction(FSDoAction obj)
-    {
-        super(obj);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }    
+		if (super.equals(anObject))
+		{
+			FSDoAction typedObject = (FSDoAction) anObject;
 
-    /** 
-     * Adds the action object to the array of actions. If the object already
-     * contains encoded actions then they will be deleted.
-     * 
-     * @param anAction an object belonging to a class derived from FSActionObject.
-     */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+			if (actions != null)
+			{
+				result = actions.equals(typedObject.actions);
+			} else
+			{
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+			}
+		}
+		return result;
+	}
 
-    /** Get the array of actions that are executed when the frame is displayed.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @return the array of action objects.
-        */
-    public ArrayList getActions() 
-    { 
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
-    /** 
-     * Set the array of actions that will be executed when the next ShowFrame 
-     * tag is executed by the Flash Player.  If the object already contains 
-     * encoded actions then they will be deleted.
-     * 
-     * @param anArray the array of action objects.
-     */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+		buffer.append(&quot;FSDoAction: { &quot;);
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-    }
+		if (actions != null)
+			buffer.append(&quot;actions = array[&quot;).append(actions.size()).append(&quot;]; &quot;);
+		else
+			buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    public Object clone()
-    {
-        FSDoAction anObject = (FSDoAction)super.clone();
-        
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+		buffer.append(&quot;}&quot;);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDoAction typedObject = (FSDoAction)anObject;
-            
-            if (actions != null)
-            {
-                result = actions.equals(typedObject.actions);
-            }
-            else
-            {
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-            }
-        }
-        return result;
-    }
+		return buffer.toString();
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
-                
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
+			int count = actions.size();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+			for (int i = 0; i &lt; count; i++)
+			{
+				currentAction = (FSActionObject) actions.get(i);
 
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	int count = actions.size();
-        	
-            for (int i=0; i&lt;count; i++)
-            {
-                currentAction = (FSActionObject)actions.get(i);
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if (count == 0 || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-            
-                action.encode(coder);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-                coder.setPointer(next);
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+			if (count == 0 || (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
-            
-            int len = length;
-            int start;
-            
-            while (len &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length];
-            coder.readBytes(encodedActions);
-        }
-        coder.endObject(name());
-    }
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		if (actions != null)
+		{
+			FSActionObject action = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (action.getLength() &lt;&lt; 3);
+
+				action.encode(coder);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+				coder.setPointer(next);
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
+
+			int len = length;
+			int start;
+
+			while (len &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSActionObject.decodeAction(coder));
+				len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[length];
+			coder.readBytes(encodedActions);
+		}
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSExceptionHandler.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSExceptionHandler.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSExceptionHandler.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,614 +33,502 @@
 import java.util.*;
 
 /**
-The FSExceptionHandler class is used to specify try..catch blocks so exceptions can be thrown 
-and handled when executing a series of actions.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * The FSExceptionHandler class is used to specify try..catch blocks so
+ * exceptions can be thrown and handled when executing a series of actions.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;type&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;register&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The number of the register that the thrown object will be assigned to.
+ * Optional, Omitted if the variable attribute is set.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;variable&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The variable in memory that the thrown object will be assigned to.
+ * Optional, Omitted if the register attribute is set.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;tryActions&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The actions executed in the try block of the exception.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;catchActions &lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The actions executed in the catch block of the exception. Defining
+ * actions for the catch block is optional and may be set to the null object or
+ * an empty array if no actions will be executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;finalActions&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The actions executed in a finally block of the exception. Defining
+ * actions for the finally block is optional and may be set to the null object
+ * or an empty array if no actions will be executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The thrown object can be assigned to either one of the Flash Player's 256
+ * internal registers or to a variable in memory. If a register number is set
+ * the variable name is set to null. Similarly if a variable name is set then
+ * the register number is set to zero.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSExceptionHandler class contains three arrays of actions supporting the
+ * standard syntax for an exception with try, catch and finally blocks. An
+ * exception is thrown by a Throw action which pops a value off the stack and
+ * assigns it to either a named variable or one of the Flash Player's internal
+ * registered so it can be processed by the actions in the catch block.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Exceptions may be nest to any level if a thrown exception is not handled by
+ * the immediate catch block it is propagated to the next handler in the
+ * exception hierarchy and so on until it is caught.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Both the catch and finally blocks are optional when defining an exception,
+ * the corresponding arguments in constructors and accessor methods may be set
+ * to null.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSExceptionHandler represents the Try action introduced in Flash 7 and is
+ * used to directly support the exception handling syntax defined in
+ * ActionScript 2.0.
+ * &lt;/p&gt;
+ */
+public class FSExceptionHandler extends FSActionObject
+{
+	private int register;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private String variable;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private ArrayList&lt;FSActionObject&gt; tryActions;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_1&quot;&gt;register&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the register that the thrown object will be assigned to. Optional, Omitted if the variable attribute is set.&lt;/td&gt;
-&lt;/tr&gt;
+	private ArrayList&lt;FSActionObject&gt; catchActions;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_2&quot;&gt;variable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The variable in memory that the thrown object will be assigned to. Optional, Omitted if the register attribute is set.&lt;/td&gt;
-&lt;/tr&gt;
+	private ArrayList&lt;FSActionObject&gt; finalActions;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_3&quot;&gt;tryActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The actions executed in the try block of the exception.&lt;/td&gt;
-&lt;/tr&gt;
+	private int tryLength;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_4&quot;&gt;catchActions &lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The actions executed in the catch block of the exception. Defining actions for the catch block is optional and may be set to the null object or an empty array if no actions will be executed.&lt;/td&gt;
-&lt;/tr&gt;
+	private int catchLength;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_5&quot;&gt;finalActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The actions executed in a finally block of the exception. Defining actions for the finally block is optional and may be set to the null object or an empty array if no actions will be executed.&lt;/td&gt;
-&lt;/tr&gt;
+	private int finalLength;
 
-&lt;/table&gt;
+	/**
+	 * Construct an FSExceptionHandler object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSExceptionHandler(FSCoder coder)
+	{
+		super(ExceptionHandler);
+		decode(coder);
+	}
 
-&lt;p&gt;The thrown object can be assigned to either one of the Flash Player's 256 internal registers or to a variable in memory. If a register number is set the variable name is set to null. Similarly if a variable name is set then the register number is set to zero.&lt;/p&gt;
+	/**
+	 * Constructs a new exception handler with the thrown object assigned to a
+	 * local variable.
+	 * 
+	 * @param name
+	 *            the name of the variable that the thrown object will be
+	 *            assigned to.
+	 * @param tryArray
+	 *            actions that will be executed in the try block of the
+	 *            exception.
+	 * @param catchArray
+	 *            actions that will be executed in the catch block of the
+	 *            exception, if one is defined. This may be null is no catch
+	 *            block is required - the exception will be handled by another
+	 *            catche block higher in the exception tree.
+	 * @param finallyArray
+	 *            actions that will be executed in the finally block of the
+	 *            exception, if one is defined. This may be null is no finally
+	 *            block is required.
+	 */
 
-&lt;p&gt;The FSExceptionHandler class contains three arrays of actions supporting the standard syntax for an exception with try, catch and finally blocks. An exception is thrown by a Throw action which pops a value off the stack and assigns it to either a named variable or one of the Flash Player's internal registered so it can be processed by the actions in the catch block.&lt;/p&gt;
+	public FSExceptionHandler(String name, ArrayList&lt;FSActionObject&gt; tryArray,
+								ArrayList&lt;FSActionObject&gt; catchArray,
+								ArrayList&lt;FSActionObject&gt; finallyArray)
+	{
+		super(ExceptionHandler);
 
-&lt;p&gt;Exceptions may be nest to any level if a thrown exception is not handled by the immediate catch block it is propagated to the next handler in the exception hierarchy and so on until it is caught.&lt;/p&gt;
+		register = 0;
+		variable = name;
+		tryActions = tryArray;
+		catchActions = catchArray;
+		finalActions = finallyArray;
+	}
 
-&lt;p&gt;Both the catch and finally blocks are optional when defining an exception, the corresponding arguments in constructors and accessor methods may be set to null.&lt;/p&gt;
+	/**
+	 * Constructs a new exception handler with the thrown object assigned to one
+	 * of the Flash Player's internal registers.
+	 * 
+	 * @param index
+	 *            the number of the register that the thrown object will be
+	 *            assigned to.
+	 * @param tryArray
+	 *            actions that will be executed in the try block of the
+	 *            exception.
+	 * @param catchArray
+	 *            actions that will be executed in the catch block of the
+	 *            exception, if one is defined. This may be null is no catch
+	 *            block is required - the exception will be handled by another
+	 *            catch block higher in the exception tree.
+	 * @param finallyArray
+	 *            actions that will be executed in the finally block of the
+	 *            exception, if one is defined. This may be null is no finally
+	 *            block is required.
+	 */
+	public FSExceptionHandler(int index, ArrayList&lt;FSActionObject&gt; tryArray,
+								ArrayList&lt;FSActionObject&gt; catchArray,
+								ArrayList&lt;FSActionObject&gt; finallyArray)
+	{
+		super(ExceptionHandler);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		register = index;
+		variable = null;
+		tryActions = tryArray;
+		catchActions = catchArray;
+		finalActions = finallyArray;
+	}
 
-&lt;p&gt;The FSExceptionHandler represents the Try action introduced in Flash 7 and is used to directly support the exception handling syntax defined in ActionScript 2.0.&lt;/p&gt;
- */  
-public class FSExceptionHandler extends FSActionObject
-{
-    private int register = 0;
-    private String variable = null;
-    
-    private ArrayList tryActions = null;
-    private ArrayList catchActions = null;
-    private ArrayList finalActions = null;
+	/**
+	 * Constructs an FSExceptionHandler object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSExceptionHandler object.
+	 */
+	public FSExceptionHandler(FSExceptionHandler obj)
+	{
+		super(obj);
 
-    /**
-     * Construct an FSExceptionHandler object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSExceptionHandler(FSCoder coder)
-    {
-        super(ExceptionHandler);
-        decode(coder);
-    }
-    /**
-     * Constructs a new exception handler with the thrown object assigned to a local variable.
-     *
-     * @param name the name of the variable that the thrown object will be assigned to.
-     * @param tryArray actions that will be executed in the try block of the exception.
-     * @param catchArray actions that will be executed in the catch block of the exception, if one is defined. This may be null is no catch block is required - the exception will be handled by another catche block higher in the exception tree.
-     * @param finallyArray actions that will be executed in the finally block of the exception, if one is defined. This may be null is no finally block is required.
-     */
-    public FSExceptionHandler(String name, ArrayList tryArray, ArrayList catchArray, ArrayList finallyArray)
-    {
-        super(ExceptionHandler);
-    
-        register = 0;
-        variable = name;
-        tryActions = tryArray;
-        catchActions = catchArray;
-        finalActions = finallyArray;
-    }
-    /**
-     * Constructs a new exception handler with the thrown object assigned to one of the 
-     * Flash Player's internal registers.
-     *
-     * @param index the number of the register that the thrown object will be assigned to.
-     * @param tryArray actions that will be executed in the try block of the exception.
-     * @param catchArray actions that will be executed in the catch block of the exception, if one is defined. This may be null is no catch block is required - the exception will be handled by another catche block higher in the exception tree.
-     * @param finallyArray actions that will be executed in the finally block of the exception, if one is defined. This may be null is no finally block is required.
-     */
-    public FSExceptionHandler(int index, ArrayList tryArray, ArrayList catchArray, ArrayList finallyArray)
-    {
-        super(ExceptionHandler);
-    
-        register = index;
-        variable = null;
-        tryActions = tryArray;
-        catchActions = catchArray;
-        finalActions = finallyArray;
-    }
-    /**
-     * Constructs an FSExceptionHandler object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSExceptionHandler object.
-     */
-    public FSExceptionHandler(FSExceptionHandler obj)
-    {
-        super(obj);
-        register = obj.register;
-        
-        if (obj.variable != null)
-            variable = new String(obj.variable);
-        
-        tryActions = new ArrayList(obj.tryActions.size());
-        
-        for (Iterator i = obj.tryActions.iterator(); i.hasNext();)
-            tryActions.add(((FSActionObject)i.next()).clone());
-        
-        if (obj.catchActions != null)
-        {
-            catchActions = new ArrayList(obj.catchActions.size());
-            
-            for (Iterator i = obj.catchActions.iterator(); i.hasNext();)
-                catchActions.add(((FSActionObject)i.next()).clone());
-        }
-        
-        if (obj.finalActions != null)
-        {
-            finalActions = new ArrayList(obj.finalActions.size());
-            
-            for (Iterator i = obj.finalActions.iterator(); i.hasNext();)
-                finalActions.add(((FSActionObject)i.next()).clone());
-        }
-    }    
+		register = obj.register;
 
-    /** Adds the action object to the array of actions for the try block.
+		if (obj.variable != null)
+			variable = new String(obj.variable);
 
-        @param anAction an action.
-        */
-    public void addToTry(FSActionObject anAction)
-    {
-        tryActions.add(anAction);
-    }
+		tryActions = FSActionObject.copy(obj.tryActions);
+		catchActions = FSActionObject.copy(obj.catchActions);
+		finalActions = FSActionObject.copy(obj.finalActions);
+	}
 
-    /** Adds the action object to the array of actions for the catch block.
+	/**
+	 * Adds the action object to the array of actions for the try block.
+	 * 
+	 * @param anAction
+	 *            an action.
+	 */
+	public void addToTry(FSActionObject anAction)
+	{
+		tryActions.add(anAction);
+	}
 
-        @param anAction an action.
-        */
-    public void addToCatch(FSActionObject anAction)
-    {
-        if (catchActions == null)
-            catchActions = new ArrayList();
-                
-        catchActions.add(anAction);
-    }
+	/**
+	 * Adds the action object to the array of actions for the catch block.
+	 * 
+	 * @param anAction
+	 *            an action.
+	 */
+	public void addToCatch(FSActionObject anAction)
+	{
+		if (catchActions == null)
+			catchActions = new ArrayList&lt;FSActionObject&gt;();
 
-    /** Adds the action object to the array of actions for the finally block.
+		catchActions.add(anAction);
+	}
 
-        @param anAction an action.
-        */
-    public void addToFinally(FSActionObject anAction)
-    {
-        if (catchActions == null)
-            finalActions = new ArrayList();
-                
-        finalActions.add(anAction);
-    }
+	/**
+	 * Adds the action object to the array of actions for the finally block.
+	 * 
+	 * @param anAction
+	 *            an action.
+	 */
+	public void addToFinally(FSActionObject anAction)
+	{
+		if (catchActions == null)
+			finalActions = new ArrayList&lt;FSActionObject&gt;();
 
-    /** Gets the name of the variable which the exception object is assigned to.
+		finalActions.add(anAction);
+	}
 
-        @return the name of the function. Returns null if the exception object
-        will be assigned to a register.
-        */
-    public String getVariable() 
-    {
-        return variable;
-    }
-    
-    /**
-     * Sets the name of the variable that the exception object is assigned to.
-     * 
-     * @param name the name of the variable. May be null if the exception object will
-     * be signed to a register.
-     */
-    public void setVariable(String name)
-    {
-        variable = name;
-        register = 0;
-    }
+	/**
+	 * Gets the name of the variable which the exception object is assigned to.
+	 * 
+	 * @return the name of the function. Returns null if the exception object
+	 *         will be assigned to a register.
+	 */
+	public String getVariable()
+	{
+		return variable;
+	}
 
-    /** 
-     * Gets the index of the register that the exception object is assigned to.
-     * 
-     * @return the number of register. Returns 0 if the exception object will be assigned
-     * to a local variable.
-     */
-    public int getRegister()
-    {
-        return register;
-    }
-    
-    /**
-     * Sets the index of the register that the exception object is assigned to.
-     * 
-     * @param index the number of the register. May be 0 if the exception object
-     * will be assigned to a local variable.
-     */
-    public void setRegister(int index)
-    {
-        register = index;
-        variable = null;
-    }
+	/**
+	 * Sets the name of the variable that the exception object is assigned to.
+	 * 
+	 * @param name
+	 *            the name of the variable. May be null if the exception object
+	 *            will be signed to a register.
+	 */
+	public void setVariable(String name)
+	{
+		variable = name;
+		register = 0;
+	}
 
-    /** Gets the array of actions executed in the try block.
+	/**
+	 * Gets the index of the register that the exception object is assigned to.
+	 * 
+	 * @return the number of register. Returns 0 if the exception object will be
+	 *         assigned to a local variable.
+	 */
+	public int getRegister()
+	{
+		return register;
+	}
 
-        @return the array of actions for the try block.
-        */
-    public ArrayList getTryActions() 
-    {
-        return tryActions;
-    }
+	/**
+	 * Sets the index of the register that the exception object is assigned to.
+	 * 
+	 * @param index
+	 *            the number of the register. May be 0 if the exception object
+	 *            will be assigned to a local variable.
+	 */
+	public void setRegister(int index)
+	{
+		register = index;
+		variable = null;
+	}
 
-    /** Sets the array of actions executed in the try block.
+	/**
+	 * Gets the array of actions executed in the try block.
+	 * 
+	 * @return the array of actions for the try block.
+	 */
+	public ArrayList&lt;FSActionObject&gt; getTryActions()
+	{
+		return tryActions;
+	}
 
-        @param array the array of actions for the try block.
-        */
-    public void setTryActions(ArrayList array) 
-    {
-        tryActions = array;
-    }
+	/**
+	 * Sets the array of actions executed in the try block.
+	 * 
+	 * @param array
+	 *            the array of actions for the try block.
+	 */
+	public void setTryActions(ArrayList&lt;FSActionObject&gt; array)
+	{
+		tryActions = array;
+	}
 
-    /** Gets the array of actions executed in the catch block.
+	/**
+	 * Gets the array of actions executed in the catch block.
+	 * 
+	 * @return the array of actions for the catch block.
+	 */
+	public ArrayList&lt;FSActionObject&gt; getCatchActions()
+	{
+		return catchActions;
+	}
 
-        @return the array of actions for the catch block.
-        */
-    public ArrayList getCatchActions() 
-    {
-        return catchActions;
-    }
+	/**
+	 * Sets the array of actions executed in the catch block.
+	 * 
+	 * @param array
+	 *            the array of actions for the catch block.
+	 */
+	public void setCatchActions(ArrayList&lt;FSActionObject&gt; array)
+	{
+		catchActions = array;
+	}
 
-    /** Sets the array of actions executed in the catch block.
+	/**
+	 * Gets the array of actions executed in the finally block.
+	 * 
+	 * @return the array of actions for the finally block.
+	 */
+	public ArrayList&lt;FSActionObject&gt; getFinalActions()
+	{
+		return finalActions;
+	}
 
-        @param array the array of actions for the catch block.
-        */
-    public void setCatchActions(ArrayList array) 
-    {
-        catchActions = array;
-    }
+	/**
+	 * Sets the array of actions executed in the final block.
+	 * 
+	 * @param array
+	 *            the array of actions for the final block.
+	 */
+	public void setFinalActions(ArrayList&lt;FSActionObject&gt; array)
+	{
+		finalActions = array;
+	}
 
-    /** Gets the array of actions executed in the finally block.
+	public Object clone()
+	{
+		FSExceptionHandler anObject = (FSExceptionHandler) super.clone();
 
-        @return the array of actions for the finally block.
-        */
-    public ArrayList getFinalActions() 
-    {
-        return finalActions;
-    }
+		anObject.tryActions = FSActionObject.copy(tryActions);
+		anObject.catchActions = FSActionObject.copy(catchActions);
+		anObject.finalActions = FSActionObject.copy(finalActions);
 
-    /** Sets the array of actions executed in the final block.
+		return anObject;
+	}
 
-        @param array the array of actions for the final block.
-        */
-    public void setFinalActions(ArrayList array) 
-    {
-        finalActions = array;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public Object clone()
-    {
-        FSExceptionHandler anObject = (FSExceptionHandler)super.clone();
-        
-         anObject.tryActions = new ArrayList();
-         anObject.catchActions = new ArrayList();
-         anObject.finalActions = new ArrayList();
-            
-        for (Iterator i = tryActions.iterator(); i.hasNext();)
-            anObject.tryActions.add(((FSActionObject)i.next()).clone());
+		if (super.equals(anObject))
+		{
+			FSExceptionHandler typedObject = (FSExceptionHandler) anObject;
 
-        for (Iterator i = catchActions.iterator(); i.hasNext();)
-            anObject.catchActions.add(((FSActionObject)i.next()).clone());
+			if (variable != null)
+				result = variable.equals(typedObject.variable);
+			else
+				result = variable == typedObject.variable;
 
-        for (Iterator i = finalActions.iterator(); i.hasNext();)
-            anObject.finalActions.add(((FSActionObject)i.next()).clone());
+			result = result &amp;&amp; register == typedObject.register;
 
-        return anObject;
-    }
+			if (tryActions != null)
+				result = result &amp;&amp; tryActions.equals(typedObject.tryActions);
+			else
+				result = result &amp;&amp; tryActions == typedObject.tryActions;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSExceptionHandler typedObject = (FSExceptionHandler)anObject;
-            
-            if (variable != null)
-                result = variable.equals(typedObject.variable);
-            else
-                result = variable == typedObject.variable;
-                
-            result = result &amp;&amp; register == typedObject.register;
+			if (catchActions != null)
+				result = result
+								&amp;&amp; catchActions
+												.equals(typedObject.catchActions);
+			else
+				result = result &amp;&amp; catchActions == typedObject.catchActions;
 
-            if (tryActions != null)
-                result = result &amp;&amp; tryActions.equals(typedObject.tryActions);
-            else
-                result = result &amp;&amp; tryActions == typedObject.tryActions;
+			if (finalActions != null)
+				result = result
+								&amp;&amp; finalActions
+												.equals(typedObject.finalActions);
+			else
+				result = result &amp;&amp; finalActions == typedObject.finalActions;
+		}
+		return result;
+	}
 
-            if (catchActions != null)
-                result = result &amp;&amp; catchActions.equals(typedObject.catchActions);
-            else
-                result = result &amp;&amp; catchActions == typedObject.catchActions;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-            if (finalActions != null)
-                result = result &amp;&amp; finalActions.equals(typedObject.finalActions);
-            else
-                result = result &amp;&amp; finalActions == typedObject.finalActions;
-        }
-        return result;
-    }
+		buffer.append(super.toString());
+		buffer.append(&quot;: { &quot;);
+		buffer.append(&quot;variable = &quot;).append(variable).append(&quot;; &quot;);
+		buffer.append(&quot;register = &quot;).append(register).append(&quot;; &quot;);
+		buffer.append(&quot;try = array[&quot;).append(tryActions.size()).append(&quot;]; &quot;);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;variable&quot;, variable);        
-            Transform.append(buffer, &quot;register&quot;, register);
-            Transform.append(buffer, &quot;tryActions&quot;, tryActions, depth);
-            Transform.append(buffer, &quot;catchActions&quot;, catchActions, depth);
-            Transform.append(buffer, &quot;finalActions&quot;, finalActions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (catchActions != null)
+		{
+			buffer.append(&quot;catch = array[&quot;).append(catchActions.size()).append(
+							&quot;]; &quot;);
+		}
+		if (finalActions != null)
+		{
+			buffer.append(&quot;final = array[&quot;).append(finalActions.size()).append(
+							&quot;]; &quot;);
+		}
 
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += 7;
-        length += (variable != null) ? coder.strlen(variable, true) : 1;
-        
-        for (Iterator i = tryActions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            length += currentAction.length(coder);
-            length += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
+		buffer.append(&quot;}&quot;);
 
-        if (catchActions != null)
-        {
-            for (Iterator i = catchActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
+		return buffer.toString();
+	}
 
-        if (finalActions != null)
-        {
-            for (Iterator i = finalActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        super.encode(coder);
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        coder.writeBits(0, 5);
-        coder.writeBits(variable == null ? 1 : 0, 1);
-        coder.writeBits(catchActions != null &amp;&amp; catchActions.size() &gt; 0 ? 1 : 0, 1);
-        coder.writeBits(finalActions != null &amp;&amp; finalActions.size() &gt; 0 ? 1 : 0, 1);
+		length += 7;
+		length += (variable != null) ? FSCoder.strlen(variable, true) : 1;
 
-        int tryLength = 0;
-        
-        for (Iterator i = tryActions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            tryLength += currentAction.getLength();
-            tryLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        
-        coder.writeWord(tryLength, 2);
+		tryLength = FSActionObject.length(tryActions);
+		catchLength = FSActionObject.length(catchActions);
+		finalLength = FSActionObject.length(finalActions);
 
-        int catchLength = 0;
-        
-        if (catchActions != null)
-        {
-            for (Iterator i = catchActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                catchLength += currentAction.getLength();
-                catchLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
-        
-        coder.writeWord(catchLength, 2);
+		length += tryLength;
+		length += catchLength;
+		length += finalLength;
 
-        int finalLength = 0;
-        
-        if (finalActions != null)
-        {
-            for (Iterator i = finalActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                finalLength += currentAction.getLength();
-                finalLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
-        
-        coder.writeWord(finalLength, 2);
+		return length;
+	}
 
-        if (variable != null)
-            coder.writeString(variable);
-        else
-            coder.writeWord(register, 1);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        for (Iterator i=tryActions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-                
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
+		coder.writeBits(0, 5);
+		coder.writeBits(variable == null ? 1 : 0, 1);
+		coder.writeBits(catchLength &gt; 0 ? 1 : 0, 1);
+		coder.writeBits(finalLength &gt; 0 ? 1 : 0, 1);
 
-        if (catchActions != null)
-        {
-            for (Iterator i=catchActions.iterator(); i.hasNext();)
-            {
-                FSActionObject action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-        }
+		coder.writeWord(tryLength, 2);
+		coder.writeWord(catchLength, 2);
+		coder.writeWord(finalLength, 2);
 
-        if (finalActions != null)
-        {
-            for (Iterator i=finalActions.iterator(); i.hasNext();)
-            {
-                FSActionObject action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-        }
+		if (variable != null)
+			coder.writeString(variable);
+		else
+			coder.writeWord(register, 1);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsVariable = false;
-        boolean containsCatch = false;
-        boolean containsFinal = false;
-        
-        super.decode(coder);
-        
-        coder.readBits(5, false);
-        containsVariable = coder.readBits(1, false) != 1;
-        containsCatch = coder.readBits(1, false) == 1;
-        containsFinal = coder.readBits(1, false) == 1;
+		FSActionObject.encode(coder, tryActions);
+		FSActionObject.encode(coder, catchActions);
+		FSActionObject.encode(coder, finalActions);
+	}
 
-        int tryLength = coder.readWord(2, false);
-        int catchLength = coder.readWord(2, false);
-        int finalLength = coder.readWord(2, false);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        tryActions = new ArrayList();
-        
-        if (containsCatch)
-            catchActions = new ArrayList();
-            
-        if (containsFinal)
-            finalActions = new ArrayList();
+		coder.readBits(5, false);
+		boolean containsVariable = coder.readBits(1, false) != 1;
+		boolean containsCatch = coder.readBits(1, false) == 1;
+		boolean containsFinal = coder.readBits(1, false) == 1;
 
-        /*
-         * Both the variable name and register index are represented 
-         * in Describe so pretend fields are consecutive.
-         */
-        if (containsVariable)
-        {
-            variable = coder.readString();
-        }
-        else
-        {
-            register = coder.readWord(1, false);
-        }
+		tryLength = coder.readWord(2, false);
+		catchLength = coder.readWord(2, false);
+		finalLength = coder.readWord(2, false);
 
-        while (tryLength &gt; 0)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            if (anAction != null)
-            {
-                tryLength -= anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-                tryActions.add(anAction);
-            }
-            else
-            {
-                coder.adjustPointer(8);
-                tryLength =- 1;
-            }
-        }
-        if (containsCatch)
-        {
-            while (catchLength &gt; 0)
-            {
-                FSActionObject anAction = FSMovie.decodeAction(coder);
-                
-                if (anAction != null)
-                {
-                    catchLength -= anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-                    catchActions.add(anAction);
-                }
-                else
-                {
-                    coder.adjustPointer(8);
-                    tryLength =- 1;
-                }
-            }
-        }
-        if (containsFinal)
-        {
-            while (finalLength &gt; 0)
-            {
-                FSActionObject anAction = FSMovie.decodeAction(coder);
-                
-                if (anAction != null)
-                {
-                    finalLength -= anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-                    finalActions.add(anAction);
-                }
-                else
-                {
-                    coder.adjustPointer(8);
-                    tryLength =- 1;
-                }
-            }
-        }
+		if (containsVariable)
+		{
+			variable = coder.readString();
+		} else
+		{
+			register = coder.readByte();
+		}
 
-        coder.endObject(name());
-    }
+		tryActions = FSActionObject.decodeActions(coder, tryLength);
+
+		if (containsCatch)
+		{
+			catchActions = FSActionObject.decodeActions(coder, catchLength);
+		}
+
+		if (containsFinal)
+		{
+			finalActions = FSActionObject.decodeActions(coder, finalLength);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSExport.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSExport.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSExport.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,192 +33,221 @@
 import java.util.*;
 
 /**
-FSExport is used to export shapes and other objects so they can be used in another Flash file. 
- 
-&lt;p&gt;Since the identifier for an object is only unique within a given Flash file, each object exported must be given a name so it can referenced when it is imported.&lt;/p&gt;
+ * FSExport is used to export shapes and other objects so they can be used in
+ * another Flash file.
+ * 
+ * &lt;p&gt;
+ * Since the identifier for an object is only unique within a given Flash file,
+ * each object exported must be given a name so it can referenced when it is
+ * imported.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;A HashTable containing key-value pairs where the key is the identifier
+ * of the object being exported and the value is name assigned to the object so
+ * it can be referenced when it is imported into a Flash file.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;P&gt;
+ * To export an object from a Flash file:
+ * &lt;/P&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSDefineShape(...);
+ * 
+ *  movie.add(shape);
+ *  movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * The object can then be imported into another file:
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSExport class represents the ExportAssets tag in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5.
+ * &lt;/p&gt;
+ */
+public class FSExport extends FSMovieObject
+{
+	private Hashtable&lt;Integer,String&gt; objects = new Hashtable&lt;Integer,String&gt;();
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	FSExport()
+	{
+		super(Export);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSExport object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSExport(FSCoder coder)
+	{
+		super(Export);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExport_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSExport object that exports the object with the specified
+	 * identifier. The exported object is assigned the specified name to allow
+	 * it to be referenced in files importing the object.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be exported.
+	 * @param aString
+	 *            the name of the exported object to allow it to be referenced.
+	 */
+	public FSExport(int anIdentifier, String aString)
+	{
+		super(Export);
+		add(anIdentifier, aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExport_1&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A HashTable containing key-value pairs where the key is the identifier of the object being exported and the value is name assigned to the object so it can be referenced when it is imported into a Flash file.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSExport object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSExport object.
+	 */
+	public FSExport(FSExport obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		objects = new Hashtable&lt;Integer,String&gt;(obj.objects.size());
+		
+		Integer key;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		for (Iterator&lt;Integer&gt; i = obj.objects.keySet().iterator(); i.hasNext();)
+		{
+			key = i.next();
+			objects.put(key, new String((String) objects.get(key)));
+		}
+	}
 
-&lt;P&gt;To export an object from a Flash file:&lt;/P&gt;
+	/**
+	 * Adds the identifier and name to the list of objects to be exported.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be exported.
+	 * @param aString
+	 *            the name of the exported object to allow it to be referenced.
+	 */
+	public void add(int anIdentifier, String aString)
+	{
+		objects.put(new Integer(anIdentifier), aString);
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(...);
+	/**
+	 * Gets the table of objects to be imported.
+	 * 
+	 * @return the table of imported objects.
+	 */
+	public Hashtable&lt;Integer,String&gt; getObjects()
+	{
+		return objects;
+	}
 
-movie.add(shape);
-movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+	/**
+	 * Sets the table of objects to be imported.
+	 * 
+	 * @param aTable
+	 *            the table of objects being imported.
+	 */
+	public void setObjects(Hashtable&lt;Integer,String&gt; aTable)
+	{
+		objects = aTable;
+	}
 
-The object can then be imported into another file:
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			result = objects.equals(((FSExport) anObject).getObjects());
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;p&gt;The FSExport class represents the ExportAssets tag in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSExport extends FSMovieObject
-{
-    private Hashtable objects = new Hashtable();
-        
-    FSExport()
-    {
-        super(Export);
-    }
-    /**
-     * Construct an FSExport object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSExport(FSCoder coder)
-    {
-        super(Export);
-        decode(coder);
-    }
-    /** Constructs an FSExport object that exports the object with the specified identifier. The exported object is assigned the specified name to allow it to be referenced in files importing the object. 
+		buffer.append(&quot;FSExport: { &quot;);
+		buffer.append(&quot;objects = &quot;).append(objects.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @param anIdentifier the identifier of the object to be exported.
-        @param aString the name of the exported object to allow it to be referenced.
-        */
-    public FSExport(int anIdentifier, String aString)
-    {
-        super(Export);
-        add(anIdentifier, aString);
-    }
-    /**
-     * Constructs an FSExport object by copying values from an existing object.
-     *
-     * @param obj an FSExport object.
-     */
-    public FSExport(FSExport obj)
-    {
-        super(obj);
-        
-        objects = new Hashtable(obj.objects.size());
-        
-        for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
-        {
-            Object key = i.next();
-            objects.put(key, new String((String)objects.get(key)));
-        }
-    }    
+		return buffer.toString();
+	}
 
-    /** Adds the identifier and name to the list of objects to be exported.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anIdentifier the identifier of the object to be exported.
-        @param aString the name of the exported object to allow it to be referenced.
-        */
-    public void add(int anIdentifier, String aString)
-    {
-        objects.put(new Integer(anIdentifier), aString);
-    }
+		length += 2;
 
-    /** Gets the table of objects to be imported.
+		for (Enumeration&lt;Integer&gt; e = objects.keys(); e.hasMoreElements();)
+		{
+			String var = (String) (objects.get(e.nextElement()));
 
-        @return the table of imported objects.
-        */
-    public Hashtable getObjects()
-    {
-        return objects;
-    }
+			length += 2;
+			length += FSCoder.strlen(var, true);
+		}
+		return length;
+	}
 
-    /** Sets the table of objects to be imported.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param aTable the table of objects being imported.
-        */
-    public void setObjects(Hashtable aTable)
-    {
-       objects = aTable;
-    }
+		coder.writeWord(objects.size(), 2);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            result = objects.equals(((FSExport)anObject).getObjects());
-        }
-        return result;
-    }
+		for (Enumeration&lt;Integer&gt; e = objects.keys(); e.hasMoreElements();)
+		{
+			Integer identifier = e.nextElement();
+			String var = (String) (objects.get(identifier));
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+			coder.writeWord(identifier.intValue(), 2);
+			coder.writeString(var);
+			coder.writeWord(0, 1);
+		}
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		int count = coder.readWord(2, false);
 
-        length += 2;
+		for (int i = 0; i &lt; count; i++)
+		{
+			int identifier = coder.readWord(2, false);
+			String var = coder.readString();
 
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            String name = (String)(objects.get(e.nextElement()));
-
-            length += 2;
-            length += coder.strlen(name, true);
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(objects.size(), 2);
-
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            Integer identifier = (Integer)(e.nextElement());
-            String name = (String)(objects.get(identifier));
-
-            coder.writeWord(identifier.intValue(), 2);
-            coder.writeString(name);
-            coder.writeWord(0, 1);
-        }        
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int count = coder.readWord(2, false);
-
-        for (int i=0; i&lt;count; i++)
-        {
-            int identifier = coder.readWord(2, false);
-            String name = coder.readString();
-
-            add(identifier, name);
-        }
-        coder.endObject(name());
-    }
+			add(identifier, var);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSFontInfo.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSFontInfo.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSFontInfo.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,402 +33,468 @@
 import java.util.*;
 
 /**
-FSFontInfo defines the name and face of a font and maps the codes for a given character 
-set to the glyphs that are drawn to represent each character.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSFontInfo defines the name and face of a font and maps the codes for a given
+ * character set to the glyphs that are drawn to represent each character.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier, in the range 1..65535, for the FSDefineFont
+ * object that contains the glyphs for the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encoding&lt;/td&gt;
+ * &lt;td&gt;Specifies whether the codes for the character set are represented using
+ * ANSI (ASCII), SJIS or Unicode.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Whether the font is bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;italic&lt;/td&gt;
+ * &lt;td&gt;Whether the font is rendered in italics.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;isSmall&lt;/td&gt;
+ * &lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;codes&lt;/td&gt;
+ * &lt;td&gt;An array mapping a glyph index to a particular character code in the
+ * font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The ANSI character set is used for Latin languages, SJIS is used for Japanese
+ * language characters and Unicode is used for any character set. The encoding
+ * attributes uses the constants FSText.ANSI, FSText.SJIS or FSText.Unicode for
+ * each character set type.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The index of each entry in the codes array matches the index in the
+ * corresponding glyph in the shapes array of an FSDefineFont object, allowing a
+ * given character code to be mapped to a given glyph.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The class allows the font associated with a Flash file to be mapped to a font
+ * installed on the device where the Flash Player displaying the file is hosted.
+ * The use of a font from a device is not automatic but is determined by the
+ * HTML tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when
+ * it is first started. If a device does not support a given font then the
+ * glyphs in the FSDefineFont class are used to render the characters.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * An important distinction between the host device to specify the font and
+ * using the glyphs in an FSDefineFont object is that the device is not
+ * anti-aliased and the rendering is dependent on the host device. The glyphs in
+ * an FSDefineFont object are anti-aliased and are guaranteed to look identical
+ * on every device the text is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFontInfo class represents the DefineFontInfo data structure from the
+ * Flash specification. It was introduced in Flash 1. Support for small fonts
+ * was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSFontInfo extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private String name = &quot;&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private int encoding = FSText.Unicode;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier, in the range 1..65535, for the FSDefineFont object that contains the glyphs for the font.&lt;/td&gt;
-&lt;/tr&gt;
+	private boolean small = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_2&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of the font.&lt;/td&gt;
-&lt;/tr&gt;
+	private boolean italic = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_3&quot;&gt;encoding&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Specifies whether the codes for the character set are represented using ANSI (ASCII), SJIS or Unicode.&lt;/td&gt;
-&lt;/tr&gt;
+	private boolean bold = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_4&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
-&lt;/tr&gt;
+	private ArrayList codes = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_5&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is bold.&lt;/td&gt;
-&lt;/tr&gt;
+	/*
+	 * attributes used to retain state during encoding.
+	 */
+	private boolean _containsWideCodes = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_6&quot;&gt;italic&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is rendered in italics.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSFontInfo object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFontInfo(FSCoder coder)
+	{
+		super(FSMovieObject.FontInfo);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_7&quot;&gt;isSmall&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs a basic FSFontInfo object specifying only the name of the
+	 * font.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 * @param aName
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public FSFontInfo(int anIdentifier, String aName)
+	{
+		super(FSMovieObject.FontInfo);
+		setIdentifier(anIdentifier);
+		setName(aName);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_8&quot;&gt;codes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array mapping a glyph index to a particular character code in the font.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSFontInfo object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSFontInfo object.
+	 */
+	public FSFontInfo(FSFontInfo obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		name = new String(obj.name);
+		encoding = obj.encoding;
+		small = obj.small;
+		italic = obj.italic;
+		bold = obj.bold;
 
-&lt;p&gt;The ANSI character set is used for Latin languages, SJIS is used for Japanese 
-language characters and Unicode is used for any character set. The encoding 
-attributes uses the constants FSText.ANSI, FSText.SJIS or FSText.Unicode 
-for each character set type.&lt;/p&gt;
+		codes = new ArrayList(obj.codes.size());
 
-&lt;p&gt;The index of each entry in the codes array matches the index in the corresponding 
-glyph in the shapes array of an FSDefineFont object, allowing a given character 
-code to be mapped to a given glyph.&lt;/p&gt;
+		for (Iterator i = obj.codes.iterator(); i.hasNext();)
+			codes.add(new Integer(((Integer) i.next()).intValue()));
+	}
 
-&lt;p&gt;The class allows the font associated with a Flash file to be mapped to a font 
-installed on the device where the Flash Player displaying the file is hosted. 
-The use of a font from a device is not automatic but is determined by the HTML 
-tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when it is first 
-started. If a device does not support a given font then the glyphs in the FSDefineFont 
-class are used to render the characters.&lt;/p&gt;
+	/**
+	 * Gets the identifier of the font that this font information is for.
+	 * 
+	 * @return the identifier of the FSDefineFont object that contains the
+	 *         glyphs for the font.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;p&gt;An important distinction between the host device to specify the font and using 
-the glyphs in an FSDefineFont object is that the device is not anti-aliased and 
-the rendering is dependent on the host device. The glyphs in an FSDefineFont 
-object are anti-aliased and are guaranteed to look identical on every device the 
-text is displayed.&lt;/p&gt;
+	/**
+	 * Gets the name of the font family.
+	 * 
+	 * @return the name of the font.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the encoding scheme used for characters rendered in the font, either
+	 * FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	 * 
+	 * @return the font character encoding.
+	 */
+	public int getEncoding()
+	{
+		return encoding;
+	}
 
-&lt;p&gt;The FSFontInfo class represents the DefineFontInfo data structure from the 
-Flash specification. It was introduced in Flash 1. Support for small fonts was 
-added in Flash 7.&lt;/p&gt;
- */
-public class FSFontInfo extends FSMovieObject
-{
-    private int identifier = 0;
-    private String name = &quot;&quot;;
-    private int encoding = FSText.Unicode;
-    private boolean small = false;
-    private boolean italic = false;
-    private boolean bold = false;
-    private ArrayList codes = new ArrayList();
-    
-    /*
-     * attributes used to retain state during encoding.
-     */
-    private boolean _containsWideCodes = false;
-    
-    /**
-     * Construct an FSFontInfo object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFontInfo(FSCoder coder)
-    {
-        super(FSMovieObject.FontInfo);
-        decode(coder);
-    }
-    /**  Constructs a basic FSFontInfo object specifying only the name of the font.
-    
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        @param aName the name assigned to the font, identifying the font family.
-        */
-    public FSFontInfo(int anIdentifier, String aName)
-    {
-        super(FSMovieObject.FontInfo);
-        setIdentifier(anIdentifier);
-        setName(aName);
-    }
-    /**
-     * Constructs an FSFontInfo object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSFontInfo object.
-     */
-    public FSFontInfo(FSFontInfo obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        name = new String(obj.name);
-        encoding = obj.encoding;
-        small = obj.small;
-        italic = obj.italic;
-        bold = obj.bold;
-        
-        codes = new ArrayList(obj.codes.size());
-        
-        for (Iterator i = obj.codes.iterator(); i.hasNext();)
-            codes.add(new Integer(((Integer)i.next()).intValue()));
-    }    
+	// Flash 7
+	/**
+	 * Does the font have a small point size. This is used only with a Unicode
+	 * font encoding.
+	 * 
+	 * @return a boolean indicating whether the font will be aligned on pixel
+	 *         boundaries.
+	 */
+	public boolean isSmall()
+	{
+		return small;
+	}
 
-    /** Gets the identifier of the font that this font information is for.
+	/**
+	 * Sets the font is small. Used only with Unicode fonts.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating the font will be aligned on pixel
+	 *            boundaries.
+	 */
+	public void setSmall(boolean aBool)
+	{
+		small = aBool;
+	}
 
-        @return the identifier of the FSDefineFont object that contains the glyphs for the font.
-        */
-    public int getIdentifier() { return identifier; }
+	// End Flash 7
 
-    /** Gets the name of the font family.
+	/**
+	 * Is the font italics.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in italics.
+	 */
+	public boolean isItalic()
+	{
+		return italic;
+	}
 
-        @return the name of the font.
-        */
-    public String getName() 
-    {
-        return name;
-    }
+	/**
+	 * Is the font bold.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in a bold face.
+	 */
+	public boolean isBold()
+	{
+		return bold;
+	}
 
-    /** Gets the encoding scheme used for characters rendered in the font, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	/**
+	 * Gets the array of character codes.
+	 * 
+	 * @return the array of character codes.
+	 */
+	public ArrayList getCodes()
+	{
+		return codes;
+	}
 
-        @return the font character encoding.
-        */
-    public int getEncoding() 
-    {
-        return encoding;
-    }
+	/**
+	 * Sets the identifier of the font that this font information is for.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-// Flash 7
-    /** Does the font have a small point size. This is used only with a Unicode 
-     *  font encoding.
-     * 
-     *  @return a boolean indicating whether the font will be aligned on pixel boundaries.
-     */
-    public boolean isSmall() 
-    {
-        return small;
-    }
+	/**
+	 * Sets the name of the font.
+	 * 
+	 * @param aString
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-    /** Sets the font is small. Used only with Unicode fonts.
-     * 
-     *  @param aBool a boolean flag indicating the font will be aligned on pixel boundaries.
-     */
-    public void setSmall(boolean aBool)
-    {
-        small = aBool;
-    }
-// End Flash 7
-    
-    /** Is the font italics.
+	/**
+	 * Sets the font character encoding.
+	 * 
+	 * @param anEncoding
+	 *            the encoding used to identify characters, either FSText.ASCII,
+	 *            FSText.SJIS or FSText.Unicode.
+	 */
+	public void setEncoding(int anEncoding)
+	{
+		encoding = anEncoding;
+	}
 
-        @return a boolean indicating whether the font is rendered in italics.
-        */
-    public boolean isItalic() 
-    {
-        return italic;
-    }
+	/**
+	 * Sets the font is italics.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            italics.
+	 */
+	public void setItalic(boolean aBool)
+	{
+		italic = aBool;
+	}
 
-    /** Is the font bold.
+	/**
+	 * Sets the font is bold.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            bold face.
+	 */
+	public void setBold(boolean aBool)
+	{
+		bold = aBool;
+	}
 
-        @return a boolean indicating whether the font is rendered in a bold face.
-        */
-    public boolean isBold()
-    {
-        return bold;
-    }
+	/**
+	 * Sets the array of character codes. The index position of a character code
+	 * in the array identifies the index of the corresponding glyph in the
+	 * FSDefineFont object.
+	 * 
+	 * @param anArray
+	 *            the array mapping glyphs to particular character codes.
+	 */
+	public void setCodes(ArrayList anArray)
+	{
+		codes = anArray;
+	}
 
-    /** Gets the array of character codes.
+	public Object clone()
+	{
+		FSFontInfo anObject = (FSFontInfo) super.clone();
 
-        @return the array of character codes.
-        */
-    public ArrayList getCodes()
-    {
-        return codes;
-    }
+		anObject.codes = new ArrayList();
 
-    /** Sets the identifier of the font that this font information is for.
+		for (Iterator i = codes.iterator(); i.hasNext();)
+			anObject.codes.add(new Integer(((Integer) i.next()).intValue()));
 
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		return anObject;
+	}
 
-    /** Sets the name of the font.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aString the name assigned to the font, identifying the font family.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+		if (super.equals(anObject))
+		{
+			FSFontInfo typedObject = (FSFontInfo) anObject;
 
-    /** Sets the font character encoding.
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; encoding == typedObject.encoding;
+			result = result &amp;&amp; small == typedObject.small;
+			result = result &amp;&amp; italic == typedObject.italic;
+			result = result &amp;&amp; bold == typedObject.bold;
 
-        @param anEncoding the encoding used to identify characters, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
-        */
-    public void setEncoding(int anEncoding)
-    {
-        encoding = anEncoding;
-    }
+			if (name != null)
+				result = result &amp;&amp; name.equals(typedObject.name);
+			else
+				result = result &amp;&amp; name == typedObject.name;
 
-    /** Sets the font is italics.
+			if (codes != null)
+				result = result &amp;&amp; codes.equals(typedObject.codes);
+			else
+				result = result &amp;&amp; codes == typedObject.codes;
+		}
+		return result;
+	}
 
-        @param aBool a boolean flag indicating whether the font will be rendered in italics.
-        */
-    public void setItalic(boolean aBool)
-    {
-        italic = aBool;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Sets the font is bold.
+		buffer.append(&quot;FSFontInfo: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;encoding = &quot;).append(encoding).append(&quot;; &quot;);
+		// Flash 7
+		buffer.append(&quot;small = &quot;).append(small).append(&quot;; &quot;);
+		// End Flash 7
+		buffer.append(&quot;italic = &quot;).append(italic).append(&quot;; &quot;);
+		buffer.append(&quot;bold = &quot;).append(bold).append(&quot;; &quot;);
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
+		buffer.append(&quot;codes = &quot;).append(codes.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @param aBool a boolean flag indicating whether the font will be rendered in bold face.
-        */
-    public void setBold(boolean aBool)
-    {
-        bold = aBool;
-    }
+		return buffer.toString();
+	}
 
-    /** Sets the array of character codes. The index position of a character code in the array identifies the index of the corresponding glyph in the FSDefineFont object.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anArray the array mapping glyphs to particular character codes.
-        */
-    public void setCodes(ArrayList anArray)
-    {
-        codes = anArray;
-    }
+		length += 4;
+		length += coder.strlen(name, false);
 
-    public Object clone()
-    {
-        FSFontInfo anObject = (FSFontInfo)super.clone();
-        
-        anObject.codes = new ArrayList();
-            
-        for (Iterator i = codes.iterator(); i.hasNext();)
-            anObject.codes.add(new Integer(((Integer)i.next()).intValue()));
+		_containsWideCodes = false;
 
-        return anObject;
-    }
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+		{
+			if (((Integer) codesIterator.next()).intValue() &gt; 255)
+				_containsWideCodes = true;
+		}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSFontInfo typedObject = (FSFontInfo)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; encoding == typedObject.encoding;
-            result = result &amp;&amp; small == typedObject.small;
-            result = result &amp;&amp; italic == typedObject.italic;
-            result = result &amp;&amp; bold == typedObject.bold;
+		length += codes.size() * (_containsWideCodes ? 2 : 1);
 
-            if (name != null)
-                result = result &amp;&amp; name.equals(typedObject.name);
-            else
-                result = result &amp;&amp; name == typedObject.name;
+		return length;
+	}
 
-            if (codes != null)
-                result = result &amp;&amp; codes.equals(typedObject.codes);
-            else
-                result = result &amp;&amp; codes == typedObject.codes;
-        }
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;encoding&quot;, encoding);
-// Flash 7
-            Transform.append(buffer, &quot;small&quot;, small);
-// End Flash 7
-            Transform.append(buffer, &quot;italic&quot;, italic);
-            Transform.append(buffer, &quot;bold&quot;, bold);
-            Transform.append(buffer, &quot;name&quot;, name);
-            Transform.append(buffer, &quot;codes&quot;, codes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.writeWord(identifier, 2);
+		coder.writeWord(coder.strlen(name, false), 1);
+		coder.writeString(name);
+		coder.writeBits(0, 2);
+		coder.writeBits(small ? 1 : 0, 1);
+		coder.writeBits(encoding, 2);
+		coder.writeBits(italic ? 1 : 0, 1);
+		coder.writeBits(bold ? 1 : 0, 1);
+		coder.writeBits(_containsWideCodes ? 1 : 0, 1);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        length += coder.strlen(name, false);
-        
-        _containsWideCodes = false;
-    
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-        {
-            if (((Integer)codesIterator.next()).intValue() &gt; 255)
-                _containsWideCodes = true;
-        }
-        
-        length += codes.size()*(_containsWideCodes ? 2 : 1);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {    
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        coder.writeWord(coder.strlen(name, false), 1);
-        coder.writeString(name);
-        coder.writeBits(0, 2);
-        coder.writeBits(small ? 1 : 0, 1);
-        coder.writeBits(encoding, 2);
-        coder.writeBits(italic ? 1 : 0, 1);
-        coder.writeBits(bold ? 1 : 0, 1);
-        coder.writeBits(_containsWideCodes ? 1 : 0, 1);
-        
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-            coder.writeWord(((Integer)codesIterator.next()).intValue(), _containsWideCodes ? 2 : 1);    
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+			coder.writeWord(((Integer) codesIterator.next()).intValue(),
+							_containsWideCodes ? 2 : 1);
+	}
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int nameLength = 0;
-       
-        codes = new ArrayList();
-        
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        nameLength = coder.readWord(1, false);
-        name = coder.readString(nameLength);
+	public void decode(FSCoder coder)
+	{
+		int nameLength = 0;
 
-        if (name.length() &gt; 0)
-        {
-            while (name.charAt(name.length()-1) == 0) {
-            	name = name.substring(0, name.length()-1);
-            }
-        }
-        
-        /* reserved */ coder.readBits(2, false);
-        small = coder.readBits(1, false) != 0 ? true : false;
-        encoding = coder.readBits(2, false);
-        italic = coder.readBits(1, false) != 0 ? true : false;
-        bold = coder.readBits(1, false) != 0 ? true : false;
-        _containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
+		codes = new ArrayList();
 
-        int bytesRead = 3 + nameLength + 1;
+		super.decode(coder);
 
-        while (bytesRead &lt; length)
-        {
-            codes.add(new Integer(coder.readWord(_containsWideCodes ? 2 : 1, false)));
-            bytesRead += (_containsWideCodes) ? 2 : 1;
-        }
+		identifier = coder.readWord(2, false);
+		nameLength = coder.readByte();
+		name = coder.readString(nameLength);
 
-        coder.endObject(name());
-    }
+		if (name.length() &gt; 0)
+		{
+			while (name.charAt(name.length() - 1) == 0)
+			{
+				name = name.substring(0, name.length() - 1);
+			}
+		}
+
+		/* reserved */coder.readBits(2, false);
+		small = coder.readBits(1, false) != 0 ? true : false;
+		encoding = coder.readBits(2, false);
+		italic = coder.readBits(1, false) != 0 ? true : false;
+		bold = coder.readBits(1, false) != 0 ? true : false;
+		_containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
+
+		int bytesRead = 3 + nameLength + 1;
+
+		while (bytesRead &lt; length)
+		{
+			codes.add(new Integer(coder.readWord(_containsWideCodes ? 2 : 1,
+							false)));
+			bytesRead += (_containsWideCodes) ? 2 : 1;
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSFontInfo2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSFontInfo2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSFontInfo2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,379 +33,485 @@
 import java.util.*;
 
 /**
-FSFontInfo2 describes the mapping of codes for a given character set to the glyphs that 
-are drawn to represent the character. 
- 
-&lt;p&gt;It extends the functionality provided by FSFontInfo by adding a language attribute which is support to support line-breaking when displaying text in different spoken languages. Support for small fonts was added in Flash 7.&lt;/P&gt;
+ * FSFontInfo2 describes the mapping of codes for a given character set to the
+ * glyphs that are drawn to represent the character.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by FSFontInfo by adding a language
+ * attribute which is support to support line-breaking when displaying text in
+ * different spoken languages. Support for small fonts was added in Flash 7.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * The class allows the font associated with a Flash file to be mapped to a font
+ * installed on the device where the Flash Player displaying the file is hosted.
+ * The use of a font from a device is not automatic but is determined by the
+ * HTML tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when
+ * it is first started. If a device does not support a given font then the
+ * glyphs in the FSDefineFont class are used to render the characters.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * An important distinction between the host device to specify the font and
+ * using the glyphs in an FSDefineFont object is that the device is not
+ * anti-aliased and the rendering is dependent on the host device. The glyphs in
+ * an FSDefineFont object are anti-aliased and are guaranteed to look identical
+ * on every device the text is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier for an FSDefineFont object that contains all the
+ * glyphs for the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;small&lt;/td&gt;
+ * &lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;encoding&lt;/td&gt;
+ * &lt;td&gt;Specifies whether the character codes areTransform.ANSI,Transform.SJIS,
+ * Unicode.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Whether the font is bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;italic&lt;/td&gt;
+ * &lt;td&gt;Whether the font is italicised.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;language&lt;/td&gt;
+ * &lt;td&gt;A code identifying the spoken language for a font, either Latin,
+ * Japanese, Korean, SimplifiedChinese or TraditionalChinese. The language code
+ * is used to assist in determining the position of line breaks in text
+ * displayed using the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;codes&lt;/td&gt;
+ * &lt;td&gt;An array mapping a glyph index to a particular character code in the
+ * font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The index of each entry in the codes array matches the index in the
+ * corresponding glyph in the shapes array of an FSDefineFont object, allowing a
+ * given character code to be mapped to a given glyph.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFontInfo2 class supports the DefineFontInfo2 data structure introduced
+ * in Flash 6. Support for small fonts was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSFontInfo2 extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;p&gt;The class allows the font associated with a Flash file to be mapped to a font installed on the device where the Flash Player displaying the file is hosted. The use of a font from a device is not automatic but is determined by the HTML tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when it is first started. If a device does not support a given font then the glyphs in the FSDefineFont class are used to render the characters.&lt;/p&gt;
+	private String name = &quot;&quot;;
 
-&lt;p&gt;An important distinction between the host device to specify the font and using the glyphs in an FSDefineFont object is that the device is not anti-aliased and the rendering is dependent on the host device. The glyphs in an FSDefineFont object are anti-aliased and are guaranteed to look identical on every device the text is displayed.&lt;/p&gt;
+	private boolean small = false;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int encoding = FSText.Unicode;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private boolean italic = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private boolean bold = false;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The unique identifier for an FSDefineFont object that contains all the glyphs for the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_2&quot;&gt;name&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The name of the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_3&quot;&gt;small&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_4&quot;&gt;encoding&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Specifies whether the character codes areTransform.ANSI,Transform.SJIS, Unicode.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_5&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is bold.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_6&quot;&gt;italic&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is italicised.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_7&quot;&gt;language&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A code identifying the spoken language for a font, either Latin, Japanese, Korean, SimplifiedChinese or TraditionalChinese. The language code is used to assist in determining the position of line breaks in text displayed using the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_8&quot;&gt;codes&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An array mapping a glyph index to a particular character code in the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	private int language = 1; // FSText.Latin
 
-&lt;p&gt;The index of each entry in the codes array matches the index in the corresponding glyph in the shapes array of an FSDefineFont object, allowing a given character code to be mapped to a given glyph.&lt;/p&gt;
+	private ArrayList codes = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Construct an FSFontInfo2 object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFontInfo2(FSCoder coder)
+	{
+		super(FontInfo2);
+		decode(coder);
+	}
 
-&lt;p&gt;The FSFontInfo2 class supports the DefineFontInfo2 data structure introduced 
-in Flash 6. Support for small fonts was added in Flash 7.&lt;/p&gt;
- */  
-public class FSFontInfo2 extends FSMovieObject
-{
-    private int identifier = 0;
-    private String name = &quot;&quot;;
-    private boolean small = false;
-    private int encoding = FSText.Unicode;
-    private boolean italic = false;
-    private boolean bold = false;
-    private int language = 1; // FSText.Latin
-    private ArrayList codes = new ArrayList();
-    
-    /**
-     * Construct an FSFontInfo2 object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFontInfo2(FSCoder coder)
-    {
-        super(FontInfo2);
-        decode(coder);
-    }
-    /**  Constructs a basic FSFontInfo2 object specifying only the name of the font.
-    
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        @param aName the name assigned to the font, identifying the font family.
-        */
-    public FSFontInfo2(int anIdentifier, String aName)
-    {
-        super(FontInfo2);
-        setIdentifier(anIdentifier);
-        setName(aName);
-    }
-    /**
-     * Constructs an FSFontInfo2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSFontInfo2 object.
-     */
-    public FSFontInfo2(FSFontInfo2 obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        name = new String(obj.name);
-        encoding = obj.encoding;
-        small = obj.small;
-        italic = obj.italic;
-        bold = obj.bold;
-        language = obj.language;
-        
-        codes = new ArrayList(obj.codes.size());
-        
-        for (Iterator i = obj.codes.iterator(); i.hasNext();)
-            codes.add(new Integer(((Integer)i.next()).intValue()));
-    }    
+	/**
+	 * Constructs a basic FSFontInfo2 object specifying only the name of the
+	 * font.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 * @param aName
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public FSFontInfo2(int anIdentifier, String aName)
+	{
+		super(FontInfo2);
+		setIdentifier(anIdentifier);
+		setName(aName);
+	}
 
-    /** Gets the identifier of the font that this font information is for.
+	/**
+	 * Constructs an FSFontInfo2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSFontInfo2 object.
+	 */
+	public FSFontInfo2(FSFontInfo2 obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		name = new String(obj.name);
+		encoding = obj.encoding;
+		small = obj.small;
+		italic = obj.italic;
+		bold = obj.bold;
+		language = obj.language;
 
-        @return the identifier of the FSDefineFont object that contains the glyphs for the font.
-        */
-    public int getIdentifier() { return identifier; }
+		codes = new ArrayList(obj.codes.size());
 
-    /** Gets the name of the font family.
+		for (Iterator i = obj.codes.iterator(); i.hasNext();)
+			codes.add(new Integer(((Integer) i.next()).intValue()));
+	}
 
-        @return the name of the font.
-        */
-    public String getName() 
-    {
-        return name;
-    }
+	/**
+	 * Gets the identifier of the font that this font information is for.
+	 * 
+	 * @return the identifier of the FSDefineFont object that contains the
+	 *         glyphs for the font.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-    /** 
-     * Gets the encoding scheme used for characters rendered in the font, either FSText.ASCII, 
-     * FSText.SJIS or FSText.Unicode.
+	/**
+	 * Gets the name of the font family.
+	 * 
+	 * @return the name of the font.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-        @return the font character encoding.
-        */
-    public int getEncoding() 
-    {
-        return encoding;
-    }
+	/**
+	 * Gets the encoding scheme used for characters rendered in the font, either
+	 * FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	 * 
+	 * @return the font character encoding.
+	 */
+	public int getEncoding()
+	{
+		return encoding;
+	}
 
-// Flash 7
-    /** Does the font have a small point size. This is used only with a Unicode 
-     *  font encoding.
-     * 
-     *  @return a boolean indicating whether the font will be aligned on pixel boundaries.
-     */
-    public boolean isSmall() 
-    {
-        return small;
-    }
+	// Flash 7
+	/**
+	 * Does the font have a small point size. This is used only with a Unicode
+	 * font encoding.
+	 * 
+	 * @return a boolean indicating whether the font will be aligned on pixel
+	 *         boundaries.
+	 */
+	public boolean isSmall()
+	{
+		return small;
+	}
 
-    /** Sets the font is small. Used only with Unicode fonts.
-     * 
-     *  @param aBool a boolean flag indicating the font will be aligned on pixel boundaries.
-     */
-    public void setSmall(boolean aBool)
-    {
-        small = aBool;
-    }
-// Flash 7
+	/**
+	 * Sets the font is small. Used only with Unicode fonts.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating the font will be aligned on pixel
+	 *            boundaries.
+	 */
+	public void setSmall(boolean aBool)
+	{
+		small = aBool;
+	}
 
-    /** Is the font italics.
+	// Flash 7
 
-        @return a boolean indicating whether the font is rendered in italics.
-        */
-    public boolean isItalic() 
-    {
-        return italic;
-    }
+	/**
+	 * Is the font italics.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in italics.
+	 */
+	public boolean isItalic()
+	{
+		return italic;
+	}
 
-    /** Is the font bold.
+	/**
+	 * Is the font bold.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in a bold face.
+	 */
+	public boolean isBold()
+	{
+		return bold;
+	}
 
-        @return a boolean indicating whether the font is rendered in a bold face.
-        */
-    public boolean isBold()
-    {
-        return bold;
-    }
+	/**
+	 * Gets the language code identifying the type of spoken language for the
+	 * font, either FSText.Japanese, FSText.Korean, FSText.Latin,
+	 * FSText.SimplifiedChinese or FSText.TraditionalChinese.
+	 * 
+	 * @return the language code used to determine how line-breaks are inserted
+	 *         into text rendered using the font.
+	 */
+	public int getLanguage()
+	{
+		return language;
+	}
 
-    /** 
-     * Gets the language code identifying the type of spoken language for the font, 
-     * either FSText.Japanese, FSText.Korean, FSText.Latin, FSText.SimplifiedChinese or 
-     * FSText.TraditionalChinese.
+	/**
+	 * Gets the array of character codes.
+	 * 
+	 * @return the array of character codes.
+	 */
+	public ArrayList getCodes()
+	{
+		return codes;
+	}
 
-        @return the language code used to determine how line-breaks are inserted into 
-        text rendered using the font.
-        */
-    public int getLanguage()
-    {
-        return language;
-    }
+	/**
+	 * Sets the identifier of the font that this font information is for.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /** Gets the array of character codes.
+	/**
+	 * Sets the name of the font.
+	 * 
+	 * @param aString
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-        @return the array of character codes.
-        */
-    public ArrayList getCodes()
-    {
-        return codes;
-    }
+	/**
+	 * Sets the font character encoding.
+	 * 
+	 * @param anEncoding
+	 *            the encoding used to identify characters, either FSText.ASCII,
+	 *            FSText.SJIS or FSText.Unicode.
+	 */
+	public void setEncoding(int anEncoding)
+	{
+		encoding = anEncoding;
+	}
 
-    /** Sets the identifier of the font that this font information is for.
+	/**
+	 * Sets the font is italics.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            italics.
+	 */
+	public void setItalic(boolean aBool)
+	{
+		italic = aBool;
+	}
 
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	/**
+	 * Sets the font is bold.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            bold face.
+	 */
+	public void setBold(boolean aBool)
+	{
+		bold = aBool;
+	}
 
-    /** Sets the name of the font.
+	/**
+	 * Sets the language code used to determine the position of line-breaks in
+	 * text rendered using the font.
+	 * 
+	 * The language attribute is ignored if the object is encoded in a Flash 5
+	 * movie.
+	 * 
+	 * @param code
+	 *            the code identifying the spoken language either Latin,
+	 *            Japanese, Korean, SimplifiedChinese or TraditionalChinese.
+	 */
+	public void setLanguage(int code)
+	{
+		language = code;
+	}
 
-        @param aString the name assigned to the font, identifying the font family.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+	/**
+	 * Sets the array of character codes.
+	 * 
+	 * @param anArray
+	 *            the array mapping glyphs to particular character codes. The
+	 *            ordinal position of a character code in the array identifies
+	 *            the index of the corresponding glyph in the FSDefineFont
+	 *            object.
+	 */
+	public void setCodes(ArrayList anArray)
+	{
+		codes = anArray;
+	}
 
-    /** Sets the font character encoding.
+	public Object clone()
+	{
+		FSFontInfo2 anObject = (FSFontInfo2) super.clone();
 
-        @param anEncoding the encoding used to identify characters, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
-        */
-    public void setEncoding(int anEncoding)
-    {
-        encoding = anEncoding;
-    }
+		anObject.codes = new ArrayList();
 
-    /** Sets the font is italics.
+		for (Iterator i = codes.iterator(); i.hasNext();)
+			anObject.codes.add(new Integer(((Integer) i.next()).intValue()));
 
-        @param aBool a boolean flag indicating whether the font will be rendered in italics.
-        */
-    public void setItalic(boolean aBool)
-    {
-        italic = aBool;
-    }
+		return anObject;
+	}
 
-    /** Sets the font is bold.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aBool a boolean flag indicating whether the font will be rendered in bold face.
-        */
-    public void setBold(boolean aBool)
-    {
-        bold = aBool;
-    }
+		if (super.equals(anObject))
+		{
+			FSFontInfo2 typedObject = (FSFontInfo2) anObject;
 
-    /** Sets the language code used to determine the position of line-breaks in text rendered using the font.
-    
-        The language attribute is ignored if the object is encoded in a Flash 5 movie.
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; encoding == typedObject.encoding;
+			result = result &amp;&amp; small == typedObject.small;
+			result = result &amp;&amp; italic == typedObject.italic;
+			result = result &amp;&amp; bold == typedObject.bold;
+			result = result &amp;&amp; language == typedObject.language;
 
-        @param code the code identifying the spoken language either Latin, Japanese, Korean, SimplifiedChinese or TraditionalChinese.
-        */
-    public void setLanguage(int code)
-    {
-        language = code;
-    }
+			if (name != null)
+				result = result &amp;&amp; name.equals(typedObject.name);
+			else
+				result = result &amp;&amp; name == typedObject.name;
 
-    /** Sets the array of character codes.
+			if (codes != null)
+				result = result &amp;&amp; codes.equals(typedObject.codes);
+			else
+				result = result &amp;&amp; codes == typedObject.codes;
+		}
+		return result;
+	}
 
-        @param anArray the array mapping glyphs to particular character codes. The ordinal position of a character code in the array identifies the index of the corresponding glyph in the FSDefineFont object.
-        */
-    public void setCodes(ArrayList anArray)
-    {
-        codes = anArray;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    public Object clone()
-    {
-        FSFontInfo2 anObject = (FSFontInfo2)super.clone();
-        
-        anObject.codes = new ArrayList();
-            
-        for (Iterator i = codes.iterator(); i.hasNext();)
-            anObject.codes.add(new Integer(((Integer)i.next()).intValue()));
+		buffer.append(&quot;FSFontInfo2: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;encoding = &quot;).append(encoding).append(&quot;; &quot;);
+		// Flash 7
+		buffer.append(&quot;small = &quot;).append(small).append(&quot;; &quot;);
+		// End Flash 7
+		buffer.append(&quot;italic = &quot;).append(italic).append(&quot;; &quot;);
+		buffer.append(&quot;bold = &quot;).append(bold).append(&quot;; &quot;);
+		buffer.append(&quot;language = &quot;).append(language).append(&quot;; &quot;);
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
+		buffer.append(&quot;codes = &quot;).append(codes.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        return anObject;
-    }
+		return buffer.toString();
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSFontInfo2 typedObject = (FSFontInfo2)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; encoding == typedObject.encoding;
-            result = result &amp;&amp; small == typedObject.small;
-            result = result &amp;&amp; italic == typedObject.italic;
-            result = result &amp;&amp; bold == typedObject.bold;
-            result = result &amp;&amp; language == typedObject.language;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-            if (name != null)
-                result = result &amp;&amp; name.equals(typedObject.name);
-            else
-                result = result &amp;&amp; name == typedObject.name;
+		length += 4;
+		length += coder.strlen(name, false);
+		length += 1;
+		length += codes.size() * 2;
 
-            if (codes != null)
-                result = result &amp;&amp; codes.equals(typedObject.codes);
-            else
-                result = result &amp;&amp; codes == typedObject.codes;
-        }
-        return result;
-    }
+		return length;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;encoding&quot;, encoding);
-// Flash 7
-            Transform.append(buffer, &quot;small&quot;, small);
-// End Flash 7
-            Transform.append(buffer, &quot;italic&quot;, italic);
-            Transform.append(buffer, &quot;bold&quot;, bold);
-            Transform.append(buffer, &quot;language&quot;, language);
-            Transform.append(buffer, &quot;name&quot;, name);
-            Transform.append(buffer, &quot;codes&quot;, codes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        length += coder.strlen(name, false);
-        length += 1;
-        length += codes.size()*2;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {    
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        coder.writeWord(coder.strlen(name, false), 1);
-        coder.writeString(name);
-        coder.writeBits(0, 2);
-        coder.writeBits(small ? 1 : 0, 1);
-        coder.writeBits(encoding, 2);
-        coder.writeBits(italic ? 1 : 0, 1);
-        coder.writeBits(bold ? 1 : 0, 1);
-        coder.writeBits(1, 1);
-        coder.writeWord(language, 1);
-    
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-            coder.writeWord(((Integer)codesIterator.next()).intValue(), 2);    
+		coder.writeWord(identifier, 2);
+		coder.writeWord(coder.strlen(name, false), 1);
+		coder.writeString(name);
+		coder.writeBits(0, 2);
+		coder.writeBits(small ? 1 : 0, 1);
+		coder.writeBits(encoding, 2);
+		coder.writeBits(italic ? 1 : 0, 1);
+		coder.writeBits(bold ? 1 : 0, 1);
+		coder.writeBits(1, 1);
+		coder.writeWord(language, 1);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int nameLength = 0;
-        
-        codes = new ArrayList();
-        
-         super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        nameLength = coder.readWord(1, false);
-        name = coder.readString(nameLength);
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+			coder.writeWord(((Integer) codesIterator.next()).intValue(), 2);
+	}
 
-        if (name.length() &gt; 0)
-        {
-            while (name.charAt(name.length()-1) == 0) {
-            	name = name.substring(0, name.length()-1);
-            }
-        }
-        
-        /* reserved */ coder.readBits(2, false);
-        small = coder.readBits(1, false) != 0 ? true : false;
-        encoding = coder.readBits(2, false);
-        italic = coder.readBits(1, false) != 0 ? true : false;
-        bold = coder.readBits(1, false) != 0 ? true : false;
-        /* containsWideCodes */ coder.readBits(1, false);
+	public void decode(FSCoder coder)
+	{
+		int nameLength = 0;
 
-        int bytesRead = 4 + nameLength + 1;
+		codes = new ArrayList();
 
-        language = coder.readWord(1, false);
+		super.decode(coder);
 
-        while (bytesRead &lt; length)
-        {
-            codes.add(new Integer(coder.readWord(2, false)));
-            bytesRead += 2;
-        }
+		identifier = coder.readWord(2, false);
+		nameLength = coder.readByte();
+		name = coder.readString(nameLength);
 
-        coder.endObject(name());
-    }
+		if (name.length() &gt; 0)
+		{
+			while (name.charAt(name.length() - 1) == 0)
+			{
+				name = name.substring(0, name.length() - 1);
+			}
+		}
+
+		/* reserved */coder.readBits(2, false);
+		small = coder.readBits(1, false) != 0 ? true : false;
+		encoding = coder.readBits(2, false);
+		italic = coder.readBits(1, false) != 0 ? true : false;
+		bold = coder.readBits(1, false) != 0 ? true : false;
+		/* containsWideCodes */coder.readBits(1, false);
+
+		int bytesRead = 4 + nameLength + 1;
+
+		language = coder.readByte();
+
+		while (bytesRead &lt; length)
+		{
+			codes.add(new Integer(coder.readWord(2, false)));
+			bytesRead += 2;
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSFrame.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSFrame.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSFrame.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -30,291 +30,304 @@
 
 package com.flagstone.transform;
 
-
 import java.util.*;
 import com.flagstone.transform.*;
 
-/** 
- * The Frame class is used to provide a higher level view of a movie. Rather 
- * than viewing movies as a sequence of individual objects each representing a 
- * given data structure in the encoded Flash file, objects can be grouped together 
- * in frames which presents a more logical view of a movie and makes movie
- * manipulation and search for specific objects easier to handle.
+/**
+ * The Frame class is used to provide a higher level view of a movie. Rather
+ * than viewing movies as a sequence of individual objects each representing a
+ * given data structure in the encoded Flash file, objects can be grouped
+ * together in frames which presents a more logical view of a movie and makes
+ * movie manipulation and search for specific objects easier to handle.
  * 
  * Each Frame object has the following attributes:
- *
+ * 
  * number - The position in the movie when the frame will be displayed.
  * 
- * label - An optional name assigned to a frame. The FSGotoFrame2 object can 
- * be used to move to a named frame when playing a movie or movie clip.
+ * label - An optional name assigned to a frame. The FSGotoFrame2 object can be
+ * used to move to a named frame when playing a movie or movie clip.
  * 
- * definitions - An array containing objects that define items for display in a 
- * movie. Definitions are sub-classes of the FSDefineObject class and define shapes, 
- * fonts, images and sounds that are displayed or played by the Flash Player.
- *
- * commands - An array containing objects that define commands that affect the 
+ * definitions - An array containing objects that define items for display in a
+ * movie. Definitions are sub-classes of the FSDefineObject class and define
+ * shapes, fonts, images and sounds that are displayed or played by the Flash
+ * Player.
+ * 
+ * commands - An array containing objects that define commands that affect the
  * display list or the Flash Player directly.
  * 
- * actions - An array that define actions that are executed when a frame is displayed.
- *
- * Frame objects simplify the handling of movies. FSDoAction, FSFrameLabel and 
- * FSShowFrame classes can now &quot;hidden&quot; from view. They are generated automatically 
- * by the FSFrame object when it is added to an FSMovie object.
+ * actions - An array that define actions that are executed when a frame is
+ * displayed.
  * 
- * The framesFromMovie(FSMovie aMovie) method allows an existing movie to be 
- * viewed as an array of FSFrame objects. Objects from the movie are copied into 
- * each frame so changes made to the attributes of each object are reflected 
- * in the movie. The frame objects are not synchronised with the movie, so any 
- * objects added to a frame are not added to the FSMovie. The easiest way to do 
+ * Frame objects simplify the handling of movies. FSDoAction, FSFrameLabel and
+ * FSShowFrame classes can now &quot;hidden&quot; from view. They are generated
+ * automatically by the FSFrame object when it is added to an FSMovie object.
+ * 
+ * The framesFromMovie(FSMovie aMovie) method allows an existing movie to be
+ * viewed as an array of FSFrame objects. Objects from the movie are copied into
+ * each frame so changes made to the attributes of each object are reflected in
+ * the movie. The frame objects are not synchronised with the movie, so any
+ * objects added to a frame are not added to the FSMovie. The easiest way to do
  * this is to remove the existing objects from the movie and add all the frames.
- *
- * ArrayList frames = FSFrame.framesFromMovie(aMovie);
- * ...
- * ...
+ * 
+ * ArrayList frames = FSFrame.framesFromMovie(aMovie); ... ...
  * aMovie.getObjects().clear();
- *   
+ * 
  * for (Iterator i = frames.iterator(); i.hasNext();)
- *     ((FSFrame)i.next()).addToMovie(aMovie);
- *
- * When the contents of an FSFrame object is added to a movie if a label defined 
- * then an FSFrameLabel object will be added. Similarly if actions are defined 
- * then an FSDoAction object will be added. An FSShowFrame object which instructs
- * the Flash Player to update the display list with all the changes is added.
- *
+ * ((FSFrame)i.next()).addToMovie(aMovie);
+ * 
+ * When the contents of an FSFrame object is added to a movie if a label defined
+ * then an FSFrameLabel object will be added. Similarly if actions are defined
+ * then an FSDoAction object will be added. An FSShowFrame object which
+ * instructs the Flash Player to update the display list with all the changes is
+ * added.
+ * 
  */
 public final class FSFrame
 {
-    /** 
-     * Create a frame based view of a movie. Objects from the movie are grouped 
-     * into Frame objects. Objects from the movie are added to the frame so any 
-     * changes made are reflected in the movie. However objects added or removed 
-     * from a frame are not reflected in the movie.
-     * 
-     * @param aMovie an FSMovie object.
-     * @return an array of Frame objects.
-     */
-    public static ArrayList framesFromMovie(FSMovie aMovie)
-    {
-        ArrayList frames = new ArrayList();
+	/**
+	 * Create a frame based view of a movie. Objects from the movie are grouped
+	 * into Frame objects. Objects from the movie are added to the frame so any
+	 * changes made are reflected in the movie. However objects added or removed
+	 * from a frame are not reflected in the movie.
+	 * 
+	 * @param aMovie
+	 *            an FSMovie object.
+	 * @return an array of Frame objects.
+	 */
+	public static ArrayList framesFromMovie(FSMovie aMovie)
+	{
+		ArrayList frames = new ArrayList();
 
-        FSFrame currentFrame = new FSFrame();
- 
-        for (Iterator i = aMovie.getObjects().iterator(); i.hasNext();)
-        {
-            FSMovieObject currentObject = (FSMovieObject)i.next();
-            
-            if (currentObject instanceof FSDoAction)
-            {
-                currentFrame.actions = ((FSDoAction)currentObject).getActions();
-            }
-            else if (currentObject instanceof FSFrameLabel)
-            {
-                currentFrame.label = ((FSFrameLabel)currentObject).getLabel();
-            }
-            else if (currentObject instanceof FSDefineObject)
-            {
-                currentFrame.addDefinition((FSDefineObject)currentObject);
-            }
-			else if (currentObject instanceof FSShowFrame)
+		FSFrame currentFrame = new FSFrame();
+
+		for (Iterator i = aMovie.getObjects().iterator(); i.hasNext();)
+		{
+			FSMovieObject currentObject = (FSMovieObject) i.next();
+
+			if (currentObject instanceof FSDoAction)
 			{
-                frames.add(currentFrame);
-                currentFrame = new FSFrame();
+				currentFrame.actions = ((FSDoAction) currentObject)
+								.getActions();
+			} else if (currentObject instanceof FSFrameLabel)
+			{
+				currentFrame.label = ((FSFrameLabel) currentObject).getLabel();
+			} else if (currentObject instanceof FSDefineObject)
+			{
+				currentFrame.addDefinition((FSDefineObject) currentObject);
+			} else if (currentObject instanceof FSShowFrame)
+			{
+				frames.add(currentFrame);
+				currentFrame = new FSFrame();
+			} else
+			{
+				currentFrame.addCommand(currentObject);
 			}
-            else
-            {
-                currentFrame.addCommand(currentObject);
-            }   
-        }
-        return frames;
-     }    
+		}
+		return frames;
+	}
 
-    private String label = null;
-    private ArrayList definitions = null;
-    private ArrayList commands = null;
-    private ArrayList actions = null;
+	private String label = null;
 
-    /** 
-     * Constructs an empty frame with no label defined and the definitions, 
-     * commands and actions arrays empty.
-     */
-    public FSFrame()
-    {
-        definitions = new ArrayList();
-        commands = new ArrayList();
-        actions = new ArrayList();
-    }
+	private ArrayList definitions = null;
 
-    /** 
-     * Constructs a frame with with the specified label, definitions, commands
-     * and actions. The label is optional and may be set to null if no label is 
-     * defined. Similarly if no definitions, commands or actions are defined for 
-     * a given frame then the corresponding argument may be set to null.
-     * 
-     * @param label a label for the frame. Maybe null if no label is defined.
-     * 
-     * @param definitions an array of definition objects. Maybe null if no 
-     * definitions are defined.
-     * 
-     * @param commands an array of objects used to manipulate the display list. 
-     * Maybe null if no display list commands are defined.
-     * 
-     * @param actions an array of action objects that will be executed when the 
-     * frame is displayed. Maybe null if no actions are defined.
-     */
-    public FSFrame(String label, ArrayList definitions, ArrayList commands, ArrayList actions)
-    {
-        setLabel(label);
-        setDefinitions(definitions);
-        setCommands(commands);
-        setActions(actions);
-    }
+	private ArrayList commands = null;
 
-    /** 
-     * Adds the action object to the frame.
-     * 
-     * @param anObject the action object to be added to the frame.
-     */
-    public void addAction(FSActionObject anObject)
-    {
-    	if (actions == null)
-    		actions = new ArrayList();
-    		
-        actions.add(anObject);
-    }
+	private ArrayList actions = null;
 
-    /** 
-     * Adds an object to the frame that defines an object to be displayed in the 
-     * movie.
-     * 
-     * @param anObject a sub-class of FSDefineObject.
-     */
-    public void addDefinition(FSDefineObject anObject)
-    {
+	/**
+	 * Constructs an empty frame with no label defined and the definitions,
+	 * commands and actions arrays empty.
+	 */
+	public FSFrame()
+	{
+		definitions = new ArrayList();
+		commands = new ArrayList();
+		actions = new ArrayList();
+	}
+
+	/**
+	 * Constructs a frame with with the specified label, definitions, commands
+	 * and actions. The label is optional and may be set to null if no label is
+	 * defined. Similarly if no definitions, commands or actions are defined for
+	 * a given frame then the corresponding argument may be set to null.
+	 * 
+	 * @param label
+	 *            a label for the frame. Maybe null if no label is defined.
+	 * 
+	 * @param definitions
+	 *            an array of definition objects. Maybe null if no definitions
+	 *            are defined.
+	 * 
+	 * @param commands
+	 *            an array of objects used to manipulate the display list. Maybe
+	 *            null if no display list commands are defined.
+	 * 
+	 * @param actions
+	 *            an array of action objects that will be executed when the
+	 *            frame is displayed. Maybe null if no actions are defined.
+	 */
+	public FSFrame(String label, ArrayList definitions, ArrayList commands,
+					ArrayList actions)
+	{
+		setLabel(label);
+		setDefinitions(definitions);
+		setCommands(commands);
+		setActions(actions);
+	}
+
+	/**
+	 * Adds the action object to the frame.
+	 * 
+	 * @param anObject
+	 *            the action object to be added to the frame.
+	 */
+	public void addAction(FSActionObject anObject)
+	{
+		if (actions == null)
+			actions = new ArrayList();
+
+		actions.add(anObject);
+	}
+
+	/**
+	 * Adds an object to the frame that defines an object to be displayed in the
+	 * movie.
+	 * 
+	 * @param anObject
+	 *            a sub-class of FSDefineObject.
+	 */
+	public void addDefinition(FSDefineObject anObject)
+	{
 		if (definitions == null)
 			definitions = new ArrayList();
-    		
-        definitions.add(anObject);
-    }
 
-    /** 
-     * Adds the display list command to the frame.
-     * 
-     * @param anObject an FSMovieObject the manipulates the display list.
-     */
-    public void addCommand(FSMovieObject anObject)
-    {
-        commands.add(anObject);
-    }
+		definitions.add(anObject);
+	}
 
-    /** 
-     * Gets the label assigned to the frame.
-     * 
-     * @return the label.
-     */
-    public String getLabel()
-    {
-        return label;
-    }
+	/**
+	 * Adds the display list command to the frame.
+	 * 
+	 * @param anObject
+	 *            an FSMovieObject the manipulates the display list.
+	 */
+	public void addCommand(FSMovieObject anObject)
+	{
+		commands.add(anObject);
+	}
 
-    /** 
-     * Gets the array of definition objects contained in the frame.
-     * 
-     * @return the array of definitions.
-     */
-    public ArrayList getDefinitions()
-    {
-        return definitions;
-    }
+	/**
+	 * Gets the label assigned to the frame.
+	 * 
+	 * @return the label.
+	 */
+	public String getLabel()
+	{
+		return label;
+	}
 
-    /**
-     * Gets the array of commands that update the display list. 
-     * 
-     * @return the array of commands objects.
-     */
-    public ArrayList getCommands()
-    {
-        return commands;
-    }
+	/**
+	 * Gets the array of definition objects contained in the frame.
+	 * 
+	 * @return the array of definitions.
+	 */
+	public ArrayList getDefinitions()
+	{
+		return definitions;
+	}
 
-    /**
-     * Gets the array of action objects that will be execute when the frame is 
-     * displayed.
-     * 
-     * @return the array of actions defined for the frame.
-     */
-    public ArrayList getActions()
-    {
-        return actions;
-    }
-    
-    /** 
-     * Sets the label for the frame.
-     * 
-     * @param aString the label.
-     */
-    public void setLabel(String aString)
-    {
-    	label = aString;
-    }
+	/**
+	 * Gets the array of commands that update the display list.
+	 * 
+	 * @return the array of commands objects.
+	 */
+	public ArrayList getCommands()
+	{
+		return commands;
+	}
 
-    /** 
-     * Sets the array of action objects for the frame.
-     * 
-     * @param anArray the array of actions.
-     */
-    public void setDefinitions(ArrayList anArray)
-    {
-        definitions = anArray;
-    }
+	/**
+	 * Gets the array of action objects that will be execute when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of actions defined for the frame.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-    /** 
-     * Sets the array of commands that updated the display list for the frame. 
-     * The changes are visible when the frame is displayed.
-     *
-     * @param anArray the array of command objects.
-     */
-    public void setCommands(ArrayList anArray)
-    {
-        commands = anArray;
-    }
+	/**
+	 * Sets the label for the frame.
+	 * 
+	 * @param aString
+	 *            the label.
+	 */
+	public void setLabel(String aString)
+	{
+		label = aString;
+	}
 
-    /** 
-     * Sets the array of action objects for the frame.
-     * 
-     * @param anArray the array of actions.
-     */
-    public void setActions(ArrayList anArray)
-    {
-    	actions = anArray;
-    }
+	/**
+	 * Sets the array of action objects for the frame.
+	 * 
+	 * @param anArray
+	 *            the array of actions.
+	 */
+	public void setDefinitions(ArrayList anArray)
+	{
+		definitions = anArray;
+	}
 
-    /** 
-     * Add the objects in the frame to the movie. The contents of the definitions 
-     * and commands arrays are added to the movie. If a label is assigned to the 
-     * frame then an FSFrameLabel object is added to the movie. If actions are 
-     * defined then an FSDoAction object is added containing the actions defined 
-     * in the frame. 
-     * 
-     * @param aMovie an FSMovie object.
-     */
-    public void addToMovie(FSMovie aMovie)
-    {
-    	if (definitions != null || definitions.size() &gt; 0)
-    	{
+	/**
+	 * Sets the array of commands that updated the display list for the frame.
+	 * The changes are visible when the frame is displayed.
+	 * 
+	 * @param anArray
+	 *            the array of command objects.
+	 */
+	public void setCommands(ArrayList anArray)
+	{
+		commands = anArray;
+	}
+
+	/**
+	 * Sets the array of action objects for the frame.
+	 * 
+	 * @param anArray
+	 *            the array of actions.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
+
+	/**
+	 * Add the objects in the frame to the movie. The contents of the
+	 * definitions and commands arrays are added to the movie. If a label is
+	 * assigned to the frame then an FSFrameLabel object is added to the movie.
+	 * If actions are defined then an FSDoAction object is added containing the
+	 * actions defined in the frame.
+	 * 
+	 * @param aMovie
+	 *            an FSMovie object.
+	 */
+	public void addToMovie(FSMovie aMovie)
+	{
+		if (definitions != null || definitions.size() &gt; 0)
+		{
 			for (Iterator i = definitions.iterator(); i.hasNext();)
-				aMovie.add((FSMovieObject)i.next());
-    	}
-            
-        if (label != null &amp;&amp; label.length() &gt; 0)
-            aMovie.add(new FSFrameLabel(label));
+				aMovie.add((FSMovieObject) i.next());
+		}
 
+		if (label != null &amp;&amp; label.length() &gt; 0)
+			aMovie.add(new FSFrameLabel(label));
+
 		if (actions != null &amp;&amp; actions.size() &gt; 0)
 			aMovie.add(new FSDoAction(actions));
 
-        for (Iterator j = commands.iterator(); j.hasNext();)
-            aMovie.add((FSMovieObject)j.next());
-            
-        aMovie.add(new FSShowFrame());
-    }
+		for (Iterator j = commands.iterator(); j.hasNext();)
+			aMovie.add((FSMovieObject) j.next());
+
+		aMovie.add(new FSShowFrame());
+	}
 }
-

Modified: dev/dev-2-4/src/com/flagstone/transform/FSFrameLabel.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSFrameLabel.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSFrameLabel.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -34,306 +34,378 @@
 import java.util.Iterator;
 
 /**
-FSFrameLabel defines a name for the current frame in a movie or movie clip.
+ * FSFrameLabel defines a name for the current frame in a movie or movie clip.
+ * 
+ * &lt;p&gt;
+ * The name can be referenced from other objects such as FSGotoFrame2 to
+ * simplify the creation of scripts to control movies by using a predefined name
+ * rather than the frame number. The label assigned to a particular frame should
+ * be unique. Frames may also be reference externally when specifying the movie
+ * to play using a URL - similar to the way names links are used in HTML. When
+ * the Flash Player loaded a movie it will begin playing at the frame specified
+ * in the URL.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;label&lt;/td&gt;
+ * &lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;isAnchor&lt;/td&gt;
+ * &lt;td&gt;Will the label be used as an anchor.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The name is assigned to a particular frame when the FSFrameLabel object is
+ * defined prior to the FSShowFrame object that displays all the objects on the
+ * display list. The frame can then be referenced by its name once it has been
+ * defined. A frame cannot be referenced before the Player has loaded and
+ * displayed the frame that contains the corresponding FSFrameLabel object.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following simplified code samples illustrate how to use the FSFrameLabel
+ * class to refer to a frame by its name rather than a number.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Using the FSFrameLabel object.&lt;br/&gt; This examples uses the FSFrameLabel
+ * object to allow the movie to loop back and replay an animation starting at a
+ * named frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  movie.add(new FSFrameLabel(&quot;Frame Name&quot;));
+ *  ...
+ *  movie.add(new FSShowFrame());
+ * 
+ *  ...
+ * 
+ *  FSDoAction frameAction = new FSDoAction();
+ * 
+ *  frameAction.add(new FSPush(&quot;FirstFrame&quot;));
+ *  frameAction.add(new FSGotoFrame2(false));
+ * 
+ *  movie.add(frameAction);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Controlling a movie clip.&lt;br/&gt; The FSFrameLabel object can also be used
+ * to control the time-line of a movie clip. In this case though the mechanism
+ * is slightly different. From Flash 5 onward movie clips are defined as
+ * objects. The ExecuteMethod action is used to execute the gotoAndPlay() or
+ * gotoAndStop() methods that control a movie clip's time-line:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // First define the commands that animate the movie clip.
+ *  ArrayList commands = new ArrayList();
+ *  ...
+ *  commands.add(new FSFrameLabel(&quot;Frame Name&quot;));
+ *  commands.add(new FSShowFrame());
+ * 
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  // Add the movie clip to the display list on layer 1 at (400, 400). Give it the name
+ *  // &quot;movieClip&quot; to allow it to be referenced later.
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, &quot;movieClip&quot;, 400, 400));
+ * 
+ *  // Create the FSDoAction object that will start the movie clip playing.
+ * 
+ *  FSDoAction clipActions = new FSDoAction();
+ * 
+ *  // Movie clips objects can be controlled by executing pre-defined methods.
+ * 
+ *  // Define the arguments followed by their number for the gotoAndPlay method.
+ * 
+ *  clipActions.add(new FSPush(&quot;Frame Name&quot;));
+ *  clipActions.add(new FSPush(1));
+ * 
+ *  // Get the movie clip object using its name. It's location is specified relative to the &quot;_root&quot;
+ *  // level which represents the main time-line of the movie.
+ * 
+ *  clipActions.add(new FSPush(&quot;_root&quot;));
+ *  clipActions.add(new FSPush(&quot;movieClip&quot;));
+ *  clipActions.add(FSAction.GetAttribute());
+ * 
+ *  actions.add(new FSPush(&quot;gotoAndPlay&quot;));
+ *  actions.add(FSAction.ExecuteMethod());
+ * 
+ *  movie.add(clipActions);
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Defining an anchored frame.&lt;br/&gt; Specifying a frame name as an anchor
+ * allows a movie start playing from any frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Define the anchored frame in a movie.
+ *  movie.add(new FSFrameLabel(&quot;StartHere&quot;, true));
+ *  movie.add(new FSShowFrame());
+ *  ....
+ *  movie.encodeToFile(&quot;movie.swf&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To start playing the movie at the frame labeled &quot;StartHere&quot; specify the label
+ * using the same format a HTML anchors:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  <A HREF="http://www.flagstonesoftware.com/flash/movie.swf#StartHere">http://www.flagstonesoftware.com/flash/movie.swf#StartHere</A>
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This may be used either in a browser window to load a file or form within a
+ * movie using the FSGetUrl or FSGetUrl2 actions.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFrameLabel class represents the FrameLabel tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3. In Flash
+ * 6 the label can support named anchors which allows a frame to be specified as
+ * the starting point when displaying a Flash movie in a web browser.
+ * &lt;/p&gt;
+ */
+public class FSFrameLabel extends FSMovieObject
+{
+	private String label = null;
 
-&lt;p&gt;The name can be referenced from other objects such as FSGotoFrame2 to simplify the creation of scripts to control movies by using a predefined name rather than the frame number. The label assigned to a particular frame should be unique. Frames may also be reference externally when specifying the movie to play using a URL - similar to the way names links are used in HTML. When the Flash Player loaded a movie it will begin playing at the frame specified in the URL.&lt;/p&gt;
+	// Flash 6
+	private boolean anchor = false;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	// End Flash 6
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	FSFrameLabel()
+	{
+		super(FrameLabel);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFrameLabel_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSFrameLabel object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFrameLabel(FSCoder coder)
+	{
+		super(FrameLabel);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFrameLabel_1&quot;&gt;label&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSFrameLabel object with the specified name.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 */
+	public FSFrameLabel(String aString)
+	{
+		super(FrameLabel);
+		setLabel(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFrameLabel_2&quot;&gt;isAnchor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Will the label be used as an anchor.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 6
+	/**
+	 * Constructs an FSFrameLabel object with the specified name. If the
+	 * isAnchor flag is true then the frame will be directly selectable by a URL
+	 * and the Flash Player will begin playing the movie at the specified frame.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 * @param isAnchor
+	 *            if true the name will be used as an anchor when referencing
+	 *            the frame in a URL.
+	 */
+	public FSFrameLabel(String aString, boolean isAnchor)
+	{
+		super(FrameLabel);
+		setLabel(aString);
+		setAnchor(isAnchor);
+	}
 
-&lt;/table&gt;
+	// End Flash 6
+	/**
+	 * Constructs an FSFrameLabel object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSFrameLabel object.
+	 */
+	public FSFrameLabel(FSFrameLabel obj)
+	{
+		super(obj);
+		label = new String(label);
+		anchor = obj.anchor;
+	}
 
-&lt;p&gt;The name is assigned to a particular frame when the FSFrameLabel object is defined prior to the FSShowFrame object that displays all the objects on the display list. The frame can then be referenced by its name once it has been defined. A frame cannot be referenced before the Player has loaded and displayed the frame that contains the corresponding FSFrameLabel object.&lt;/p&gt;
+	/**
+	 * Gets the label.
+	 * 
+	 * @return the string defining the label.
+	 */
+	public String getLabel()
+	{
+		return label;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the label.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 */
+	public void setLabel(String aString)
+	{
+		label = aString;
+	}
 
-&lt;p&gt;The following simplified code samples illustrate how to use the FSFrameLabel class to refer to a frame by its name rather than a number.&lt;/P&gt;
+	// Flash 6
+	/**
+	 * Sets the label defining whether it will be referenced as an anchor or
+	 * not.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 * @param isAnchor
+	 *            if true the name will be used as an anchor when referencing
+	 *            the frame in a URL.
+	 */
+	public void setLabel(String aString, boolean isAnchor)
+	{
+		label = aString;
+		anchor = isAnchor;
+	}
 
-&lt;p&gt;1. Using the FSFrameLabel object.&lt;br/&gt;
-This examples uses the FSFrameLabel object to allow the movie to loop back and replay an animation starting at a named frame.&lt;/p&gt;
+	/**
+	 * Gets the flag indicating whether the frame name is also used as an anchor
+	 * so the frame can be referenced from outside of the movie.
+	 * 
+	 * @return true if the frame is an anchor frame, false otherwise.
+	 */
+	public boolean getAnchor()
+	{
+		return anchor;
+	}
 
-&lt;pre&gt;
-movie.add(new FSFrameLabel(&quot;Frame Name&quot;));
-...
-movie.add(new FSShowFrame());
+	/**
+	 * Sets the flag indicating whether the frame name is also used as an anchor
+	 * so the frame can be referenced from outside of the movie.
+	 * 
+	 * @param isAnchor
+	 *            true if the frame is an anchor frame, false otherwise.
+	 */
+	public void setAnchor(boolean isAnchor)
+	{
+		anchor = isAnchor;
+	}
 
-...
+	// Flash 6
 
-FSDoAction frameAction = new FSDoAction();
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-frameAction.add(new FSPush(&quot;FirstFrame&quot;));
-frameAction.add(new FSGotoFrame2(false));
+		if (super.equals(anObject))
+		{
+			FSFrameLabel typedObject = (FSFrameLabel) anObject;
 
-movie.add(frameAction);
+			if (label != null)
+				result = label.equals(typedObject.label);
+			else
+				result = typedObject.label == null;
 
-&lt;/pre&gt;
+			// Flash 6
+			result = result &amp;&amp; anchor == typedObject.anchor;
+			// Flash 7
+		}
+		return result;
+	}
 
-&lt;p&gt;2. Controlling a movie clip.&lt;br/&gt;
-The FSFrameLabel object can also be used to control the time-line of a movie clip. In this case though the mechanism is slightly different. From Flash 5 onward movie clips are defined as objects. The ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop() methods that control a movie clip's time-line:&lt;/p&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;pre&gt;
-// First define the commands that animate the movie clip.
-ArrayList commands = new ArrayList();
-...
-commands.add(new FSFrameLabel(&quot;Frame Name&quot;));
-commands.add(new FSShowFrame());
+		buffer.append(&quot;FSFrameLabel: { &quot;);
+		buffer.append(&quot;label = &quot;).append(label).append(&quot;; &quot;);
+		// Flash 6
+		buffer.append(&quot;anchor = &quot;).append(anchor).append(&quot;; &quot;);
+		// End Flash 6
+		buffer.append(&quot;}&quot;);
 
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+		return buffer.toString();
+	}
 
-// Add the movie clip to the display list on layer 1 at (400, 400). Give it the name
-// &quot;movieClip&quot; to allow it to be referenced later.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-movie.add(movieClip);
-movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, &quot;movieClip&quot;, 400, 400));
+		length += coder.strlen(label, true);
 
-// Create the FSDoAction object that will start the movie clip playing.
+		// Flash 6
+		length += anchor ? 1 : 0;
+		// End Flash 6
 
-FSDoAction clipActions = new FSDoAction();
+		return length;
+	}
 
-// Movie clips objects can be controlled by executing pre-defined methods.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeString(label);
+		coder.writeWord(0, 1);
 
-// Define the arguments followed by their number for the gotoAndPlay method.
+		// Flash 6
+		if (anchor)
+			coder.writeWord(1, 1);
+		// End Flash 6
+	}
 
-clipActions.add(new FSPush(&quot;Frame Name&quot;));
-clipActions.add(new FSPush(1));
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-// Get the movie clip object using its name. It's location is specified relative to the &quot;_root&quot;
-// level which represents the main time-line of the movie.
+		int start = coder.getPointer();
+		int strlen = 0;
 
-clipActions.add(new FSPush(&quot;_root&quot;));
-clipActions.add(new FSPush(&quot;movieClip&quot;));
-clipActions.add(FSAction.GetAttribute());
+		for (strlen = 0; coder.scanWord(1, false) != 0; coder.adjustPointer(8), strlen++)
+			;
 
-actions.add(new FSPush(&quot;gotoAndPlay&quot;));
-actions.add(FSAction.ExecuteMethod());
+		coder.setPointer(start);
+		label = coder.readString(strlen++);
+		coder.adjustPointer(8);
 
-movie.add(clipActions);
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;3. Defining an anchored frame.&lt;br/&gt;
-Specifying a frame name as an anchor allows a movie start playing from any frame.&lt;/p&gt;
-
-&lt;pre&gt;
-// Define the anchored frame in a movie.
-movie.add(new FSFrameLabel(&quot;StartHere&quot;, true));
-movie.add(new FSShowFrame());
-....
-movie.encodeToFile(&quot;movie.swf&quot;);
-&lt;/pre&gt;
-
-&lt;p&gt;To start playing the movie at the frame labeled &quot;StartHere&quot; specify the label using the same format a HTML anchors:&lt;/p&gt;
-
-&lt;pre&gt;
-<A HREF="http://www.flagstonesoftware.com/flash/movie.swf#StartHere">http://www.flagstonesoftware.com/flash/movie.swf#StartHere</A>
-&lt;/pre&gt;
-
-&lt;p&gt;This may be used either in a browser window to load a file or form within a movie using the FSGetUrl or FSGetUrl2 actions.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSFrameLabel class represents the FrameLabel tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3. In Flash 6 the label can support named anchors which allows a frame to be specified as the starting point when displaying a Flash movie in a web browser.&lt;/p&gt;
- */
-public class FSFrameLabel extends FSMovieObject
-{
-    private String label = null;
-// Flash 6
-    private boolean anchor = false;
-// End Flash 6
-
-    FSFrameLabel()
-    {
-        super(FrameLabel);
-    }
-
-    /**
-     * Construct an FSFrameLabel object, initalizing it with values decoded from
-     * an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFrameLabel(FSCoder coder)
-    {
-        super(FrameLabel);
-        decode(coder);
-    }
-    /** Constructs an FSFrameLabel object with the specified name.
-
-        @param aString the string that defines the label that will be assigned to the current frame.
-        */
-    public FSFrameLabel(String aString)
-    {
-        super(FrameLabel);
-        setLabel(aString);
-    }
-// Flash 6
-    /** Constructs an FSFrameLabel object with the specified name. If the isAnchor
-     *  flag is true then the frame will be directly selectable by a URL and the
-     *  Flash Player will begin playing the movie at the specified frame.
-     *
-     *  @param aString the string that defines the label that will be assigned to the current frame.
-     *  @param isAnchor if true the name will be used as an anchor when referencing the frame in a URL.
-     */
-    public FSFrameLabel(String aString, boolean isAnchor)
-    {
-        super(FrameLabel);
-        setLabel(aString);
-        setAnchor(isAnchor);
-    }
-// End Flash 6
-    /**
-     * Constructs an FSFrameLabel object by copying values from an existing
-     * object.
-     *
-     * @param obj an FSFrameLabel object.
-     */
-    public FSFrameLabel(FSFrameLabel obj)
-    {
-        super(obj);
-        label = new String(label);
-        anchor = obj.anchor;
-    }
-
-    /** Gets the label.
-
-        @return the string defining the label.
-        */
-    public String getLabel() { return label; }
-
-    /** Sets the label.
-
-        @param aString the string that defines the label that will be assigned to the current frame.
-        */
-    public void setLabel(String aString)
-    {
-        label = aString;
-    }
-
-// Flash 6
-    /** Sets the label defining whether it will be referenced as an anchor or not.
-     *
-     *  @param aString the string that defines the label that will be assigned to the current frame.
-     *  @param isAnchor if true the name will be used as an anchor when referencing the frame in a URL.
-     */
-    public void setLabel(String aString, boolean isAnchor)
-    {
-        label = aString;
-        anchor = isAnchor;
-    }
-
-    /** Gets the flag indicating whether the frame name is also used as an anchor
-     *  so the frame can be referenced from outside of the movie.
-     *
-     *  @return true if the frame is an anchor frame, false otherwise.
-     */
-    public boolean getAnchor() { return anchor; }
-
-    /** Sets the flag indicating whether the frame name is also used as an anchor
-     *  so the frame can be referenced from outside of the movie.
-     *
-     *  @param isAnchor true if the frame is an anchor frame, false otherwise.
-     */
-    public void setAnchor(boolean isAnchor)
-    {
-        anchor = isAnchor;
-    }
-// Flash 6
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-
-        if (super.equals(anObject))
-        {
-            FSFrameLabel typedObject = (FSFrameLabel)anObject;
-
-            if (label != null)
-                result = label.equals(typedObject.label);
-            else
-                result = typedObject.label == null;
-
-// Flash 6
-            result = result &amp;&amp;  anchor == typedObject.anchor;
-// Flash 7
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;label&quot;, label);
-// Flash 6
-            Transform.append(buffer, &quot;anchor&quot;, anchor);
-// End Flash 6
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += coder.strlen(label, true);
-
-// Flash 6
-        length += anchor ? 1 : 0;
-// End Flash 6
-
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeString(label);
-        coder.writeWord(0, 1);
-
-// Flash 6
-        if (anchor)
-            coder.writeWord(1, 1);
-// End Flash 6
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int start = coder.getPointer();
-        int strlen = 0;
-
-        for (strlen=0; coder.scanWord(1, false) != 0; coder.adjustPointer(8), strlen++);
-
-        coder.setPointer(start);
-        label = coder.readString(strlen++);
-        coder.adjustPointer(8);
-
-// Flash 6
-        if (strlen &lt; length)
-            anchor = coder.readWord(1, false) != 0 ? true : false;
-// End Flash 6
-
-        coder.endObject(name());
-    }
+		// Flash 6
+		if (strlen &lt; length)
+			anchor = coder.readByte() != 0 ? true : false;
+		// End Flash 6
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSGetUrl.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSGetUrl.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSGetUrl.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,238 +31,303 @@
 package com.flagstone.transform;
 
 /**
-FSGetUrl is used to display a web page or load a movie clip into the Flash Player.
+ * FSGetUrl is used to display a web page or load a movie clip into the Flash
+ * Player.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;url&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The fully qualified uniform resource location where the movie clip or
+ * web page will be retrieved from.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;target&lt;/td&gt;
+ * &lt;td&gt;A level in the Flash Player where the movie clip will be loaded or frame
+ * or window in the browser where the web page will be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To display a web page or new Flash movie the target can either be the name of
+ * the web browser frame or one of the following reserved words:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the frame with the name defined in an HTML
+ * &lt;frame&gt; tag.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_blank&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in a new window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_self&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the current window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_top&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the top level frame of the current window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_parent&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the parent frame of the frame where the Flash
+ * Player id displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;(blank string) opens the new page in the current frame or window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To load a movie clip into the currently playing movie then the target is a
+ * string literal of the form &quot;_level&lt;i&gt;n&lt;/i&gt;&quot;. The Flash Player supports the
+ * concept of virtual layers (analogous to the layers in the Display List).
+ * Higher levels are displayed in front of lower levels. The background of each
+ * level is transparent allowing movie clips on lower levels to be visible in
+ * areas not filled by the movie clip on a given level. The main movie is loaded
+ * into _level0. Movie clips are loaded into any level above this (1, 2, 124,
+ * etc.). If a movie clip is loaded into a level that already contains a movie
+ * clip then the existing clip is replaced by the new one.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a web page into the named frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;,">http://www.myserver.com/page.html&quot;,</A> &quot;myFrame&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a web page in a new window:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;,">http://www.myserver.com/page.html&quot;,</A> &quot;_blank&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a web page into the current window or
+ * frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;,">http://www.myserver.com/page.html&quot;,</A> &quot;&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * or
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;">http://www.myserver.com/page.html&quot;</A>);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a movie clip into the currently playing
+ * movie:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/movieClip.swf&amp;quot;,">http://www.myserver.com/movieClip.swf&quot;,</A>
+ * 				&quot;_level1&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGetUrl is a class for representing the ActionGetUrl action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSGetUrl extends FSActionObject
+{
+	private String url = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private String target = &quot;&quot;;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	FSGetUrl()
+	{
+		super(FSActionObject.GetUrl);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGetUrl_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSGetUrl object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGetUrl(FSCoder coder)
+	{
+		super(FSActionObject.GetUrl);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl_1&quot;&gt;url&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The fully qualified uniform resource location where the movie clip or web page will be retrieved from.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGetUrl with the specified url and target frame.
+	 * 
+	 * @param urlString
+	 *            a fully qualified URL.
+	 * @param targetString
+	 *            the location (in the Flash Player or web browser) where the
+	 *            contents of file retrieved via the url will be displayed.
+	 */
+	public FSGetUrl(String urlString, String targetString)
+	{
+		super(FSActionObject.GetUrl);
+		setUrl(urlString);
+		setTarget(targetString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl_2&quot;&gt;target&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A level in the Flash Player where the movie clip will be loaded or frame or window in the browser where the web page will be displayed.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSGetUrl with the specified url. The target defaults to the
+	 * current window.
+	 * 
+	 * @param urlString
+	 *            a fully qualified URL.
+	 */
+	public FSGetUrl(String urlString)
+	{
+		super(FSActionObject.GetUrl);
+		setUrl(urlString);
+	}
 
-&lt;p&gt;To display a web page or new Flash movie the target can either be the name of the web browser frame or one of the following reserved words:&lt;/p&gt;
+	/**
+	 * Constructs an FSGetUrl object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGetUrl object.
+	 */
+	public FSGetUrl(FSGetUrl obj)
+	{
+		super(obj);
+		url = new String(obj.url);
+		target = new String(obj.target);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Gets the URL.
+	 * 
+	 * @return the URL that web page or movie clip will be loaded from.
+	 */
+	public String getUrl()
+	{
+		return url;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the frame with the name defined in an HTML &lt;frame&gt; tag.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the name of the target frame.
+	 * 
+	 * @return the name of the location (in the Flash Player or web browser)
+	 *         where the web page or movie clip will be displayed.
+	 */
+	public String getTarget()
+	{
+		return target;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_blank&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in a new window.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the URL of the file to be retrieved.
+	 * 
+	 * @param aString
+	 *            a fully qualified URL.
+	 */
+	public void setUrl(String aString)
+	{
+		url = aString;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_self&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the current window.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the name of the Target where the URL will be displayed. The target
+	 * may be a frame or window in a web browser when displaying a web page or a
+	 * level in the current movie when loading a movie clip.
+	 * 
+	 * @param aString
+	 *            the name of the location (in the Flash Player or web browser)
+	 *            where contents of file retrieved via the url will be
+	 *            displayed.
+	 */
+	public void setTarget(String aString)
+	{
+		target = aString;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_top&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the top level frame of the current window.&lt;/td&gt;
-&lt;/tr&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_parent&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the parent frame of the frame where the Flash Player id displayed.&lt;/td&gt;
-&lt;/tr&gt;
+		if (super.equals(anObject))
+		{
+			FSGetUrl typedObject = (FSGetUrl) anObject;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;(blank string) opens the new page in the current frame or window.&lt;/td&gt;
-&lt;/tr&gt;
+			result = url.equals(typedObject.url);
+			result = result &amp;&amp; target.equals(typedObject.target);
+		}
+		return result;
+	}
 
-&lt;/table&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;p&gt;To load a movie clip into the currently playing movie then the target is a string literal of the form &quot;_level&lt;i&gt;n&lt;/i&gt;&quot;. The Flash Player supports the concept of virtual layers (analogous to the layers in the Display List). Higher levels are displayed in front of lower levels. The background of each level is transparent allowing movie clips on lower levels to be visible in areas not filled by the movie clip on a given level. The main movie is loaded into _level0. Movie clips are loaded into any level above this (1, 2, 124, etc.). If a movie clip is loaded into a level that already contains a movie clip then the existing clip is replaced by the new one.&lt;/p&gt;
+		buffer.append(&quot;FSGetUrl: { &quot;);
+		buffer.append(&quot;url = &quot;).append(url).append(&quot;; &quot;);
+		buffer.append(&quot;target = &quot;).append(target).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;p&gt;To create an action that will load a web page into the named frame:&lt;/p&gt;
+		length += FSCoder.strlen(url, true);
+		length += FSCoder.strlen(target, true);
 
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;, &quot;myFrame&quot;);
-&lt;/pre&gt;
+		return length;
+	}
 
-&lt;p&gt;To create an action that will load a web page in a new window:&lt;/p&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;, &quot;_blank&quot;);
-&lt;/pre&gt;
+		coder.writeString(url);
+		coder.writeWord(0, 1);
 
-&lt;p&gt;To create an action that will load a web page into the current window or frame:&lt;/p&gt;
+		coder.writeString(target);
+		coder.writeWord(0, 1);
+	}
 
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;, &quot;&quot;);
-&lt;/pre&gt;
-
-&lt;p&gt;or&lt;/p&gt;
-
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;);
-&lt;/pre&gt;
-
-&lt;p&gt;To create an action that will load a movie clip into the currently playing movie:&lt;/p&gt;
-
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/movieClip.swf">http://www.myserver.com/movieClip.swf</A>&quot;, &quot;_level1&quot;);
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSGetUrl is a class for representing the ActionGetUrl action of the Macromedia Flash (SWF) File Format Specification. It was introduced in  Flash 1.&lt;/p&gt;
- */
-public class FSGetUrl extends FSActionObject
-{
-    private String url = null;
-    private String target = &quot;&quot;;
-    
-    FSGetUrl()
-    {
-        super(FSActionObject.GetUrl);
-    }
-    /**
-     * Construct an FSGetUrl object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGetUrl(FSCoder coder)
-    {
-        super(FSActionObject.GetUrl);
-        decode(coder);
-    }
-    /** Constructs an FSGetUrl with the specified url and target frame. 
-
-        @param urlString a fully qualified URL.
-        @param targetString the location (in the Flash Player or web browser) where the contents of file retrieved via the url will be displayed.
-        */
-    public FSGetUrl(String urlString, String targetString)
-    {
-        super(FSActionObject.GetUrl);
-        setUrl(urlString);
-        setTarget(targetString);
-    }
-    /**  Constructs an FSGetUrl with the specified url. The target defaults to the current window. 
-
-        @param urlString a fully qualified URL.
-        */
-    public FSGetUrl(String urlString)
-    {
-        super(FSActionObject.GetUrl);
-        setUrl(urlString);
-    }
-    /**
-     * Constructs an FSGetUrl object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGetUrl object.
-     */
-    public FSGetUrl(FSGetUrl obj)
-    {
-        super(obj);
-        url = new String(obj.url);
-        target = new String(obj.target);
-    }    
-
-    /** Gets the URL. 
-
-        @return the URL that web page or movie clip will be loaded from.
-        */
-    public String getUrl() { return url; }
-
-    /** Gets the name of the target frame. 
-
-        @return the name of the location (in the Flash Player or web browser) where the web page or movie clip will be displayed.
-        */    
-    public String getTarget() { return target; }
-
-    /**  Sets the URL of the file to be retrieved.
-
-        @param aString a fully qualified URL.
-        */
-    public void setUrl(String aString)
-    {
-        url = aString;
-    } 
-
-    /** Sets the name of the Target where the URL will be displayed. The target may be a frame or window in a web browser when displaying a web page or a level in the current movie when loading a movie clip.
-
-        @param aString the name of the location (in the Flash Player or web browser) where contents of file retrieved via the url will be displayed.
-        */
-    public void setTarget(String aString)
-    {
-        target = aString;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSGetUrl typedObject = (FSGetUrl)anObject;
-            
-            result = url.equals(typedObject.url);
-            result = result &amp;&amp; target.equals(typedObject.target);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;url&quot;, url);
-            Transform.append(buffer, &quot;target&quot;, target);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += coder.strlen(url, true);
-        length += coder.strlen(target, true);
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeString(url);
-        coder.writeWord(0, 1);
-
-        coder.writeString(target);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        url = coder.readString();
-        target = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		url = coder.readString();
+		target = coder.readString();
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSGetUrl2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSGetUrl2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSGetUrl2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,240 +31,355 @@
 package com.flagstone.transform;
 
 /**
-The FSGetUrl2 action is used to either load a web page or movie clip or load or submit 
-variable values to/from a server.
-  
-&lt;p&gt;It extends the functionality provided by the FSGetUrl action by allowing the variables defined in a movie to be submitted as form values to a server. Variables defined in a movie can also be initialised by loading a file containing variable name / value assignments.&lt;/p&gt;
+ * The FSGetUrl2 action is used to either load a web page or movie clip or load
+ * or submit variable values to/from a server.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by the FSGetUrl action by allowing the
+ * variables defined in a movie to be submitted as form values to a server.
+ * Variables defined in a movie can also be initialised by loading a file
+ * containing variable name / value assignments.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;requestType&lt;/td&gt;
+ * &lt;td&gt;The type of request generated by the action.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSGetUrl2 is a stack-based action, however the type of request being
+ * submitted to the server is defined by the requestType attribute. Two
+ * arguments, &lt;i&gt;url&lt;/i&gt; and &lt;i&gt;target/level&lt;/i&gt; are popped from the stack.
+ * The &lt;i&gt;url&lt;/i&gt; is the first argument popped from the stack and is a fully
+ * qualified uniform resource location where the movie clip or web page will be
+ * retrieved from. The second argument is either a &lt;i&gt;target&lt;/i&gt; - the name of
+ * a specific movie clip, e.g. _root.movieClip or the name of a level in the
+ * main movie into which a movie clip has been loaded, e.g. _level1.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Request Types&lt;/b&gt;&lt;br/&gt; The &lt;i&gt;request type&lt;/i&gt; is specified as an
+ * attribute of the FSGetUrl2 action. Whether a new web page, movie clip or
+ * variable values are loaded is specified by the following types of request:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Type of Request&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToLevel&lt;/td&gt;
+ * &lt;td&gt;Load a movie to the specified level.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToLevelWithGet&lt;/td&gt;
+ * &lt;td&gt;Load a movie submitting the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToLevelWithPost&lt;/td&gt;
+ * &lt;td&gt;Load a movie submitting the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToTarget&lt;/td&gt;
+ * &lt;td&gt;Load a new Flash movie or web page to the specified target.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToTargetWithGet&lt;/td&gt;
+ * &lt;td&gt;Load a new Flash movie or web page to the specified target, submitting
+ * the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToTargetWithPost&lt;/td&gt;
+ * &lt;td&gt;Load a new Flash movie or web page to the specified target, submitting
+ * the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToLevel&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToLevelWithGet&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level,
+ * submitting the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToLevelWithPost&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level,
+ * submitting the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToTarget&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToTargetWithGet&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified target,
+ * submitting the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToTargetWithPost&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified target,
+ * submitting the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * When variables are submitted they are encoded using standard x-www-urlencoded
+ * encoding.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Targets&lt;/b&gt;&lt;br/&gt; The &lt;i&gt;target&lt;/i&gt; can either be the name of the frame
+ * can be one of the following reserved words:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt; opens the new page in the frame with the name
+ * defined in the HTML &lt;frame&gt; tag.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_blank&lt;/code&gt; opens the new page in a new window.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_self&lt;/code&gt; opens the new page in the current window.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_top&lt;/code&gt; opens the new page in the top level frame of the
+ * current window.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_parent&lt;/code&gt; opens the new page in the parent frame of the
+ * frame where the Flash Player id displayed.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt; (blank string) opens the new page in the current frame
+ * or window.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Levels&lt;/b&gt;&lt;br/&gt; Levels are virtual layers (analogous to the layers in
+ * the Display List). Higher levels are displayed in front of lower levels. The
+ * background of each level is transparent allowing movie clips on lower levels
+ * to be visible in areas not filled by the movie clip on a given level. The
+ * main movie is loaded into level 0. Movie clips are loaded into any level
+ * above this (1, 2, 124, etc.). If a movie clip is loaded into a level that
+ * already contains a movie clip then the existing clip is replaced by the new
+ * one. The level follows the general form: &quot;_level&lt;i&gt;n&lt;/i&gt;&quot; loads a movie
+ * clip into the current movie at level &lt;i&gt;n&lt;/i&gt;.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Display a movie in the named frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction frameActions = new FSDoAction();
+ * 
+ * // Push the target followed by the url
+ * 
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movie.swf&amp;quot;">http://www.server.com/movie.swf&quot;</A>));
+ * frameActions.add(new FSPush(&quot;aFrame&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToTarget));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Load a movie clip into the current movie at level 1:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movieClip.swf&amp;quot;">http://www.server.com/movieClip.swf&quot;</A>));
+ * frameActions.add(new FSPush(&quot;_level1&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToLevel));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Submit the value of a variable as an argument to a server script:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Set the variable
+ * 
+ * frameActions.add(new FSPush(&quot;MyVariable&quot;));
+ * frameActions.add(new FSPush(23));
+ * frameActions.add(FSAction.SetVariable());
+ * 
+ * // Submit it to the server script
+ * 
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php&amp;quot;">http://www.server.com/cgi-bin/form.php&quot;</A>));
+ * frameActions.add(new FSPush(&quot;&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToTargetWithPost));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Initialise the variables in a movie clip using name/value pairs returned from
+ * a server script:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * 
+ * // Specify the level where the movie clip is loaded.
+ * 
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php&amp;quot;">http://www.server.com/cgi-bin/form.php&quot;</A>));
+ * frameActions.add(new FSPush(&quot;_level1&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToLevelWithGet));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGetUrl2 is a class for representing the ActionGetUrl2 action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 4.
+ * &lt;/p&gt;
+ */
+public class FSGetUrl2 extends FSActionObject
+{
+	/** Load a movie without submitting the movie variables. */
+	public static final int MovieToLevel = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Load a movie submitting the movie variables using HTTP GET. */
+	public static final int MovieToLevelWithGet = 1;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Load a movie submitting the movie variables using HTTP POST. */
+	public static final int MovieToLevelWithPost = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load a movie or web page without submitting the movie variables. */
+	public static final int MovieToTarget = 64;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl2_1&quot;&gt;requestType&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The type of request generated by the action.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/** Load a movie or web page submitting the movie variables using HTTP GET. */
+	public static final int MovieToTargetWithGet = 65;
 
-&lt;p&gt;FSGetUrl2 is a stack-based action, however the type of request being submitted to the server is defined by the requestType attribute. Two arguments, &lt;i&gt;url&lt;/i&gt; and &lt;i&gt;target/level&lt;/i&gt; are popped from the stack. The &lt;i&gt;url&lt;/i&gt; is the first argument popped from the stack and is a fully qualified uniform resource location where the movie clip or web page will be retrieved from. The second argument is either a &lt;i&gt;target&lt;/i&gt; - the name of a specific movie clip, e.g. _root.movieClip or the name of a level in the main movie into which a movie clip has been loaded, e.g. _level1.&lt;/p&gt;
+	/** Load a movie or web page submitting the movie variables using HTTP POST. */
+	public static final int MovieToTargetWithPost = 66;
 
-&lt;p&gt;&lt;b&gt;Request Types&lt;/b&gt;&lt;br/&gt;
-The &lt;i&gt;request type&lt;/i&gt; is specified as an attribute of the FSGetUrl2 action. Whether a new web page, movie clip or variable values are loaded is specified by the following types of request:&lt;/p&gt;
+	/** Load variables without submitting the movie variables. */
+	public static final int VariablesToLevel = 128;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Type of Request&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
+	/** Load variables submitting the movie variables using HTTP GET. */
+	public static final int VariablesToLevelWithGet = 129;
 
-&lt;tr&gt;&lt;td&gt;MovieToLevel&lt;/td&gt;&lt;td&gt;Load a movie to the specified level.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToLevelWithGet&lt;/td&gt;&lt;td&gt;Load a movie submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToLevelWithPost&lt;/td&gt;&lt;td&gt;Load a movie submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
+	/** Load variables submitting the movie variables using HTTP POST. */
+	public static final int VariablesToLevelWithPost = 130;
 
-&lt;tr&gt;&lt;td&gt;MovieToTarget&lt;/td&gt;&lt;td&gt;Load a new Flash movie or web page to the specified target.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToTargetWithGet&lt;/td&gt;&lt;td&gt;Load a new Flash movie or web page to the specified target, submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToTargetWithPost&lt;/td&gt;&lt;td&gt;Load a new Flash movie or web page to the specified target, submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
+	/** Load variables without submitting the movie variables. */
+	public static final int VariablesToTarget = 192;
 
-&lt;tr&gt;&lt;td&gt;VariablesToLevel&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToLevelWithGet&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level, submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToLevelWithPost&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level, submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
+	/** Load variables submitting the movie variables using HTTP GET. */
+	public static final int VariablesToTargetWithGet = 193;
 
-&lt;tr&gt;&lt;td&gt;VariablesToTarget&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToTargetWithGet&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified target, submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToTargetWithPost&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified target, submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Load variables submitting the movie variables using HTTP POST. */
+	public static final int VariablesToTargetWithPost = 194;
 
-&lt;p&gt;When variables are submitted they are encoded using standard x-www-urlencoded encoding.&lt;/p&gt;
+	private int requestType = MovieToLevel;
 
-&lt;p&gt;&lt;b&gt;Targets&lt;/b&gt;&lt;br/&gt;
-The &lt;i&gt;target&lt;/i&gt; can either be the name of the frame can be one of the following reserved words:&lt;/p&gt;
+	/**
+	 * Construct an FSGetUrl2 object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGetUrl2(FSCoder coder)
+	{
+		super(GetUrl2);
+		decode(coder);
+	}
 
-&lt;ul&gt;
-&lt;li&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt; opens the new page in the frame with the name defined in the HTML &lt;frame&gt; tag.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_blank&lt;/code&gt; opens the new page in a new window.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_self&lt;/code&gt; opens the new page in the current window.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_top&lt;/code&gt; opens the new page in the top level frame of the current window.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_parent&lt;/code&gt; opens the new page in the parent frame of the frame where the Flash Player id displayed.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt; (blank string) opens the new page in the current frame or window.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Constructs an FSGetUrl2 using the specified request type.
+	 * 
+	 * @param aType
+	 *            the type of request to be performed. Must be one of the
+	 *            constants defined in this class.
+	 */
+	public FSGetUrl2(int aType)
+	{
+		super(GetUrl2);
+		setRequestType(aType);
+	}
 
-&lt;p&gt;&lt;b&gt;Levels&lt;/b&gt;&lt;br/&gt;
-Levels are virtual layers (analogous to the layers in the Display List). Higher levels are displayed in front of lower levels. The background of each level is transparent allowing movie clips on lower levels to be visible in areas not filled by the movie clip on a given level. The main movie is loaded into level 0. Movie clips are loaded into any level above this (1, 2, 124, etc.). If a movie clip is loaded into a level that already contains a movie clip then the existing clip is replaced by the new one. The level follows the general form: &quot;_level&lt;i&gt;n&lt;/i&gt;&quot; loads a movie clip into the current movie at level &lt;i&gt;n&lt;/i&gt;.&lt;/p&gt;
+	/**
+	 * Constructs an FSGetUrl2 object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGetUrl2 object.
+	 */
+	public FSGetUrl2(FSGetUrl2 obj)
+	{
+		super(obj);
+		requestType = obj.requestType;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the request type.
+	 * 
+	 * @return the type of request to be performed.
+	 */
+	public int getRequestType()
+	{
+		return requestType;
+	}
 
-&lt;p&gt;Display a movie in the named frame:&lt;/p&gt;
+	/**
+	 * Sets the request type.
+	 * 
+	 * @param aType
+	 *            the type of request to be performed. Must be one of the
+	 *            constants defined in this class.
+	 */
+	public void setRequestType(int aType)
+	{
+		requestType = aType;
+	}
 
-&lt;pre&gt;
-FSDoAction frameActions = new FSDoAction();
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-// Push the target followed by the url
+		if (super.equals(anObject))
+			result = requestType == ((FSGetUrl2) anObject).getRequestType();
 
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movie.swf">http://www.server.com/movie.swf</A>&quot;));
-frameActions.add(new FSPush(&quot;aFrame&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToTarget));
-&lt;/pre&gt;
+		return result;
+	}
 
-&lt;p&gt;Load a movie clip into the current movie at level 1:&lt;/p&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;pre&gt;
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movieClip.swf">http://www.server.com/movieClip.swf</A>&quot;));
-frameActions.add(new FSPush(&quot;_level1&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToLevel));
-&lt;/pre&gt;
+		buffer.append(&quot;FSGetUrl2: { &quot;);
+		buffer.append(&quot;requestType = &quot;).append(requestType).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-&lt;p&gt;Submit the value of a variable as an argument to a server script:&lt;/p&gt;
+		return buffer.toString();
+	}
 
-&lt;pre&gt;
-// Set the variable
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-frameActions.add(new FSPush(&quot;MyVariable&quot;));
-frameActions.add(new FSPush(23));
-frameActions.add(FSAction.SetVariable());
+		length += 1;
 
-// Submit it to the server script
+		return length;
+	}
 
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php">http://www.server.com/cgi-bin/form.php</A>&quot;));
-frameActions.add(new FSPush(&quot;&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToTargetWithPost));
-&lt;/pre&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(requestType, 1);
+	}
 
-&lt;p&gt;Initialise the variables in a movie clip using name/value pairs returned from a server script:&lt;/p&gt;
-
-&lt;pre&gt;
-
-// Specify the level where the movie clip is loaded.
-
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php">http://www.server.com/cgi-bin/form.php</A>&quot;));
-frameActions.add(new FSPush(&quot;_level1&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToLevelWithGet));
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSGetUrl2 is a class for representing the ActionGetUrl2 action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSGetUrl2 extends FSActionObject
-{
-    /** Load a movie without submitting the movie variables. */
-    public static final int MovieToLevel = 0;
-    /** Load a movie submitting the movie variables using HTTP GET. */
-    public static final int MovieToLevelWithGet  = 1;
-    /** Load a movie submitting the movie variables using HTTP POST. */
-    public static final int MovieToLevelWithPost = 2;
-    /** Load a movie or web page without submitting the movie variables. */
-    public static final int MovieToTarget = 64;
-    /** Load a movie or web page submitting the movie variables using HTTP GET. */
-    public static final int MovieToTargetWithGet  = 65;
-    /** Load a movie or web page submitting the movie variables using HTTP POST. */
-    public static final int MovieToTargetWithPost = 66;
-
-    /** Load variables without submitting the movie variables. */
-    public static final int VariablesToLevel = 128;
-    /** Load variables submitting the movie variables using HTTP GET. */
-    public static final int VariablesToLevelWithGet  = 129;
-    /** Load variables submitting the movie variables using HTTP POST. */
-    public static final int VariablesToLevelWithPost = 130;
-    /** Load variables without submitting the movie variables. */
-    public static final int VariablesToTarget = 192;
-    /** Load variables submitting the movie variables using HTTP GET. */
-    public static final int VariablesToTargetWithGet  = 193;
-    /** Load variables submitting the movie variables using HTTP POST. */
-    public static final int VariablesToTargetWithPost = 194;
-        
-    private int requestType = MovieToLevel;
-    
-    /**
-     * Construct an FSGetUrl2 object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGetUrl2(FSCoder coder)
-    {
-        super(GetUrl2);
-        decode(coder);
-    }
-    /** Constructs an FSGetUrl2 using the specified request type. 
-
-        @param aType the type of request to be performed. Must be one of the constants defined in this class.
-        */
-    public FSGetUrl2(int aType)
-    {
-        super(GetUrl2);
-        setRequestType(aType);
-    }
-    /**
-     * Constructs an FSGetUrl2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGetUrl2 object.
-     */
-    public FSGetUrl2(FSGetUrl2 obj)
-    {
-        super(obj);
-        requestType = obj.requestType;
-    }    
-
-    /** Gets the request type. 
-
-        @return the type of request to be performed.
-        */
-    public int getRequestType() { return requestType; }
-
-    /** Sets the request type. 
-
-        @param aType the type of request to be performed. Must be one of the constants defined in this class.
-        */
-    public void setRequestType(int aType)
-    {
-        requestType = aType;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = requestType == ((FSGetUrl2)anObject).getRequestType();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;requestType&quot;, requestType);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(requestType, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        requestType = coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		requestType = coder.readByte();
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,148 +31,178 @@
 package com.flagstone.transform;
 
 /**
-The FSGotoFrame action instructs the player to move to the specified frame in the current 
-movie's main time-line.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * The FSGotoFrame action instructs the player to move to the specified frame in
+ * the current movie's main time-line.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameNumber&lt;/td&gt;
+ * &lt;td&gt;The number of the frame in the movie's main time-line, in the range
+ * 1..65535, to move to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The movie will start playing immediately from the specified frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGotoFrame gotoFrame = new FSGotoFrame(12);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoFrame is only used to control the main time-line of a movie.
+ * Controlling how an individual movie clip is played is handled by a different
+ * mechanism. From Flash 5 onward movie clips are defined as objects. The
+ * ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop()
+ * methods that control a movie clip's time-line:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(&quot;frameName&quot;));
+ * frameAction.add(new FSPush(1));
+ * 
+ * // Get a reference to the object.
+ * 
+ * frameAction.add(new FSPush(&quot;_root&quot;));
+ * frameAction.add(new FSPush(&quot;movieClip&quot;));
+ * frameAction.add(new FSAction(FSAction.GetAttribute));
+ * 
+ * // Place the name of the method on the stack then execute it.
+ * 
+ * frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * frameAction.add(new FSAction(FSAction.ExecuteMethod));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGotoFrame represents the ActionGotoFrame action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3. This class is
+ * now superseded by the FSGotoFrame2 action which allows either the name of a
+ * frame or a number of be specified.
+ * &lt;/p&gt;
+ */
+public class FSGotoFrame extends FSActionObject
+{
+	private int frameNumber = 1;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSGotoFrame object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGotoFrame(FSCoder coder)
+	{
+		super(GotoFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGotoFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoFrame with the specified frame number. The frame
+	 * number must be in the range 1..65535.
+	 * 
+	 * @param aNumber
+	 *            the number of the frame.
+	 */
+	public FSGotoFrame(int aNumber)
+	{
+		super(GotoFrame);
+		setFrameNumber(aNumber);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGotoFrame_1&quot;&gt;frameNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the frame in the movie's main time-line, in the range 1..65535, to move to.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSGotoFrame(FSGotoFrame obj)
+	{
+		super(obj);
+		frameNumber = obj.frameNumber;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the number of the frame to move the main time-line to.
+	 * 
+	 * @return the frame number.
+	 */
+	public int getFrameNumber()
+	{
+		return frameNumber;
+	}
 
-&lt;p&gt;The movie will start playing immediately from the specified frame.&lt;/p&gt;
+	/**
+	 * Sets the number of the frame to move the main time-line to. The frame
+	 * number must be in the range 1..65535.
+	 * 
+	 * @param aNumber
+	 *            the frame number.
+	 */
+	public void setFrameNumber(int aNumber)
+	{
+		frameNumber = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSGotoFrame gotoFrame = new FSGotoFrame(12);
-&lt;/pre&gt;
+		if (super.equals(anObject))
+			result = frameNumber == ((FSGotoFrame) anObject).getFrameNumber();
 
-&lt;p&gt;FSGotoFrame is only used to control the main time-line of a movie. Controlling how an individual movie clip is played is handled by a different mechanism. From Flash 5 onward movie clips are defined as objects. The ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop() methods that control a movie clip's time-line:&lt;/p&gt;
+		return result;
+	}
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-frameAction.add(new FSPush(&quot;frameName&quot;));
-frameAction.add(new FSPush(1));
+		buffer.append(&quot;FSGotoFrame: {&quot;);
+		buffer.append(&quot;frameNumber = &quot;).append(frameNumber).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-// Get a reference to the object.
+		return buffer.toString();
+	}
 
-frameAction.add(new FSPush(&quot;_root&quot;));
-frameAction.add(new FSPush(&quot;movieClip&quot;));
-frameAction.add(new FSAction(FSAction.GetAttribute));
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-// Place the name of the method on the stack then execute it.
+		length += 2;
 
-frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
-frameAction.add(new FSAction(FSAction.ExecuteMethod));
-&lt;/pre&gt;
+		return length;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(frameNumber, 2);
+	}
 
-&lt;p&gt;The FSGotoFrame represents the ActionGotoFrame action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3. This class is now superseded by the FSGotoFrame2 action which allows either the name of a frame or a number of be specified.&lt;/p&gt; */
-public class FSGotoFrame extends FSActionObject
-{
-    private int frameNumber = 1;
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    /**
-     * Construct an FSGotoFrame object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGotoFrame(FSCoder coder)
-    {
-        super(GotoFrame);
-        decode(coder);
-    }
-    /** Constructs an FSGotoFrame with the specified frame number. The frame number must be in the range 1..65535.
-
-        @param aNumber the number of the frame.
-        */
-    public FSGotoFrame(int aNumber)
-    {
-        super(GotoFrame);
-        setFrameNumber(aNumber);
-    }
-    /**
-     * Constructs an FSGotoFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSGotoFrame(FSGotoFrame obj)
-    {
-        super(obj);
-        frameNumber = obj.frameNumber;
-    }    
-
-    /** Gets the number of the frame to move the main time-line to.
-
-        @return the frame number.
-        */
-    public int getFrameNumber() { return frameNumber; }
-
-    /** Sets the number of the frame to move the main time-line to. The frame number must be in the range 1..65535.
-
-        @param aNumber the frame number.
-        */
-    public void setFrameNumber(int aNumber)
-    {
-        frameNumber = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = frameNumber == ((FSGotoFrame)anObject).getFrameNumber();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;}&quot;);
-            Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(frameNumber, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        frameNumber = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+		frameNumber = coder.readWord(2, false);
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSGotoFrame2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,273 +31,320 @@
 package com.flagstone.transform;
 
 /**
-The FSGotoFrame2 action instructs the player to go to the named or numbered frame in the 
-current movie's main time-line. It extends the functionality provided by the FSGotoFrame action by allowing 
-the name of a frame, previously assigned using the FSFrameLabel object, to be specified.&lt;/p&gt;
+ * The FSGotoFrame2 action instructs the player to go to the named or numbered
+ * frame in the current movie's main time-line. It extends the functionality
+ * provided by the FSGotoFrame action by allowing the name of a frame,
+ * previously assigned using the FSFrameLabel object, to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;play&lt;/td&gt;
+ * &lt;td&gt;A boolean flag indicating whether the Flash Player should start playing
+ * the frame as soon as it is loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameOffset&lt;/td&gt;
+ * &lt;td&gt;An offset added to the frame number of the stack to generate the final
+ * frame number that the timeline should move to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Up to Flash Version 4, movies contained a single sequence of 65536 frames. In
+ * Flash 5 the concept of Scenes was added which allowed movies to contain
+ * 'pages' of frames. FSGotoFrame2 contains a frameOffset attribute which allows
+ * the frames in each scene to be referenced by its 'logical' number. The
+ * frameOffset for a given scene is added to the frame number to generate the
+ * 'physical' page number.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoFrame2 is a stack-based action. The name or number of the frame is
+ * pushed onto the stack before the FSGotoFrame2 action is executed. If a
+ * frameOffset is specified it is added to the number of the frame identified by
+ * the stack arguments to give the final frame number. Whether the movie starts
+ * playing the frame is controlled by the boolean attribute, &lt;i&gt;play&lt;/i&gt;. When
+ * set to true the movie starts playing the frame as soon as it has been loaded
+ * by the Flash Player.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Start playing a movie at the specified frame number:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(12));
+ * actions.add(new FSGotoFrame2(true));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Move to the named frame but do not start playing immediately:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSMovie movie = new FSMovie();
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+ * 
+ * actions.add(new FSPush(&quot;FirstFrame&quot;));
+ * actions.add(new FSGotoFrame2(false));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To use the concept of scenes in a movie, divide the physical frames into a
+ * sequence of logical pages:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * 
+ *  int sceneSize = 1024;
+ *  int scene = 5;
+ *  boolean play = true;
+ * 
+ *  // Goto the first frame in scene 5.
+ * 
+ *  frameAction.add(new FSPush(1));
+ *  frameAction.add(new FSGotoFrame2(scene*sceneSize, play);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoFrame2 is only used to control the main time-line of a movie.
+ * Controlling how an individual movie clip is played is handled by a different
+ * mechanism. From Flash 5 onward movie clips are defined as objects. The
+ * ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop()
+ * methods that control a movie clip's time-line:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(&quot;frameName&quot;));
+ * frameAction.add(new FSPush(1));
+ * 
+ * // Get a reference to the object.
+ * 
+ * frameAction.add(new FSPush(&quot;_root&quot;));
+ * frameAction.add(new FSPush(&quot;movieClip&quot;));
+ * frameAction.add(FSAction.GetAttribute());
+ * 
+ * // Place the name of the method on the stack then execute it.
+ * 
+ * frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * frameAction.add(FSAction.ExecuteMethod());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGotoFrame2 is a class for representing the ActionGotoFrame2 action of
+ * the Macromedia Flash (SWF) File Format Specification. It was introduced in
+ * Flash 4 and supersedes the FSGotoFrame action. In Flash 5 the frameOffset
+ * attribute was added which allows movies to be divided into a series of
+ * 'pages'.
+ * &lt;/p&gt;
+ */
+public class FSGotoFrame2 extends FSActionObject
+{
+	private boolean playFrame = false;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int frameOffset = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSGotoFrame2 object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGotoFrame2(FSCoder coder)
+	{
+		super(GotoFrame2);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoFrame2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoFrame2 object with the specified play flag setting.
+	 * 
+	 * @param aBool
+	 *            true if the player should being playing the movie at the
+	 *            specified frame. false if the player should stop playing the
+	 *            movie.
+	 */
+	public FSGotoFrame2(boolean aBool)
+	{
+		super(GotoFrame2);
+		setPlayFrame(aBool);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoFrame2_1&quot;&gt;play&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A boolean flag indicating whether the Flash Player should start playing the frame as soon as it 
-is loaded.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 5
+	/**
+	 * Constructs an FSGotoFrame2 object with the specified play flag setting
+	 * and frame offset for a given scene.
+	 * 
+	 * @param offset
+	 *            a number which will be added to the number of the frame popped
+	 *            from the stack to give the final frame number.
+	 * @param aBool
+	 *            true if the player should being playing the movie at the
+	 *            specified frame, false if the player should stop playing the
+	 *            movie.
+	 */
+	public FSGotoFrame2(int offset, boolean aBool)
+	{
+		super(GotoFrame2);
+		setPlayFrame(aBool);
+		setFrameOffset(offset);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoFrame2_2&quot;&gt;frameOffset&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An offset added to the frame number of the stack to generate the final frame number that the 
-timeline should move to.&lt;/td&gt;
-&lt;/tr&gt;
+	// End Flash 5
+	/**
+	 * Constructs an FSGotoFrame2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSGotoFrame2(FSGotoFrame2 obj)
+	{
+		super(obj);
+		playFrame = obj.playFrame;
+		frameOffset = obj.frameOffset;
+	}
 
-&lt;/table&gt;
+	// Flash 5
+	/**
+	 * Gets the offset that will be added to the 'logical' frame number obtained
+	 * from the stack to generate the 'physical' frame number.
+	 * 
+	 * @return an offset that will be added to the frame number obtained form
+	 *         the stack.
+	 */
+	public int getFrameOffset()
+	{
+		return frameOffset;
+	}
 
-&lt;p&gt;Up to Flash Version 4, movies contained a single sequence of 65536 frames. In Flash 5 the 
-concept of Scenes was added which allowed movies to contain 'pages' of frames. FSGotoFrame2 
-contains a frameOffset attribute which allows the frames in each scene to be referenced by 
-its 'logical' number. The frameOffset for a given scene is added to the frame number to 
-generate the 'physical' page number.&lt;/p&gt;
+	/**
+	 * Sets the offset that will be added to the 'logical' frame number obtained
+	 * from the stack to generate the 'physical' frame number.
+	 * 
+	 * @param offset
+	 *            a number that will be added to the frame number obtained form
+	 *            the stack.
+	 */
+	public void setFrameOffset(int offset)
+	{
+		frameOffset = offset;
+	}
 
-&lt;p&gt;FSGotoFrame2 is a stack-based action. The name or number of the frame is pushed onto the 
-stack before the FSGotoFrame2 action is executed. If a frameOffset is specified it is added 
-to the number of the frame identified by the stack arguments to give the final frame number. 
-Whether the movie starts playing the frame is controlled by the boolean attribute, &lt;i&gt;play&lt;/i&gt;. 
-When set to true the movie starts playing the frame as soon as it has been loaded by the Flash 
-Player.&lt;/p&gt;
+	// End Flash 5
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the play flag.
+	 * 
+	 * @return true if the player will being playing the movie at the specified
+	 *         frame, false otherwise.
+	 */
+	public boolean getPlayFrame()
+	{
+		return playFrame;
+	}
 
-&lt;p&gt;Start playing a movie at the specified frame number:&lt;/p&gt;
+	/**
+	 * Sets the play flag.
+	 * 
+	 * @param aBool
+	 *            true if the player should being playing the movie at the
+	 *            specified frame. false if the player should stop playing the
+	 *            movie.
+	 */
+	public void setPlayFrame(boolean aBool)
+	{
+		playFrame = aBool;
+	}
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-actions.add(new FSPush(12));
-actions.add(new FSGotoFrame2(true));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSGotoFrame2 typedObject = (FSGotoFrame2) anObject;
 
-&lt;p&gt;Move to the named frame but do not start playing immediately:&lt;/p&gt;
+			result = playFrame == typedObject.playFrame;
+			result = result &amp;&amp; frameOffset == typedObject.frameOffset;
+		}
+		return result;
+	}
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
-FSDoAction actions = new FSDoAction();
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+		buffer.append(&quot;FSGotoframe2: {&quot;);
+		buffer.append(&quot;playFrame = &quot;).append(playFrame).append(&quot;; &quot;);
+		// Flash 5
+		buffer.append(&quot;frameOffset = &quot;).append(frameOffset).append(&quot;; &quot;);
+		// End Flash 5
+		buffer.append(&quot;}&quot;);
 
-actions.add(new FSPush(&quot;FirstFrame&quot;));
-actions.add(new FSGotoFrame2(false));
-&lt;/pre&gt;
+		return buffer.toString();
+	}
 
-&lt;p&gt;To use the concept of scenes in a movie, divide the physical frames into a sequence of logical pages:&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;pre&gt;
+		length += 1 + ((frameOffset &gt; 0) ? 2 : 0);
 
-int sceneSize = 1024;
-int scene = 5;
-boolean play = true;
+		return length;
+	}
 
-// Goto the first frame in scene 5.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-frameAction.add(new FSPush(1));
-frameAction.add(new FSGotoFrame2(scene*sceneSize, play);
+		coder.writeBits(0, 6);
+		coder.writeBits(frameOffset != 0 ? 1 : 0, 1);
+		coder.writeBits(playFrame ? 1 : 0, 1);
 
-&lt;/pre&gt;
+		// Flash 5
+		if (frameOffset &gt; 0)
+			coder.writeWord(frameOffset, 2);
+		// End Flash 5
+	}
 
-&lt;p&gt;FSGotoFrame2 is only used to control the main time-line of a movie. Controlling how an individual 
-movie clip is played is handled by a different mechanism. From Flash 5 onward movie clips are defined 
-as objects. The ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop() methods 
-that control a movie clip's time-line:&lt;/p&gt;
+	public void decode(FSCoder coder)
+	{
+		boolean containsOffset = false;
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+		super.decode(coder);
+		coder.readBits(6, false);
+		containsOffset = coder.readBits(1, false) != 0 ? true : false;
+		playFrame = coder.readBits(1, false) != 0 ? true : false;
 
-frameAction.add(new FSPush(&quot;frameName&quot;));
-frameAction.add(new FSPush(1));
-
-// Get a reference to the object.
-
-frameAction.add(new FSPush(&quot;_root&quot;));
-frameAction.add(new FSPush(&quot;movieClip&quot;));
-frameAction.add(FSAction.GetAttribute());
-
-// Place the name of the method on the stack then execute it.
-
-frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
-frameAction.add(FSAction.ExecuteMethod());
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSGotoFrame2 is a class for representing the ActionGotoFrame2 action of the Macromedia 
-Flash (SWF) File Format Specification. It  was introduced in Flash 4 and supersedes the FSGotoFrame 
-action. In Flash 5 the frameOffset attribute was added which allows movies to be divided into a 
-series of 'pages'.&lt;/p&gt;
- */  
-public class FSGotoFrame2 extends FSActionObject
-{
-    private boolean playFrame = false;
-    private int frameOffset = 0;
-    
-    /**
-     * Construct an FSGotoFrame2 object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGotoFrame2(FSCoder coder)
-    {
-        super(GotoFrame2);
-        decode(coder);
-    }
-    /** Constructs an FSGotoFrame2 object with the specified play flag setting. 
-
-        @param aBool true if the player should being playing the movie at the specified frame. 
-        false if the player should stop playing the movie.
-        */
-    public FSGotoFrame2(boolean aBool)
-    {
-        super(GotoFrame2);
-        setPlayFrame(aBool);
-    }
-// Flash 5
-    /** Constructs an FSGotoFrame2 object with the specified play flag setting 
-     *  and frame offset for a given scene. 
-     *  
-     *  @param offset a number which will be added to the number of the frame popped from the 
-     *  stack to give the final frame number.
-     *  @param aBool true if the player should being playing the movie at the specified frame, 
-     *  false if the player should stop playing the movie.
-     */
-    public FSGotoFrame2(int offset, boolean aBool)
-    {
-        super(GotoFrame2);
-        setPlayFrame(aBool);
-        setFrameOffset(offset);
-    }
-//  End Flash 5
-    /**
-     * Constructs an FSGotoFrame2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSGotoFrame2(FSGotoFrame2 obj)
-    {
-        super(obj);
-        playFrame = obj.playFrame;
-        frameOffset = obj.frameOffset;
-    }    
-//  Flash 5
-    /** Gets the offset that will be added to the 'logical' frame number obtained 
-     *  from the stack to generate the 'physical' frame number.
-     * 
-     *  @return an offset that will be added to the frame number obtained form the stack.
-     */
-    public int getFrameOffset() 
-    { 
-        return frameOffset; 
-    }
-
-    /** Sets the offset that will be added to the 'logical' frame number obtained 
-     *  from the stack to generate the 'physical' frame number.
-     * 
-     *  @param offset a number that will be added to the frame number obtained form the stack.
-     */
-    public void setFrameOffset(int offset)
-    {
-        frameOffset = offset;
-    } 
-// End Flash 5
-
-    /** Gets the play flag. 
-
-        @return true if the player will being playing the movie at the specified frame, false otherwise.
-        */
-    public boolean getPlayFrame() { return playFrame; }
-
-    /** Sets the play flag. 
-
-        @param aBool true if the player should being playing the movie at the specified frame. false if the player should stop playing the movie.
-        */
-    public void setPlayFrame(boolean aBool)
-    {
-        playFrame = aBool;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSGotoFrame2 typedObject = (FSGotoFrame2)anObject;
-            
-            result = playFrame == typedObject.playFrame;
-            result = result &amp;&amp; frameOffset == typedObject.frameOffset;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;}&quot;);
-            Transform.append(buffer, &quot;playFrame&quot;, playFrame);
-// Flash 5
-            Transform.append(buffer, &quot;frameOffset&quot;, frameOffset);
-// End Flash 5
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1 + ((frameOffset &gt; 0) ? 2 : 0);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeBits(0, 6);
-        coder.writeBits(frameOffset != 0 ? 1 : 0, 1);
-        coder.writeBits(playFrame ? 1 : 0, 1);
-        
-// Flash 5
-        if (frameOffset &gt; 0)
-            coder.writeWord(frameOffset, 2);
-// End Flash 5
-        
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsOffset = false; 
-        
-        super.decode(coder);
-        coder.readBits(6, false);
-        containsOffset = coder.readBits(1, false) != 0 ? true : false;
-        playFrame = coder.readBits(1, false) != 0 ? true : false;
-
-// Flash 5
-        if (containsOffset)
-            frameOffset = coder.readWord(2, false);
-// End Flash 5
-
-        coder.endObject(name());
-    }
+		// Flash 5
+		if (containsOffset)
+			frameOffset = coder.readWord(2, false);
+		// End Flash 5
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSGotoLabel.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSGotoLabel.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSGotoLabel.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,155 +31,177 @@
 package com.flagstone.transform;
 
 /**
-The FSGotoLabel action instructs the player to move to the frame in the current movie 
-with the specified label.
+ * The FSGotoLabel action instructs the player to move to the frame in the
+ * current movie with the specified label.
+ * 
+ * &lt;p&gt;
+ * The label is assigned to the frame using the FSFrameLabel object.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;label&lt;/td&gt;
+ * &lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSMovie movie = new FSMovie();
+ * 
+ *  // Assign the name to the &quot;current&quot; frame
+ * 
+ *  movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+ *  movie.add(new FSShowFrame());
+ *  ...
+ * 
+ *  // Move the timeline back to the named frame when the actions
+ *  // associated with this frame is executed.
+ * 
+ *  FSDoAction actions = new FSDoAction();
+ * 
+ *  actions.add(new FSGotoLabel(&quot;FirstFrame&quot;));
+ * 
+ *  movie.add(actions);
+ *  movie.add(new FSShowFrame());
+ * 
+ * &lt;/pre&gt;
+ * 
+ * 
+ * &lt;p&gt;
+ * The scope of a frame is delineated by successive FSShowFrame objects. To
+ * assign a label to a frame the FSFrameLabel object can be added at any point
+ * prior to the FSShowFrame object that marks the end of the frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoLabel represents the ActionGotoLabel action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSGotoLabel extends FSActionObject
+{
+	private String label = null;
 
-&lt;p&gt;The label is assigned to the frame using the FSFrameLabel object.&lt;/p&gt;
+	FSGotoLabel()
+	{
+		super(GotoLabel);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSGotoLabel object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGotoLabel(FSCoder coder)
+	{
+		super(GotoLabel);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoLabel action with the specified frame label.
+	 * 
+	 * @param aString
+	 *            the label assigned a particular frame in the movie.
+	 */
+	public FSGotoLabel(String aString)
+	{
+		super(GotoLabel);
+		setLabel(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoLabel_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoLabel object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGotoLabel object.
+	 */
+	public FSGotoLabel(FSGotoLabel obj)
+	{
+		super(obj);
+		label = new String(obj.label);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoLabel_1&quot;&gt;label&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the frame label.
+	 * 
+	 * @return the label assigned to the frame.
+	 */
+	public String getLabel()
+	{
+		return label;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the frame label.
+	 * 
+	 * @param aString
+	 *            the label assigned a particular frame in the movie.
+	 */
+	public void setLabel(String aString)
+	{
+		label = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
+		if (super.equals(anObject))
+			result = label.equals(((FSGotoLabel) anObject).getLabel());
 
-// Assign the name to the &quot;current&quot; frame
+		return result;
+	}
 
-movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
-movie.add(new FSShowFrame());
-...
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-// Move the timeline back to the named frame when the actions
-// associated with this frame is executed.
+		buffer.append(&quot;FSGotoLabel: {&quot;);
+		buffer.append(&quot;label = &quot;).append(label).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-FSDoAction actions = new FSDoAction();
+		return buffer.toString();
+	}
 
-actions.add(new FSGotoLabel(&quot;FirstFrame&quot;));
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-movie.add(actions);
-movie.add(new FSShowFrame());
+		length += coder.strlen(label, true);
 
-&lt;/pre&gt;
+		return length;
+	}
 
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-&lt;p&gt;The scope of a frame is delineated by successive FSShowFrame objects. To assign a label to a frame the FSFrameLabel object can be added at any point prior to the FSShowFrame object that marks the end of the frame.&lt;/p&gt;
+		coder.writeString(label);
+		coder.writeWord(0, 1);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;FSGotoLabel represents the ActionGotoLabel action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt; */  
-public class FSGotoLabel extends FSActionObject
-{
-    private String label = null;
-    
-    FSGotoLabel()
-    {
-        super(GotoLabel);
-    }
-    /**
-     * Construct an FSGotoLabel object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGotoLabel(FSCoder coder)
-    {
-        super(GotoLabel);
-        decode(coder);
-    }
-    /** Constructs an FSGotoLabel action with the specified frame label. 
-
-        @param aString the label assigned a particular frame in the movie.
-        */
-    public FSGotoLabel(String aString)
-    {
-        super(GotoLabel);
-        setLabel(aString);
-    }
-    /**
-     * Constructs an FSGotoLabel object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoLabel object.
-     */
-    public FSGotoLabel(FSGotoLabel obj)
-    {
-        super(obj);
-        label = new String(obj.label);
-    }    
-
-    /** Gets the frame label.
-
-        @return the label assigned to the frame.
-        */
-    public String getLabel() { return label; }
-
-    /** Sets the frame label. 
-
-        @param aString the label assigned a particular frame in the movie.
-        */
-    public void setLabel(String aString)
-    {
-        label = aString;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = label.equals(((FSGotoLabel)anObject).getLabel());
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;}&quot;);
-            Transform.append(buffer, &quot;label&quot;, label);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += coder.strlen(label, true);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-         coder.writeString(label);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        label = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		label = coder.readString();
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSImageBlock.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSImageBlock.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSImageBlock.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -4,17 +4,17 @@
 import java.util.zip.Inflater;
 
 /**
- * When an image is sent in a ScreenVideo stream only pixel information for the 
- * portions of the image that change are sent. FSImageBlock is used to sub-divide
- * an image into a set of blocks. The blocks from successive frames can then 
- * be compared to determine which blocks are encoded in the stream.
+ * When an image is sent in a ScreenVideo stream only pixel information for the
+ * portions of the image that change are sent. FSImageBlock is used to
+ * sub-divide an image into a set of blocks. The blocks from successive frames
+ * can then be compared to determine which blocks are encoded in the stream.
  * 
  * An image is divided by tiling the blocks across the image from top-left to
  * bottom right. If the image is not covered an integer number of blocks then
- * the size of the blocks along the right and bottom edges of the image are 
+ * the size of the blocks along the right and bottom edges of the image are
  * reduced in size.
  * 
- * The FSImageBlock is a contains class for the image data and is used in 
+ * The FSImageBlock is a contains class for the image data and is used in
  * conjunction with the FsStreamVideoPacket class.
  */
 public class FSImageBlock implements Cloneable
@@ -27,120 +27,124 @@
 	 * Create a new image block with the specified width and height and image
 	 * data. The image is compressed using the zip format.
 	 * 
-	 * @param width the width of the block in pixels.
-	 * @param height the height of the block in pixels
-	 * @param data the pixels covered by the block, compressed using the zip 
-	 * format.
+	 * @param width
+	 *            the width of the block in pixels.
+	 * @param height
+	 *            the height of the block in pixels
+	 * @param data
+	 *            the pixels covered by the block, compressed using the zip
+	 *            format.
 	 */
-    public FSImageBlock(int width, int height, byte[] data)
+	public FSImageBlock(int width, int height, byte[] data)
 	{
-    	this.width = width;
-    	this.height = height;
-    	block = data;
+		this.width = width;
+		this.height = height;
+		block = data;
 	}
-	
-    /**
-     * Return the width of the block. although the block size is specified in 
-     * parent FSScreenVideoPacket object the actual block size used may vary
-     * if the tiled array of blocks overlaps the edge of the image.
-     * 
-     * @return the width of the block in pixels.
-     */
-    public int getWidth() 
-    {
-        return width;
-    }
 
-    /**
-     * Return the height of the block. although the block size is specified in 
-     * parent FSScreenVideoPacket object the actual block size used may vary
-     * if the tiled array of blocks overlaps the edge of the image.
-     * 
-     * @return the height of the block in pixels.
-     */
-    public int getHeight() 
-    {
-        return height;
-    }
+	/**
+	 * Return the width of the block. although the block size is specified in
+	 * parent FSScreenVideoPacket object the actual block size used may vary if
+	 * the tiled array of blocks overlaps the edge of the image.
+	 * 
+	 * @return the width of the block in pixels.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-    /**
-     * Returns the zipped image data for the block.
-     * 
-     * @return an array of bytes containing the portion of the image in the 
-     * block.
-     */
-    public byte[] getData() 
-    {
-        return block;
-    }
-    
-    /**
-     * When a ScreenVideo stream is created only the image blocks that change
-     * are included. The blocks that do not change are encoded as empty blocks
-     * which have width and height of zero and do not contain any image data.
-     * This convenience method is used to determine when an image block contains
-     * any valid image data.
-     * 
-     * @return true if the block covers an area of the image that changed or 
-     * false if no image data is included.
-     */
-    public boolean isEmpty()
-    {
-    	return width == 0 || height == 0 || block == null || block.length == 0;
-    }
+	/**
+	 * Return the height of the block. although the block size is specified in
+	 * parent FSScreenVideoPacket object the actual block size used may vary if
+	 * the tiled array of blocks overlaps the edge of the image.
+	 * 
+	 * @return the height of the block in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-    public Object clone()
-    {
-    	return new FSImageBlock(width, height, block);
-    }
-    
-    public boolean equals(Object anObject)
-    {
-        if (anObject == null) {
-        	return false;
-        }
-        
-        if (this == anObject) {
-        	return true;
-        }
-        
-        boolean result = false;
-        
-        if (anObject instanceof FSImageBlock)
-        {
-            FSImageBlock typedObject = (FSImageBlock)anObject;
-            
-            try
-            {
-                result = width == typedObject.width;
-                result = result &amp;&amp; height == typedObject.height;
-                
-            	byte[] a = unzip(block);
-            	byte[] b = unzip(typedObject.block);
-            	
-                result = result &amp;&amp; Transform.equals(a, b);
-            }
-            catch (DataFormatException e)
-            {
-            	result = false;
-            }
-        }
-        return result;
-    }
+	/**
+	 * Returns the zipped image data for the block.
+	 * 
+	 * @return an array of bytes containing the portion of the image in the
+	 *         block.
+	 */
+	public byte[] getData()
+	{
+		return block;
+	}
 
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*3];
-        int count = 0;
-        
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
-        
-        byte[] uncompressedData = new byte[count];
-        
-        System.arraycopy(data, 0, uncompressedData, 0, count);
+	/**
+	 * When a ScreenVideo stream is created only the image blocks that change
+	 * are included. The blocks that do not change are encoded as empty blocks
+	 * which have width and height of zero and do not contain any image data.
+	 * This convenience method is used to determine when an image block contains
+	 * any valid image data.
+	 * 
+	 * @return true if the block covers an area of the image that changed or
+	 *         false if no image data is included.
+	 */
+	public boolean isEmpty()
+	{
+		return width == 0 || height == 0 || block == null || block.length == 0;
+	}
 
-        return uncompressedData;
-    }
+	public Object clone()
+	{
+		return new FSImageBlock(width, height, block);
+	}
+
+	public boolean equals(Object anObject)
+	{
+		if (anObject == null)
+		{
+			return false;
+		}
+
+		if (this == anObject)
+		{
+			return true;
+		}
+
+		boolean result = false;
+
+		if (anObject instanceof FSImageBlock)
+		{
+			FSImageBlock typedObject = (FSImageBlock) anObject;
+
+			try
+			{
+				result = width == typedObject.width;
+				result = result &amp;&amp; height == typedObject.height;
+
+				byte[] a = unzip(block);
+				byte[] b = unzip(typedObject.block);
+
+				result = result &amp;&amp; Transform.equals(a, b);
+			} catch (DataFormatException e)
+			{
+				result = false;
+			}
+		}
+		return result;
+	}
+
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		byte[] data = new byte[width * height * 3];
+		int count = 0;
+
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes);
+		count = inflater.inflate(data);
+
+		byte[] uncompressedData = new byte[count];
+
+		System.arraycopy(data, 0, uncompressedData, 0, count);
+
+		return uncompressedData;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSImport.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSImport.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSImport.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,238 +33,288 @@
 import java.util.*;
 
 /**
-FSImport is used to import shapes and other objects from another Flash file. 
+ * FSImport is used to import shapes and other objects from another Flash file.
+ * 
+ * &lt;p&gt;
+ * Since the identifier for an object is only unique within a given Flash file,
+ * imported objects are referenced by a name assigned when the object is
+ * exported.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Attribute&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;url&lt;/td&gt;
+ * &lt;td&gt;The URL of the file containing the object to be imported. The URL must
+ * be in the same sub-domain and relative to the URL of the Flash file
+ * containing the file importing the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;A HashTable containing key-value pairs where the key is the identifier
+ * of the object being imported and the value is name assigned to the object
+ * when it was exported into a Flash file.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To provide a degree of security the Flash Player will only import files that
+ * originate from the same domain as the file that it is currently playing. For
+ * example if the Flash file being shown was loaded from
+ * www.mydomain.com/flash.swf then the file contains the exported objects must
+ * reside somewhere at www.mydomain.com. This prevents a malicious Flash file
+ * from loading files from an unknown third party.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * To export an object from a Flash file:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSDefineShape(...);
+ * 
+ *  movie.add(shape);
+ *  movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The object can then be imported:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSImport class represents the ImportAssets data structure in the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5.
+ * &lt;/p&gt;
+ */
+public class FSImport extends FSMovieObject
+{
+	private String url = null;
 
-&lt;p&gt;Since the identifier for an object is only unique within a given Flash file, imported objects are referenced by a name assigned when the object is exported.&lt;/p&gt;
+	private Hashtable objects = new Hashtable();
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	FSImport()
+	{
+		super(Import);
+	}
 
-&lt;tr&gt;
-&lt;th align=&quot;left&quot;&gt;Attribute&lt;/th&gt;
-&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSImport object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSImport(FSCoder coder)
+	{
+		super(Import);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSImport_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSImport object that imports an object from the specified
+	 * file. The exported object is referenced by a name assigned to it when it
+	 * was exported. The newly imported object must be assigned an identifier
+	 * that is unique within the movie the object is imported into. Limited
+	 * security is provided by requiring that the URL must be in the same domain
+	 * or sub-domain as the URL of the movie which contains this object.
+	 * 
+	 * @param aUrl
+	 *            the URL referencing the file to be imported.
+	 * @param anIdentifier
+	 *            the identifier of the object to be exported.
+	 * @param aString
+	 *            the name of the exported object to allow it to be referenced.
+	 */
+	public FSImport(String aUrl, int anIdentifier, String aString)
+	{
+		super(Import);
+		setUrl(aUrl);
+		add(anIdentifier, aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSImport_1&quot;&gt;url&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The URL of the file containing the object to be imported. The URL must be in the same sub-domain and relative to the URL of the Flash file containing the file importing the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSImport object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSImport object.
+	 */
+	public FSImport(FSImport obj)
+	{
+		super(obj);
+		url = new String(obj.url);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSImport_2&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A HashTable containing key-value pairs where the key is the identifier of the object being imported and the value is name assigned to the object when it was exported into a Flash file.&lt;/td&gt;
-&lt;/tr&gt;
+		objects = new Hashtable(obj.objects.size());
 
-&lt;/table&gt;
+		for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
+		{
+			Object key = i.next();
+			objects.put(key, new String((String) objects.get(key)));
+		}
+	}
 
-&lt;p&gt;To provide a degree of security the Flash Player will only import files that originate from the same domain as the file that it is currently playing. For example if the Flash file being shown was loaded from www.mydomain.com/flash.swf then the file contains the exported objects must reside somewhere at www.mydomain.com. This prevents a malicious Flash file from loading files from an unknown third party.&lt;/p&gt;
+	/**
+	 * Adds the identifier and name to the list of objects to be imported.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be imported.
+	 * @param aString
+	 *            the name of the imported object to allow it to be referenced.
+	 */
+	public void add(int anIdentifier, String aString)
+	{
+		objects.put(new Integer(anIdentifier), aString);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the URL of the file containing the object to be imported. Limited
+	 * security is provided by requiring that the URL must be in the same domain
+	 * or sub-domain as the URL of the movie which contains this object.
+	 * 
+	 * @return the URL of the file containing the object to be imported.
+	 */
+	public String getUrl()
+	{
+		return url;
+	}
 
-&lt;p&gt;To export an object from a Flash file:&lt;/p&gt;
+	/**
+	 * Gets the table of objects to be imported.
+	 * 
+	 * @return the table of imported objects.
+	 */
+	public Hashtable getObjects()
+	{
+		return objects;
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(...);
+	/**
+	 * Sets the URL of the file containing the imported objects. The URL must be
+	 * in the same sub-domain and relative to the URL of the file containing the
+	 * FSImport object.
+	 * 
+	 * @param aString
+	 *            a URL relative to the URL of the file containing the FSImport
+	 *            object.
+	 */
+	public void setUrl(String aString)
+	{
+		url = aString;
+	}
 
-movie.add(shape);
-movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+	/**
+	 * Sets the table of objects to be imported.
+	 * 
+	 * @param aTable
+	 *            the table of objects being imported.
+	 */
+	public void setObjects(Hashtable aTable)
+	{
+		objects = aTable;
+	}
 
-&lt;p&gt;The object can then be imported:&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			if (url != null)
+				result = url.equals(((FSImport) anObject).getUrl());
+			else
+				result = ((FSImport) anObject).getUrl() == null;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			result = result
+							&amp;&amp; objects.equals(((FSImport) anObject)
+											.getObjects());
+		}
+		return result;
+	}
 
-&lt;p&gt;The FSImport class represents the ImportAssets data structure in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSImport extends FSMovieObject
-{
-    private String url = null;
-    private Hashtable objects = new Hashtable();
-        
-    FSImport()
-    {
-        super(Import);
-    }
-    /**
-     * Construct an FSImport object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSImport(FSCoder coder)
-    {
-        super(Import);
-        decode(coder);
-    }
-    /** Constructs an FSImport object that imports an object from the specified file. The exported object is referenced by a name assigned to it when it was exported. The newly imported object must be assigned an identifier that is unique within the movie the object is imported into. Limited security is provided by requiring that the URL must be in the same domain or sub-domain as the URL of the movie which contains this object.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param aUrl the URL referencing the file to be imported.
-        @param anIdentifier the identifier of the object to be exported.
-        @param aString the name of the exported object to allow it to be referenced.
-        */
-    public FSImport(String aUrl, int anIdentifier, String aString)
-    {
-        super(Import);
-        setUrl(aUrl);
-        add(anIdentifier, aString);
-    }
-    /**
-     * Constructs an FSImport object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSImport object.
-     */
-    public FSImport(FSImport obj)
-    {
-        super(obj);
-        url = new String(obj.url);
-        
-        objects = new Hashtable(obj.objects.size());
-        
-        for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
-        {
-            Object key = i.next();
-            objects.put(key, new String((String)objects.get(key)));
-        }
-    }    
+		buffer.append(&quot;FSImport: { &quot;);
+		buffer.append(&quot;url = &quot;).append(url).append(&quot;; &quot;);
+		buffer.append(&quot;objects = &quot;).append(objects.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Adds the identifier and name to the list of objects to be imported.
+		return buffer.toString();
+	}
 
-        @param anIdentifier the identifier of the object to be imported.
-        @param aString the name of the imported object to allow it to be referenced.
-        */
-    public void add(int anIdentifier, String aString)
-    {
-        objects.put(new Integer(anIdentifier), aString);
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the URL of the file containing the object to be imported. Limited security is provided by requiring that the URL must be in the same domain or sub-domain as the URL of the movie which contains this object.
+		length += coder.strlen(url, true);
+		length += 2;
 
-        @return the URL of the file containing the object to be imported.
-        */
-    public String getUrl() 
-    {
-        return url;
-    }
+		for (Enumeration e = objects.keys(); e.hasMoreElements();)
+		{
+			String name = (String) (objects.get(e.nextElement()));
 
-    /** Gets the table of objects to be imported. 
+			length += 2;
+			length += coder.strlen(name, true);
+		}
 
-        @return the table of imported objects.
-        */
-    public Hashtable getObjects() 
-    {
-        return objects;
-    }
+		return length;
+	}
 
-    /**  Sets the URL of the file containing the imported objects. The URL must be in the same sub-domain and relative to the URL of the file containing the FSImport object.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param aString a URL relative to the URL of the file containing the FSImport object.
-        */
-    public void setUrl(String aString)
-    {
-        url = aString;
-    }
+		coder.writeString(url);
+		coder.writeWord(0, 1);
 
-    /** Sets the table of objects to be imported.
+		coder.writeWord(objects.size(), 2);
 
-        @param aTable the table of objects being imported.
-        */
-    public void setObjects(Hashtable aTable)
-    {
-        objects = aTable;
-    }
+		for (Enumeration e = objects.keys(); e.hasMoreElements();)
+		{
+			Integer identifier = (Integer) (e.nextElement());
+			String name = (String) (objects.get(identifier));
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            if (url != null)
-                result = url.equals(((FSImport)anObject).getUrl());
-            else
-                result = ((FSImport)anObject).getUrl() == null;
-                
-            result = result &amp;&amp; objects.equals(((FSImport)anObject).getObjects());
-        }
-        return result;
-    }
+			coder.writeWord(identifier.intValue(), 2);
+			coder.writeString(name);
+			coder.writeWord(0, 1);
+		}
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;url&quot;, url);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		url = coder.readString();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		int count = coder.readWord(2, false);
 
-        length += coder.strlen(url, true);
-        length += 2;
+		for (int i = 0; i &lt; count; i++)
+		{
+			int identifier = coder.readWord(2, false);
+			String name = coder.readString();
 
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            String name = (String)(objects.get(e.nextElement()));
-            
-            length += 2;
-            length += coder.strlen(name, true);
-        }
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-           
-        coder.writeString(url);
-        coder.writeWord(0, 1);
-
-        coder.writeWord(objects.size(), 2);
-
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            Integer identifier = (Integer)(e.nextElement());
-            String name = (String) (objects.get(identifier));
-
-            coder.writeWord(identifier.intValue(), 2);
-            coder.writeString(name);
-            coder.writeWord(0, 1);
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        url = coder.readString();
-        
-        int count = coder.readWord(2, false);
-
-        for (int i=0; i&lt;count; i++)
-        {
-            int identifier = coder.readWord(2, false);
-            String name = coder.readString();
-
-            add(identifier, name);
-        }
-        coder.endObject(name());
-    }
+			add(identifier, name);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSInitialize.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSInitialize.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSInitialize.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,368 +33,407 @@
 import java.util.*;
 
 /**
-FSInitialize is used to specify a sequence of actions that are executed to initialise 
- a movie clip before it is displayed.
- 
-&lt;p&gt;It implements the #initclip pragma in the ActionScript language.&lt;/p&gt;
+ * FSInitialize is used to specify a sequence of actions that are executed to
+ * initialise a movie clip before it is displayed.
+ * 
+ * &lt;p&gt;
+ * It implements the #initclip pragma in the ActionScript language.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the FSDefineMovieClip object that defines the movie
+ * clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of actions that will be executed to initialize the movie clips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Unlike the FSDoAction class which specifies the actions that are executed
+ * when a particular frame is displayed the actions contained in an FSInitialize
+ * object are executed only once, regardless of where the object is included in
+ * a movie. If a frame containing the FSInitialize object is played again the
+ * actions are skipped. Also there can only be one FSInitialize object for each
+ * movie clip defined in the movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;_root&quot;));
+ *  actions.add(FSAction.GetVariable());
+ * 
+ *  int clipId = movie.newIdentifier();
+ * 
+ *  movie.add(new FSDefineMovieClip(clipId, clipObjects));
+ *  ...
+ * 
+ *  movie.add(new FSInitialize(clipId, actions));
+ *  ...
+ *  movie.add(new FSShowFrame()); 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSInitialize class represents the DoInitAction tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 6.
+ * &lt;/p&gt;
+ * 
+ * @see FSDoAction
+ */
+public class FSInitialize extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private ArrayList actions = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private byte[] encodedActions = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSInitialize_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSInitialize object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSInitialize(FSCoder coder)
+	{
+		super(Initialize);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSInitialize_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the FSDefineMovieClip object that defines the movie clip.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSInitialize object that will initialize the movie clip
+	 * with the specified identifier with the actions in the array.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the movie clip to initialize
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public FSInitialize(int anIdentifier, ArrayList anArray)
+	{
+		super(Initialize);
+		setIdentifier(anIdentifier);
+		setActions(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSInitialize_2&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of actions that will be executed to initialize the movie clips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSInitialize object that will initialize the movie clip
+	 * with the specified identifier with the encoded actions.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the movie clip to initialize
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSInitialize(int anIdentifier, byte[] bytes)
+	{
+		super(Initialize);
+		setIdentifier(anIdentifier);
+		setEncodedActions(bytes);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSInitialize object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSInitialize object.
+	 */
+	public FSInitialize(FSInitialize obj)
+	{
+		super(obj);
 
-&lt;p&gt;Unlike the FSDoAction class which specifies the actions that are executed when a particular frame is displayed the actions contained in an FSInitialize object are executed only once, regardless of where the object is included in a movie. If a frame containing the FSInitialize object is played again the actions are skipped. Also there can only be one FSInitialize object for each movie clip defined in the movie.&lt;/p&gt;
+		identifier = obj.identifier;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-&lt;pre&gt;
-ArrayList actions = new ArrayList();
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(FSAction.GetVariable());
+	/**
+	 * Returns the identifier of the movie clip that will be initialized.
+	 * 
+	 * @return the identifier of the movie clip.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-int clipId = movie.newIdentifier();
+	/**
+	 * Sets the identifier of the movie clip that will be initialized.
+	 * 
+	 * @param aNumber
+	 *            the identifier of the movie clip. The value must be in the
+	 *            range 1..65535.
+	 */
+	public void setIdentifier(int aNumber)
+	{
+		identifier = aNumber;
+	}
 
-movie.add(new FSDefineMovieClip(clipId, clipObjects));
-...
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-movie.add(new FSInitialize(clipId, actions));
-...
-movie.add(new FSShowFrame()); 
-&lt;/pre&gt;
+	/**
+	 * Get the array of actions that are used to initialize the movie clip.
+	 * 
+	 * @return the array of action objects.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSActionObject.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Set the array of actions of the movie clip that will be initialized
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-&lt;p&gt;The FSInitialize class represents the DoInitAction tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 6.&lt;/p&gt;
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
<A HREF="https://lists.berlios.de/mailman/listinfo/transform-svn">- at see</A> FSDoAction
- */  
-public class FSInitialize extends FSMovieObject
-{
-    private int identifier = 0;
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-    
-    /**
-     * Construct an FSInitialize object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSInitialize(FSCoder coder)
-    {
-        super(Initialize);
-        decode(coder);
-    }
-    /**  
-     * Constructs an FSInitialize object that will initialize the movie clip 
-     * with the specified identifier with the actions in the array.
-     *
-     * @param anIdentifier the identifier of the movie clip to initialize
-     * @param anArray the array of action objects.
-     */
-    public FSInitialize(int anIdentifier, ArrayList anArray)
-    {
-        super(Initialize);
-        setIdentifier(anIdentifier);
-        setActions(anArray);
-    }
-    /**  
-     * Constructs an FSInitialize object that will initialize the movie clip 
-     * with the specified identifier with the encoded actions.
-     *
-     * @param anIdentifier the identifier of the movie clip to initialize
-     * @param bytes an array of encoded action objects.
-     */
-    public FSInitialize(int anIdentifier, byte[] bytes)
-    {
-        super(Initialize);
-        setIdentifier(anIdentifier);
-        setEncodedActions(bytes);
-    }
-    /**
-     * Constructs an FSInitialize object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSInitialize object.
-     */
-    public FSInitialize(FSInitialize obj)
-    {
-        super(obj);
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-        identifier = obj.identifier;
-        
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }    
+	public Object clone()
+	{
+		FSInitialize anObject = (FSInitialize) super.clone();
 
-    /** Returns the identifier of the movie clip that will be initialized. 
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-        @return the identifier of the movie clip.
-        */     
-    public int getIdentifier() 
-    {
-        return identifier;
-    }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
+		return anObject;
+	}
 
-    /** Sets the identifier of the movie clip that will be initialized.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aNumber the identifier of the movie clip. The value must be in the 
-        range 1..65535.
-        */     
-    public void setIdentifier(int aNumber)
-    {
-        identifier = aNumber;
-    }
-    
-    /** Adds the action object to the array of actions.
+		if (super.equals(anObject))
+		{
+			FSInitialize typedObject = (FSInitialize) anObject;
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+			result = identifier == typedObject.identifier;
 
-    /** Get the array of actions that are used to initialize the movie clip.
+			if (actions != null)
+				result = result &amp;&amp; actions.equals(typedObject.actions);
+			else
+				result = result
+								&amp;&amp; Transform.equals(encodedActions,
+												typedObject.encodedActions);
+		}
+		return result;
+	}
 
-        @return the array of action objects.
-        */
-    public ArrayList getActions() 
-    { 
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Set the array of actions of the movie clip that will be initialized
+		buffer.append(&quot;FSInitialize: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
 
-        @param anArray the array of action objects.
-        */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+		if (actions != null)
+			buffer.append(&quot;actions = array[&quot;).append(actions.size()).append(&quot;]; &quot;);
+		else
+			buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-    }
+		buffer.append(&quot;}&quot;);
 
-    public Object clone()
-    {
-        FSInitialize anObject = (FSInitialize)super.clone();
-        
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+		return buffer.toString();
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSInitialize typedObject = (FSInitialize)anObject;
-            
-            result = identifier == typedObject.identifier;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-            if (actions != null)
-                result = result &amp;&amp; actions.equals(typedObject.actions);
-            else
-                result = result &amp;&amp; Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+		length += 2;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int length = action.getLength();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (length &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+		coder.writeWord(identifier, 2);
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+		if (actions != null)
+		{
+			FSActionObject action = null;
 
-        identifier = coder.readWord(2, false);
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
 
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
-            
-            int len = length-2;
-            int start;
-            
-            while (len &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length-2];
-            coder.readBytes(encodedActions);
-        }
-        coder.endObject(name());
-    }
+				int objStart = coder.getPointer();
+				int length = action.getLength();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (length &lt;&lt; 3);
+
+				action.encode(coder);
+				coder.setPointer(next);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		identifier = coder.readWord(2, false);
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
+
+			int len = length - 2;
+			int start;
+
+			while (len &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSActionObject.decodeAction(coder));
+				len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[length - 2];
+			coder.readBytes(encodedActions);
+		}
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSLayer.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSLayer.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSLayer.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,11 +33,11 @@
 import java.util.*;
 
 /**
- * The Layer class can be used to simplify the creation of movies. It provides
- * a series of methods that can be used to control how an object is displayed
- * and provides an API that is easier to use when compared to creating the 
- * commands (FSPlaceObject, FSRemoveObject, etc.) used to manipulate the Flash 
- * Player's display list directly. The following code:
+ * The Layer class can be used to simplify the creation of movies. It provides a
+ * series of methods that can be used to control how an object is displayed and
+ * provides an API that is easier to use when compared to creating the commands
+ * (FSPlaceObject, FSRemoveObject, etc.) used to manipulate the Flash Player's
+ * display list directly. The following code:
  * 
  * &lt;pre&gt;
  * FSLayer layer = new Layer(1);
@@ -61,12 +61,12 @@
  * movie.add(FSShowFrame.getInstance());
  * &lt;/pre&gt;
  * 
- * After each set of commands the display list is updated by executing the 
+ * After each set of commands the display list is updated by executing the
  * show() method - this adds a ShowFrame instruction to the final movie which
  * tells the Flash Player to render the display list on the screen.
  * 
- * The select() method is only used when displaying an object for the first 
- * time or re-displaying it after it was deleted from the display list.
+ * The select() method is only used when displaying an object for the first time
+ * or re-displaying it after it was deleted from the display list.
  * 
  * The commands that manipulate the display list can also be combined to apply
  * several operations at once:
@@ -92,15 +92,15 @@
  * movie.add(FSShowFrame.getInstance());
  * &lt;/pre&gt;
  * 
- * An operation is use to set the attributes on either an FSPlaceObject2 or 
- * FSRemoveObject2 object so operations of the same type cannot be combined
- * to create a cumulative effect. For example:
+ * An operation is use to set the attributes on either an FSPlaceObject2 or
+ * FSRemoveObject2 object so operations of the same type cannot be combined to
+ * create a cumulative effect. For example:
  * 
  * &lt;pre&gt;
  * layer.move(x1, y1);
  * layer.move(x2, y2);
  * &lt;/pre&gt;
- *
+ * 
  * is the same as:
  * 
  * &lt;pre&gt;
@@ -110,382 +110,417 @@
  * and not:
  * 
  * &lt;pre&gt;
- * layer.move(x1+x2, y1+y2);
+ * layer.move(x1 + x2, y1 + y2);
  * &lt;/pre&gt;
  * 
- * The most obvious benefit is code that is easier to write and read however
- * the benefits of using layers come to the fore when creating movies with 
- * multiple objects. Currently the movie object represents the main time-line and
- * the commands to control and display each object must be interleaved together.
- * This quickly becomes unwieldy and error prone if several objects are involved.
- * With layers, each can be regarded as the time-line for a single object. The 
- * object can then be manipulated more easily and the final set of Layers merged
- * together to create a single time-line. The only limitation in the merging 
- * process is that all the Layers must start at the same point in time. 
+ * The most obvious benefit is code that is easier to write and read however the
+ * benefits of using layers come to the fore when creating movies with multiple
+ * objects. Currently the movie object represents the main time-line and the
+ * commands to control and display each object must be interleaved together.
+ * This quickly becomes unwieldy and error prone if several objects are
+ * involved. With layers, each can be regarded as the time-line for a single
+ * object. The object can then be manipulated more easily and the final set of
+ * Layers merged together to create a single time-line. The only limitation in
+ * the merging process is that all the Layers must start at the same point in
+ * time.
  * 
- * Each Layer object created must be assigned a unique number. In Flash an object 
- * to be displayed is assigned to a given layer with (typically) only one object 
- * displayed on a given layer. The layer number is used to control the order in 
- * which the objects are displayed. Objects placed on a higher layer number are 
- * displayed in front of object placed on a lower layer number. 
+ * Each Layer object created must be assigned a unique number. In Flash an
+ * object to be displayed is assigned to a given layer with (typically) only one
+ * object displayed on a given layer. The layer number is used to control the
+ * order in which the objects are displayed. Objects placed on a higher layer
+ * number are displayed in front of object placed on a lower layer number.
  * 
  */
 public final class FSLayer
 {
 	/**
-	 * Merge layers together to create a single time-line. Each layer is 
-	 * assumed to start at the same point in time. The process steps through 
-	 * each of the layers, frame by frame, adding all the commands used to 
-	 * manipulate the Flash Player's display list into a single group.
+	 * Merge layers together to create a single time-line. Each layer is assumed
+	 * to start at the same point in time. The process steps through each of the
+	 * layers, frame by frame, adding all the commands used to manipulate the
+	 * Flash Player's display list into a single group.
 	 * 
-	 * @param layers and array of FSLayer objects.
+	 * @param layers
+	 *            and array of FSLayer objects.
 	 * 
-	 * @return an array of all the objects contained in each layer. This array 
-	 * can then be added to the movie.
+	 * @return an array of all the objects contained in each layer. This array
+	 *         can then be added to the movie.
 	 */
-    public static ArrayList merge(ArrayList layers)
-    {
-        ArrayList objects = new ArrayList();
-        
-        int[] idx = new int[layers.size()];
-        
-        for (int i=0; i&lt;idx.length; i++) {
-        	idx[i] = 0;
-        }
-        
-        while (true)
-        {
-        	ArrayList array = null;
-        	FSMovieObject object;
+	public static ArrayList&lt;FSMovieObject&gt; merge(ArrayList&lt;FSLayer&gt; layers)
+	{
+		ArrayList&lt;FSMovieObject&gt; objects = new ArrayList&lt;FSMovieObject&gt;();
 
-        	for (int i=0; i&lt;idx.length; i++)
-            {
-        		array = ((FSLayer)layers.get(i)).getObjects();
-        		
-        		while (idx[i] &lt; array.size())
-        		{
-        			object = (FSMovieObject)array.get(idx[i]++);
-        			
-        			if (object.getType() == FSMovieObject.ShowFrame) {
-        				break;
-        			}
-        			
-        			objects.add(object);
-        		}
-        		
-        		if (idx[i] == array.size()) {
-        			array = null;
-        		}
-            }
-        	objects.add(FSShowFrame.getInstance());
-        	
-        	if (array == null) {
-        		break;
-        	}
-        }
-        
-        return objects;
-    }    
+		int[] idx = new int[layers.size()];
 
-    private int layer;
-    private int identifier;
-    private FSPlaceObject2 place;
-    
-    private ArrayList displayList;
+		for (int i = 0; i &lt; idx.length; i++)
+		{
+			idx[i] = 0;
+		}
 
-    /**
-     * Create a new Layer object. Layers are used to define the order in which
-     * objects are displayed. Objects placed on a high layer number are 
-     * displayed in front of those on a lower layer.
-     * 
-     * @param number the layer number on the display list.
-     */
-    public FSLayer(int number)
-    {
-    	layer = number;
-    	identifier = 0;
-    	displayList = new ArrayList();
-    }
-    
-    /**
-     * Return the layer number. The Flash Player assumes that there is only 
-     * one object placed on each layer and so each must have a unique number.
-     * 
-     * @return the layer number.
-     */
-    public int getLayer()
-    {
-    	return layer;
-    }
-    
-    /**
-     * Return the identifier of the object on the layer. Note: it is possible 
-     * to place more than one object on a layer however only one should be 
-     * visible on the display list at a given time.
-     * 
-     * @return the unique identifier used to reference the object.
-     */
-    public int getIdentifier()
-    {
-    	return identifier;
-    }
-    
-    /**
-     * Return the array of commands used to manipulate the object on the display
-     * list.
-     * 
-     * @return an array of FSMovieObject containing the definition of the object
-     * (shape, text, etc) to be displayed and the associated commands that 
-     * update the position of the object on the screen.
-     */
-    public ArrayList getObjects()
-    {
-    	return displayList;
-    }
+		while (true)
+		{
+			ArrayList&lt;FSMovieObject&gt; array = null;
+			FSMovieObject object;
 
-    /**
-     * Add an object to the layer. The object may be selected later for display.
-     * 
-     * @param definition an object defining an image, shape, text, sound
-     * or video.
-     */
-    public void add(FSDefineObject definition)
-    {
+			for (int i = 0; i &lt; idx.length; i++)
+			{
+				array = ((FSLayer) layers.get(i)).getObjects();
+
+				while (idx[i] &lt; array.size())
+				{
+					object = (FSMovieObject) array.get(idx[i]++);
+
+					if (object.getType() == FSMovieObject.ShowFrame)
+					{
+						break;
+					}
+
+					objects.add(object);
+				}
+
+				if (idx[i] == array.size())
+				{
+					array = null;
+				}
+			}
+			objects.add(FSShowFrame.getInstance());
+
+			if (array == null)
+			{
+				break;
+			}
+		}
+
+		return objects;
+	}
+
+	private int layer;
+	private int identifier;
+	private FSPlaceObject2 place;
+	private ArrayList&lt;FSMovieObject&gt; displayList;
+
+	/**
+	 * Create a new Layer object. Layers are used to define the order in which
+	 * objects are displayed. Objects placed on a high layer number are
+	 * displayed in front of those on a lower layer.
+	 * 
+	 * @param number
+	 *            the layer number on the display list.
+	 */
+	public FSLayer(int number)
+	{
+		layer = number;
+		identifier = 0;
+		displayList = new ArrayList&lt;FSMovieObject&gt;();
+	}
+
+	/**
+	 * Return the layer number. The Flash Player assumes that there is only one
+	 * object placed on each layer and so each must have a unique number.
+	 * 
+	 * @return the layer number.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
+
+	/**
+	 * Return the identifier of the object on the layer. Note: it is possible to
+	 * place more than one object on a layer however only one should be visible
+	 * on the display list at a given time.
+	 * 
+	 * @return the unique identifier used to reference the object.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
+
+	/**
+	 * Return the array of commands used to manipulate the object on the display
+	 * list.
+	 * 
+	 * @return an array of FSMovieObject containing the definition of the object
+	 *         (shape, text, etc) to be displayed and the associated commands
+	 *         that update the position of the object on the screen.
+	 */
+	public ArrayList&lt;FSMovieObject&gt; getObjects()
+	{
+		return displayList;
+	}
+
+	/**
+	 * Add an object to the layer. The object may be selected later for display.
+	 * 
+	 * @param definition
+	 *            an object defining an image, shape, text, sound or video.
+	 */
+	public void add(FSDefineObject definition)
+	{
 		displayList.add(definition);
-    }
-    
-    /**
-     * Select the object previously added to the layer to be added on the 
-     * display list. The object will be placed at the default coordinates (0,0).
-     * 
-     * IMPORTANT: You only need to use this method when adding an object to the
-     * display list for the first time or when re-adding it after it has been
-     * deleted. Since the display list has one layer per object then the layer
-     * number can be used to identify which object to update.
-     * 
-     * @param id an object definition, FSDefineShape, FSDefineImage, etc. that 
-     * will be added to the display list.
-     */
-    public void select(int id)
-    {
+	}
+
+	/**
+	 * Select the object previously added to the layer to be added on the
+	 * display list. The object will be placed at the default coordinates (0,0).
+	 * 
+	 * IMPORTANT: You only need to use this method when adding an object to the
+	 * display list for the first time or when re-adding it after it has been
+	 * deleted. Since the display list has one layer per object then the layer
+	 * number can be used to identify which object to update.
+	 * 
+	 * @param id
+	 *            an object definition, FSDefineShape, FSDefineImage, etc. that
+	 *            will be added to the display list.
+	 */
+	public void select(int id)
+	{
 		identifier = id;
-		place = new FSPlaceObject2(id, layer, 0,0);
+		place = new FSPlaceObject2(id, layer, 0, 0);
 		displayList.add(place);
-    }
+	}
 
-    /**
-     * Add an object to the later and select it to be added on the display list.
-     * 
-     * @param definition an object definition, FSDefineShape, FSDefineImage,
-     * etc. that will be added to the display list.
-     */
-    public void select(FSDefineObject definition)
-    {
+	/**
+	 * Add an object to the later and select it to be added on the display list.
+	 * 
+	 * @param definition
+	 *            an object definition, FSDefineShape, FSDefineImage, etc. that
+	 *            will be added to the display list.
+	 */
+	public void select(FSDefineObject definition)
+	{
 		add(definition);
 		select(definition.getIdentifier());
-    }
+	}
 
-    /**
-     * Set the coordinates where the object will be displayed.
-     * 
-     * @param x the x-coordinate, expressed in twips.
-     * @param y the y-coordinate, expressed in twips.
-     */
-    public void move(int x, int y) 
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, x, y);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setTransform(new FSCoordTransform(x, y));
-    	}
-    }
-    
-    /**
-     * Change the colour of the object to the values (r,g,b). The colour will
-     * be opaque so you cannot use this method to change only the colour of 
-     * a transparent object.
-     * 
-     * @param r the red component of the colour.
-     * @param g the green component of the colour.
-     * @param b the blue component of the colour.
-     */
-    public void color(int r, int g, int b)
-    {
-    	color(r,g,b,255);
-    }
-    
-    /**
-     * Change the colour of the object to the values (r,g,b,a).
-     * 
-     * @param r the red component of the colour.
-     * @param g the green component of the colour.
-     * @param b the blue component of the colour.
-     * @param a the transparency component.
-     */
-    public void color(int r, int g, int b, int a)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, new FSColorTransform(r, g, b, a));
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setColorTransform(new FSColorTransform(r, g, b, a));
-    	}
-    }
-    
-    /** 
-     * Set the number of layers that the outline of the object will clip when
-     * placed on the display list.
-     * 
-     * @param depth the number of layers that will be clipped.
-     */
-    public void clip(int depth)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, (FSCoordTransform)null);
-    		place.setClippingDepth(depth);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setClippingDepth(depth);
-    	}
-    }
-    
-    /**
-     * Set the point in the morphing process for a morph shape in the range 
-     * 0.0 to 1.0. May be set to zero if the shape being placed is not being 
-     * morphed.
-     * 
-     * @param ratio the ratio between the starting shape and the end shape.
-     */
-    public void morph(float ratio)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, ratio, null);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setRatio(ratio);
-    	}
-    }
-    
-    /**
-     * Assign a name to the object.
-     * 
-     * @param name a string that can be used to reference the object.
-     */
-    public void name(String name)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, (FSCoordTransform)null);
-    		place.setName(name);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setName(name);
-    	}
-    }
-        
-    /**
-     * Remove the object from the display list.
-     */
-    public void remove()
-    {
-    	if (place != null) {
-    		place = null;
-    	}
-    	
-    	displayList.add(new FSRemoveObject2(layer));
-    }
+	/**
+	 * Set the coordinates where the object will be displayed.
+	 * 
+	 * @param x
+	 *            the x-coordinate, expressed in twips.
+	 * @param y
+	 *            the y-coordinate, expressed in twips.
+	 */
+	public void move(int x, int y)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, x, y);
+			displayList.add(place);
+		} else
+		{
+			place.setTransform(new FSCoordTransform(x, y));
+		}
+	}
 
-    /**
-     * Replace the object on the display list.
-     */
-    public void replace(int id)
-    {
+	/**
+	 * Change the colour of the object to the values (r,g,b). The colour will be
+	 * opaque so you cannot use this method to change only the colour of a
+	 * transparent object.
+	 * 
+	 * @param r
+	 *            the red component of the colour.
+	 * @param g
+	 *            the green component of the colour.
+	 * @param b
+	 *            the blue component of the colour.
+	 */
+	public void color(int r, int g, int b)
+	{
+		color(r, g, b, 255);
+	}
+
+	/**
+	 * Change the colour of the object to the values (r,g,b,a).
+	 * 
+	 * @param r
+	 *            the red component of the colour.
+	 * @param g
+	 *            the green component of the colour.
+	 * @param b
+	 *            the blue component of the colour.
+	 * @param a
+	 *            the transparency component.
+	 */
+	public void color(int r, int g, int b, int a)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, new FSColorTransform(r, g, b, a));
+			displayList.add(place);
+		} else
+		{
+			place.setColorTransform(new FSColorTransform(r, g, b, a));
+		}
+	}
+
+	/**
+	 * Set the number of layers that the outline of the object will clip when
+	 * placed on the display list.
+	 * 
+	 * @param depth
+	 *            the number of layers that will be clipped.
+	 */
+	public void clip(int depth)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, (FSCoordTransform) null);
+			place.setClippingDepth(depth);
+			displayList.add(place);
+		} else
+		{
+			place.setClippingDepth(depth);
+		}
+	}
+
+	/**
+	 * Set the point in the morphing process for a morph shape in the range 0.0
+	 * to 1.0. May be set to zero if the shape being placed is not being
+	 * morphed.
+	 * 
+	 * @param ratio
+	 *            the ratio between the starting shape and the end shape.
+	 */
+	public void morph(float ratio)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, ratio, null);
+			displayList.add(place);
+		} else
+		{
+			place.setRatio(ratio);
+		}
+	}
+
+	/**
+	 * Assign a name to the object.
+	 * 
+	 * @param name
+	 *            a string that can be used to reference the object.
+	 */
+	public void name(String name)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, (FSCoordTransform) null);
+			place.setName(name);
+			displayList.add(place);
+		} else
+		{
+			place.setName(name);
+		}
+	}
+
+	/**
+	 * Remove the object from the display list.
+	 */
+	public void remove()
+	{
+		if (place != null)
+		{
+			place = null;
+		}
+
+		displayList.add(new FSRemoveObject2(layer));
+	}
+
+	/**
+	 * Replace the object on the display list.
+	 */
+	public void replace(int id)
+	{
 		identifier = id;
 
-		if (place == null) {
-    		place = new FSPlaceObject2(id, layer);
-    		displayList.add(place);
-    	}
-    	else {
-    		place.setIdentifier(id);
-    		place.setPlaceType(FSPlaceObject2.Replace);
-    	}
-    }
+		if (place == null)
+		{
+			place = new FSPlaceObject2(id, layer);
+			displayList.add(place);
+		} else
+		{
+			place.setIdentifier(id);
+			place.setPlaceType(FSPlaceObject2.Replace);
+		}
+	}
 
-    /**
-     * Change the colour of the object by applying a color transform.
-     * 
-     * @param color the color transform to apply to the shape.
-     */
-    public void change(FSColorTransform color)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, color);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setColorTransform(color);
-    	}
-    }
-    
-    /**
-     * Change the position, orientation and scaling of the object by applying a 
-     * 2D coordinate transform.
-     * 
-     * Use this method to apply more complex coordinate transforms to an object
-     * for example that composite move, scaling and rotation operations in a 
-     * single step.
-     * 
-     * @param coord the coordinate transform to apply to the object.
-     */
-    public void change(FSCoordTransform coord)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, coord);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setTransform(coord);
-    	}
-    }
-    
-    /**
-     * Instruct the Flash Player to display a frame and render the contents of 
-     * the display list, applying the commands previously set. You must use this 
-     * method for any of the other operations to take effect.
-     * 
-     */
-    public void show()
-    {
-    	show(1);
-    }
-    
-    /**
-     * Display one or more frames. The state (position, orientation, visibility,
-     * etc.) of the object will remain unchanged for the duration of the 
-     * added frames. 
-     * 
-     * @param count the number of frames to be displayed.
-     * @throws IllegalArgumentException is the number of frames is less than 1.
-     */
-    public void show(int count)
-    {
-    	if (count &lt; 1) {
-    		throw new IllegalArgumentException(&quot;Must show at least one frame&quot;);
-    	}
-    	
-    	if (place != null) {
-    		place = null;
-    	}
-    	
-    	for (int i=0; i&lt;count; i++) {
-    		displayList.add(FSShowFrame.getInstance());
-    	}
-    }
+	/**
+	 * Change the colour of the object by applying a color transform.
+	 * 
+	 * @param color
+	 *            the color transform to apply to the shape.
+	 */
+	public void change(FSColorTransform color)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, color);
+			displayList.add(place);
+		} else
+		{
+			place.setColorTransform(color);
+		}
+	}
+
+	/**
+	 * Change the position, orientation and scaling of the object by applying a
+	 * 2D coordinate transform.
+	 * 
+	 * Use this method to apply more complex coordinate transforms to an object
+	 * for example that composite move, scaling and rotation operations in a
+	 * single step.
+	 * 
+	 * @param coord
+	 *            the coordinate transform to apply to the object.
+	 */
+	public void change(FSCoordTransform coord)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, coord);
+			displayList.add(place);
+		} else
+		{
+			place.setTransform(coord);
+		}
+	}
+
+	/**
+	 * Instruct the Flash Player to display a frame and render the contents of
+	 * the display list, applying the commands previously set. You must use this
+	 * method for any of the other operations to take effect.
+	 * 
+	 */
+	public void show()
+	{
+		show(1);
+	}
+
+	/**
+	 * Display one or more frames. The state (position, orientation, visibility,
+	 * etc.) of the object will remain unchanged for the duration of the added
+	 * frames.
+	 * 
+	 * @param count
+	 *            the number of frames to be displayed.
+	 * @throws IllegalArgumentException
+	 *             is the number of frames is less than 1.
+	 */
+	public void show(int count)
+	{
+		if (count &lt; 1)
+		{
+			throw new IllegalArgumentException(&quot;Must show at least one frame&quot;);
+		}
+
+		if (place != null)
+		{
+			place = null;
+		}
+
+		for (int i = 0; i &lt; count; i++)
+		{
+			displayList.add(FSShowFrame.getInstance());
+		}
+	}
 }
-

Modified: dev/dev-2-4/src/com/flagstone/transform/FSLimitScript.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSLimitScript.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSLimitScript.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,169 +31,197 @@
 package com.flagstone.transform;
 
 /**
-The FSLimitScript is used to define the execution environment of the Flash Player, 
-limiting the resources available when executing actions.
+ * The FSLimitScript is used to define the execution environment of the Flash
+ * Player, limiting the resources available when executing actions.
+ * 
+ * &lt;p&gt;
+ * FSLimitScript can be used to limit the maximum recursion depth and limit the
+ * time a sequence of actions can execute for. This provides a rudimentary
+ * mechanism for people viewing a movie to regain control of the Flash Player
+ * should a script fail.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;depth&lt;/td&gt;
+ * &lt;td&gt;The maximum depth, in the range 1..65535, that a sequence of actions can
+ * recurse to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;timeout&lt;/td&gt;
+ * &lt;td&gt;The maximum time, in seconds, that a sequence of actions will execute
+ * before the Flash Player present a dialog box asking whether the script should
+ * be terminated.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSLimitScript represents the ScriptLimits tag in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSLimitScript extends FSMovieObject
+{
+	private int depth = 0;
 
-&lt;p&gt;FSLimitScript can be used to limit the maximum recursion depth and limit the time a sequence of actions can execute for. This provides a rudimentary mechanism for people viewing a movie to regain control of the Flash Player should a script fail.&lt;/p&gt;
+	private int timeout = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSLimitScript object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSLimitScript(FSCoder coder)
+	{
+		super(LimitScript);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSLimitScript object that limits the recursion depth to
+	 * &lt;em&gt;depth&lt;/em&gt; levels and specifies that any sequence of actions will
+	 * timeout after &lt;em&gt;timeout&lt;/em&gt; seconds.
+	 * 
+	 * @param depth
+	 *            the maximum depth a sequence of actions can recurse to.
+	 * @param timeout
+	 *            the time in seconds that a sequence of actions is allowed to
+	 *            execute before the Flash Player displays a dialog box asking
+	 *            whether the script should be terminated.
+	 */
+	public FSLimitScript(int depth, int timeout)
+	{
+		super(LimitScript);
+		setDepth(depth);
+		setTimeout(timeout);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLimitScript_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSLimitScript object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSLimitScript object.
+	 */
+	public FSLimitScript(FSLimitScript obj)
+	{
+		super(obj);
+		depth = obj.depth;
+		timeout = obj.timeout;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLimitScript_1&quot;&gt;depth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum depth, in the range 1..65535, that a sequence of actions can recurse to.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the maximum recursion level.
+	 * 
+	 * @return the maximum depth a sequence of actions can recurse to.
+	 */
+	public int getDepth()
+	{
+		return depth;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLimitScript_1&quot;&gt;timeout&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum time, in seconds, that a sequence of actions will execute before the Flash Player present a dialog box asking whether the script should be terminated.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the maximum recursion level.
+	 * 
+	 * @param depth
+	 *            the maximum depth a sequence of actions can recurse to.
+	 */
+	public void setDepth(int depth)
+	{
+		this.depth = depth;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the maximum time a sequence of actions will execute before the Flash
+	 * Player present a dialog box asking whether the script should be
+	 * terminated.
+	 * 
+	 * @return the time in seconds that a sequence of actions is allowed to
+	 *         execute.
+	 */
+	public int getTimeout()
+	{
+		return timeout;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the maximum time a sequence of actions will execute before the Flash
+	 * Player present a dialog box asking whether the script should be
+	 * terminated.
+	 * 
+	 * @param time
+	 *            the time in seconds that a sequence of actions is allowed to
+	 *            execute.
+	 */
+	public void setTimeout(int time)
+	{
+		timeout = time;
+	}
 
-&lt;p&gt;The FSLimitScript represents the ScriptLimits tag in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSLimitScript extends FSMovieObject
-{
-    private int depth = 0; 
-    private int timeout = 0; 
-    
-    /**
-     * Construct an FSLimitScript object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSLimitScript(FSCoder coder)
-    {
-        super(LimitScript);
-        decode(coder);
-    }
-    /**
-     * Constructs an FSLimitScript object that limits the recursion depth to &lt;em&gt;depth&lt;/em&gt; levels
-     * and specifies that any sequence of actions will timeout after &lt;em&gt;timeout&lt;/em&gt; seconds.
-     *
-     * @param depth the maximum depth a sequence of actions can recurse to.
-     * @param timeout the time in seconds that a sequence of actions is allowed to execute before the Flash Player displays a dialog box asking whether the script should be terminated.
-     */
-    public FSLimitScript(int depth, int timeout)
-    {
-        super(LimitScript);
-        setDepth(depth);
-        setTimeout(timeout);
-    }
-    /**
-     * Constructs an FSLimitScript object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSLimitScript object.
-     */
-    public FSLimitScript(FSLimitScript obj)
-    {
-        super(obj);
-        depth = obj.depth;
-        timeout = obj.timeout;
-    }    
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Gets the maximum recursion level.
-     *
-     * @return the maximum depth a sequence of actions can recurse to.
-     */
-    public int getDepth() 
-    {
-        return depth;
-    }
+		if (super.equals(anObject))
+		{
+			FSLimitScript typedObject = (FSLimitScript) anObject;
 
-    /**
-     * Sets the maximum recursion level.
-     *
-     * @param depth the maximum depth a sequence of actions can recurse to.
-     */
-    public void setDepth(int depth)
-    {
-        this.depth = depth;
-    }
-    
-    /**
-     * Gets the maximum time a sequence of actions will execute before the Flash Player present a dialog box asking whether the script should be terminated.
-     *
-     * @return the time in seconds that a sequence of actions is allowed to execute.
-     */
-    public int getTimeout() 
-    {
-        return timeout;
-    }
+			result = depth == typedObject.depth;
+			result = result &amp;&amp; timeout == typedObject.timeout;
+		}
+		return result;
+	}
 
-    /**
-     * Sets the maximum time a sequence of actions will execute before the Flash Player present a dialog box asking whether the script should be terminated.
-     *
-     * @param time the time in seconds that a sequence of actions is allowed to execute.
-     */
-    public void setTimeout(int time)
-    {
-        timeout = time;
-    }
-    
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSLimitScript typedObject = (FSLimitScript) anObject;
-            
-            result = depth == typedObject.depth;
-            result = result &amp;&amp; timeout == typedObject.timeout;
-        }
-        return result;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    public void appendDescription(StringBuffer buffer, int stackDepth)
-    {
-        buffer.append(name());
-        
-        if (stackDepth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;depth&quot;, depth);
-            Transform.append(buffer, &quot;timeout&quot;, timeout);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		buffer.append(&quot;FSLimitScript: { &quot;);
+		buffer.append(&quot;depth = &quot;).append(depth).append(&quot;; &quot;);
+		buffer.append(&quot;timeout = &quot;).append(timeout).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(depth, 2);
-        coder.writeWord(timeout, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        depth = coder.readWord(2, false);
-        timeout = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+		return buffer.toString();
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 4;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(depth, 2);
+		coder.writeWord(timeout, 2);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		depth = coder.readWord(2, false);
+		timeout = coder.readWord(2, false);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSLine.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSLine.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSLine.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -74,7 +74,7 @@
  * (SWF) File Format Specification. It was introduced in Flash 1.
  * &lt;/p&gt;
  */
-public class FSLine extends FSShapeObject implements Cloneable, Codeable
+public class FSLine extends FSShapeObject
 {
 	private int x;
 	private int y;

Deleted: dev/dev-2-4/src/com/flagstone/transform/FSMorphSolidLine.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSMorphSolidLine.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSMorphSolidLine.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,261 +0,0 @@
-/*
- * FSMorphSolidLine.java
- * Transform
- * 
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform;
-
-/**
-FSMorphSolidLine defines the width and colour of a line drawn for a morphing shape. 
- 
-&lt;p&gt;It specifies the width and colour of the line at the start and end of the morphing process. The transparency value for the colour should also be specified. As with the FSSolidLine class all lines are drawn with rounded corners and end caps. Different join and line end styles can be created by drawing very narrow shapes.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_0&quot;&gt;startWidth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The width of the line at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_1&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour applied to the line at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_2&quot;&gt;endWidth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The width of the line at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_3&quot;&gt;endColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour applied to the line at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
-
-&lt;p&gt;The FSDefineMorphShape object support transparent colours so alpha channel information must be specified in the colour objects.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSMorphSolidLine class represents the MorphLineStyle structure from the Macromedia Flash (SWF) File Format Specification. Shape morphing was introduced in Flash 3.&lt;/P&gt;
- */  
-public class FSMorphSolidLine extends FSLineStyle
-{
-    private int startWidth = 0;
-    private int endWidth = 0;
-    private FSColor startColor = null;
-    private FSColor endColor = null;
-    
-    /**
-     * Construct an FSMorphSolidLine object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSMorphSolidLine(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSMorphLineStyle object specifying the starting and ending widths and colours.
-
-        @param aStartWidth the width of the line at the start of the morphing process.
-        @param anEndWidth the width of the line at the end of the morphing process.
-        @param aStartColor the colour of the line at the start of the morphing process.
-        @param anEndColor the colour of the line at the end of the morphing process.
-        */
-    public FSMorphSolidLine(int aStartWidth, int anEndWidth, FSColor aStartColor, FSColor anEndColor)
-    {
-        setStartWidth(aStartWidth);
-        setEndWidth(anEndWidth);
-        setStartColor(aStartColor);
-        setEndColor(anEndColor);
-    }
-    /**
-     * Constructs an FSMorphSolidLine object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSMorphSolidLine object.
-     */
-    public FSMorphSolidLine(FSMorphSolidLine obj)
-    {
-        startWidth = obj.startWidth;
-        endWidth = obj.endWidth;
-        startColor = new FSColor(obj.startColor);
-        endColor = new FSColor(obj.endColor);
-    }    
-
-    /** Gets the width of the line at the start of the morphing process.
-
-        @return the starting width of the line.
-        */
-    public int getStartWidth() 
-    { 
-        return startWidth; 
-    }
-
-    /** Gets the width of the line at the end of the morphing process.
-
-        @return the ending width of the line.
-        */
-    public int getEndWidth() 
-    { 
-        return endWidth; 
-    }
-
-    /** Gets the colour of the line at the start of the morphing process.
-
-        @return the starting colour of the line.
-        */
-    public FSColor getStartColor() { return startColor; }
-
-    /** Gets the colour of the line at the end of the morphing process.
-
-        @return the ending colour of the line.
-        */
-    public FSColor getEndColor() { return endColor; }
-
-    /** Sets the width of the line at the start of the morphing process.
-
-        @param aNumber the starting width of the line.
-        */
-    public void setStartWidth(int aNumber)
-    {
-        startWidth = aNumber;
-    }
-
-    /** Sets the width of the line at the end of the morphing process.
-
-        @param aNumber the ending width of the line.
-        */
-    public void setEndWidth(int aNumber)
-    {
-        endWidth = aNumber;
-    }
-
-    /** Gets the colour of the line at the start of the morphing process.
-
-        @param aColor the starting colour of the line.
-        */
-    public void setStartColor(FSColor aColor)
-    {
-        startColor = aColor;
-    }
-
-    /** Sets the colour of the line at the end of the morphing process.
-
-        @param aColor the ending colour of the line.
-        */
-    public void setEndColor(FSColor aColor)
-    {
-        endColor = aColor;
-    }
-
-    public Object clone()
-    {
-        FSMorphSolidLine anObject = (FSMorphSolidLine)super.clone();
-        
-        anObject.startColor = (startColor != null) ? (FSColor)startColor.clone() : null;
-        anObject.endColor = (endColor != null) ? (FSColor)endColor.clone() : null;
-        
-        return anObject;
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSMorphSolidLine typedObject = (FSMorphSolidLine)anObject;
-            
-            result = startWidth == typedObject.startWidth;
-            result = result &amp;&amp; endWidth == typedObject.endWidth;
-
-            if (startColor != null)
-                result = result &amp;&amp; startColor.equals(typedObject.startColor);
-            else
-                result = result &amp;&amp; startColor == typedObject.startColor;
-
-            if (endColor != null)
-                result = result &amp;&amp; endColor.equals(typedObject.endColor);
-            else
-                result = result &amp;&amp; endColor == typedObject.endColor;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startWidth&quot;, startWidth);
-            Transform.append(buffer, &quot;endWidth&quot;, endWidth);
-            Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
-            Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 4;
-    
-        length += startColor.length(coder);
-        length += endColor.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(startWidth, 2);
-        coder.writeWord(endWidth, 2);
-        startColor.encode(coder);
-        endColor.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        startWidth = coder.readWord(2, false);
-        endWidth = coder.readWord(2, false);
-        startColor = new FSColor(coder);
-        endColor = new FSColor(coder);
-    }
-}
\ No newline at end of file

Deleted: dev/dev-2-4/src/com/flagstone/transform/FSMovieEvent.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSMovieEvent.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSMovieEvent.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,175 +0,0 @@
-/*
- * FSMovieEvent.java
- * Transform
- * 
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform;
-
-/**
- * @deprecated the FSMovieEvent will no longer be supported in future releases
- * to report decoding and encoding events and to report errors. Instead methods
- * which report errors through exceptions are preferred. If an error occurs then
- * it is due to an error which cannot be easily recovered from therefore the
- * FSMovieEvent will no longer be used.
- * 
- * The FSMovieEvent class is a container class for the information generated for events 
- * while a movie is being encoded or decoded.
- *
- */
-public class FSMovieEvent
-{
-    /** Identifies an event generated while a movie is being encoded. */
-    public static final int Encode = 0;
-    /** Identifies an event generated while a movie is being decoded. */
-    public static final int Decode = 1;
-
-    /** Identifies an event generated when an object in a movie begins to be encoded or decoded. */
-    public static final int Begin = 0;
-    /** Identifies an event generated when an object in a movie completes being encoded or decoded. */
-    public static final int End = 1;
-    /** Identifies an error occurred while a movie is being encoded or decoded. */
-    public static final int Error  = 2;
-    /** Identifies a value read from the binary Flash file as it is being decoded. */
-    public static final int Value = 3;
-
-    private int action = 0;
-    private int event = 0;
-    private int location = 0;
-    private int length = 0;
-
-    private Object value;
-
-    /**
-     * Constructs an FSMovieEvent object reporting whether the event.
-     * 
-     * @param anAction identifies whether the event was generated while the movie was being encoded
-     * or decoded.
-     * 
-     * @param anEvent identifies the type of event, signalling either the start and end of each object
-     * being decoded, a value decoded while will be assigned to an object attributes or whether an
-     * error occurred.
-     * 
-     * @param aLocation identifies the offset in bits from the start of the movie where the event occurred.
-     * 
-     * @param aLength identifies the number of bits involved when decoding a value. This is set to zero 
-     * for Begin, End and Error events.
-     * 
-     * @param aValue depends on the type of event generated. For Begin and End events, aValue is a String
-     * containing the name of the object being encoded or decoded. For Value events, aValue is an object
-     * wrapping the value being decoded. For Error events, aValue is an error message describing the error
-     * that occurred.
-     */
-    public FSMovieEvent(int anAction, int anEvent, int aLocation, int aLength, Object aValue)
-    {
-        action = anAction;
-        event = anEvent;
-        location = aLocation;
-        length = aLength;
-        value = aValue;
-    }
-    
-    /**
-     * Returns the type of action that generated the event, either Decode when a movie is being decoded
-     * or Encode when a movie is being encoded.
-     * 
-     * @return FSMovieEvent.Decode or FSMovieEvent.Encode according to whether a movie is being decoded 
-     * or encoded.
-     */
-    public int getAction() 
-    { 
-        return action;
-    }
-
-    /**
-     * Identifies the type of event that occurred.
-     * 
-     * FSMovieEvent.Begin occurs when an object in a movie begins the process of being encoded
-     * or decoded.
-     * 
-     * FSMovieEvent.End occurs when an object in a movie completes the process of being encoded
-     * or decoded.
-     * 
-     * FSMovieEvent.Value occurs when an attribute of an object is decoded.
-     * 
-     * FSMovieEvent.Error occurs when an error is detected while encoding or decoding a movie.
-     * 
-     * @return the type of event that occurred.
-     */
-    public int getEvent() 
-    { 
-        return event;
-    }
-
-    /**
-     * Identifies the offset in bits from the start of the movie where the event occurred.
-     * 
-     * @return the bit offset where the event occurred.
-     */
-    public int getLocation() 
-    { 
-        return location;
-    }
-
-    /**
-     * Identifies the number of bits involved when decoding a value. This is set to zero 
-     * for Begin, End and Error events.
-     * 
-     * @return the number of bits read from the file for the decoded value.
-     */
-    public int getLength() 
-    { 
-        return length;
-    }
-
-    /**
-     * Returns an object containing information on the event. The object depends on the type of event 
-     * generated. For Begin and End events, aValue is a String containing the name of the object being 
-     * encoded or decoded. For Value events, aValue is an object wrapping the value being decoded. For 
-     * Error events, aValue is String containing an error message describing the error that occurred.
-     * 
-     * @return an object containing information associated with the event.
-     */
-    public Object getValue() 
-    { 
-        return value;
-    }
-
-    /**
-     * Generates a string representation of the event object.
-     * 
-     * @return a string reporting the values in the attributes.
-     */
-    public String toString()
-    {
-        String description = null;
-
-        description = &quot;FSMovieEvent: { action = &quot; + action + &quot;; event = &quot; + event + &quot;; location = &quot; + location + &quot;; length = &quot; + length + &quot;; value = &quot; + value.toString() + &quot;};&quot;;
-
-        return description;
-    }
-}

Deleted: dev/dev-2-4/src/com/flagstone/transform/FSMovieListener.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSMovieListener.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSMovieListener.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,57 +0,0 @@
-/*
- * FSMovieListener.java
- * Transform
- * 
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform;
-
-/**
- * @deprecated the FSMovieListener interface will no longer be used future 
- * release to report decoding and encoding events and to report errors. Instead 
- * methods which report errors through exceptions are preferred. If an error 
- * occurs then it is due to a design error or corrupt data in a Flash file which 
- * cannot be easily recovered from therefore the FSMovieListener interface will 
- * no longer be used.
-
- * The FSMovieListener interface defines the methods required to register an object to 
- * receive event information from an FSMovie object as it encodes and decodes Flash 
- * movies.
- *
- */
-public interface FSMovieListener
-{
-    /**
-     * @deprecated
-     * 
-     * The FSMovie object calls this method to send FSMovieEvent object to a registered
-     * listener.
-     * 
-     * @param anEvent an FSMovieEvent object containing the information about an event.
-     */
-    public void logEvent(FSMovieEvent anEvent);
-}

Modified: dev/dev-2-4/src/com/flagstone/transform/FSNewFunction.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSNewFunction.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSNewFunction.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,430 +33,496 @@
 import java.util.*;
 
 /**
-The FSNewFunction action is used to create a user-defined function.
+ * The FSNewFunction action is used to create a user-defined function.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through an array of FSActionObjects
+ * to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;A string defining the name of the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;arguments&lt;/td&gt;
+ * &lt;td&gt;An array containing the names of the arguments. The order of the strings
+ * in the argument array indicate the order in which the values will be popped
+ * off the stack when the function is executed. The fist argument is popped from
+ * the stack first.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * User-defined functions are also used to create methods for user-defined
+ * objects. The name of the function is omitted and the function definition is
+ * assigned to a variable which allows it to be referenced at a alter time. See
+ * the example below:
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The arguments supplied to the function can be referenced by the name supplied
+ * in the arguments array.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * All the action objects added are owned by the function. They will be deleted
+ * when the function definition is deleted.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Define a function&lt;br/&gt; Define a function that increments the value passed
+ * to it:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // List the names of the arguments
+ * 
+ * ArrayList arguments = new ArrayList();
+ * 
+ * arguments.add(&quot;value&quot;);
+ * 
+ * // Now define the actions performed by the function. Values passed to the function
+ * // can be referenced by the name defined in the array of arguments.
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(new FSPush(&quot;value&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(1));
+ * actions.add(FSAction.Add());
+ * actions.add(FSAction.Return());
+ * actions.add(new FSNewFunction(&quot;increment&quot;, arguments, actions));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be referenced using it's name:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(1));
+ * actions.add(new FSPush(&quot;increment&quot;));
+ * actions.add(FSAction.ExecuteFunction());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Defining a method.&lt;br/&gt; When creating a user-defined object the name of
+ * the function can be omitted. Simply assign the function definition to a
+ * variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  actions.add(new FSPush(methodVariable));
+ * 
+ *  FSVector&lt;FSString&gt; arguments;
+ * 
+ *  arguments.push_back(&quot;value&quot;);
+ * 
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;value&quot;));
+ *  actions.add(FSAction.GetVariable());
+ *  actions.add(new FSPush(1));
+ *  actions.add(FSAction.Add());
+ *  actions.add(FSAction.Return());
+ *  actions.add(new FSNewFunction(arguments, actions));
+ *  actions.add(FSAction.SetVariable()));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be executed by pushing the arguments onto the stack
+ * then calling the function assigned to the variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push argument(s) onto stack
+ * 
+ * actions.add(new FSPush(1));
+ * 
+ * // Get the variable that contains the function
+ * 
+ * actions.add(new FSPush(methodVariable));
+ * actions.add(FSAction.GetVariable());
+ * 
+ * // Execute the function
+ * actions.add(FSAction.ExecuteFunction());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSNewFunction class represents the ActionDefineFunction action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5.
+ * &lt;/p&gt;
+ */
+public class FSNewFunction extends FSActionObject
+{
+	private String name = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private ArrayList arguments = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private ArrayList actions = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through an array of FSActionObjects to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	private int actionsLength = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_1&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A string defining the name of the function.&lt;/td&gt;
-&lt;/tr&gt;
+	FSNewFunction()
+	{
+		super(NewFunction);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_2&quot;&gt;arguments&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array containing the names of the arguments. The order of the strings in the argument array indicate the order in which the values will be popped off the stack when the function is executed. The fist argument is popped from the stack first.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSNewFunction object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSNewFunction(FSCoder coder)
+	{
+		super(NewFunction);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_3&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSNewFunction with the specified name, argument names and
+	 * actions to be executed. The order of the Strings in the argument array
+	 * indicate the order in which the values will be popped off the stack when
+	 * the function is executed. The fist argument is popped from the stack
+	 * first.
+	 * 
+	 * @param aString
+	 *            the name of the function.
+	 * @param argumentArray
+	 *            an array of Strings listing the names of the arguments.
+	 * @param actionArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction(String aString, ArrayList argumentArray,
+							ArrayList actionArray)
+	{
+		super(NewFunction);
+		setName(aString);
+		setArguments(argumentArray);
+		setActions(actionArray);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an anonymous FSNewFunction with the specified argument names
+	 * and actions to be executed. Use this constructor when defining functions
+	 * that will be assigned to object variables and used as methods.
+	 * 
+	 * @param argumentArray
+	 *            an array of Strings listing the names of the arguments.
+	 * @param actionArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction(ArrayList argumentArray, ArrayList actionArray)
+	{
+		super(NewFunction);
+		setArguments(argumentArray);
+		setActions(actionArray);
+	}
 
-&lt;p&gt;User-defined functions are also used to create methods for user-defined objects. The name of the function is omitted and the function definition is assigned to a variable which allows it to be referenced at a alter time. See the example below:&lt;/p&gt;
+	/**
+	 * Constructs an FSNewFunction object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSNewFunction object.
+	 */
+	public FSNewFunction(FSNewFunction obj)
+	{
+		super(obj);
 
-&lt;p&gt;The arguments supplied to the function can be referenced by the name supplied in the arguments array.&lt;/p&gt;
+		if (obj.name != null)
+			name = new String(obj.name);
 
-&lt;p&gt;All the action objects added are owned by the function. They will be deleted when the function definition is deleted.&lt;/p&gt;
+		if (obj.arguments != null)
+		{
+			arguments = new ArrayList(obj.arguments.size());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+			for (Iterator i = obj.arguments.iterator(); i.hasNext();)
+				arguments.add(new String(i.next().toString()));
+		}
 
-&lt;p&gt;1. Define a function&lt;br/&gt;
-Define a function that increments the value passed to it:&lt;/p&gt;
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-&lt;pre&gt;
-// List the names of the arguments
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		}
+	}
 
-ArrayList arguments = new ArrayList();
+	/**
+	 * Adds the name of an argument to the array of argument names.
+	 * 
+	 * @param anArgument
+	 *            the name of an argument passed to the FSNewFunction object.
+	 */
+	public void add(String anArgument)
+	{
+		arguments.add(anArgument);
+	}
 
-arguments.add(&quot;value&quot;);
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		actions.add(anAction);
+	}
 
-// Now define the actions performed by the function. Values passed to the function
-// can be referenced by the name defined in the array of arguments.
+	/**
+	 * Gets the name of the function.
+	 * 
+	 * @return the name of the function.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Gets the names of the function arguments.
+	 * 
+	 * @return the array of argument names.
+	 */
+	public ArrayList getArguments()
+	{
+		return arguments;
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction(&quot;increment&quot;, arguments, actions));
-&lt;/pre&gt;
+	/**
+	 * Gets the actions.
+	 * 
+	 * @return the array of actions executed.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-&lt;p&gt;The function can then be referenced using it's name:&lt;/p&gt;
+	/**
+	 * Sets the name of the function.
+	 * 
+	 * @param aString
+	 *            the name of the function.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(1));
-actions.add(new FSPush(&quot;increment&quot;));
-actions.add(FSAction.ExecuteFunction());
-&lt;/pre&gt;
+	/**
+	 * Sets the names of the function arguments.
+	 * 
+	 * @param anArray
+	 *            an array of Strings listing the names of the arguments.
+	 */
+	public void setArguments(ArrayList anArray)
+	{
+		arguments = anArray;
+	}
 
-&lt;p&gt;2. Defining a method.&lt;br/&gt;
-When creating a user-defined object the name of the function can be omitted. Simply assign the function definition to a variable:&lt;/p&gt;
+	/**
+	 * Sets the actions.
+	 * 
+	 * @param anArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(methodVariable));
+	public Object clone()
+	{
+		FSNewFunction anObject = (FSNewFunction) super.clone();
 
-FSVector&lt;FSString&gt; arguments;
+		anObject.arguments = new ArrayList();
 
-arguments.push_back(&quot;value&quot;);
+		for (Iterator i = arguments.iterator(); i.hasNext();)
+			anObject.arguments.add(new String((String) i.next()));
 
-ArrayList actions = new ArrayList();
+		anObject.actions = new ArrayList();
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction(arguments, actions));
-actions.add(FSAction.SetVariable()));
-&lt;/pre&gt;
+		for (Iterator i = actions.iterator(); i.hasNext();)
+			anObject.actions.add(((FSActionObject) i.next()).clone());
 
-&lt;p&gt;The function can then be executed by pushing the arguments onto the stack then calling the function assigned to the variable:&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;pre&gt;
-// Push argument(s) onto stack
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-actions.add(new FSPush(1));
+		if (super.equals(anObject))
+		{
+			FSNewFunction typedObject = (FSNewFunction) anObject;
 
-// Get the variable that contains the function
+			if (name != null)
+				result = name.equals(typedObject.name);
+			else
+				result = name == typedObject.name;
 
-actions.add(new FSPush(methodVariable));
-actions.add(FSAction.GetVariable());
+			if (arguments != null)
+				result = result &amp;&amp; arguments.equals(typedObject.arguments);
+			else
+				result = result &amp;&amp; arguments == typedObject.arguments;
 
-// Execute the function
-actions.add(FSAction.ExecuteFunction());
-&lt;/pre&gt;
+			if (actions != null)
+				result = result &amp;&amp; actions.equals(typedObject.actions);
+			else
+				result = result &amp;&amp; actions == typedObject.actions;
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;p&gt;The FSNewFunction class represents the ActionDefineFunction action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSNewFunction extends FSActionObject
-{
-    private String name = null;
-    private ArrayList arguments = null;
-    private ArrayList actions = null;
+		buffer.append(&quot;FSNewFunction: { &quot;);
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
+		buffer.append(&quot;arguments = &quot;).append(arguments.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;actions = &quot;).append(actions.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    private int actionsLength = 0;
-    
-    FSNewFunction()
-    {
-        super(NewFunction);
-    }
-    /**
-     * Construct an FSNewFunction object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSNewFunction(FSCoder coder)
-    {
-        super(NewFunction);
-        decode(coder);
-    }
-    /** Constructs an FSNewFunction with the specified name, argument names and actions to be executed. The order of the Strings in the argument array indicate the order in which the values will be popped off the stack when the function is executed. The fist argument is popped from the stack first.
+		return buffer.toString();
+	}
 
-        @param aString the name of the function.
-        @param argumentArray an array of Strings listing the names of the arguments.
-        @param actionArray the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction(String aString, ArrayList argumentArray, ArrayList actionArray)
-    {
-        super(NewFunction);
-        setName(aString);
-        setArguments(argumentArray);
-        setActions(actionArray);
-    }
-    /** Constructs an anonymous FSNewFunction with the specified argument names and actions to be executed. Use this constructor when defining functions that will be assigned to object variables and used as methods.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param argumentArray an array of Strings listing the names of the arguments.
-        @param actionArray the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction(ArrayList argumentArray, ArrayList actionArray)
-    {
-        super(NewFunction);
-        setArguments(argumentArray);
-        setActions(actionArray);
-    }
-    /**
-     * Constructs an FSNewFunction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSNewFunction object.
-     */
-    public FSNewFunction(FSNewFunction obj)
-    {
-        super(obj);
+		length += (name != null) ? FSCoder.strlen(name, true) : 1;
+		length += 2;
 
-        if (obj.name != null)
-            name = new String(obj.name);
-        
-        if (obj.arguments != null)
-        {
-            arguments = new ArrayList(obj.arguments.size());
-            
-            for (Iterator i = obj.arguments.iterator(); i.hasNext();)
-                arguments.add(new String(i.next().toString()));
-        }
+		if (arguments.size() &gt; 0)
+		{
+			for (int i = 0; i &lt; arguments.size(); i++)
+				length += FSCoder.strlen((String) arguments.get(i), true);
+		}
 
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-    }    
-    
-    /** Adds the name of an argument to the array of argument names.
+		length += 2;
 
-        @param anArgument the name of an argument passed to the FSNewFunction object.
-        */
-    public void add(String anArgument)
-    {
-        arguments.add(anArgument); 
-    }
+		actionsLength = 0;
 
-    /** Adds the action object to the array of actions.
+		for (int i = 0; i &lt; actions.size(); i++)
+		{
+			FSActionObject currentAction = (FSActionObject) actions.get(i);
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        actions.add(anAction);
-    }
+			actionsLength += currentAction.length(coder);
+			actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
+		length += actionsLength;
 
-    /** Gets the name of the function.
+		return length;
+	}
 
-        @return the name of the function.
-        */
-    public String getName() 
-    {
-        return name;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(type, 1);
+		coder.writeWord(length - actionsLength, 2);
 
-    /** Gets the names of the function arguments.
+		if (name != null)
+			coder.writeString(name);
 
-        @return the array of argument names.
-        */
-    public ArrayList getArguments() 
-    {
-        return arguments;
-    }
+		coder.writeWord(0, 1);
 
-    /** Gets the actions.
+		coder.writeWord(arguments.size(), 2);
 
-        @return the array of actions executed.
-        */
-    public ArrayList getActions() 
-    {
-        return actions;
-    }
+		if (arguments.size() &gt; 0)
+		{
+			for (int i = 0; i &lt; arguments.size(); i++)
+			{
+				coder.writeString((String) arguments.get(i));
+				coder.writeWord(0, 1);
+			}
+		}
 
-    /** Sets the name of the function.
+		coder.writeWord(actionsLength, 2);
 
-        @param aString the name of the function.
-        */
-    public void setName(String aString) 
-    {
-        name = aString;
-    }
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
 
-    /** Sets the names of the function arguments. 
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
 
-        @param anArray an array of Strings listing the names of the arguments.
-        */
-    public void setArguments(ArrayList anArray) 
-    {
-        arguments = anArray;
-    }
+			action.encode(coder);
+			coder.setPointer(next);
 
-    /** Sets the actions.
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        @param anArray the array of actions that define the operation performed by the function.
-        */
-    public void setActions(ArrayList anArray) 
-    {
-        actions = anArray;
-    }
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
+	}
 
-    public Object clone()
-    {
-        FSNewFunction anObject = (FSNewFunction)super.clone();
-        
-         anObject.arguments = new ArrayList();
-            
-        for (Iterator i = arguments.iterator(); i.hasNext();)
-            anObject.arguments.add(new String((String)i.next()));
+	public void decode(FSCoder coder)
+	{
+		int argumentCount = 0;
+		int bytesRead = 0;
 
-        anObject.actions = new ArrayList();
-            
-        for (Iterator i = actions.iterator(); i.hasNext();)
-            anObject.actions.add(((FSActionObject)i.next()).clone());
+		arguments = new ArrayList();
+		actions = new ArrayList();
 
-        return anObject;
-    }
+		super.decode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSNewFunction typedObject = (FSNewFunction)anObject;
-            
-            if (name != null)
-                result = name.equals(typedObject.name);
-            else
-                result = name == typedObject.name;
+		name = coder.readString();
 
-            if (arguments != null)
-                result = result &amp;&amp; arguments.equals(typedObject.arguments);
-            else
-                result = result &amp;&amp; arguments == typedObject.arguments;
+		argumentCount = coder.readWord(2, false);
 
-            if (actions != null)
-                result = result &amp;&amp; actions.equals(typedObject.actions);
-            else
-                result = result &amp;&amp; actions == typedObject.actions;
-        }
-        return result;
-    }
+		if (argumentCount &gt; 0)
+		{
+			for (int i = argumentCount; i &gt; 0; i--)
+				arguments.add(coder.readString());
+		}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;name&quot;, name);        
-            Transform.append(buffer, &quot;arguments&quot;, arguments, depth);
-            Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		actionsLength = coder.readWord(2, false);
+		length += actionsLength;
 
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += (name != null) ? coder.strlen(name, true) : 1;
-        length += 2;
-        
-        if (arguments.size() &gt; 0)
-        {
-            for (int i=0; i&lt;arguments.size(); i++)
-                length += coder.strlen((String)arguments.get(i), true);
-        }
+		while (bytesRead &lt; actionsLength)
+		{
+			FSActionObject anAction = FSActionObject.decodeAction(coder);
 
-        length += 2;
-        
-        actionsLength = 0;
-
-        for (int i=0; i&lt;actions.size(); i++)
-        {
-            FSActionObject currentAction = (FSActionObject)actions.get(i);
-            
-            actionsLength += currentAction.length(coder);
-            actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        length += actionsLength;
-        
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.beginObject(name());
-
-        coder.writeWord(type, 1);
-        coder.writeWord(length - actionsLength, 2);
-
-        if (name != null)
-            coder.writeString(name);
-
-        coder.writeWord(0, 1);
-
-        coder.writeWord(arguments.size(), 2);
-
-        if (arguments.size() &gt; 0)
-        {
-            for (int i=0; i&lt;arguments.size(); i++)
-            {
-                coder.writeString((String)arguments.get(i));
-                coder.writeWord(0, 1);
-            }
-        }
-        
-        coder.writeWord(actionsLength, 2);
-        
-        for (Iterator i=actions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-                
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int argumentCount = 0;
-        int bytesRead = 0;
-        
-        arguments = new ArrayList();
-        actions = new ArrayList();
-
-        super.decode(coder);
-
-        name = coder.readString();
-        
-        argumentCount = coder.readWord(2, false);
-        
-        if (argumentCount &gt; 0)
-        {
-            for (int i=argumentCount; i&gt;0; i--)
-                arguments.add(coder.readString());
-        }
-            
-        actionsLength = coder.readWord(2, false);
-        length += actionsLength;
-                
-        while (bytesRead &lt; actionsLength)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-            actions.add(anAction);
-        }
-
-        coder.endObject(name());
-    }
+			bytesRead += anAction.getLength()
+							+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+			actions.add(anAction);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSNewFunction2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSNewFunction2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSNewFunction2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,568 +33,661 @@
 import java.util.*;
 
 /**
-The FSNewFunction2 action is used to create a user-defined function. 
+ * The FSNewFunction2 action is used to create a user-defined function.
+ * 
+ * &lt;p&gt;
+ * It was added in Flash 7 to improve the performance of function calls by
+ * allowing variables to be pre-loaded to a set of up to 256 internal registers
+ * and controlling the loading of pre-defined variables such as &lt;em&gt;_root&lt;/em&gt;,
+ * &lt;em&gt;_parent&lt;/em&gt;, &lt;em&gt;_global&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt;, &lt;em&gt;this&lt;/em&gt;
+ * and the &lt;em&gt;arguments&lt;/em&gt; array containing the arguments passed to the
+ * function.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;A string defining the name of the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;registerCount&lt;/td&gt;
+ * &lt;td&gt;The number of registers, up to 256, to allocate for storing variables.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;optimizations&lt;/td&gt;
+ * &lt;td&gt;A code consisting of a number of flags that control the execution
+ * environment for the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;arguments&lt;/td&gt;
+ * &lt;td&gt;An array of FSRegisterVariable objects containing the names of the
+ * arguments and whether they will be assigned to internal registers or defined
+ * in memory as local variables. The order of the FSRegisterVariable objects in
+ * the argument array indicate the order in which the values will be popped off
+ * the stack when the function is executed. The fist argument is popped from the
+ * stack first.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The optimisation attribute is a compound code, containing a number of flags
+ * that control how the environment of the function is initialised. Controlling
+ * the pre-defined variables that are created and pre-loading them into
+ * registers can significantly improve performance.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;CreateSuper&lt;/td&gt;
+ * &lt;td&gt;Create and initialise the &lt;em&gt;super&lt;/em&gt; variable with the parent
+ * class of the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;CreateArguments&lt;/td&gt;
+ * &lt;td&gt;Create the &lt;em&gt;arguments&lt;/em&gt; variable which contains the arguments
+ * passed to the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;CreateThis&lt;/td&gt;
+ * &lt;td&gt;Create the and initialise the &lt;em&gt;this&lt;/em&gt; variable with the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadThis&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;this&lt;/em&gt; variable into register number 1.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadArguments&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;parent&lt;/em&gt; variable into register number 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadSuper&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;super&lt;/em&gt; variable into register number 3.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadRoot&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;_root&lt;/em&gt; variable into register number 4.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadParent&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;_parent&lt;/em&gt; variable into register number 5.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadGlobal&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;_global&lt;/em&gt; variable into register number 5.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The register numbers that the predefined variables, &lt;em&gt;this&lt;/em&gt;,
+ * &lt;em&gt;parent&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt;, &lt;em&gt;_root&lt;/em&gt;, &lt;em&gt;_parent&lt;/em&gt;
+ * and &lt;em&gt;_global&lt;/em&gt; are assigned to are fixed. When specifying which of
+ * the functions arguments are also assigned to registers it is important avoid
+ * these locations otherwise the variables will be overwritten.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * User-defined functions are also used to create methods for user-defined
+ * objects. The name of the function is omitted and the function definition is
+ * assigned to a variable which allows it to be referenced at a alter time. See
+ * the example below.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The arguments supplied to the function can be referenced by the name supplied
+ * in the arguments array.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * All the action objects added are owned by the function. They will be deleted
+ * when the function definition is deleted.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Define a function&lt;br/&gt; Define a function that increments the value passed
+ * to it:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // List the names of the arguments
+ * 
+ * ArrayList arguments = new ArrayList();
+ * 
+ * arguments.add(&quot;value&quot;);
+ * 
+ * // Now define the actions performed by the function. Values passed to the function
+ * // can be referenced by the name defined in the array of arguments.
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(new FSPush(&quot;value&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(1));
+ * actions.add(FSAction.Add());
+ * actions.add(FSAction.Return());
+ * actions.add(new FSNewFunction2(&quot;increment&quot;, arguments, actions));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be referenced using it's name:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(1));
+ * actions.add(new FSPush(&quot;increment&quot;));
+ * actions.add(FSAction.ExecuteFunction());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Defining a method.&lt;br/&gt; When creating a user-defined object the name of
+ * the function can be omitted. Simply assign the function definition to a
+ * variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  actions.add(new FSPush(methodVariable));
+ * 
+ *  FSVector&lt;FSString&gt; arguments;
+ * 
+ *  arguments.push_back(&quot;value&quot;);
+ * 
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;value&quot;));
+ *  actions.add(FSAction.GetVariable());
+ *  actions.add(new FSPush(1));
+ *  actions.add(FSAction.Add());
+ *  actions.add(FSAction.Return());
+ *  actions.add(new FSNewFunction2(arguments, actions));
+ *  actions.add(FSAction.SetVariable()));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be executed by pushing the arguments onto the stack
+ * then calling the function assigned to the variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push argument(s) onto stack
+ * 
+ * actions.add(new FSPush(1));
+ * 
+ * // Get the variable that contains the function
+ * 
+ * actions.add(new FSPush(methodVariable));
+ * actions.add(FSAction.GetVariable());
+ * 
+ * // Execute the function
+ * actions.add(FSAction.ExecuteMethod());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Controlling the execution environment.&lt;br/&gt; The code that defines the
+ * optimizations that improve execution performance is created by bitwise-ORing
+ * the individual flags together.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int optimizations = FSNewFunction2.CreateSuper | FSNewFunction2.PreloadSuper;
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSNewFunction class represents the ActionDefineFunction2 action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 7.
+ * &lt;/p&gt;
+ */
+public class FSNewFunction2 extends FSActionObject
+{
+	/** Create and initialized the predefined variable, &lt;em&gt;super&lt;/em&gt;. */
+	public static final int CreateSuper = 4;
 
-&lt;p&gt;It was added in Flash 7 to improve the performance of function calls by allowing 
-variables to be pre-loaded to a set of up to 256 internal registers and controlling 
-the loading of pre-defined variables such as &lt;em&gt;_root&lt;/em&gt;, &lt;em&gt;_parent&lt;/em&gt;, 
-&lt;em&gt;_global&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt;, &lt;em&gt;this&lt;/em&gt; and the &lt;em&gt;arguments&lt;/em&gt; array 
-containing the arguments passed to the function.&lt;/p&gt;
+	/** Create and initialized the predefined variable, &lt;em&gt;arguments&lt;/em&gt;. */
+	public static final int CreateArguments = 16;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Create and initialized the predefined variable, &lt;em&gt;this&lt;/em&gt;. */
+	public static final int CreateThis = 64;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;this&lt;/em&gt;, into register 1. */
+	public static final int LoadThis = 128;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_1&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A string defining the name of the function.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;arguments&lt;/em&gt;, into register 2. */
+	public static final int LoadArguments = 32;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_2&quot;&gt;registerCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of registers, up to 256, to allocate for storing variables.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;super&lt;/em&gt;, into register 3. */
+	public static final int LoadSuper = 8;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_3&quot;&gt;optimizations&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A code consisting of a number of flags that control the execution environment 
-for the function.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;_root&lt;/em&gt;, into register 4. */
+	public static final int LoadRoot = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_4&quot;&gt;arguments&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSRegisterVariable objects containing the names of the arguments 
-and whether they will be assigned to internal registers or defined in memory as 
-local variables. The order of the FSRegisterVariable objects in the argument 
-array indicate the order in which the values will be popped off the stack when 
-the function is executed. The fist argument is popped from the stack first.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;_parent&lt;/em&gt;, into register 5. */
+	public static final int LoadParent = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_5&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;_global&lt;/em&gt;, into register 6. */
+	public static final int LoadGlobal = 32768;
 
-&lt;/table&gt;
+	private String name = null;
+	private int registerCount = 0;
+	private int optimizations = 0;
 
-&lt;p&gt;The optimisation attribute is a compound code, containing a number of flags that 
-control how the environment of the function is initialised. Controlling the pre-defined 
-variables that are created and pre-loading them into registers can significantly 
-improve performance.&lt;/p&gt;
+	private ArrayList&lt;FSRegisterVariable&gt; arguments = null;
+	private ArrayList&lt;FSActionObject&gt; actions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;
-&lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
-&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
-&lt;/tr&gt;
+	/*
+	 * variables used to record state when encoding.
+	 */
+	private int _actionsLength = 0;
 
-&lt;tr&gt;&lt;td&gt;CreateSuper&lt;/td&gt;&lt;td&gt;Create and initialise the &lt;em&gt;super&lt;/em&gt; variable with the parent class of the function.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;CreateArguments&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Create the &lt;em&gt;arguments&lt;/em&gt; variable which contains the arguments passed to the function.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;CreateThis&lt;/td&gt;&lt;td&gt;Create the and initialise the &lt;em&gt;this&lt;/em&gt; variable with the object.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadThis&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;this&lt;/em&gt; variable into register number 1.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadArguments&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;parent&lt;/em&gt; variable into register number 2.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadSuper&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;super&lt;/em&gt; variable into register number 3.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadRoot&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;_root&lt;/em&gt; variable into register number 4.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadParent&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;_parent&lt;/em&gt; variable into register number 5.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadGlobal&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;_global&lt;/em&gt; variable into register number 5.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Construct an FSNewFunction2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSNewFunction2(FSCoder coder)
+	{
+		super(NewFunction2);
+		decode(coder);
+	}
 
-&lt;p&gt;The register numbers that the predefined variables, &lt;em&gt;this&lt;/em&gt;, &lt;em&gt;parent&lt;/em&gt;, 
-&lt;em&gt;super&lt;/em&gt;, &lt;em&gt;_root&lt;/em&gt;, &lt;em&gt;_parent&lt;/em&gt; and &lt;em&gt;_global&lt;/em&gt; are assigned 
-to are fixed. When specifying which of the functions arguments are also assigned 
-to registers it is important avoid these locations otherwise the variables will 
-be overwritten.&lt;/p&gt;
+	/**
+	 * Constructs an FSNewFunction with the specified name, argument names and
+	 * actions to be executed. The order of the Strings in the argument array
+	 * indicate the order in which the values will be popped off the stack when
+	 * the function is executed. The first argument is popped from the stack
+	 * first.
+	 * 
+	 * @param name
+	 *            the name of the function.
+	 * @param arguments
+	 *            an array of FSRegisterVariable objects listing the names of the 
+	 *            arguments and the registers they are assigned to.
+	 * @param actions
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction2(String name, ArrayList&lt;FSRegisterVariable&gt; arguments, ArrayList&lt;FSActionObject&gt; actions)
+	{
+		super(NewFunction2);
+		setName(name);
+		setArguments(arguments);
+		setActions(actions);
+	}
 
-&lt;p&gt;User-defined functions are also used to create methods for user-defined objects. 
-The name of the function is omitted and the function definition is assigned to a 
-variable which allows it to be referenced at a alter time. See the example below.&lt;/p&gt;
+	/**
+	 * Constructs an anonymous FSNewFunction with the specified argument names
+	 * and actions to be executed. Use this constructor when defining functions
+	 * that will be assigned to object variables and used as methods.
+	 * 
+	 * @param arguments
+	 *            an array of FSRegisterVariable objects listing the names of the 
+	 *            arguments and the registers they are assigned to.
+	 * @param actions
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction2(ArrayList&lt;FSRegisterVariable&gt; arguments, ArrayList&lt;FSActionObject&gt; actions)
+	{
+		super(NewFunction2);
+		setArguments(arguments);
+		setActions(actions);
+	}
 
-&lt;p&gt;The arguments supplied to the function can be referenced by the name supplied 
-in the arguments array.&lt;/p&gt;
+	/**
+	 * Constructs an FSNewFunction2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSNewFunction2 object.
+	 */
+	public FSNewFunction2(FSNewFunction2 obj)
+	{
+		super(obj);
 
-&lt;p&gt;All the action objects added are owned by the function. They will be deleted 
-when the function definition is deleted.&lt;/p&gt;
+		if (obj.name != null)
+			name = new String(obj.name);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		registerCount = obj.registerCount;
+		optimizations = obj.optimizations;
 
-&lt;p&gt;1. Define a function&lt;br/&gt;
-Define a function that increments the value passed to it:&lt;/p&gt;
+		if (obj.arguments != null)
+		{
+			arguments = new ArrayList&lt;FSRegisterVariable&gt;(obj.arguments.size());
 
-&lt;pre&gt;
-// List the names of the arguments
+			for (Iterator&lt;FSRegisterVariable&gt; i = obj.arguments.iterator(); i.hasNext();)
+				arguments.add(new FSRegisterVariable(i.next()));
+		}
 
-ArrayList arguments = new ArrayList();
+		if (obj.actions != null)
+		{
+			actions = new ArrayList&lt;FSActionObject&gt;(obj.actions.size());
 
-arguments.add(&quot;value&quot;);
+			for (Iterator&lt;FSActionObject&gt; i = obj.actions.iterator(); i.hasNext();)
+				actions.add((FSActionObject)i.next().clone());
+		}
+	}
 
-// Now define the actions performed by the function. Values passed to the function
-// can be referenced by the name defined in the array of arguments.
+	/**
+	 * Adds the name of an argument to the array of argument names.
+	 * 
+	 * @param anArgument
+	 *            the name of an argument passed to the FSNewFunction object.
+	 */
+	public void add(FSRegisterVariable anArgument)
+	{
+		arguments.add(anArgument);
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		actions.add(anAction);
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction2(&quot;increment&quot;, arguments, actions));
-&lt;/pre&gt;
+	/**
+	 * Gets the name of the function.
+	 * 
+	 * @return the name of the function.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-&lt;p&gt;The function can then be referenced using it's name:&lt;/p&gt;
+	/**
+	 * Sets the name of the function. The name may be null when defining
+	 * methods.
+	 * 
+	 * @param aString
+	 *            the name of the function or null for a method.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(1));
-actions.add(new FSPush(&quot;increment&quot;));
-actions.add(FSAction.ExecuteFunction());
-&lt;/pre&gt;
+	/**
+	 * Gets the number of registers to allocate for function variables.
+	 * 
+	 * @return the number of registers to allocate.
+	 */
+	public int getRegisterCount()
+	{
+		return registerCount;
+	}
 
-&lt;p&gt;2. Defining a method.&lt;br/&gt;
-When creating a user-defined object the name of the function can be omitted. 
-Simply assign the function definition to a variable:&lt;/p&gt;
+	/**
+	 * Sets the number of registers to allocate for function variables. Up to
+	 * 256 registers may be allocated for each function.
+	 * 
+	 * @param count
+	 *            the number of registers to allocate.
+	 */
+	public void setRegisterCount(int count)
+	{
+		registerCount = count;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(methodVariable));
+	/**
+	 * Get the code containing the compound flags that control the execution
+	 * environment of the function or method.
+	 * 
+	 * @return the code for the optimizations.
+	 */
+	public int getOptimizations()
+	{
+		return optimizations;
+	}
 
-FSVector&lt;FSString&gt; arguments;
+	/**
+	 * Set the code containing the compound flags that control the execution
+	 * environment of the function or method.
+	 * 
+	 * @param code
+	 *            the compound code can be created by bitwise-ORing the
+	 *            constants that identify the optimizations performed.
+	 */
+	public void setOptimizations(int code)
+	{
+		optimizations = code;
+	}
 
-arguments.push_back(&quot;value&quot;);
+	/**
+	 * Gets the array of FSRegisterVariables that define the function arguments
+	 * and whether they are assigned to internal registers or to local variables
+	 * in memory.
+	 * 
+	 * @return the array of FSRegisterVariables that define the functions
+	 *         arguments.
+	 */
+	public ArrayList&lt;FSRegisterVariable&gt; getArguments()
+	{
+		return arguments;
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Sets the array of FSRegisterVariables that define the function arguments
+	 * and whether they are assigned to internal registers or to local variables
+	 * in memory.
+	 * 
+	 * @param anArray
+	 *            an array of Strings listing the names of the arguments.
+	 */
+	public void setArguments(ArrayList&lt;FSRegisterVariable&gt; anArray)
+	{
+		arguments = anArray;
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction2(arguments, actions));
-actions.add(FSAction.SetVariable()));
-&lt;/pre&gt;
+	/**
+	 * Gets the actions executed by the function.
+	 * 
+	 * @return the array of actions executed.
+	 */
+	public ArrayList&lt;FSActionObject&gt; getActions()
+	{
+		return actions;
+	}
 
-&lt;p&gt;The function can then be executed by pushing the arguments onto the stack 
-then calling the function assigned to the variable:&lt;/p&gt;
+	/**
+	 * Sets the actions.
+	 * 
+	 * @param anArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public void setActions(ArrayList&lt;FSActionObject&gt; anArray)
+	{
+		actions = anArray;
+	}
 
-&lt;pre&gt;
-// Push argument(s) onto stack
+	public Object clone()
+	{
+		FSNewFunction2 anObject = (FSNewFunction2) super.clone();
 
-actions.add(new FSPush(1));
+		anObject.arguments = new ArrayList&lt;FSRegisterVariable&gt;();
 
-// Get the variable that contains the function
+		for (Iterator&lt;FSRegisterVariable&gt; i = arguments.iterator(); i.hasNext();)
+			anObject.arguments.add(new FSRegisterVariable(i.next()));
 
-actions.add(new FSPush(methodVariable));
-actions.add(FSAction.GetVariable());
+		anObject.actions = new ArrayList&lt;FSActionObject&gt;();
 
-// Execute the function
-actions.add(FSAction.ExecuteMethod());
-&lt;/pre&gt;
+		for (Iterator&lt;FSActionObject&gt; i = actions.iterator(); i.hasNext();)
+			anObject.actions.add((FSActionObject)i.next().clone());
 
-&lt;p&gt;3. Controlling the execution environment.&lt;br/&gt;
-The code that defines the optimizations that improve execution performance is 
-created by bitwise-ORing the individual flags together.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;pre&gt; 
-int optimizations = FSNewFunction2.CreateSuper |  FSNewFunction2.PreloadSuper;
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSNewFunction2 typedObject = (FSNewFunction2) anObject;
 
-&lt;p&gt;The FSNewFunction class represents the ActionDefineFunction2 action of the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSNewFunction2 extends FSActionObject
-{
-/** Create and initialized the predefined variable, &lt;em&gt;super&lt;/em&gt;. */
-    public static final int CreateSuper = 4;
-/** Create and initialized the predefined variable, &lt;em&gt;arguments&lt;/em&gt;. */
-    public static final int CreateArguments = 16;
-/** Create and initialized the predefined variable, &lt;em&gt;this&lt;/em&gt;. */
-    public static final int CreateThis = 64;
+			if (name != null)
+				result = name.equals(typedObject.name);
+			else
+				result = name == typedObject.name;
 
-/** Load the predefine variable, &lt;em&gt;this&lt;/em&gt;, into register 1. */
-    public static final int LoadThis = 128;
-/** Load the predefine variable, &lt;em&gt;arguments&lt;/em&gt;, into register 2. */
-    public static final int LoadArguments = 32;
-/** Load the predefine variable, &lt;em&gt;super&lt;/em&gt;, into register 3. */
-    public static final int LoadSuper = 8;
-/** Load the predefine variable, &lt;em&gt;_root&lt;/em&gt;, into register 4. */
-    public static final int LoadRoot = 2;
-/** Load the predefine variable, &lt;em&gt;_parent&lt;/em&gt;, into register 5. */
-    public static final int LoadParent = 1;
-/** Load the predefine variable, &lt;em&gt;_global&lt;/em&gt;, into register 6. */
-    public static final int LoadGlobal = 32768;
-    
-    private String name = null;
-    
-    private int registerCount = 0;
-    private int optimizations = 0;
-    
-    private ArrayList arguments = null;
-    private ArrayList actions = null;
-    
-    /*
-     * variables used to record state when encoding.
-     */
-    private int _actionsLength = 0;
+			result = result &amp;&amp; registerCount == typedObject.registerCount;
+			result = result &amp;&amp; optimizations == typedObject.optimizations;
 
-    /**
-     * Construct an FSNewFunction2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSNewFunction2(FSCoder coder)
-    {
-        super(NewFunction2);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSNewFunction with the specified name, argument names and actions to 
-     * be executed. The order of the Strings in the argument array indicate the order in 
-     * which the values will be popped off the stack when the function is executed. The 
-     * first argument is popped from the stack first.
+			if (arguments != null)
+				result = result &amp;&amp; arguments.equals(typedObject.arguments);
+			else
+				result = result &amp;&amp; arguments == typedObject.arguments;
 
-        @param name the name of the function.
-        @param arguments an array of Strings listing the names of the arguments.
-        @param actions the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction2(String name, ArrayList arguments, ArrayList actions)
-    {
-        super(NewFunction2);
-        setName(name);
-        setArguments(arguments);
-        setActions(actions);
-    }
-    /** 
-     * Constructs an anonymous FSNewFunction with the specified argument names and actions 
-     * to be executed. Use this constructor when defining functions that will be assigned 
-     * to object variables and used as methods.
+			if (actions != null)
+				result = result &amp;&amp; actions.equals(typedObject.actions);
+			else
+				result = result &amp;&amp; actions == typedObject.actions;
+		}
+		return result;
+	}
 
-        @param arguments an array of Strings listing the names of the arguments.
-        @param actions the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction2(ArrayList arguments, ArrayList actions)
-    {
-        super(NewFunction2);
-        setArguments(arguments);
-        setActions(actions);
-    }
-    /**
-     * Constructs an FSNewFunction2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSNewFunction2 object.
-     */
-    public FSNewFunction2(FSNewFunction2 obj)
-    {
-        super(obj);
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        if (obj.name != null)
-            name = new String(obj.name);
-        
-        registerCount = obj.registerCount;
-        optimizations = obj.optimizations;
-        
-        if (obj.arguments != null)
-        {
-            arguments = new ArrayList(obj.arguments.size());
-            
-            for (Iterator i = obj.arguments.iterator(); i.hasNext();)
-                arguments.add(new String(i.next().toString()));
-        }
+		buffer.append(&quot;FSNewFunction2: { &quot;);
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
+		buffer.append(&quot;registerCount = &quot;).append(registerCount).append(&quot;; &quot;);
+		buffer.append(&quot;optimizations = &quot;).append(optimizations).append(&quot;; &quot;);
+		buffer.append(&quot;arguments = &quot;).append(arguments.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;actions = array[&quot;).append(actions.size()).append(&quot;]; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-    }    
+		return buffer.toString();
+	}
 
-    /** Adds the name of an argument to the array of argument names.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anArgument the name of an argument passed to the FSNewFunction object.
-        */
-    public void add(FSRegisterVariable anArgument)
-    {
-        arguments.add(anArgument); 
-    }
+		length += (name != null) ? FSCoder.strlen(name, true) : 1;
+		length += 5;
 
-    /** Adds the action object to the array of actions.
+		for (int i = 0; i &lt; arguments.size(); i++)
+			length += arguments.get(i).length(coder);
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        actions.add(anAction);
-    }
+		length += 2;
 
-    /** Gets the name of the function.
+		_actionsLength = 0;
 
-        @return the name of the function.
-        */
-    public String getName() 
-    {
-        return name;
-    }
-    
-    /** Sets the name of the function. The name may be null when defining methods.
+		FSActionObject currentAction;
 
-        @param aString the name of the function or null for a method.
-        */
-    public void setName(String aString) 
-    {
-        name = aString;
-    }
+		for (Iterator&lt;FSActionObject&gt; i = actions.iterator(); i.hasNext();)
+		{
+			currentAction =  i.next();
 
-    /** 
-     * Gets the number of registers to allocate for function variables.
-     * 
-     * @return the number of registers to allocate.
-     */
-    public int getRegisterCount()
-    {
-        return registerCount;
-    }
-    
-    /**
-     * Sets the number of registers to allocate for function variables. Up to
-     * 256 registers may be allocated for each function.
-     * 
-     * @param count the number of registers to allocate.
-     */
-    public void setRegisterCount(int count)
-    {
-        registerCount = count;
-    }
+			_actionsLength += currentAction.length(coder);
+			_actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
+		length += _actionsLength;
 
-    /** 
-     * Get the code containing the compound flags that control the execution environment
-     * of the function or method.
-     *
-     * @return the code for the optimizations.
-     */
-    public int getOptimizations()
-    {
-        return optimizations;
-    }
-    
-    /** 
-     * Set the code containing the compound flags that control the execution environment
-     * of the function or method.
-     *
-     * @param code the compound code can be created by bitwise-ORing the constants that 
-     * identify the optimizations performed.
-     */
-    public void setOptimizations(int code)
-    {
-        optimizations = code;
-    }
+		return length;
+	}
 
-    /** 
-     * Gets the array of FSRegisterVariables that define the function arguments and whether
-     * they are assigned to internal registers or to local variables in memory.
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(type, 1);
+		coder.writeWord(length - _actionsLength, 2);
 
-        @return the array of FSRegisterVariables that define the functions arguments.
-        */
-    public ArrayList getArguments() 
-    {
-        return arguments;
-    }
+		if (name != null)
+			coder.writeString(name);
 
-    /**
-     * Sets the array of FSRegisterVariables that define the function arguments and whether
-     * they are assigned to internal registers or to local variables in memory.
-     *
-     * @param anArray an array of Strings listing the names of the arguments.
-     */
-    public void setArguments(ArrayList anArray) 
-    {
-        arguments = anArray;
-    }
+		coder.writeWord(0, 1);
 
-    /** Gets the actions executed by the function.
+		coder.writeWord(arguments.size(), 2);
+		coder.writeWord(registerCount, 1);
+		coder.writeBits(optimizations, 16);
 
-        @return the array of actions executed.
-        */
-    public ArrayList getActions() 
-    {
-        return actions;
-    }
+		for (Iterator&lt;FSRegisterVariable&gt; i=arguments.iterator(); i.hasNext();)
+			i.next().encode(coder);
 
-    /** Sets the actions.
+		coder.writeWord(_actionsLength, 2);
 
-        @param anArray the array of actions that define the operation performed by the function.
-        */
-    public void setActions(ArrayList anArray) 
-    {
-        actions = anArray;
-    }
+		for (Iterator&lt;FSActionObject&gt; i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
 
-    public Object clone()
-    {
-        FSNewFunction2 anObject = (FSNewFunction2)super.clone();
-        
-         anObject.arguments = new ArrayList();
-            
-        for (Iterator i = arguments.iterator(); i.hasNext();)
-            anObject.arguments.add((FSRegisterVariable)((FSRegisterVariable)i.next()).clone());
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
 
-        anObject.actions = new ArrayList();
-            
-        for (Iterator i = actions.iterator(); i.hasNext();)
-            anObject.actions.add(((FSActionObject)i.next()).clone());
+			action.encode(coder);
+			coder.setPointer(next);
 
-        return anObject;
-    }
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSNewFunction2 typedObject = (FSNewFunction2)anObject;
-            
-            if (name != null)
-                result = name.equals(typedObject.name);
-            else
-                result = name == typedObject.name;
-                
-            result = result &amp;&amp; registerCount == typedObject.registerCount;
-            result = result &amp;&amp; optimizations == typedObject.optimizations;
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
+	}
 
-            if (arguments != null)
-                result = result &amp;&amp; arguments.equals(typedObject.arguments);
-            else
-                result = result &amp;&amp; arguments == typedObject.arguments;
+	public void decode(FSCoder coder)
+	{
+		int argumentCount = 0;
+		int bytesRead = 0;
 
-            if (actions != null)
-                result = result &amp;&amp; actions.equals(typedObject.actions);
-            else
-                result = result &amp;&amp; actions == typedObject.actions;
-        }
-        return result;
-    }
+		arguments = new ArrayList&lt;FSRegisterVariable&gt;();
+		actions = new ArrayList&lt;FSActionObject&gt;();
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;name&quot;, name);        
-            Transform.append(buffer, &quot;registerCount&quot;, registerCount);
-            Transform.append(buffer, &quot;optimizations&quot;, optimizations);
-            Transform.append(buffer, &quot;arguments&quot;, arguments, depth);
-            Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		super.decode(coder);
 
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += (name != null) ? coder.strlen(name, true) : 1;
-        length += 5;
-        
-        for (int i=0; i&lt;arguments.size(); i++)
-            length += ((FSRegisterVariable)arguments.get(i)).length(coder);
-        
-        length += 2;
-        
-        _actionsLength = 0;
+		name = coder.readString();
+		argumentCount = coder.readWord(2, false);
+		registerCount = coder.readByte();
+		optimizations = coder.readBits(16, false);
 
-        for (Iterator i = actions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            _actionsLength += currentAction.length(coder);
-            _actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        length += _actionsLength;
-        
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.beginObject(name());
+		for (int i = 0; i &lt; argumentCount; i++)
+			arguments.add(new FSRegisterVariable(coder));
 
-        coder.writeWord(type, 1);
-        coder.writeWord(length - _actionsLength, 2);
+		_actionsLength = coder.readWord(2, false);
+		length += _actionsLength;
 
-        if (name != null)
-            coder.writeString(name);
+		while (bytesRead &lt; _actionsLength)
+		{
+			FSActionObject anAction = FSActionObject.decodeAction(coder);
 
-        coder.writeWord(0, 1);
-
-        coder.writeWord(arguments.size(), 2);
-        coder.writeWord(registerCount, 1);
-        coder.writeBits(optimizations, 16);
-
-        for (Iterator i = arguments.iterator(); i.hasNext();)
-            ((FSRegisterVariable)i.next()).encode(coder);
-
-        coder.writeWord(_actionsLength, 2);
-           
-        for (Iterator i=actions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-                
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
-
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int argumentCount = 0;
-        int bytesRead = 0;
-        
-        arguments = new ArrayList();
-        actions = new ArrayList();
-
-        super.decode(coder);
-
-        name = coder.readString();
-        
-        argumentCount = coder.readWord(2, false);
-        registerCount = coder.readWord(1, false);
-        optimizations = coder.readBits(16, false);
-        
-        for (int i=0; i&lt;argumentCount; i++)
-            arguments.add(new FSRegisterVariable(coder));
-
-        _actionsLength = coder.readWord(2, false);
-        length += _actionsLength;
-        
-        while (bytesRead &lt; _actionsLength)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-            actions.add(anAction);
-        }
-
-        coder.endObject(name());
-    }
+			bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
+			actions.add(anAction);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,318 +31,431 @@
 package com.flagstone.transform;
 
 /**
-FSPlaceObject is used to add an object (shape, button, etc.) to the Flash Player's display list.
-  
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSPlaceObject is used to add an object (shape, button, etc.) to the Flash
+ * Player's display list.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier, in the range 1..65535, of the object to be
+ * displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The Display List layer on which the object is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;coordTransform&lt;/td&gt;
+ * &lt;td&gt;An FSCoordTransform which defines the location and appearance of the
+ * object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;An FSColorTransform which defines any changes to be made to the object's
+ * original colour. Optional. May be set to null if an object's colour is not
+ * being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Every class that defines a shape, button etc. is assigned a unique
+ * identifier. This is an integer in the range 1..65535 and is used to refer to
+ * objects when performing actions such as adding or removing them from the
+ * display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The display list contains all the objects that are currently visible on the
+ * Flash Player's screen. The display list is ordered in layers, with one (and
+ * only one) object displayed on each layer. The Layer defines the order in
+ * which objects are displayed. Objects with a higher layer number are displayed
+ * in front of objects on a lower layer.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The coordinate transform is principally used to specify the location of the
+ * object when it is drawn on the screen however more complex coordinate
+ * transforms can also be specified such as rotating or scaling the object
+ * without changing the original definition.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Similarly the color transform allows the color of the object to be changed
+ * when it is displayed without changing the original definition. The
+ * FSPlaceObject class only supports opaque colours so although the
+ * FSColorTransform supports transparent colours this information is ignored by
+ * the Flash Player. The colour transform is optional and may be set to the null
+ * object.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following simplified code fragments illustrate how the FSPlaceObject
+ * class can be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Display an object.&lt;br/&gt; Display an object on layer 1 at (400, 400).
+ * FSPlaceObject provides a constructor which specifies just the x and y
+ * coordinates, the FSCoordTransform object is constructed internally.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......)
+ * 
+ *  movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Scale an object.&lt;br/&gt; Scale an object to twice its original size by
+ * specifying a more complex coordinate transformation. Complex transforms can
+ * be created by compositing individual steps.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform location = FSCoordTransform.translate(200, 200);
+ * FSCoordTransform scale = FSCoordTransform.scale(2.0, 2.0);
+ * FSCoordTransform transform = FSCoordTransform.composite(location, scale);
+ * 
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, transform));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Move an object.&lt;br/&gt; To move an object the FSPlaceObject class must be
+ * used in conjunction with the FSRemoveObject class to first remove the object
+ * from its existing position before being placed at the new location.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Move shape to a new location, removing the original so it does not get displayed twice.
+ * movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPlaceObject class represents the PlaceObject tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1 and is
+ * superseded by the PlaceObject2 tag which was added in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSPlaceObject extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private int layer = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private FSCoordTransform transform = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier, in the range 1..65535, of the object to be displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	private FSColorTransform colorTransform = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The Display List layer on which the object is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSPlaceObject object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPlaceObject(FSCoder coder)
+	{
+		super(FSMovieObject.PlaceObject);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_3&quot;&gt;coordTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSCoordTransform which defines the location and appearance of the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject object that places an object with the
+	 * identifier into the display list layer at the specified coordinates
+	 * (x,y).
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 * @param aLayer
+	 *            the layer in the display list where the object will be placed.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be drawn.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be drawn.
+	 */
+	public FSPlaceObject(int anIdentifier, int aLayer, int xLocation,
+							int yLocation)
+	{
+		super(FSMovieObject.PlaceObject);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_4&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColorTransform which defines any changes to be made to the object's original colour. Optional. May be set to null if an object's colour is not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject object that places the object with the
+	 * identifier at the specified layer with the coordinate transform.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 * @param aLayer
+	 *            the layer in the display list where the object will be placed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that defines the orientation, size
+	 *            and location of the object when it is drawn.
+	 */
+	public FSPlaceObject(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform)
+	{
+		super(FSMovieObject.PlaceObject);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSPlaceObject object that places the the object with the
+	 * identifier at the specified layer, coordinate transform and colour
+	 * transform.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 * @param aLayer
+	 *            the layer in the display list where the object will be placed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that defines the orientation, size
+	 *            and location of the object when it is drawn.
+	 * @param aColorTransform
+	 *            an FSColorTransform object that defines the colour of the
+	 *            object when it is drawn.
+	 */
+	public FSPlaceObject(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform,
+							FSColorTransform aColorTransform)
+	{
+		super(FSMovieObject.PlaceObject);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(aColorTransform);
+	}
 
-&lt;p&gt;Every class that defines a shape, button etc. is assigned a unique identifier. This is an integer in the range 1..65535 and is used to refer to objects when performing actions such as adding or removing them from the display list.&lt;/p&gt;
+	/**
+	 * Constructs an FSPlaceObject object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSPlaceObject object.
+	 */
+	public FSPlaceObject(FSPlaceObject obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		layer = obj.layer;
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;p&gt;The display list contains all the objects that are currently visible on the Flash Player's screen. The display list is ordered in layers, with one (and only one) object displayed on each layer. The Layer defines the order in which objects are displayed. Objects with a higher layer number are displayed in front of objects on a lower layer.&lt;/p&gt;
+		if (obj.colorTransform != null)
+			colorTransform = new FSColorTransform(obj.colorTransform);
+	}
 
-&lt;p&gt;The coordinate transform is principally used to specify the location of the object when it is drawn on the screen however more complex coordinate transforms can also be specified such as rotating or scaling the object without changing the original definition.&lt;/p&gt;
+	/**
+	 * Gets the identifier of the object.
+	 * 
+	 * @return the identifier of the object being placed.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;p&gt;Similarly the color transform allows the color of the object to be changed when it is displayed without changing the original definition. The FSPlaceObject class only supports opaque colours so although the FSColorTransform supports transparent colours this information is ignored by the Flash Player. The colour transform is optional and may be set to the null object.&lt;/p&gt;
+	/**
+	 * Gets the layer that defines the order in which objects are displayed.
+	 * 
+	 * @return the layer on which the object will be displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the transform that defines the position where the object is
+	 * displayed.
+	 * 
+	 * @return the FSCoordTransform applied to the object when it is drawn.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;p&gt;The following simplified code fragments illustrate how the FSPlaceObject class can be used.&lt;/p&gt;
+	/**
+	 * Gets the colour transform that defines any colour effects applied when
+	 * the object is displayed.
+	 * 
+	 * @return the FSColorTransform applied to the object when it is drawn.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-&lt;p&gt;1. Display an object.&lt;br/&gt; 
-Display an object on layer 1 at (400, 400). FSPlaceObject provides a constructor which specifies just the x and y coordinates, the FSCoordTransform object is constructed internally.&lt;/p&gt;
+	/**
+	 * Sets the identifier of the object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......)
+	/**
+	 * Sets the layer that defines the order in which objects are displayed.
+	 * 
+	 * @param aNumber
+	 *            the layer in the display list where the object will be placed.
+	 */
+	public void setLayer(int aNumber)
+	{
+		layer = aNumber;
+	}
 
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+	/**
+	 * Sets the transform that defines the position where the object is
+	 * displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that defines the orientation, size
+	 *            and location of the object when it is drawn.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-&lt;p&gt;2. Scale an object.&lt;br/&gt;
-Scale an object to twice its original size by specifying a more complex coordinate transformation. Complex transforms can be created by compositing individual steps.&lt;/p&gt;
+	/**
+	 * Sets the colour transform that defines any colour effects applied when
+	 * the object is displayed.
+	 * 
+	 * @param aColorTransform
+	 *            an FSColorTransform object that defines the colour of the
+	 *            object when it is drawn.
+	 */
+	public void setColorTransform(FSColorTransform aColorTransform)
+	{
+		colorTransform = aColorTransform;
+	}
 
-&lt;pre&gt;
-FSCoordTransform location = FSCoordTransform.translate(200, 200);
-FSCoordTransform scale = FSCoordTransform.scale(2.0, 2.0);
-FSCoordTransform transform = FSCoordTransform.composite(location, scale);
+	public Object clone()
+	{
+		FSPlaceObject anObject = (FSPlaceObject) super.clone();
 
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, transform));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-&lt;p&gt;3. Move an object.&lt;br/&gt;
-To move an object the FSPlaceObject class must be used in conjunction with the FSRemoveObject class to first remove the object from its existing position before being placed at the new location.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-// Move shape to a new location, removing the original so it does not get displayed twice.
-movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSPlaceObject typedObject = (FSPlaceObject) anObject;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; layer == typedObject.layer;
 
-&lt;p&gt;The FSPlaceObject class represents the PlaceObject tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1 and is superseded by the PlaceObject2 tag which was added in Flash 3.&lt;/p&gt;
- */
-public class FSPlaceObject extends FSMovieObject
-{
-    private int identifier = 0;
-    private int layer = 0;
-    private FSCoordTransform transform = null;
-    private FSColorTransform colorTransform = null;
-        
-    /**
-     * Construct an FSPlaceObject object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPlaceObject(FSCoder coder)
-    {
-        super(FSMovieObject.PlaceObject);
-        decode(coder);
-    }
-    /** Constructs an FSPlaceObject object that places an object with the identifier into the display list layer at the specified coordinates (x,y).
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        @param aLayer the layer in the display list where the object will be placed.
-        @param xLocation the x-coordinate where the object will be drawn.
-        @param yLocation the y-coordinate where the object will be drawn.
-        */
-    public FSPlaceObject(int anIdentifier, int aLayer, int xLocation, int yLocation)
-    {
-        super(FSMovieObject.PlaceObject);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+			if (colorTransform == null)
+				result = result &amp;&amp; (typedObject.getColorTransform() == null);
+			else
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
+		}
+		return result;
+	}
 
-    /** Constructs an FSPlaceObject object that places the object with the identifier at the specified layer with the coordinate transform.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        @param aLayer the layer in the display list where the object will be placed.
-        @param aTransform an FSCoordTransform object that defines the orientation, size and location of the object when it is drawn.
-        */
-    public FSPlaceObject(int anIdentifier, int aLayer, FSCoordTransform aTransform)
-    {
-        super(FSMovieObject.PlaceObject);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-    }
+		buffer.append(&quot;FSPlaceObject: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;layer = &quot;).append(layer).append(&quot;; &quot;);
+		buffer.append(&quot;transform = &quot;).append(transform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;colorTransform = &quot;).append(colorTransform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Constructs an FSPlaceObject object that places the the object with the identifier at the specified layer, coordinate transform and colour transform.
+		return buffer.toString();
+	}
 
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        @param aLayer the layer in the display list where the object will be placed.
-        @param aTransform an FSCoordTransform object that defines the orientation, size and location of the object when it is drawn.
-        @param aColorTransform an FSColorTransform object that defines the colour of the object when it is drawn.
-        */
-    public FSPlaceObject(int anIdentifier, int aLayer, FSCoordTransform aTransform, FSColorTransform aColorTransform)
-    {
-        super(FSMovieObject.PlaceObject);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(aColorTransform);
-    }
-    /**
-     * Constructs an FSPlaceObject object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSPlaceObject object.
-     */
-    public FSPlaceObject(FSPlaceObject obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        layer = obj.layer;
-        transform = new FSCoordTransform(obj.transform);
-        
-        if (obj.colorTransform != null)
-            colorTransform = new FSColorTransform(obj.colorTransform);
-    }    
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 4;
+		length += transform.length(coder);
+		length += (colorTransform != null) ? colorTransform.length(coder) : 0;
 
-    /** Gets the identifier of the object.
+		return length;
+	}
 
-        @return the identifier of the object being placed.
-        */
-    public int getIdentifier() { return identifier; }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Gets the layer that defines the order in which objects are displayed.
+		coder.writeWord(identifier, 2);
+		coder.writeWord(layer, 2);
+		transform.encode(coder);
 
-        @return the layer on which the object will be displayed.
-        */
-    public int getLayer() { return layer; }
+		if (colorTransform != null)
+			colorTransform.encode(coder);
+	}
 
-    /** Gets the transform that defines the position where the object is displayed.
+	public void decode(FSCoder coder)
+	{
+		int lengthRead = coder.getPointer();
 
-        @return the FSCoordTransform applied to the object when it is drawn.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+		super.decode(coder);
 
-    /** Gets the colour transform that defines any colour effects applied when the object is displayed.
+		identifier = coder.readWord(2, false);
+		layer = coder.readWord(2, false);
+		transform = new FSCoordTransform(coder);
 
-        @return the FSColorTransform applied to the object when it is drawn.
-        */
-    public FSColorTransform getColorTransform() { return colorTransform; }
+		lengthRead = (coder.getPointer() - lengthRead) &gt;&gt; 3;
 
-    /** Sets the identifier of the object.
-
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-
-    /** Sets the layer that defines the order in which objects are displayed.
-
-        @param aNumber the layer in the display list where the object will be placed.
-        */
-    public void setLayer(int aNumber)
-    {
-        layer = aNumber;
-    }
-
-    /** Sets the transform that defines the position where the object is displayed.
-
-        @param aTransform an FSCoordTransform object that defines the orientation, size and location of the object when it is drawn.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
-
-    /** Sets the colour transform that defines any colour effects applied when the object is displayed.
-
-        @param aColorTransform an FSColorTransform object that defines the colour of the object when it is drawn.
-        */
-    public void setColorTransform(FSColorTransform aColorTransform)
-    {
-        colorTransform = aColorTransform;
-    }
-
-    public Object clone()
-    {
-        FSPlaceObject anObject = (FSPlaceObject)super.clone();
-        
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSPlaceObject typedObject = (FSPlaceObject)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; layer == typedObject.layer;
-
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
-
-            if (colorTransform == null)
-                result = result &amp;&amp; (typedObject.getColorTransform() == null);
-            else
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 4;
-        length += transform.length(coder);
-        length += (colorTransform != null) ? colorTransform.length(coder) : 0;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(identifier, 2);
-        coder.writeWord(layer, 2);
-        transform.encode(coder);
-        
-        if (colorTransform != null)
-            colorTransform.encode(coder);
-
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int lengthRead = coder.getPointer();
-        
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        layer = coder.readWord(2, false);
-        transform = new FSCoordTransform(coder);
-        
-        lengthRead = (coder.getPointer() - lengthRead) &gt;&gt; 3;
-        
-        if (length &gt; lengthRead)
-            colorTransform = new FSColorTransform(coder);
-
-        coder.endObject(name());
-    }
+		if (length &gt; lengthRead)
+			colorTransform = new FSColorTransform(coder);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSPlaceObject2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,1023 +33,1275 @@
 import java.util.*;
 
 /**
-FSPlaceObject2 is used to add and manipulate objects (shape, button, etc.) on the Flash 
-Player's display list. 
- 
-&lt;p&gt;FSPlaceObject2 supersedes the FSPlaceObject class providing more functionality and easier manipulation of  objects in the display list through the following operations:&lt;/p&gt;
+ * FSPlaceObject2 is used to add and manipulate objects (shape, button, etc.) on
+ * the Flash Player's display list.
+ * 
+ * &lt;p&gt;
+ * FSPlaceObject2 supersedes the FSPlaceObject class providing more
+ * functionality and easier manipulation of objects in the display list through
+ * the following operations:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;Place a new shape on the display list.&lt;/li&gt;
+ * &lt;li&gt;Change an existing shape by moving it to new location or changing its
+ * appearance.&lt;/li&gt;
+ * &lt;li&gt;Replace an existing shape with a another.&lt;/li&gt;
+ * &lt;li&gt;Define clipping layers to mask objects displayed in front of a shape.&lt;/li&gt;
+ * &lt;li&gt;Control the morphing process that changes one shape into another.&lt;/li&gt;
+ * &lt;li&gt;Assign names to objects rather than using their identifiers.&lt;/li&gt;
+ * &lt;li&gt;Define the sequence of actions that are executed when an event occurs in
+ * movie clip.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Clipping Depth&lt;/b&gt;&lt;br/&gt; With the introduction of Flash 3 the display
+ * list supported a clipping layer. This allowed the outline of an object to
+ * define a clipping path that is used to mask other objects placed in front of
+ * it. The clipping depth can be set to mask objects between the layer
+ * containing the clipping path and a specified layer.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&lt;b&gt;Shape Morphing&lt;/b&gt;&lt;br/&gt; Shapes that will be morphed are defined using
+ * the FSDefineMorphShape class which defines a start and end shape. The Flash
+ * Player performs the interpolation that transforms one shape into another. The
+ * progress of the morphing process is controlled by a ratio which ranges from
+ * 0.0 to 1.0, where 0 generates a shape identical to the starting shape in the
+ * FSDefineMorphShape object and 1.0 generates the shape at the end of the
+ * morphing process.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&lt;b&gt;Movie Clip Events&lt;/b&gt;&lt;br/&gt; With the introduction of Flash 5, movie
+ * clips (defined using the FSDefineMovieClip class) could specify sequences of
+ * actions that would be performed in response to mouse or keyboard events. The
+ * actions are specified using FSClipEvent objects and the FSPlaceObject2 class
+ * is used to register the actions in response to a particular event with the
+ * Flash player. Multiple events can be handled by defining an FSClipEvent for
+ * each type of event. For more information see the FSClipEvent class.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;place&lt;/td&gt;
+ * &lt;td&gt;Indicates whether a new object is being placed in the display list or an
+ * existing object is being modified or replaced.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the object to added to the display list.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;Defines the order in which objects are displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;Optional. A coordinate transform defines the position, scale and
+ * rotation of the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;Optional. A colour transform defines any colour changes such as
+ * transparency effects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;depth&lt;/td&gt;
+ * &lt;td&gt;Optional. The layer number up to which objects will be clipped by this
+ * object's outline.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;ratio&lt;/td&gt;
+ * &lt;td&gt;Optional. The point for the morphing process of a shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;Optional. A name to assign to the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;events&lt;/td&gt;
+ * &lt;td&gt;Optional. An array of FSClipEvent objects that define the actions that
+ * are performed when a specific movie clip event occurs.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedEvents&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded clip events can also be set. The
+ * encoded objects are typically generated by the parser in the Translate
+ * framework. The events array and encodedEvents cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Since only one object can be placed on a given layer an existing object on
+ * the display list can be identified by the layer it is displayed on rather
+ * than its identifier. Therefore Layer is the only required attribute. The
+ * remaining attributes are optional according to the different operation being
+ * performed:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;If an existing object on the display list is being modified then only
+ * the layer number is required. Previously in the FSPlaceObject class both the
+ * identifier and the layer number were required.&lt;/li&gt;
+ * &lt;li&gt;If no coordinate transform is applied to the shape (the default is a
+ * unity transform that does not change the shape) then it is not encoded.&lt;/li&gt;
+ * &lt;li&gt;Similarly if no colour transform is applied to the shape (the default is
+ * a unity transform that does not change the shape's colour) then it is not
+ * encoded.&lt;/li&gt;
+ * &lt;li&gt;If a shape is not being morphed then the ratio attribute may be left at
+ * its default value (-1.0).&lt;/li&gt;
+ * &lt;li&gt;If a shape is not used to define a clipping area then the depth
+ * attribute may be left at its default value (0).&lt;/li&gt;
+ * &lt;li&gt;If a name is net assigned to an object the name attribute may be left
+ * its default value (an empty string).&lt;/li&gt;
+ * &lt;li&gt;If no events are being defined for a movie clip then the array of
+ * FSClipEvent object may be left empty.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * The class provides a range of constructors which define different subsets of
+ * the attributes according to the type of operation that will be performed on
+ * an object in the Flash Player's display list. If an attribute is not
+ * specified in a constructor then it will be assigned a default value and will
+ * be omitted when the object is encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following code samples illustrate how to use the FSPlaceObject2 class to
+ * manipulate objects on the display list. These examples use constructors with
+ * the most convenient (simplest) arguments. To define more complex place
+ * operations constructors are provided that take larger numbers of arguments
+ * and allow more complex transformations to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Display an object.&lt;br/&gt; To display an object at a given location the
+ * placeType, identifier, layer number and x,y coordinates are required.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Add the shape to the display list - on layer 1 at coordinates (400, 400)
+ *  // The constructor allows just the x and y coordinate to be defined, the
+ *  // FSCoordTransform object is constructed internally.
+ * 
+ *  FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......);
+ * 
+ *  movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Move an object.&lt;br/&gt; To move an object only the layer number is required.
+ * This simplifies the code required to manipulate existing objects when
+ * compared to the original FSPlaceObject class.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Move shape to a new location.
+ * movie.add(new FSPlaceObject2(1, 250, 300));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Replace an existing object with another.&lt;br/&gt; To move an object only the
+ * layer number is required. This simplifies the code required to manipulate
+ * existing objects when compared to the original FSPlaceObject class.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Replace the shape.
+ * movie.add(new FSPlaceObject2(newShape.getIdentifier(), 1));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 4. Defining a clipping layer.&lt;br/&gt; The number of layers to clip using the
+ * outline of the shape as a path can be specified when placing the shape on the
+ * display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list and clip objects on the next two layers
+ * 
+ * currentLayer = 1;
+ * clipTo = currentLayer + 2;
+ * 
+ * movie.add(new FSPlaceObject2(shape.getIdentifier(), currentLayer, clipTo, 400,
+ * 				400));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 5. Controlling the morphing process.&lt;br/&gt; The ratio attribute controls the
+ * progress as an FSDefineMorphShape object changes from one shape into another.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSShape triangle = new FSShape(....);
+ *  FSShape hexagon = new FSShape(....);
+ * 
+ *  FSDefineMorphShape shape = new FSDefineMorphShape(movie.newIdentifier(), ...., triangle, hexagon);
+ * 
+ *  movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 400, 400));
+ * 
+ *  // Morph the shapes over 10 frames
+ * 
+ *  for (float i=0.1; i&lt;1.0; i+= 0.1)
+ *  {
+ *  movie.add(new FSPlaceObject(1, i));
+ *  movie.add(new FSShowFrame());
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 6. Defining a movie clip event.&lt;br/&gt; FSClipEvent objects are ONLY used to
+ * define the sequence of actions executed when a particular event occurs in a
+ * movie clip.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Define an array of clip events that will contain one event that defines the
+ *  // behaviour of the movie clip in response to a mouse down event.
+ * 
+ *  ArrayList events = new ArrayList();
+ * 
+ *  FSClipEvent clipEvent = new FSClipEvent(FSClipEvent.MouseDown);
+ * 
+ *  // Add one or more actions for the mouse down event.
+ * 
+ *  clipEvent.add(...);
+ *  ...
+ * 
+ *  // Add the clip event to the array of events for the movie clip.
+ * 
+ *  events.add(clipEvent);
+ * 
+ *  // Create the commands to animate the movie clip.
+ * 
+ *  ArrayList commands = new ArrayList();
+ * 
+ *  commands.add(...);
+ * 
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  // Now place the movie clip on the screen on layer 1 at (400, 400).
+ * 
+ *  movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPlaceObject2 class represents the PlaceObject2 tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSPlaceObject2 extends FSMovieObject
+{
+	/* Update an existing object on the display list */
+	public static final int Modify = 1;
 
-&lt;ul&gt;
-&lt;li&gt;Place a new shape on the display list.&lt;/li&gt;
-&lt;li&gt;Change an existing shape by moving it to new location or changing its appearance.&lt;/li&gt;
-&lt;li&gt;Replace an existing shape with a another.&lt;/li&gt;
-&lt;li&gt;Define clipping layers to mask objects displayed in front of a shape.&lt;/li&gt;
-&lt;li&gt;Control the morphing process that changes one shape into another.&lt;/li&gt;
-&lt;li&gt;Assign names to objects rather than using their identifiers.&lt;/li&gt;
-&lt;li&gt;Define the sequence of actions that are executed when an event occurs in movie clip.&lt;/li&gt;
-&lt;/ul&gt;
+	/* Add a new object to the display list */
+	public static final int New = 2;
 
-&lt;p&gt;&lt;b&gt;Clipping Depth&lt;/b&gt;&lt;br/&gt;
-With the introduction of Flash 3 the display list supported a clipping layer. This 
-allowed the outline of an object to define a clipping path that is used to mask 
-other objects placed in front of it. The clipping depth can be set to mask objects 
-between the layer containing the clipping path and a specified layer.&lt;/p&gt;
+	/* Replace an existing object on the display list with a new one */
+	public static final int Replace = 3;
 
-&lt;p&lt;b&gt;Shape Morphing&lt;/b&gt;&lt;br/&gt;
-Shapes that will be morphed are defined using the FSDefineMorphShape class which defines a start and end shape. The Flash Player performs the interpolation that transforms one shape into another. The progress of the morphing process is controlled by a ratio which ranges from 0.0 to 1.0, where 0 generates a shape identical to the starting shape in the FSDefineMorphShape object and 1.0 generates the shape at the end of the morphing process.&lt;/p&gt;
+	private int place = New;
 
-&lt;p&lt;b&gt;Movie Clip Events&lt;/b&gt;&lt;br/&gt;
-With the introduction of Flash 5, movie clips (defined using the FSDefineMovieClip class) could specify sequences of actions that would be performed in response to mouse or keyboard events. The actions are specified using FSClipEvent objects and the FSPlaceObject2 class is used to register the actions in response to a particular event with the Flash player. Multiple events can be handled by defining an FSClipEvent for each type of event. For more information see the FSClipEvent class.&lt;/p&gt;
+	private int layer = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int identifier = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private FSCoordTransform transform = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private FSColorTransform colorTransform = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_1&quot;&gt;place&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether a new object is being placed in the display list or an existing object is being modified or replaced.&lt;/td&gt;
-&lt;/tr&gt;
+	private float ratio = -1.0f;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_2&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the object to added to the display list.&lt;/td&gt;
-&lt;/tr&gt;
+	private int clippingDepth = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_3&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Defines the order in which objects are displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	private String name = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_4&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. A coordinate transform defines the position, scale and rotation of the object.&lt;/td&gt;
-&lt;/tr&gt;
+	private ArrayList clipEvents = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_5&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. A colour transform defines any colour changes such as transparency effects.&lt;/td&gt;
-&lt;/tr&gt;
+	private byte[] encodedEvents = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_6&quot;&gt;depth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. The layer number up to which objects will be clipped by this object's outline.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSPlaceObject2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPlaceObject2(FSCoder coder)
+	{
+		super(PlaceObject2);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_7&quot;&gt;ratio&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. The point for the morphing process of a shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new object on the display
+	 * list at the coordinates on the screen.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, int xLocation,
+							int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_8&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. A name to assign to the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object to place new morphing shape on the
+	 * display list at the coordinates on the screen.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aRatio
+	 *            the ratio of the progress in morphing the shape.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, float aRatio,
+							int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setRatio(aRatio);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_9&quot;&gt;events&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. An array of FSClipEvent objects that define the actions that are performed when a specific movie clip event occurs.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new shape on the display
+	 * list with the specified coordinate and optional colour transform.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_10&quot;&gt;encodedEvents&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded clip events can also be set. The encoded objects are typically generated by the parser in the Translate framework. The events array and encodedEvents cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new shape on the display
+	 * list with the specified coordinate and optional colour transform.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 * @param aColorTransform
+	 *            a FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform,
+							FSColorTransform aColorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(aColorTransform);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new shape on the display
+	 * list at the coordinates on the screen that defines a clipping path that
+	 * will clip objects for the specified number of layers.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aDepth
+	 *            the layer number up to which objects will be clipped by this
+	 *            object's outline.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, int aDepth,
+							int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setClippingDepth(aDepth);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;p&gt;Since only one object can be placed on a given layer an existing object on the display list can be identified by the layer it is displayed on rather than its identifier. Therefore Layer is the only required attribute. The remaining attributes are optional according to the different operation being performed:&lt;/p&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that places a new, named movie clip
+	 * on the display list at the coordinates on the screen.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new movie clip to be displayed.
+	 * @param aLayer
+	 *            the layer number on which the clip is being displayed.
+	 * @param anArray
+	 *            an array of FSClipEvent objects that define the events
+	 *            responded to by the movie clip.
+	 * @param aName
+	 *            a c-string that define a name for the movie clip.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, ArrayList anArray,
+							String aName, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setClipEvents(anArray);
+		setName(aName);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;ul&gt;
-&lt;li&gt;If an existing object on the display list is being modified then only the layer number is required. Previously in the FSPlaceObject class both the identifier and the layer number were required.&lt;/li&gt;
-&lt;li&gt;If no coordinate transform is applied to the shape (the default is a unity transform that does not change the shape) then it is not encoded.&lt;/li&gt;
-&lt;li&gt;Similarly if no colour transform is applied to the shape (the default is a unity transform that does not change the shape's colour) then it is not encoded.&lt;/li&gt;
-&lt;li&gt;If a shape is not being morphed then the ratio attribute may be left at its default value (-1.0).&lt;/li&gt;
-&lt;li&gt;If a shape is not used to define a clipping area then the depth attribute may be left at its default value (0).&lt;/li&gt;
-&lt;li&gt;If a name is net assigned to an object the name attribute may be left its default value (an empty string).&lt;/li&gt;
-&lt;li&gt;If no events are being defined for a movie clip then the array of FSClipEvent object may be left empty.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that places a new, named movie clip
+	 * on the display list at the coordinates on the screen. The array of bytes
+	 * contains the encoded FSClipEvent objects which specify the events and
+	 * actions that the movie clip will respond to. These are typically
+	 * generated using the classes in the Translate framework.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new movie clip to be displayed.
+	 * @param aLayer
+	 *            the layer number on which the clip is being displayed.
+	 * @param bytes
+	 *            an array of encoded clip event objects.
+	 * @param aName
+	 *            a c-string that define a name for the movie clip.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, byte[] bytes,
+							String aName, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setEncodedEvents(bytes);
+		setName(aName);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;p&gt;The class provides a range of constructors which define different subsets of the attributes according to the type of operation that will be performed on an object in the Flash Player's display list. If an attribute is not specified in a constructor then it will be assigned a default value and will be omitted when the object is encoded.&lt;/p&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that replaces the object at the
+	 * specified layer in the display list, aLayer with the object with the
+	 * identifier, anIdentifier. The location and transforms currently applied
+	 * to the object being replaced will be preserved.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object that will replaced the one
+	 *            current displayed on &lt;i&gt;aLayer&lt;/i&gt;.
+	 * @param aLayer
+	 *            the layer number on which the object being replaced is
+	 *            displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Replace);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that changes the location of the
+	 * object in the display list at layer, aLayer to the coordinates (x,y).
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int aLayer, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;p&gt;The following code samples illustrate how to use the FSPlaceObject2 class to manipulate objects on the display list. These examples use constructors with the most convenient (simplest) arguments. To define more complex place operations constructors are provided that take larger numbers of arguments and allow more complex transformations to be specified.&lt;/p&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that applies the specified coordinate
+	 * transform to the object in the display list at layer, aLayer.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aLayer, FSCoordTransform transform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setTransform(transform);
+	}
 
-&lt;p&gt;1. Display an object.&lt;br/&gt;
-To display an object at a given location the placeType, identifier, layer number and x,y coordinates are required.&lt;/p&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that applied the specified colour
+	 * transform to the object in the display list at layer, aLayer.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param colorTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aLayer, FSColorTransform colorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setColorTransform(colorTransform);
+	}
 
-&lt;pre&gt;
-// Add the shape to the display list - on layer 1 at coordinates (400, 400)
-// The constructor allows just the x and y coordinate to be defined, the
-// FSCoordTransform object is constructed internally.
+	/**
+	 * Constructs an FSPlaceObject2 object that applies the specified coordinate
+	 * and colour transforms to the object in the display list at layer, aLayer.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 * @param colorTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aLayer, FSCoordTransform transform,
+							FSColorTransform colorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setTransform(transform);
+		setColorTransform(colorTransform);
+	}
 
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......);
+	/**
+	 * Constructs an FSPlaceObject2 object that changes the location of the
+	 * object in the display list at layer, aLayer to the coordinates (x,y).
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param aRatio
+	 *            the ratio of the progress in morphing the shape.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int aLayer, float aRatio, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setRatio(aRatio);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that modifies the morphing shape
+	 * located on layer, aLayer in the display list. The progress of the
+	 * morphing process is controlled by aRatio.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param aRatio
+	 *            the ratio of the progress in morphing the shape.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed.
+	 */
+	public FSPlaceObject2(int aLayer, float aRatio, FSCoordTransform transform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setRatio(aRatio);
+		setTransform(transform);
+	}
 
-&lt;p&gt;2. Move an object.&lt;br/&gt;
-To move an object only the layer number is required. This simplifies the code required to manipulate existing objects when compared to the original FSPlaceObject class.&lt;/p&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object with the specified placement type,
+	 * object identifier, layer number, coordinate transform and colour
+	 * transform. The exact operation performed is dependent on the placement
+	 * type specified.
+	 * 
+	 * @param aPlace
+	 *            the type of operation to be performed, either New, Modify or
+	 *            Replace.
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 * @param colorTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aPlace, int anIdentifier, int aLayer,
+							FSCoordTransform transform,
+							FSColorTransform colorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(aPlace);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(transform);
+		setColorTransform(colorTransform);
+	}
 
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
+	/**
+	 * Constructs an FSPlaceObject2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSPlaceObject2 object.
+	 */
+	public FSPlaceObject2(FSPlaceObject2 obj)
+	{
+		super(obj);
+		place = obj.place;
+		layer = obj.layer;
+		identifier = obj.identifier;
 
-// Move shape to a new location.
-movie.add(new FSPlaceObject2(1, 250, 300));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		if (obj.transform != null)
+			transform = new FSCoordTransform(obj.transform);
 
-&lt;p&gt;3. Replace an existing object with another.&lt;br/&gt;
-To move an object only the layer number is required. This simplifies the code required to manipulate existing objects when compared to the original FSPlaceObject class.&lt;/p&gt;
+		if (obj.colorTransform != null)
+			colorTransform = new FSColorTransform(obj.colorTransform);
 
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
+		ratio = obj.ratio;
+		clippingDepth = obj.clippingDepth;
 
-// Replace the shape.
-movie.add(new FSPlaceObject2(newShape.getIdentifier(), 1));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		if (obj.name != null)
+			name = new String(obj.name);
 
-&lt;p&gt;4. Defining a clipping layer.&lt;br/&gt;
-The number of layers to clip using the outline of the shape as a path can be specified when placing the shape on the display list.&lt;/p&gt;
+		if (obj.clipEvents != null)
+		{
+			clipEvents = new ArrayList(obj.clipEvents.size());
 
-&lt;pre&gt;
-// Add the shape to the display list and clip objects on the next two layers
+			for (Iterator i = obj.clipEvents.iterator(); i.hasNext();)
+				clipEvents.add(((FSClipEvent) i.next()).clone());
+		} else
+		{
+			encodedEvents = Transform.clone(encodedEvents);
+		}
+	}
 
-currentLayer = 1;
-clipTo = currentLayer + 2;
+	/**
+	 * Adds a clip event to the array of clip events. If the object already
+	 * contains a set of encoded clip event objects they will be deleted.
+	 * 
+	 * @param aClipEvent
+	 *            a clip event object.
+	 */
+	public void add(FSClipEvent aClipEvent)
+	{
+		if (clipEvents == null)
+			clipEvents = new ArrayList();
 
-movie.add(new FSPlaceObject2(shape.getIdentifier(), currentLayer, clipTo, 400, 400));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		clipEvents.add(aClipEvent);
+		encodedEvents = null;
+	}
 
-&lt;p&gt;5. Controlling the morphing process.&lt;br/&gt;
-The ratio attribute controls the progress as an FSDefineMorphShape object changes from one shape into another.&lt;/p&gt;
+	/**
+	 * Gets the array of FSClipEvent object that define the actions that will be
+	 * executed in response to events that occur in the FSDefineMovieClip being
+	 * placed.
+	 * 
+	 * @return the array of clip events
+	 */
+	public ArrayList getClipEvents()
+	{
+		return clipEvents;
+	}
 
-&lt;pre&gt;
-FSShape triangle = new FSShape(....);
-FSShape hexagon = new FSShape(....);
+	/**
+	 * Set the array of Clip events. Clip Events are only valid for movie clips
+	 * and the argument should be set to null when placing other types of
+	 * object.
+	 * 
+	 * If the object already contains a set of encoded clip event objects they
+	 * will be deleted.
+	 * 
+	 * @param anArray
+	 *            an array of FSClipEvent objects.
+	 */
+	public void setClipEvents(ArrayList anArray)
+	{
+		clipEvents = anArray;
 
-FSDefineMorphShape shape = new FSDefineMorphShape(movie.newIdentifier(), ...., triangle, hexagon);
+		if (encodedEvents != null)
+			encodedEvents = null;
+	}
 
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 400, 400));
+	/**
+	 * Set the encoded clip event objects generated by the classes in the
+	 * Translate framework. If the object already contains an array of clip
+	 * events objects then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded clip events.
+	 */
+	public void setEncodedEvents(byte[] bytes)
+	{
+		encodedEvents = bytes;
+		clipEvents = null;
+	}
 
-// Morph the shapes over 10 frames
+	/**
+	 * Gets the type of place operation being performed.
+	 * 
+	 * @return the placement type.
+	 */
+	public int getPlaceType()
+	{
+		return place;
+	}
 
-for (float i=0.1; i&lt;1.0; i+= 0.1)
-{
-    movie.add(new FSPlaceObject(1, i));
-    movie.add(new FSShowFrame());
-}
-&lt;/pre&gt;
+	/**
+	 * Gets the Layer on which the object will be displayed in the display list.
+	 * 
+	 * @return the layer number being referenced.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;p&gt;6. Defining a movie clip event.&lt;br/&gt;
-FSClipEvent objects are ONLY used to define the sequence of actions executed when a particular event occurs in a movie clip.&lt;/p&gt;
+	/**
+	 * Gets the identifier of the object to be placed. This is only required
+	 * when placing an object for the first time. Subsequent references to the
+	 * object on this layer can simply use the layer number.
+	 * 
+	 * @return the identifier of an object being placed on the display list.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;pre&gt;
-// Define an array of clip events that will contain one event that defines the
-// behaviour of the movie clip in response to a mouse down event.
+	/**
+	 * Gets the coordinate transform.
+	 * 
+	 * @return the FSCoordTransform that will be applied to an object in the
+	 *         display list.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-ArrayList events = new ArrayList();
+	/**
+	 * Gets the colour transform.
+	 * 
+	 * @return the FSColorTransform that will be applied to an object in the
+	 *         display list.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-FSClipEvent clipEvent = new FSClipEvent(FSClipEvent.MouseDown);
+	/**
+	 * Gets the morph ratio, in the range 0.0 to 1.0 that defines the progress
+	 * in the morphing process performed by the Flash Player from the defined
+	 * start and end shapes. A value of 0 indicates the start of the process and
+	 * 65535 the end.
+	 * 
+	 * @return the morph ratio, in the range 0.0..1.0.
+	 */
+	public float getRatio()
+	{
+		return ratio;
+	}
 
-// Add one or more actions for the mouse down event.
+	/**
+	 * Gets the number of layers that will be clipped by the object placed on
+	 * the layer specified in this object.
+	 * 
+	 * @return the number of layers that will be clipped.
+	 */
+	public int getClippingDepth()
+	{
+		return clippingDepth;
+	}
 
-clipEvent.add(...);
-...
+	/**
+	 * Gets the name of the object.
+	 * 
+	 * @return the name assigned to an object.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-// Add the clip event to the array of events for the movie clip.
+	/**
+	 * Sets the type of placement.
+	 * 
+	 * @param aType
+	 *            the type of operation to be performed, either New, Modify or
+	 *            Replace.
+	 */
+	public void setPlaceType(int aType)
+	{
+		place = aType;
+	}
 
-events.add(clipEvent);
+	/**
+	 * Sets the layer at which the object will be placed.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 */
+	public void setLayer(int aLayer)
+	{
+		layer = aLayer;
+	}
 
-// Create the commands to animate the movie clip.
+	/**
+	 * Sets the identifier of the object.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-ArrayList commands = new ArrayList();
+	/**
+	 * Sets the coordinate transform that defines the position where the object
+	 * will be displayed. The argument may be null if the location of the object
+	 * is not being changed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-commands.add(...);
+	/**
+	 * Sets the colour transform that defines the colour effects applied to the
+	 * object. The argument may be null if the color of the object is not being
+	 * changed.
+	 * 
+	 * @param aTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed.
+	 */
+	public void setColorTransform(FSColorTransform aTransform)
+	{
+		colorTransform = aTransform;
+	}
 
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+	/**
+	 * Sets point of the morphing process for a morph shape in the range 0..1.
+	 * May be set to zero if the shape being placed is not being morphed.
+	 * 
+	 * @param aNumber
+	 *            the progress in the morphing process.
+	 */
+	public void setRatio(float aNumber)
+	{
+		ratio = aNumber;
+	}
 
-// Now place the movie clip on the screen on layer 1 at (400, 400).
+	/**
+	 * Sets the number of layers that this object will mask. May be set to zero
+	 * if the shape being placed does not define a clipping area.
+	 * 
+	 * @param aNumber
+	 *            the number of layers clipped.
+	 */
+	public void setClippingDepth(int aNumber)
+	{
+		clippingDepth = aNumber;
+	}
 
-movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400));
-&lt;/pre&gt;
+	/**
+	 * Set the name of an object to be displayed. If a shape is not being
+	 * assigned a name then setting the argument to null will omit the attribute
+	 * when the object is encoded.
+	 * 
+	 * @param aString
+	 *            the name assigned to the object.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public Object clone()
+	{
+		FSPlaceObject2 anObject = (FSPlaceObject2) super.clone();
 
-&lt;p&gt;The FSPlaceObject2 class represents the PlaceObject2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSPlaceObject2 extends FSMovieObject
-{
-    /* Update an existing object on the display list */
-    public static final int Modify = 1;
-    /* Add a new object to the display list */
-    public static final int New = 2;
-    /* Replace an existing object on the display list with a new one */
-    public static final int Replace = 3;
-    
-    private int place = New;
-    private int layer = 0;
-    private int identifier = 0;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-    private FSCoordTransform transform = null;
-    private FSColorTransform colorTransform = null;
+		if (clipEvents != null)
+		{
+			anObject.clipEvents = new ArrayList();
 
-    private float ratio = -1.0f;
-    private int clippingDepth = 0;
+			for (Iterator i = clipEvents.iterator(); i.hasNext();)
+				anObject.clipEvents.add(((FSClipEvent) i.next()).clone());
+		} else
+		{
+			anObject.encodedEvents = Transform.clone(encodedEvents);
+		}
+		return anObject;
+	}
 
-    private String name = null;
-    private ArrayList clipEvents = null;
-    private byte[] encodedEvents = null;
-        
-    /**
-     * Construct an FSPlaceObject2 object, initialising it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPlaceObject2(FSCoder coder)
-    {
-        super(PlaceObject2);
-        decode(coder);
-    }
-    /** Constructs an FSPlaceObject2 object to place a new object on the display list at the coordinates on the screen.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+		if (super.equals(anObject))
+		{
+			FSPlaceObject2 typedObject = (FSPlaceObject2) anObject;
 
-    /** Constructs an FSPlaceObject2 object to place new morphing shape on the display list at the coordinates on the screen.
+			result = place == typedObject.place;
+			result = result &amp;&amp; layer == typedObject.layer;
+			result = result &amp;&amp; identifier == typedObject.identifier;
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aRatio the ratio of the progress in morphing the shape.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, float aRatio, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setRatio(aRatio);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+			if (transform == null)
+				result = result &amp;&amp; (typedObject.transform == null);
+			else
+				result = result &amp;&amp; transform.equals(typedObject.transform);
 
-    /** Constructs an FSPlaceObject2 object to place a new shape on the display list with the specified coordinate and optional colour transform.
+			if (colorTransform == null)
+				result = result &amp;&amp; (typedObject.colorTransform == null);
+			else
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aTransform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, FSCoordTransform aTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-    }
+			result = result &amp;&amp; ratio == typedObject.ratio;
+			result = result &amp;&amp; clippingDepth == typedObject.clippingDepth;
 
-    /** Constructs an FSPlaceObject2 object to place a new shape on the display list with the specified coordinate and optional colour transform.
+			if (name == null)
+				result = result &amp;&amp; (typedObject.name == null);
+			else
+				result = result &amp;&amp; name.equals(typedObject.name);
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aTransform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        @param aColorTransform a FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, FSCoordTransform aTransform, FSColorTransform aColorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(aColorTransform);
-    }
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-    /** Constructs an FSPlaceObject2 object to place a new shape on the display list at the coordinates on the screen that defines a clipping path that will clip objects for the specified number of layers.
+			if (clipEvents != null)
+				result = result &amp;&amp; clipEvents.equals(typedObject.clipEvents);
+			else
+				result = result
+								&amp;&amp; Transform.equals(encodedEvents,
+												typedObject.encodedEvents);
+		}
+		return result;
+	}
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aDepth the layer number up to which objects will be clipped by this object's outline.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, int aDepth, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setClippingDepth(aDepth);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Constructs an FSPlaceObject2 object that places a new, named movie clip on the display list at the coordinates on the screen.
+		buffer.append(&quot;FSPlaceObject2: { &quot;);
+		buffer.append(&quot;place = &quot;).append(place).append(&quot;; &quot;);
+		buffer.append(&quot;layer = &quot;).append(layer).append(&quot;; &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;transform = &quot;).append(transform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;colorTransform = &quot;).append(colorTransform.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;ratio = &quot;).append(ratio).append(&quot;; &quot;);
+		buffer.append(&quot;clippingDepth = &quot;).append(clippingDepth).append(&quot;; &quot;);
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
 
-        @param anIdentifier the identifier of a new movie clip to be displayed.
-        @param aLayer the layer number on which the clip is being displayed.
-        @param anArray an array of FSClipEvent objects that define the events responded to by the movie clip.
-        @param aName a c-string that define a name for the movie clip.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, ArrayList anArray, String aName, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setClipEvents(anArray);
-        setName(aName);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
-    
-    /** Constructs an FSPlaceObject2 object that places a new, named movie clip 
-     * on the display list at the coordinates on the screen. The array of bytes
-     * contains the encoded FSClipEvent objects which specify the events and 
-     * actions that the movie clip will respond to. These are typically generated
-     * using the classes in the Translate framework.
-     * 
-     * @param anIdentifier the identifier of a new movie clip to be displayed.
-     * @param aLayer the layer number on which the clip is being displayed.
-     * @param bytes an array of encoded clip event objects.
-     * @param aName a c-string that define a name for the movie clip.
-     * @param xLocation the x-coordinate where the object will be displayed.
-     * @param yLocation the y-coordinate where the object will be displayed.
-     */
-    public FSPlaceObject2(int anIdentifier, int aLayer, byte[] bytes, String aName, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setEncodedEvents(bytes);
-        setName(aName);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
-    
-    /** Constructs an FSPlaceObject2 object that replaces the object at the specified layer in the display list, aLayer with the object with the identifier, anIdentifier. The location and transforms currently applied to the object being replaced will be preserved.
+		if (clipEvents != null)
+			buffer.append(&quot;clipEvents = array[&quot;).append(clipEvents.size()).append(&quot;]; &quot;);
+		else
+			buffer.append(&quot;clipEvents = &lt;data&gt;; &quot;);
 
-        @param anIdentifier the identifier of the object that will replaced the one current displayed on &lt;i&gt;aLayer&lt;/i&gt;.
-        @param aLayer the layer number on which the object being replaced is displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Replace);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-    }
+		buffer.append(&quot;}&quot;);
 
-    /** Constructs an FSPlaceObject2 object that changes the location of the object in the display list at layer, aLayer to the coordinates (x,y).
+		return buffer.toString();
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int aLayer, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Constructs an FSPlaceObject2 object that applies the specified coordinate transform to the object in the display list at layer, aLayer.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param transform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int aLayer, FSCoordTransform transform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setTransform(transform);
-    }
+		length += 3;
+		length += (place == 2 || place == 3) ? 2 : 0;
+		length += (containsTransform()) ? transform.length(coder) : 0;
+		length += (containsColorTransform(coder)) ? colorTransform
+						.length(coder) : 0;
+		length += (containsRatio()) ? 2 : 0;
+		length += (containsClippingDepth()) ? 2 : 0;
 
-    /** Constructs an FSPlaceObject2 object that applied the specified colour transform to the object in the display list at layer, aLayer.
+		length += containsName() ? coder.strlen(name, true) : 0;
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param colorTransform an FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int aLayer, FSColorTransform colorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setColorTransform(colorTransform);
-    }
+		if (containsClipEvents())
+		{
+			if (clipEvents != null)
+			{
+				int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
 
-    /** Constructs an FSPlaceObject2 object that applies the specified coordinate and colour transforms to the object in the display list at layer, aLayer.
+				length += 2 + eventSize;
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param transform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        @param colorTransform an FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int aLayer, FSCoordTransform transform, FSColorTransform colorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setTransform(transform);
-        setColorTransform(colorTransform);
-    }
+				for (Iterator i = clipEvents.iterator(); i.hasNext();)
+					length += ((FSClipEvent) i.next()).length(coder);
 
-    /** Constructs an FSPlaceObject2 object that changes the location of the object in the display list at layer, aLayer to the coordinates (x,y).
+				length += eventSize;
+			} else
+			{
+				length += encodedEvents.length;
+			}
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param aRatio the ratio of the progress in morphing the shape.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int aLayer, float aRatio, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setRatio(aRatio);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+		return length;
+	}
 
-    /** Constructs an FSPlaceObject2 object that modifies the morphing shape located on layer, aLayer in the display list. The progress of the morphing process is controlled by aRatio.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param aRatio the ratio of the progress in morphing the shape.
-        @param transform an FSCoordTransform object that will be applied to the object displayed.
-        */
-    public FSPlaceObject2(int aLayer, float aRatio, FSCoordTransform transform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setRatio(aRatio);
-        setTransform(transform);
-    }
-    
-    /** Constructs an FSPlaceObject2 object with the specified placement type, object identifier, layer number, coordinate transform and colour transform. The exact operation performed is dependent on the placement type specified.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-     @param aPlace the type of operation to be performed, either New, Modify or Replace.
-     @param anIdentifier the identifier of a new object to be displayed.
-     @param aLayer the layer number on which an object is being displayed.
-     @param transform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-     @param colorTransform an FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-     */
-    public FSPlaceObject2(int aPlace, int anIdentifier, int aLayer, FSCoordTransform transform, FSColorTransform colorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(aPlace);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(transform);
-        setColorTransform(colorTransform);
-    }
-    /**
-     * Constructs an FSPlaceObject2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSPlaceObject2 object.
-     */
-    public FSPlaceObject2(FSPlaceObject2 obj)
-    {
-        super(obj);
-        place = obj.place;
-        layer = obj.layer;
-        identifier = obj.identifier;
-        
-        if (obj.transform != null)
-            transform = new FSCoordTransform(obj.transform);
-        
-        if (obj.colorTransform != null)
-            colorTransform = new FSColorTransform(obj.colorTransform);
-        
-        ratio = obj.ratio;
-        clippingDepth = obj.clippingDepth;
-        
-        if (obj.name != null)
-            name = new String(obj.name);
-        
-        if (obj.clipEvents != null)
-        {
-            clipEvents = new ArrayList(obj.clipEvents.size());
-            
-            for (Iterator i = obj.clipEvents.iterator(); i.hasNext();)
-                clipEvents.add(((FSClipEvent)i.next()).clone());
-        }
-        else
-        {
-            encodedEvents = Transform.clone(encodedEvents);
-        }
-    }    
+		coder.writeBits(containsClipEvents() ? 1 : 0, 1);
+		coder.writeBits(containsClippingDepth() ? 1 : 0, 1);
+		coder.writeBits(containsName() ? 1 : 0, 1);
+		coder.writeBits(containsRatio() ? 1 : 0, 1);
+		coder.writeBits(containsColorTransform(coder) ? 1 : 0, 1);
+		coder.writeBits(containsTransform() ? 1 : 0, 1);
+		coder.writeBits(place, 2);
+		coder.writeWord(layer, 2);
 
-    /** Adds a clip event to the array of clip events. If the object already
-     * contains a set of encoded clip event objects they will be deleted.
-     *
-     * @param aClipEvent a clip event object.
-     */
-    public void add(FSClipEvent aClipEvent)
-    {
-        if (clipEvents == null)
-            clipEvents = new ArrayList();
-            
-        clipEvents.add(aClipEvent);
-        encodedEvents = null;
-    }
-    /** 
-     * Gets the array of FSClipEvent object that define the actions that will be 
-     * executed in response to events that occur in the FSDefineMovieClip being placed.
-     *
-     * @return the array of clip events
-     */
-    public ArrayList getClipEvents()
-    {
-        return clipEvents;
-    }
+		if (place == 2 || place == 3)
+			coder.writeWord(identifier, 2);
+		if (containsTransform())
+			transform.encode(coder);
+		if (containsColorTransform(coder))
+			colorTransform.encode(coder);
+		if (containsRatio())
+			coder.writeWord((int) (ratio * 65535.0f), 2);
 
-    /** 
-     * Set the array of Clip events. Clip Events are only valid for movie clips 
-     * and the argument should be set to null when placing other types of object.
-     * 
-     * If the object already contains a set of encoded clip event objects they 
-     * will be deleted.
-     *
-     * @param anArray an array of FSClipEvent objects.
-     */
-    public void setClipEvents(ArrayList anArray)
-    {
-        clipEvents = anArray;
- 
-        if (encodedEvents != null)
-           encodedEvents = null;
-    }
+		// if (coder.context[FSCoder.Version] &gt; 5)
+		// {
+		if (containsName())
+		{
+			coder.writeString(name);
+			coder.writeWord(0, 1);
+		}
 
-    /** 
-     * Set the encoded clip event objects generated by the classes in the Translate 
-     * framework. If the object already contains an array of clip events objects
-     * then they will be deleted.
-     * 
-     * @param bytes the array of encoded clip events.
-     */
-    public void setEncodedEvents(byte[] bytes)
-    {
-        encodedEvents = bytes;
-        clipEvents = null;
-    }
+		if (containsClippingDepth())
+			coder.writeWord(clippingDepth, 2);
+		/*
+		 * } else { if (containsClippingDepth())
+		 * coder.writeWord(clippingDepth+1, 2);
+		 * 
+		 * if (containsName()) { coder.writeString(name); coder.writeWord(0, 1); } }
+		 */
+		if (containsClipEvents())
+		{
+			if (clipEvents != null)
+			{
+				int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
+				int eventMask = 0;
 
-    /** Gets the type of place operation being performed.
+				coder.writeWord(0, 2);
 
-        @return the placement type.
-        */
-    public int getPlaceType()
-    {
-        return place;
-    }
+				for (Iterator i = clipEvents.iterator(); i.hasNext();)
+					eventMask |= ((FSClipEvent) i.next()).getEvent();
 
-    /** Gets the Layer on which the object will be displayed in the display list. 
+				coder.writeWord(eventMask, eventSize);
 
-        @return the layer number being referenced.
-        */
-    public int getLayer()
-    {
-        return layer;
-    }
+				for (Iterator&lt;FSClipEvent&gt; i = clipEvents.iterator(); i.hasNext();)
+					i.next().encode(coder);
 
-    /** Gets the identifier of the object to be placed. This is only required when placing an object for the first time. Subsequent references to the object on this layer can simply use the layer number.
+				coder.writeWord(0, eventSize);
+			} else
+			{
+				coder.writeBytes(encodedEvents);
+			}
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 
-        @return the identifier of an object being placed on the display list.
-        */
-    public int getIdentifier()
-    {
-        return identifier;
-    }
+	public void decode(FSCoder coder)
+	{
+		boolean containsClipEvents = false;
+		boolean containsClippingDepth = false;
+		boolean containsName = false;
+		boolean containsRatio = false;
+		boolean containsColorTransform = false;
+		boolean containsTransform = false;
 
-    /** Gets the coordinate transform.
+		super.decode(coder);
 
-        @return the FSCoordTransform that will be applied to an object in the display list.
-        */
-    public FSCoordTransform getTransform()
-    {
-        return transform;
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Gets the colour transform.
+		containsClipEvents = coder.readBits(1, false) != 0 ? true : false;
+		containsClippingDepth = coder.readBits(1, false) != 0 ? true : false;
+		containsName = coder.readBits(1, false) != 0 ? true : false;
+		containsRatio = coder.readBits(1, false) != 0 ? true : false;
+		containsColorTransform = coder.readBits(1, false) != 0 ? true : false;
+		containsTransform = coder.readBits(1, false) != 0 ? true : false;
+		place = coder.readBits(2, false);
+		layer = coder.readWord(2, false);
 
-        @return the FSColorTransform that will be applied to an object in the display list.
-        */
-    public FSColorTransform getColorTransform()
-    {
-        return colorTransform;
-    }
+		if (place == 2 || place == 3)
+			identifier = coder.readWord(2, false);
 
-    /** Gets the morph ratio, in the range 0.0 to 1.0 that defines the progress in the morphing process performed by the Flash Player from the defined start and end shapes. A value of 0 indicates the start of the process and 65535 the end.
+		if (containsTransform)
+			transform = new FSCoordTransform(coder);
 
-        @return the morph ratio, in the range 0.0..1.0.
-        */
-    public float getRatio()
-    {
-        return ratio;
-    }
+		if (containsColorTransform)
+			colorTransform = new FSColorTransform(coder);
 
-    /** Gets the number of layers that will be clipped by the object placed on the layer specified in this object.
+		if (containsRatio)
+			ratio = coder.readWord(2, false) / 65535.0f;
 
-        @return the number of layers that will be clipped.
-        */
-    public int getClippingDepth()
-    { 
-        return clippingDepth;
-    }
+		if (containsName)
+			name = coder.readString();
 
-    /** Gets the name of the object.
+		if (containsClippingDepth)
+			clippingDepth = coder.readWord(2, false);
 
-        @return the name assigned to an object.
-        */
-    public String getName()
-    {
-        return name;
-    }
+		if (containsClipEvents)
+		{
+			int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
+			clipEvents = new ArrayList();
 
-    /** Sets the type of placement.
+			coder.readWord(2, false);
+			coder.readWord(eventSize, false);
 
-        @param aType the type of operation to be performed, either New, Modify or Replace.
-        */
-    public void setPlaceType(int aType)
-    {
-        place = aType;
-    }
+			while (coder.scanWord(eventSize, false) != 0)
+				clipEvents.add(new FSClipEvent(coder));
 
-    /** Sets the layer at which the object will be placed. 
+			coder.readWord(eventSize, false);
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        */
-    public void setLayer(int aLayer)
-    {
-        layer = aLayer;
-    }
+	private boolean containsTransform()
+	{
+		return transform != null;
+	}
 
-    /** Sets the identifier of the object.
+	private boolean containsColorTransform(FSCoder coder)
+	{
+		return colorTransform != null;
+	}
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	private boolean containsClipEvents()
+	{
+		return (clipEvents != null &amp;&amp; clipEvents.size() &gt; 0)
+						|| encodedEvents != null;
+	}
 
-    /** Sets the coordinate transform that defines the position where the object will be displayed. The argument may be null if the location of the object is not being changed.
+	private boolean containsClippingDepth()
+	{
+		return clippingDepth &gt; 0;
+	}
 
-        @param aTransform an FSCoordTransform object that will be applied to the object displayed.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+	private boolean containsName()
+	{
+		return name != null &amp;&amp; name.length() &gt; 0;
+	}
 
-    /** Sets the colour transform that defines the colour effects applied to the object. The argument may be null if the color of the object is not being changed.
-
-        @param aTransform an FSColorTransform object that will be applied to the object displayed.
-        */
-    public void setColorTransform(FSColorTransform aTransform)
-    {
-        colorTransform = aTransform;
-    }
-
-    /** Sets point of the morphing process for a morph shape in the range 0..1. May be set to zero if the shape being placed is not being morphed.
-
-        @param aNumber the progress in the morphing process.
-        */
-    public void setRatio(float aNumber)
-    {
-        ratio = aNumber;
-    }
-
-    /** 
-     * Sets the number of layers that this object will mask. May be set to zero 
-     * if the shape being placed does not define a clipping area.
-
-        @param aNumber the number of layers clipped.
-        */
-    public void setClippingDepth(int aNumber)
-    {
-        clippingDepth = aNumber;
-    }
-
-    /** Set the name of an object to be displayed. If a shape is not being assigned a name then setting the argument to null will omit the attribute when the object is encoded.
-
-        @param aString the name assigned to the object.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
-
-    public Object clone()
-    {
-        FSPlaceObject2 anObject = (FSPlaceObject2)super.clone();
-        
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
-        
-        if (clipEvents != null)
-        {
-            anObject.clipEvents = new ArrayList();
-            
-            for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                anObject.clipEvents.add(((FSClipEvent)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedEvents = Transform.clone(encodedEvents);
-        }
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSPlaceObject2 typedObject = (FSPlaceObject2)anObject;
-            
-            result = place == typedObject.place;
-            result = result &amp;&amp; layer == typedObject.layer;
-            result = result &amp;&amp; identifier == typedObject.identifier;
-           
-            if (transform == null)
-                result = result &amp;&amp; (typedObject.transform == null);
-            else
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-
-            if (colorTransform == null)
-                result = result &amp;&amp; (typedObject.colorTransform == null);
-            else
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-
-            result = result &amp;&amp; ratio == typedObject.ratio;
-            result = result &amp;&amp; clippingDepth == typedObject.clippingDepth;
-
-            if (name == null)
-                result = result &amp;&amp; (typedObject.name == null);
-            else
-                result = result &amp;&amp; name.equals(typedObject.name);
-                
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
-
-            if (clipEvents != null)
-                result = result &amp;&amp; clipEvents.equals(typedObject.clipEvents);
-            else
-                result = result &amp;&amp; Transform.equals(encodedEvents, typedObject.encodedEvents);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;place&quot;, place);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            Transform.append(buffer, &quot;ratio&quot;, ratio);
-            Transform.append(buffer, &quot;clippingDepth&quot;, clippingDepth);
-            Transform.append(buffer, &quot;name&quot;, name);
-
-            if (clipEvents != null)
-                Transform.append(buffer, &quot;clipEvents&quot;, clipEvents, depth);
-            else
-                buffer.append(&quot;clipEvents = &lt;data&gt;; &quot;);
-
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        coder.context[FSCoder.TransparentColors] = 1;
-
-        length += 3;
-        length += (place == 2 || place == 3) ? 2 : 0;
-        length += (containsTransform()) ? transform.length(coder) : 0;
-        length += (containsColorTransform(coder)) ? colorTransform.length(coder) : 0;
-        length += (containsRatio()) ? 2 : 0;
-        length += (containsClippingDepth()) ? 2 : 0;
-        
-        length += containsName() ? coder.strlen(name, true) : 0;
-
-        if (containsClipEvents())
-        {
-            if (clipEvents != null)
-            {
-                int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
-            
-                length += 2 + eventSize;
-            
-                for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                    length += ((FSClipEvent)i.next()).length(coder);
-                
-                length += eventSize;
-            }
-            else
-            {
-                length += encodedEvents.length;
-            }
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
-
-        coder.writeBits(containsClipEvents() ? 1 : 0, 1);
-        coder.writeBits(containsClippingDepth() ? 1 : 0, 1);
-        coder.writeBits(containsName() ? 1 : 0, 1);
-        coder.writeBits(containsRatio() ? 1 : 0, 1);
-        coder.writeBits(containsColorTransform(coder) ? 1 : 0, 1);
-        coder.writeBits(containsTransform() ? 1 : 0, 1);
-        coder.writeBits(place, 2);
-        coder.writeWord(layer, 2);
-        
-        if (place == 2 || place == 3)
-            coder.writeWord(identifier, 2);
-        if (containsTransform())
-            transform.encode(coder);
-        if (containsColorTransform(coder))
-            colorTransform.encode(coder);
-        if (containsRatio())
-            coder.writeWord((int)(ratio * 65535.0f), 2);
-            
-//        if (coder.context[FSCoder.Version] &gt; 5)
-//        {
-            if (containsName())
-            {
-                coder.writeString(name);
-                coder.writeWord(0, 1);
-            }
-    
-            if (containsClippingDepth())
-                coder.writeWord(clippingDepth, 2);
-/*        }
-        else
-        {
-            if (containsClippingDepth())
-                coder.writeWord(clippingDepth+1, 2);
-
-            if (containsName())
-            {
-                coder.writeString(name);
-                coder.writeWord(0, 1);
-            }
-        }
-*/
-        if (containsClipEvents())
-        {
-            if (clipEvents != null)
-            {
-                int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
-                int eventMask = 0;
-            
-                coder.writeWord(0, 2);
-
-                for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                    eventMask |= ((FSClipEvent)i.next()).getEvent();
-           
-                coder.writeWord(eventMask, eventSize);
-
-                for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                    ((FSTransformObject)i.next()).encode(coder);
-                
-                coder.writeWord(0, eventSize);
-            }
-            else
-            {
-                coder.writeBytes(encodedEvents);
-            }
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsClipEvents = false;
-        boolean containsClippingDepth = false;
-        boolean containsName = false;
-        boolean containsRatio = false;
-        boolean containsColorTransform = false;
-        boolean containsTransform = false;
-       
-        super.decode(coder);
-
-        coder.context[FSCoder.TransparentColors] = 1;
-
-        containsClipEvents = coder.readBits(1, false) != 0 ? true : false;
-        containsClippingDepth = coder.readBits(1, false) != 0 ? true : false;
-        containsName = coder.readBits(1, false) != 0 ? true : false;
-        containsRatio = coder.readBits(1, false) != 0 ? true : false;
-        containsColorTransform = coder.readBits(1, false) != 0 ? true : false;
-        containsTransform = coder.readBits(1, false) != 0 ? true : false;
-        place = coder.readBits(2, false);
-        layer = coder.readWord(2, false);
-        
-        if (place == 2 || place == 3)
-            identifier = coder.readWord(2, false);
-            
-        if (containsTransform)
-            transform = new FSCoordTransform(coder);
-
-        if (containsColorTransform)
-            colorTransform = new FSColorTransform(coder);
-
-        if (containsRatio)
-            ratio = coder.readWord(2, false) / 65535.0f;
-
-        if (containsName)
-            name = coder.readString();
-
-        if (containsClippingDepth)
-            clippingDepth = coder.readWord(2, false);
-
-        if (containsClipEvents)
-        {
-            int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
-            clipEvents = new ArrayList();
-            
-            coder.readWord(2, false);
-            coder.readWord(eventSize, false);
-
-            while (coder.scanWord(eventSize, false) != 0)
-                clipEvents.add(new FSClipEvent(coder));
- 
-            coder.readWord(eventSize, false);
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-
-    private boolean containsTransform()
-    {
-        return transform != null;
-    }
-
-    private boolean containsColorTransform(FSCoder coder)
-    {
-        return colorTransform != null;
-    }
-
-    private boolean containsClipEvents()
-    {
-        return (clipEvents != null &amp;&amp; clipEvents.size() &gt; 0) || encodedEvents != null;
-    }
-
-    private boolean containsClippingDepth()
-    {
-        return clippingDepth &gt; 0;
-    }
-
-    private boolean containsName()
-    {
-        return name != null &amp;&amp; name.length() &gt; 0;
-    }
-
-    private boolean containsRatio()
-    {
-        return ratio &gt;= 0.0;
-    }
+	private boolean containsRatio()
+	{
+		return ratio &gt;= 0.0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSRegisterVariable.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSRegisterVariable.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSRegisterVariable.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,139 +31,160 @@
 package com.flagstone.transform;
 
 /**
-FSRegisterVariable is a lightweight class used to identify the register that an argument 
-defined in The FSNewFunction2 class is mapped into when executing the function.
-
-&lt;p&gt;Register numbers up to 255 may be specified. If the number is zero then the 
-argument is defined as a local variable.&lt;/p&gt;
- */  
-public class FSRegisterVariable extends FSTransformObject
+ * FSRegisterVariable is a lightweight class used to identify the register that
+ * an argument defined in The FSNewFunction2 class is mapped into when executing
+ * the function.
+ * 
+ * &lt;p&gt;
+ * Register numbers up to 255 may be specified. If the number is zero then the
+ * argument is defined as a local variable.
+ * &lt;/p&gt;
+ */
+public class FSRegisterVariable implements Cloneable, Codeable
 {
-    private int index = 0;
-    private String name = null;
+	private int index = 0;
+	private String name = null;
 
-    /**
-     * Construct an FSRegisterVariable object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRegisterVariable(FSCoder coder)
-    {
-        decode(coder);
-    }    
-    /**
-     * Constructs a new FSRegisterVariable object specifying the name of the argument and 
-     * the number of the register it will be mapped to. If the index is 0 then the 
-     * argument will be stored in a local variable.
-     *
-     * @param index the number of the register, 1..255, 0 if the argument will be stored in a local variable.
-     * @param name the name of the argument.
-     */
-    public FSRegisterVariable(int index, String name)
-    {
-        this.index = index;    
-        this.name = name;
-    }
+	/**
+	 * Construct an FSRegisterVariable object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRegisterVariable(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    /**
-     * Gets the number of the register that will contain the function argument.
-     *
-     * @return the number of the register, 1..255, in which the function argument will be stored, 0 if the argument will be stored in a local variable.
-     */
-    public int getIndex() { return index; }
-    /**
-     * Constructs an FSRegisterVariable object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSRegisterVariable object.
-     */
-    public FSRegisterVariable(FSRegisterVariable obj)
-    {
-        index = obj.index;
-        name = new String(obj.name);
-    }    
+	/**
+	 * Constructs a new FSRegisterVariable object specifying the name of the
+	 * argument and the number of the register it will be mapped to. If the
+	 * index is 0 then the argument will be stored in a local variable.
+	 * 
+	 * @param index
+	 *            the number of the register, 1..255, 0 if the argument will be
+	 *            stored in a local variable.
+	 * @param name
+	 *            the name of the argument.
+	 */
+	public FSRegisterVariable(int index, String name)
+	{
+		this.index = index;
+		this.name = name;
+	}
 
-    /**
-     * Gets the name of the function argument.
-     *
-     * @return the name of the argument.
-     */
-    public String getName() { return name; }
+	/**
+	 * Gets the number of the register that will contain the function argument.
+	 * 
+	 * @return the number of the register, 1..255, in which the function
+	 *         argument will be stored, 0 if the argument will be stored in a
+	 *         local variable.
+	 */
+	public int getIndex()
+	{
+		return index;
+	}
 
-    /**
-     * Sets the number of the register that will contain the function argument.
-     *
-     * @param index the number of the register, 1..255, in which the function argument will be stored, 0 if the argument will be stored in a local variable.
-     */
-    public void setIndex(int index)
-    {
-        this.index = index;
-    }
+	/**
+	 * Constructs an FSRegisterVariable object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSRegisterVariable object.
+	 */
+	public FSRegisterVariable(FSRegisterVariable obj)
+	{
+		index = obj.index;
+		name = new String(obj.name);
+	}
 
-    /**
-     * Sets the name of the function argument.
-     *
-     * @param name the name of the argument.
-     */
-     public void setName(String name)
-    {
-        this.name = name;
-    }
+	/**
+	 * Gets the name of the function argument.
+	 * 
+	 * @return the name of the argument.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSRegisterVariable typedObject = (FSRegisterVariable)anObject;
-            
-            result = index == typedObject.index;
-            result = result &amp;&amp; name.equals(typedObject.name);
-        }
-        return result;
-    }
+	/**
+	 * Sets the number of the register that will contain the function argument.
+	 * 
+	 * @param index
+	 *            the number of the register, 1..255, in which the function
+	 *            argument will be stored, 0 if the argument will be stored in a
+	 *            local variable.
+	 */
+	public void setIndex(int index)
+	{
+		this.index = index;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	/**
+	 * Sets the name of the function argument.
+	 * 
+	 * @param name
+	 *            the name of the argument.
+	 */
+	public void setName(String name)
+	{
+		this.name = name;
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;index&quot;, index);
-            Transform.append(buffer, &quot;name&quot;, name);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public int length(FSCoder coder)
-    {
-        int length = 1;
-        
-        length += coder.strlen(name, true);
+		if (super.equals(anObject))
+		{
+			FSRegisterVariable typedObject = (FSRegisterVariable) anObject;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(index, 1);
-        coder.writeString(name);
-        coder.writeWord(0, 1);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        index = coder.readWord(1, false);
-        name = coder.readString();
-    }
+			result = index == typedObject.index;
+			result = result &amp;&amp; name.equals(typedObject.name);
+		}
+		return result;
+	}
+
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
+
+		buffer.append(&quot;FSRegisterVariable: { &quot;);
+		buffer.append(&quot;index = &quot;).append(index).append(&quot;; &quot;);
+		buffer.append(&quot;name = &quot;).append(name).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+
+		return buffer.toString();
+	}
+
+	public int length(FSCoder coder)
+	{
+		int length = 1;
+
+		length += coder.strlen(name, true);
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(index, 1);
+		coder.writeString(name);
+		coder.writeWord(0, 1);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		index = coder.readByte();
+		name = coder.readString();
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,183 +31,230 @@
 package com.flagstone.transform;
 
 /**
-FSRemoveObject removes an object from the Flash Player's Display List. 
+ * FSRemoveObject removes an object from the Flash Player's Display List.
+ * 
+ * &lt;p&gt;
+ * An object placed on the display list is displayed in every frame of a movie
+ * until it is explicitly removed. Objects must also be removed if its location
+ * or appearance is changed using either the FSPlaceObject or FSPlaceObject2
+ * classes.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier, in the range 1..65535, of the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The layer at which the object is placed in the Display List.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although only one object can be placed on any layer in the display list both
+ * the object's unique identifier and the layer number must be specified. The
+ * FSRemoveObject class is superseded in Flash 3 by the FSRemoveObject2 class
+ * which lifts this requirement allowing an object to be referenced by the layer
+ * number it occupies in the display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Remove an object.&lt;br/&gt; To remove an object from the display list the
+ * object's identifier and the layer number using when the object was placed is
+ * used.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Place a shape to the display list for one frame.
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // now remove it.
+ * movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Move an object.&lt;br/&gt; To move an object it first must be removed from the
+ * display list and repositioned at its new location. Adding the object, with a
+ * new location, on the same layer, although only one object can be displayed on
+ * a given layer, will not work. The object will be displayed twice.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Move shape to a new location, removing the original so it does not get displayed twice.
+ * movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRemoveObject class represents the RemoveObject tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1 and is
+ * superseded by the RemoveObject2 tag which was added in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSRemoveObject extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;p&gt;An object placed on the display list is displayed in every frame of a movie until it is explicitly removed. Objects must also be removed if its location or appearance is changed using either the FSPlaceObject or FSPlaceObject2 classes.&lt;/p&gt;
+	private int layer = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSRemoveObject object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRemoveObject(FSCoder coder)
+	{
+		super(FSMovieObject.RemoveObject);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSRemoveObject object that will remove an object with the
+	 * specified identifier from the given layer in the display list.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object currently on the display
+	 *            list.
+	 * @param layer
+	 *            the layer in the display list where the object is being
+	 *            displayed.
+	 */
+	public FSRemoveObject(int anIdentifier, int layer)
+	{
+		super(FSMovieObject.RemoveObject);
+		setIdentifier(anIdentifier);
+		setLayer(layer);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSRemoveobject_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSRemoveObject object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSRemoveObject object.
+	 */
+	public FSRemoveObject(FSRemoveObject obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		layer = obj.layer;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveobject_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier, in the range 1..65535, of the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the object to be removed from the display list.
+	 * 
+	 * @return the identifier of the object to be removed.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveobject_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The layer at which the object is placed in the Display List.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the layer in the display list where the object will be displayed.
+	 * 
+	 * @return the layer number where the object to be removed is displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;p&gt;Although only one object can be placed on any layer in the display list both the object's unique identifier and the layer number must be specified. The FSRemoveObject class is superseded in Flash 3 by the FSRemoveObject2 class which lifts this requirement allowing an object to be referenced by the layer number it occupies in the display list.&lt;/p&gt;
+	/**
+	 * Sets the identifier of the object to be removed.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object currently on the display
+	 *            list.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the layer in the display list where the object will be displayed.
+	 * 
+	 * @param aLayer
+	 *            the layer in the display list where the object is being
+	 *            displayed.
+	 */
+	public void setLayer(int aLayer)
+	{
+		layer = aLayer;
+	}
 
-&lt;p&gt;1. Remove an object.&lt;br/&gt;
-To remove an object from the display list the object's identifier and the layer number using when the object was placed is used.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-// Place a shape to the display list for one frame.
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
+		if (super.equals(anObject))
+		{
+			FSRemoveObject typedObject = (FSRemoveObject) anObject;
 
-// now remove it.
-movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; layer == typedObject.layer;
+		}
+		return result;
+	}
 
-&lt;p&gt;2. Move an object.&lt;br/&gt;
-To move an object it first must be removed from the display list and repositioned at its new location. Adding the object, with a new location, on the same layer, although only one object can be displayed on a given layer, will not work. The object will be displayed twice.&lt;/p&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
+		buffer.append(&quot;FSRemoveObject: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;layer = &quot;).append(layer).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-// Move shape to a new location, removing the original so it does not get displayed twice.
-movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		return buffer.toString();
+	}
 
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 4;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		return length;
+	}
 
-&lt;p&gt;The FSRemoveObject class represents the RemoveObject tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1 and is superseded by the RemoveObject2 tag which was added in Flash 3.&lt;/p&gt;
- */
-public class FSRemoveObject extends FSMovieObject
-{
-    private int identifier = 0;
-    private int layer = 0;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(identifier, 2);
+		coder.writeWord(layer, 2);
+	}
 
-    /**
-     * Construct an FSRemoveObject object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRemoveObject(FSCoder coder)
-    {
-        super(FSMovieObject.RemoveObject);
-        decode(coder);
-    }
-    /**  Constructs an FSRemoveObject object that will remove an object with the specified identifier from the given layer in the display list.
-
-        @param anIdentifier the unique identifier for the object currently on the display list.
-        @param layer the layer in the display list where the object is being displayed.
-        */
-    public FSRemoveObject(int anIdentifier, int layer)
-    {
-        super(FSMovieObject.RemoveObject);
-        setIdentifier(anIdentifier);
-        setLayer(layer);
-    }
-    /**
-     * Constructs an FSRemoveObject object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSRemoveObject object.
-     */
-    public FSRemoveObject(FSRemoveObject obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        layer = obj.layer;
-    }    
-
-    /** Gets the identifier of the object to be removed from the display list.
-
-        @return the identifier of the object to be removed.
-        */
-    public int getIdentifier() { return identifier; }
-
-    /** Gets the layer in the display list where the object will be displayed.
-
-        @return the layer number where the object to be removed is displayed.
-        */
-    public int getLayer() { return layer; }
-
-    /** Sets the identifier of the object to be removed.
-
-        @param anIdentifier the unique identifier for the object currently on the display list.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-
-    /** Sets the layer in the display list where the object will be displayed.
-
-        @param aLayer the layer in the display list where the object is being displayed.
-        */
-    public void setLayer(int aLayer)
-    {
-        layer = aLayer;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSRemoveObject typedObject = (FSRemoveObject)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; layer == typedObject.layer;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 4;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(identifier, 2);
-        coder.writeWord(layer, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        identifier = coder.readWord(2, false);
-        layer = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		identifier = coder.readWord(2, false);
+		layer = coder.readWord(2, false);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSRemoveObject2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,125 +31,147 @@
 package com.flagstone.transform;
 
 /**
-FSRemoveObject2 removes an object from the display list.
+ * FSRemoveObject2 removes an object from the display list.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The number of the layer in the Flash Player's Display List where the
+ * object is displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRemoveObject2 class only requires the layer number to identify a
+ * particular object, unlike the FSRemoveObject class which also requires the
+ * object's identifier although only one object can be placed on a given layer.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRemoveObject2 class represents the RemoveObject2 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSRemoveObject2 extends FSMovieObject
+{
+	private int layer = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSRemoveObject2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRemoveObject2(FSCoder coder)
+	{
+		super(RemoveObject2);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSRemoveObject2, specifying the layer in the display list
+	 * where the object to be removed is currently displayed.
+	 * 
+	 * @param layer
+	 *            the layer number on which the object is displayed.
+	 */
+	public FSRemoveObject2(int layer)
+	{
+		super(RemoveObject2);
+		setLayer(layer);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveObject2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSRemoveObject2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSRemoveObject2 object.
+	 */
+	public FSRemoveObject2(FSRemoveObject2 obj)
+	{
+		super(obj);
+		layer = obj.layer;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveObject2_1&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the layer in the Flash Player's Display List where the object is displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the layer in the display list where the object to be removed is
+	 * currently displayed.
+	 * 
+	 * @return the layer number where the object is currently displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the layer in the display list from which the object will be removed.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is displayed.
+	 */
+	public void setLayer(int aLayer)
+	{
+		layer = aLayer;
+	}
 
-&lt;p&gt;The FSRemoveObject2 class only requires the layer number to identify a particular object, unlike the FSRemoveObject class which also requires the object's identifier although only one object can be placed on a given layer.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSRemoveObject2 typedObject = (FSRemoveObject2) anObject;
 
-&lt;p&gt;The FSRemoveObject2 class represents the RemoveObject2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash in Flash 3.&lt;/p&gt;
- */ 
-public class FSRemoveObject2 extends FSMovieObject
-{
-    private int layer = 0;
+			result = layer == typedObject.layer;
+		}
+		return result;
+	}
 
-    /**
-     * Construct an FSRemoveObject2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRemoveObject2(FSCoder coder)
-    {
-        super(RemoveObject2);
-        decode(coder);
-    }
-    /** Constructs an FSRemoveObject2, specifying the layer in the display list where the object to be removed is currently displayed.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param layer the layer number on which the object is displayed.
-        */
-    public FSRemoveObject2(int layer)
-    {
-        super(RemoveObject2);
-        setLayer(layer);
-    }
-    /**
-     * Constructs an FSRemoveObject2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSRemoveObject2 object.
-     */
-    public FSRemoveObject2(FSRemoveObject2 obj)
-    {
-        super(obj);
-        layer = obj.layer;
-    }    
+		buffer.append(&quot;FSRemoveObject2: { &quot;);
+		buffer.append(&quot;layer = &quot;).append(layer).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Gets the layer in the display list where the object to be removed is currently displayed.
+		return buffer.toString();
+	}
 
-        @return the layer number where the object is currently displayed.
-        */
-    public int getLayer() { return layer; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 2;
 
-    /** Sets the layer in the display list from which the object will be removed.
+		return length;
+	}
 
-        @param aLayer the layer number on which the object is displayed.
-        */
-    public void setLayer(int aLayer)
-    {
-        layer = aLayer;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(layer, 2);
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSRemoveObject2 typedObject = (FSRemoveObject2)anObject;
-            
-            result = layer == typedObject.layer;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 2;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(layer, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        layer = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		layer = coder.readWord(2, false);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSScreenVideoPacket.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSScreenVideoPacket.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSScreenVideoPacket.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,251 +33,259 @@
 import java.util.Iterator;
 
 /**
- * The FSScreenVideoPacket class is used to encode or decode a frame of video data using 
- * Macromedia's ScreenVideo format.
+ * The FSScreenVideoPacket class is used to encode or decode a frame of video
+ * data using Macromedia's ScreenVideo format.
  * 
  */
 public final class FSScreenVideoPacket implements Cloneable
 {
-    private boolean keyFrame;
-    private int codec;
-    
-    private int blockWidth;
-    private int blockHeight;
+	private boolean keyFrame;
 
-    private int imageWidth;
-    private int imageHeight;
-    
-    private ArrayList imageBlocks;
+	private int codec;
 
+	private int blockWidth;
+
+	private int blockHeight;
+
+	private int imageWidth;
+
+	private int imageHeight;
+
+	private ArrayList imageBlocks;
+
 	public FSScreenVideoPacket(byte[] data)
 	{
 		decode(data);
 	}
 
-    public FSScreenVideoPacket(boolean key, int codec, int imageWidth, int imageHeight, int blockWidth, int blockHeight, ArrayList blocks)
+	public FSScreenVideoPacket(boolean key, int codec, int imageWidth,
+								int imageHeight, int blockWidth,
+								int blockHeight, ArrayList blocks)
 	{
-    	setKeyFrame(key);
-    	setCodec(codec);
-        setImageWidth(imageWidth);
-        setImageHeight(imageHeight);
-        setBlockWidth(blockWidth);
-        setBlockHeight(blockHeight);
-        setImageBlocks(blocks);
+		setKeyFrame(key);
+		setCodec(codec);
+		setImageWidth(imageWidth);
+		setImageHeight(imageHeight);
+		setBlockWidth(blockWidth);
+		setBlockHeight(blockHeight);
+		setImageBlocks(blocks);
 	}
-    
-    public void add(FSImageBlock block)
-    {
-        imageBlocks.add(block);
-    }
 
-	public boolean getKeyFrame() 
-    {
-        return keyFrame; 
-    }
+	public void add(FSImageBlock block)
+	{
+		imageBlocks.add(block);
+	}
 
-	public void setKeyFrame(boolean key) 
-    {
-        keyFrame = key; 
-    }
+	public boolean getKeyFrame()
+	{
+		return keyFrame;
+	}
 
-	public int getCodec() 
-    {
-        return codec; 
-    }
+	public void setKeyFrame(boolean key)
+	{
+		keyFrame = key;
+	}
 
-	public void setCodec(int codec) 
-    {
-        this.codec = codec; 
-    }
+	public int getCodec()
+	{
+		return codec;
+	}
 
-	public int getImageWidth() 
-    {
-        return imageWidth; 
-    }
+	public void setCodec(int codec)
+	{
+		this.codec = codec;
+	}
 
-	public void setImageWidth(int width) 
-    {
-        imageWidth = width; 
-    }
+	public int getImageWidth()
+	{
+		return imageWidth;
+	}
 
-    public int getImageHeight() 
-    { 
-        return imageHeight; 
-    }
+	public void setImageWidth(int width)
+	{
+		imageWidth = width;
+	}
 
-	public void setImageHeight(int height) 
-    {
-        imageHeight = height; 
-    }
+	public int getImageHeight()
+	{
+		return imageHeight;
+	}
 
-	public int getBlockWidth() 
-    {
-        return blockWidth; 
-    }
+	public void setImageHeight(int height)
+	{
+		imageHeight = height;
+	}
 
-	public void setBlockWidth(int width) 
-    {
-        blockWidth = width; 
-    }
+	public int getBlockWidth()
+	{
+		return blockWidth;
+	}
 
-    public int getBlockHeight() 
-    { 
-        return blockHeight; 
-    }
+	public void setBlockWidth(int width)
+	{
+		blockWidth = width;
+	}
 
-	public void setBlockHeight(int height) 
-    {
-        blockHeight = height; 
-    }
+	public int getBlockHeight()
+	{
+		return blockHeight;
+	}
 
-    public ArrayList getImageBlocks() 
-    { 
-        return imageBlocks; 
-    }
+	public void setBlockHeight(int height)
+	{
+		blockHeight = height;
+	}
 
-	public void setImageBlocks(ArrayList blocks) 
-    {
-        imageBlocks = new ArrayList(blocks); 
-    }
+	public ArrayList getImageBlocks()
+	{
+		return imageBlocks;
+	}
 
-    public Object clone()
+	public void setImageBlocks(ArrayList blocks)
 	{
-        FSScreenVideoPacket anObject = null;
-        
-        try
-        {
-            anObject = (FSScreenVideoPacket)super.clone();
-        
-            anObject.imageBlocks = new ArrayList();
-			
-            for (Iterator i = imageBlocks.iterator(); i.hasNext();)
-                anObject.imageBlocks.add(((FSImageBlock)i.next()).clone());
-	    }
-	    catch (CloneNotSupportedException e)
-	    {
-            throw new InternalError();
-	    }
+		imageBlocks = new ArrayList(blocks);
+	}
+
+	public Object clone()
+	{
+		FSScreenVideoPacket anObject = null;
+
+		try
+		{
+			anObject = (FSScreenVideoPacket) super.clone();
+
+			anObject.imageBlocks = new ArrayList();
+
+			for (Iterator i = imageBlocks.iterator(); i.hasNext();)
+				anObject.imageBlocks.add(((FSImageBlock) i.next()).clone());
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
 		{
-			FSScreenVideoPacket typedObject = (FSScreenVideoPacket)anObject;
-			
-            result = keyFrame == typedObject.keyFrame;
-            result = result &amp;&amp; codec == typedObject.codec;
-            result = result &amp;&amp; imageWidth == typedObject.imageWidth;
-            result = result &amp;&amp; imageHeight == typedObject.imageHeight;
-            result = result &amp;&amp; blockHeight == typedObject.blockHeight;
-            result = result &amp;&amp; blockWidth == typedObject.blockWidth;
-            result = result &amp;&amp; imageBlocks.equals(typedObject.imageBlocks);	
-        }
+			FSScreenVideoPacket typedObject = (FSScreenVideoPacket) anObject;
+
+			result = keyFrame == typedObject.keyFrame;
+			result = result &amp;&amp; codec == typedObject.codec;
+			result = result &amp;&amp; imageWidth == typedObject.imageWidth;
+			result = result &amp;&amp; imageHeight == typedObject.imageHeight;
+			result = result &amp;&amp; blockHeight == typedObject.blockHeight;
+			result = result &amp;&amp; blockWidth == typedObject.blockWidth;
+			result = result &amp;&amp; imageBlocks.equals(typedObject.imageBlocks);
+		}
 		return result;
-    }
+	}
 
-    private int length()
+	private int length()
 	{
 		int length = 5;
-        
-        FSImageBlock block;
-        
-		for (Iterator i = imageBlocks.iterator(); i.hasNext();) 
+
+		FSImageBlock block;
+
+		for (Iterator i = imageBlocks.iterator(); i.hasNext();)
 		{
-			block = (FSImageBlock)i.next();
-			
+			block = (FSImageBlock) i.next();
+
 			length += 2;
 
-			if (!block.isEmpty()) {
+			if (!block.isEmpty())
+			{
 				length += block.getData().length;
 			}
-        }
+		}
 		return length;
 	}
 
 	public byte[] encode()
 	{
-        byte[] data = new byte[length()];
-        
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
-    
-        coder.writeBits(keyFrame ? FSVideo.KeyFrame : FSVideo.Frame, 4);
-        coder.writeBits(codec, 4);
-        
-        coder.writeBits((blockWidth/16)-1, 4);
-        coder.writeBits(imageWidth, 12);
-        coder.writeBits((blockHeight/16)-1, 4);
-        coder.writeBits(imageHeight, 12);
-        
-        FSImageBlock block;
-        byte[] blockData;
+		byte[] data = new byte[length()];
 
-        for (Iterator i=imageBlocks.iterator(); i.hasNext();) 
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
+
+		coder.writeBits(keyFrame ? FSVideo.KeyFrame : FSVideo.Frame, 4);
+		coder.writeBits(codec, 4);
+
+		coder.writeBits((blockWidth / 16) - 1, 4);
+		coder.writeBits(imageWidth, 12);
+		coder.writeBits((blockHeight / 16) - 1, 4);
+		coder.writeBits(imageHeight, 12);
+
+		FSImageBlock block;
+		byte[] blockData;
+
+		for (Iterator i = imageBlocks.iterator(); i.hasNext();)
 		{
-			block = (FSImageBlock)i.next();
-			
-			if (block.isEmpty()) {
-		        coder.writeWord(0, 2);
-			}
-			else {
+			block = (FSImageBlock) i.next();
+
+			if (block.isEmpty())
+			{
+				coder.writeWord(0, 2);
+			} else
+			{
 				blockData = block.getData();
-		        coder.writeBits(blockData.length, 16);
-		        coder.writeBytes(blockData);				
+				coder.writeBits(blockData.length, 16);
+				coder.writeBytes(blockData);
 			}
-        }
-		
-        return coder.getData();
+		}
+
+		return coder.getData();
 	}
-	
+
 	public void decode(byte[] data)
-	{        
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
-        
-        keyFrame = coder.readBits(4, false) == 1 ? true : false;
-        codec = coder.readBits(4, false);
-        
-        blockWidth = (coder.readBits(4, false) + 1) * 16;
-        imageWidth = coder.readBits(12, false);
-        blockHeight = (coder.readBits(4, false) + 1) * 16;
-        imageHeight = coder.readBits(12, false);
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
 
-        int columns = imageWidth / blockWidth + ((imageWidth % blockWidth &gt; 0) ? 1 : 0);
-        int rows = imageHeight / blockHeight + ((imageHeight % blockHeight &gt; 0) ? 1 : 0);
-        
-        int height = imageHeight;
-        int width = imageWidth;
-        
-        imageBlocks = new ArrayList(rows*columns);
-        FSImageBlock block;
+		keyFrame = coder.readBits(4, false) == 1 ? true : false;
+		codec = coder.readBits(4, false);
 
-        for (int i=0; i&lt;rows; i++, height -= blockHeight)
-        {
-            for (int j=0; j&lt;columns; j++, width -= blockWidth)
-            {
-                int length = coder.readBits(16, false);
-                
-                if (length != 0)
-                {
-                    byte[] blockData = new byte[length];
-                    
-                    coder.readBytes(blockData);
-                    
-                    int dataHeight = (height &lt; blockHeight) ? height : blockHeight;
-                    int dataWidth = (width &lt; blockWidth) ? width : blockWidth;
-            
-                    block = new FSImageBlock(dataHeight, dataWidth, blockData);
-                }
-                else 
-                {
-                	block = new FSImageBlock(0, 0, null);
-                }
-        
-                imageBlocks.add(block);
-            }
-        }
+		blockWidth = (coder.readBits(4, false) + 1) * 16;
+		imageWidth = coder.readBits(12, false);
+		blockHeight = (coder.readBits(4, false) + 1) * 16;
+		imageHeight = coder.readBits(12, false);
+
+		int columns = imageWidth / blockWidth
+						+ ((imageWidth % blockWidth &gt; 0) ? 1 : 0);
+		int rows = imageHeight / blockHeight
+						+ ((imageHeight % blockHeight &gt; 0) ? 1 : 0);
+
+		int height = imageHeight;
+		int width = imageWidth;
+
+		imageBlocks = new ArrayList(rows * columns);
+		FSImageBlock block;
+
+		for (int i = 0; i &lt; rows; i++, height -= blockHeight)
+		{
+			for (int j = 0; j &lt; columns; j++, width -= blockWidth)
+			{
+				int length = coder.readBits(16, false);
+
+				if (length != 0)
+				{
+					byte[] blockData = new byte[length];
+
+					coder.readBytes(blockData);
+
+					int dataHeight = (height &lt; blockHeight) ? height
+									: blockHeight;
+					int dataWidth = (width &lt; blockWidth) ? width : blockWidth;
+
+					block = new FSImageBlock(dataHeight, dataWidth, blockData);
+				} else
+				{
+					block = new FSImageBlock(0, 0, null);
+				}
+
+				imageBlocks.add(block);
+			}
+		}
 	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSerialNumber.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSerialNumber.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSerialNumber.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,136 +31,153 @@
 package com.flagstone.transform;
 
 /**
-FSSerialNumber is used to add a user-defined serial number into a Flash file. 
- 
-&lt;p&gt;The serial number is simply a string and can contain arbitrary information.&lt;/p&gt;
+ * FSSerialNumber is used to add a user-defined serial number into a Flash file.
+ * 
+ * &lt;p&gt;
+ * The serial number is simply a string and can contain arbitrary information.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;serialNumber&lt;/td&gt;
+ * &lt;td&gt;A string containing the serial number.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSSerialNumber(&quot;1234-DGF-2354&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSerialNumber represents the SerialNumber tag in the Macromedia Flash
+ * (SWF) File Format Specification. It is not known when this tag was
+ * introduced.
+ * &lt;/p&gt;
+ */
+public class FSSerialNumber extends FSMovieObject
+{
+	private String serialNumber = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSerialNumber object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSerialNumber(FSCoder coder)
+	{
+		super(SerialNumber);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSerialNumber action with the specified string.
+	 * 
+	 * @param aString
+	 *            an arbitrary string containing the serial number.
+	 */
+	public FSSerialNumber(String aString)
+	{
+		super(SerialNumber);
+		setSerialNumber(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSerialNumber_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSerialNumber object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSerialNumber object.
+	 */
+	public FSSerialNumber(FSSerialNumber obj)
+	{
+		super(obj);
+		serialNumber = new String(obj.serialNumber);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSerialNumber_1&quot;&gt;serialNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A string containing the serial number.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the serial number.
+	 * 
+	 * @return the serial number string.
+	 */
+	public String getSerialNumber()
+	{
+		return serialNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	/**
+	 * Sets the serial number.
+	 * 
+	 * @param aString
+	 *            an arbitrary string containing the serial number.
+	 */
+	public void setSerialNumber(String aString)
+	{
+		serialNumber = aString;
+	}
 
-&lt;pre&gt;
-movie.add(new FSSerialNumber(&quot;1234-DGF-2354&quot;));
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSSerialNumber typedObject = (FSSerialNumber) anObject;
 
-&lt;p&gt;The FSSerialNumber represents the SerialNumber tag in the Macromedia Flash (SWF) File Format Specification. It is not known when this tag was introduced.&lt;/p&gt;
- */  
-public class FSSerialNumber extends FSMovieObject
-{
-    private String serialNumber = null;
-    
-    /**
-     * Construct an FSSerialNumber object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSerialNumber(FSCoder coder)
-    {
-        super(SerialNumber);
-        decode(coder);
-    }
-    /** Constructs an FSSerialNumber action with the specified string. 
+			if (serialNumber != null)
+				result = serialNumber.equals(typedObject.serialNumber);
+			else
+				result = serialNumber == typedObject.serialNumber;
+		}
+		return result;
+	}
 
-        @param aString an arbitrary string containing the serial number.
-        */
-    public FSSerialNumber(String aString)
-    {
-        super(SerialNumber);
-        setSerialNumber(aString);
-    }
-    /**
-     * Constructs an FSSerialNumber object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSerialNumber object.
-     */
-    public FSSerialNumber(FSSerialNumber obj)
-    {
-        super(obj);
-        serialNumber = new String(obj.serialNumber);
-    }    
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Gets the serial number.
+		buffer.append(&quot;FSSerialNumber: { &quot;);
+		buffer.append(&quot;serialNumber = &quot;).append(serialNumber).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @return the serial number string.
-        */
-    public String getSerialNumber() { return serialNumber; }
+		return buffer.toString();
+	}
 
-    /** Sets the serial number.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param aString an arbitrary string containing the serial number.
-        */
-    public void setSerialNumber(String aString)
-    {
-        serialNumber = aString;
-    } 
+		length += coder.strlen(serialNumber, true);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSerialNumber typedObject = (FSSerialNumber)anObject;
+		return length;
+	}
 
-            if (serialNumber != null)
-                result = serialNumber.equals(typedObject.serialNumber);
-            else
-                result = serialNumber == typedObject.serialNumber;
-        }
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeString(serialNumber);
+		coder.writeWord(0, 1);
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;serialNumber&quot;, serialNumber);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += coder.strlen(serialNumber, true);
-
-        return length;
-    }    
-
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-           coder.writeString(serialNumber);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        serialNumber = coder.readString(length-1);
-        coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		serialNumber = coder.readString(length - 1);
+		coder.readByte();
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSetBackgroundColor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSetBackgroundColor.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSetBackgroundColor.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,147 +31,175 @@
 package com.flagstone.transform;
 
 /**
-FSSetBackgroundColor sets the background colour displayed in every frame in the movie.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSSetBackgroundColor sets the background colour displayed in every frame in
+ * the movie.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;color&lt;/td&gt;
+ * &lt;td&gt;An FSColor object that defines the background colour.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although the colour is specified using an FSColor object the colour displayed
+ * is completely opaque - the alpha channel information in the object is
+ * ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The background colour must be set before the first frame is displayed
+ * otherwise the background colour defaults to white. This is typically the
+ * first object in a coder. If more than one FSSetBackgroundColor object is
+ * added to a movie then only first one sets the background colour. Subsequent
+ * objects are ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSMovie movie = new FSMovie();
+ * 
+ *  movie.setFrameSize(new FSBounds(0, 0, 8000, 8000)); // twips = 400 x 400 pixels
+ *  movie.setFrameRate(1.0f); 1 frame per second.
+ * 
+ *  movie.add(new FSSetBackgroundColor(new FSColor(0xAD, 0xD8, 0xE6))); // light blue
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSetBackgroundColor class represents the SetBackgroundColor tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSSetBackgroundColor extends FSMovieObject
+{
+	private FSColor color = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSSetBackgroundColor object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSetBackgroundColor(FSCoder coder)
+	{
+		super(FSMovieObject.SetBackgroundColor);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSetBackgroundColor_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetBackgroundColor object with a the specified colour.
+	 * 
+	 * @param aColor
+	 *            the colour for the background.
+	 */
+	public FSSetBackgroundColor(FSColor aColor)
+	{
+		super(FSMovieObject.SetBackgroundColor);
+		setColor(aColor);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSetBackgroundColor_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColor object that defines the background colour.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetBackgroundColor object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSSetBackgroundColor object.
+	 */
+	public FSSetBackgroundColor(FSSetBackgroundColor obj)
+	{
+		super(obj);
+		color = new FSColor(obj.color);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the colour for the movie background.
+	 * 
+	 * @return the FSColor object defining the movie's background colour.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-&lt;p&gt;Although the colour is specified using an FSColor object the colour displayed is completely opaque - the alpha channel information in the object is ignored.&lt;/p&gt;
+	/**
+	 * Sets the colour for the movie background.
+	 * 
+	 * @param aColor
+	 *            the colour for the background.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-&lt;p&gt;The background colour must be set before the first frame is displayed otherwise the background colour defaults to white. This is typically the first object in a coder. If more than one FSSetBackgroundColor object is added to a movie then only first one sets the background colour. Subsequent objects are ignored.&lt;/p&gt;
+	public Object clone()
+	{
+		FSSetBackgroundColor anObject = (FSSetBackgroundColor) super.clone();
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-movie.setFrameSize(new FSBounds(0, 0, 8000, 8000)); // twips = 400 x 400 pixels
-movie.setFrameRate(1.0f); 1 frame per second.
+		return anObject;
+	}
 
-movie.add(new FSSetBackgroundColor(new FSColor(0xAD, 0xD8, 0xE6))); // light blue
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSSetBackgroundColor typedObject = (FSSetBackgroundColor) anObject;
 
-&lt;p&gt;The FSSetBackgroundColor class represents the SetBackgroundColor tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSSetBackgroundColor extends FSMovieObject
-{
-    private FSColor color = null;
-    
-    /**
-     * Construct an FSSetBackgroundColor object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSetBackgroundColor(FSCoder coder)
-    {
-        super(FSMovieObject.SetBackgroundColor);
-        decode(coder);
-    }
-    /** Constructs an FSSetBackgroundColor object with a the specified colour.
+			if (color != null)
+				result = color.equals(typedObject.color);
+			else
+				result = color == typedObject.color;
+		}
+		return result;
+	}
 
-        @param aColor the colour for the background.
-        */
-    public FSSetBackgroundColor(FSColor aColor)
-    {
-        super(FSMovieObject.SetBackgroundColor);
-        setColor(aColor);
-    }
-    /**
-     * Constructs an FSSetBackgroundColor object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSSetBackgroundColor object.
-     */
-    public FSSetBackgroundColor(FSSetBackgroundColor obj)
-    {
-        super(obj);
-        color = new FSColor(obj.color);
-    }    
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Gets the colour for the movie background.
+		buffer.append(&quot;: { &quot;);
+		buffer.append(&quot;color = &quot;).append(color.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @return the FSColor object defining the movie's background colour.
-        */
-    public FSColor getColor() { return color; }
+		return buffer.toString();
+	}
 
-    /** Sets the colour for the movie background.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param aColor the colour for the background.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+		length += color.length(coder);
 
-    public Object clone()
-    {
-        FSSetBackgroundColor anObject = (FSSetBackgroundColor)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
-        
-        return anObject;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSetBackgroundColor typedObject = (FSSetBackgroundColor)anObject;
-            
-            if (color != null)
-                result = color.equals(typedObject.color);
-            else
-                result = color == typedObject.color;
-        }
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		color.encode(coder);
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += color.length(coder);
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        color.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        color = new FSColor(coder);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		color = new FSColor(coder);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSetTarget.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSetTarget.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSetTarget.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,141 +31,163 @@
 package com.flagstone.transform;
 
 /**
-FSSetTarget is used to control the time-line of a particular movie clip. 
- 
-&lt;p&gt;The action performs a &quot;context switch&quot;. All following actions such as GotoFrame, Play, etc. will be applied to the specified object until another &lt;b&gt;FSSetTarget&lt;/b&gt; action is executed. Setting the target to be the empty string (&quot;&quot;) returns the target to the movie's main timeline.&lt;/p&gt;
+ * FSSetTarget is used to control the time-line of a particular movie clip.
+ * 
+ * &lt;p&gt;
+ * The action performs a &quot;context switch&quot;. All following actions such as
+ * GotoFrame, Play, etc. will be applied to the specified object until another
+ * &lt;b&gt;FSSetTarget&lt;/b&gt; action is executed. Setting the target to be the empty
+ * string (&quot;&quot;) returns the target to the movie's main timeline.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;target&lt;/td&gt;
+ * &lt;td&gt;The name assigned to a movie clip. Names are assigned using the
+ * FSPlaceObject2 class when the movie clip is placed on the Flash Player's
+ * Display List.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Direct all subsequent actions to this movie clip
+ * 
+ *  actions.add(new FSSetTarget(&quot;/MovieClip:3&quot;));
+ *  ...
+ *  &lt;movie clip actions&gt;
+ *  ...
+ * 
+ *  // Restore the actions to the main movie timeline
+ * 
+ *  actions.add(new FSSetTarget(&quot;&quot;));
+ * &lt;/pre&gt;
+ * 
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSetTarget class represents the SetTarget action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSSetTarget extends FSActionObject
+{
+	private String target = &quot;&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSetTarget object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSetTarget(FSCoder coder)
+	{
+		super(SetTarget);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetTarget action that changes the context to the
+	 * specified target.
+	 * 
+	 * @param aString
+	 *            the name of a movie clip.
+	 */
+	public FSSetTarget(String aString)
+	{
+		super(SetTarget);
+		setTarget(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSetTarget_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetTarget object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSetTarget object.
+	 */
+	public FSSetTarget(FSSetTarget obj)
+	{
+		super(obj);
+		target = new String(obj.target);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSetTarget_1&quot;&gt;target&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name assigned to a movie clip. Names are assigned using the FSPlaceObject2 class when the movie clip is placed on the Flash Player's Display List.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the name of the target movie clip.
+	 * 
+	 * @return the name of the target movie clip.
+	 */
+	public String getTarget()
+	{
+		return target;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the name of the target movie clip.
+	 * 
+	 * @param aString
+	 *            the name of a movie clip.
+	 */
+	public void setTarget(String aString)
+	{
+		target = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-// Direct all subsequent actions to this movie clip
+		if (super.equals(anObject))
+			result = target.equals(((FSSetTarget) anObject).getTarget());
 
-actions.add(new FSSetTarget(&quot;/MovieClip:3&quot;));
-...
-&lt;movie clip actions&gt;
-...
+		return result;
+	}
 
-// Restore the actions to the main movie timeline
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-actions.add(new FSSetTarget(&quot;&quot;));
-&lt;/pre&gt;
+		buffer.append(&quot;FSSetTarget: { &quot;);
+		buffer.append(&quot;target = &quot;).append(target).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
+		return buffer.toString();
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;p&gt;The FSSetTarget class represents the SetTarget action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */ 
-public class FSSetTarget extends FSActionObject
-{
-    private String target = &quot;&quot;;
-    
-    /**
-     * Construct an FSSetTarget object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSetTarget(FSCoder coder)
-    {
-        super(SetTarget);
-        decode(coder);
-    }
-    /** Constructs an FSSetTarget action that changes the context to the specified target.
+		length += coder.strlen(target, true);
 
-        @param aString the name of a movie clip.
-        */
-    public FSSetTarget(String aString)
-    {
-        super(SetTarget);
-        setTarget(aString);
-    }
-    /**
-     * Constructs an FSSetTarget object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSetTarget object.
-     */
-    public FSSetTarget(FSSetTarget obj)
-    {
-        super(obj);
-        target = new String(obj.target);
-    }    
+		return length;
+	}
 
-    /** Gets the name of the target movie clip. 
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @return the name of the target movie clip.
-        */
-    public String getTarget() { return target; }
+		coder.writeString(target);
+		coder.writeWord(0, 1);
+	}
 
-    /** Sets the name of the target movie clip.
-
-        @param aString the name of a movie clip.
-        */
-    public void setTarget(String aString)
-    {
-        target = aString;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = target.equals(((FSSetTarget)anObject).getTarget());
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;target&quot;, target);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += coder.strlen(target, true);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-         coder.writeString(target);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        target = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		target = coder.readString();
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSShape.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSShape.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSShape.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,232 +33,260 @@
 import java.util.*;
 
 /**
-FSShape is a container for the shape objects (FSLine, FSCurve and FSShapeStyle objects) 
-that describe how a particular shape is drawn.
+ * FSShape is a container for the shape objects (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how a particular shape is drawn.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of shape (FSLine, FSCurve and FSShapeStyle) objects which are
+ * used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * FSShapes are used in shape and font definitions. The FSShape class is used to
+ * simplify the design of these classes and provides no added functionality
+ * other than acting as a container class.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSShape class represents the Shape record from the Macromedia Flash (SWF)
+ * File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSShape implements Cloneable, Codeable
+{
+	private ArrayList&lt;FSShapeObject&gt; objects = null;
+	private byte[] encodedObjects = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/*
+	 * This method is only used when lazily decoding shapes.
+	 */
+	FSShape(FSCoder coder, int length)
+	{
+		/*
+		 * This test is used to overcome a bug in SWFTool's pdf2swf where empty
+		 * glyphs are only encoded using 1 byte - should be 2.
+		 */
+		if (length &gt; 1)
+			encodedObjects = new byte[length];
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSShape_0&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of shape (FSLine, FSCurve and FSShapeStyle) objects which are used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSShape object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSShape(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;/table&gt;
-&lt;/p&gt;
+	/** Constructs an FSShape object with no shape objects. */
+	public FSShape()
+	{
+		objects = new ArrayList();
+	}
 
-&lt;p&gt;FSShapes are used in shape and font definitions. The FSShape class is used to simplify the design of these classes and provides no added functionality other than acting as a container class.&lt;/p&gt;
+	/**
+	 * Constructs an FSShape object, specifying the Objects that describe how
+	 * the shape is drawn.
+	 * 
+	 * @param anArray
+	 *            the array of shape records.
+	 */
+	public FSShape(ArrayList&lt;FSShapeObject&gt; anArray)
+	{
+		setObjects(anArray);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Constructs an FSShape object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSShape object.
+	 */
+	public FSShape(FSShape obj)
+	{
+		if (objects != null)
+		{
+			objects = new ArrayList&lt;FSShapeObject&gt;();
 
-&lt;p&gt;The FSShape class represents the Shape record from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSShape extends FSTransformObject
-{
-    private ArrayList objects = null;
-    private byte[] encodedObjects = null; 
+			for (Iterator&lt;FSShapeObject&gt; i = obj.objects.iterator(); i.hasNext();)
+				objects.add((FSShapeObject)i.next().clone());
+		} else
+		{
+			encodedObjects = Transform.clone(obj.encodedObjects);
+		}
+	}
 
-    /*
-     * This method is only used when lazily decoding shapes.
-     */
-    FSShape(FSCoder coder, int length)
-    {
-        /*
-         * This test is used to overcome a bug in SWFTool's pdf2swf where empty 
-         * glyphs are only encoded using 1 byte - should be 2.
-         */
-        if (length &gt; 1)
-            encodedObjects = new byte[length];
-        
-        decode(coder);
-    }
+	/**
+	 * Adds the object to the array of shape records.
+	 * 
+	 * @param anObject
+	 *            an instance of FSShapeStyle, FSLine or FSCurve.
+	 */
+	public void add(FSShapeObject anObject)
+	{
+		if (encodedObjects != null)
+		{
+			objects = FSShapeObject.decodeShape(encodedObjects);
+			encodedObjects = null;
+		}
+		objects.add(anObject);
+	}
 
-    /**
-     * Construct an FSShape object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSShape(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSShape object with no shape objects. */
-    public FSShape()
-    {
-        objects = new ArrayList();
-    }
-    /** Constructs an FSShape object, specifying the Objects that describe how the shape is drawn.
+	/**
+	 * Gets the array of shape records that define the shape.
+	 * 
+	 * @return the array of shape records.
+	 */
+	public ArrayList&lt;FSShapeObject&gt; getObjects()
+	{
+		if (encodedObjects != null)
+		{
+			objects = FSShapeObject.decodeShape(encodedObjects);
+			encodedObjects = null;
+		}
+		return objects;
+	}
 
-        @param anArray the array of shape records.
-        */
-    public FSShape(ArrayList anArray)
-    {
-        setObjects(anArray);
-    }
-    /**
-     * Constructs an FSShape object by copying values from an existing object.
-     *
-     * @param obj an FSShape object.
-     */
-    public FSShape(FSShape obj)
-    {
-        if (objects != null)
-        {
-            objects = new ArrayList();
-        
-            for (Iterator i = obj.objects.iterator(); i.hasNext();)
-                objects.add(((FSTransformObject)i.next()).clone());
-        }
-        else
-        {
-            encodedObjects = Transform.clone(obj.encodedObjects);
-        }
-    }
+	/**
+	 * Sets the array of shape records.
+	 * 
+	 * @param anArray
+	 *            the array of shape records.
+	 */
+	public void setObjects(ArrayList&lt;FSShapeObject&gt; anArray)
+	{
+		objects = anArray;
+	}
 
-    /** Adds the object to the array of shape records.
+	public Object clone()
+	{
+		FSShape anObject = null;
 
-        @param anObject an instance of FSShapeStyle, FSLine or FSCurve.
-        */
-    public void add(FSTransformObject anObject)
-    {
-        if (encodedObjects != null)
-        {
-            objects = FSMovie.decodeShape(encodedObjects);
-            encodedObjects = null;
-        }            
-        objects.add(anObject);
-     }
+		try
+		{
+			anObject = (FSShape)super.clone();
 
-    /** Gets the array of shape records that define the shape.
+			if (objects != null)
+			{
+				anObject.objects = new ArrayList&lt;FSShapeObject&gt;();
 
-        @return the array of shape records.
-        */
-    public ArrayList getObjects() 
-    {
-        if (encodedObjects != null)
-        {
-            objects = FSMovie.decodeShape(encodedObjects);
-            encodedObjects = null;
-        }
-        return objects;
-    }
+				for (Iterator&lt;FSShapeObject&gt; i = objects.iterator(); i.hasNext();)
+					anObject.objects.add((FSShapeObject)i.next().clone());
+			} else
+			{
+				anObject.encodedObjects = Transform.clone(encodedObjects);
+			}
+		} 
+		catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
 
-    /** Sets the array of shape records.
 
-        @param anArray the array of shape records.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		return anObject;
+	}
 
-    public Object clone()
-    {
-        FSShape anObject = (FSShape)super.clone();
-        
-        if (objects != null)
-        {
-            anObject.objects = new ArrayList();
-        
-            for (Iterator i = objects.iterator(); i.hasNext();)
-                anObject.objects.add(((FSTransformObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedObjects = Transform.clone(encodedObjects);
-        }
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        return anObject;
-    }
+		if (super.equals(anObject))
+		{
+			FSShape typedObject = (FSShape) anObject;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSShape typedObject = (FSShape)anObject;
-            
-            if (objects != null)
-                result = objects.equals(typedObject.objects);
-            else
-                result = objects == typedObject.objects;
-        }
-        return result;
-    }
+			if (objects != null)
+				result = objects.equals(typedObject.objects);
+			else
+				result = objects == typedObject.objects;
+		}
+		return result;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		buffer.append(&quot;: { &quot;);
+		buffer.append(&quot;objects = &quot;).append(objects.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 0;
-        
-        coder.context[FSCoder.NumberOfShapeBits] = numberOfBits;
-        
-        if (objects != null)
-        {
-            numberOfBits += 8;
-            
-            for (Iterator shapeIterator = objects.iterator(); shapeIterator.hasNext();) 
-                numberOfBits += ((FSTransformObject)shapeIterator.next()).length(coder);
-                
-            numberOfBits += 6; // Add size of end of shape
-        
-            numberOfBits += (numberOfBits % 8 &gt; 0) ? 8-(numberOfBits % 8) : 0;
-        }
-        else
-        {
-            numberOfBits += encodedObjects.length &lt;&lt; 3;
-        }
-        return numberOfBits&gt;&gt;3;
-    }
+		return buffer.toString();
+	}
 
-    public void encode(FSCoder coder)
-    {
-        if (objects != null)
-        {      
-            coder.writeBits(coder.context[FSCoder.NumberOfFillBits], 4);
-            coder.writeBits(coder.context[FSCoder.NumberOfLineBits], 4);
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 0;
 
-            for (Iterator shapeIterator = objects.iterator(); shapeIterator.hasNext();) 
-                ((FSTransformObject)shapeIterator.next()).encode(coder);
-        
-            coder.writeBits(0, 6); // End of shape
-            coder.alignToByte();
-        }
-        else
-        {
-            coder.writeBytes(encodedObjects);
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        if (encodedObjects != null)
-        {
-            coder.readBytes(encodedObjects);            
-        }
-        else
-        {
-            objects = FSMovie.decodeShape(coder);
-        }
-    }
+		coder.context[FSCoder.NumberOfShapeBits] = numberOfBits;
+
+		if (objects != null)
+		{
+			numberOfBits += 8;
+
+			for (Iterator shapeIterator = objects.iterator(); shapeIterator.hasNext();)
+				numberOfBits += ((Codeable) shapeIterator.next()).length(coder);
+
+			numberOfBits += 6; // Add size of end of shape
+
+			numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
+		} else
+		{
+			numberOfBits += encodedObjects.length &lt;&lt; 3;
+		}
+		return numberOfBits &gt;&gt; 3;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		if (objects != null)
+		{
+			coder.writeBits(coder.context[FSCoder.NumberOfFillBits], 4);
+			coder.writeBits(coder.context[FSCoder.NumberOfLineBits], 4);
+
+			for (Iterator shapeIterator = objects.iterator(); shapeIterator.hasNext();)
+				((Codeable) shapeIterator.next()).encode(coder);
+
+			coder.writeBits(0, 6); // End of shape
+			coder.alignToByte();
+		} else
+		{
+			coder.writeBytes(encodedObjects);
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		if (encodedObjects != null)
+		{
+			coder.readBytes(encodedObjects);
+		} else
+		{
+			objects = FSShapeObject.decodeShape(coder);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSShapeObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSShapeObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSShapeObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -32,7 +32,7 @@
 
 import java.util.ArrayList;
 
-public abstract class FSShapeObject
+public abstract class FSShapeObject implements Cloneable, Codeable
 {
 	static ArrayList&lt;FSShapeObject&gt; decodeShape(byte[] bytes)
 	{
@@ -71,4 +71,25 @@
 
 		return objects;
 	}
+
+
+	/**
+	 * Creates a deep copy of the entire object.
+	 * 
+	 * @return a copy of the object.
+	 */
+	public Object clone()
+	{
+		Object anObject = null;
+
+		try
+		{
+			anObject = super.clone();
+		} 
+		catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
+		return anObject;
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSShapeStyle.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSShapeStyle.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSShapeStyle.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -286,7 +286,7 @@
  * Flash (SWF) File Format Specification. It was introduced in Flash 1.
  * &lt;/p&gt;
  */
-public class FSShapeStyle extends FSShapeObject implements Cloneable, Codeable
+public class FSShapeStyle extends FSShapeObject
 {
 	private int moveX;
 	private int moveY;
@@ -717,34 +717,25 @@
 
 	public Object clone()
 	{
-		FSShapeStyle anObject;
+		FSShapeStyle style = (FSShapeStyle) super.clone();
 
-		try
+		if (fillStyles != null)
 		{
-			anObject = (FSShapeStyle) super.clone();
+			style.fillStyles = new ArrayList&lt;FSFillStyle&gt;();
 
-			if (fillStyles != null)
-			{
-				anObject.fillStyles = new ArrayList&lt;FSFillStyle&gt;();
+			for (Iterator&lt;FSFillStyle&gt; i = fillStyles.iterator(); i.hasNext();)
+				style.fillStyles.add((FSFillStyle)i.next().clone());
+		}
 
-				for (Iterator&lt;FSFillStyle&gt; i = fillStyles.iterator(); i.hasNext();)
-					anObject.fillStyles.add((FSFillStyle)i.next().clone());
-			}
-
-			if (lineStyles != null)
-			{
-				anObject.lineStyles = new ArrayList&lt;FSLineStyle&gt;();
-
-				for (Iterator&lt;FSLineStyle&gt; i = lineStyles.iterator(); i.hasNext();)
-					anObject.lineStyles.add((FSLineStyle) i.next().clone());
-			}
-		} 
-		catch (CloneNotSupportedException e)
+		if (lineStyles != null)
 		{
-			throw new InternalError();
+			style.lineStyles = new ArrayList&lt;FSLineStyle&gt;();
+
+			for (Iterator&lt;FSLineStyle&gt; i = lineStyles.iterator(); i.hasNext();)
+				style.lineStyles.add((FSLineStyle) i.next().clone());
 		}
 
-		return anObject;
+		return style;
 	}
 
 	/**

Deleted: dev/dev-2-4/src/com/flagstone/transform/FSSolidLine.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSolidLine.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSolidLine.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,222 +0,0 @@
-/*
- * FSSolidLine.java
- * Transform
- * 
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform;
-
-/**
-FSSolidLine defines the width and colour of a line that is used when drawing the outline of a shape.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSolidLine_0&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The width of the line drawn in twips.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSolidLine_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour used to draw the line.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;All lines are drawn with rounded corners and end caps. Different join and line end styles can be created by drawing line segments as a sequence of filled shapes. With 1 twip equal to 1/20th of a pixel this technique can easily be used to draw the narrowest of visible lines.&lt;/p&gt;
-
-&lt;p&gt;Whether the alpha channel in the colour is used is determined by the class used to define the shape. Transparent colours are only supported from Flash 3 onwards. Simply specifying the level of transparency in the FSColor object is not sufficient.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-
-&lt;pre&gt;
-FSSolidLine lineStyle = new FSSolidLine(20, new FSColor(0, 0, 0));
-&lt;/pre&gt;
-
-&lt;p&gt;Draws a black line, 1 pixel wide.&lt;/p&gt;
-
-&lt;pre&gt;
-FSSolidLine lineStyle = new FSSolidLine(20, new FSColor(255, 0, 0, 128));
-&lt;/pre&gt;
-
-&lt;p&gt;Draws a transparent red line, 1 pixel wide. If the alpha channel is not specified then the value defaults to 255 generating a completely opaque colour.&lt;/p&gt;
-
-&lt;p&gt;Flash only supports contiguous lines. Dashed line styles can be created by drawing the line as a series of short line segments by interspersing FSShapeStyle objects to move the current point in between the FSLine objects that draw the line segments.&lt;/p&gt;
-
-&lt;pre&gt;
-// define the line style
-lineStyles.add(new FSSolidLine(20, new FSColor(0, 0, 0)));
-
-// Select the line style
-shape.add(new FSShapeStyle(1, 0, 0));
-
-// Draw the dashed line with lines and gaps each 5 pixels long
-shape.add(new FSShapeStyle(1, 0, 0));
-
-for (int i=0; i&lt;10; i++)
-{
-    shape.add(new FSLine(100, 0));
-    shape.add(new FSShapeStyle(0, 0, 0));
-    shape.add(new FSLine(100, 0));
-}
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSSolidLine class represents the LineStyle structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1. Support for transparent colours was added in Flash 3.&lt;/p&gt;
- */
-public class FSSolidLine extends FSLineStyle
-{
-    private int width = 0;
-    private FSColor color = null;
-    
-    /**
-     * Construct an FSSolidLine object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSolidLine(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSSolidLine, specifying the width and colour of the line. 
-
-        @param aWidth the width of the line.
-        @param aColor the colour of the line.
-        */
-    public FSSolidLine(int aWidth, FSColor aColor)
-    {
-        setWidth(aWidth);
-        setColor(aColor);
-    }
-    /**
-     * Constructs an FSSolidLine object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSolidLine object.
-     */
-    public FSSolidLine(FSSolidLine obj)
-    {
-        width = obj.width;
-        color = new FSColor(obj.color);
-    }    
-
-    /**  Gets the width of the line.
-
-        @return the width of the line.
-        */
-    public int getWidth() 
-    {  
-        return width;
-    }
-
-    /** Gets the colour of the line.
-
-        @return the colour for the line.
-        */
-    public FSColor getColor() { return color; }
-
-    /** Sets the width of the line.
-
-        @param aNumber the width of the line.
-        */
-    public void setWidth(int aNumber)
-    {
-        width = aNumber;
-    }
-
-    /** Sets the colour of the line.
-
-        @param aColor the colour of the line.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
-
-    public Object clone()
-    {
-        FSSolidLine anObject = (FSSolidLine)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSolidLine typedObject = (FSSolidLine)anObject;
-            
-            result = width == typedObject.width;
-
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 2;
-    
-        length += color.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(width, 2);
-        color.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        width = coder.readWord(2, false);
-        color = new FSColor(coder);
-    }
-}

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSound.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSound.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSound.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,439 +33,605 @@
 import java.util.*;
 
 /**
-The FSSound class identifies a sound (previously defined using The FSDefineSound class) 
-and controls how it is played.
+ * The FSSound class identifies a sound (previously defined using The
+ * FSDefineSound class) and controls how it is played.
+ * 
+ * &lt;p&gt;
+ * FSSound defines how the sound fades in and out, whether it is repeated as
+ * well as specifying an envelope that provides a finer degree of control over
+ * the levels at which the sound is played.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the FSDefineSound object that
+ * contains the sound data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;mode&lt;/td&gt;
+ * &lt;td&gt;Controls how the sound is played, either: Start - start playing the
+ * sound, Continue - start playing the sound if it is not already playing and
+ * Stop - stop playing the sound.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;inPoint&lt;/td&gt;
+ * &lt;td&gt;The sample number that the sound increases in volume to until full
+ * volume is reached. Optional. Set to 0 if the sound does not fade in.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;outPoint&lt;/td&gt;
+ * &lt;td&gt;The sample number at which the that the sound starts to fades until the
+ * sound has finished playing. Optional. Set to 0 if the sound does not fade
+ * out.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;loopCount&lt;/td&gt;
+ * &lt;td&gt;The number of times the sound is repeated. Optional. Must be at least 1
+ * if a sound is being played. Set to 0 if a sound is being stopped.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;envelopes&lt;/td&gt;
+ * &lt;td&gt;An array of FSEnvelope objects that control how the sound is played.
+ * Optional. May be set to null or an empty array if no envelope is defined.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Not all the attributes are required to play a sound. Only the identifier and
+ * the mode is required. The other attributes are optional and may be added as a
+ * greater degree of control is required. The inPoint and outPoint attributes
+ * may be set to zero if the sound does not fade in or out respectively. The
+ * loopCount may be set to zero if a sound is being stopped. The envelopes array
+ * may be left empty if no envelope is defined for the sound. The class provides
+ * different constructors to specify different sets of attributes.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The in and out point specify the sample number which marks the point in time
+ * at which the sound stops increasing or starts decreasing in volume
+ * respectively. Sounds are played by the Flash player at 44.1KHz so the sample
+ * number also indicates the time when the total number of samples in the sound
+ * is taken into account.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSound class is based on the SoundInfo data structure from the
+ * Macromedia Flash (SWF) File Format Specification. However it also contains
+ * the identifier for the sound which is a separate attribute in the data
+ * structures defined in the specification that contain SoundInfo data.
+ * &lt;/p&gt;
+ */
+public class FSSound implements Cloneable, Codeable
+{
+	/**
+	 * Identifies an uncompressed pulse code modulated sound. The byte-order for
+	 * 16-bit sound samples is dependent on the host platform on which the sound
+	 * is played.
+	 */
+	public static final int NATIVE_PCM = 0;
 
-&lt;p&gt;FSSound defines how the sound fades in and out, whether it is repeated as well as specifying an envelope that provides a finer degree of control over the levels at which the sound is played.&lt;/p&gt;
+	/** Identifies an adaptive pulse code modulated sound. */
+	public static final int ADPCM = 1;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Identifies an MP3 format sound. */
+	public static final int MP3 = 2;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Identifies an uncompressed pulse code modulated sound, little-endian byte
+	 * order.
+	 */
+	public static final int PCM = 3;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_0&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the FSDefineSound object that contains the sound data.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 6
+	// / Identifies a Nellymoser Asao encoded sound.
+	public static final int NELLYMOSER = 6;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_1&quot;&gt;mode&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Controls how the sound is played, either: Start - start playing the sound, Continue - start playing the sound if it is not already playing and Stop - stop playing the sound.&lt;/td&gt;
-&lt;/tr&gt;
+	// End Flash 6
+	/** Start playing the sound. */
+	public static final int Start = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_2&quot;&gt;inPoint&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sample number that the sound increases in volume to until full volume is reached. Optional. Set to 0 if the sound does not fade in.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Start playing the sound or continues if it is already playing. */
+	public static final int Continue = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_3&quot;&gt;outPoint&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sample number at which the that the sound starts to fades until the sound has finished playing. Optional. Set to 0 if the sound does not fade out.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Stop playing the sound. */
+	public static final int Stop = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_4&quot;&gt;loopCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of times the sound is repeated. Optional. Must be at least 1 if a sound is being played. Set to 0 if a sound is being stopped.&lt;/td&gt;
-&lt;/tr&gt;
+	private int identifier = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_5&quot;&gt;envelopes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSEnvelope objects that control how the sound is played. Optional. May be set to null or an empty array if no envelope is defined.&lt;/td&gt;
-&lt;/tr&gt;
+	private int mode = 0;
 
-&lt;/table&gt;
+	private int inPoint = 0;
 
-&lt;p&gt;Not all the attributes are required to play a sound. Only the identifier and the mode is required. The other attributes are optional and may be added as a greater degree of control is required. The inPoint and outPoint attributes may be set to zero if the sound does not fade in or out respectively. The loopCount may be set to zero if a sound is being stopped. The envelopes array may be left empty if no envelope is defined for the sound. The class provides different constructors to specify different sets of attributes.&lt;/p&gt;
+	private int outPoint = 0;
 
-&lt;p&gt;The in and out point specify the sample number which marks the point in time at which the sound stops increasing or starts decreasing in volume respectively. Sounds are played by the Flash player at 44.1KHz so the sample number also indicates the time when the total number of samples in the sound is taken into account.&lt;/p&gt;
+	private int loopCount = 0;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	private ArrayList&lt;FSEnvelope&gt; envelopes = null;
 
-&lt;p&gt;The FSSound class is based on the SoundInfo data structure from the Macromedia Flash (SWF) File Format Specification. However it also contains the identifier for the sound which is a separate attribute in the data structures defined in the specification that contain SoundInfo data.&lt;/p&gt;
- */
-public class FSSound extends FSTransformObject
-{
-    /** Identifies an uncompressed pulse code modulated sound. The byte-order for 16-bit sound samples
-     is dependent on the host platform on which the sound is played. */
-    public static final int NATIVE_PCM = 0;
-    /** Identifies an adaptive pulse code modulated sound. */
-    public static final int ADPCM = 1;
-    /** Identifies an MP3 format sound. */
-    public static final int MP3 = 2;
-    /** Identifies an uncompressed pulse code modulated sound, little-endian byte order. */
-    public static final int PCM = 3;
-// Flash 6
-    /// Identifies a Nellymoser Asao encoded sound.
-    public static final int NELLYMOSER = 6;
-// End Flash 6
-    /** Start playing the sound. */
-    public static final int Start = 0;
-    /** Start playing the sound or continues if it is already playing. */
-    public static final int Continue = 1;
-    /** Stop playing the sound. */
-    public static final int Stop = 2;
+	/**
+	 * Construct an FSSound object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSound(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    private int identifier = 0;
-    private int mode = 0;
-    private int inPoint = 0;
-    private int outPoint = 0;
-    private int loopCount = 0;
-    private ArrayList envelopes = null;
+	/**
+	 * Constructs an FSSound object specifying how the sound is played.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Start - start playing the sound, Continue - do not play the
+	 *            sound if it is already playing and Stop - stop playing the
+	 *            sound.
+	 */
+	public FSSound(int anIdentifier, int aMode)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+	}
 
-    /**
-     * Construct an FSSound object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSound(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSSound object specifying how the sound is played.
+	/**
+	 * Constructs and FSSound object specifying how the sound is played and the
+	 * number of times the sound is repeated.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param aCount
+	 *            the number of times the sound is repeated. May be set to zero
+	 *            if the sound will not be repeated.
+	 */
+	public FSSound(int anIdentifier, int aMode, int aCount)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setLoopCount(aCount);
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Start - start playing the sound, Continue - do not play the sound if it is already playing and Stop - stop playing the sound.
-        */
-    public FSSound(int anIdentifier, int aMode)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-    }
+	/**
+	 * Constructs and FSSound object specifying how the sound is played and the
+	 * points at which the sound fades in and out.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param anInPoint
+	 *            the sample number which the sound fades in to. May be set to
+	 *            zero if the sound does not fade in.
+	 * @param anOutPoint
+	 *            the sample number at which the sound starts to fade. May be
+	 *            set to zero if the sound does not fade out.
+	 */
+	public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setInPoint(anInPoint);
+		setOutPoint(anOutPoint);
+	}
 
-    /** Constructs and FSSound object specifying how the sound is played and the number of times the sound is repeated.
+	/**
+	 * Constructs and FSSound object specifying how the sound is played, the
+	 * point at which the sound fades in and out and the number of times the
+	 * sound is repeated.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param anInPoint
+	 *            the sample number which the sound fades in to. May be set to
+	 *            zero if the sound does not fade in.
+	 * @param anOutPoint
+	 *            the sample number at which the sound starts to fade. May be
+	 *            set to zero if the sound does not fade out.
+	 * @param aCount
+	 *            the number of times the sound is repeated. May be set to zero
+	 *            if the sound will not be repeated.
+	 */
+	public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint,
+					int aCount)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setInPoint(anInPoint);
+		setOutPoint(anOutPoint);
+		setLoopCount(aCount);
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param aCount the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
-        */
-    public FSSound(int anIdentifier, int aMode, int aCount)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setLoopCount(aCount);
-    }
+	/**
+	 * Constructs and FSSound object specifying how the sound is played, the
+	 * point at which the sound fades in and out, the number of times the sound
+	 * is repeated and the envelopes used to control how the sound is played.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param anInPoint
+	 *            the sample number which the sound fades in to. May be set to
+	 *            zero if the sound does not fade in.
+	 * @param anOutPoint
+	 *            the sample number at which the sound starts to fade. May be
+	 *            set to zero if the sound does not fade out.
+	 * @param aCount
+	 *            the number of times the sound is repeated. May be set to zero
+	 *            if the sound will not be repeated.
+	 * @param anArray
+	 *            an array of FSEnvelope objects that define the levels at which
+	 *            a sound is played over the duration of the sound. May be set
+	 *            to NULL if no envelope is defined.
+	 */
+	public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint,
+					int aCount, ArrayList anArray)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setInPoint(anInPoint);
+		setOutPoint(anOutPoint);
+		setLoopCount(aCount);
+		setEnvelopes(anArray);
+	}
 
-    /** Constructs and FSSound object specifying how the sound is played and the points at which the sound fades in and out.
+	/**
+	 * Constructs an FSSound object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSSound object.
+	 */
+	public FSSound(FSSound obj)
+	{
+		identifier = obj.identifier;
+		mode = obj.mode;
+		inPoint = obj.inPoint;
+		outPoint = obj.outPoint;
+		loopCount = obj.loopCount;
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param anInPoint the sample number which the sound fades in to. May be set to zero if the sound does not fade in.
-        @param anOutPoint the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
-        */
-    public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setInPoint(anInPoint);
-        setOutPoint(anOutPoint);
-    }
+		envelopes = new ArrayList&lt;FSEnvelope&gt;();
 
-    /** Constructs and FSSound object specifying how the sound is played, the point at which the sound fades in and out and the number of times the sound is repeated.
+		for (Iterator&lt;FSEnvelope&gt; i = obj.envelopes.iterator(); i.hasNext();)
+			envelopes.add((FSEnvelope) i.next().clone());
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param anInPoint the sample number which the sound fades in to. May be set to zero if the sound does not fade in.
-        @param anOutPoint the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
-        @param aCount the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
-        */
-    public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint, int aCount)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setInPoint(anInPoint);
-        setOutPoint(anOutPoint);
-        setLoopCount(aCount);
-    }
+	/**
+	 * Add a FSEnvelope object to the array of envelope objects.
+	 * 
+	 * @param anEnvelope
+	 *            an FSEnvelope object.
+	 */
+	public void add(FSEnvelope anEnvelope)
+	{
+		envelopes.add(anEnvelope);
+	}
 
-    /** Constructs and FSSound object specifying how the sound is played, the point at which the sound fades in and out, the number of times the sound is repeated and the envelopes used to control how the sound is played.
+	/**
+	 * Gets the identifier of the sound to the played.
+	 * 
+	 * @return the sound identifier.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param anInPoint the sample number which the sound fades in to. May be set to zero if the sound does not fade in.
-        @param anOutPoint the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
-        @param aCount the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
-        @param anArray an array of FSEnvelope objects that define the levels at which a sound is played over the duration of the sound. May be set to NULL if no envelope is defined.
-        */
-    public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint, int aCount, ArrayList anArray)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setInPoint(anInPoint);
-        setOutPoint(anOutPoint);
-        setLoopCount(aCount);
-        setEnvelopes(anArray);
-    }
-    /**
-     * Constructs an FSSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSound object.
-     */
-    public FSSound(FSSound obj)
-    {
-        identifier = obj.identifier;
-        mode = obj.mode;
-        inPoint = obj.inPoint;
-        outPoint = obj.outPoint;
-        loopCount = obj.loopCount;
-        
-        envelopes = new ArrayList();
-        
-        for (Iterator i = obj.envelopes.iterator(); i.hasNext();)
-            envelopes.add(((FSEnvelope)i.next()).clone());        
-    }
+	/**
+	 * Gets the synchronisation mode: SyncNoMultiple - do not play the sound if
+	 * it is already playing and SyncStop - stop playing the sound.
+	 * 
+	 * @return the synchronisation mode of the sound.
+	 */
+	public int getMode()
+	{
+		return mode;
+	}
 
-    /** Add a FSEnvelope object to the array of envelope objects.
+	/**
+	 * Gets the sample number at which the sound reaches full volume when fading
+	 * in.
+	 * 
+	 * @return the in point
+	 */
+	public int getInPoint()
+	{
+		return inPoint;
+	}
 
-        @param anEnvelope an FSEnvelope object.
-        */
-    public void add(FSEnvelope anEnvelope) { envelopes.add(anEnvelope); }
+	/**
+	 * Gets the sample number at which the sound starts to fade.
+	 * 
+	 * @return the out point
+	 */
+	public int getOutPoint()
+	{
+		return outPoint;
+	}
 
-    /** Gets the identifier of the sound to the played.
+	/**
+	 * Gets the number of times the sound will be repeated.
+	 * 
+	 * @return the Loop Count.
+	 */
+	public int getLoopCount()
+	{
+		return loopCount;
+	}
 
-        @return the sound identifier.
-        */
-    public int getIdentifier() { return identifier; }
+	/**
+	 * Gets the array of FSEnvelope objects that control the levels the sound is
+	 * played.
+	 * 
+	 * @return an array of FSEnvelope objects.
+	 */
+	public ArrayList&lt;FSEnvelope&gt; getEnvelopes()
+	{
+		return envelopes;
+	}
 
-    /** Gets the synchronisation mode: SyncNoMultiple - do not play the sound if it is already playing and SyncStop - stop playing the sound.
+	/**
+	 * Sets the identifier of the sound to the played.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier for the sound to be played.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-        @return the synchronisation mode of the sound.
-        */
-    public int getMode() { return mode; }
+	/**
+	 * Sets how the sound is synchronised when the frames are displayed: Start -
+	 * start playing the sound, Continue - do not play the sound if it is
+	 * already playing and Stop - stop playing the sound.
+	 * 
+	 * @param aMode
+	 *            how the sound is played.
+	 */
+	public void setMode(int aMode)
+	{
+		mode = aMode;
+	}
 
-    /**
-        Gets the sample number at which the sound reaches full volume when fading in.
+	/**
+	 * Sets the sample number at which the sound reaches full volume when fading
+	 * in. May be set to zero if the sound does not fade in.
+	 * 
+	 * @param aNumber
+	 *            the sample number which the sound fades in to.
+	 */
+	public void setInPoint(int aNumber)
+	{
+		inPoint = aNumber;
+	}
 
-     @return the in point
-     */
-    public int getInPoint() { return inPoint; }
+	/**
+	 * Sets the sample number at which the sound starts to fade. May be set to
+	 * zero if the sound does not fade out.
+	 * 
+	 * @param aNumber
+	 *            the sample number at which the sound starts to fade.
+	 */
+	public void setOutPoint(int aNumber)
+	{
+		outPoint = aNumber;
+	}
 
-    /**
-        Gets the sample number at which the sound starts to fade.
+	/**
+	 * Sets the number of times the sound is repeated. May be set to zero if the
+	 * sound will not be repeated.
+	 * 
+	 * @param aNumber
+	 *            the number of times the sound is repeated.
+	 */
+	public void setLoopCount(int aNumber)
+	{
+		loopCount = aNumber;
+	}
 
-     @return the out point
-     */
-    public int getOutPoint() { return outPoint; }
+	/**
+	 * Sets the array of FSEnvelope objects that define the levels at which a
+	 * sound is played over the duration of the sound. May be set to null if no
+	 * envelope is defined.
+	 * 
+	 * @param anArray
+	 *            an array of FSEnvelope objects.
+	 */
+	public void setEnvelopes(ArrayList&lt;FSEnvelope&gt; anArray)
+	{
+		envelopes = anArray;
+	}
 
-    /**
-        Gets the number of times the sound will be repeated.
+	public Object clone()
+	{
+		FSSound anObject = null;
 
-     @return the Loop Count.
-     */
-    public int getLoopCount() { return loopCount; }
+		try {
+			anObject = (FSSound) super.clone();
 
-    /**
-        Gets the array of FSEnvelope objects that control the levels the sound is played.
+			anObject.envelopes = new ArrayList&lt;FSEnvelope&gt;();
 
-     @return an array of FSEnvelope objects.
-     */
-    public ArrayList getEnvelopes() { return envelopes; }
+			for (Iterator&lt;FSEnvelope&gt; i = envelopes.iterator(); i.hasNext();)
+				anObject.envelopes.add((FSEnvelope) i.next().clone());
+		} 
+		catch (CloneNotSupportedException e) {
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-    /** Sets the identifier of the sound to the played.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anIdentifier the identifier for the sound to be played.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		if (super.equals(anObject))
+		{
+			FSSound typedObject = (FSSound) anObject;
 
-    /** Sets how the sound is synchronised when the frames are displayed: Start - start playing the sound, Continue - do not play the sound if it is already playing and Stop - stop playing the sound.
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; mode == typedObject.mode;
+			result = result &amp;&amp; inPoint == typedObject.inPoint;
+			result = result &amp;&amp; outPoint == typedObject.outPoint;
+			result = result &amp;&amp; loopCount == typedObject.loopCount;
 
-        @param aMode how the sound is played.
-        */
-    public void setMode(int aMode)
-    {
-        mode = aMode;
-    }
+			if (envelopes != null)
+				result = result &amp;&amp; envelopes.equals(typedObject.envelopes);
+			else
+				result = result &amp;&amp; envelopes == typedObject.envelopes;
+		}
+		return result;
+	}
 
-    /** Sets the sample number at which the sound reaches full volume when fading in. May be set to zero if the sound does not fade in.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param aNumber the sample number which the sound fades in to.
-        */
-    public void setInPoint(int aNumber)
-    {
-        inPoint = aNumber;
-    }
+		buffer.append(&quot;FSSound: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;mode = &quot;).append(mode).append(&quot;; &quot;);
+		buffer.append(&quot;inPoint = &quot;).append(inPoint).append(&quot;; &quot;);
+		buffer.append(&quot;outPoint = &quot;).append(outPoint).append(&quot;; &quot;);
+		buffer.append(&quot;loopCount = &quot;).append(loopCount).append(&quot;; &quot;);
+		buffer.append(&quot;envelopes = &quot;).append(envelopes.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    /** Sets the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
+		return buffer.toString();
+	}
 
-     @param aNumber the sample number at which the sound starts to fade.
-     */
-    public void setOutPoint(int aNumber)
-    {
-        outPoint = aNumber;
-    }
+	public int length(FSCoder coder)
+	{
+		boolean _containsInPoint = containsInPoint();
+		boolean _containsOutPoint = containsOutPoint();
+		boolean _containsLoopCount = containsLoopCount();
+		boolean _containsEnvelopes = containsEnvelopes();
 
-    /** Sets the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
+		int length = 3;
 
-        @param aNumber the number of times the sound is repeated.
-        */
-    public void setLoopCount(int aNumber)
-    {
-        loopCount = aNumber;
-    }
+		length += (_containsInPoint) ? 4 : 0;
+		length += (_containsOutPoint) ? 4 : 0;
+		length += (_containsLoopCount) ? 2 : 0;
+		length += (_containsEnvelopes) ? 1 : 0;
+		length += (_containsEnvelopes) ? envelopes.size() * 8 : 0;
 
-    /** Sets the array of FSEnvelope objects that define the levels at which a sound is played over the duration of the sound. May be set to null if no envelope is defined.
+		return length;
+	}
 
-        @param anArray an array of FSEnvelope objects.
-        */
-    public void setEnvelopes(ArrayList anArray)
-    {
-        envelopes = anArray;
-    }
+	public void encode(FSCoder coder)
+	{
+		boolean _containsInPoint = containsInPoint();
+		boolean _containsOutPoint = containsOutPoint();
+		boolean _containsLoopCount = containsLoopCount();
+		boolean _containsEnvelopes = containsEnvelopes();
 
-    public Object clone()
-    {
-        FSSound anObject = (FSSound)super.clone();
-        
-        anObject.envelopes = new ArrayList();
-        
-        for (Iterator i = envelopes.iterator(); i.hasNext();)
-            anObject.envelopes.add(((FSEnvelope)i.next()).clone());
+		coder.writeWord(identifier, 2);
+		coder.writeBits(mode, 4);
+		coder.writeBits(_containsEnvelopes ? 1 : 0, 1);
+		coder.writeBits(_containsLoopCount ? 1 : 0, 1);
+		coder.writeBits(_containsOutPoint ? 1 : 0, 1);
+		coder.writeBits(_containsInPoint ? 1 : 0, 1);
 
-        return anObject;
-    }
+		if (_containsInPoint)
+			coder.writeWord(inPoint, 4);
+		if (_containsOutPoint)
+			coder.writeWord(outPoint, 4);
+		if (_containsLoopCount)
+			coder.writeWord(loopCount, 2);
+		if (_containsEnvelopes)
+		{
+			coder.writeWord(envelopes.size(), 1);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSound typedObject = (FSSound)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; mode == typedObject.mode;
-            result = result &amp;&amp; inPoint == typedObject.inPoint;
-            result = result &amp;&amp; outPoint == typedObject.outPoint;
-            result = result &amp;&amp; loopCount == typedObject.loopCount;
+			for (int i = 0; i &lt; envelopes.size(); i++)
+				envelopes.get(i).encode(coder);
+		}
+	}
 
-            if (envelopes != null)
-                result = result &amp;&amp; envelopes.equals(typedObject.envelopes);
-            else
-                result = result &amp;&amp; envelopes == typedObject.envelopes;
-        }
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		boolean _containsInPoint = false;
+		boolean _containsOutPoint = false;
+		boolean _containsLoopCount = false;
+		boolean _containsEnvelopes = false;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;mode&quot;, mode);
-            Transform.append(buffer, &quot;inPoint&quot;, inPoint);
-            Transform.append(buffer, &quot;outPoint&quot;, outPoint);
-            Transform.append(buffer, &quot;loopCount&quot;, loopCount);
-            Transform.append(buffer, &quot;envelopes&quot;, envelopes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		envelopes = new ArrayList();
 
-    public int length(FSCoder coder)
-    {
-        boolean _containsInPoint = containsInPoint();
-        boolean _containsOutPoint = containsOutPoint();
-        boolean _containsLoopCount = containsLoopCount();
-        boolean _containsEnvelopes = containsEnvelopes();
-        
-        int length = 3;
-    
-        length += (_containsInPoint) ? 4 : 0;
-        length += (_containsOutPoint) ? 4 : 0;
-        length += (_containsLoopCount) ? 2 : 0;
-        length += (_containsEnvelopes) ? 1 : 0;
-        length += (_containsEnvelopes) ? envelopes.size()*8 : 0;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsInPoint = containsInPoint();
-        boolean _containsOutPoint = containsOutPoint();
-        boolean _containsLoopCount = containsLoopCount();
-        boolean _containsEnvelopes = containsEnvelopes();
-        
-        coder.writeWord(identifier, 2);
-        coder.writeBits(mode, 4);
-        coder.writeBits(_containsEnvelopes ? 1 : 0, 1);
-        coder.writeBits(_containsLoopCount ? 1 : 0, 1);
-        coder.writeBits(_containsOutPoint ? 1 : 0, 1);
-        coder.writeBits(_containsInPoint ? 1 : 0, 1);
-    
-        if (_containsInPoint)
-            coder.writeWord(inPoint, 4);
-        if (_containsOutPoint)
-            coder.writeWord(outPoint, 4);
-        if (_containsLoopCount)
-            coder.writeWord(loopCount, 2);
-        if (_containsEnvelopes)
-        {
-            coder.writeWord(envelopes.size(), 1);
+		int envelopeCount = 0;
 
-            for (int i=0; i&lt;envelopes.size(); i++)
-                ((FSTransformObject)envelopes.get(i)).encode(coder);
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean _containsInPoint = false;
-        boolean _containsOutPoint = false;
-        boolean _containsLoopCount = false;
-        boolean _containsEnvelopes = false;
-        
-        envelopes = new ArrayList();
+		identifier = coder.readWord(2, false);
+		mode = coder.readBits(4, false);
+		_containsEnvelopes = coder.readBits(1, false) != 0 ? true : false;
+		_containsLoopCount = coder.readBits(1, false) != 0 ? true : false;
+		_containsOutPoint = coder.readBits(1, false) != 0 ? true : false;
+		_containsInPoint = coder.readBits(1, false) != 0 ? true : false;
 
-        int envelopeCount = 0;
+		if (_containsInPoint)
+			inPoint = coder.readWord(4, false);
 
-        identifier = coder.readWord(2, false);
-        mode = coder.readBits(4, false);
-        _containsEnvelopes = coder.readBits(1, false) != 0 ? true : false;
-        _containsLoopCount = coder.readBits(1, false) != 0 ? true : false;
-        _containsOutPoint = coder.readBits(1, false) != 0 ? true : false;
-        _containsInPoint = coder.readBits(1, false) != 0 ? true : false;
-    
-        if (_containsInPoint)
-            inPoint = coder.readWord(4, false);
-            
-        if (_containsOutPoint)
-            outPoint = coder.readWord(4, false);
-            
-        if (_containsLoopCount)
-            loopCount = coder.readWord(2, false);
-            
-        if (_containsEnvelopes)
-        {
-            envelopeCount = coder.readWord(1, false);
+		if (_containsOutPoint)
+			outPoint = coder.readWord(4, false);
 
-            for (int i=0; i&lt;envelopeCount; i++)
-                envelopes.add(new FSEnvelope(coder));
-        }
-    }
+		if (_containsLoopCount)
+			loopCount = coder.readWord(2, false);
 
-    private boolean containsInPoint()
-    {
-        return inPoint != 0;
-    }
+		if (_containsEnvelopes)
+		{
+			envelopeCount = coder.readByte();
 
-    private boolean containsOutPoint()
-    {
-        return outPoint != 0;
-    }
-    
-    private boolean containsLoopCount()
-    {
-        return loopCount != 0;
-    }
+			for (int i = 0; i &lt; envelopeCount; i++)
+				envelopes.add(new FSEnvelope(coder));
+		}
+	}
 
-    private boolean containsEnvelopes()
-    {
-        return envelopes != null &amp;&amp; envelopes.size() &gt; 0;
-    }
+	private boolean containsInPoint()
+	{
+		return inPoint != 0;
+	}
+
+	private boolean containsOutPoint()
+	{
+		return outPoint != 0;
+	}
+
+	private boolean containsLoopCount()
+	{
+		return loopCount != 0;
+	}
+
+	private boolean containsEnvelopes()
+	{
+		return envelopes != null &amp;&amp; envelopes.size() &gt; 0;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamBlock.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamBlock.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamBlock.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,147 +31,170 @@
 package com.flagstone.transform;
 
 /**
-FSSoundStreamBlock contains the sound data being streamed to the Flash Player. 
- 
-&lt;p&gt;Streaming sounds are played in tight synchronisation with one FSSoundStreamBlock 
-object defining the sound for each frame displayed in a movie.&lt;/p&gt;
+ * FSSoundStreamBlock contains the sound data being streamed to the Flash
+ * Player.
+ * 
+ * &lt;p&gt;
+ * Streaming sounds are played in tight synchronisation with one
+ * FSSoundStreamBlock object defining the sound for each frame displayed in a
+ * movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;soundData&lt;/td&gt;
+ * &lt;td&gt;The encoded sound data for a single frame in a movie. The format for the
+ * sound is defined by an FSSoundStreamHead object. Sounds may be encoded using
+ * the uncompressed PCM (big or little endian byte order), compressed ADPCM,
+ * compressed MP3 or NELLYMOSER formats.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * When a streaming sound is played if the Flash Player cannot render the frames
+ * fast enough to maintain synchronisation with the sound being played then
+ * frames will be skipped. Normally the player will reduce the frame rate so
+ * every frame of a movie is played.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamBlock class represents the SoundStreamBlock tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1 with support for Uncompressed PCM encoded sounds (both Little-Endian and
+ * Big-Endian formats) and the compressed ADPCM format. Support for MP3 was
+ * added in Flash 3. The Nellymoser Asao format was added in Flash 6.
+ * &lt;/p&gt;
+ */
+public class FSSoundStreamBlock extends FSMovieObject
+{
+	private byte[] soundData = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSoundStreamBlock object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSoundStreamBlock(FSCoder coder)
+	{
+		super(FSMovieObject.SoundStreamBlock);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamBlock specifying the sound data in the format
+	 * defined by a preceding FSSoundStreamHead or FSSoundStreamHead2 object.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the sound data.
+	 */
+	public FSSoundStreamBlock(byte[] bytes)
+	{
+		super(FSMovieObject.SoundStreamBlock);
+		setSoundData(bytes);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamBlock_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamBlock object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSSoundStreamBlock object.
+	 */
+	public FSSoundStreamBlock(FSSoundStreamBlock obj)
+	{
+		super(obj);
+		soundData = Transform.clone(obj.soundData);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamBlock_1&quot;&gt;soundData&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded sound data for a single frame in a movie. The format for the sound 
-is defined by an FSSoundStreamHead object. Sounds may be encoded using the uncompressed 
-PCM (big or little endian byte order), compressed ADPCM, compressed MP3 or NELLYMOSER
-formats.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the sound data in the format defined by a preceding
+	 * FSSoundStreamHead or FSSoundStreamHead2 object.
+	 * 
+	 * @return the sound data.
+	 */
+	public byte[] getSoundData()
+	{
+		return soundData;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the sound data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the sound data.
+	 */
+	public void setSoundData(byte[] bytes)
+	{
+		soundData = bytes;
+	}
 
-&lt;p&gt;When a streaming sound is played if the Flash Player cannot render the frames fast 
-enough to maintain synchronisation with the sound being played then frames will be 
-skipped. Normally the player will reduce the frame rate so every frame of a movie 
-is played.&lt;/p&gt;
+	public Object clone()
+	{
+		FSSoundStreamBlock anObject = (FSSoundStreamBlock) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.soundData = Transform.clone(soundData);
 
-&lt;p&gt;The FSSoundStreamBlock class represents the SoundStreamBlock tag from the Macromedia 
-Flash (SWF) File Format Specification. It was introduced in Flash 1 with support for 
-Uncompressed PCM encoded sounds (both Little-Endian and Big-Endian formats) and the 
-compressed ADPCM format. Support for MP3 was added in Flash 3. The Nellymoser Asao
-format was added in Flash 6.&lt;/p&gt;
- */
-public class FSSoundStreamBlock extends FSMovieObject
-{
-    private byte[] soundData = null;
-    
-    /**
-     * Construct an FSSoundStreamBlock object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSoundStreamBlock(FSCoder coder)
-    {
-        super(FSMovieObject.SoundStreamBlock);
-        decode(coder);
-    }
-    /** Constructs an FSSoundStreamBlock specifying the sound data in the format defined by a preceding FSSoundStreamHead or FSSoundStreamHead2 object.
+		return anObject;
+	}
 
-        @param bytes an array of bytes containing the sound data.
-        */
-    public FSSoundStreamBlock(byte[] bytes)
-    {
-        super(FSMovieObject.SoundStreamBlock);
-        setSoundData(bytes);
-    }
-    /**
-     * Constructs an FSSoundStreamBlock object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSSoundStreamBlock object.
-     */
-    public FSSoundStreamBlock(FSSoundStreamBlock obj)
-    {
-        super(obj);
-        soundData = Transform.clone(obj.soundData);
-    }    
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the sound data in the format defined by a preceding FSSoundStreamHead or FSSoundStreamHead2 object.
+		if (super.equals(anObject))
+		{
+			FSSoundStreamBlock typedObject = (FSSoundStreamBlock) anObject;
 
-        @return the sound data.
-        */
-    public byte[] getSoundData() { return soundData; }
+			result = Transform.equals(soundData, typedObject.soundData);
+		}
+		return result;
+	}
 
-    /** Sets the sound data.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param bytes an array of bytes containing the sound data.
-        */
-    public void setSoundData(byte[] bytes)
-    {
-        soundData = bytes;
-    }
+		buffer.append(&quot;FSSoundStreamBlock: { &quot;);
+		buffer.append(&quot;soundData = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    public Object clone()
-    {
-        FSSoundStreamBlock anObject = (FSSoundStreamBlock)super.clone();
-        
-        anObject.soundData = Transform.clone(soundData);
-        
-        return anObject;
-    }
+		return buffer.toString();
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSoundStreamBlock typedObject = (FSSoundStreamBlock)anObject;
-            
-            result = Transform.equals(soundData, typedObject.soundData);
-        }
-        return result;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;soundData&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		length += soundData.length;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += soundData.length;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(soundData);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        soundData = new byte[length];
-        coder.readBytes(soundData);
-        coder.endObject(name());
-    }
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(soundData);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		soundData = new byte[length];
+		coder.readBytes(soundData);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,465 +31,572 @@
 package com.flagstone.transform;
 
 /**
-FSSoundStreamHead defines the format of a streaming sound, identifying the encoding scheme, 
-the rate at which the sound will be played and the size of the decoded samples. 
- 
-&lt;p&gt;The actual sound is streamed used the FSSoundStreamBlock class which contains 
-the data for each frame in a movie.&lt;/p&gt;
+ * FSSoundStreamHead defines the format of a streaming sound, identifying the
+ * encoding scheme, the rate at which the sound will be played and the size of
+ * the decoded samples.
+ * 
+ * &lt;p&gt;
+ * The actual sound is streamed used the FSSoundStreamBlock class which contains
+ * the data for each frame in a movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;format&lt;/td&gt;
+ * &lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little0endian byte
+ * order), FSSound.ADPCM, or FSSound.NATIVE_PCM (Big-endian or Little-Endian
+ * byte order depending on the platform where the sound was generated.).&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackRate&lt;/td&gt;
+ * &lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackSampleSize&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in an uncompressed sample when the sound is played,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackChannels&lt;/td&gt;
+ * &lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamRate&lt;/td&gt;
+ * &lt;td&gt;The rate at which the streaming sound was samples - 5512, 11025, 22050
+ * or 44100 Hz.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleSize&lt;/td&gt;
+ * &lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamChannels&lt;/td&gt;
+ * &lt;td&gt;The number of channels: 1 = mono or 2 = stereo, in the streaming sound&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleCount&lt;/td&gt;
+ * &lt;td&gt;The average number of samples in each FSSoundStreamBlock object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;latency&lt;/td&gt;
+ * &lt;td&gt;Latency defines the number of samples to skip only when playing sounds
+ * encoded with the MP3 format.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Four encoded formats for the sound data are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or
+ * 2 bytes. For two-byte samples the byte order is dependent on the platform on
+ * which the Flash Player is hosted. Sounds created on a platform which supports
+ * big-endian byte order will not be played correctly when listened to on a
+ * platform which supports little-endian byte order.&lt;/li&gt;
+ * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes
+ * with the latter presented in Little-Endian byte order. This ensures that
+ * sounds can be played across different platforms.&lt;/li&gt;
+ * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded
+ * and compressed by comparing the difference between successive sound sample
+ * which dramatically reduces the size of the encoded sound when compared to the
+ * uncompressed PCM formats. Use this format whenever possible.&lt;/li&gt;
+ * &lt;li&gt;MP3 - MPEG Layer 3 encoded sound.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * Constants representing the different formats are defined in the FSSound
+ * class.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When a stream sound is played if the Flash Player cannot render the frames
+ * fast enough to maintain synchronisation with the sound being played then
+ * frames will be skipped. Normally the player will reduce the frame rate so
+ * every frame of a movie is played. The different sets of attributes that
+ * identify how the sound will be played compared to the way it was encoded
+ * allows the Player more control over how the animation is rendered. Reducing
+ * the resolution or playback rate can improve synchronisation with the frames
+ * displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamHead class represents the SoundStreamHead structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSSoundStreamHead extends FSMovieObject
+{
+	private int format = FSSound.ADPCM;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int playbackRate = 5512;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private int playbackChannels = 1;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private int playbackSampleSize = 16;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_1&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little0endian byte order), 
-FSSound.ADPCM, or FSSound.NATIVE_PCM (Big-endian or Little-Endian byte order depending
-on the platform where the sound was generated.).&lt;/td&gt;
-&lt;/tr&gt;
+	private int streamRate = 5512;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_2&quot;&gt;playbackRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
-&lt;/tr&gt;
+	private int streamChannels = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_3&quot;&gt;playbackSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in an uncompressed sample when the sound is played, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
+	private int streamSampleSize = 16;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_4&quot;&gt;playbackChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
-&lt;/tr&gt;
+	private int streamSampleCount = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_5&quot;&gt;streamRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The rate at which the streaming sound was samples - 5512, 11025, 22050 or 44100 Hz.&lt;/td&gt;
-&lt;/tr&gt;
+	private int latency = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_6&quot;&gt;streamSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSSoundStreamHead object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSoundStreamHead(FSCoder coder)
+	{
+		super(FSMovieObject.SoundStreamHead);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_7&quot;&gt;streamChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of channels: 1 = mono or 2 = stereo, in the streaming sound&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamHead object specifying all the parameters
+	 * required to define the sound.
+	 * 
+	 * @param playRate
+	 *            the recommended rate for playing the sound, either 5512,
+	 *            11025, 22050 or 44100 Hz.
+	 * @param playChannels
+	 *            The recommended number of playback channels: 1 = mono or 2 =
+	 *            stereo.
+	 * @param playSize
+	 *            the recommended uncompressed sample size for playing the
+	 *            sound, either 1 or 2 bytes.
+	 * @param streamingRate
+	 *            the rate at which the sound was sampled, either 5512, 11025,
+	 *            22050 or 44100 Hz.
+	 * @param streamingChannels
+	 *            the number of channels: 1 = mono or 2 = stereo.
+	 * @param streamingSize
+	 *            the sample size for the sound in bytes, either 1 or 2.
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 * @param latency
+	 *            defines the number of samples to skip only when playing sounds
+	 *            encoded with the MP3 format.
+	 */
+	public FSSoundStreamHead(int playRate, int playChannels, int playSize,
+								int streamingRate, int streamingChannels,
+								int streamingSize, int streamingCount,
+								int latency)
+	{
+		super(FSMovieObject.SoundStreamHead);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_8&quot;&gt;streamSampleCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The average number of samples in each FSSoundStreamBlock object.&lt;/td&gt;
-&lt;/tr&gt;
+		setPlaybackRate(playRate);
+		setPlaybackChannels(playChannels);
+		setPlaybackSampleSize(playSize);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_9&quot;&gt;latency&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Latency defines the number of samples to skip only when playing sounds encoded 
-with the MP3 format.&lt;/td&gt;
-&lt;/tr&gt;
+		setStreamRate(streamingRate);
+		setStreamChannels(streamingChannels);
+		setStreamSampleSize(streamingSize);
+		setStreamSampleCount(streamingCount);
+		setLatency(latency);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSSoundStreamHead object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSoundStreamHead object.
+	 */
+	public FSSoundStreamHead(FSSoundStreamHead obj)
+	{
+		super(obj);
+		format = obj.format;
+		playbackRate = obj.playbackRate;
+		playbackChannels = obj.playbackChannels;
+		playbackSampleSize = obj.playbackSampleSize;
 
-&lt;p&gt;Four encoded formats for the sound data are supported:&lt;/p&gt;
+		streamRate = obj.streamRate;
+		streamChannels = obj.streamChannels;
+		streamSampleSize = obj.streamSampleSize;
+		streamSampleCount = obj.streamSampleCount;
+		latency = obj.latency;
+	}
 
-&lt;ul&gt;
-&lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes. For two-byte samples the byte order is dependent on the platform on which the Flash Player is hosted. Sounds created on a platform which supports big-endian byte order will not be played correctly when listened to on a platform which supports little-endian byte order.&lt;/li&gt;
-&lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes with 
-the latter presented in Little-Endian byte order. This ensures that sounds can be played across different platforms.&lt;/li&gt;
-&lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded and compressed
-by comparing the difference between successive sound sample which dramatically reduces
-the size of the encoded sound when compared to the uncompressed PCM formats. Use this 
-format whenever possible.&lt;/li&gt;
-&lt;li&gt;MP3 - MPEG Layer 3 encoded sound.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Gets the streaming sound format. For the FSSoundStreamHead class supports
+	 * ADPCM or MP3 encoded sound data.
+	 * 
+	 * @return the format used to play the sound.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-&lt;p&gt;Constants representing the different formats are defined in the FSSound class.&lt;/p&gt;
+	/**
+	 * Sets the format for the streaming sound.
+	 * 
+	 * @param encoding
+	 *            the compression format for the sound data, either
+	 *            FSSound.ADPCM or FSSound.MP3.
+	 */
+	public void setFormat(int encoding)
+	{
+		format = encoding;
+	}
 
-&lt;p&gt;When a stream sound is played if the Flash Player cannot render the frames fast enough 
-to maintain synchronisation with the sound being played then frames will be skipped. 
-Normally the player will reduce the frame rate so every frame of a movie is played. 
-The different sets of attributes that identify how the sound will be played compared 
-to the way it was encoded allows the Player more control over how the animation is 
-rendered. Reducing the resolution or playback rate can improve synchronisation with 
-the frames displayed.&lt;/p&gt;
+	/**
+	 * Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	 * 
+	 * @return the rate at which the sound will be played back.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @return the number of channels for the sound playback.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-&lt;p&gt;The FSSoundStreamHead class represents the SoundStreamHead structure from the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSSoundStreamHead extends FSMovieObject
-{
-    private int format = FSSound.ADPCM;
+	/**
+	 * Gets the recommended playback sample range in bytes: 1 or 2.
+	 * 
+	 * @return the sample size used to play back the sound.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-    private int playbackRate = 5512;
-    private int playbackChannels = 1;
-    private int playbackSampleSize = 16;
+	/**
+	 * Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming
+	 * sound.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public float getStreamRate()
+	{
+		return streamRate;
+	}
 
-    private int streamRate = 5512;
-    private int streamChannels = 1;
-    private int streamSampleSize = 16;
-    private int streamSampleCount = 0;
-    private int latency = 0;
+	/**
+	 * Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	 * 
+	 * @return the number of channels in the sound.
+	 */
+	public int getStreamChannels()
+	{
+		return streamChannels;
+	}
 
-    /**
-     * Construct an FSSoundStreamHead object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSoundStreamHead(FSCoder coder)
-    {
-        super(FSMovieObject.SoundStreamHead);
-        decode(coder);
-    }
-    /** Constructs an FSSoundStreamHead object specifying all the parameters required to define the sound.
+	/**
+	 * Gets the sample size in bytes: 1 or 2 in the streaming sound.
+	 * 
+	 * @return the sample size.
+	 */
+	public int getStreamSampleSize()
+	{
+		return streamSampleSize;
+	}
 
-        @param playRate the recommended rate for playing the sound, either 5512, 11025, 22050 or 44100 Hz.
-        @param playChannels The recommended number of playback channels: 1 = mono or 2 = stereo.
-        @param playSize the recommended uncompressed sample size for playing the sound, either 1 or 2 bytes.
-        @param streamingRate the rate at which the sound was sampled, either 5512, 11025, 22050 or 44100 Hz.
-        @param streamingChannels the number of channels: 1 = mono or 2 = stereo.
-        @param streamingSize the sample size for the sound in bytes, either 1 or 2.
-        @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-        @param latency defines the number of samples to skip only when playing sounds encoded with the MP3 format.
-        */
-    public FSSoundStreamHead(int playRate, int playChannels, int playSize, int streamingRate, int streamingChannels, int streamingSize, int streamingCount, int latency)
-    {
-        super(FSMovieObject.SoundStreamHead);
-        
-        setPlaybackRate(playRate);
-        setPlaybackChannels(playChannels);
-        setPlaybackSampleSize(playSize);
+	/**
+	 * Gets the average number of samples in each stream block following.
+	 * 
+	 * @return the number of sound samples in each following FSSoundStreamBlock
+	 *         object.
+	 */
+	public int getStreamSampleCount()
+	{
+		return streamSampleCount;
+	}
 
-        setStreamRate(streamingRate);
-        setStreamChannels(streamingChannels);
-        setStreamSampleSize(streamingSize);
-        setStreamSampleCount(streamingCount);
-        setLatency(latency);
-    }
-    /**
-     * Constructs an FSSoundStreamHead object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSoundStreamHead object.
-     */
-    public FSSoundStreamHead(FSSoundStreamHead obj)
-    {
-        super(obj);
-        format = obj.format;
-        playbackRate = obj.playbackRate;
-        playbackChannels = obj.playbackChannels;
-        playbackSampleSize = obj.playbackSampleSize;
-        
-        streamRate = obj.streamRate;
-        streamChannels = obj.streamChannels;
-        streamSampleSize = obj.streamSampleSize;
-        streamSampleCount = obj.streamSampleCount;
-        latency = obj.latency;
-    }
-    
-    /** Gets the streaming sound format. For the FSSoundStreamHead class supports 
-     * ADPCM or MP3 encoded sound data.
-    
-        @return the format used to play the sound.
-        */
-    public int getFormat()
-    {
-        return format;
-    }
+	/**
+	 * Sets the recommended playback rate in Hz. Must be either: 5512, 11025,
+	 * 22050 or 44100.
+	 * 
+	 * @param playRate
+	 *            the recommended rate for playing the sound.
+	 */
+	public void setPlaybackRate(int playRate)
+	{
+		playbackRate = playRate;
+	}
 
-    /** Sets the format for the streaming sound.
+	/**
+	 * Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @param aNumber
+	 *            the recommended number of playback channels.
+	 */
+	public void setPlaybackChannels(int aNumber)
+	{
+		playbackChannels = aNumber;
+	}
 
-        @param encoding the compression format for the sound data, either 
-        FSSound.ADPCM or FSSound.MP3.
-    */
-    public void setFormat(int encoding)
-    {
-        format = encoding;
-    }
+	/**
+	 * Sets the recommended playback sample size in bytes. Must be wither 1 or
+	 * 2.
+	 * 
+	 * @param playSize
+	 *            the recommended sample size for playing the sound.
+	 */
+	public void setPlaybackSampleSize(int playSize)
+	{
+		playbackSampleSize = playSize;
+	}
 
-   /** Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	/**
+	 * Sets the sample rate in Hz for the streaming sound. Must be either: 5512,
+	 * 11025, 22050 or 44100.
+	 * 
+	 * @param streamingRate
+	 *            the rate at which the streaming sound was sampled.
+	 */
+	public void setStreamRate(int streamingRate)
+	{
+		streamRate = streamingRate;
+	}
 
-        @return the rate at which the sound will be played back.
-        */
-    public int getPlaybackRate() { return playbackRate; }
+	/**
+	 * Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+	 * 
+	 * @param streamingChannels
+	 *            the number of channels in the streaming sound.
+	 */
+	public void setStreamChannels(int streamingChannels)
+	{
+		streamChannels = streamingChannels;
+	}
 
-    /** Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	/**
+	 * Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+	 * 
+	 * @param streamingSize
+	 *            the sample size for the sound.
+	 */
+	public void setStreamSampleSize(int streamingSize)
+	{
+		streamSampleSize = streamingSize;
+	}
 
-        @return the number of channels for the sound playback.
-        */
-    public int getPlaybackChannels() { return playbackChannels; }
+	/**
+	 * Sets the number of samples in each stream block.
+	 * 
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 */
+	public void setStreamSampleCount(int streamingCount)
+	{
+		streamSampleCount = streamingCount;
+	}
 
-    /** Gets the recommended playback sample range in bytes: 1 or 2.
+	/**
+	 * For MP3 encoded sounds, returns the number of samples to skip when
+	 * starting to play a sound.
+	 * 
+	 * @return the number of samples skipped in an MP3 encoded sound Returns 0
+	 *         for other sound formats.
+	 */
+	public int getLatency()
+	{
+		return latency;
+	}
 
-        @return the sample size used to play back the sound.
-        */
-    public int getPlaybackSampleSize() { return playbackSampleSize; }
+	/**
+	 * Set the number of samples to skip when starting to play an MP3 encoded
+	 * sound.
+	 * 
+	 * @param latency
+	 *            the number of samples to be skipped in an MP3 encoded sound
+	 *            should be 0 for other sound formats.
+	 */
+	public void setLatency(int latency)
+	{
+		this.latency = latency;
+	}
 
-    /** Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming sound.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the rate at which the sound was sampled.
-        */
-    public float getStreamRate() { return streamRate; }
+		if (super.equals(anObject))
+		{
+			FSSoundStreamHead typedObject = (FSSoundStreamHead) anObject;
 
-    /** Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result &amp;&amp; streamRate == typedObject.streamRate;
+			result = result &amp;&amp; streamChannels == typedObject.streamChannels;
+			result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
+			result = result
+							&amp;&amp; streamSampleCount == typedObject.streamSampleCount;
+			result = result &amp;&amp; latency == typedObject.latency;
+		}
+		return result;
+	}
 
-        @return the number of channels in the sound.
-        */
-    public int getStreamChannels() { return streamChannels; }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Gets the sample size in bytes: 1 or 2 in the streaming sound.
+		buffer.append(&quot;FSSoundStreamHead: { &quot;);
+		buffer.append(&quot;format = &quot;).append(format).append(&quot;; &quot;);
+		buffer.append(&quot;playbackRate = &quot;).append(playbackRate).append(&quot;; &quot;);
+		buffer.append(&quot;playbackChannels = &quot;).append(playbackChannels).append(&quot;; &quot;);
+		buffer.append(&quot;playbackSampleSize = &quot;).append(playbackSampleSize).append(&quot;; &quot;);
+		buffer.append(&quot;streamRate = &quot;).append(streamRate).append(&quot;; &quot;);
+		buffer.append(&quot;streamChannels = &quot;).append(streamChannels).append(&quot;;&quot;);
+		buffer.append(&quot;streamSampleSize = &quot;).append(streamSampleSize).append(&quot;; &quot;);
+		buffer.append(&quot;streamSampleCount = &quot;).append(streamSampleCount).append(&quot;; &quot;);
+		buffer.append(&quot;latency = &quot;).append(latency).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-        @return the sample size.
-        */
-    public int getStreamSampleSize() { return streamSampleSize; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the average number of samples in each stream block following.
+		length += 4;
 
-        @return the number of sound samples in each following FSSoundStreamBlock object.
-        */
-    public int getStreamSampleCount() { return streamSampleCount; }
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			length += 2;
 
-    /** Sets the recommended playback rate in Hz. Must be either: 5512, 11025, 22050 or 44100.
+		return length;
+	}
 
-        @param playRate the recommended rate for playing the sound.
-        */
-    public void setPlaybackRate(int playRate)
-    {
-        playbackRate = playRate;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+		coder.writeBits(0, 4);
 
-        @param aNumber the recommended number of playback channels.
-        */
-    public void setPlaybackChannels(int aNumber)
-    {
-        playbackChannels = aNumber;
-    }
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
 
-    /** Sets the recommended playback sample size in bytes. Must be wither 1 or 2.
+		coder.writeBits(format, 4);
 
-        @param playSize the recommended sample size for playing the sound.
-        */
-    public void setPlaybackSampleSize(int playSize)
-    {
-        playbackSampleSize = playSize;
-    }
+		switch (streamRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(streamSampleSize - 1, 1);
+		coder.writeBits(streamChannels - 1, 1);
+		coder.writeWord(streamSampleCount, 2);
 
-    /** Sets the sample rate in Hz for the streaming sound. Must be either: 5512, 11025, 22050 or 44100.
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			coder.writeWord(latency, 2);
+	}
 
-        @param streamingRate the rate at which the streaming sound was sampled.
-        */
-    public void setStreamRate(int streamingRate)
-    {
-        streamRate = streamingRate;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    /** Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+		coder.readBits(4, false);
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
 
-        @param streamingChannels the number of channels in the streaming sound.
-        */
-    public void setStreamChannels(int streamingChannels)
-    {
-        streamChannels = streamingChannels;
-    }
+		format = coder.readBits(4, false);
 
-    /** Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				streamRate = 5512;
+				break;
+			case 1:
+				streamRate = 11025;
+				break;
+			case 2:
+				streamRate = 22050;
+				break;
+			case 3:
+				streamRate = 44100;
+				break;
+		}
+		streamSampleSize = coder.readBits(1, false) + 1;
+		streamChannels = coder.readBits(1, false) + 1;
+		streamSampleCount = coder.readWord(2, false);
 
-        @param streamingSize the sample size for the sound.
-        */
-    public void setStreamSampleSize(int streamingSize)
-    {
-        streamSampleSize = streamingSize;
-    }
-
-    /** Sets the number of samples in each stream block.
-
-        @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-        */
-    public void setStreamSampleCount(int streamingCount)
-    {
-        streamSampleCount = streamingCount;
-    }
-
-    /**
-     * For MP3 encoded sounds, returns the number of samples to skip when starting to play a sound.
-     *
-     * @return the number of samples skipped in an MP3 encoded sound Returns 0 for other sound formats.
-     */
-    public int getLatency() 
-    { 
-        return latency; 
-    }
-
-    /**
-     * Set the number of samples to skip when starting to play an MP3 encoded sound.
-     *
-     * @param latency the number of samples to be skipped in an MP3 encoded sound should be 0 for other sound formats.
-     */
-    public void setLatency(int latency)
-    {
-        this.latency = latency;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSoundStreamHead typedObject = (FSSoundStreamHead)anObject;
-            
-            result = format == typedObject.format;
-            result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-            result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-            result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-            result = result &amp;&amp; streamRate == typedObject.streamRate;
-            result = result &amp;&amp; streamChannels == typedObject.streamChannels;
-            result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
-            result = result &amp;&amp; streamSampleCount == typedObject.streamSampleCount;
-            result = result &amp;&amp; latency == typedObject.latency;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;format&quot;, format);
-            Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-            Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-            Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-            Transform.append(buffer, &quot;streamRate&quot;, streamRate);
-            Transform.append(buffer, &quot;streamChannels&quot;, streamChannels);
-            Transform.append(buffer, &quot;streamSampleSize&quot;, streamSampleSize);
-            Transform.append(buffer, &quot;streamSampleCount&quot;, streamSampleCount);
-            Transform.append(buffer, &quot;latency&quot;, latency);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 4;
-        
-        if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-            length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-         coder.writeBits(0, 4);
-
-        switch (playbackRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(playbackSampleSize-1, 1);
-        coder.writeBits(playbackChannels-1, 1);
-
-        coder.writeBits(format, 4);
-
-        switch (streamRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(streamSampleSize-1, 1);
-        coder.writeBits(streamChannels-1, 1);
-        coder.writeWord(streamSampleCount, 2);
-
-        if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-            coder.writeWord(latency, 2);
-
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        coder.readBits(4, false);
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                playbackRate = 5512;
-                break;
-            case 1:
-                playbackRate = 11025;
-                break;
-            case 2:
-                playbackRate = 22050;
-                break;
-            case 3:
-                playbackRate = 44100;
-                break;
-        }
-        playbackSampleSize = coder.readBits(1, false)+1;
-        playbackChannels = coder.readBits(1, false)+1;
-
-        format = coder.readBits(4, false);
-
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                streamRate = 5512;
-                break;
-            case 1:
-                streamRate = 11025;
-                break;
-            case 2:
-                streamRate = 22050;
-                break;
-            case 3:
-                streamRate = 44100;
-                break;
-        }
-        streamSampleSize = coder.readBits(1, false)+1;
-        streamChannels = coder.readBits(1, false)+1;
-        streamSampleCount = coder.readWord(2, false);
-        
-        if (length == 6 &amp;&amp; format == FSSound.MP3)
-            latency = coder.readWord(2, true);
-
-        coder.endObject(name());
-    }
+		if (length == 6 &amp;&amp; format == FSSound.MP3)
+			latency = coder.readWord(2, true);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSSoundStreamHead2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,471 +31,572 @@
 package com.flagstone.transform;
 
 /**
-FSSoundStreamHead2 defines an sound compressed using different compression formats
-that is streamed in tight synchronisation with the movie being played.
+ * FSSoundStreamHead2 defines an sound compressed using different compression
+ * formats that is streamed in tight synchronisation with the movie being
+ * played.
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamHead2 class defines how the streaming sound is played.
+ * Objects of the FSSoundStreamBlock class contains the sound data.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * When a stream sound is played if the Flash Player cannot render the frames
+ * fast enough to maintain synchronisation with the sound being played then
+ * frames will be skipped. Normally the player will reduce the frame rate so
+ * every frame of a movie is played.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * To define the stream sound the parameters for and sampled sound and how it
+ * will be played back must be specified:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;format&lt;/td&gt;
+ * &lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little-Endian byte
+ * order), FSSound.ADPCM, FSSound.NATIVE_PCM (Big-Endian or Little-Endian byte
+ * order depending on the platform where the sound was created), FSSound.MP3 or
+ * FSSound.NELLYMOSER&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackRate&lt;/td&gt;
+ * &lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackSampleSize&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in an uncompressed sample when the sound is played,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackChannels&lt;/td&gt;
+ * &lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamRate&lt;/td&gt;
+ * &lt;td&gt;The stream sampling rate - 5512, 11025, 22050 or 44100 Hz&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleSize&lt;/td&gt;
+ * &lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamChannels&lt;/td&gt;
+ * &lt;td&gt;The number of channels: 1 = mono or 2 = stereo in the streaming sound&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleCount&lt;/td&gt;
+ * &lt;td&gt;The average number of samples in each sound stream block.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;latency&lt;/td&gt;
+ * &lt;td&gt;Latency defines the number of samples to skip only when playing sounds
+ * encoded with the MP3 format.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSSoundStreamHead2 allows way the sound is played to differ from the way it
+ * is encoded and streamed to the player. This allows the Player more control
+ * over how the animation is rendered. Reducing the resolution or playback rate
+ * can improve synchronisation with the frames displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;b&gt;History&lt;/b&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamHead2 class represents the SoundStreamHead structure from
+ * the Flash specification. It was introduced in Flash 3. Support for the
+ * Nellymoser Asao format was added in Flash 6.
+ * &lt;/p&gt;
+ */
+public class FSSoundStreamHead2 extends FSMovieObject
+{
+	private int format = FSSound.ADPCM;
 
-&lt;p&gt;The FSSoundStreamHead2 class defines how the streaming sound is played. Objects 
-of the FSSoundStreamBlock class contains the sound data.&lt;/P&gt;
+	private int playbackRate = 5512;
 
-&lt;p&gt;When a stream sound is played if the Flash Player cannot render the frames fast 
-enough to maintain synchronisation with the sound being played then frames will 
-be skipped. Normally the player will reduce the frame rate so every frame of a 
-movie is played.&lt;/p&gt;
+	private int playbackChannels = 1;
 
-&lt;p&gt;To define the stream sound the parameters for and sampled sound and how it will 
-be played back must be specified:&lt;/p&gt;
+	private int playbackSampleSize = 16;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int streamRate = 5512;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private int streamChannels = 1;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private int streamSampleSize = 16;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_1&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little-Endian byte order), 
-FSSound.ADPCM, FSSound.NATIVE_PCM (Big-Endian or Little-Endian byte order 
-depending on the platform where the sound was created), FSSound.MP3 or 
-FSSound.NELLYMOSER&lt;/td&gt;
-&lt;/tr&gt;
+	private int streamSampleCount = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_2&quot;&gt;playbackRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
-&lt;/tr&gt;
+	private int latency = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_3&quot;&gt;playbackSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in an uncompressed sample when the sound is played, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
+	/*
+	 * The following variable is used to preserve the value of a reserved field
+	 * when decoding then encoding an existing Flash file. Macromedia's file
+	 * file format specification states that this field is always zero - it is
+	 * not, so this is used to preserve the value in case it is implementing an
+	 * undocumented feature.
+	 */
+	private int _reserved = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_4&quot;&gt;playbackChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSSoundStreamHead2 object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSoundStreamHead2(FSCoder coder)
+	{
+		super(SoundStreamHead2);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_5&quot;&gt;streamRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The stream sampling rate - 5512, 11025, 22050 or 44100 Hz&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamHead2 object specifying all the parameters
+	 * required to define the sound.
+	 * 
+	 * @param encoding
+	 *            the compression format for the sound data, either
+	 *            FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or
+	 *            FSSound.NELLYMOSER (Flash 6+ only).
+	 * @param playRate
+	 *            the recommended rate for playing the sound, either 5512,
+	 *            11025, 22050 or 44100 Hz.
+	 * @param playChannels
+	 *            The recommended number of playback channels: 1 = mono or 2 =
+	 *            stereo.
+	 * @param playSize
+	 *            the recommended uncompressed sample size for playing the
+	 *            sound, either 1 or 2 bytes.
+	 * @param streamingRate
+	 *            the rate at which the sound was sampled, either 5512, 11025,
+	 *            22050 or 44100 Hz.
+	 * @param streamingChannels
+	 *            the number of channels: 1 = mono or 2 = stereo.
+	 * @param streamingSize
+	 *            the sample size for the sound, either 1 or 2 bytes.
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 * @param latency
+	 *            defines the number of samples to skip only when playing sounds
+	 *            encoded with the MP3 format.
+	 */
+	public FSSoundStreamHead2(int encoding, int playRate, int playChannels,
+								int playSize, int streamingRate,
+								int streamingChannels, int streamingSize,
+								int streamingCount, int latency)
+	{
+		super(SoundStreamHead2);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_6&quot;&gt;streamSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
+		setFormat(encoding);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_7&quot;&gt;streamChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of channels: 1 = mono or 2 = stereo in the streaming sound&lt;/td&gt;
-&lt;/tr&gt;
+		setPlaybackRate(playRate);
+		setPlaybackChannels(playChannels);
+		setPlaybackSampleSize(playSize);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_8&quot;&gt;streamSampleCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The average number of samples in each sound stream block.&lt;/td&gt;
-&lt;/tr&gt;
+		setStreamRate(streamingRate);
+		setStreamChannels(streamingChannels);
+		setStreamSampleSize(streamingSize);
+		setStreamSampleCount(streamingCount);
+		setLatency(latency);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_9&quot;&gt;latency&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Latency defines the number of samples to skip only when playing sounds encoded 
-with the MP3 format.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamHead2 object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSSoundStreamHead2 object.
+	 */
+	public FSSoundStreamHead2(FSSoundStreamHead2 obj)
+	{
+		super(obj);
+		format = obj.format;
+		playbackRate = obj.playbackRate;
+		playbackChannels = obj.playbackChannels;
+		playbackSampleSize = obj.playbackSampleSize;
 
-&lt;/table&gt;
+		streamRate = obj.streamRate;
+		streamChannels = obj.streamChannels;
+		streamSampleSize = obj.streamSampleSize;
+		streamSampleCount = obj.streamSampleCount;
+		latency = obj.latency;
+		_reserved = obj._reserved;
+	}
 
-&lt;p&gt;FSSoundStreamHead2 allows way the sound is played to differ from the way it is 
-encoded and streamed to the player. This allows the Player more control over how 
-the animation is rendered. Reducing the resolution or playback rate can improve 
-synchronisation with the frames displayed.&lt;/p&gt;
+	/**
+	 * Gets the streaming sound format. For the FSSoundStreamHead2 class
+	 * supports NATIVE_PCM, ADPCM, MP3, PCM or NELLYMOSER encoded sound data.
+	 * 
+	 * @return the format used to play the sound.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-&lt;b&gt;History&lt;/b&gt;
+	/**
+	 * Sets the format for the streaming sound.
+	 * 
+	 * @param encoding
+	 *            the compression format for the sound data, either
+	 *            FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or
+	 *            FSSound.NELLYMOSER.
+	 */
+	public void setFormat(int encoding)
+	{
+		format = encoding;
+	}
 
-&lt;p&gt;The FSSoundStreamHead2 class represents the SoundStreamHead structure from the 
-Flash specification. It was introduced in Flash 3. Support for the Nellymoser Asao
-format was added in Flash 6.&lt;/p&gt;
- */
-public class FSSoundStreamHead2 extends FSMovieObject
-{
-    private int format = FSSound.ADPCM;
+	/**
+	 * Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	 * 
+	 * @return the rate at which the sound will be played back.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-    private int playbackRate = 5512;
-    private int playbackChannels = 1;
-    private int playbackSampleSize = 16;
+	/**
+	 * Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @return the number of channels for the sound playback.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-    private int streamRate = 5512;
-    private int streamChannels = 1;
-    private int streamSampleSize = 16;
-    private int streamSampleCount = 0;
-    private int latency = 0;
-    
-    /*
-     * The following variable is used to preserve the value of a reserved field
-     * when decoding then encoding an existing Flash file. Macromedia's file 
-     * file format specification states that this field is always zero - it is
-     * not, so this is used to preserve the value in case it is implementing 
-     * an undocumented feature.
-     */
-    private int _reserved = 0;
+	/**
+	 * Gets the recommended playback sample range in bytes: 1 or 2.
+	 * 
+	 * @return the sample size used to play back the sound.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-    /**
-     * Construct an FSSoundStreamHead2 object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSoundStreamHead2(FSCoder coder)
-    {
-        super(SoundStreamHead2);
-        decode(coder);
-    }
-    /** Constructs an FSSoundStreamHead2 object specifying all the parameters required to define the sound.
+	/**
+	 * Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming
+	 * sound.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public float getStreamRate()
+	{
+		return streamRate;
+	}
 
-    @param encoding the compression format for the sound data, either FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER (Flash 6+ only).
-    @param playRate the recommended rate for playing the sound, either 5512, 11025, 22050 or 44100 Hz.
-    @param playChannels The recommended number of playback channels: 1 = mono or 2 = stereo.
-    @param playSize the recommended uncompressed sample size for playing the sound, either 1 or 2 bytes.
-    @param streamingRate the rate at which the sound was sampled, either 5512, 11025, 22050 or 44100 Hz.
-    @param streamingChannels the number of channels: 1 = mono or 2 = stereo.
-    @param streamingSize the sample size for the sound, either 1 or 2 bytes.
-    @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-    @param latency defines the number of samples to skip only when playing sounds encoded with the MP3 format.
-    */
-    public FSSoundStreamHead2(int encoding, int playRate, int playChannels, int playSize, int streamingRate, int streamingChannels, int streamingSize, int streamingCount, int latency)
-    {
-        super(SoundStreamHead2);
+	/**
+	 * Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	 * 
+	 * @return the number of channels in the sound.
+	 */
+	public int getStreamChannels()
+	{
+		return streamChannels;
+	}
 
-        setFormat(encoding);
+	/**
+	 * Gets the sample size in bytes: 1 or 2 in the streaming sound.
+	 * 
+	 * @return the sample size.
+	 */
+	public int getStreamSampleSize()
+	{
+		return streamSampleSize;
+	}
 
-        setPlaybackRate(playRate);
-        setPlaybackChannels(playChannels);
-        setPlaybackSampleSize(playSize);
+	/**
+	 * Gets the average number of samples in each stream block following.
+	 * 
+	 * @return the number of sound samples in each following FSSoundStreamBlock
+	 *         object.
+	 */
+	public int getStreamSampleCount()
+	{
+		return streamSampleCount;
+	}
 
-        setStreamRate(streamingRate);
-        setStreamChannels(streamingChannels);
-        setStreamSampleSize(streamingSize);
-        setStreamSampleCount(streamingCount);
-        setLatency(latency);
-    }
-    /**
-     * Constructs an FSSoundStreamHead2 object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSSoundStreamHead2 object.
-     */
-    public FSSoundStreamHead2(FSSoundStreamHead2 obj)
-    {
-        super(obj);
-        format = obj.format;
-        playbackRate = obj.playbackRate;
-        playbackChannels = obj.playbackChannels;
-        playbackSampleSize = obj.playbackSampleSize;
-        
-        streamRate = obj.streamRate;
-        streamChannels = obj.streamChannels;
-        streamSampleSize = obj.streamSampleSize;
-        streamSampleCount = obj.streamSampleCount;
-        latency = obj.latency;
-        _reserved = obj._reserved;
-    }
+	/**
+	 * Sets the recommended playback rate in Hz. Must be either: 5512, 11025,
+	 * 22050 or 44100.
+	 * 
+	 * @param playRate
+	 *            the recommended rate for playing the sound.
+	 */
+	public void setPlaybackRate(int playRate)
+	{
+		playbackRate = playRate;
+	}
 
-    /** 
-     * Gets the streaming sound format. For the FSSoundStreamHead2 class supports 
-     * NATIVE_PCM, ADPCM, MP3, PCM or NELLYMOSER encoded sound data.
-    
-        @return the format used to play the sound.
-        */
-    public int getFormat()
-    {
-        return format;
-    }
+	/**
+	 * Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @param aNumber
+	 *            the recommended number of playback channels.
+	 */
+	public void setPlaybackChannels(int aNumber)
+	{
+		playbackChannels = aNumber;
+	}
 
-    /** Sets the format for the streaming sound.
+	/**
+	 * Sets the recommended playback sample size in bytes. Must be wither 1 or
+	 * 2.
+	 * 
+	 * @param playSize
+	 *            the recommended sample size for playing the sound.
+	 */
+	public void setPlaybackSampleSize(int playSize)
+	{
+		playbackSampleSize = playSize;
+	}
 
-       @param encoding the compression format for the sound data, either 
-       FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER.
-    */
-    public void setFormat(int encoding)
-    {
-        format = encoding;
-    }
+	/**
+	 * Sets the sample rate in Hz for the streaming sound. Must be either: 5512,
+	 * 11025, 22050 or 44100.
+	 * 
+	 * @param streamingRate
+	 *            the rate at which the streaming sound was sampled.
+	 */
+	public void setStreamRate(int streamingRate)
+	{
+		streamRate = streamingRate;
+	}
 
-    /** Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	/**
+	 * Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+	 * 
+	 * @param streamingChannels
+	 *            the number of channels in the streaming sound.
+	 */
+	public void setStreamChannels(int streamingChannels)
+	{
+		streamChannels = streamingChannels;
+	}
 
-         @return the rate at which the sound will be played back.
-         */
-     public int getPlaybackRate() { return playbackRate; }
+	/**
+	 * Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+	 * 
+	 * @param streamingSize
+	 *            the sample size for the sound.
+	 */
+	public void setStreamSampleSize(int streamingSize)
+	{
+		streamSampleSize = streamingSize;
+	}
 
-     /** Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	/**
+	 * Sets the number of samples in each stream block.
+	 * 
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 */
+	public void setStreamSampleCount(int streamingCount)
+	{
+		streamSampleCount = streamingCount;
+	}
 
-         @return the number of channels for the sound playback.
-         */
-     public int getPlaybackChannels() { return playbackChannels; }
+	/**
+	 * For MP3 encoded sounds, returns the number of samples to skip when
+	 * starting to play a sound.
+	 * 
+	 * @return the number of samples skipped in an MP3 encoded sound Returns 0
+	 *         for other sound formats.
+	 */
+	public int getLatency()
+	{
+		return latency;
+	}
 
-     /** Gets the recommended playback sample range in bytes: 1 or 2.
+	/**
+	 * Set the number of samples to skip when starting to play an MP3 encoded
+	 * sound.
+	 * 
+	 * @param latency
+	 *            the number of samples to be skipped in an MP3 encoded sound
+	 *            should be 0 for other sound formats.
+	 */
+	public void setLatency(int latency)
+	{
+		this.latency = latency;
+	}
 
-         @return the sample size used to play back the sound.
-         */
-     public int getPlaybackSampleSize() { return playbackSampleSize; }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-     /** Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming sound.
+		if (super.equals(anObject))
+		{
+			FSSoundStreamHead2 typedObject = (FSSoundStreamHead2) anObject;
 
-         @return the rate at which the sound was sampled.
-         */
-     public float getStreamRate() { return streamRate; }
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result &amp;&amp; streamRate == typedObject.streamRate;
+			result = result &amp;&amp; streamChannels == typedObject.streamChannels;
+			result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
+			result = result
+							&amp;&amp; streamSampleCount == typedObject.streamSampleCount;
+			result = result &amp;&amp; latency == typedObject.latency;
+		}
+		return result;
+	}
 
-     /** Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-         @return the number of channels in the sound.
-         */
-     public int getStreamChannels() { return streamChannels; }
+		buffer.append(&quot;FSSoundStreamHead2: { &quot;);
+		buffer.append(&quot;format = &quot;).append(format).append(&quot;; &quot;);
+		buffer.append(&quot;playbackRate = &quot;).append(playbackRate).append(&quot;; &quot;);
+		buffer.append(&quot;playbackChannels = &quot;).append(playbackChannels).append(&quot;; &quot;);
+		buffer.append(&quot;playbackSampleSize = &quot;).append(playbackSampleSize).append(&quot;; &quot;);
+		buffer.append(&quot;streamRate = &quot;).append(streamRate).append(&quot;; &quot;);
+		buffer.append(&quot;streamChannels = &quot;).append(streamChannels).append(&quot;;&quot;);
+		buffer.append(&quot;streamSampleSize = &quot;).append(streamSampleSize).append(&quot;; &quot;);
+		buffer.append(&quot;streamSampleCount = &quot;).append(streamSampleCount).append(&quot;; &quot;);
+		buffer.append(&quot;latency = &quot;).append(latency).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-     /** Gets the sample size in bytes: 1 or 2 in the streaming sound.
+		return buffer.toString();
+	}
 
-         @return the sample size.
-         */
-     public int getStreamSampleSize() { return streamSampleSize; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-     /** Gets the average number of samples in each stream block following.
+		length += 4;
 
-         @return the number of sound samples in each following FSSoundStreamBlock object.
-         */
-     public int getStreamSampleCount() { return streamSampleCount; }
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			length += 2;
 
-     /** Sets the recommended playback rate in Hz. Must be either: 5512, 11025, 22050 or 44100.
+		return length;
+	}
 
-         @param playRate the recommended rate for playing the sound.
-         */
-     public void setPlaybackRate(int playRate)
-     {
-         playbackRate = playRate;
-     }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-     /** Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+		coder.writeBits(_reserved, 4);
 
-         @param aNumber the recommended number of playback channels.
-         */
-     public void setPlaybackChannels(int aNumber)
-     {
-         playbackChannels = aNumber;
-     }
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
 
-     /** Sets the recommended playback sample size in bytes. Must be wither 1 or 2.
+		coder.writeBits(format, 4);
 
-         @param playSize the recommended sample size for playing the sound.
-         */
-     public void setPlaybackSampleSize(int playSize)
-     {
-         playbackSampleSize = playSize;
-     }
+		switch (streamRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(streamSampleSize - 1, 1);
+		coder.writeBits(streamChannels - 1, 1);
+		coder.writeWord(streamSampleCount, 2);
 
-     /** Sets the sample rate in Hz for the streaming sound. Must be either: 5512, 11025, 22050 or 44100.
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			coder.writeWord(latency, 2);
+	}
 
-         @param streamingRate the rate at which the streaming sound was sampled.
-         */
-     public void setStreamRate(int streamingRate)
-     {
-         streamRate = streamingRate;
-     }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-     /** Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+		_reserved = coder.readBits(4, false);
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
 
-         @param streamingChannels the number of channels in the streaming sound.
-         */
-     public void setStreamChannels(int streamingChannels)
-     {
-         streamChannels = streamingChannels;
-     }
+		format = coder.readBits(4, false);
 
-     /** Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				streamRate = 5512;
+				break;
+			case 1:
+				streamRate = 11025;
+				break;
+			case 2:
+				streamRate = 22050;
+				break;
+			case 3:
+				streamRate = 44100;
+				break;
+		}
+		streamSampleSize = coder.readBits(1, false) + 1;
+		streamChannels = coder.readBits(1, false) + 1;
+		streamSampleCount = coder.readWord(2, false);
 
-         @param streamingSize the sample size for the sound.
-         */
-     public void setStreamSampleSize(int streamingSize)
-     {
-         streamSampleSize = streamingSize;
-     }
-
-     /** Sets the number of samples in each stream block.
-
-         @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-         */
-     public void setStreamSampleCount(int streamingCount)
-     {
-         streamSampleCount = streamingCount;
-     }
-
-     /**
-      * For MP3 encoded sounds, returns the number of samples to skip when starting to play a sound.
-      *
-      * @return the number of samples skipped in an MP3 encoded sound Returns 0 for other sound formats.
-      */
-     public int getLatency() 
-     { 
-         return latency; 
-     }
-
-     /**
-      * Set the number of samples to skip when starting to play an MP3 encoded sound.
-      *
-      * @param latency the number of samples to be skipped in an MP3 encoded sound should be 0 for other sound formats.
-      */
-     public void setLatency(int latency)
-     {
-         this.latency = latency;
-     }
-     
-     public boolean equals(Object anObject)
-     {
-         boolean result = false;
-        
-         if (super.equals(anObject))
-         {
-             FSSoundStreamHead2 typedObject = (FSSoundStreamHead2)anObject;
-            
-             result = format == typedObject.format;
-             result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-             result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-             result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-             result = result &amp;&amp; streamRate == typedObject.streamRate;
-             result = result &amp;&amp; streamChannels == typedObject.streamChannels;
-             result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
-             result = result &amp;&amp; streamSampleCount == typedObject.streamSampleCount;
-             result = result &amp;&amp; latency == typedObject.latency;
-         }
-         return result;
-     }
-
-     public void appendDescription(StringBuffer buffer, int depth)
-     {
-         buffer.append(name());
-        
-         if (depth &gt; 0)
-         {
-             buffer.append(&quot;: { &quot;);
-             Transform.append(buffer, &quot;format&quot;, format);
-             Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-             Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-             Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-             Transform.append(buffer, &quot;streamRate&quot;, streamRate);
-             Transform.append(buffer, &quot;streamChannels&quot;, streamChannels);
-             Transform.append(buffer, &quot;streamSampleSize&quot;, streamSampleSize);
-             Transform.append(buffer, &quot;streamSampleCount&quot;, streamSampleCount);
-             Transform.append(buffer, &quot;latency&quot;, latency);
-             buffer.append(&quot;}&quot;);
-         }
-     }
-
-     public int length(FSCoder coder)
-     {
-         super.length(coder);
-    
-         length += 4;
-        
-         if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-             length += 2;
-        
-         return length;
-     }
-    
-     public void encode(FSCoder coder)
-     {
-         super.encode(coder);
-        
-         coder.writeBits(_reserved, 4);
-
-         switch (playbackRate)
-         {
-             case 5512:
-                 coder.writeBits(0, 2);
-                 break;
-             case 11025:
-                 coder.writeBits(1, 2);
-                 break;
-             case 22050:
-                 coder.writeBits(2, 2);
-                 break;
-             case 44100:
-                 coder.writeBits(3, 2);
-                 break;
-         }
-         coder.writeBits(playbackSampleSize-1, 1);
-         coder.writeBits(playbackChannels-1, 1);
-
-         coder.writeBits(format, 4);
-
-         switch (streamRate)
-         {
-             case 5512:
-                 coder.writeBits(0, 2);
-                 break;
-             case 11025:
-                 coder.writeBits(1, 2);
-                 break;
-             case 22050:
-                 coder.writeBits(2, 2);
-                 break;
-             case 44100:
-                 coder.writeBits(3, 2);
-                 break;
-         }
-         coder.writeBits(streamSampleSize-1, 1);
-         coder.writeBits(streamChannels-1, 1);
-         coder.writeWord(streamSampleCount, 2);
-
-         if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-             coder.writeWord(latency, 2);
-
-         coder.endObject(name());
-     }
-    
-     public void decode(FSCoder coder)
-     {
-         super.decode(coder);
-        
-         _reserved = coder.readBits(4, false);
-         switch (coder.readBits(2, false))
-         {
-             case 0:
-                 playbackRate = 5512;
-                 break;
-             case 1:
-                 playbackRate = 11025;
-                 break;
-             case 2:
-                 playbackRate = 22050;
-                 break;
-             case 3:
-                 playbackRate = 44100;
-                 break;
-         }
-         playbackSampleSize = coder.readBits(1, false)+1;
-         playbackChannels = coder.readBits(1, false)+1;
-
-         format = coder.readBits(4, false);
-
-         switch (coder.readBits(2, false))
-         {
-             case 0:
-                 streamRate = 5512;
-                 break;
-             case 1:
-                 streamRate = 11025;
-                 break;
-             case 2:
-                 streamRate = 22050;
-                 break;
-             case 3:
-                 streamRate = 44100;
-                 break;
-         }
-         streamSampleSize = coder.readBits(1, false)+1;
-         streamChannels = coder.readBits(1, false)+1;
-         streamSampleCount = coder.readWord(2, false);
-        
-         if (length == 6 &amp;&amp; format == FSSound.MP3)
-             latency = coder.readWord(2, true);
-
-         coder.endObject(name());
-     }
+		if (length == 6 &amp;&amp; format == FSSound.MP3)
+			latency = coder.readWord(2, true);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSStartSound.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSStartSound.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSStartSound.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,134 +31,157 @@
 package com.flagstone.transform;
 
 /**
-FSStartSound instructs the player to start or stop playing a sound defined using the 
- FSDefineSound class.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSStartSound instructs the player to start or stop playing a sound defined
+ * using the FSDefineSound class.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that identifies the sound and controls how it is
+ * played - how the sound fades in or out, whether it is repeated along with an
+ * envelope that controls the sound levels as it is played.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSStartSound class represents the StartSound tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1. In the
+ * Macromedia Flash (SWF) File Format Specification the StartSound tag contains
+ * an identifier and an FSSoundInfo structure. The Transform FSSound object
+ * simply combines both to simplify the design of other sound classes. The
+ * information encoded is identical.
+ * &lt;/p&gt;
+ */
+public class FSStartSound extends FSMovieObject
+{
+	private FSSound sound = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSStartSound object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSStartSound(FSCoder coder)
+	{
+		super(FSMovieObject.StartSound);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSStartSound_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSStartSound object with an FSSound object that identifies
+	 * the sound and controls how it is played.
+	 * 
+	 * @param aSound
+	 *            the FSSound object.
+	 */
+	public FSStartSound(FSSound aSound)
+	{
+		super(FSMovieObject.StartSound);
+		setSound(aSound);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSStartSound_1&quot;&gt;sound&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that identifies the sound and controls how it is played - how the sound fades in or out, whether it is repeated along with an envelope that controls the sound levels as it is played.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSStartSound object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSStartSound object.
+	 */
+	public FSStartSound(FSStartSound obj)
+	{
+		super(obj);
+		sound = new FSSound(obj.sound);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the FSSound object describing how the sound will be played.
+	 * 
+	 * @return the FSSound object.
+	 */
+	public FSSound getSound()
+	{
+		return sound;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the FSSound object that describes how the sound will be played.
+	 * 
+	 * @param aSound
+	 *            the FSSound object that controls how the sound is played.
+	 */
+	public void setSound(FSSound aSound)
+	{
+		sound = aSound;
+	}
 
-&lt;p&gt;The FSStartSound class represents the StartSound tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1. In the Macromedia Flash (SWF) File Format Specification the StartSound tag contains an identifier and an FSSoundInfo structure. The Transform FSSound object simply combines both to simplify the design of other sound classes. The information encoded is identical.&lt;/p&gt;
- */
-public class FSStartSound extends FSMovieObject
-{
-    private FSSound sound = null;
+	public Object clone()
+	{
+		FSStartSound anObject = (FSStartSound) super.clone();
 
-    /**
-     * Construct an FSStartSound object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSStartSound(FSCoder coder)
-    {
-        super(FSMovieObject.StartSound);
-        decode(coder);
-    }
-    /** Constructs an FSStartSound object with an FSSound object that identifies the sound and controls how it is played.
+		anObject.sound = (sound != null) ? (FSSound) sound.clone() : null;
 
-        @param aSound the FSSound object.
-        */
-    public FSStartSound(FSSound aSound)
-    {
-        super(FSMovieObject.StartSound);
-        setSound(aSound);
-    }
-    /**
-     * Constructs an FSStartSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSStartSound object.
-     */
-    public FSStartSound(FSStartSound obj)
-    {
-        super(obj);
-        sound = new FSSound(obj.sound);
-    }    
+		return anObject;
+	}
 
-    /**  Gets the FSSound object describing how the sound will be played.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the FSSound object.
-        */
-    public FSSound getSound() { return sound; }
+		if (super.equals(anObject))
+		{
+			FSStartSound typedObject = (FSStartSound) anObject;
 
-    /**  Sets the FSSound object that describes how the sound will be played.
+			if (sound != null)
+				result = sound.equals(typedObject.sound);
+			else
+				result = sound == typedObject.sound;
+		}
+		return result;
+	}
 
-        @param aSound the FSSound object that controls how the sound is played.
-        */
-    public void setSound(FSSound aSound)
-    {
-        sound = aSound;
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    public Object clone()
-    {
-        FSStartSound anObject = (FSStartSound)super.clone();
-        
-        anObject.sound = (sound!= null) ? (FSSound)sound.clone() : null;
-        
-        return anObject;
-    }
+		buffer.append(&quot;FSStartSound: { &quot;);
+		buffer.append(&quot;sound = &quot;).append(sound.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSStartSound typedObject = (FSStartSound)anObject;
-            
-            if (sound != null)
-                 result = sound.equals(typedObject.sound);
-            else
-                result = sound == typedObject.sound;
-        }            
-        return result;
-    }
+		return buffer.toString();
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;sound&quot;, sound, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += sound.length(coder);
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += sound.length(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        sound.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);        
-        sound = new FSSound(coder);
-        coder.endObject(name());
-    }
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		sound.encode(coder);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		sound = new FSSound(coder);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSTabOrder.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSTabOrder.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSTabOrder.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,167 +31,182 @@
 package com.flagstone.transform;
 
 /**
-The FSTabOrder class is used to set the tabbing order of text fields, movie clips and 
-buttons visible on the display list.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * The FSTabOrder class is used to set the tabbing order of text fields, movie
+ * clips and buttons visible on the display list.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The layer number which contains the object assigned to the tabbing
+ * order.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;index&lt;/td&gt;
+ * &lt;td&gt;The index of the object in the tabbing order.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSTabOrder object represents the SetTabIndex tag in the Flash file
+ * specification . It was introduced in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSTabOrder extends FSMovieObject
+{
+	private int layer = 0;
+	private int index = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSTabOrder object, initializing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSTabOrder(FSCoder coder)
+	{
+		super(TabOrder);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct a FSTabOrder object that set the tab order for the object on
+	 * the display list at the specified layer.
+	 * 
+	 * @param layer
+	 *            the layer number which contains the object assigned to the
+	 *            tabbing order.
+	 * @param index
+	 *            the index of the object in the tabbing order.
+	 */
+	public FSTabOrder(int layer, int index)
+	{
+		super(TabOrder);
+		setLayer(layer);
+		setIndex(index);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_1&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The layer number which contains the object assigned to the tabbing order.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSTabOrder object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSTabOrder object.
+	 */
+	public FSTabOrder(FSTabOrder obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_2&quot;&gt;index&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index of the object in the tabbing order.&lt;/td&gt;
-&lt;/tr&gt;
+		layer = obj.layer;
+		index = obj.index;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the layer number which contains the object assigned to the tabbing
+	 * order.
+	 * 
+	 * @return the layer number.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the layer number which contains the object assigned to the tabbing
+	 * order.
+	 * 
+	 * @param layer
+	 *            the layer number.
+	 */
+	public void setLayer(int layer)
+	{
+		this.layer = layer;
+	}
 
-&lt;p&gt;The FSTabOrder object represents the SetTabIndex tag in the Flash file specification . It was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSTabOrder extends FSMovieObject
-{
-    private int layer = 0; 
-    private int index = 0; 
-    
-    /**
-     * Construct an FSTabOrder object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSTabOrder(FSCoder coder)
-    {
-        super(TabOrder);
-        decode(coder);
-    }
+	/**
+	 * Gets the index of the object in the tabbing order.
+	 * 
+	 * @return the index in the tabbing order.
+	 */
+	public int getIndex()
+	{
+		return index;
+	}
 
-    /**
-     * Construct a FSTabOrder object that set the tab order for the object on the display list
-     * at the specified layer.
-     *
-     * @param layer the layer number which contains the object assigned to the tabbing order.
-     * @param index the index of the object in the tabbing order.
-     */
-    public FSTabOrder(int layer, int index)
-    {
-        super(TabOrder);
-        setLayer(layer);
-        setIndex(index);
-    }
-    /**
-     * Constructs an FSTabOrder object by copying values from an existing object.
-     *
-     * @param obj an FSTabOrder object.
-     */
-    public FSTabOrder(FSTabOrder obj)
-    {
-        super(obj);
-        
-        layer = obj.layer;
-        index = obj.index;
-    }
-    /**
-     * Gets the layer number which contains the object assigned to the tabbing order.
-     *
-     * @return the layer number.
-     */
-    public int getLayer() 
-    {
-        return layer;
-    }
+	/**
+	 * Sets the index of the object in the tabbing order.
+	 * 
+	 * @param index
+	 *            the index in the tabbing order.
+	 */
+	public void setIndex(int index)
+	{
+		this.index = index;
+	}
 
-    /**
-     * Sets the layer number which contains the object assigned to the tabbing order.
-     *
-     * @param layer the layer number.
-     */
-    public void setLayer(int layer)
-    {
-        this.layer = layer;
-    }
-    
-    /**
-     * Gets the index of the object in the tabbing order.
-     *
-     * @return the index in the tabbing order.
-     */
-    public int getIndex() 
-    {
-        return index;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Sets the index of the object in the tabbing order.
-     *
-     * @param index the index in the tabbing order.
-     */
-    public void setIndex(int index)
-    {
-        this.index = index;
-    }
-    
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSTabOrder typedObject = (FSTabOrder) anObject;
-            
-            result = layer == typedObject.layer;
-            result = result &amp;&amp; index == typedObject.index;
-        }
-        return result;
-    }
+		if (super.equals(anObject))
+		{
+			FSTabOrder typedObject = (FSTabOrder) anObject;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;layer&quot;, this.layer);
-            Transform.append(buffer, &quot;index&quot;, index);
-              buffer.append(&quot;}&quot;);
-        }
-    }
+			result = layer == typedObject.layer;
+			result = result &amp;&amp; index == typedObject.index;
+		}
+		return result;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(layer, 2);
-        coder.writeWord(index, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        layer = coder.readWord(2, false);
-        index = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
+
+		buffer.append(&quot;FSTabOrder: { &quot;);
+		buffer.append(&quot;layer = &quot;).append(layer).append(&quot;; &quot;);
+		buffer.append(&quot;index = &quot;).append(index).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 4;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(layer, 2);
+		coder.writeWord(index, 2);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		layer = coder.readWord(2, false);
+		index = coder.readWord(2, false);
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSTable.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSTable.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSTable.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,231 +33,256 @@
 import java.util.*;
 
 /**
-FSTable is used to create a table of string literals that can be referenced by an index 
- rather than using the literal value when executing a sequence of actions.
- 
-&lt;p&gt;Variables and built-in functions are specified by their name and the FSTable 
-class contains a table of the respective strings. References to a variable or 
-function can then use its index in the table rather than the name resulting in 
-a more compact representation when the actions are encoded into binary form.&lt;/p&gt;
+ * FSTable is used to create a table of string literals that can be referenced
+ * by an index rather than using the literal value when executing a sequence of
+ * actions.
+ * 
+ * &lt;p&gt;
+ * Variables and built-in functions are specified by their name and the FSTable
+ * class contains a table of the respective strings. References to a variable or
+ * function can then use its index in the table rather than the name resulting
+ * in a more compact representation when the actions are encoded into binary
+ * form.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;values&lt;/td&gt;
+ * &lt;td&gt;An array of up to 65536 strings.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The use of the FSTable class is illustrated in the following simple
+ * expression:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * var1 = (var1 + var2) / (var1 - var3);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This can be translated into the following sequence of actions:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSTable values = new FSTable();
+ * 
+ * values.add(&quot;var1&quot;);
+ * values.add(&quot;var2&quot;);
+ * values.add(&quot;var3&quot;);
+ * 
+ * actions.add(values);
+ * 
+ * actions.add(new FSPush(FSTableIndex(0))); // var1
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSTableIndex(0))); // var1
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSTableIndex(1))); // var2
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSAction(FSAction.Add));
+ * actions.add(new FSPush(FSTableIndex(0))); // var1
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSTableIndex(2))); // var3
+ * actions.add(FSAction.Subtract());
+ * actions.add(FSAction.Divide());
+ * actions.add(FSAction.SetVariable());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The table in the FSTable class can support up to 65536 different variables.
+ * As a result using the FSVariable class to reference the variables in the
+ * example above uses one byte rather than the five required to represent the
+ * name directly (including the null character terminating the string).
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSTable stores the strings in an array. No checking for duplicate values
+ * is performed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSTable class represents the ActionConstantPool in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5. It was
+ * extended in Flash 6 to support tables of up to 65536 strings.
+ * &lt;/p&gt;
+ */
+public class FSTable extends FSActionObject
+{
+	private ArrayList values = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSTable object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSTable(FSCoder coder)
+	{
+		super(Table);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Constructs an empty table. */
+	public FSTable()
+	{
+		super(Table);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSTable_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSTable object using the array of strings.
+	 * 
+	 * @param anArray
+	 *            of Strings that will be added to the table.
+	 */
+	public FSTable(ArrayList anArray)
+	{
+		super(Table);
+		setValues(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSTable_1&quot;&gt;values&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of up to 65536 strings.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSTable object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSTable(FSTable obj)
+	{
+		super(obj);
 
-&lt;p&gt;The use of the FSTable class is illustrated in the following simple expression:&lt;/p&gt;
+		values = new ArrayList(obj.values.size());
 
-&lt;pre&gt;
-var1 = (var1 + var2) / (var1 - var3);
-&lt;/pre&gt;
+		for (Iterator i = obj.values.iterator(); i.hasNext();)
+			values.add(new String((String) i.next()));
+	}
 
-&lt;p&gt;This can be translated into the following sequence of actions:&lt;/p&gt;
+	/**
+	 * Adds a String to the variable table.
+	 * 
+	 * @param aString
+	 *            a String that will be added to the end of the table.
+	 */
+	public void add(String aString)
+	{
+		values.add(aString);
+	}
 
-&lt;pre&gt;
-FSTable values = new FSTable();
+	/**
+	 * Gets the array of Strings stored in the variable table.
+	 * 
+	 * @return the array of string literals.
+	 */
+	public ArrayList getValues()
+	{
+		return values;
+	}
 
-values.add(&quot;var1&quot;);
-values.add(&quot;var2&quot;);
-values.add(&quot;var3&quot;);
+	/**
+	 * Sets the array of Strings stored in the literal table.
+	 * 
+	 * @param anArray
+	 *            of Strings that will replaces the existing literal table.
+	 */
+	public void setValues(ArrayList anArray)
+	{
+		values = anArray;
+	}
 
-actions.add(values);
+	public Object clone()
+	{
+		FSTable anObject = (FSTable) super.clone();
 
-actions.add(new FSPush(FSTableIndex(0)));            // var1
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSTableIndex(0)));            // var1
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSTableIndex(1)));            // var2
-actions.add(FSAction.GetVariable());
-actions.add(new FSAction(FSAction.Add));
-actions.add(new FSPush(FSTableIndex(0)));            // var1
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSTableIndex(2)));            // var3
-actions.add(FSAction.Subtract());
-actions.add(FSAction.Divide());
-actions.add(FSAction.SetVariable());
-&lt;/pre&gt;
+		anObject.values = new ArrayList();
 
-&lt;p&gt;The table in the FSTable class can support up to 65536 different variables. As 
-a result using the FSVariable class to reference the variables in the example 
-above uses one byte rather than the five required to represent the name directly 
-(including the null character terminating the string).&lt;/p&gt;
+		for (Iterator i = values.iterator(); i.hasNext();)
+			anObject.values.add(new String((String) i.next()));
 
-&lt;p&gt;The FSTable stores the strings in an array. No checking for duplicate values is performed.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSTable class represents the ActionConstantPool in the Macromedia Flash (SWF)
-File Format Specification. It was introduced in Flash 5. It was extended in Flash 
-6 to support tables of up to 65536 strings.&lt;/p&gt;
- */  
-public class FSTable extends FSActionObject
-{
-    private ArrayList values = null;
-    
-    /**
-     * Construct an FSTable object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSTable(FSCoder coder)
-    {
-        super(Table);
-        decode(coder);
-    }
-    /** Constructs an empty table. */
-    public FSTable()
-    {
-        super(Table);
-    }
-    /** Constructs an FSTable object using the array of strings.
+		if (super.equals(anObject))
+			result = values.equals(((FSTable) anObject).getValues());
 
-        @param anArray of Strings that will be added to the table.
-        */
-    public FSTable(ArrayList anArray)
-    {
-        super(Table);
-        setValues(anArray);
-    }
-    /**
-     * Constructs an FSTable object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSTable(FSTable obj)
-    {
-        super(obj);
+		return result;
+	}
 
-        values = new ArrayList(obj.values.size());
-        
-        for (Iterator i = obj.values.iterator(); i.hasNext();)
-            values.add(new String((String)i.next()));
-    }    
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Adds a String to the variable table.
+		buffer.append(&quot;FSTable: { &quot;);
+		buffer.append(&quot;values = array[&quot;).append(values.size()).append(&quot;]; &quot;);
+		buffer.append(&quot;}&quot;);
 
-        @param aString a String that will be added to the end of the table.
-        */
-    public void add(String aString)
-    {
-        values.add(aString);
-    }
+		return buffer.toString();
+	}
 
-    /** Gets the array of Strings stored in the variable table.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @return the array of string literals.
-        */
-    public ArrayList getValues()
-    {
-        return values;
-    }
+		length += 2;
 
-    /** Sets the array of Strings stored in the literal table.
+		for (Iterator i = values.iterator(); i.hasNext();)
+			length += coder.strlen((String) i.next(), true);
 
-        @param anArray of Strings that will replaces the existing literal table.
-        */
-    public void setValues(ArrayList anArray)
-    {
-        values = anArray;
-    }
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSTable anObject = (FSTable)super.clone();
-        
-        anObject.values = new ArrayList();
-            
-        for (Iterator i = values.iterator(); i.hasNext();)
-            anObject.values.add(new String((String)i.next()));
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        return anObject;
-    }
+		coder.writeWord(values.size(), 2);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = values.equals(((FSTable)anObject).getValues());
+		if (values.size() &gt; 0)
+		{
+			for (Iterator i = values.iterator(); i.hasNext();)
+			{
+				coder.writeString((String) i.next());
+				coder.writeWord(0, 1);
+			}
+		}
+	}
 
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;values&quot;, values, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		int attributeCount = coder.readWord(2, false);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        for (Iterator i = values.iterator(); i.hasNext();)
-            length += coder.strlen((String)i.next(), true); 
-                    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		if (attributeCount &gt; 0)
+		{
+			values = new ArrayList();
 
-        coder.writeWord(values.size(), 2);
-        
-        if (values.size() &gt; 0)
-        {
-            for (Iterator i = values.iterator(); i.hasNext();)
-            {
-                coder.writeString((String)i.next());
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int attributeCount = coder.readWord(2, false);
-        
-        if (attributeCount &gt; 0)
-        {
-            values = new ArrayList();
-            
-            for (int i=0; i&lt;attributeCount; i++)
-                values.add(coder.readString());
-        }
-        else
-        {
-            /*
-             * Reset the length as Macromedia is using the length of a 
-             * table to hide coded following an empty table.
-             */
-            length = 2;
-            values = new ArrayList();
-        }
-        coder.endObject(name());
-    }
+			for (int i = 0; i &lt; attributeCount; i++)
+				values.add(coder.readString());
+		} else
+		{
+			/*
+			 * Reset the length as Macromedia is using the length of a table to
+			 * hide coded following an empty table.
+			 */
+			length = 2;
+			values = new ArrayList();
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSText.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSText.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSText.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,568 +33,681 @@
 import java.util.*;
 
 /**
-FSText is used to display a line of text. 
- 
-&lt;p&gt;It contains an array of FSCharacter 
-objects which identify the glyphs that will be displayed along with style information 
-that sets the colour of the text, the size of the font and the relative placement 
-of the line within a block of text.&lt;/p&gt;
+ * FSText is used to display a line of text.
+ * 
+ * &lt;p&gt;
+ * It contains an array of FSCharacter objects which identify the glyphs that
+ * will be displayed along with style information that sets the colour of the
+ * text, the size of the font and the relative placement of the line within a
+ * block of text.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the font object which contains
+ * the glyphs representing each character displayed. Optional. Set to 0 if the
+ * font is not being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;color&lt;/td&gt;
+ * &lt;td&gt;An FSColor object describing colour of the text. Optional. Set to null
+ * if the colour is not being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;offsetX&lt;/td&gt;
+ * &lt;td&gt;The offset, in twips, relative to the left side bounding rectangle of
+ * the text block where the text will be displayed. Optional. Set to zero if no
+ * indent is being specified.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;offsetY&lt;/td&gt;
+ * &lt;td&gt;The offset, in twips, relative to the bottom of the bounding rectangle
+ * of the text block where the text will be displayed. Optional. Set to the
+ * height of the font if only a single line of text is being displayed so the
+ * characters are placed correctly within the bounding rectangle defined for the
+ * text object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;The height of the font, in twips, used to render the characters.
+ * Optional. Set to zero if the font size is not being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;characters&lt;/td&gt;
+ * &lt;td&gt;An array of FSCharacter objects which identify the glyph that will be
+ * displayed along with the spacing to the next character in the line of text.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Whether the alpha channel in the colour needs to be specified depends on the
+ * class the FSText is added to. The FSDefineText2 class supports transparent
+ * text while FSDefineText class does not.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The x and y offsets are used to control how several FSText objects are laid
+ * out to create a block of text. The y offset is specified relative to the
+ * bottom edge of the bounding rectangle, which is actually closer to the top of
+ * the screen as the direction of the y-axis is from the top to the bottom of
+ * the screen. In this respect Flash is counter-intuitive. Lines with higher
+ * offset values are displayed below lines with lower offsets.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When several FSText objects are used to define a block of text using the
+ * FSDefineText or FSDefineText2 classes the attributes such as the font
+ * selected, size and colour must be specified in the first FSText object. For
+ * the remaining FSText objects these may be set to null or zero. The attributes
+ * will apply to all following FSText object until explicitly changed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The creation and layout of the glyphs to create the text is too onerous to
+ * perform from scratch. It is easier and more convenient to use existing font
+ * definitions either by parsing an existing Flash file or by converting a font
+ * definition from a specification such as TrueType in order to obtain the
+ * glyphs and layout information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Creating a simple string.&lt;br/&gt; This examples assumes a font definition
+ * that contains glyphs for the following set of characters ' ', 'a', 'b', 'c'
+ * .... 'x', 'y', 'z'. The font used fixed size for the spacing between glyphs
+ * .e.g. Courier.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * ArrayList characters = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and displaying 
+ * // the characters in black. The text is not indented or offset.
+ * 
+ * int xOffset = 0;
+ * int yOffset = 240;
+ * int fontSize = 240;
+ * 
+ * FSText string = new FSText(font.getIdentifier(), FSColorTable.black(), xOffset,
+ * 				yOffset, fontSize, characters);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Creating a block of text.&lt;br/&gt; Again this examples assumes a fixed size
+ * font definition that contains glyphs for the set of characters.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * ArrayList line1 = new ArrayList();
+ * 
+ * line1.add(new FSCharacter(19, 120)); // 's'
+ * line1.add(new FSCharacter(10, 120)); // 't'
+ * line1.add(new FSCharacter(18, 120)); // 'r'
+ * line1.add(new FSCharacter(9, 120)); // 'i'
+ * line1.add(new FSCharacter(14, 120)); // 'n'
+ * line1.add(new FSCharacter(6, 120)); // 'g'
+ * line1.add(new FSCharacter(0, 120)); // ' '
+ * line1.add(new FSCharacter(28, 120)); // '1'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and 
+ * // displaying the characters in black. The text is not indented or offset.
+ * 
+ * int fontSize = 240;
+ * int yOffset = 240;
+ * 
+ * FSText string1 = new FSText(font.getIdentifier(), FSColorTable.black(), 0,
+ * 				yOffset, fontSize, line1);
+ * 
+ * ArrayList line1 = new ArrayList();
+ * 
+ * line2.add(new FSCharacter(19, 120)); // 's'
+ * line2.add(new FSCharacter(10, 120)); // 't'
+ * line2.add(new FSCharacter(18, 120)); // 'r'
+ * line2.add(new FSCharacter(9, 120)); // 'i'
+ * line2.add(new FSCharacter(14, 120)); // 'n'
+ * line2.add(new FSCharacter(6, 120)); // 'g'
+ * line2.add(new FSCharacter(0, 120)); // ' '
+ * line2.add(new FSCharacter(29, 120)); // '2'
+ * 
+ * // Display the second string 'one line' height (240 twips) below the first. 
+ * // The font size and colour remain unchanged.
+ * 
+ * yOffset += fontSize;
+ * 
+ * FSText string2 = new FSText(0, yOffset, line2);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSText class represents both the TextRecordType0 and TextRecordType1
+ * structures from the Macromedia Flash (SWF) File Format Specification. It was
+ * introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSText implements Cloneable, Codeable
+{
+	/** Defines that the font character set is based on the Unicode standard. */
+	public static final int Unicode = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Defines that the font character set is based on the SJIS standard for
+	 * representing Kanji characters.
+	 */
+	public static final int SJIS = 2;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Defines that the font character set is based on the ANSI UTF-8 standard
+	 * which supports standard ASCII encoded strings.
+	 */
+	public static final int ANSI = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_0&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the font object which contains the 
-glyphs representing each character displayed. Optional. Set to 0 if the font is 
-not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 6
+	// / Code used to identify the spoken language for Latin fonts.
+	public static final int Latin = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColor object describing colour of the text. Optional. Set to null if the 
-colour is not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for Japanese fonts.
+	public static final int Japanese = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_2&quot;&gt;offsetX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The offset, in twips, relative to the left side bounding rectangle of the text 
-block where the text will be displayed. Optional. Set to zero if no indent is being 
-specified.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for Japanese fonts.
+	public static final int Korean = 3;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_3&quot;&gt;offsetY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The offset, in twips, relative to the bottom of the bounding rectangle of the 
-text block where the text will be displayed. Optional. Set to the height of the 
-font if only a single line of text is being displayed so the characters are placed 
-correctly within the bounding rectangle defined for the text object.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for simplified Chinese fonts.
+	public static final int SimplifiedChinese = 4;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_4&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The height of the font, in twips,  used to render the characters. Optional. 
-Set to zero if the font size is not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for traditional Chinese
+	// fonts.
+	public static final int TraditionalChinese = 5;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_5&quot;&gt;characters&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSCharacter objects which identify the glyph that will be displayed 
-along with the spacing to the next character in the line of text.&lt;/td&gt;
-&lt;/tr&gt;
+	// End Flash 6
 
-&lt;/table&gt;
+	private int identifier = 0;
 
-&lt;p&gt;Whether the alpha channel in the colour needs to be specified depends on the 
-class the FSText is added to. The FSDefineText2 class supports transparent text 
-while FSDefineText class does not.&lt;/p&gt;
+	private FSColor color = null;
 
-&lt;p&gt;The x and y offsets are used to control how several FSText objects are laid 
-out to create a block of text. The y offset is specified relative to the bottom 
-edge of the bounding rectangle, which is actually closer to the top of the screen 
-as the direction of the y-axis is from the top to the bottom of the screen. In this 
-respect Flash is counter-intuitive. Lines with higher offset values are displayed 
-below lines with lower offsets.&lt;/p&gt;
+	private int offsetX = Transform.VALUE_NOT_SET;
 
-&lt;p&gt;When several FSText objects are used to define a block of text using the FSDefineText 
-or FSDefineText2 classes the attributes such as the font selected, size and colour 
-must be specified in the first FSText object. For the remaining FSText objects 
-these may be set to null or zero. The attributes will apply to all following FSText 
-object until explicitly changed.&lt;/p&gt;
+	private int offsetY = Transform.VALUE_NOT_SET;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	private int height = 0;
 
-&lt;p&gt;The creation and layout of the glyphs to create the text is too onerous to 
-perform from scratch. It is easier and more convenient to use existing font 
-definitions either by parsing an existing Flash file or by converting a font 
-definition from a specification such as TrueType in order to obtain the glyphs 
-and layout information.&lt;/p&gt;
+	private ArrayList characters = new ArrayList();
 
-&lt;p&gt;1. Creating a simple string.&lt;br/&gt;
-This examples assumes a font definition that contains glyphs for the following 
-set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font used fixed size 
-for the spacing between glyphs .e.g. Courier.&lt;/p&gt;
+	/**
+	 * Construct an FSText object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSText(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;pre&gt;
-ArrayList characters = new ArrayList();
+	/**
+	 * Constructs an FSText object specifying the array of characters to be
+	 * displayed and their relative placement within a block of text. The
+	 * selected font, colour of the text and height will remain unchanged from
+	 * previous settings.
+	 * 
+	 * @param xOffset
+	 *            the location of the text relative to the left edge of the
+	 *            bounding rectangle enclosing the block of text.
+	 * @param yOffset
+	 *            the location of the text relative to the bottom edge of the
+	 *            bounding rectangle enclosing the block of text.
+	 * @param anArray
+	 *            an array of FSCharacter objects.
+	 */
+	public FSText(int xOffset, int yOffset, ArrayList anArray)
+	{
+		setOffsetX(xOffset);
+		setOffsetY(yOffset);
+		setCharacters(anArray);
+	}
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+	/**
+	 * Constructs an FSText object, specifying the colour and position of the
+	 * following FSText.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the font that the text will be rendered in.
+	 * @param aColor
+	 *            the colour of the text.
+	 * @param xOffset
+	 *            the location of the text relative to the left edge of the
+	 *            bounding rectangle enclosing the text.
+	 * @param yOffset
+	 *            the location of the text relative to the bottom edge of the
+	 *            bounding rectangle enclosing the text.
+	 * @param aHeight
+	 *            the height of the text in the chosen font.
+	 * @param anArray
+	 *            an array of FSCharacter objects.
+	 */
+	public FSText(int anIdentifier, FSColor aColor, int xOffset, int yOffset,
+					int aHeight, ArrayList anArray)
+	{
+		setIdentifier(anIdentifier);
+		setColor(aColor);
+		setOffsetX(xOffset);
+		setOffsetY(yOffset);
+		setHeight(aHeight);
+		setCharacters(anArray);
+	}
 
-// Create the string setting the height to be 12-point (240 twips) and displaying 
-// the characters in black. The text is not indented or offset.
+	/**
+	 * Constructs an FSText object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSText object.
+	 */
+	public FSText(FSText obj)
+	{
+		identifier = obj.identifier;
+		color = new FSColor(obj.color);
+		offsetX = obj.offsetX;
+		offsetY = obj.offsetY;
+		height = obj.height;
 
-int xOffset = 0;
-int yOffset = 240;
-int fontSize = 240;
+		characters = new ArrayList(obj.characters.size());
 
-FSText string = new FSText(font.getIdentifier(), FSColorTable.black(), xOffset, yOffset, fontSize, characters);
-&lt;/pre&gt;
+		for (Iterator&lt;FSCharacter&gt; i = obj.characters.iterator(); i.hasNext();)
+			characters.add(i.next().clone());
+	}
 
-&lt;p&gt;2. Creating a block of text.&lt;br/&gt;
-Again this examples assumes a fixed size font definition that contains glyphs for 
-the set of characters.&lt;/p&gt;
+	/**
+	 * Gets the identifier of the font in which the text will be displayed.
+	 * 
+	 * @return the identifier of the font.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;pre&gt;
-ArrayList line1 = new ArrayList();
+	/**
+	 * Gets the colour of the font in which the text will be displayed.
+	 * 
+	 * @return the colour of the text.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-line1.add(new FSCharacter(19, 120)); // 's'
-line1.add(new FSCharacter(10, 120)); // 't'
-line1.add(new FSCharacter(18, 120)); // 'r'
-line1.add(new FSCharacter(9, 120));  // 'i'
-line1.add(new FSCharacter(14, 120)); // 'n'
-line1.add(new FSCharacter(6, 120));  // 'g'
-line1.add(new FSCharacter(0, 120));  // ' '
-line1.add(new FSCharacter(28, 120));  // '1'
+	/**
+	 * Gets the location of the start of the text relative to the left edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @return the indentation applied to the text.
+	 */
+	public int getOffsetX()
+	{
+		return offsetX;
+	}
 
-// Create the string setting the height to be 12-point (240 twips) and 
-// displaying the characters in black. The text is not indented or offset.
+	/**
+	 * Gets the location of the start of the text relative to the bottom edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @return the location of the text relative to the bottom of the bounding
+	 *         rectangle.
+	 */
+	public int getOffsetY()
+	{
+		return offsetY;
+	}
 
-int fontSize = 240;
-int yOffset = 240;
+	/**
+	 * Gets the height of the text.
+	 * 
+	 * @return the height of the font used to displayed the text.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-FSText string1 = new FSText(font.getIdentifier(), FSColorTable.black(), 0, yOffset, fontSize, line1);
+	/**
+	 * Sets the identifier of the font in which the text will be displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the font that the text will be rendered in.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
+	/**
+	 * Sets the colour of the font in which the text will be displayed.
+	 * 
+	 * @param aColor
+	 *            the colour of the text.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-ArrayList line1 = new ArrayList();
+	/**
+	 * Sets the location of the start of the text relative to the left edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @param xOffset
+	 *            the location of the text relative to the left edge of the
+	 *            bounding rectangle enclosing the text.
+	 */
+	public void setOffsetX(int xOffset)
+	{
+		offsetX = xOffset;
+	}
 
-line2.add(new FSCharacter(19, 120)); // 's'
-line2.add(new FSCharacter(10, 120)); // 't'
-line2.add(new FSCharacter(18, 120)); // 'r'
-line2.add(new FSCharacter(9, 120));  // 'i'
-line2.add(new FSCharacter(14, 120)); // 'n'
-line2.add(new FSCharacter(6, 120));  // 'g'
-line2.add(new FSCharacter(0, 120));  // ' '
-line2.add(new FSCharacter(29, 120));  // '2'
+	/**
+	 * Sets the location of the start of the text relative to the bottom edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @param yOffset
+	 *            the location of the text relative to the bottom edge of the
+	 *            bounding rectangle enclosing the text.
+	 */
+	public void setOffsetY(int yOffset)
+	{
+		offsetY = yOffset;
+	}
 
-// Display the second string 'one line' height (240 twips) below the first. 
-// The font size and colour remain unchanged.
+	/**
+	 * Sets the height of the text.
+	 * 
+	 * @param aHeight
+	 *            the height of the text in the chosen font.
+	 */
+	public void setHeight(int aHeight)
+	{
+		height = aHeight;
+	}
 
-yOffset += fontSize;
+	/**
+	 * Adds an FSCharacter object to the array of characters.
+	 * 
+	 * @param aCharacter
+	 *            an FSCharacter object.
+	 */
+	public void add(FSCharacter aCharacter)
+	{
+		characters.add(aCharacter);
+	}
 
-FSText string2 = new FSText(0, yOffset, line2);
-&lt;/pre&gt;
+	/**
+	 * Gets the array of characters to be displayed.
+	 * 
+	 * @return the array of FSCharacter objects.
+	 */
+	public ArrayList getCharacters()
+	{
+		return characters;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the array of characters to be displayed.
+	 * 
+	 * @param anArray
+	 *            an array of FSCharacter objects.
+	 */
+	public void setCharacters(ArrayList anArray)
+	{
+		characters = anArray;
+	}
 
-&lt;p&gt;The FSText class represents both the TextRecordType0 and TextRecordType1 
-structures from the Macromedia Flash (SWF) File Format Specification. It was 
-introduced in Flash 1.&lt;/p&gt; 
- */
-public class FSText extends FSTransformObject
-{
-    /** Defines that the font character set is based on the Unicode standard. */
-    public static final int Unicode = 0;
-    /** Defines that the font character set is based on the SJIS standard for representing Kanji characters. */
-    public static final int SJIS = 2;
-    /** Defines that the font character set is based on the ANSI UTF-8 standard which supports standard ASCII encoded strings. */
-    public static final int ANSI = 1;
+	int glyphBits()
+	{
+		int numberOfBits = 0;
 
-// Flash 6
-    /// Code used to identify the spoken language for Latin fonts.
-    public static final int Latin = 1;
-    /// Code used to identify the spoken language for Japanese fonts.   
-    public static final int Japanese = 2;
-    /// Code used to identify the spoken language for Japanese fonts.   
-    public static final int Korean = 3;
-    /// Code used to identify the spoken language for simplified Chinese fonts.    
-    public static final int SimplifiedChinese = 4;
-    /// Code used to identify the spoken language for traditional Chinese fonts.  
-    public static final int TraditionalChinese = 5;
-// End Flash 6
-          
-    private int identifier = 0;
-    private FSColor color = null;
-    private int offsetX = Transform.VALUE_NOT_SET;
-    private int offsetY = Transform.VALUE_NOT_SET;
-    private int height = 0;
+		for (Iterator charIter = characters.iterator(); charIter.hasNext();)
+			numberOfBits = Math.max(numberOfBits, FSCoder.size(
+							((FSCharacter) charIter.next()).getGlyphIndex(),
+							false));
 
-    private ArrayList characters = new ArrayList();
+		return numberOfBits;
+	}
 
-    /**
-     * Construct an FSText object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSText(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**
-     * Constructs an FSText object specifying the array of characters to be displayed and their 
-     * relative placement within a block of text. The selected font, colour of the text and height 
-     * will remain unchanged from previous settings.
+	int advanceBits()
+	{
+		int numberOfBits = 0;
 
-        @param xOffset the location of the text relative to the left edge of the bounding rectangle 
-        enclosing the block of text.
-        @param yOffset the location of the text relative to the bottom edge of the bounding rectangle 
-        enclosing the block of text.
-        @param anArray an array of FSCharacter objects.
-        */
-    public FSText(int xOffset, int yOffset, ArrayList anArray)
-    {
-        setOffsetX(xOffset);
-        setOffsetY(yOffset);
-        setCharacters(anArray);
-    }
+		for (Iterator charIter = characters.iterator(); charIter.hasNext();)
+			numberOfBits = Math
+							.max(
+											numberOfBits,
+											FSCoder
+															.size(
+																			((FSCharacter) charIter
+																							.next())
+																							.getAdvance(),
+																			true));
 
-    /** Constructs an FSText object, specifying the colour and position of the following FSText.
+		return numberOfBits;
+	}
 
-        @param anIdentifier the identifier of the font that the text will be rendered in.
-        @param aColor the colour of the text.
-        @param xOffset the location of the text relative to the left edge of the bounding rectangle 
-        enclosing the text.
-        @param yOffset the location of the text relative to the bottom edge of the bounding rectangle 
-        enclosing the text.
-        @param aHeight the height of the text in the chosen font.
-        @param anArray an array of FSCharacter objects.
-        */
-    public FSText(int anIdentifier, FSColor aColor, int xOffset, int yOffset, int aHeight, ArrayList anArray)
-    {
-        setIdentifier(anIdentifier);
-        setColor(aColor);
-        setOffsetX(xOffset);
-        setOffsetY(yOffset);
-        setHeight(aHeight);
-        setCharacters(anArray);
-    }
-    /**
-     * Constructs an FSText object by copying values from an existing object.
-     *
-     * @param obj an FSText object.
-     */
-    public FSText(FSText obj)
-    {
-        identifier = obj.identifier;
-        color = new FSColor(obj.color);
-        offsetX = obj.offsetX;
-        offsetY = obj.offsetY;
-        height = obj.height;
-        
-        characters = new ArrayList(obj.characters.size());
-        
-        for (Iterator i = obj.characters.iterator(); i.hasNext();)
-            characters.add(((FSCharacter)i.next()).clone());
-    }    
+	public Object clone()
+	{
+		FSText anObject = null;
 
-    /** Gets the identifier of the font in which the text will be displayed.
+		try {
+			anObject = (FSText) super.clone();
 
-     @return the identifier of the font.
-     */
-    public int getIdentifier() { return identifier; }
+			anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-    /** Gets the colour of the font in which the text will be displayed.
+			anObject.characters = new ArrayList();
 
-        @return the colour of the text.
-        */
-    public FSColor  getColor() { return color; }
+			for (Iterator i = characters.iterator(); i.hasNext();)
+				anObject.characters.add(((FSCharacter) i.next()).clone());
+		} 
+		catch (CloneNotSupportedException e) {
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-    /** Gets the location of the start of the text relative to the left edge of the bounding rectangle in twips.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the indentation applied to the text.
-        */
-    public int getOffsetX() { return offsetX; }
+		if (super.equals(anObject))
+		{
+			FSText typedObject = (FSText) anObject;
 
-    /** Gets the location of the start of the text relative to the bottom edge of the bounding rectangle in twips.
+			result = identifier == typedObject.identifier;
 
-        @return the location of the text relative to the bottom of the bounding rectangle.
-        */
-    public int getOffsetY() { return offsetY; }
+			if (color != null)
+				result = result &amp;&amp; color.equals(typedObject.color);
+			else
+				result = result &amp;&amp; color == typedObject.color;
 
-    /** Gets the height of the text.
+			result = result &amp;&amp; offsetX == typedObject.offsetX;
+			result = result &amp;&amp; offsetY == typedObject.offsetY;
+			result = result &amp;&amp; height == typedObject.height;
 
-        @return the height of the font used to displayed the text.
-        */
-    public int getHeight() 
-    { 
-        return height; 
-    }
+			if (characters != null)
+				result = characters.equals(typedObject.characters);
+			else
+				result = characters == typedObject.characters;
+		}
+		return result;
+	}
 
-    /** Sets the identifier of the font in which the text will be displayed.
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        @param anIdentifier the identifier of the font that the text will be rendered in.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		buffer.append(&quot;FSText: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;color = &quot;).append(color.toString()).append(&quot;; &quot;);
+		buffer.append(&quot;offsetX = &quot;).append(offsetX).append(&quot;; &quot;);
+		buffer.append(&quot;offsetY = &quot;).append(offsetY).append(&quot;; &quot;);
+		buffer.append(&quot;height = &quot;).append(height).append(&quot;; &quot;);
+		buffer.append(&quot;characters = array[&quot;).append(characters.size()).append(&quot;]; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-    /** Sets the colour of the font in which the text will be displayed.
+	public int length(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsOffsetX = containsOffsetX();
+		boolean _containsOffsetY = containsOffsetY();
 
-        @param aColor the colour of the text.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+		int length = 1;
 
-    /** Sets the location of the start of the text relative to the left edge of the bounding rectangle in twips.
+		if (containsStyle())
+		{
+			length += (_containsFont) ? 2 : 0;
+			length += (_containsColor) ? color.length(coder) : 0;
+			length += (_containsOffsetY) ? 2 : 0;
+			length += (_containsOffsetX) ? 2 : 0;
+			length += (_containsFont) ? 2 : 0;
+		}
 
-        @param xOffset the location of the text relative to the left edge of the bounding rectangle enclosing the text.
-        */
-    public void setOffsetX(int xOffset)
-    {
-        offsetX = xOffset;
-    }
+		length += 1;
 
-    /** Sets the location of the start of the text relative to the bottom edge of the bounding rectangle in twips.
+		if (characters.size() &gt; 0)
+		{
+			int numberOfBits = 0;
+			int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
+			int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
 
-        @param yOffset the location of the text relative to the bottom edge of the bounding rectangle enclosing the text.
-        */
-    public void setOffsetY(int yOffset)
-    {
-        offsetY = yOffset;
-    }
+			numberOfBits = (numberOfGlyphBits + numberOfAdvanceBits)
+							* characters.size();
+			numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
 
-    /** Sets the height of the text.
+			length += numberOfBits &gt;&gt; 3;
+		}
+		return length;
+	}
 
-        @param aHeight the height of the text in the chosen font.
-        */
-    public void setHeight(int aHeight)
-    {
-        height = aHeight;
-    }
+	public void encode(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsOffsetY = containsOffsetY();
+		boolean _containsOffsetX = containsOffsetX();
 
-    /** Adds an FSCharacter object to the array of characters.
+		coder.writeBits(1, 1);
+		coder.writeBits(0, 3);
 
-        @param aCharacter an FSCharacter object.
-        */
-    public void add(FSCharacter aCharacter)
-    {
-        characters.add(aCharacter);
-    }
+		coder.writeBits(_containsFont ? 1 : 0, 1);
+		coder.writeBits(_containsColor ? 1 : 0, 1);
+		coder.writeBits(_containsOffsetY ? 1 : 0, 1);
+		coder.writeBits(_containsOffsetX ? 1 : 0, 1);
 
-    /** Gets the array of characters to be displayed.
+		if (_containsFont)
+			coder.writeWord(identifier, 2);
 
-        @return the array of FSCharacter objects.
-        */
-    public ArrayList getCharacters() { return characters; }
+		if (_containsColor)
+			color.encode(coder);
 
-    /** Sets the array of characters to be displayed.
+		if (_containsOffsetX)
+			coder.writeWord(offsetX, 2);
 
-        @param anArray an array of FSCharacter objects.
-        */
-    public void setCharacters(ArrayList anArray)
-    {
-        characters = anArray;
-    }
-    
-    int glyphBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator charIter = characters.iterator(); charIter.hasNext();) 
-            numberOfBits = Math.max(numberOfBits, FSCoder.size(((FSCharacter)charIter.next()).getGlyphIndex(), false));
-        
-        return numberOfBits;
-    }
+		if (_containsOffsetY)
+			coder.writeWord(offsetY, 2);
 
-    int advanceBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator charIter = characters.iterator(); charIter.hasNext();) 
-            numberOfBits = Math.max(numberOfBits, FSCoder.size(((FSCharacter)charIter.next()).getAdvance(), true));
-        
-        return numberOfBits;
-    }
+		if (_containsFont)
+			coder.writeWord(height, 2);
 
-    public Object clone()
-    {
-        FSText anObject = (FSText)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
+		coder.writeWord(characters.size(), 1);
 
-        anObject.characters = new ArrayList();
-        
-        for (Iterator i = characters.iterator(); i.hasNext();)
-            anObject.characters.add(((FSCharacter)i.next()).clone());
+		for (Iterator&lt;FSCharacter&gt; charIter = characters.iterator(); charIter.hasNext();)
+			charIter.next().encode(coder);
 
-        return anObject;
-    }
+		coder.alignToByte();
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSText typedObject = (FSText)anObject;
-            
-            result = identifier == typedObject.identifier;
+	public void decode(FSCoder coder)
+	{
+		/* type */coder.readBits(1, false);
+		/* reserved */coder.readBits(3, false);
 
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
+		boolean _containsFont = coder.readBits(1, false) != 0 ? true : false;
+		boolean _containsColor = coder.readBits(1, false) != 0 ? true : false;
+		boolean _containsOffsetY = coder.readBits(1, false) != 0 ? true : false;
+		boolean _containsOffsetX = coder.readBits(1, false) != 0 ? true : false;
 
-            result = result &amp;&amp; offsetX == typedObject.offsetX;
-            result = result &amp;&amp; offsetY == typedObject.offsetY;
-            result = result &amp;&amp; height == typedObject.height;
+		if (_containsFont)
+			identifier = coder.readWord(2, false);
 
-            if (characters != null)
-                result = characters.equals(typedObject.characters);
-            else
-                result = characters == typedObject.characters;
-        }
-        return result;
-    }
+		if (_containsColor)
+			color = new FSColor(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            Transform.append(buffer, &quot;offsetX&quot;, offsetX);
-            Transform.append(buffer, &quot;offsetY&quot;, offsetY);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;characters&quot;, characters, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (_containsOffsetX)
+			offsetX = coder.readWord(2, true);
 
-    public int length(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsOffsetX = containsOffsetX();
-        boolean _containsOffsetY = containsOffsetY();
-        
-        int length = 1;
-    
-        if (containsStyle())
-        {
-            length += (_containsFont) ? 2 : 0;
-            length += (_containsColor) ? color.length(coder) : 0;
-            length += (_containsOffsetY) ? 2 : 0;
-            length += (_containsOffsetX) ? 2 : 0;
-            length += (_containsFont) ? 2 : 0;
-        }
-        
-        length += 1;
+		if (_containsOffsetY)
+			offsetY = coder.readWord(2, true);
 
-        if (characters.size() &gt; 0)
-        {
-            int numberOfBits = 0;
-            int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
-            int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
-            
-            numberOfBits = (numberOfGlyphBits + numberOfAdvanceBits)*characters.size();
-            numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
+		if (_containsFont)
+			height = coder.readWord(2, false);
 
-            length += numberOfBits &gt;&gt; 3;
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsOffsetY = containsOffsetY();
-        boolean _containsOffsetX = containsOffsetX();
+		int charCount = coder.readByte();
 
-        coder.writeBits(1, 1);
-        coder.writeBits(0, 3);
+		characters = new ArrayList(charCount);
 
-        coder.writeBits(_containsFont ? 1 : 0, 1);
-        coder.writeBits(_containsColor ? 1 : 0, 1);
-        coder.writeBits(_containsOffsetY ? 1 : 0, 1);
-        coder.writeBits(_containsOffsetX ? 1 : 0, 1);
-    
-        if (_containsFont)
-            coder.writeWord(identifier, 2);
-    
-        if (_containsColor)
-            color.encode(coder);
-    
-        if (_containsOffsetX)
-            coder.writeWord(offsetX, 2);
-    
-        if (_containsOffsetY)
-            coder.writeWord(offsetY, 2);
-    
-        if (_containsFont)
-            coder.writeWord(height, 2);
+		for (int i = 0; i &lt; charCount; i++)
+			characters.add(new FSCharacter(coder));
 
-        coder.writeWord(characters.size(), 1);
-        
-        for (Iterator charIter = characters.iterator(); charIter.hasNext();) 
-            ((FSTransformObject)charIter.next()).encode(coder);
-            
-        coder.alignToByte();
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        /* type */ coder.readBits(1, false);
-        /* reserved */ coder.readBits(3, false);
-        
-        boolean _containsFont = coder.readBits(1, false) != 0 ? true : false;
-        boolean _containsColor = coder.readBits(1, false) != 0 ? true : false;
-        boolean _containsOffsetY = coder.readBits(1, false) != 0 ? true : false;
-        boolean _containsOffsetX = coder.readBits(1, false) != 0 ? true : false;
+		coder.alignToByte();
+	}
 
-        if (_containsFont)
-            identifier = coder.readWord(2, false);
+	private boolean containsFont()
+	{
+		return identifier != 0 &amp;&amp; height != 0;
+	}
 
-        if (_containsColor)
-            color = new FSColor(coder);
+	private boolean containsColor()
+	{
+		return color != null;
+	}
 
-        if (_containsOffsetX)
-            offsetX = coder.readWord(2, true);
+	private boolean containsOffsetX()
+	{
+		return offsetX != Transform.VALUE_NOT_SET;
+	}
 
-        if (_containsOffsetY)
-            offsetY = coder.readWord(2, true);
+	private boolean containsOffsetY()
+	{
+		return offsetY != Transform.VALUE_NOT_SET;
+	}
 
-        if (_containsFont)
-            height = coder.readWord(2, false);
+	boolean containsStyle()
+	{
+		return containsFont() || containsColor() || containsOffsetX()
+						|| containsOffsetY();
+	}
 
-        int charCount = coder.readWord(1, false);
-        
-        characters = new ArrayList(charCount);
-
-        for (int i=0; i&lt;charCount; i++)
-            characters.add(new FSCharacter(coder));
-        
-        coder.alignToByte();
-    }
-    
-    private boolean containsFont()
-    {
-        return identifier != 0 &amp;&amp; height != 0;
-    }
-
-    private boolean containsColor()
-    {
-        return color != null;
-    }
-
-    private boolean containsOffsetX()
-    {
-        return offsetX != Transform.VALUE_NOT_SET;
-    }
-
-    private boolean containsOffsetY()
-    {
-        return offsetY != Transform.VALUE_NOT_SET;
-    }
-
-    boolean containsStyle()
-    {
-        return containsFont() || containsColor() || containsOffsetX() || containsOffsetY();
-    }
-    
 }

Deleted: dev/dev-2-4/src/com/flagstone/transform/FSTransformObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSTransformObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSTransformObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,134 +0,0 @@
-/*
- * FSTransformObject.java
- * Transform
- * 
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform;
-
-/** 
- * The FSTransformObject object defines the basic set of method that an object must implement 
- * if it can used to represent the data structures that make up the Flash File Format
- * specification.
- * 
- * Sub-classes can be used to represent either one of the tagged data structures 
- * such as PlaceObject and added directly to an FSMovie or one of the data-types
- * that the objects contain e.g. a colour.
- *
- * In addition to the methods directly relating to the coding of the object to and from the 
- * binary data representation that comprises the Flash File Format specification the class
- * also includes a common set of methods used when validating or reporting the state of 
- * individual objects.
- */
-public abstract class FSTransformObject extends Object implements Cloneable
-{
-    /** 
-     * Return the name of the class without the package prefix. This method is used when 
-      * logging events to identify the object being encoded or decoded.
-     *
-     * @return the name of the class, e.g. FSDefineShape.
-     */
-    public String name()
-    {
-        String className = getClass().getName();
-        int index = className.lastIndexOf(&quot;.&quot;)+1;
-
-        return className.substring(index, className.length());
-    }
-   
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        return getClass().isInstance(anObject);
-    }
-
-    /** Creates a deep copy of the entire object.
-
-        @return a copy of the object.
-        */
-    public Object clone()
-    {
-        Object anObject = null;
-        
-        try 
-        {
-           anObject = super.clone();
-        }
-        catch (CloneNotSupportedException e)
-        {
-           throw new InternalError();
-         }
-        return anObject;
-       }
-
-    /**
-     * Generates a string representation of the event object.
-     * 
-     * This method calls appendDescription with the level set to 2 which will displays the 
-     * contents of the first level of nested objects (level 1 will only show the type of 
-     * any nested objects).
-     * 
-     * @return a string reporting the values in the attributes.
-     */
-    public String toString()
-    {
-           StringBuffer buffer = new StringBuffer();
-        
-           appendDescription(buffer, 2);
-        
-           return buffer.toString();
-       }
-
-   /** 
-    * AppendDescription is used to present a string description of the object including
-    * all nested objects up to a specified depth. This method provide a more controlled
-    * way of creating a string representation of an object since large objects such as 
-    * font or shape definitions can contain dozens of nested objects.
-    *
-    * The representation of the object is appended to the StringBuffer, showing the 
-    * name of the class and values of the attributes it contains. If the object contains 
-    * any attributes that are objects then the object graph will be traversed up to the
-    * specified depth. If objects are nested at a level less than specified depth then
-    * the full string representation of the object is displayed. For objects at the 
-    * specified depth only the name of the class is displayed. Any objects below this 
-    * depth are not displayed.    
-    *
-    * @param buffer a StringBuffer to which the description of each object is appended.
-    * @param depth the maximum level of nesting up to which objects will be displayed. 
-    */
-    public abstract void appendDescription(StringBuffer buffer, int depth);
-    
-    abstract public int length(FSCoder coder);
-    abstract public void encode(FSCoder coder);
-    abstract public void decode(FSCoder coder);
-}
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSVideo.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSVideo.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSVideo.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,68 +33,73 @@
 import java.util.zip.*;
 import java.io.*;
 
-/** 
- * FSVideo is a container class for the objects that represents the data 
- * structures in a Flash video file. It is very similar to the FSMovie class
- * for flash (.swf) files and provides a simple API for decoding and encoding 
- * files and accessing the objects that represent the different data structures
- * used for audio and video data.
- */ 
+/**
+ * FSVideo is a container class for the objects that represents the data
+ * structures in a Flash video file. It is very similar to the FSMovie class for
+ * flash (.swf) files and provides a simple API for decoding and encoding files
+ * and accessing the objects that represent the different data structures used
+ * for audio and video data.
+ */
 public final class FSVideo implements Cloneable
 {
-    /** 
-     * Indicates that the video data was encoded using the Sorenson
-     * modified H263 format.
-     */
-    public static final int H263 = 2;
-    /** 
-     * Indicates that the video data was encoded using Macromedia's 
-     * ScreenVideo format.
-     */
-    public static final int ScreenVideo = 3;
-    
-    /**
-     * Indicates a frame is a key frame in the video stream.
-     */
-    public static final int KeyFrame = 1;
-    
-    /**
-     * Indicates a frame is a normal frame (one displayed between key frames)
-     * in the video stream.
-     */
-    public static final int Frame = 2;
+	/**
+	 * Indicates that the video data was encoded using the Sorenson modified
+	 * H263 format.
+	 */
+	public static final int H263 = 2;
 
-    /**
-     * Indicates a frame is an optional frame - one that may be deleted to maintain
-     * real-time display of the video stream. Used only with video encoded using
-     * the Sorenson modified H263 format.
-     */
-    public static final int Optional = 3;
-    
-    
-    /*
-     * Index values for the context array in FSVideoCoder.
-     */
+	/**
+	 * Indicates that the video data was encoded using Macromedia's ScreenVideo
+	 * format.
+	 */
+	public static final int ScreenVideo = 3;
+
+	/**
+	 * Indicates a frame is a key frame in the video stream.
+	 */
+	public static final int KeyFrame = 1;
+
+	/**
+	 * Indicates a frame is a normal frame (one displayed between key frames) in
+	 * the video stream.
+	 */
+	public static final int Frame = 2;
+
+	/**
+	 * Indicates a frame is an optional frame - one that may be deleted to
+	 * maintain real-time display of the video stream. Used only with video
+	 * encoded using the Sorenson modified H263 format.
+	 */
+	public static final int Optional = 3;
+
+	/*
+	 * Index values for the context array in FSVideoCoder.
+	 */
 	static final int Action = 0;
+
 	static final int Version = 1;
+
 	static final int Type = 2;
-    static final int Delta = 3;
+
+	static final int Delta = 3;
+
 	static final int Identifier = 4;
+
 	static final int Codec = 5;
-	
-    static FSVideoObject decodeObject(FSCoder coder)
-    {
+
+	static FSVideoObject decodeObject(FSCoder coder)
+	{
 		FSVideoObject currentObject = null;
-        
-        int start = coder.getPointer();
 
-		int type = coder.readWord(1, false);
+		int start = coder.getPointer();
+
+		int type = coder.readByte();
 		int length = coder.readWord(3, false) &amp; 0x00FFFFFF;
 		int next = start + ((11 + length) &lt;&lt; 3);
-		
+
 		coder.setPointer(start);
-		
- 		switch (type)
+
+		switch (type)
 		{
 			case FSVideoObject.AudioData:
 				currentObject = new FSAudioData(coder);
@@ -108,217 +113,261 @@
 			default:
 				break;
 		}
-    
-        int delta = next - coder.getPointer();            
-        coder.context[FSVideo.Delta] = delta;
+
+		int delta = next - coder.getPointer();
+		coder.context[FSVideo.Delta] = delta;
 		coder.setPointer(next);
-        
+
 		return currentObject;
-    }
-    
+	}
+
 	private String signature = &quot;FLV&quot;;
-    private int version = 1;
-    private ArrayList objects = new ArrayList();
 
-    /** 
-     * Constructs an FSVideo object with no objects.
-     */
+	private int version = 1;
+
+	private ArrayList objects = new ArrayList();
+
+	/**
+	 * Constructs an FSVideo object with no objects.
+	 */
 	public FSVideo()
 	{
 	}
 
-    /** Constructs an FSVideo object and decodes the contents of the specified file to generate an 
-        array of objects representing the video file. If an error occurs while reading and parsing 
-        the file then an exception is thrown.
-
-        @param fileName the path to the Flash Video file that will be parsed.
-        @throws FileNotFoundException - if an error occurs while reading the file.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the file.
-        */
-	public FSVideo(String fileName) throws FileNotFoundException, IOException, DataFormatException
+	/**
+	 * Constructs an FSVideo object and decodes the contents of the specified
+	 * file to generate an array of objects representing the video file. If an
+	 * error occurs while reading and parsing the file then an exception is
+	 * thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash Video file that will be parsed.
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the file.
+	 */
+	public FSVideo(String fileName) throws FileNotFoundException, IOException,
+					DataFormatException
 	{
 		decodeFromFile(fileName);
 	}
 
-    /** 
-     * Constructs an FSVideo object and decodes the binary data presented in the byte array to generate 
-     * an array of objects representing the Flash Video data. If an error occurs while parsing the data then 
-     * an exception is thrown. 
-     *
-     * @param data an array of bytes containing the Flash Video binary data.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the data.
-     */
-    public FSVideo(byte[] data) throws IOException, DataFormatException
+	/**
+	 * Constructs an FSVideo object and decodes the binary data presented in the
+	 * byte array to generate an array of objects representing the Flash Video
+	 * data. If an error occurs while parsing the data then an exception is
+	 * thrown.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the Flash Video binary data.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the data.
+	 */
+	public FSVideo(byte[] data) throws IOException, DataFormatException
 	{
-        decodeFromData(data);
+		decodeFromData(data);
 	}
-    
-    /** Gets the number representing the version of Flash Video that the video represents.
 
-        @return an integer defining the Flash Video version number for the coder.
-        */
-    public int getVersion()
-    {
-        return version;
-    }
+	/**
+	 * Gets the number representing the version of Flash Video that the video
+	 * represents.
+	 * 
+	 * @return an integer defining the Flash Video version number for the coder.
+	 */
+	public int getVersion()
+	{
+		return version;
+	}
 
-	/** Sets the Flash Video version.
-
-		@param aNumber the version of the Flash Video file format that this object utilises.
-		*/
+	/**
+	 * Sets the Flash Video version.
+	 * 
+	 * @param aNumber
+	 *            the version of the Flash Video file format that this object
+	 *            utilises.
+	 */
 	public void setVersion(int aNumber)
 	{
 		version = aNumber;
 	}
 
-    /** Gets the array of video objects.
+	/**
+	 * Gets the array of video objects.
+	 * 
+	 * @return the array of objects.
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-        @return the array of objects.
-        */
-    public ArrayList getObjects() { return objects; }
+	/**
+	 * Sets the array of objects contained in the Movie.
+	 * 
+	 * @param anArray
+	 *            the array of objects that describe a coder.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-    /** Sets the array of objects contained in the Movie.
+	/**
+	 * Adds the object to the Movie.
+	 * 
+	 * @param anObject
+	 *            the object to be added to the coder.
+	 */
+	public void add(FSVideoObject anObject)
+	{
+		objects.add(anObject);
+	}
 
-        @param anArray the array of objects that describe a coder.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+	/**
+	 * Adds the array of object to the Video.
+	 * 
+	 * @param array
+	 *            an array of FSVideoObjects that will be added to the video in
+	 *            the order they are in the array.
+	 */
+	public void add(ArrayList array)
+	{
+		objects.addAll(array);
+	}
 
-    /** Adds the object to the Movie.
+	/**
+	 * Decodes the contents of the specified file. An object for each tag
+	 * decoded from the file is placed in the object array in the order they
+	 * were read from the file. If an error occurs while reading and parsing the
+	 * file then an exception is thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash Video file that will be parsed.
+	 * 
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the file.
+	 */
+	public void decodeFromFile(String fileName) throws FileNotFoundException,
+					DataFormatException, IOException
+	{
+		FileInputStream fileContents = null;
+		File swfFile = new File(fileName);
 
-        @param anObject the object to be added to the coder.
-        */
-    public void add(FSVideoObject anObject)
-    {
-        objects.add(anObject);
-    }
+		fileContents = new FileInputStream(swfFile);
 
-    /** Adds the array of object to the Video.
+		int fileLength = (int) swfFile.length();
+		byte[] contents = new byte[fileLength];
 
-        @param array an array of FSVideoObjects that will be added to the video in the order they are 
-        in the array.
-        */
-    public void add(ArrayList array)
-    {
-        objects.addAll(array);
-    }
+		fileContents.read(contents);
+		fileContents.close();
 
-    /** 
-     * Decodes the contents of the specified file. An object for each tag decoded 
-     * from the file is placed in the object array in the order they were read
-     * from the file. If an error occurs while reading and parsing the file then 
-     * an exception is thrown.
-     *
-     * @param fileName the path to the Flash Video file that will be parsed.
-     * 
-     * @throws FileNotFoundException - if an error occurs while reading the file.
-     * @throws DataFormatException - if the file does not contain Flash data.
-     * @throws IOException - if an error occurs while reading and decoding the file.
-     */
-	public void decodeFromFile(String fileName) throws FileNotFoundException, DataFormatException, IOException
-	{
-        FileInputStream fileContents = null;
-        File swfFile = new File(fileName);
-        
-        fileContents = new FileInputStream(swfFile);
-        
-        int fileLength = (int)swfFile.length();
-        byte[] contents = new byte[fileLength];
-        
-        fileContents.read(contents);
-        fileContents.close();
-        
-        decodeFromData(contents);
-    }
+		decodeFromData(contents);
+	}
 
-   /** 
-    * Decodes the binary Flash Video data stored in the byte array. If an error 
-    * occurs while the data is being decoded an exception is thrown.
-    *
-    * @param bytes an array of bytes that contain the encoded Flash Video objects.
-    *
-    * @throws DataFormatException - if the file does not contain Flash data.
-    * @throws IOException - if an error occurs while reading and decoding the file.
-    */
-	public void decodeFromData(byte[] bytes) throws DataFormatException, IOException
+	/**
+	 * Decodes the binary Flash Video data stored in the byte array. If an error
+	 * occurs while the data is being decoded an exception is thrown.
+	 * 
+	 * @param bytes
+	 *            an array of bytes that contain the encoded Flash Video
+	 *            objects.
+	 * 
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the file.
+	 */
+	public void decodeFromData(byte[] bytes) throws DataFormatException,
+					IOException
 	{
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
-        FSVideoObject object = null;
-        
-        boolean containsAudio = false;
-        boolean containsVideo = false;
-        
-        isFlashVideo(bytes);
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
+		FSVideoObject object = null;
 
-        signature = coder.readString(3, &quot;UTF8&quot;);
-        version = coder.readWord(1, false);
-        coder.readBits(5, false);
-        containsAudio = coder.readBits(1, false) != 0;
-        coder.readBits(1, false);
-        containsVideo = coder.readBits(1, false) != 0;
+		boolean containsAudio = false;
+		boolean containsVideo = false;
 
-        int offset = coder.readWord(4, false);
-        offset = coder.readWord(4, false);
-        
-        do {
-            objects.add(decodeObject(coder));
-            
-            if (coder.context[Delta] != 0)
-                throw new IOException();
-            
-            offset = coder.readWord(4, false);    
+		isFlashVideo(bytes);
 
-        } while (!coder.eof());
+		signature = coder.readString(3, &quot;UTF8&quot;);
+		version = coder.readByte();
+		coder.readBits(5, false);
+		containsAudio = coder.readBits(1, false) != 0;
+		coder.readBits(1, false);
+		containsVideo = coder.readBits(1, false) != 0;
+
+		int offset = coder.readWord(4, false);
+		offset = coder.readWord(4, false);
+
+		do
+		{
+			objects.add(decodeObject(coder));
+
+			if (coder.context[Delta] != 0)
+				throw new IOException();
+
+			offset = coder.readWord(4, false);
+
+		} while (!coder.eof());
 	}
-    
-    /** 
-     * Encodes the array of objects and writes the data to the specified file. 
-     * If an error occurs while encoding the file then an exception is thrown.
-     *
-     * @param fileName the path to the file that the video will be encoded to.
-     *
-     * @throws FileNotFoundException - if an error occurs while reading the file.
-     * @throws IOException - if an error occurs while encoding and writing the file.
-     */
-	public void encodeToFile(String fileName) throws FileNotFoundException, IOException
+
+	/**
+	 * Encodes the array of objects and writes the data to the specified file.
+	 * If an error occurs while encoding the file then an exception is thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the file that the video will be encoded to.
+	 * 
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws IOException -
+	 *             if an error occurs while encoding and writing the file.
+	 */
+	public void encodeToFile(String fileName) throws FileNotFoundException,
+					IOException
 	{
 		FileOutputStream fileContents = new FileOutputStream(fileName);
-    
-        byte[] encodedData = encode();
 
-        fileContents.write(encodedData);
-        fileContents.close();
-    }
+		byte[] encodedData = encode();
 
-    /** 
-     * Returns the encoded representation of the array of objects that this Video
-     * contains. If an error occurs while encoding the file then an exception is 
-     * thrown.
-     *
-     * @return the array of bytes representing the encoded objects.
-     * @throws IOException if an error occurs while the data is being decoded.
-     */
-    public byte[] encode() throws IOException
-    {
+		fileContents.write(encodedData);
+		fileContents.close();
+	}
+
+	/**
+	 * Returns the encoded representation of the array of objects that this
+	 * Video contains. If an error occurs while encoding the file then an
+	 * exception is thrown.
+	 * 
+	 * @return the array of bytes representing the encoded objects.
+	 * @throws IOException
+	 *             if an error occurs while the data is being decoded.
+	 */
+	public byte[] encode() throws IOException
+	{
 		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, 0);
-        
-        coder.context[FSVideo.Version] = version;
 
-        int fileLength = length(coder);
+		coder.context[FSVideo.Version] = version;
 
- 		coder.setData(FSCoder.BIG_ENDIAN, new byte[fileLength]);         
-        
-        boolean containsAudio = false;
-        boolean containsVideo = false;
-        
-        for (Iterator i=objects.iterator(); i.hasNext(); )
+		int fileLength = length(coder);
+
+		coder.setData(FSCoder.BIG_ENDIAN, new byte[fileLength]);
+
+		boolean containsAudio = false;
+		boolean containsVideo = false;
+
+		for (Iterator i = objects.iterator(); i.hasNext();)
 		{
-			int type = ((FSVideoObject)(i.next())).getType();
-			
+			int type = ((FSVideoObject) (i.next())).getType();
+
 			if (type == FSVideoObject.AudioData)
 				containsAudio = true;
 			else if (type == FSVideoObject.VideoData)
@@ -326,124 +375,123 @@
 		}
 
 		coder.writeString(signature, &quot;UTF8&quot;);
-        coder.writeWord(version, 1);
-        coder.writeBits(0, 5);
-        coder.writeBits(containsAudio ? 1 : 0, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(containsVideo ? 1 : 0, 1);
-        coder.writeWord(9, 4);
-        coder.writeWord(0, 4);
-        
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-			FSVideoObject object = (FSVideoObject)i.next();
+		coder.writeWord(version, 1);
+		coder.writeBits(0, 5);
+		coder.writeBits(containsAudio ? 1 : 0, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(containsVideo ? 1 : 0, 1);
+		coder.writeWord(9, 4);
+		coder.writeWord(0, 4);
 
-            int length = object.getLength();
-            int start = coder.getPointer();
-            int next = start + (length &lt;&lt; 3);
-            
-            object.encode(coder);
-            coder.setPointer(next);
-            
-            if (((next - coder.getPointer()) &gt;&gt; 3) != 0)
-                throw new IOException();
-            
-            coder.writeWord(length+11, 4);
-        }
+		for (Iterator&lt;FSVideoObject&gt; i = objects.iterator(); i.hasNext();) {
+			FSVideoObject.encode(coder, i.next());
+		}
 		return coder.getData();
-    }
-    
-    /** 
-     * Creates a deep copy of the entire video.
-     * 
-     * @return a copy of the object.
-     */
+	}
+
+	/**
+	 * Creates a deep copy of the entire video.
+	 * 
+	 * @return a copy of the object.
+	 */
 	public Object clone()
 	{
-        FSVideo anObject = null;
-        
-        try {
-            anObject = (FSVideo)super.clone();
+		FSVideo anObject = null;
 
+		try
+		{
+			anObject = (FSVideo) super.clone();
+
 			anObject.objects = new ArrayList();
-			
+
 			for (Iterator i = objects.iterator(); i.hasNext();)
-				anObject.objects.add(((FSVideoObject)i.next()).clone());
-        }
-        catch (CloneNotSupportedException e)
-        {
-            throw new InternalError();
-        }
-        
+				anObject.objects.add(((FSVideoObject) i.next()).clone());
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
+
 		return anObject;
 	}
 
-    /** 
-     * Returns true if anObject is equal to this one. The comparison is performed 
-     * on all the objects contained in the video. Objects are considered equal 
-     * if they would generate identical binary data when they are encoded to a 
-     * Flash Video file.
-     *
+	/**
+	 * Returns true if anObject is equal to this one. The comparison is
+	 * performed on all the objects contained in the video. Objects are
+	 * considered equal if they would generate identical binary data when they
+	 * are encoded to a Flash Video file.
+	 * 
 	 * @return true if this object would be identical to anObject when encoded.
-     */
+	 */
 	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSVideo typedObject = (FSVideo)anObject;
+		{
+			FSVideo typedObject = (FSVideo) anObject;
 
-            result = version == typedObject.version;
-            result = result &amp;&amp; objects.equals(((FSVideo)anObject).getObjects());            
-        }
+			result = version == typedObject.version;
+			result = result
+							&amp;&amp; objects
+											.equals(((FSVideo) anObject)
+															.getObjects());
+		}
 		return result;
 	}
 
-    /** 
-     * AppendDescription is used to present a string description of the object 
-     * including all nested objects up to a specified depth. 
-     *
-     * The representation of the object is appended to the StringBuffer, showing 
-     * the name of the class and values of the attributes it contains. If the 
-     * object contains any attributes that are objects then the object graph will 
-     * be traversed up to the specified depth. If objects are nested at a level 
-     * less than specified depth then the full string representation of the 
-     * object is displayed. For objects at the specified depth only the name of 
-     * the class is displayed. Any objects below this depth are not displayed.	
-     *
-     * @param buffer a StringBuffer to which the description of each object is appended.
-     * @param depth the maximum level of nesting up to which objects will be displayed. 
-     */
-	public void appendDescription(StringBuffer buffer, int depth)
+	/**
+	 * AppendDescription is used to present a string description of the object
+	 * including all nested objects up to a specified depth.
+	 * 
+	 * The representation of the object is appended to the StringBuffer, showing
+	 * the name of the class and values of the attributes it contains. If the
+	 * object contains any attributes that are objects then the object graph
+	 * will be traversed up to the specified depth. If objects are nested at a
+	 * level less than specified depth then the full string representation of
+	 * the object is displayed. For objects at the specified depth only the name
+	 * of the class is displayed. Any objects below this depth are not
+	 * displayed.
+	 * 
+	 * @param buffer
+	 *            a StringBuffer to which the description of each object is
+	 *            appended.
+	 * @param depth
+	 *            the maximum level of nesting up to which objects will be
+	 *            displayed.
+	 */
+	public String toString()
 	{
-		buffer.append(&quot;FSVideo&quot;);
-		buffer.append(&quot; : { &quot;);
-		Transform.append(buffer, &quot;signature&quot;, signature);
-		Transform.append(buffer, &quot;version&quot;, version);
-		Transform.append(buffer, &quot;objects&quot;, objects, depth);
+		StringBuffer buffer = new StringBuffer();
+		
+		buffer.append(&quot;FSVideo: { &quot;);
+		buffer.append(&quot;signature = &quot;).append(signature).append(&quot;; &quot;);
+		buffer.append(&quot;version = &quot;).append(version).append(&quot;; &quot;);
+		buffer.append(&quot;objects = array[&quot;).append(objects.size()).append(&quot;]; &quot;);
 		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
 	}
 
 	private int length(FSCoder coder)
 	{
-        int length = 13;
+		int length = 13;
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
+		for (Iterator i = objects.iterator(); i.hasNext();)
 		{
-            length += 4 + ((FSVideoObject)(i.next())).length(coder);
+			length += 4 + ((FSVideoObject) (i.next())).length(coder);
 		}
-        return length;
+		return length;
 	}
 
-    private void isFlashVideo(byte[] bytes) throws DataFormatException
-    {
+	private void isFlashVideo(byte[] bytes) throws DataFormatException
+	{
 		if (bytes == null || bytes.length &lt; 8)
 			throw new DataFormatException();
-            
-        boolean isFlashVideo = bytes[0] == 0x46 &amp;&amp; bytes[1] == 0x4C &amp;&amp; bytes[2] == 0x56;
-        
-        if (isFlashVideo == false)
-            throw new DataFormatException();
-    }
+
+		boolean isFlashVideo = bytes[0] == 0x46 &amp;&amp; bytes[1] == 0x4C
+						&amp;&amp; bytes[2] == 0x56;
+
+		if (isFlashVideo == false)
+			throw new DataFormatException();
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSVideoData.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSVideoData.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSVideoData.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -29,7 +29,7 @@
  */
 package com.flagstone.transform;
 
-/**  
+/**
  * The FSVideoData class is used to store the data for a single video frame.
  * 
  * &lt;table class=&quot;datasheet&quot;&gt;
@@ -40,21 +40,22 @@
  * 
  * &lt;tr&gt;
  * &lt;td&gt;timestamp&lt;/td&gt;
- * &lt;td&gt;The time in milliseconds at which the sound will be played. The timestamp 
- * is used exclusively for determining when sound or video will be played. Any 
- * internal timing information in the audio or video data is ignored.&lt;/td&gt;
+ * &lt;td&gt;The time in milliseconds at which the sound will be played. The
+ * timestamp is used exclusively for determining when sound or video will be
+ * played. Any internal timing information in the audio or video data is
+ * ignored.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;codec&lt;/td&gt;
- * &lt;td&gt;Identifies the format of the video data. FSVideo.H263 represents data 
+ * &lt;td&gt;Identifies the format of the video data. FSVideo.H263 represents data
  * encoded using the Sorenson modified H263 format.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;frameType&lt;/td&gt;
- * &lt;td&gt;The type of frame being displayed, either FSVideo.KeyFrame, FSVideo.Frame 
- * or FSVideo.Optional.&lt;/td&gt;
+ * &lt;td&gt;The type of frame being displayed, either FSVideo.KeyFrame,
+ * FSVideo.Frame or FSVideo.Optional.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
@@ -66,38 +67,45 @@
  * 
  * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
  * 
- * The FSVideoData class represents the FLV Tag with the Video Data section from 
- * Macromedia's Flash (SWF) File Format Specification. It was added in Flash 
- * Video 1 with support for the Sorenson modified H263 format. Support for 
- * Macromedia's ScreenVideo format was added when Flash 7 was released.&lt;/p&gt;
- */  
+ * The FSVideoData class represents the FLV Tag with the Video Data section from
+ * Macromedia's Flash (SWF) File Format Specification. It was added in Flash
+ * Video 1 with support for the Sorenson modified H263 format. Support for
+ * Macromedia's ScreenVideo format was added when Flash 7 was released.
+ * &lt;/p&gt;
+ */
 public final class FSVideoData extends FSVideoObject
 {
 	private int codec = 0;
+
 	private int frameType = 0;
-    private byte[] data = null;
 
+	private byte[] data = null;
+
 	FSVideoData(FSCoder coder)
 	{
-        super(FSVideoObject.VideoData, 0);
+		super(FSVideoObject.VideoData, 0);
 		decode(coder);
 	}
 
-    /**
-     * Constructs a new FSVideoData object specifying the time which the video 
-     * should be displayed, the video data and the format used to encode it and 
-     * the type of frame that the video represents - either a key frame, regular 
-     * frame or an optional frame which can be discarded (H263 format only). 
-     *
-	 * @param timestamp the time in milliseconds at which the data should be played.
-     * @param format the format used to encode the video either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     * @param type the type of frame being displayed, either FSVideo.KeyFrame, 
-     * FSVideo.Frame or FSVideo.Optional.
-     * @param data an array of bytes containing the video encoded using the 
-     * format indicated in the codec attribute, either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
+	/**
+	 * Constructs a new FSVideoData object specifying the time which the video
+	 * should be displayed, the video data and the format used to encode it and
+	 * the type of frame that the video represents - either a key frame, regular
+	 * frame or an optional frame which can be discarded (H263 format only).
+	 * 
+	 * @param timestamp
+	 *            the time in milliseconds at which the data should be played.
+	 * @param format
+	 *            the format used to encode the video either FSVideo.H263 or
+	 *            FSVideo.ScreenVideo.
+	 * @param type
+	 *            the type of frame being displayed, either FSVideo.KeyFrame,
+	 *            FSVideo.Frame or FSVideo.Optional.
+	 * @param data
+	 *            an array of bytes containing the video encoded using the
+	 *            format indicated in the codec attribute, either FSVideo.H263
+	 *            or FSVideo.ScreenVideo.
+	 */
 	public FSVideoData(int timestamp, int format, int type, byte[] data)
 	{
 		super(FSVideoObject.VideoData, timestamp);
@@ -106,154 +114,155 @@
 		setData(data);
 	}
 
-    /**
-     * Gets the scheme used to encode the video data, either FSVideo.H263 for 
-     * data that was encoded using the modified Sorenson H263 format or 
-     * FSVideo.ScreenVideo for video that was encoded using Macromedia's 
-     * ScreenVideo format.
-     *
-     * @return the format used to encode the video either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
-    public int getCodec()
-    {
-        return codec;
-    }
+	/**
+	 * Gets the scheme used to encode the video data, either FSVideo.H263 for
+	 * data that was encoded using the modified Sorenson H263 format or
+	 * FSVideo.ScreenVideo for video that was encoded using Macromedia's
+	 * ScreenVideo format.
+	 * 
+	 * @return the format used to encode the video either FSVideo.H263 or
+	 *         FSVideo.ScreenVideo.
+	 */
+	public int getCodec()
+	{
+		return codec;
+	}
 
-    /**
-     * Sets the format used to encode the video data, either FSVideo.H263 for 
-     * data that was encoded using the modified Sorenson H263 format or
-     * FSVideo.ScreenVideo for video that was encoded using Macromedia's 
-     * ScreenVideo format.
-     *
-     * @param format the format used to encode the video either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
-    public void setCodec(int format)
+	/**
+	 * Sets the format used to encode the video data, either FSVideo.H263 for
+	 * data that was encoded using the modified Sorenson H263 format or
+	 * FSVideo.ScreenVideo for video that was encoded using Macromedia's
+	 * ScreenVideo format.
+	 * 
+	 * @param format
+	 *            the format used to encode the video either FSVideo.H263 or
+	 *            FSVideo.ScreenVideo.
+	 */
+	public void setCodec(int format)
 	{
 		codec = format;
 	}
-    
-    /**
-     * Gets the type of frame that will be displayed, either FSVideo.KeyFrame, 
-     * FSVideo.Frame or FSVideo.Optional. The latter is used only to indicate 
-     * disposable frame and is only used with the Sorenson modified H263 format.
-     *
-     * @return the type of frame, either FSVideo.KeyFrame, FSVideo.Frame or 
-     * FSVideo.Optional.
-     */
-    public int getFrameType() 
-    {
-        return frameType;
-    }
 
-    /**
-     * Sets the type of frame type indicating whether it is a key frame 
-     * (FSVideo.KeyFrame), a normal frame (FSVideo.Frame) displayed between key 
-     * frames other whether display of the frame is optional ( FSVideo.Optional). 
-     * The latter is used only with video encoded using the Sorenson modified 
-     * H263 format.
-     *
-     * @param type the type of frame being displayed, either FSVideo.KeyFrame, 
-     * FSVideo.Frame or FSVideo.Optional.
-     */
-    public void setFrameType(int type)
+	/**
+	 * Gets the type of frame that will be displayed, either FSVideo.KeyFrame,
+	 * FSVideo.Frame or FSVideo.Optional. The latter is used only to indicate
+	 * disposable frame and is only used with the Sorenson modified H263 format.
+	 * 
+	 * @return the type of frame, either FSVideo.KeyFrame, FSVideo.Frame or
+	 *         FSVideo.Optional.
+	 */
+	public int getFrameType()
 	{
+		return frameType;
+	}
+
+	/**
+	 * Sets the type of frame type indicating whether it is a key frame
+	 * (FSVideo.KeyFrame), a normal frame (FSVideo.Frame) displayed between key
+	 * frames other whether display of the frame is optional (
+	 * FSVideo.Optional). The latter is used only with video encoded using the
+	 * Sorenson modified H263 format.
+	 * 
+	 * @param type
+	 *            the type of frame being displayed, either FSVideo.KeyFrame,
+	 *            FSVideo.Frame or FSVideo.Optional.
+	 */
+	public void setFrameType(int type)
+	{
 		frameType = type;
 	}
-    
-    /**
-     * Get the encoded video data.
-     *
-     * @return an array of bytes encoded using the format indicated in the codec 
-     * attribute, either FSVideo.H263 or FSVideo.ScreenVideo.
-     */
-    public byte[] getData() 
-    {
-        return data;
-    }
 
-    /**
-     * Sets the encoded video data for the frame.
-     *
-     * @param data an array of bytes containing the video encoded using the 
-     * format indicated in the codec attribute, either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
-    public void setData(byte[] data)
+	/**
+	 * Get the encoded video data.
+	 * 
+	 * @return an array of bytes encoded using the format indicated in the codec
+	 *         attribute, either FSVideo.H263 or FSVideo.ScreenVideo.
+	 */
+	public byte[] getData()
 	{
+		return data;
+	}
+
+	/**
+	 * Sets the encoded video data for the frame.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the video encoded using the
+	 *            format indicated in the codec attribute, either FSVideo.H263
+	 *            or FSVideo.ScreenVideo.
+	 */
+	public void setData(byte[] data)
+	{
 		this.data = data;
 	}
-    
-    public Object clone()
+
+	public Object clone()
 	{
-        FSVideoData anObject = (FSVideoData)super.clone();
-        
-        anObject.data = Transform.clone(data);
-        
+		FSVideoData anObject = (FSVideoData) super.clone();
+
+		anObject.data = Transform.clone(data);
+
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSVideoData typedObject = (FSVideoData)anObject;
-            
-            result = codec == typedObject.codec;
-            result = result &amp;&amp; frameType == typedObject.frameType;
+		{
+			FSVideoData typedObject = (FSVideoData) anObject;
 
-            if (data != null)
-                result = result &amp;&amp; Transform.equals(data, typedObject.data);
-            else
-                result = result &amp;&amp; typedObject.data == null;
-        }
+			result = codec == typedObject.codec;
+			result = result &amp;&amp; frameType == typedObject.frameType;
+
+			if (data != null)
+				result = result &amp;&amp; Transform.equals(data, typedObject.data);
+			else
+				result = result &amp;&amp; typedObject.data == null;
+		}
 		return result;
 	}
 
-	public void appendDescription(StringBuffer buffer, int depth)
+	public String toString()
 	{
-		buffer.append(name());
+		StringBuffer buffer = new StringBuffer();
 
-		if (depth &gt; 0)
-		{
-			buffer.append(&quot;: { &quot;);
-			Transform.append(buffer, &quot;codec&quot;, codec);
-			Transform.append(buffer, &quot;frameType&quot;, frameType);
-            Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
-
-			buffer.append(&quot;}&quot;);
-		}
+		buffer.append(&quot;FSVideoData: { &quot;);
+		buffer.append(&quot;codec = &quot;).append(codec).append(&quot;; &quot;);
+		buffer.append(&quot;frameType = &quot;).append(frameType).append(&quot;; &quot;);
+		buffer.append(&quot;data = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
 	}
 
-	int length(FSCoder coder)
+	public int length(FSCoder coder)
 	{
 		super.length(coder);
-	
+
 		length += 1 + data.length;
-	
+
 		return length;
 	}
-	
-	void encode(FSCoder coder)
+
+	public void encode(FSCoder coder)
 	{
-        super.encode(coder);
-		
+		super.encode(coder);
+
 		coder.writeBits(codec, 4);
 		coder.writeBits(frameType, 4);
-        coder.writeBytes(data);
+		coder.writeBytes(data);
 	}
-	
-	void decode(FSCoder coder)
+
+	public void decode(FSCoder coder)
 	{
 		super.decode(coder);
-        
-        data = new byte[length-1];
-        
+
+		data = new byte[length - 1];
+
 		codec = coder.readBits(4, false);
 		frameType = coder.readBits(4, false);
-        coder.readBytes(data);
+		coder.readBytes(data);
 	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSVideoFrame.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSVideoFrame.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSVideoFrame.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,221 +31,246 @@
 package com.flagstone.transform;
 
 /**
-FSVideoFrame contains the video data displayed in a single frame of a Flash movie.
- 
- &lt;table class=&quot;datasheet&quot;&gt;
+ * FSVideoFrame contains the video data displayed in a single frame of a Flash
+ * movie.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the FSDefineVideo object that defines the size of the
+ * images displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameNumber&lt;/td&gt;
+ * &lt;td&gt;The number of the frame that the data is for.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;data&lt;/td&gt;
+ * &lt;td&gt;The encoded video data. Encoded using either the modified Sorenson H263
+ * or Macromedia's Screen Video formats.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Each frame of video is displayed whenever display list is updated using the
+ * FSShowFrame object - any timing information stored within the video data is
+ * ignored. Since the video is updated at the same time as the display list the
+ * frame rate of the video may be the same or less than the frame rate of the
+ * Flash movie but not higher.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSVideoFrame class represents the VideoFrame data structure in the
+ * Macromedia Flash (SWF) File Format Specification. It was added in Flash 6
+ * with support for the Sorenson modified H263 format. Support for Macromedia's
+ * Screen Video format was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSVideoFrame extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private int frameNumber = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	private byte[] data = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the FSDefineVideo object that defines the size of the images displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSVideoFrame object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSVideoFrame(FSCoder coder)
+	{
+		super(VideoFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_1&quot;&gt;frameNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the frame that the data is for.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs a new FSVideoFrame object which will display the specified
+	 * frame of video data in the FSDefineVideo object that matches the
+	 * identifier.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineVideo object.
+	 * @param frameNumber
+	 *            the number of the frame.
+	 * @param data
+	 *            the encoded video data. For Flash 6 this is encoded in the
+	 *            H263 format. In Flash 7 H263 and ScreenVideo is supported.
+	 */
+	public FSVideoFrame(int anIdentifier, int frameNumber, byte[] data)
+	{
+		super(VideoFrame);
+		setIdentifier(anIdentifier);
+		setFrameNumber(frameNumber);
+		setData(data);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_1&quot;&gt;data&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded video data. Encoded using either the modified Sorenson H263 or Macromedia's Screen Video formats.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSVideoFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSVideoFrame object.
+	 */
+	public FSVideoFrame(FSVideoFrame obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		frameNumber = obj.frameNumber;
 
-&lt;/table&gt;
+		data = Transform.clone(obj.data);
+	}
 
-&lt;p&gt;Each frame of video is displayed whenever display list is updated using the FSShowFrame object - any timing information stored within the video data is ignored. Since the video is updated at the same time as the display list the frame rate of the video may be the same or less than the frame rate of the Flash movie but not higher.&lt;/p&gt;
+	/**
+	 * Get the identifier of the FSDefineVideo object where the frame will be
+	 * displayed.
+	 * 
+	 * @return the unique identifier of the FSDefineVideo object.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the identifier of the FSDefineVideo object where the frame will be
+	 * displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineVideo object.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;p&gt;The FSVideoFrame class represents the VideoFrame data structure in the Macromedia Flash (SWF) File Format Specification. It was added in Flash 6 with support for the Sorenson modified H263 format. Support for Macromedia's Screen Video format was added in Flash 7.&lt;/p&gt;
- */  
-public class FSVideoFrame extends FSMovieObject
-{
-    private int identifier = 0;
-    private int frameNumber = 0;
-    
-    private byte[] data = null;
+	/**
+	 * Gets the number of the frame.
+	 * 
+	 * @return the frame number.
+	 */
+	public int getFrameNumber()
+	{
+		return frameNumber;
+	}
 
-    /**
-     * Construct an FSVideoFrame object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSVideoFrame(FSCoder coder)
-    {
-        super(VideoFrame);
-        decode(coder);
-    }
-    /**
-     * Constructs a new FSVideoFrame object which will display the specified frame of video data
-     * in the FSDefineVideo object that matches the identifier. 
-     *
-     * @param anIdentifier the unique identifier of the FSDefineVideo object.
-     * @param frameNumber the number of the frame.
-     * @param data the encoded video data. For Flash 6 this is encoded in the H263 format. In Flash 7
-     * H263 and ScreenVideo is supported.
-     */
-    public FSVideoFrame(int anIdentifier, int frameNumber, byte[] data)
-    {
-        super(VideoFrame);
-        setIdentifier(anIdentifier);
-        setFrameNumber(frameNumber);
-        setData(data);
-    }
-    /**
-     * Constructs an FSVideoFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSVideoFrame object.
-     */
-    public FSVideoFrame(FSVideoFrame obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        frameNumber = obj.frameNumber;
-        
-        data = Transform.clone(obj.data);
-    }    
+	/**
+	 * Sets the number of the frame.
+	 * 
+	 * @param number
+	 *            the frame number.
+	 */
+	public void setFrameNumber(int number)
+	{
+		frameNumber = number;
+	}
 
-    /**
-     * Get the identifier of the FSDefineVideo object where the frame will be displayed.
-     *
-     * @return the unique identifier of the FSDefineVideo object.
-     */
-    public int getIdentifier()
-    {
-        return identifier;
-    }
+	/**
+	 * Gets the encoded video data. In Flash 6 modified H263 encoded video is
+	 * supported. Flash 7 supports both modified H263 and ScreenVideo.
+	 * 
+	 * @return the encoded video data.
+	 */
+	public byte[] getData()
+	{
+		return data;
+	}
 
-    /**
-     * Sets the identifier of the FSDefineVideo object where the frame will be displayed.
-     *
-     * @param anIdentifier the unique identifier of the FSDefineVideo object.
-     */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-    
-    /**
-     * Gets the number of the frame.
-     *
-     * @return the frame number.
-     */
-    public int getFrameNumber() 
-    {
-        return frameNumber;
-    }
+	/**
+	 * Sets the encoded video data. In Flash 6 modified H263 encoded video is
+	 * supported. Flash 7 supports both modified H263 and ScreenVideo,
+	 * 
+	 * @param data
+	 *            the encoded video data.
+	 */
+	public void setData(byte[] data)
+	{
+		this.data = data;
+	}
 
-    /**
-     * Sets the number of the frame.
-     *
-     * @param number the frame number.
-     */
-    public void setFrameNumber(int number)
-    {
-        frameNumber = number;
-    }
-    
-    /**
-     * Gets the encoded video data. In Flash 6 modified H263 encoded video is supported. Flash 7 supports 
-     * both modified H263 and ScreenVideo.
-     *
-     * @return the encoded video data.
-     */
-    public byte[] getData() 
-    {
-        return data;
-    }
+	public Object clone()
+	{
+		FSVideoFrame anObject = (FSVideoFrame) super.clone();
 
-    /**
-     * Sets the encoded video data. In Flash 6 modified H263 encoded video is supported. Flash 7 supports 
-     * both modified H263 and ScreenVideo,
-     *
-     * @param data the encoded video data.
-     */
-    public void setData(byte[] data)
-    {
-        this.data = data;
-    }
-    
-    public Object clone()
-    {
-        FSVideoFrame anObject = (FSVideoFrame)super.clone();
-        
-        return anObject;
-    }
+		return anObject;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSVideoFrame typedObject = (FSVideoFrame)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; frameNumber == typedObject.frameNumber;
-            
-            if (data != null)
-                result = result &amp;&amp; Transform.equals(data, typedObject.data);
-            else
-                result = result &amp;&amp; typedObject.data == null;
-        }
-        return result;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		if (super.equals(anObject))
+		{
+			FSVideoFrame typedObject = (FSVideoFrame) anObject;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
-            Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; frameNumber == typedObject.frameNumber;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 4 + data.length;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        coder.writeWord(frameNumber, 2);
-        coder.writeBytes(data);
+			if (data != null)
+				result = result &amp;&amp; Transform.equals(data, typedObject.data);
+			else
+				result = result &amp;&amp; typedObject.data == null;
+		}
+		return result;
+	}
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        data = new byte[length-4];
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-        identifier = coder.readWord(2, false);
-        frameNumber = coder.readWord(2, false);
-        coder.readBytes(data);
-        
-        coder.endObject(name());
-    }
+		buffer.append(&quot;FSVideoFrame: { &quot;);
+		buffer.append(&quot;identifier = &quot;).append(identifier).append(&quot;; &quot;);
+		buffer.append(&quot;frameNumber = &quot;).append(frameNumber).append(&quot;; &quot;);
+		buffer.append(&quot;data = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 4 + data.length;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(identifier, 2);
+		coder.writeWord(frameNumber, 2);
+		coder.writeBytes(data);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		data = new byte[length - 4];
+
+		identifier = coder.readWord(2, false);
+		frameNumber = coder.readWord(2, false);
+		coder.readBytes(data);
+	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSVideoMetaData.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSVideoMetaData.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSVideoMetaData.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -29,100 +29,100 @@
  */
 package com.flagstone.transform;
 
-/** 
+/**
  * The FSVideoMetaData class is used to store infromation on how the video
  * stream should be displayed.
  * 
- * Although meta-data can be found in all flash Video files there is no 
- * documentation published by Adobe that describes the data structure. As a 
+ * Although meta-data can be found in all flash Video files there is no
+ * documentation published by Adobe that describes the data structure. As a
  * result the information is decoded as a simple block of binary data.
- */  
+ */
 public final class FSVideoMetaData extends FSVideoObject
 {
 	private byte[] data;
-	
+
 	FSVideoMetaData(FSCoder coder)
 	{
-        super(FSVideoObject.MetaData, 0);
+		super(FSVideoObject.MetaData, 0);
 		decode(coder);
 	}
-    
-    /**
-     * Get the encoded meta data that decribes how the video stream should be 
-     * played.
-     *
-     * @return an array of bytes containing the encoded meta-data.
-     */
-    public byte[] getData() 
-    {
-        return data;
-    }
 
-    /**
-     * Sets the encoded meta data that decribes how the video stream should be 
-     * played.
-     * 
-     * @param data an array of bytes containing the encoded meta-data.
-     */
-    public void setData(byte[] data)
+	/**
+	 * Get the encoded meta data that describes how the video stream should be
+	 * played.
+	 * 
+	 * @return an array of bytes containing the encoded meta-data.
+	 */
+	public byte[] getData()
 	{
+		return data;
+	}
+
+	/**
+	 * Sets the encoded meta data that describes how the video stream should be
+	 * played.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the encoded meta-data.
+	 */
+	public void setData(byte[] data)
+	{
 		this.data = data;
 	}
-    
-    public Object clone()
+
+	public Object clone()
 	{
-        FSVideoMetaData anObject = (FSVideoMetaData)super.clone();
-        
+		FSVideoMetaData anObject = (FSVideoMetaData) super.clone();
+
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSVideoMetaData typedObject = (FSVideoMetaData)anObject;
-            
-            if (data != null)
-                result = result &amp;&amp; Transform.equals(data, typedObject.data);
-            else
-                result = result &amp;&amp; typedObject.data == null;
-        }
+		{
+			FSVideoMetaData typedObject = (FSVideoMetaData) anObject;
+
+			if (data != null)
+				result = result &amp;&amp; Transform.equals(data, typedObject.data);
+			else
+				result = result &amp;&amp; typedObject.data == null;
+		}
 		return result;
 	}
 
-	public void appendDescription(StringBuffer buffer, int depth)
+	public String toString()
 	{
-		buffer.append(name());
+		StringBuffer buffer = new StringBuffer();
 
-		if (depth &gt; 0)
-		{
-			buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
-			buffer.append(&quot;}&quot;);
-		}
+		buffer.append(&quot;FSVideoMetaData: { &quot;);
+		buffer.append(&quot;data = &quot;).append(&quot;&lt;data&gt;&quot;).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
 	}
 
-	int length(FSCoder coder)
+	public int length(FSCoder coder)
 	{
 		super.length(coder);
-	
+
 		length += data.length;
-	
+
 		return length;
 	}
-	
-	void encode(FSCoder coder)
+
+	public void encode(FSCoder coder)
 	{
-        super.encode(coder);
+		super.encode(coder);
 		coder.writeBytes(data);
 	}
-	
-	void decode(FSCoder coder)
+
+	public void decode(FSCoder coder)
 	{
 		super.decode(coder);
-        data = new byte[length];
-        coder.readBytes(data);
+		data = new byte[length];
+		coder.readBytes(data);
 	}
 }
\ No newline at end of file

Modified: dev/dev-2-4/src/com/flagstone/transform/FSVideoObject.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSVideoObject.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSVideoObject.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -29,130 +29,152 @@
  */
 package com.flagstone.transform;
 
-/** 
- * The FSVideoObject is the root class for objects that represent each of the 
- * tagged data structures that make up the Flash Video file format specification.
- *
- * Each of the major data structures defined in the Flash file format specification 
- * start with a header that contains the type identifying the data structure followed 
- * by the number of bytes that the body of the encoded data structure occupies in 
- * the file. The FSVideoObject manages the encoding and decoding of this information.
- *
+import java.io.IOException;
+
+/**
+ * The FSVideoObject is the root class for objects that represent each of the
+ * tagged data structures that make up the Flash Video file format
+ * specification.
+ * 
+ * Each of the major data structures defined in the Flash file format
+ * specification start with a header that contains the type identifying the data
+ * structure followed by the number of bytes that the body of the encoded data
+ * structure occupies in the file. The FSVideoObject manages the encoding and
+ * decoding of this information.
+ * 
  * This class is primarily used internally in the library however the getType()
- * method is useful when manipulating decoded video files. Rather than using the 
- * runtime type checking provided in the Java environment the method can be used 
- * to identify the class, derived from FSVideoObject, that represents each data 
+ * method is useful when manipulating decoded video files. Rather than using the
+ * runtime type checking provided in the Java environment the method can be used
+ * to identify the class, derived from FSVideoObject, that represents each data
  * structure, improving performance.
  */
 
-public abstract class FSVideoObject extends Object implements Cloneable
+public abstract class FSVideoObject implements Cloneable, Codeable
 {
-    /** Type identifying objects containing sound */
-    public static final int AudioData = 8;
-    /** Type identifying objects containing video */
-    public static final int VideoData = 9;
-    /** Type identifying objects containing meta-data */
-    public static final int MetaData = 18;
+	/** Type identifying objects containing sound */
+	public static final int AudioData = 8;
+	/** Type identifying objects containing video */
+	public static final int VideoData = 9;
+	/** Type identifying objects containing meta-data */
+	public static final int MetaData = 18;
+	
+	static void encode(FSCoder coder, FSVideoObject object) throws IOException
+	{
+		int length = object.length;
+		int start = coder.getPointer();
+		int next = start + (length &lt;&lt; 3);
 
-    protected int type = 0;
-	protected int length = 0;
-	protected int timestamp = 0;
+		object.encode(coder);
+		coder.setPointer(next);
 
+		if (((next - coder.getPointer()) &gt;&gt; 3) != 0)
+			throw new IOException();
+
+		coder.writeWord(length + 11, 4);
+	}
+
+	protected int type;
+	protected int length;
+	protected int timestamp;
+
 	/**
-	 * Constructs a movie object with the specified type. The timestamp identifies the 
-     * time, in milliseconds, relative to the start of the file that the audio or video
-     * will be played.
-     *
-     * The timestamp is used exclusively for determining when sound or video will be 
-     * played. Any internal timing information in the audio or video data is ignored. 
-     *
-	 * @param type an identifier indicating the type of movie object.
-	 * @param timestamp the time in milliseconds at which the data should be played.
+	 * Constructs a movie object with the specified type. The timestamp
+	 * identifies the time, in milliseconds, relative to the start of the file
+	 * that the audio or video will be played.
+	 * 
+	 * The timestamp is used exclusively for determining when sound or video
+	 * will be played. Any internal timing information in the audio or video
+	 * data is ignored.
+	 * 
+	 * @param type
+	 *            an identifier indicating the type of movie object.
+	 * @param timestamp
+	 *            the time in milliseconds at which the data should be played.            
 	 */
-    public FSVideoObject(int type, int timestamp)
+	protected FSVideoObject(int type, int timestamp)
 	{
 		this.type = type;
-        this.timestamp = timestamp;
+		setTimestamp(timestamp);
 	}
 
-    /** 
-     * Gets the code used that identifies the type of the object when it is 
-     * encoded. 
- 	 *
-     * @return the code used to denote the type of the object.
-     */
-	public int getType() 
-    {
-        return type;
-    }
-    
-    int getLength()
-    {
-    	return length;
-    }
+	/**
+	 * Gets the code used that identifies the type of the object when it is
+	 * encoded.
+	 * 
+	 * @return the code used to denote the type of the object.
+	 */
+	public int getType()
+	{
+		return type;
+	}
+	
+	/**
+	 * Gets the timestamp, in milliseconds, relative to the start of the file,
+	 * when the audio or video will be played.
+	 * 
+	 * @return the time when the data will be played.
+	 */
+	public int getTimestamp()
+	{
+		return timestamp;
+	}
 
-    /**
-     * Gets the timestamp, in milliseconds, relative to the start of the file, when the 
-     * audio or video will be played.
-     *
-     * @return the time when the data will be played.
-     */
-	public int getTimestamp() 
-    {
-        return timestamp;
-    }
-    
-    /**
-     * Sets the timestamp, in milliseconds, relative to the start of the file, when the 
-     * audio or video will be played.
-     *
-     * @return time the time in milliseconds relative to the start of the file.
-     */
-	public void setTimestamp(int time) 
-    {
-        timestamp = time;
-    }
-    
-	public boolean equals(Object anObject)
+	/**
+	 * Sets the timestamp, in milliseconds, relative to the start of the file,
+	 * when the audio or video will be played.
+	 * 
+	 * @return time the time in milliseconds relative to the start of the file.
+	 */
+	public void setTimestamp(int time)
 	{
-        boolean result = false; 
-        
-        if (getClass().isInstance(anObject))
-        {
-            FSVideoObject typedObject = (FSVideoObject)anObject;
-            
-            result = type == typedObject.type;
-            result = result &amp;&amp; timestamp == typedObject.timestamp;
-        }
-        return result;
+		timestamp = time;
 	}
 
-	/** 
-	 * Return the name of the class without the package prefix. This method is used when 
-	 * logging events to identify the object being encoded or decoded.
-	 *
-	 * @return the name of the class, e.g. FSDefineShape.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @param obj
+	 *            the reference object with which to compare.
+	 * @return true if this object would be identical to anObject when encoded.
 	 */
-	public String name()
+	public boolean equals(Object obj)
 	{
-		String className = getClass().getName();
-		int index = className.lastIndexOf(&quot;.&quot;)+1;
+		boolean result = false;
 
-		return className.substring(index, className.length());
+		if (obj == null)
+		{
+			return false;
+		}
+
+		if (obj == this)
+		{
+			return true;
+		}
+
+		if (obj instanceof FSVideoObject)
+		{
+			FSVideoObject video = (FSVideoObject) obj;
+			
+			result = type == video.type;
+			result = result &amp;&amp; timestamp == video.timestamp;
+		}
+		return result;
 	}
-   
-	/** Creates a deep copy of the entire object.
-
-		 @return a copy of the object.
-		 */
+	
+	/**
+	 * Creates a deep copy of the entire object.
+	 * 
+	 * @return a copy of the object.
+	 */
 	public Object clone()
 	{
 		Object anObject = null;
-        
-		try 
-		{
+
+		try {
 			anObject = super.clone();
-		}
+		} 
 		catch (CloneNotSupportedException e)
 		{
 			throw new InternalError();
@@ -160,35 +182,30 @@
 		return anObject;
 	}
 
-	public void appendDescription(StringBuffer buffer, int depth)
+	public int length(FSCoder coder)
 	{
-		buffer.append(name());
-	}
+		coder.context[FSCoder.Type] = type;
 
-	int length(FSCoder coder)
-	{
-		coder.context[FSCoder.Type] = type;
-        
-        length = 11;
-        
+		length = 11;
+
 		return length;
 	}
 
-	void encode(FSCoder coder)
+	public void encode(FSCoder coder)
 	{
 		coder.context[FSCoder.Type] = type;
-		
-        coder.writeWord(type, 1);			
-        coder.writeWord(length, 3);			
-        coder.writeWord(timestamp, 3);			
-        coder.writeWord(0, 4);			
+
+		coder.writeWord(type, 1);
+		coder.writeWord(length, 3);
+		coder.writeWord(timestamp, 3);
+		coder.writeWord(0, 4);
 	}
-	
-	void decode(FSCoder coder)
+
+	public void decode(FSCoder coder)
 	{
-        type = coder.readWord(1, false);
-        length = coder.readWord(3, false);
-        timestamp = coder.readWord(3, false);
-        coder.readWord(4, false); // reserved
+		type = coder.readByte();
+		length = coder.readWord(3, false);
+		timestamp = coder.readWord(3, false);
+		coder.readWord(4, false); // reserved
 	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,178 +31,217 @@
 package com.flagstone.transform;
 
 /**
-The FSWaitForFrame action instructs the player to wait until the specified frame 
- number has been loaded. 
- 
-&lt;p&gt;If the frame has been loaded then the actions in the following &lt;i&gt;n&lt;/i&gt; actions are executed. This action is most often used to execute a short animation loop that plays until the main part of a movie has been loaded.&lt;/p&gt;
+ * The FSWaitForFrame action instructs the player to wait until the specified
+ * frame number has been loaded.
+ * 
+ * &lt;p&gt;
+ * If the frame has been loaded then the actions in the following &lt;i&gt;n&lt;/i&gt;
+ * actions are executed. This action is most often used to execute a short
+ * animation loop that plays until the main part of a movie has been loaded.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameNumber&lt;/td&gt;
+ * &lt;td&gt;The number of the frame to check to see whether it has been loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actionCount&lt;/td&gt;
+ * &lt;td&gt;The number of actions, following the FSWaitForFrame action that will be
+ * executed when the frame has been loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * The following example instructs the Flash Player to wait until the eighth
+ * frame of a movie clip has been loaded then to move the time-line to the
+ * loaded frame:
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSWaitForFrame(8, 1));
+ * actions.add(new FSGotoFrame(8));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This method of waiting until a frame has been loaded is considered obsolete.
+ * Determining the number of frames loaded using the FramesLoaded property of
+ * the Flash player in combination with an FSIf action is now the preferred
+ * mechanism:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(&quot;_root&quot;));
+ * actions.add(new FSAction(FSAction.GetVariable));
+ * actions.add(new FSPush(FSPush.FramesLoaded));
+ * actions.add(new FSAction(FSAction.GetProperty));
+ * actions.add(new FSPush(8));
+ * actions.add(new FSAction(FSAction.Less));
+ * actions.add(new FSIf(-29));
+ * 
+ * actions.add(new FSGotoFrame(8));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWaitForFrame class represents the ActionWaitForFrame action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSWaitForFrame extends FSActionObject
+{
+	private int frameNumber = 1;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int actionCount = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSWaitForFrame object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSWaitForFrame(FSCoder coder)
+	{
+		super(WaitForFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame object with the specified frame number and
+	 * the number of actions that will be executed when the frame is loaded.
+	 * 
+	 * @param aFrameNumber
+	 *            the number of the frame to wait for.
+	 * @param anActionCount
+	 *            the number of actions to execute.
+	 */
+	public FSWaitForFrame(int aFrameNumber, int anActionCount)
+	{
+		super(WaitForFrame);
+		setFrameNumber(aFrameNumber);
+		setActionCount(anActionCount);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame_1&quot;&gt;frameNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the frame to check to see whether it has been loaded.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSWaitForFrame object.
+	 */
+	public FSWaitForFrame(FSWaitForFrame obj)
+	{
+		super(obj);
+		frameNumber = obj.frameNumber;
+		actionCount = obj.actionCount;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame_2&quot;&gt;actionCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of actions, following the FSWaitForFrame action that will be executed when the frame has been loaded.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the frame number.
+	 * 
+	 * @return the number of the frame to wait for.
+	 */
+	public int getFrameNumber()
+	{
+		return frameNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-The following example instructs the Flash Player to wait until the eighth frame of a movie clip has been loaded then to move the time-line to the loaded frame:
+	/**
+	 * Gets the number of actions that will be executed when the specified frame
+	 * is loaded.
+	 * 
+	 * @return the number of actions.
+	 */
+	public int getActionCount()
+	{
+		return actionCount;
+	}
 
-&lt;pre&gt;
-actions.add(new FSWaitForFrame(8, 1));
-actions.add(new FSGotoFrame(8));
-&lt;/pre&gt;
+	/**
+	 * Sets the frame number.
+	 * 
+	 * @param aNumber
+	 *            the number of the frame to wait for.
+	 */
+	public void setFrameNumber(int aNumber)
+	{
+		frameNumber = aNumber;
+	}
 
-&lt;p&gt;This method of waiting until a frame has been loaded is considered obsolete. Determining the number of frames loaded using the FramesLoaded property of the Flash player in combination with an FSIf action is now the preferred mechanism:&lt;/p&gt;
+	/**
+	 * Sets the number of actions to execute if the frame has been loaded.
+	 * Unlike other actions it is the number of actions that are specified not
+	 * the number of bytes in memory they occupy.
+	 * 
+	 * @param aNumber
+	 *            the number of actions to execute.
+	 */
+	public void setActionCount(int aNumber)
+	{
+		actionCount = aNumber;
+	}
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(new FSAction(FSAction.GetVariable));
-actions.add(new FSPush(FSPush.FramesLoaded));
-actions.add(new FSAction(FSAction.GetProperty));
-actions.add(new FSPush(8));
-actions.add(new FSAction(FSAction.Less));
-actions.add(new FSIf(-29));
+		if (super.equals(anObject))
+		{
+			FSWaitForFrame typedObject = (FSWaitForFrame) anObject;
 
-actions.add(new FSGotoFrame(8));
-&lt;/pre&gt;
+			result = frameNumber == typedObject.frameNumber;
+			result = result &amp;&amp; actionCount == typedObject.actionCount;
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;p&gt;The FSWaitForFrame class represents the ActionWaitForFrame action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */
-public class FSWaitForFrame extends FSActionObject
-{
-    private int frameNumber = 1;
-    private int actionCount = 0;
-    
-    /**
-     * Construct an FSWaitForFrame object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSWaitForFrame(FSCoder coder)
-    {
-        super(WaitForFrame);
-        decode(coder);
-    }
-    /** Constructs an FSWaitForFrame object with the specified frame number and the number of actions that will be executed when the frame is loaded.
+		buffer.append(&quot;FSWaitForFrame: { &quot;);
+		buffer.append(&quot;frameNumber = &quot;).append(frameNumber).append(&quot;; &quot;);
+		buffer.append(&quot;actionCount = &quot;).append(actionCount).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-        @param aFrameNumber the number of the frame to wait for.
-        @param anActionCount the number of actions to execute.
-        */
-    public FSWaitForFrame(int aFrameNumber, int anActionCount)
-    {
-        super(WaitForFrame);
-        setFrameNumber(aFrameNumber);
-        setActionCount(anActionCount);
-    }
-    /**
-     * Constructs an FSWaitForFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSWaitForFrame object.
-     */
-    public FSWaitForFrame(FSWaitForFrame obj)
-    {
-        super(obj);
-        frameNumber = obj.frameNumber;
-        actionCount = obj.actionCount;
-    }    
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the frame number.
+		length += 3;
 
-        @return the number of the frame to wait for.
-        */
-    public int getFrameNumber() { return frameNumber; }
+		return length;
+	}
 
-    /** Gets the number of actions that will be executed when the specified frame is loaded.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(frameNumber, 2);
+		coder.writeWord(actionCount, 1);
+	}
 
-        @return the number of actions.
-        */
-    public int getActionCount() { return actionCount; }
-
-    /** Sets the frame number.
-
-        @param aNumber the number of the frame to wait for.
-        */
-    public void setFrameNumber(int aNumber)
-    {
-        frameNumber = aNumber;
-    } 
-
-    /** Sets the number of actions to execute if the frame has been loaded. Unlike other actions it is the number of actions that are specified not the number of bytes in memory they occupy.
-
-        @param aNumber the number of actions to execute.
-        */
-    public void setActionCount(int aNumber)
-    {
-        actionCount = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSWaitForFrame typedObject = (FSWaitForFrame)anObject;
-            
-            result = frameNumber == typedObject.frameNumber;
-            result = result &amp;&amp; actionCount == typedObject.actionCount;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
-            Transform.append(buffer, &quot;actionCount&quot;, actionCount);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 3;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(frameNumber, 2);
-        coder.writeWord(actionCount, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        frameNumber = coder.readWord(2, false);
-        actionCount = coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		frameNumber = coder.readWord(2, false);
+		actionCount = coder.readByte();
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame2.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame2.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSWaitForFrame2.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -31,150 +31,182 @@
 package com.flagstone.transform;
 
 /**
-The FSWaitForFrame2 action instructs the player to wait until the specified frame 
-number or named frame has been loaded. 
- 
-&lt;p&gt;If the frame has been loaded then the following &lt;i&gt;n&lt;/i&gt; actions are executed. The FSWaitForFrame2 action extends the FSWaitForFrame action by allowing the name of a frame to be specified.&lt;/p&gt;
+ * The FSWaitForFrame2 action instructs the player to wait until the specified
+ * frame number or named frame has been loaded.
+ * 
+ * &lt;p&gt;
+ * If the frame has been loaded then the following &lt;i&gt;n&lt;/i&gt; actions are
+ * executed. The FSWaitForFrame2 action extends the FSWaitForFrame action by
+ * allowing the name of a frame to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actionCount&lt;/td&gt;
+ * &lt;td&gt;The number of actions following that will be executed when the frame of
+ * interest has been loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSWaitForFrame2 is a stack-based action. The frame number or frame name which
+ * should be loaded to trigger execution of the following actions is popped from
+ * the Flash Player's stack.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * The following example instructs the Flash Player to wait until the frame with
+ * the name &quot;frame&quot; in a movie clip has been loaded:
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(&quot;frame&quot;));
+ * actions.add(new FSWaitForFrame2(1));
+ * actions.add(new FSGotoFrame2(&quot;frame&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This method of waiting until a frame has been loaded is considered obsolete.
+ * Determining the number of frames loaded using the FramesLoaded property of
+ * the Flash player in combination with an FSIf action is now the preferred
+ * mechanism:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(&quot;_root&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSPush.FramesLoaded));
+ * actions.add(FSAction.GetProperty());
+ * actions.add(new FSPush(8));
+ * actions.add(FSAction.Less());
+ * actions.add(new FSIf(-29));
+ * 
+ * actions.add(new FSGotoFrame(8));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWaitForFrame2 class represents the ActionWaitForFrame2 action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 4.
+ * &lt;/p&gt;
+ */
+public class FSWaitForFrame2 extends FSActionObject
+{
+	private int actionCount = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSWaitForFrame2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSWaitForFrame2(FSCoder coder)
+	{
+		super(WaitForFrame2);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame2 object with the number of actions to
+	 * execute if the frame has been loaded.
+	 * 
+	 * @param aNumber
+	 *            the number of actions to execute.
+	 */
+	public FSWaitForFrame2(int aNumber)
+	{
+		super(WaitForFrame2);
+		setActionCount(aNumber);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSWaitForFrame2 object.
+	 */
+	public FSWaitForFrame2(FSWaitForFrame2 obj)
+	{
+		super(obj);
+		actionCount = obj.actionCount;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame2_1&quot;&gt;actionCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of actions following that will be executed when the frame of interest has been loaded.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the number of actions to execute.
+	 * 
+	 * @return the number of actions to execute.
+	 */
+	public int getActionCount()
+	{
+		return actionCount;
+	}
 
-&lt;p&gt;FSWaitForFrame2 is a stack-based action. The frame number or frame name which should be loaded to trigger execution of the following actions is popped from the Flash Player's stack.&lt;/p&gt;
+	/**
+	 * Sets the number of actions to execute.
+	 * 
+	 * @param aNumber
+	 *            the number of actions to execute.
+	 */
+	public void setActionCount(int aNumber)
+	{
+		actionCount = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-The following example instructs the Flash Player to wait until the frame with the name &quot;frame&quot; in a movie clip has been loaded:
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-actions.add(new FSPush(&quot;frame&quot;));
-actions.add(new FSWaitForFrame2(1));
-actions.add(new FSGotoFrame2(&quot;frame&quot;));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+			result = actionCount == ((FSWaitForFrame2) anObject)
+							.getActionCount();
 
-&lt;p&gt;This method of waiting until a frame has been loaded is considered obsolete. Determining the number of frames loaded using the FramesLoaded property of the Flash player in combination with an FSIf action is now the preferred mechanism:&lt;/p&gt;
+		return result;
+	}
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSPush.FramesLoaded));
-actions.add(FSAction.GetProperty());
-actions.add(new FSPush(8));
-actions.add(FSAction.Less());
-actions.add(new FSIf(-29));
+		buffer.append(&quot;FSWaitForFrame2: { &quot;);
+		buffer.append(&quot;actionCount = &quot;).append(actionCount).append(&quot;; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-actions.add(new FSGotoFrame(8));
-&lt;/pre&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		length += 1;
 
-&lt;p&gt;The FSWaitForFrame2 class represents the ActionWaitForFrame2 action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSWaitForFrame2 extends FSActionObject
-{
-    private int actionCount = 0;
-    
-    /**
-     * Construct an FSWaitForFrame2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSWaitForFrame2(FSCoder coder)
-    {
-        super(WaitForFrame2);
-        decode(coder);
-    }
-    /** Constructs an FSWaitForFrame2 object with the number of actions to execute if the frame has been loaded.
+		return length;
+	}
 
-        @param aNumber the number of actions to execute.
-        */
-    public FSWaitForFrame2(int aNumber)
-    {
-        super(WaitForFrame2);
-        setActionCount(aNumber);
-    }
-    /**
-     * Constructs an FSWaitForFrame2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSWaitForFrame2 object.
-     */
-    public FSWaitForFrame2(FSWaitForFrame2 obj)
-    {
-        super(obj);
-        actionCount = obj.actionCount;
-    }    
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(actionCount, 1);
+	}
 
-    /** Gets the number of actions to execute.
-
-        @return the number of actions to execute.
-        */    
-    public int getActionCount() { return actionCount; }
-
-    /** Sets the number of actions to execute.
-
-        @param aNumber the number of actions to execute.
-        */        
-    public void setActionCount(int aNumber)
-    {
-        actionCount = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = actionCount == ((FSWaitForFrame2)anObject).getActionCount();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;actionCount&quot;, actionCount);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(actionCount, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        actionCount = coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		actionCount = coder.readByte();
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/FSWith.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSWith.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/FSWith.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,231 +33,253 @@
 import java.util.*;
 
 /**
-FSWith is a stack-based action and supports the with statement from the ActionScript language.
- 
-&lt;pre&gt;
-with(_root.movieClip)
+ * FSWith is a stack-based action and supports the with statement from the
+ * ActionScript language.
+ * 
+ * &lt;pre&gt;
+ *  with(_root.movieClip)
+ *  {
+ *  gotoAndPlay(&quot;frame&quot;);
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;A code identifying the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of actions that will be executed for the specified movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWith action temporarily selects the movie clip allowing the following
+ * stream of actions to control the movie clip's time-line.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The ActionScript shown above is represented (compiled) into the following
+ * actions:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * clipActions.add(new FSPush(&quot;frame&quot;));
+ * clipActions.add(new FSPush(1));
+ * clipActions.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * clipActions.add(FSAction.ExecuteFunction());
+ * 
+ * // Get the movie clip 
+ * 
+ * actions.add(new FSPush(&quot;_root&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(&quot;movieClip&quot;));
+ * actions.add(FSAction.GetAttribute());
+ * 
+ * actions.add(new FSWith(clipActions));
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWith class represents the ActionWith action in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5. FSWith
+ * supersedes the FSSetTarget action.
+ * &lt;/p&gt;
+ */
+public class FSWith extends FSActionObject
 {
-    gotoAndPlay(&quot;frame&quot;);
-}
-&lt;/pre&gt;
+	private ArrayList actions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/*
+	 * Variables used when encoding.
+	 */
+	private int actionsLength = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSWith object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSWith(FSCoder coder)
+	{
+		super(With);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWith_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A code identifying the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWith object with an array of actions.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public FSWith(ArrayList anArray)
+	{
+		super(With);
+		setActions(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWith_1&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of actions that will be executed for the specified movie clip.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSWith object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSWith(FSWith obj)
+	{
+		super(obj);
 
-&lt;p&gt;The FSWith action temporarily selects the movie clip allowing the following stream of actions to control the movie clip's time-line.&lt;/p&gt;
+		actions = new ArrayList(obj.actions.size());
 
-&lt;p&gt;The ActionScript shown above is represented (compiled) into the following actions:&lt;/p&gt;
+		for (Iterator i = obj.actions.iterator(); i.hasNext();)
+			actions.add(((FSActionObject) i.next()).clone());
+	}
 
-&lt;pre&gt;
-clipActions.add(new FSPush(&quot;frame&quot;));
-clipActions.add(new FSPush(1));
-clipActions.add(new FSPush(&quot;gotoAndPlay&quot;));
-clipActions.add(FSAction.ExecuteFunction());
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		actions.add(anAction);
+	}
 
-// Get the movie clip 
+	/**
+	 * Get the array of actions that are executed for the movie clip target.
+	 * 
+	 * @return the array of action objects.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(&quot;movieClip&quot;));
-actions.add(FSAction.GetAttribute());
+	/**
+	 * Set the array of actions that will be executed for the movie clip target.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
 
-actions.add(new FSWith(clipActions));
+	public Object clone()
+	{
+		FSWith anObject = (FSWith) super.clone();
 
-&lt;/pre&gt;
+		anObject.actions = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		for (Iterator i = actions.iterator(); i.hasNext();)
+			anObject.actions.add(((FSActionObject) i.next()).clone());
 
-&lt;p&gt;The FSWith class represents the ActionWith action in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5. FSWith supersedes the FSSetTarget action.&lt;/p&gt;
- */  
-public class FSWith extends FSActionObject
-{
-    private ArrayList actions = null;
-    
-    /*
-     * Variables used when encoding.
-     */
-    private int actionsLength = 0;
-    
-    /**
-     * Construct an FSWith object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSWith(FSCoder coder)
-    {
-        super(With);
-        decode(coder);
-    }
-    /** Constructs an FSWith object with an array of actions.
+		return anObject;
+	}
 
-        @param anArray the array of action objects.
-        */
-    public FSWith(ArrayList anArray)
-    {
-        super(With);
-        setActions(anArray);
-    }
-    /**
-     * Constructs an FSWith object by copying values from an existing object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSWith(FSWith obj)
-    {
-        super(obj);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        actions = new ArrayList(obj.actions.size());
-        
-        for (Iterator i = obj.actions.iterator(); i.hasNext();)
-            actions.add(((FSActionObject)i.next()).clone());
-    }    
+		if (super.equals(anObject))
+			result = actions.equals(((FSWith) anObject).getActions());
 
-    /** Adds the action object to the array of actions.
+		return result;
+	}
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        actions.add(anAction);
-    }
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-    /** Get the array of actions that are executed for the movie clip target.
+		buffer.append(&quot;FSWith: { &quot;);
+		buffer.append(&quot;actions = array[&quot;).append(actions.size()).append(&quot;]; &quot;);
+		buffer.append(&quot;}&quot;);
+		
+		return buffer.toString();
+	}
 
-        @return the array of action objects.
-        */
-    public ArrayList getActions() { return actions; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Set the array of actions that will be executed for the movie clip target.
+		length += 2;
 
-        @param anArray the array of action objects.
-        */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-    }
+		actionsLength = 0;
 
-    public Object clone()
-    {
-        FSWith anObject = (FSWith)super.clone();
-        
-         anObject.actions = new ArrayList();
-            
-        for (Iterator i = actions.iterator(); i.hasNext();)
-            anObject.actions.add(((FSActionObject)i.next()).clone());
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject currentAction = (FSActionObject) i.next();
 
-        return anObject;
-    }
+			actionsLength += currentAction.length(coder);
+			actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
+		length += actionsLength;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = actions.equals(((FSWith)anObject).getActions());
+		return length;
+	}
 
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(type, 1);
+		coder.writeWord(length - actionsLength, 2);
+		coder.writeWord(actionsLength, 2);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += 2;
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
 
-        actionsLength = 0;
-        
-        for (Iterator i = actions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            actionsLength += currentAction.length(coder);
-            actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        length += actionsLength;
-        
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.beginObject(name());
-     
-        coder.writeWord(type, 1);
-        coder.writeWord(length - actionsLength, 2);
-        coder.writeWord(actionsLength, 2);
+			action.encode(coder);
+			coder.setPointer(next);
 
-        for (Iterator i=actions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-              
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int bytesRead = 0;
-        
-        super.decode(coder);
-        
-        actionsLength = coder.readWord(2, false);
-        
-        length += actionsLength;
-        
-        actions = new ArrayList();
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
+	}
 
-        while (bytesRead &lt; actionsLength)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-            actions.add(anAction);
-        }
+	public void decode(FSCoder coder)
+	{
+		int bytesRead = 0;
 
-        coder.endObject(name());
-    }
+		super.decode(coder);
+
+		actionsLength = coder.readWord(2, false);
+
+		length += actionsLength;
+
+		actions = new ArrayList();
+
+		while (bytesRead &lt; actionsLength)
+		{
+			FSActionObject anAction = FSActionObject.decodeAction(coder);
+
+			bytesRead += anAction.getLength()
+							+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+			actions.add(anAction);
+		}
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/Transform.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/Transform.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/Transform.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -33,258 +33,105 @@
 import java.util.*;
 
 /**
- * The %Transform class defines constants and methods used throughout the %Transform package. 
+ * The %Transform class defines constants and methods used throughout the
+ * %Transform package.
  */
 public class Transform
 {
-    /** 
-     * @deprecated No longer required for debugging.
-     * 
-     * DEBUG is used to turn on additional logging and error checking.
-     */
-    public static final boolean DEBUG = false;
-    /** 
-     * VERSION is used to identify the version of Flash that the edition supports.
-     */
-    public static final int VERSION = 7;
+	/**
+	 * VERSION is used to identify the version of Flash that the edition
+	 * supports.
+	 */
+	public static final int VERSION = 7;
 
-    /** 
-     * MAJOR is used to identify the current version of the framework. This
-     * is incremented for each new version of Flash supported.
-     */
-    public static final int MAJOR = 2;
-    /** 
-     * MINOR is used to identify the current minor version of the framework. This
-     * is incremented when new functionality is added or API changes are made.
-     */
-    public static final int MINOR = 3;
-    /** 
-     * The RELEASE number is used to differentiate between different releases. 
-     * This number is incremented when an enhancement or bug fix has been made 
-     * and the API is unchanged.
-     */
-    public static final int RELEASE = 0;
-    /** 
-     * VALUE_NOT_SET is used to signify that a field has not yet assigned a value. Some Flash 
-     * tags contain optional fields to reduce the size of the binary data when a tag is encoded. 
-     * These fields are only encoded if they have been assigned a valid value. The range of 
-     * valid values will depend on the number of bits used to encode the field and whether it 
-     * is a signed or unsigned value. VALUE_NOT_SET was chosen to be the largest negative 
-     * integer - since the largest optional field is 16-bits in length and thus no confusion 
-     * will result.
-     */
-    public static final int VALUE_NOT_SET = Integer.MIN_VALUE;
-    
-    /** 
-     * The main method reports basic information about the package. The method prints out the 
-     * version of Flash supported and the version number along with copyright and licensing 
-     * information.
-     */    
-    public static void main(String args[]) 
-    {
-        String version = MAJOR + &quot;.&quot; + MINOR + &quot;.&quot; + RELEASE;
-        
-        System.out.println(&quot;/**&quot;);
+	/**
+	 * MAJOR is used to identify the current version of the framework. This is
+	 * incremented for each new version of Flash supported.
+	 */
+	public static final int MAJOR = 2;
 
-        System.out.println(
-            &quot; * Transform For Flash &quot; + VERSION + &quot;, Version &quot; + version);
-        
-        System.out.println(&quot; * &quot;);
-        System.out.println(&quot; * Copyright (c) Flagstone Software Limited, 2001-2008.&quot;);
-        System.out.println(&quot; * All Rights Reserved.&quot;);
-        System.out.println(&quot; * &quot;);
-        System.out.println(&quot; * Use of this software is subject to the terms in the license&quot;);
-        System.out.println(&quot; * that accompanied the software.&quot;);
-        System.out.println(&quot; * &quot;);
-        System.out.println(&quot; */&quot;);
-    }
+	/**
+	 * MINOR is used to identify the current minor version of the framework.
+	 * This is incremented when new functionality is added or API changes are
+	 * made.
+	 */
+	public static final int MINOR = 3;
 
-    static void append(StringBuffer buffer, String name, int value)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (value == Transform.VALUE_NOT_SET)
-            buffer.append(&quot;&lt;Value Not Set&gt;&quot;);
-        else
-            buffer.append(value);
-            
-        buffer.append(&quot;; &quot;);
-    }
+	/**
+	 * The RELEASE number is used to differentiate between different releases.
+	 * This number is incremented when an enhancement or bug fix has been made
+	 * and the API is unchanged.
+	 */
+	public static final int RELEASE = 0;
 
-    static void append(StringBuffer buffer, String name, boolean value)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        buffer.append(value);
-        buffer.append(&quot;; &quot;);
-    }
+	/**
+	 * VALUE_NOT_SET is used to signify that a field has not yet assigned a
+	 * value. Some Flash tags contain optional fields to reduce the size of the
+	 * binary data when a tag is encoded. These fields are only encoded if they
+	 * have been assigned a valid value. The range of valid values will depend
+	 * on the number of bits used to encode the field and whether it is a signed
+	 * or unsigned value. VALUE_NOT_SET was chosen to be the largest negative
+	 * integer - since the largest optional field is 16-bits in length and thus
+	 * no confusion will result.
+	 */
+	public static final int VALUE_NOT_SET = Integer.MIN_VALUE;
 
-    static void append(StringBuffer buffer, String name, float value)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        buffer.append(value);
-        buffer.append(&quot;; &quot;);
-    }
+	/**
+	 * The main method reports basic information about the package. The method
+	 * prints out the version of Flash supported and the version number along
+	 * with copyright and licensing information.
+	 */
+	public static void main(String args[])
+	{
+		String version = MAJOR + &quot;.&quot; + MINOR + &quot;.&quot; + RELEASE;
 
-    static void append(StringBuffer buffer, String name, String value)
-    {
-        if (value == null)
-            value = &quot;null; &quot;;
-        else if (value.equals(&quot;&lt;data&gt;&quot;))
-            value = value + &quot;; &quot;;
-        else
-            value = '&quot;' + value + &quot;\&quot;; &quot;;
-        
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        buffer.append(value);
-    }
+		System.out.println(&quot;/**&quot;);
 
-    static void append(StringBuffer buffer, String name, FSTransformObject anObject, int indentLevel)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (anObject != null)
-        {
-            if (indentLevel &gt; 0)
-                anObject.appendDescription(buffer, indentLevel-1);
-            else
-                buffer.append(anObject.name());
-        }
-        else
-        {
-            buffer.append(&quot;null&quot;);
-        }
-        buffer.append(&quot;; &quot;);
-    }
+		System.out.println(&quot; * Transform For Flash &quot; + VERSION + &quot;, Version &quot;
+						+ version);
 
-    static void append(StringBuffer buffer, String name, ArrayList anArray, int indentLevel)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (anArray != null)
-        {
-            buffer.append(&quot;Array(&quot;);
-            buffer.append(anArray.size());
-            buffer.append(&quot;) [ &quot;);
+		System.out.println(&quot; * &quot;);
+		System.out
+						.println(&quot; * Copyright (c) Flagstone Software Limited, 2001-2008.&quot;);
+		System.out.println(&quot; * All Rights Reserved.&quot;);
+		System.out.println(&quot; * &quot;);
+		System.out
+						.println(&quot; * Use of this software is subject to the terms in the license&quot;);
+		System.out.println(&quot; * that accompanied the software.&quot;);
+		System.out.println(&quot; * &quot;);
+		System.out.println(&quot; */&quot;);
+	}
 
-            for (Iterator j = anArray.iterator(); j.hasNext();)
-            {
-                Object currentElement = j.next();
-                        
-                if (currentElement instanceof FSTransformObject)
-                {
-                    FSTransformObject object = (FSTransformObject)currentElement;
-                    
-                    if (indentLevel &gt; 0)
-                        object.appendDescription(buffer, indentLevel-1);
-                    else
-                        buffer.append(object.name());
-                }
-                else if (currentElement instanceof String)
-                {
-                    buffer.append('&quot;');
-                    buffer.append(currentElement.toString());
-                    buffer.append('&quot;');
-                }
-                else
-                    buffer.append(currentElement.toString());
-                
-                if (j.hasNext())
-                    buffer.append(',');
-                
-                buffer.append(' ');
-            }
-            buffer.append(&quot;]; &quot;);
-        }
-        else
-        {
-            buffer.append(&quot;null; &quot;);
-        }
-    }
+	static boolean equals(byte[] b1, byte[] b2)
+	{
+		boolean result = false;
 
-    static void append(StringBuffer buffer, String name, Hashtable table, int indentLevel)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (table != null)
-        {
-            buffer.append(&quot;Table (&quot;);
-            buffer.append(table.size());
-            buffer.append(&quot;)&quot;);
+		if (b1 == null &amp;&amp; b2 == null)
+			return true;
 
-            if (indentLevel &gt; 0)
-            {
-                buffer.append(&quot; {&quot;);
+		if (b1 != null &amp;&amp; b2 != null)
+		{
+			result = b1.length == b2.length;
 
-                for (Enumeration e = table.keys(); e.hasMoreElements(); )
-                {
-                    Object key = e.nextElement();
-                    Object value = table.get(key);
-                                
-                    buffer.append(key);
-                    buffer.append(&quot; = &quot;);
-                        
-                    if (value instanceof FSTransformObject)
-                        ((FSTransformObject)value).appendDescription(buffer, indentLevel-1);
-                    else if (value instanceof String)
-                    {
-                        buffer.append('&quot;');
-                        buffer.append(value.toString());
-                        buffer.append('&quot;');
-                    }
-                    else
-                        buffer.append(value.toString());
-                        
-                    if (e.hasMoreElements())
-                        buffer.append(',');
-                
-                    buffer.append(' ');
-                }
-            }
-            buffer.append(&quot;} &quot;);
-        }
-        else
-        {
-            buffer.append(&quot;null&quot;);
-        }
-    }
+			if (result)
+				for (int i = 0; i &lt; b1.length; i++)
+					if (b1[i] != b2[i])
+						result = false;
+		}
+		return result;
+	}
 
-    static boolean equals(byte[] b1, byte[] b2)
-    {
-        boolean result = false;
-        
-        if (b1 == null &amp;&amp; b2 ==null)
-            return true;
-            
-        if (b1 != null &amp;&amp; b2 != null)
-        {
-            result = b1.length == b2.length;
-            
-            if (result)
-                for (int i=0; i&lt;b1.length; i++)
-                    if (b1[i] != b2[i])
-                        result = false;
-        }
-        return result;
-    }
+	static byte[] clone(byte[] data)
+	{
+		byte[] newData = null;
 
-    static byte[] clone(byte[] data)
-    {
-        byte[] newData = null;
-        
-        if (data != null)
-        {
-            newData = new byte[data.length];
-        
-            for (int i=0; i&lt;data.length; i++)
-                newData[i] = data[i];
-        }
-        return newData;
-    }
+		if (data != null)
+		{
+			newData = new byte[data.length];
+
+			for (int i = 0; i &lt; data.length; i++)
+				newData[i] = data[i];
+		}
+		return newData;
+	}
 }

Modified: dev/dev-2-4/src/com/flagstone/transform/test/FSImageConstructorTest.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/test/FSImageConstructorTest.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/test/FSImageConstructorTest.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -92,7 +92,7 @@
         int xOrigin = generator.getWidth()/2;
         int yOrigin = generator.getHeight()/2;
 
-        FSSolidLine borderStyle = new FSSolidLine(20, FSColorTable.black());
+        FSLineStyle borderStyle = new FSLineStyle(20, FSColorTable.black());
 
         FSDefineObject image = generator.defineImage(imageId);
         FSDefineShape3 shape = generator.defineEnclosingShape(shapeId, imageId,

Modified: dev/dev-2-4/src/com/flagstone/transform/test/FSShapeConstructorTest.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/test/FSShapeConstructorTest.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/test/FSShapeConstructorTest.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -36,7 +36,7 @@
 
             int identifier = 0;
 
-            path.add(new FSSolidLine(20, FSColorTable.black()));
+            path.add(new FSLineStyle(20, FSColorTable.black()));
             path.add(new FSSolidFill(FSColorTable.red()));
 
             movie.setFrameRate(1.0f);

Modified: dev/dev-2-4/src/com/flagstone/transform/test/FSTextConstructorTest.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/test/FSTextConstructorTest.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/test/FSTextConstructorTest.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -341,7 +341,7 @@
         int textHeight = text.getBounds().getHeight();
         int shapeId = movie.newIdentifier();
 
-        path.add(new FSSolidLine(1, FSColorTable.darkblue()));
+        path.add(new FSLineStyle(1, FSColorTable.darkblue()));
         path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(),
                         textWidth, textHeight);
 
@@ -388,7 +388,7 @@
             int shapeId = movie.newIdentifier();
 
             path.newPath();
-            path.add(new FSSolidLine(1, FSColorTable.darkblue()));
+            path.add(new FSLineStyle(1, FSColorTable.darkblue()));
             path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(),
                             textWidth, textHeight);
 
@@ -443,7 +443,7 @@
         int shapeId = movie.newIdentifier();
 
         path.newPath();
-        path.add(new FSSolidLine(1, FSColorTable.darkblue()));
+        path.add(new FSLineStyle(1, FSColorTable.darkblue()));
         path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(),
                         textWidth, textHeight);
 

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/FSCodec.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSCodec.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSCodec.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,631 +0,0 @@
-/* 
- * FSCodec.java
- * Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform.util;
-
-/**
- * @deprecated FSCoded is replaced by FSCoder from com.flagstone.transform so
- * there is only one class for reading and writing data.
- * 
- * FSCodec is a similar to Java stream classes, allowing words and bit fields to be read
- * and written from an internal array of bytes. FSCodec supports both little-endian
- * and big-endian byte ordering. The primary use of the class is to support post-processing
- * of sound files loaded using the FSSoundConstructor class where the encoded sound samples
- * contain bits fields. For example compressing 16-bit, byte-aligned sound samples to the 
- * ADPCM format. However the class may be used in any situation where data must be encoded
- * or decoded to an array of bytes.
- * 
- * The FSCodec class maintains an internal pointer which points to the next bit in the internal
- * array where data will be read or written. When calculating an offset in bytes to jump to
- * simply multiply the offset by 8 for the correct bit position. The class provides accessor
- * methods, getPosition() and setPosition() to change the location of the internal pointer.
- * 
- * When writing to an array the size of the array is changed dynamically should a write 
- * operation cause a buffer overflow. For reads if an overflow results then the bits/bytes
- * that overflowed will be set to zero, rather than throwing an exception. The eof() method 
- * can be used to determine whether the end of the buffer has been reached.
- */
-public class FSCodec
-{
-    /** 
-     * Identifies that multibyte words are stored in little-endian format with the least
-     * significant byte in a word stored first.
-     */
-    public static final int LITTLE_ENDIAN = 0;
-
-    /** 
-     * Identifies that multibyte words are stored in big-endian format with the most
-     * significant byte in a word stored first.
-     */
-    public static final int BIG_ENDIAN = 1;
-    
-    private int byteOrder = LITTLE_ENDIAN;
-    private byte[] data = null;
-    private int ptr = 0;
-    private int end = 0;
-    
-    /**
-     * Constructs and FSCodec object containing an array of bytes with the specified byte 
-     * ordering.
-     * 
-     * @param order the byte-order for words, either FSCodec.LITTLE_ENDIAN or FSCodec.BIG_ENDIAN.
-     * @param bytes an array of bytes where the data will be read or written.
-     */
-    public FSCodec(int order, byte[] bytes)
-    {
-        byteOrder = order;
-        
-        data = new byte[bytes.length];
-        System.arraycopy(bytes, 0, data, 0, bytes.length);
-        end = data.length &lt;&lt; 3;
-    }
-    
-    /**
-     * Constructs and FSCodec object containing an array of bytes with the specified byte 
-     * ordering.
-     * 
-     * @param order the byte-order for words, either FSCodec.LITTLE_ENDIAN or FSCodec.BIG_ENDIAN.
-     * @param size the size of the internal buffer to be created.
-     */
-    public FSCodec(int order, int size)
-    {
-        byteOrder = order;
-        
-        data = new byte[size];
-        end = data.length &lt;&lt; 3;
-    }
-    
-    /**
-     * Returns a copy of the array of bytes.
-     * 
-     * @return a copy of the internal buffer.
-     */
-    public byte[] getData()
-    {
-        int length = (ptr + 7) &gt;&gt; 3;
-        
-        byte[] bytes = new byte[length];
-        System.arraycopy(data, 0, bytes, 0, length);
-        
-        return bytes;
-    }
-
-    /**
-     * Sets the array of bytes used to read or write data to. The size of the array must be 
-     * calculated in advance to avoid buffer overflows.
-     * 
-     * @param bytes a byte array that will be used as the internal buffer.
-     */
-    public void setData(byte[] bytes)
-    {
-        data = bytes;
-        ptr = 0;
-        end = data.length &lt;&lt; 3;
-    }
-    
-    /**
-     * Sets the array of bytes used to read or write data to. The byte-order for words read
-     * or written is also specified. The size of the array must be calculated in advance to 
-     * avoid buffer overflows.
-     * 
-     * @param order the byte-order for words, either FSCodec.LITTLE_ENDIAN or FSCodec.BIG_ENDIAN.
-     * @param bytes a byte array that will be used as the internal buffer.
-     */
-    public void setData(int order, byte[] bytes)
-    {
-        byteOrder = order;
-        data = bytes;
-        ptr = 0;
-        end = data.length &lt;&lt; 3;
-    }
-    
-    /**
-     * Returns the offset, in bits, from the start of the buffer where the next value will be 
-     * read or written.
-     * 
-     * @return the offset in bits where the next value will be read or written. 
-     */
-    public int getPosition()
-    {
-        return ptr;
-    }
-
-    /**
-     * Sets the offset, in bits, from the start of the buffer where the next value will be 
-     * read or written. If the offset falls outside of the bits range supported by the buffer 
-     * then the pointer is clamped to either the start or end of the buffer.
-     *  
-     * @param offset the offset in bits from the start of the array of bytes.
-     */
-    public void setPosition(int offset)
-    {
-        if (offset &lt; 0)
-            ptr = 0;
-        else if (offset &gt; end)
-            ptr = end;
-        else
-            ptr = offset;
-    }
-
-    /**
-     * Moves the internal pointer forward so it is aligned on a byte boundary. All word
-     * values read and written to the internal buffer must be byte-aligned.
-     */
-    public void alignToByte()
-    {
-        ptr = (ptr+7) &amp; ~7;
-    }
-    
-    /**
-     * Returns true of the internal pointer is at the end of the buffer.
-     * 
-     * @return true if the pointer is at the end of the buffer, false otherwise.
-     */
-    public boolean eof()
-    {
-        return ptr &gt;= end;
-    }
-
-    /**
-     * Searches the internal buffer for a bit pattern and advances the pointer to
-     * the start of the bit field, returning true to signal a successful search.
-     * If the bit pattern cannot be found then the method returns false and the 
-     * position of the internal pointer is not changed.
-     * 
-     * The step, in bits, added to the pointer can be specified, allowing the
-     * number of bits being searched to be independent of the location in the 
-     * internal buffer. This is useful for example when searching for a bit 
-     * field that begins on a byte or word boundary.
-     *  
-     * @param value an integer containing the bit patter to search for.
-     * @param numberOfBits least significant n bits in the value to search for.
-     * @param step the increment in bits to add to the internal pointer as the buffer
-     * is searched.
-     * @return true if the pattern was found, false otherwise.
-     */
-    public boolean findBits(int value, int numberOfBits, int step)
-    {
-        boolean found = false;
-        int start = ptr;
-        int val = 0;
-        
-        if (numberOfBits &lt; 1 || numberOfBits &gt; 32)
-            throw new IllegalArgumentException(&quot;Number of bits must be in the range 1..32.&quot;);
-            
-        for (; ptr &lt; end; ptr += step)
-        {
-            val = readBits(numberOfBits, false);
-            ptr -= numberOfBits;
-            
-            if (val == value)
-            {
-                found = true;
-                break;
-            }
-        }
-        
-        if (found == false)
-            ptr = start;
-            
-        return found;
-    }
-
-    /**
-     * Searches the internal buffer for a word and advances the pointer to the location
-     * where the word was found, returning true to signal a successful search. The 
-     * search will begin on the next byte boundary. If word cannot be found then the 
-     * method returns false and the position of the internal pointer is not changed.
-     * 
-     * Specifying the number of bytes in the search value allows word of either 8, 16,
-     * 24 or 32 bits to be searched for. Searches for words are performed faster than 
-     * using the findBits() method.
-     * 
-     * @param value an integer containing the word to search for.
-     * @param numberOfBytes least significant n bytes in the value to search for.
-     * @param step the increment in bits to add to the internal pointer as the buffer
-     * is searched.
-     * @return true if the pattern was found, false otherwise.
-     */
-    public boolean findWord(int value, int numberOfBytes, int step)
-    {
-        boolean found = false;
-        int start = ptr;
-        int val = 0;
-        
-        if (numberOfBytes &lt; 1 || numberOfBytes &gt; 4)
-            throw new IllegalArgumentException(&quot;Number of bytes must be in the range 1..4.&quot;);
-        
-        if ((ptr &amp; 7) &gt; 0)
-            ptr = (ptr+7) &amp; ~7;
-        
-        for (; ptr &lt; end; ptr += step)
-        {
-            val = readWord(numberOfBytes, false);
-            ptr -= (numberOfBytes*8);
-            
-            if (val == value)
-            {
-                found = true;
-                break;
-            }
-        }
-        
-        if (found == false)
-            ptr = start;
-            
-        return found;
-    }
-
-    /**
-     * Read a bit field from the internal buffer.
-     * 
-     * If a buffer overflow occurs then the number of bits which cause the overflow will 
-     * be set to zero.
-     * 
-     * @param numberOfBits the number of bits to read.
-     * @param signed a boolean flag indicating whether the value read should be sign extended.
-     * @return the value read.
-     */
-    public int readBits(int numberOfBits, boolean signed)
-    {
-        int value = 0;
-    
-        if (numberOfBits &lt; 1 || numberOfBits &gt; 32)
-            throw new IllegalArgumentException(&quot;Number of bits must be in the range 1..32.&quot;);
-        
-        int index = ptr &gt;&gt; 3;
-        int base = (data.length - index &gt; 4) ? 0  : (4 - (data.length - index))*8;
-        
-        for (int i=32; i&gt;base; i-=8, index++)
-            value |= (data[index] &amp; 0x000000FF) &lt;&lt; (i-8);
-
-        value &lt;&lt;= ptr % 8;
-
-        if (signed)
-            value &gt;&gt;= 32 - numberOfBits;
-        else 
-            value &gt;&gt;&gt;= 32 - numberOfBits;
-
-        ptr += numberOfBits;
-
-        if (ptr &gt; (data.length &lt;&lt; 3))
-            ptr = data.length &lt;&lt; 3;
-
-        return value;
-    }
-    
-    /**
-     * Write a bit value to the internal buffer. The buffer will resize automatically
-     * if required.
-     * 
-     * @param value an integer containing the value to be written.
-     * @param numberOfBits the least significant n bits from the value that will be 
-     * written to the buffer.
-     */
-    public void writeBits(int value, int numberOfBits)
-    {
-        if (ptr + numberOfBits + 24 &gt; end)
-        {
-            int length = ((numberOfBits &gt; data.length) ? numberOfBits : data.length) + data.length;
-            byte[] bytes = new byte[length];
-            
-            System.arraycopy(data, 0, bytes, 0, data.length);
-            data = bytes;
-        }
-        
-        if (numberOfBits &lt; 1 || numberOfBits &gt; 32)
-            throw new IllegalArgumentException(&quot;Number of bits must be in the range 1..32.&quot;);
-        
-        int index = ptr &gt;&gt; 3;
-
-        value &lt;&lt;= (32 - numberOfBits);    
-        value = value &gt;&gt;&gt; (ptr % 8);
-        value = value | (data[index] &lt;&lt; 24);
-
-        for (int i=24; i&gt;=0; i-=8, index++)
-            data[index] = (byte)(value &gt;&gt;&gt; i);
-        
-        ptr += numberOfBits;
-
-        if (ptr &gt; (data.length &lt;&lt; 3))
-            ptr = data.length &lt;&lt; 3;
-    }
-    
-    /**
-     * Read a word from the internal buffer.
-     * 
-     * If a buffer overflow occurs then the number of bytes which cause the overflow will 
-     * be set to zero.
-     * 
-     * @param numberOfBytes the number of bytes read in the range 1..4.
-     * @param signed a boolean flag indicating whether the value read should be sign extended.
-     * @return the value read.
-     */
-    public int readWord(int numberOfBytes, boolean signed)
-    {
-        int value = 0;
-    
-        if (numberOfBytes &lt; 1 || numberOfBytes &gt; 4)
-            throw new IllegalArgumentException(&quot;Number of bytes must be in the range 1..4.&quot;);
-        
-        int index = ptr &gt;&gt; 3;
-        
-        if (index + numberOfBytes &gt; data.length)
-            numberOfBytes = data.length - index;
-        
-        int numberOfBits = numberOfBytes*8;
-
-        if (byteOrder == LITTLE_ENDIAN)
-        {
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, index++)
-                value += (data[index] &amp; 0x000000FF) &lt;&lt; i;
-        }
-        else
-        {
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, index++)
-            {
-                value = value &lt;&lt; 8;
-                value += data[index] &amp; 0x000000FF;
-            }
-        }
-        
-        if (signed)
-        {
-            value &lt;&lt;= 32 - numberOfBits;
-            value &gt;&gt;= 32 - numberOfBits;
-        }
-
-        return value;
-    }
-
-    /**
-     * Write a word to the internal buffer. The buffer will resize automatically
-     * if required.
-     * 
-     * @param value an integer containing the value to be written.
-     * @param numberOfBytes the least significant n bytes from the value that will be 
-     * written to the buffer.
-     */
-    public void writeWord(int value, int numberOfBytes)
-    {
-        if (numberOfBytes &lt; 1 || numberOfBytes &gt; 4)
-            throw new IllegalArgumentException(&quot;Number of bytes must be in the range 1..4.&quot;);
-            
-        int numberOfBits = numberOfBytes*8;
-        
-        if (ptr + numberOfBits &gt; end)
-        {
-            int length = ((numberOfBits &gt; data.length) ? numberOfBits : data.length) + data.length;
-            byte[] bytes = new byte[length];
-            
-            System.arraycopy(data, 0, bytes, 0, data.length);
-            data = bytes;
-            end = data.length &lt;&lt; 3;
-        }
-        
-        if (byteOrder == LITTLE_ENDIAN)
-        {
-            int index = ptr &gt;&gt;&gt; 3;
-            
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, value &gt;&gt;&gt;= 8, index++)
-                data[index] = (byte)value;
-        }
-        else
-        {
-            int index = (ptr + numberOfBits - 8) &gt;&gt;&gt; 3;
-            
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, value &gt;&gt;&gt;= 8, index--)
-                data[index] = (byte)value;
-        }
-    }
-
-    /**
-     * Reads an array of bytes from the internal buffer. If a read overflow occurs
-     * while reading the internal buffer then the remaining bytes in the array will
-     * not be filled. The method returns the number of bytes read.
-     * 
-     * @param bytes the array that will contain the bytes read.
-     * @return the number of bytes read from the buffer.
-     */
-    public int readBytes(byte[] bytes)
-    {
-        int bytesRead = 0;
-    
-        if (bytes == null || bytes.length == 0)
-            return bytesRead;
-
-        int index = ptr &gt;&gt;&gt; 3;
-        int numberOfBytes = bytes.length;
-        
-        if (index + numberOfBytes &gt; data.length)
-            numberOfBytes = data.length - index;
-
-        for (int i=0; i&lt;numberOfBytes; i++, ptr+=8, index++, bytesRead++)
-            bytes[i] = data[index];
-
-        return bytesRead;
-    }
-
-    /**
-     * Writes an array of bytes from the internal buffer. The internal buffer will
-     * be resized automatically if required.
-     * 
-     * @param bytes the array containing the data to be written.
-     * @return the number of bytes written to the buffer.
-     */
-    public int writeBytes(byte[] bytes)
-    {
-        int bytesWritten = 0;
-    
-        if (ptr + (bytes.length &lt;&lt; 3) &gt; end)
-        {
-            int length = ((bytes.length &gt; data.length) ? bytes.length : data.length) + data.length;
-            byte[] buffer = new byte[length];
-            
-            System.arraycopy(data, 0, buffer, 0, data.length);
-            data = bytes;
-            end = data.length &lt;&lt; 3;
-        }
-        
-        if (bytes == null || bytes.length == 0)
-            return bytesWritten;
-
-        int index = ptr &gt;&gt;&gt; 3;
-        int numberOfBytes = bytes.length;
-
-        for (int i=0; i&lt;numberOfBytes; i++, ptr+=8, index++, bytesWritten++)
-            data[index] = bytes[i];
-        
-        return bytesWritten;
-    }
-    
-    byte[] getBuffer()
-    {
-        return data;
-    }
-
-    int getPointer()
-    {
-        return ptr;
-    }
-
-    void setPointer(int location)
-    {
-        if (location &lt; 0)
-            location = 0;
-        else if (location &gt; end)
-            location = end;
-
-        ptr = location;
-    }
-
-    void adjustPointer(int offset)
-    {
-        ptr += offset;
-        
-        if (ptr &lt; 0)
-            ptr = 0;
-        else if (ptr &gt;= end)
-            ptr = end;
-    }
-    
-    int readBits(int numberOfBits)
-    {
-        int value = 0;
-    
-        if (numberOfBits == 0)
-            return value;
-        
-        int index = ptr &gt;&gt; 3;
-        int base = (data.length - index &gt; 4) ? 0  : (4 - (data.length - index))*8;
-        
-        for (int i=32; i&gt;base; i-=8, index++)
-            value |= (data[index] &amp; 0x000000FF) &lt;&lt; (i-8);
-
-        value &lt;&lt;= ptr % 8;
-        value &gt;&gt;&gt;= 32 - numberOfBits;
-
-        ptr += numberOfBits;
-
-        if (ptr &gt; (data.length &lt;&lt; 3))
-            ptr = data.length &lt;&lt; 3;
-
-        return value;
-    }
-    
-    int readByte()
-    {
-        int value = data[ptr&gt;&gt;3] &amp; 0xFF;
-    
-        ptr += 8;
-        
-        return value;
-    }
-
-    int readShort(boolean signed)
-    {
-        int value = 0;
-        int index = ptr &gt;&gt; 3;
-        
-        if (byteOrder == LITTLE_ENDIAN)
-        {
-            value = (data[index++] &amp; 0xFF);    
-            value += (data[index] &amp; 0xFF) &lt;&lt; 8;
-        }
-        else
-        {
-            value = (data[index++] &amp; 0xFF) &lt;&lt; 8;
-            value += (data[index] &amp; 0xFF);    
-        }
-
-        if (signed)
-        {
-            value &lt;&lt;= 16;
-            value &gt;&gt;= 16;
-        }
-        ptr += 16;
-        
-        return value;
-    }
-
-    int readInt()
-    {
-        int value = 0;
-        int index = ptr &gt;&gt; 3;
-        
-        if (byteOrder == LITTLE_ENDIAN)
-        {
-            value = (data[index++] &amp; 0xFF);    
-            value += (data[index++] &amp; 0xFF) &lt;&lt; 8;
-            value += (data[index++] &amp; 0xFF) &lt;&lt; 16;
-            value += (data[index] &amp; 0xFF) &lt;&lt; 24;
-        }
-        else
-        {
-            value = (data[index++] &amp; 0xFF) &lt;&lt; 24;
-            value += (data[index++] &amp; 0xFF) &lt;&lt; 16;
-            value += (data[index++] &amp; 0xFF) &lt;&lt; 8;
-            value += (data[index] &amp; 0xFF);    
-        }
-        ptr += 32;
-        
-        return value;
-    }
-
-    float readFixedBits(int numberOfBits, int fractionSize)
-    {
-        float value = 0;
-        float divisor = (float)(1 &lt;&lt; fractionSize);
-    
-        value = ((float)readBits(numberOfBits, true)) / divisor;
-        
-        return value;
-    }
-}

Modified: dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSImageConstructor.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -48,7 +48,7 @@
 import com.flagstone.transform.FSShapeStyle;
 import com.flagstone.transform.FSLine;
 
-import com.flagstone.transform.FSSolidLine;
+import com.flagstone.transform.FSLineStyle;
 
 import com.flagstone.transform.FSFillStyle;
 import com.flagstone.transform.FSBitmapFill;
@@ -891,7 +891,7 @@
      * @param borderStyle the style drawn around the border of the image. May be null if no 
      * border is drawn.
      */
-    public FSDefineShape3 defineEnclosingShape(int shapeIdentifier, int imageIdentifier, int xOrigin, int yOrigin, FSSolidLine borderStyle)
+    public FSDefineShape3 defineEnclosingShape(int shapeIdentifier, int imageIdentifier, int xOrigin, int yOrigin, FSLineStyle borderStyle)
     {
         int lineWidth = 0;
         
@@ -937,7 +937,7 @@
             
             if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
             {
-                coder.readWord(1, false);
+                coder.readByte();
                 height = coder.readWord(2, false);
                 width = coder.readWord(2, false);
                 return true;
@@ -964,7 +964,7 @@
         
         for (int i=0; i&lt;2; i++)
         {
-            if (coder.readWord(1, false) != bmpSignature[i])
+            if (coder.readByte() != bmpSignature[i])
                 throw new DataFormatException(&quot;Not a valid BMP file&quot;);
         }
 
@@ -1029,19 +1029,19 @@
                 for (int i=0; i &lt; coloursUsed; i++) 
                 {
                     colourTable[i][3] = (byte)0xFF;
-                    colourTable[i][2] = (byte)coder.readWord(1, false);
-                    colourTable[i][1] = (byte)coder.readWord(1, false);
-                    colourTable[i][0] = (byte)coder.readWord(1, false);
+                    colourTable[i][2] = (byte)coder.readByte();
+                    colourTable[i][1] = (byte)coder.readByte();
+                    colourTable[i][0] = (byte)coder.readByte();
                 }
             }
             else
             {
                 for (int i=0; i &lt; coloursUsed; i++)
                 {
-                    colourTable[i][0] = (byte)coder.readWord(1, false);
-                    colourTable[i][1] = (byte)coder.readWord(1, false);
-                    colourTable[i][2] = (byte)coder.readWord(1, false);
-                    colourTable[i][3] = (byte)(coder.readWord(1, false) | 0xFF);
+                    colourTable[i][0] = (byte)coder.readByte();
+                    colourTable[i][1] = (byte)coder.readByte();
+                    colourTable[i][2] = (byte)coder.readByte();
+                    colourTable[i][3] = (byte)(coder.readByte() | 0xFF);
                 }
             }
                 
@@ -1096,11 +1096,11 @@
 
         while (containsMorePixels) 
         {       
-            int count = coder.readWord(1, false);
+            int count = coder.readByte();
         
             if (count == 0)
             {
-                int code = coder.readWord(1, false);
+                int code = coder.readByte();
                 
                 switch (code)
                 {
@@ -1121,7 +1121,7 @@
                             indexedImage[row][col++] = (byte) coder.readBits(4, false);
                         }
                         
-                        if ((code &amp; 2) == 2) coder.readWord(1, false);
+                        if ((code &amp; 2) == 2) coder.readByte();
                         break;
                 }
             }
@@ -1145,11 +1145,11 @@
 
         while (containsMorePixels) 
         {       
-            int count = coder.readWord(1, false);
+            int count = coder.readByte();
         
             if (count == 0)
             {
-                int code = coder.readWord(1, false);
+                int code = coder.readByte();
                 
                 switch (code)
                 {
@@ -1165,15 +1165,15 @@
                         row -= coder.readWord(2, false);
                     default:
                         for (int i=0; i&lt;code; i++)
-                            indexedImage[row][col++] = (byte) coder.readWord(1, false);
+                            indexedImage[row][col++] = (byte) coder.readByte();
                         
-                        if ((code &amp; 1) == 1) coder.readWord(1, false);
+                        if ((code &amp; 1) == 1) coder.readByte();
                         break;
                 }
             }
             else
             {
-                byte index = (byte)coder.readWord(1, false);
+                byte index = (byte)coder.readByte();
                 
                 for (int i=0; i&lt;count; i++) 
                     indexedImage[row][col++] = index;
@@ -1268,10 +1268,10 @@
         {
             for (w=0; w&lt;width; w++)
             {
-                colorImage[h][w][2] = (byte)coder.readWord(1, false);
-                colorImage[h][w][1] = (byte)coder.readWord(1, false);
-                colorImage[h][w][0] = (byte)coder.readWord(1, false);
-                colorImage[h][w][3] = (byte)coder.readWord(1, false);
+                colorImage[h][w][2] = (byte)coder.readByte();
+                colorImage[h][w][1] = (byte)coder.readByte();
+                colorImage[h][w][0] = (byte)coder.readByte();
+                colorImage[h][w][3] = (byte)coder.readByte();
                 colorImage[h][w][3] = (byte)0xFF;
             }
         }
@@ -1287,7 +1287,7 @@
 
         for (int i=0; i&lt;8; i++)
         {
-            if (coder.readWord(1, false) != pngSignature[i])
+            if (coder.readByte() != pngSignature[i])
                 throw new DataFormatException(&quot;Not a valid PNG file&quot;);
         }
         
@@ -1340,11 +1340,11 @@
     {
         width = coder.readWord(4, false);
         height = coder.readWord(4, false);
-        attributes[BIT_DEPTH] = coder.readWord(1, false);
-        attributes[COLOUR_TYPE] = coder.readWord(1, false);
-        attributes[COMPRESSION_METHOD] = coder.readWord(1, false);
-        attributes[FILTER_METHOD] = coder.readWord(1, false);
-        attributes[INTERLACE_METHOD] = coder.readWord(1, false);
+        attributes[BIT_DEPTH] = coder.readByte();
+        attributes[COLOUR_TYPE] = coder.readByte();
+        attributes[COMPRESSION_METHOD] = coder.readByte();
+        attributes[FILTER_METHOD] = coder.readByte();
+        attributes[INTERLACE_METHOD] = coder.readByte();
         
         coder.readWord(4, false); // crc
 
@@ -1369,9 +1369,9 @@
             for (int i=0; i&lt;paletteSize; i++)
             {
                 colourTable[i][3] = (byte)0xFF;
-                colourTable[i][2] = (byte)coder.readWord(1, false);
-                colourTable[i][1] = (byte)coder.readWord(1, false);
-                colourTable[i][0] = (byte)coder.readWord(1, false);
+                colourTable[i][2] = (byte)coder.readByte();
+                colourTable[i][1] = (byte)coder.readByte();
+                colourTable[i][0] = (byte)coder.readByte();
             }
         }
         else
@@ -1397,7 +1397,7 @@
                 format = IDXA;
                 for (int i=0; i&lt;length; i++) 
                 {
-                    colourTable[i][3] = (byte)coder.readWord(1, false);
+                    colourTable[i][3] = (byte)coder.readByte();
 
                     if (colourTable[i][3] == 0) {
                         colourTable[i][0] = 0;
@@ -1422,7 +1422,7 @@
         System.arraycopy(chunkData, 0, data, 0, currentLength);
 
         for (int i=currentLength; i&lt;newLength; i++)
-            data[i] = (byte)coder.readWord(1, false);
+            data[i] = (byte)coder.readByte();
             
         chunkData = data;
         
@@ -1563,7 +1563,7 @@
             case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; break;
             case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; break;
             case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; break;
-            case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; break;
+            case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
             case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
         }                    
 
@@ -1582,7 +1582,7 @@
         {
             switch (attributes[BIT_DEPTH])
             {
-                case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; break;
+                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
                 case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
             }                    
             colorImage[row][col][i] = colour;
@@ -1599,7 +1599,7 @@
             case 1:  index = coder.readBits(1, false); break;
             case 2:  index = coder.readBits(2, false); break;
             case 4:  index = coder.readBits(4, false); break;
-            case 8:  index = coder.readWord(1, false); break;
+            case 8:  index = coder.readByte(); break;
             case 16: index = coder.readWord(2, false); break;
         }                    
         indexedImage[row][col] = (byte)index;
@@ -1616,7 +1616,7 @@
             case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; alpha = coder.readBits(1, false); break;
             case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; alpha = coder.readBits(2, false); break;
             case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; alpha = coder.readBits(4, false); break;
-            case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; alpha = coder.readWord(1, false); break;
+            case 8:  pixel = coder.readByte(); colour = (byte) pixel; alpha = coder.readByte(); break;
             case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); alpha = coder.readWord(2, false) &gt;&gt; 8; break;
         }                    
 
@@ -1635,7 +1635,7 @@
         {
             switch (attributes[BIT_DEPTH])
             {
-                case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; break;
+                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
                 case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel &gt;&gt; 8); break;
             }                    
             colorImage[row][col][i] = colour;

Modified: dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSShapeConstructor.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -89,7 +89,7 @@
  *    // calculating the bounding rectangle which must completely enclose
  *    // the shape so it will be drawn correctly.
  *
- *    path.add(new FSSolidLine(1, FSColorTable.black()));
+ *    path.add(new FSLineStyle(1, FSColorTable.black()));
  *    path.add(new FSSolidFill(FSColorTable.red()));
  *
  *    newPath();                   // start a new path
@@ -125,7 +125,7 @@
  *    int height = 100;
  *    int cornerRadius = 10
  *
- *    path.add(new FSSolidLine(1, FSColorTable.black()));
+ *    path.add(new FSLineStyle(1, FSColorTable.black()));
  *    path.add(new FSSolidFill(FSColorTable.red()));
  *
  *    // Create a rectangle with rounded corners.
@@ -190,7 +190,7 @@
     /** Sets the line style at the index in the array of line styles.
 
         @param index the position in the array of line styles.
-        @param aLineStyle and FSSolidLine object.
+        @param aLineStyle and FSLineStyle object.
         @throws ArrayIndexOutOfBounds if the index &lt; 0 or index &gt; array size.
         */
     public void set(int index, FSLineStyle aLineStyle)
@@ -198,9 +198,9 @@
         lineStyles.set(index, aLineStyle);
     }
 
-    /** Add a FSSolidLine object to the array of line styles.
+    /** Add a FSLineStyle object to the array of line styles.
 
-        @param aLineStyle and FSSolidLine object.
+        @param aLineStyle and FSLineStyle object.
         */
     public void add(FSLineStyle aLineStyle)
     {
@@ -271,7 +271,7 @@
      */
     public void selectLineStyle(int index)
     {
-        lineWidth = ((FSSolidLine)lineStyles.get(index)).getWidth();
+        lineWidth = ((FSLineStyle)lineStyles.get(index)).getWidth();
 
         objects.add(new FSShapeStyle(index+1, Transform.VALUE_NOT_SET, Transform.VALUE_NOT_SET));
     }
@@ -307,7 +307,7 @@
      */
     public void selectStyle(int lineIndex, int fillIndex)
     {
-        lineWidth = ((FSSolidLine)lineStyles.get(lineIndex)).getWidth();
+        lineWidth = ((FSLineStyle)lineStyles.get(lineIndex)).getWidth();
         
         objects.add(new FSShapeStyle(lineIndex+1, fillIndex+1, Transform.VALUE_NOT_SET));
     }
@@ -322,7 +322,7 @@
      */
     public void selectStyle(int lineIndex, int fillIndex, int altIndex)
     {
-        lineWidth = ((FSSolidLine)lineStyles.get(lineIndex)).getWidth();
+        lineWidth = ((FSLineStyle)lineStyles.get(lineIndex)).getWidth();
  
         objects.add(new FSShapeStyle(lineIndex+1, fillIndex+1, altIndex+1));
     }

Modified: dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSSoundConstructor.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -452,7 +452,7 @@
 
         for (int i=0; i&lt;4; i++)
         {
-            if (coder.readWord(1, false) != riffSignature[i])
+            if (coder.readByte() != riffSignature[i])
                 throw new DataFormatException(&quot;Not a valid RIFF file&quot;);
         }
         
@@ -460,7 +460,7 @@
         
         for (int i=0; i&lt;4; i++)
         {
-            if (coder.readWord(1, false) != wavSignature[i])
+            if (coder.readByte() != wavSignature[i])
                 throw new DataFormatException(&quot;Not a valid WAV file&quot;);
         }
        
@@ -548,10 +548,10 @@
                 
                 int totalLength = (hasFooter == 1) ? 10 : 0;
 
-                totalLength += coder.readWord(1, false) &lt;&lt; 23;
-                totalLength += coder.readWord(1, false) &lt;&lt; 15;
-                totalLength += coder.readWord(1, false) &lt;&lt; 7;
-                totalLength += coder.readWord(1, false);
+                totalLength += coder.readByte() &lt;&lt; 23;
+                totalLength += coder.readByte() &lt;&lt; 15;
+                totalLength += coder.readByte() &lt;&lt; 7;
+                totalLength += coder.readByte();
 
                 coder.adjustPointer(totalLength&lt;&lt;3);
             }

Modified: dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/util/FSTextConstructor.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1635,7 +1635,7 @@
             {
                 case 0: 
                     for (n=0; n&lt;256; n++)
-                        characterTable[n] = (short)coder.readWord(1, false);
+                        characterTable[n] = (short)coder.readByte();
                     break;
                 case 4:
                     segmentCount = coder.readWord(2, false) / 2;
@@ -1775,7 +1775,7 @@
         int[] instructions = new int[instructionCount];
             
         for (int i=0; i&lt;instructionCount; i++)
-            instructions[i] = coder.readWord(1, false);
+            instructions[i] = coder.readByte();
                 
         int numberOfPoints = (numberOfContours == 0) ? 0 : endPtsOfContours[endPtsOfContours.length-1]+1;
         
@@ -1796,11 +1796,11 @@
             } 
             else 
             {
-                flags[i] = coder.readWord(1, false);
+                flags[i] = coder.readByte();
                     
                 if ((flags[i] &amp; REPEAT_FLAG) &gt; 0) 
                 {
-                    repeatCount = coder.readWord(1, false);
+                    repeatCount = coder.readByte();
                     repeatFlag = flags[i];
                 }
             }
@@ -1814,9 +1814,9 @@
             if ((flags[i] &amp; X_SHORT) &gt; 0) 
             {
                 if ((flags[i] &amp; X_POSITIVE) &gt; 0)
-                    last = xCoordinates[i] = last + coder.readWord(1, false);
+                    last = xCoordinates[i] = last + coder.readByte();
                 else 
-                    last = xCoordinates[i] = last - coder.readWord(1, false);
+                    last = xCoordinates[i] = last - coder.readByte();
             } 
             else 
             {
@@ -1834,9 +1834,9 @@
             if ((flags[i] &amp; Y_SHORT) &gt; 0)
             {
                 if ((flags[i] &amp; Y_POSITIVE) &gt; 0)
-                    last = yCoordinates[i] = last + coder.readWord(1, false);
+                    last = yCoordinates[i] = last + coder.readByte();
                 else 
-                    last = yCoordinates[i] = last - coder.readWord(1, false);
+                    last = yCoordinates[i] = last - coder.readByte();
             } 
             else 
             {
@@ -1991,8 +1991,8 @@
             
             if ((flags &amp; ARG_1_AND_2_ARE_WORDS) == 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) == 0)
             {
-                destIndex = coder.readWord(1, false);
-                sourceIndex = coder.readWord(1, false);
+                destIndex = coder.readByte();
+                sourceIndex = coder.readByte();
                 
                 //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
                 //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
@@ -2000,8 +2000,8 @@
             }
             else if ((flags &amp; ARG_1_AND_2_ARE_WORDS) == 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) &gt; 0)
             {
-                xOffset = (coder.readWord(1, false) &lt;&lt; 24) &gt;&gt; 24;
-                yOffset = (coder.readWord(1, false) &lt;&lt; 24) &gt;&gt; 24;
+                xOffset = (coder.readByte() &lt;&lt; 24) &gt;&gt; 24;
+                yOffset = (coder.readByte() &lt;&lt; 24) &gt;&gt; 24;
                 transform.translate(xOffset, yOffset);
             }
             else if ((flags &amp; ARG_1_AND_2_ARE_WORDS) &gt; 0 &amp;&amp; (flags &amp; ARGS_ARE_XY_VALUES) == 0)

Deleted: dev/dev-2-4/src/com/flagstone/transform/util/TransformUtil.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/util/TransformUtil.java	2008-03-18 22:34:36 UTC (rev 382)
+++ dev/dev-2-4/src/com/flagstone/transform/util/TransformUtil.java	2008-03-19 10:47:20 UTC (rev 383)
@@ -1,98 +0,0 @@
-/*
- *  TransformUtil.java
- *  Transform Utilities
- *
- * Copyright (c) 2001-2008 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.flagstone.transform.util;
-
-/** \mainpage Transform Utilities
- * 
- * The Transform Utilities framework is designed to extend the functionality provided 
- * by the Transform SWF framework and support a higher level interface to reduce the 
- * level of effort required to implement applications that use the Transform SWF 
- * framework.
- *
- * Transform Utilities contains the following classes:
- * 
-\htmlonly
-&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot; border=&quot;0&quot; class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Class&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;FSImageConstructor&lt;/td&gt;&lt;td&gt;Loads JPEG, PNG and BMP format images from files and 
-generates the objects required to display them in a movie. The class provides accessor 
-methods to the image data allowing further processing before generating the Transform 
-object that contain the image data.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr class=&quot;shaded&quot;&gt;&lt;td&gt;FSShapeConstructor&lt;/td&gt;&lt;td&gt;Draws arbitrary complex paths for 
-drawing shapes. The class also supports a number of predefined paths for drawing geometric 
-shapes and polygons. Support for drawing cubic Bezier curves is provided so the class 
-provides a comprehensive API for integration into any 2-D graphics application.&lt;/td&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;FSSoundConstructor&lt;/td&gt;&lt;td&gt;Generates the Transform SWF objects required to play 
-sounds played in response to events and to stream sounds so soundtracks can be added to 
-movies. Sound files containing WAVE and MP3 are supported. As with the FSImageConstructor 
-class accessor methods are provided to allow the sound samples to be processed before the 
-Transform SWF objects are generated. See also 
-&lt;a href=&quot;<A HREF="http://www.flagstonesoftware.com/usefulcode.html">http://www.flagstonesoftware.com/usefulcode.html</A>&quot;&gt;Useful Code&lt;/a&gt;
-for code to compress PCM encoded sounds to the ADPCM format.&lt;/td&gt;&lt;/tr&gt;
-
-&lt;tr class=&quot;shaded&quot;&gt;&lt;td&gt;FSTextConstructor&lt;/td&gt;&lt;td&gt;Used to generate font definitions and 
-create strings that are displayed in Flash files. Font definitions may be created from 
-an existing Flash file or an OpenType/TrueType font file. The Java version of the framework 
-also allows fonts to be created from AWT font classes. Text objects used to define single 
-strings or blocks of text can be generated from the font definition. The FSTextConstructor 
-tracks the string generated so, if required, the font definition object generated only 
-contains the glyphs used, greatly reducing the size of the Flash file generated.&lt;/td&gt;&lt;/tr&gt;
-
-&lt;/table&gt;
-&lt;p&gt;&lt;/P&gt;
-\endhtmlonly
- * 
- * @deprecated No longer used with the merging of Transform Utilties into the 
- * main Transform SWF distribution.
- */
-public class TransformUtil 
-{
-    // Package information  
-    static final boolean DebugEdition = false;
-
-    /** 
-     * MAJOR is used to identify the current version of the framework. This
-     * is incremented for each new version of Flash supported.
-     */
-    public static final int MAJOR = 1;
-    /** 
-     * MINOR is used to identify the current minor version of the framework. This
-     * is incremented when new functionality is added or API changes are made.
-     */
-    public static final int MINOR = 1;
-    /** 
-     * The RELEASE number is used to differentiate between different releases. 
-     * This number is incremented when an enhancement or bug fix has been made 
-     * and the API is unchanged.
-     */
-    public static final int RELEASE = 2;
-}
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000318.html">[Transform-svn] r382 - dev/dev-2-4/src/com/flagstone/transform
</A></li>
	<LI>Next message: <A HREF="000320.html">[Transform-svn] r384 - in dev/dev-2-4/src/com/flagstone/transform:	. test util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#319">[ date ]</a>
              <a href="thread.html#319">[ thread ]</a>
              <a href="subject.html#319">[ subject ]</a>
              <a href="author.html#319">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/transform-svn">More information about the Transform-svn
mailing list</a><br>
</body></html>
