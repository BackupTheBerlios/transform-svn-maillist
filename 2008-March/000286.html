<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Transform-svn] r350 - dev/dev-2-4/src/com/flagstone/transform
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/transform-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r350%20-%20dev/dev-2-4/src/com/flagstone/transform&In-Reply-To=%3C200803181134.m2IBY0JJ023575%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000285.html">
   <LINK REL="Next"  HREF="000287.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Transform-svn] r350 - dev/dev-2-4/src/com/flagstone/transform</H1>
    <B>smackay at mail.berlios.de</B> 
    <A HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r350%20-%20dev/dev-2-4/src/com/flagstone/transform&In-Reply-To=%3C200803181134.m2IBY0JJ023575%40sheep.berlios.de%3E"
       TITLE="[Transform-svn] r350 - dev/dev-2-4/src/com/flagstone/transform">smackay at mail.berlios.de
       </A><BR>
    <I>Tue Mar 18 12:34:00 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000285.html">[Transform-svn] r349 - dev/dev-2-4/src/com/flagstone/transform
</A></li>
        <LI>Next message: <A HREF="000287.html">[Transform-svn] r351 - dev/dev-2-4/src/com/flagstone/transform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#286">[ date ]</a>
              <a href="thread.html#286">[ thread ]</a>
              <a href="subject.html#286">[ subject ]</a>
              <a href="author.html#286">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: smackay
Date: 2008-03-18 12:33:47 +0100 (Tue, 18 Mar 2008)
New Revision: 350

Modified:
   dev/dev-2-4/src/com/flagstone/transform/FSCoordTransform.java
Log:
Updated to use new interfaces.

Modified: dev/dev-2-4/src/com/flagstone/transform/FSCoordTransform.java
===================================================================
--- dev/dev-2-4/src/com/flagstone/transform/FSCoordTransform.java	2008-03-18 11:13:31 UTC (rev 349)
+++ dev/dev-2-4/src/com/flagstone/transform/FSCoordTransform.java	2008-03-18 11:33:47 UTC (rev 350)
@@ -31,518 +31,654 @@
 package com.flagstone.transform;
 
 /**
-FSCoordTransform is used to specify two-dimensional coordinate transforms, allowing an 
-object to be scaled, rotated or moved without changing the original definition of how 
-the object is drawn.
- 
-&lt;p&gt;A two-dimensional transform is defined using a 3x3 matrix and the new values for a pair of coordinates (x,y) are calculated using the following matrix multiplication:&lt;/p&gt;
+ * FSCoordTransform is used to specify two-dimensional coordinate transforms,
+ * allowing an object to be scaled, rotated or moved without changing the
+ * original definition of how the object is drawn.
+ * 
+ * &lt;p&gt;
+ * A two-dimensional transform is defined using a 3x3 matrix and the new values
+ * for a pair of coordinates (x,y) are calculated using the following matrix
+ * multiplication:
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/transform.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * Different transformations such as scaling, rotation, shearing and translation
+ * can be performed using the above matrix multiplication. More complex
+ * transformations can be defined by performing successive matrix
+ * multiplications in a process known as compositing. This allows a complex
+ * transformations to performed on an object.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform contains a 3x3 array for defining the transformations.
+ * However when it is encoded the matrix is reduced to the following set
+ * attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;scaleX&lt;/td&gt;
+ * &lt;td&gt;The value to scale the shape in the x direction combined with the cosine
+ * component of any rotation.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;scaleY&lt;/td&gt;
+ * &lt;td&gt;The value to scale the shape in the x direction combined with the cosine
+ * component of any rotation.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;rotate0&lt;/td&gt;
+ * &lt;td&gt;The sine component of any rotation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;rotate1&lt;/td&gt;
+ * &lt;td&gt;The negative sine component of any rotation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;translateX&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of any translation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;translateY&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of any translation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h2 class=&quot;datasheet&quot;&gt;Examples&lt;/h2&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform provides a set of methods for generating the matrices
+ * that will perform specific transformations. Methods are provided that
+ * represent matrices for performing translation, scaling, rotation and shearing
+ * transformations.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform = new FSCoordTransform();
+ * 
+ * transform.scale(2.0, 2.0); // scale(x,y)
+ * transform.rotate(30.0); // rotate(degrees)
+ * transform.shear(1.2, 0.9); // shear(x, y)
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The composite method can be used to multiply two matrices together to create
+ * complex transformations though successive compositing steps. For example to
+ * place a new object on the screen first rotating it by 30 degrees and scaling
+ * it to twice its original size the required transform can be constructed using
+ * the following steps:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSCoordTransform transform = new FSCoordTranform();
+ * 
+ *  transform.scale(2.0, 2.0);
+ *  transform.rotate(30.0);
+ * 
+ *  int layer = 1;
+ *  int identifier = movie.newIdentifier();
+ * 
+ *  FSDefineShape shape = new FSDefineShape(identifier, ...);
+ * 
+ *  FSPlaceObject2 placeShape = new FSPlaceObject2(identifier, layer, transform);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Compositing transforms are not commutative, the order in which
+ * transformations are applied will affect the final result. For example
+ * consider the following pair if transforms:
+ * &lt;/p&gt;
+ * 
+ * FSCoordTransform transform = new FSCoordTransform();
+ * 
+ * transform.translate(100, 100); transform.scale(2.0, 2.0);
+ * 
+ * &lt;p&gt;
+ * The composite transform places an object at the coordinates (100,100) then
+ * scales it to twice its original size. If the transform was composited in the
+ * opposite order:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform transform = new FSCoordTransform();
+ * 
+ * transform.scale(2.0, 2.0);
+ * transform.translate(100, 100);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Then the coordinates for the object's location would also be scaled, placing
+ * the object at (200,200).
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Arbitrary coordinate transforms are created by specifying the 3 by 3 array of
+ * floating-point values in the constructor:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * float[][] matrix = new float[][]
+ * {
+ * 	{
+ * 		0.923f, 0.321f, 1000.0f },
+ * 	{
+ * 		0.868f, 0.235f, 1000.0f },
+ * 	{
+ * 		0.000f, 0.000f, 1.0000f } };
+ * 
+ * FSCoordTransform transform = new FSCoordTransform(matrix);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * A constructor is also provided to handle the most common composite transform -
+ * scaling and translating an object at the same time:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform composite = new FSCoordTransform(100, 150, 2.0, 2.0);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Will place the object at the twip coordinates (100, 150) and scale the object
+ * to twice its original size.
+ * &lt;/P&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform class represents the Matrix data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSCoordTransform implements Cloneable, Codeable
+{
+	private float[][] matrix = new float[][] {
+		{1.0f, 0.0f, 0.0f },
+		{0.0f, 1.0f, 0.0f },
+		{0.0f, 0.0f, 1.0f } 
+	};
 
-&lt;img src=&quot;doc-files/transform.gif&quot;&gt;
+	/**
+	 * Construct an FSCoordTransform object and initialise it with values
+	 * decoded from a binary encoded FSCoordTransform object.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSColor encoded as binary
+	 *            data.
+	 */
+	public FSCoordTransform(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;p&gt;Different transformations such as scaling, rotation, shearing and translation can be performed using the above matrix multiplication. More complex transformations can be defined by performing successive matrix multiplications in a process known as compositing. This allows a complex transformations to performed on an object.&lt;/p&gt;
+	/**
+	 * Constructs an FSCoordTransform object defining a unity transform. If the
+	 * transform is applied to a shape its location or appearance will not
+	 * change.
+	 */
+	public FSCoordTransform()
+	{
+	}
 
-&lt;p&gt;The FSCoordTransform contains a 3x3 array for defining the transformations. However when it is encoded the matrix is reduced to the following set attributes:&lt;/p&gt;
+	/**
+	 * Constructs an FSCoordTransform object defining a translation transform
+	 * that will change an objects location to the specified coordinates.
+	 * 
+	 * @param x
+	 *            the x-coordinate where the object will be displayed.
+	 * @param y
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSCoordTransform(int x, int y)
+	{
+		matrix[0][2] = (float) x;
+		matrix[1][2] = (float) y;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSCoordTransform object defining translation and scaling
+	 * transforms that will change an object's location and size.
+	 * 
+	 * @param x
+	 *            the x-coordinate where the object will be displayed.
+	 * @param y
+	 *            the y-coordinate where the object will be displayed.
+	 * @param scaleX
+	 *            value to scale the object in the x direction.
+	 * @param scaleY
+	 *            value to scale the object in the y direction.
+	 */
+	public FSCoordTransform(int x, int y, double scaleX, double scaleY)
+	{
+		matrix[0][0] = (float) scaleX;
+		matrix[1][1] = (float) scaleY;
+		matrix[0][2] = (float) x;
+		matrix[1][2] = (float) y;
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSCoordTransform object with the specified transformation
+	 * matrix.
+	 * 
+	 * @param aMatrix
+	 *            a 3x3 array of floats containing the values defining the
+	 *            transform.
+	 */
+	public FSCoordTransform(float[][] aMatrix)
+	{
+		for (int i = 0; i &lt; 3; i++)
+			for (int j = 0; j &lt; 3; j++)
+				matrix[i][j] = aMatrix[i][j];
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_0&quot;&gt;scaleX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The value to scale the shape in the x direction combined with the cosine 
-component of any rotation.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSCoordTransform object by copying an existing object.
+	 */
+	public FSCoordTransform(FSCoordTransform obj)
+	{
+		for (int i = 0; i &lt; 3; i++)
+			for (int j = 0; j &lt; 3; j++)
+				matrix[i][j] = obj.matrix[i][j];
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_1&quot;&gt;scaleY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The value to scale the shape in the x direction combined with the cosine 
-component of any rotation.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the translation points of the transform.
+	 * 
+	 * @param x
+	 *            the x-coordinate where the object will be displayed.
+	 * @param y
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public void translate(int x, int y)
+	{
+		float[][] m = new float[][] {
+			{1.0f, 0.0f, (float) x },
+			{0.0f, 1.0f, (float) y },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_2&quot;&gt;rotate0&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sine component of any rotation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		composite(m);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_3&quot;&gt;rotate1&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The negative sine component of any rotation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the scaling factor for the transform.
+	 * 
+	 * @param x
+	 *            value to scale the object in the x direction.
+	 * @param y
+	 *            value to scale the object in the y direction.
+	 */
+	public void scale(double x, double y)
+	{
+		float[][] m = new float[][] {
+			{(float) x, 0.0f, 0.0f },
+			{0.0f, (float) y, 0.0f },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_4&quot;&gt;translateX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of any translation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		composite(m);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_5&quot;&gt;translateY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of any translation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the angle which the transform will rotate an object.
+	 * 
+	 * @param angle
+	 *            value, in degrees, to rotate the object clockwise.
+	 */
+	public void rotate(double angle)
+	{
+		float[][] m = new float[][] {
+			{1.0f, 0.0f, 0.0f },
+			{0.0f, 1.0f, 0.0f },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;/table&gt;
+		m[0][0] = (float) Math.cos(Math.toRadians(angle));
+		m[0][1] = -(float) Math.sin(Math.toRadians(angle));
+		m[1][0] = (float) Math.sin(Math.toRadians(angle));
+		m[1][1] = (float) Math.cos(Math.toRadians(angle));
 
-&lt;h2 class=&quot;datasheet&quot;&gt;Examples&lt;/h2&gt;
+		composite(m);
+	}
 
-&lt;p&gt;The FSCoordTransform provides a set of methods for generating the matrices that will perform specific transformations. Methods are provided that represent matrices for performing translation, scaling, rotation and shearing transformations.&lt;/p&gt;
+	/**
+	 * Sets the shearing factor for the transform.
+	 * 
+	 * @param x
+	 *            value to shear the object in the x direction.
+	 * @param y
+	 *            value to shear the object in the y direction.
+	 */
+	public void shear(double x, double y)
+	{
+		float[][] m = new float[][] {
+			{1.0f, (float) y, 0.0f },
+			{(float) x, 1.0f, 0.0f },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;pre&gt;
-FSCoordTransform = new FSCoordTransform();
+		composite(m);
+	}
 
-transform.scale(2.0, 2.0); // scale(x,y)
-transform.rotate(30.0);  // rotate(degrees)
-transform.shear(1.2, 0.9);  // shear(x, y)
-&lt;/pre&gt;
+	/**
+	 * Applies the transformation to the coordinates of a point.
+	 * 
+	 * @param x
+	 *            x-coordinate of a point.
+	 * @param y
+	 *            x-coordinate of a point.
+	 * @return an array containing the transformed point.
+	 */
+	public int[] transformPoint(int x, int y)
+	{
+		float[] point = new float[] { (float) x, (float) y, 1.0f };
+		int[] result = new int[2];
 
-&lt;p&gt;The composite method can be used to multiply two matrices together to create complex transformations though successive compositing steps. For example to place a new object on the screen first rotating it by 30 degrees and scaling it to twice its original size the required transform can be constructed using the following steps:&lt;/p&gt;
+		result[0] = (int) (matrix[0][0] * point[0] + matrix[0][1] * point[1] + matrix[0][2]
+						* point[2]);
+		result[1] = (int) (matrix[1][0] * point[0] + matrix[1][1] * point[1] + matrix[1][2]
+						* point[2]);
 
-&lt;pre&gt;
-FSCoordTransform transform = new FSCoordTranform();
+		return result;
+	}
 
-transform.scale(2.0, 2.0);
-transform.rotate(30.0);
+	/**
+	 * Gets the 3 X 3 array that is used to store the transformation values.
+	 * 
+	 * @return an array, float[3][3], containing the values for the
+	 *         transformation matrix.
+	 */
+	public float[][] getMatrix()
+	{
+		return matrix;
+	}
 
-int layer = 1;
-int identifier = movie.newIdentifier();
+	/**
+	 * Sets the values in the 3 X 3 array that is used to store the
+	 * transformation values.
+	 * 
+	 * @param aMatrix
+	 *            a 3x3 array of floats containing the values defining the
+	 *            transform.
+	 */
+	public void setMatrix(float[][] aMatrix)
+	{
+		for (int i = 0; i &lt; 3; i++)
+			for (int j = 0; j &lt; 3; j++)
+				matrix[i][j] = aMatrix[i][j];
+	}
 
-FSDefineShape shape = new FSDefineShape(identifier, ...);
+	/**
+	 * Composite the 3 X 3 matrix with the FSCoordTransform argument. This
+	 * method is used to create multiple transformation effects that can be
+	 * applied to an object in a single step. Using the instance method fixes
+	 * the order in which the transforms are composited. Since matrix
+	 * multiplication is not commutative this limits the number of complex
+	 * transforms that can be generated when compared to the class method.
+	 * 
+	 * @param transform
+	 *            an FSCoordTransform object to composite with this instance.
+	 */
+	public void composite(FSCoordTransform transform)
+	{
+		composite(transform.getMatrix());
+	}
 
-FSPlaceObject2 placeShape = new FSPlaceObject2(identifier, layer, transform);
-&lt;/pre&gt;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @param obj
+	 *            the reference object with which to compare.
+	 *            
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object obj)
+	{
+		boolean result = false;
 
-&lt;p&gt;Compositing transforms are not commutative, the order in which transformations are applied will affect the final result. For example consider the following pair if transforms:&lt;/p&gt;
+		if (obj == null) {
+			return false;
+		}
 
-FSCoordTransform transform = new FSCoordTransform();
+		if (obj == this) {
+			return true;
+		}
 
-transform.translate(100, 100);
-transform.scale(2.0, 2.0);
+		if (obj instanceof FSCoordTransform)
+		{
+			float m[][] = ((FSCoordTransform) obj).matrix;
+			result = true;
 
-&lt;p&gt;The composite transform places an object at the coordinates (100,100) then scales it to twice its original size. If the transform was composited in the opposite order:&lt;/p&gt;
+			for (int i = 0; i &lt; 3; i++)
+				for (int j = 0; j &lt; 3; j++)
+					if (matrix[i][j] != m[i][j])
+						result = false;
+		}
+		return result;
+	}
 
-&lt;pre&gt;
-FSCoordTransform transform = new FSCoordTransform();
+	/**
+	 * Creates a copy of the entire object.
+	 * 
+	 * @return a copy of the object.
+	 */
+	public Object clone()
+	{
+		Object anObject = null;
 
-transform.scale(2.0, 2.0);
-transform.translate(100, 100);
-&lt;/pre&gt;     
+		try {
+			anObject = super.clone();
+		} 
+		catch (CloneNotSupportedException e) {
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-&lt;p&gt;Then the coordinates for the object's location would also be scaled, placing the object at (200,200).&lt;/p&gt;
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
 
-&lt;p&gt;Arbitrary coordinate transforms are created by specifying the 3 by 3 array of floating-point values in the constructor:&lt;/p&gt;
+		buffer.append(&quot;FSCoordTransform: { [&quot;);
+		buffer.append(&quot;[&quot; + matrix[0][0] + &quot;, &quot; + matrix[0][1] + &quot;, &quot;
+						+ matrix[0][2] + &quot;], &quot;);
+		buffer.append(&quot;[&quot; + matrix[1][0] + &quot;, &quot; + matrix[1][1] + &quot;, &quot;
+						+ matrix[1][2] + &quot;], &quot;);
+		buffer.append(&quot;[&quot; + matrix[2][0] + &quot;, &quot; + matrix[2][1] + &quot;, &quot;
+						+ matrix[2][2] + &quot;] &quot;);
+		buffer.append(&quot;]; }&quot;);
 
-&lt;pre&gt;
-float[][] matrix = new float[][] {
-    {0.923f, 0.321f, 1000.0f}, 
-    {0.868f, 0.235f, 1000.0f}, 
-    {0.000f, 0.000f, 1.0000f}
-};
+		return buffer.toString();
+	}
 
-FSCoordTransform transform = new FSCoordTransform(matrix);
-&lt;/pre&gt;
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 14; // include 7 bits for byte alignment
+		
+		numberOfBits += translateFieldSize() * 2;
+		
+		if (containsScaling())
+			numberOfBits += 5 + scaleFieldSize() * 2;
 
-&lt;p&gt;A constructor is also provided to handle the most common composite transform - scaling and translating an object at the same time:&lt;/p&gt;
+		if (containsRotation())
+			numberOfBits += 5 + rotateFieldSize() * 2;
 
-&lt;pre&gt;
-FSCoordTransform composite = new FSCoordTransform(100, 150, 2.0, 2.0);
-&lt;/pre&gt;
+		return numberOfBits &gt;&gt; 3;
+	}
 
-&lt;p&gt;Will place the object at the twip coordinates (100, 150) and scale the object to twice its original size.&lt;/P&gt;
+	public void encode(FSCoder coder)
+	{
+		int translateBits = translateFieldSize();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		coder.alignToByte();
 
-&lt;p&gt;The FSCoordTransform class represents the Matrix data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSCoordTransform extends FSTransformObject
-{
-    private float[][] matrix = new float[][] { 
-        {1.0f, 0.0f, 0.0f}, 
-        {0.0f, 1.0f, 0.0f}, 
-        {0.0f, 0.0f, 1.0f} 
-    };
+		coder.writeBits(containsScaling() ? 1 : 0, 1);
 
-    /**
-     * Construct an FSCoordTransform object and initialize it with values decoded 
-     * from a binary encoded FSCoordTransform object.
-     * 
-     * @param coder an FSCoder object containing an FSColor encoded as binary
-     * data.
-     */
-    public FSCoordTransform(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSCoordTransform object defining a unity transform. If the 
-     * transform is applied to a shape its location or appearance will not change.
-     */
-    public FSCoordTransform()
-    {
-    }  
-    /** 
-     * Constructs an FSCoordTransform object defining a translation transform 
-     * that will change an objects location to the specified coordinates. 
-     * 
-     * @param x the x-coordinate where the object will be displayed.
-     * @param y the y-coordinate where the object will be displayed.
-     */
-    public FSCoordTransform(int x, int y)
-    {
-        float xValue = (float)x;
-        float yValue = (float)y;
+		if (containsScaling())
+		{
+			int scaleBits = scaleFieldSize();
 
-        matrix[0][2] = xValue;
-        matrix[1][2] = yValue;
-    }
-    /** 
-     * Constructs an FSCoordTransform object defining translation and scaling transforms
-     * that will change an object's location and size.
-    
-        @param x the x-coordinate where the object will be displayed.
-        @param y the y-coordinate where the object will be displayed.
-        @param scaleX value to scale the object in the x direction.
-        @param scaleY value to scale the object in the y direction.
-        */
-    public FSCoordTransform(int x, int y, double scaleX, double scaleY)
-    {
-        matrix[0][0] = (float)scaleX;
-        matrix[1][1] = (float)scaleY;
-        matrix[0][2] = (float)x;
-        matrix[1][2] = (float)y;
-    }
+			coder.writeBits(scaleBits, 5);
+			coder.writeFixedBits(matrix[0][0], scaleBits, 16);
+			coder.writeFixedBits(matrix[1][1], scaleBits, 16);
+		}
 
-    /** Constructs an FSCoordTransform object with the specified transformation matrix.
-    
-        @param aMatrix a 3x3 array of floats containing the values defining the transform.
-        */
-    public FSCoordTransform(float[][] aMatrix)
-    {
-        setMatrix(aMatrix);
-    }
-    /**
-     * Construct an FSCoordTransform object by copying an existing object.
-     */
-    public FSCoordTransform(FSCoordTransform obj)
-    {
-        for(int i=0; i&lt;3; i++)
-            for (int j = 0; j&lt;3; j++)
-                matrix[i][j] = obj.matrix[i][j];
-    }
-    
-    /** Sets the translation points of the transform.
-     * 
-     * @param x the x-coordinate where the object will be displayed.
-     * @param y the y-coordinate where the object will be displayed.
-     */
-    public void translate(int x, int y)
-    {
-        float[][] m = new float[][] { 
-            {1.0f, 0.0f, (float)x}, 
-            {0.0f, 1.0f, (float)y}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        composite(m);
-    }
+		coder.writeBits(containsRotation() ? 1 : 0, 1);
 
-    /** Sets the scaling factor for the transform.
-     * 
-     * @param x value to scale the object in the x direction.
-     * @param y value to scale the object in the y direction.
-     */
-    public void scale(double x, double y)
-    {
-        float[][] m = new float[][] { 
-            {(float)x, 0.0f, 0.0f}, 
-            {0.0f, (float)y, 0.0f}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        composite(m);
-    }
+		if (containsRotation())
+		{
+			int rotateBits = rotateFieldSize();
 
-    /** Sets the angle which the transform will rotate an object.
-     * 
-     * @param angle value, in degrees, to rotate the object clockwise.
-     */
-    public void rotate(double angle)
-    {
-        float[][] m = new float[][] { 
-            {1.0f, 0.0f, 0.0f}, 
-            {0.0f, 1.0f, 0.0f}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        m[0][0] = (float)Math.cos(Math.toRadians(angle));
-        m[0][1] = -(float)Math.sin(Math.toRadians(angle));
-        m[1][0] = (float)Math.sin(Math.toRadians(angle));
-        m[1][1] = (float)Math.cos(Math.toRadians(angle));
+			coder.writeBits(rotateBits, 5);
+			coder.writeFixedBits(matrix[1][0], rotateBits, 16);
+			coder.writeFixedBits(matrix[0][1], rotateBits, 16);
+		}
+		coder.writeBits(translateBits, 5);
+		coder.writeBits((int) matrix[0][2], translateBits);
+		coder.writeBits((int) matrix[1][2], translateBits);
 
-        composite(m);
-    }
+		coder.alignToByte();
+	}
 
-    /** Sets the shearing factor for the transform.
-     * 
-     * @param x value to shear the object in the x direction.
-     * @param y value to shear the object in the y direction.
-     */
-    public void shear(double x, double y)
-    {
-        float[][] m = new float[][] { 
-            {1.0f, (float)y, 0.0f}, 
-            {(float)x, 1.0f, 0.0f}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        composite(m);
-    }
+	public void decode(FSCoder coder)
+	{
+		int scaleFieldSize = 0;
+		int rotateFieldSize = 0;
+		int translateFieldSize = 0;
 
-    /**
-     * Applies the transformation to the coordinates of a point.
-     * 
-     * @param x x-coordinate of a point.
-     * @param y x-coordinate of a point.
-     * @return an array containing the transformed point.
-     */
-    public int[] transformPoint(int x, int y)
-    {
-        float[] point = new float[] { (float)x, (float)y, 1.0f };
-        int[] result = new int[2];
-        
-        result[0] = (int)(matrix[0][0] * point[0] +  matrix[0][1] * point[1] +  matrix[0][2] * point[2]);
-        result[1] = (int)(matrix[1][0] * point[0] +  matrix[1][1] * point[1] +  matrix[1][2] * point[2]);
-        
-        return result;
-    }
+		coder.alignToByte();
 
-    /** Gets the 3 X 3 array that is used to store the transformation values.
-    
-        @return an array, float[3][3], containing the values for the transformation matrix.
-        */
-    public float[][] getMatrix()
-    {
-        return matrix;
-    }
+		boolean _containsScaling = coder.readBits(1, false) != 0 ? true : false;
 
-    /** Sets the values in the 3 X 3 array that is used to store the transformation values. 
-    
-        @param aMatrix a 3x3 array of floats containing the values defining the transform.
-        */
-    public void setMatrix(float[][] aMatrix)
-    {
-        for(int i=0; i&lt;3; i++)
-            for (int j = 0; j&lt;3; j++)
-                matrix[i][j] = aMatrix[i][j];
-    }
+		if (_containsScaling)
+		{
+			scaleFieldSize = coder.readBits(5, false);
+			matrix[0][0] = coder.readFixedBits(scaleFieldSize, 16);
+			matrix[1][1] = coder.readFixedBits(scaleFieldSize, 16);
+		}
 
-    /** Composite the 3 X 3 matrix with the FSCoordTransform argument. This method is used to create multiple transformation effects that can be applied to an object in a single step. Using the instance method fixes the order in which the transforms are composited. Since matrix multiplication is not commutative this limits the number of complex transforms that can be generated when compared to the class method.
+		boolean _containsRotation = coder.readBits(1, false) != 0 ? true
+						: false;
 
-        @param transform an FSCoordTransform object to composite with this instance.
-        */
-    public void composite(FSCoordTransform transform)
-    {
-        composite(transform.getMatrix());
-    }
+		if (_containsRotation)
+		{
+			rotateFieldSize = coder.readBits(5, false);
+			matrix[1][0] = coder.readFixedBits(rotateFieldSize, 16);
+			matrix[0][1] = coder.readFixedBits(rotateFieldSize, 16);
+		}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSCoordTransform typedObject = (FSCoordTransform)anObject;
-            float m[][] = typedObject.matrix;
-            
-            result = true;
-            
-            for(int i=0; i&lt;3; i++)
-                for (int j=0; j&lt;3; j++)
-                    if (matrix[i][j] != m[i][j])
-                        result = false;
-        }
-        return result;
-    }
+		translateFieldSize = coder.readBits(5, false);
+		matrix[0][2] = (float) coder.readBits(translateFieldSize, true);
+		matrix[1][2] = (float) coder.readBits(translateFieldSize, true);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		coder.alignToByte();
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            buffer.append(&quot;[ &quot;);
-            buffer.append(&quot;[&quot; + matrix[0][0] + &quot;, &quot; + matrix[0][1] + &quot;, &quot; + matrix[0][2] + &quot;], &quot;);
-            buffer.append(&quot;[&quot; + matrix[1][0] + &quot;, &quot; + matrix[1][1] + &quot;, &quot; + matrix[1][2] + &quot;], &quot;);
-            buffer.append(&quot;[&quot; + matrix[2][0] + &quot;, &quot; + matrix[2][1] + &quot;, &quot; + matrix[2][2] + &quot;] &quot;);
-            buffer.append(&quot;]; &quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	/**
+	 * Returns true if the values in the transformation matrix represent a unity
+	 * transform - one which will not change the physical appearance or location
+	 * of a shape.
+	 * 
+	 * @return true if the object represents a unity transform, false otherwise.
+	 */
+	public boolean isUnityTransform()
+	{
+		return !(containsScaling() || containsRotation() || containsTranslation());
+	}
 
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 7 + translateFieldSize()*2;
-    
-        if (containsScaling())
-            numberOfBits += 5 + scaleFieldSize()*2;
-    
-        if (containsRotation())
-            numberOfBits += 5 + rotateFieldSize()*2;
-    
-        numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
-    
-        return numberOfBits&gt;&gt;3;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int translateBits = translateFieldSize();
-        
-        coder.alignToByte();
-    
-        coder.writeBits(containsScaling() ? 1 : 0, 1);
-    
-        if (containsScaling())
-        {
-            int scaleBits = scaleFieldSize();
-            
-            coder.writeBits(scaleBits, 5);
-            coder.writeFixedBits(matrix[0][0], scaleBits, 16);
-            coder.writeFixedBits(matrix[1][1], scaleBits, 16);
-        }
-    
-        coder.writeBits(containsRotation() ? 1 : 0, 1);
-    
-        if (containsRotation())
-        {
-            int rotateBits = rotateFieldSize();
-            
-            coder.writeBits(rotateBits, 5);
-            coder.writeFixedBits(matrix[1][0], rotateBits, 16);
-            coder.writeFixedBits(matrix[0][1], rotateBits, 16);
-        }
-        coder.writeBits(translateBits, 5);
-        coder.writeBits((int)matrix[0][2], translateBits);
-        coder.writeBits((int)matrix[1][2], translateBits);
-    
-        coder.alignToByte();
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int scaleFieldSize = 0;
-        int rotateFieldSize = 0;
-        int translateFieldSize = 0;
-    
-        coder.alignToByte();
+	private boolean containsScaling()
+	{
+		return matrix[0][0] != 1.0f || matrix[1][1] != 1.0f;
+	}
 
-        boolean _containsScaling = coder.readBits(1, false) != 0 ? true : false;
-            
-        if (_containsScaling)
-        {
-            scaleFieldSize = coder.readBits(5, false);
-            matrix[0][0] = coder.readFixedBits(scaleFieldSize, 16);
-            matrix[1][1] = coder.readFixedBits(scaleFieldSize, 16);
-        }
-    
-        boolean _containsRotation = coder.readBits(1, false) != 0 ? true : false;
-        
-        if (_containsRotation)
-        {
-            rotateFieldSize = coder.readBits(5, false);
-            matrix[1][0] = coder.readFixedBits(rotateFieldSize, 16);
-            matrix[0][1] = coder.readFixedBits(rotateFieldSize, 16);
-        }
-    
-        translateFieldSize = coder.readBits(5, false);
-        matrix[0][2] = (float)coder.readBits(translateFieldSize, true);
-        matrix[1][2] = (float)coder.readBits(translateFieldSize, true);
-        
-        coder.alignToByte();
-    }
+	private boolean containsRotation()
+	{
+		return matrix[1][0] != 0.0f || matrix[0][1] != 0.0f;
+	}
 
-    /** Returns true if the values in the transformation matrix represent a unity transform - one which will not change the physical appearance or location of a shape.
+	private boolean containsTranslation()
+	{
+		return matrix[0][2] != 0.0f || matrix[1][2] != 0.0f;
+	}
 
-        @return true if the object represents a unity transform, false otherwise.
-        */
-    public boolean isUnityTransform()
-    {
-        return ! (containsScaling() || containsRotation() || containsTranslation());
-    }
-    
-    private boolean containsScaling() 
-    { 
-        return matrix[0][0] != 1.0f || matrix[1][1] != 1.0f;
-    }
-     
-    private boolean containsRotation() 
-    {
-        return matrix[1][0] != 0.0f || matrix[0][1] != 0.0f;
-    } 
+	private int scaleFieldSize()
+	{
+		int size = 0;
 
-    private boolean containsTranslation()
-    {
-        return matrix[0][2] != 0.0f || matrix[1][2] != 0.0f;
-    }
+		if (isUnityTransform() == false)
+			size = FSCoder.fixedSize(new float[] { matrix[0][0], matrix[1][1] });
 
-    private int scaleFieldSize() 
-    {
-        int size = 0;
-        
-        if (isUnityTransform() == false)
-            size = FSCoder.fixedSize(new float[] {matrix[0][0], matrix[1][1]});
-        
-        return size;
-    }
+		return size;
+	}
 
-    private int rotateFieldSize()
-    {
-        int size = FSCoder.fixedSize(new float[] {matrix[1][0], matrix[0][1]});
-        
-        return size;
-    }
+	private int rotateFieldSize()
+	{
+		int size = FSCoder.fixedSize(new float[] { matrix[1][0], matrix[0][1] });
 
-    private int translateFieldSize()
-    {
-        int size = 0;
-        
-        if (containsTranslation())
-            size = FSCoder.size(new int[] {(int)matrix[0][2], (int)matrix[1][2]}, true);
+		return size;
+	}
 
-        return size;
-    }
-    
-    private void composite(float[][] m)
-    {
-        float result[][] = new float[3][3];
-                   
-        result[0][0] = matrix[0][0] * m[0][0] + matrix[0][1] * m[1][0] + matrix[0][2] * m[2][0];
-        result[0][1] = matrix[0][0] * m[0][1] + matrix[0][1] * m[1][1] + matrix[0][2] * m[2][1];
-        result[0][2] = matrix[0][0] * m[0][2] + matrix[0][1] * m[1][2] + matrix[0][2] * m[2][2];
+	private int translateFieldSize()
+	{
+		int size = 0;
 
-        result[1][0] = matrix[1][0] * m[0][0] + matrix[1][1] * m[1][0] + matrix[1][2] * m[2][0];
-        result[1][1] = matrix[1][0] * m[0][1] + matrix[1][1] * m[1][1] + matrix[1][2] * m[2][1];
-        result[1][2] = matrix[1][0] * m[0][2] + matrix[1][1] * m[1][2] + matrix[1][2] * m[2][2];
+		if (containsTranslation())
+			size = FSCoder.size(new int[] { (int) matrix[0][2], (int) matrix[1][2] }, true);
 
-        result[2][0] = matrix[2][0] * m[0][0] + matrix[2][1] * m[1][0] + matrix[2][2] * m[2][0];
-        result[2][1] = matrix[2][0] * m[0][1] + matrix[2][1] * m[1][1] + matrix[2][2] * m[2][1];
-        result[2][2] = matrix[2][0] * m[0][2] + matrix[2][1] * m[1][2] + matrix[2][2] * m[2][2];
-       
-        matrix[0][0] = result[0][0];
-        matrix[0][1] = result[0][1];
-        matrix[0][2] = result[0][2];
+		return size;
+	}
 
-        matrix[1][0] = result[1][0];
-        matrix[1][1] = result[1][1];
-        matrix[1][2] = result[1][2];
+	private void composite(float[][] m)
+	{
+		float result[][] = new float[3][3];
 
-        matrix[2][0] = result[2][0];
-        matrix[2][1] = result[2][1];
-        matrix[2][2] = result[2][2];
-    }
+		result[0][0] = matrix[0][0] * m[0][0] + matrix[0][1] * m[1][0]
+						+ matrix[0][2] * m[2][0];
+		result[0][1] = matrix[0][0] * m[0][1] + matrix[0][1] * m[1][1]
+						+ matrix[0][2] * m[2][1];
+		result[0][2] = matrix[0][0] * m[0][2] + matrix[0][1] * m[1][2]
+						+ matrix[0][2] * m[2][2];
+
+		result[1][0] = matrix[1][0] * m[0][0] + matrix[1][1] * m[1][0]
+						+ matrix[1][2] * m[2][0];
+		result[1][1] = matrix[1][0] * m[0][1] + matrix[1][1] * m[1][1]
+						+ matrix[1][2] * m[2][1];
+		result[1][2] = matrix[1][0] * m[0][2] + matrix[1][1] * m[1][2]
+						+ matrix[1][2] * m[2][2];
+
+		result[2][0] = matrix[2][0] * m[0][0] + matrix[2][1] * m[1][0]
+						+ matrix[2][2] * m[2][0];
+		result[2][1] = matrix[2][0] * m[0][1] + matrix[2][1] * m[1][1]
+						+ matrix[2][2] * m[2][1];
+		result[2][2] = matrix[2][0] * m[0][2] + matrix[2][1] * m[1][2]
+						+ matrix[2][2] * m[2][2];
+
+		matrix[0][0] = result[0][0];
+		matrix[0][1] = result[0][1];
+		matrix[0][2] = result[0][2];
+
+		matrix[1][0] = result[1][0];
+		matrix[1][1] = result[1][1];
+		matrix[1][2] = result[1][2];
+
+		matrix[2][0] = result[2][0];
+		matrix[2][1] = result[2][1];
+		matrix[2][2] = result[2][2];
+	}
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000285.html">[Transform-svn] r349 - dev/dev-2-4/src/com/flagstone/transform
</A></li>
	<LI>Next message: <A HREF="000287.html">[Transform-svn] r351 - dev/dev-2-4/src/com/flagstone/transform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#286">[ date ]</a>
              <a href="thread.html#286">[ thread ]</a>
              <a href="subject.html#286">[ subject ]</a>
              <a href="author.html#286">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/transform-svn">More information about the Transform-svn
mailing list</a><br>
</body></html>
