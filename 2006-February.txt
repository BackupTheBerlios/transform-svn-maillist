From smackay at berlios.de  Mon Feb 20 21:20:48 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Mon, 20 Feb 2006 21:20:48 +0100
Subject: [Transform-svn] r59 - trunk/src/com/flagstone/transform/tools
Message-ID: <200602202020.k1KKKmP7029585@sheep.berlios.de>

Author: smackay
Date: 2006-02-20 21:20:34 +0100 (Mon, 20 Feb 2006)
New Revision: 59

Modified:
   trunk/src/com/flagstone/transform/tools/Tool.java
Log:
Tool constructor is now public so tools can be accessed by classes outside of the Transform framework.

Modified: trunk/src/com/flagstone/transform/tools/Tool.java
===================================================================
--- trunk/src/com/flagstone/transform/tools/Tool.java	2006-02-20 13:05:36 UTC (rev 58)
+++ trunk/src/com/flagstone/transform/tools/Tool.java	2006-02-20 20:20:34 UTC (rev 59)
@@ -18,7 +18,7 @@
     
     protected String extension = null; 
     
-    Tool(String[] args)
+    public Tool(String[] args)
     {
         getOptions(args);
     }



From smackay at berlios.de  Mon Feb 20 21:31:55 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Mon, 20 Feb 2006 21:31:55 +0100
Subject: [Transform-svn] r60 - trunk/src/com/flagstone/transform/tools
Message-ID: <200602202031.k1KKVtpb002085@sheep.berlios.de>

Author: smackay
Date: 2006-02-20 21:31:39 +0100 (Mon, 20 Feb 2006)
New Revision: 60

Modified:
   trunk/src/com/flagstone/transform/tools/Tool.java
Log:
Tool.java: Added BSD Licence header.

Modified: trunk/src/com/flagstone/transform/tools/Tool.java
===================================================================
--- trunk/src/com/flagstone/transform/tools/Tool.java	2006-02-20 20:20:34 UTC (rev 59)
+++ trunk/src/com/flagstone/transform/tools/Tool.java	2006-02-20 20:31:39 UTC (rev 60)
@@ -1,11 +1,32 @@
-//
-// Tool.java
-// Transform
-//
-// Created by smackay on Mon Jul 15 2002.
-// Copyright (c) 2002 Flagstone Software Ltd. All rights reserved.
-//
-
+/*
+ * Tool.java
+ * Transform
+ * 
+ * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
 package com.flagstone.transform.tools;
 
 import java.io.File;



From smackay at berlios.de  Tue Feb 21 15:36:45 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 15:36:45 +0100
Subject: [Transform-svn] r62 - trunk/src/com/flagstone/transform/test
Message-ID: <200602211436.k1LEajA2016338@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 15:36:31 +0100 (Tue, 21 Feb 2006)
New Revision: 62

Added:
   trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java
   trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
Modified:
   trunk/src/com/flagstone/transform/test/FSMovieTest.java
   trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java
   trunk/src/com/flagstone/transform/test/TextDumpTest.java
Log:
com.flagstone.transform.test: Added tests for the constructor
classes and tidied up some unused variables in existing classes.

Added: trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java	2006-02-21 14:34:20 UTC (rev 61)
+++ trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java	2006-02-21 14:36:31 UTC (rev 62)
@@ -0,0 +1,96 @@
+package com.flagstone.transform.test;
+
+import java.io.*;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+public class FSImageConstructorTest
+{
+    private File sourceDir = null;
+    private File destDir = null;
+    private String extension = null;
+    
+    public FSImageConstructorTest()
+    {
+    }
+    /**
+     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
+     * @testng.parameters value = "srcDir dstDir ext"
+     */
+    public void configure(String srcDir, String dstDir, String ext)
+    {
+        sourceDir = new File(srcDir);
+        destDir = new File(dstDir);
+        extension = ext;
+    }
+    /**
+     * @testng.test dataProvider="files"
+     */
+    public void displayImage(File imageFile)
+    {
+        try 
+        {
+            String fileName = imageFile.getName();
+            fileName = fileName.substring(0, fileName.lastIndexOf('.')) + ".swf";
+    
+            File destFile = new File(destDir, fileName);
+ 
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            FSImageConstructor imageConstructor = new FSImageConstructor(imageFile.getPath());
+            encodeImageToFile(imageConstructor, destFile);
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+    /**
+     * @testng.data-provider name="files"
+     */
+    public Object[][] findFiles()
+    {
+        FilenameFilter filter = new FilenameFilter() 
+        {
+            public boolean accept(File directory, String name) {
+                return name.endsWith(extension);
+            }
+        };
+        
+        String[] files = sourceDir.list(filter);
+        Object[][] parameters = new Object[files.length][1];
+        
+        for (int i=0; i<files.length; i++)
+            parameters[i] = new Object[] { new File(sourceDir, files[i]) };
+        
+        return parameters;
+    }
+    private void encodeImageToFile(FSImageConstructor generator, File file) throws Exception
+    {
+        FSMovie movie = new FSMovie();
+        
+        int imageId = movie.newIdentifier();
+        int shapeId = movie.newIdentifier();
+        
+        int xOrigin = generator.getWidth()/2;
+        int yOrigin = generator.getHeight()/2;
+        
+        FSSolidLine borderStyle = new FSSolidLine(20, FSColorTable.black());
+        
+        FSDefineObject image = generator.defineImage(imageId);
+        FSDefineShape3 shape = generator.defineEnclosingShape(shapeId, imageId, 
+            -xOrigin, -yOrigin, borderStyle);
+        
+        movie.setFrameRate(1.0f);
+        movie.setFrameSize(shape.getBounds());
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        movie.add(image);
+        movie.add(shape);
+        movie.add(new FSPlaceObject2(shapeId, 1, 0, 0));
+        movie.add(new FSShowFrame());
+        
+        movie.encodeToFile(file.getPath());
+    }
+}

Modified: trunk/src/com/flagstone/transform/test/FSMovieTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSMovieTest.java	2006-02-21 14:34:20 UTC (rev 61)
+++ trunk/src/com/flagstone/transform/test/FSMovieTest.java	2006-02-21 14:36:31 UTC (rev 62)
@@ -39,7 +39,6 @@
 {
     private File sourceDir = null;
     private File destDir = null;
-    private String testSuite = null;
     private String extension = ".swf";
     
     public FSMovieTest()
@@ -53,8 +52,6 @@
     {
         sourceDir = new File(srcDir);
         destDir = new File(dstDir);
-        
-        testSuite = sourceDir.getName();
     }
     /**
      * @testng.test dataProvider="files"
@@ -82,11 +79,10 @@
         try 
         {
             File srcFile = new File(sourceDir, file);
-            File testDir = new File(destDir, "encode"+File.separator+testSuite);
-            File destFile = new File(testDir, file);
+            File destFile = new File(destDir, file);
             
-            if (testDir.exists() == false)
-                assert testDir.mkdirs() : "Count not create directory: "+testDir;
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
             
             FSMovie movie = new FSMovie(srcFile.getPath());
             movie.encodeToFile(destFile.getPath());
@@ -108,11 +104,10 @@
         try 
         {
             File srcFile = new File(sourceDir, file);
-            File testDir = new File(destDir, "clone"+File.separator+testSuite);
-            File destFile = new File(testDir, file);
+            File destFile = new File(destDir, file);
             
-            if (testDir.exists() == false)
-                assert testDir.mkdirs() : "Count not create directory: "+testDir;
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
             
             FSMovie movie = new FSMovie(srcFile.getPath());
             
@@ -129,6 +124,29 @@
         }
     }
     /**
+     * @testng.test dataProvider="files"
+     */
+    public void toText(String file)
+    {
+        try
+        {
+            File srcFile = new File(sourceDir, file);
+            File dstFile = new File(destDir, file.substring(0, file.length()-3)+"txt");
+            
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            new TextDump(new String[] {
+                            "--fileIn", srcFile.getPath(), 
+                            "--fileOut", dstFile.getPath()});
+
+        }
+        catch (Throwable e)
+        {
+            assert false : file+": "+e.toString();
+        }
+    }
+    /**
      * @testng.data-provider name="files"
      */
     public Object[][] findFiles()

Modified: trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java	2006-02-21 14:34:20 UTC (rev 61)
+++ trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java	2006-02-21 14:36:31 UTC (rev 62)
@@ -29,8 +29,6 @@
  */
 package com.flagstone.transform.test;
 
-import com.flagstone.transform.*;
-
 public class FSSetBackgroundColorTest 
 {    
     public FSSetBackgroundColorTest()

Added: trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2006-02-21 14:34:20 UTC (rev 61)
+++ trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2006-02-21 14:36:31 UTC (rev 62)
@@ -0,0 +1,140 @@
+package com.flagstone.transform.test;
+
+import java.io.*;
+import java.util.*;
+import java.awt.*;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+public class FSTextConstructorTest
+{
+    private File sourceDir = null;
+    private File destDir = null;
+    private String extension = null;
+    
+    public FSTextConstructorTest()
+    {
+    }
+    /**
+     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
+     * @testng.parameters value = "srcDir dstDir ext"
+     */
+    public void configure(String srcDir, String dstDir, String ext)
+    {
+        sourceDir = new File(srcDir);
+        destDir = new File(dstDir);
+        extension = ext;
+    }
+	/**
+     * @testng.test
+	 */
+    public void displayAWTFont()
+    {
+        try 
+        {
+            Font[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
+
+            for (int i=0; i<fonts.length; i++)
+            {
+                String fontName = fonts[i].getFontName();
+    
+                File destFile = new File(destDir, fontName + ".swf");
+     
+                if (destDir.exists() == false)
+                    assert destDir.mkdirs() : "Count not create directory: "+destDir;
+                
+                FSTextConstructor textGenerator = new FSTextConstructor(1, fontName);            
+                encodeFontToFile(textGenerator, destFile);
+            }
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+	/**
+     * @testng.test dataProvider="files"
+	 */
+    public void displayTrueTypeFont(String fontFile)
+    {
+        try 
+        {
+            File srcFile = new File(sourceDir, fontFile);
+            File destFile = new File(destDir, fontFile.substring(0, fontFile.lastIndexOf('.')) + ".swf");
+ 
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            FSTextConstructor textGenerator = new FSTextConstructor(1, srcFile.getPath());          
+            encodeFontToFile(textGenerator, destFile);
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+    /**
+     * @testng.data-provider name="files"
+     */
+    public Object[][] findFiles()
+    {
+        FilenameFilter filter = new FilenameFilter() 
+        {
+            public boolean accept(File directory, String name) {
+                return name.endsWith(extension);
+            }
+        };
+        
+        String[] files = sourceDir.list(filter);       
+
+        Object[][] parameters = new Object[files.length][1];
+        
+        for (int i=0; i<files.length; i++)
+            parameters[i] = new Object[] { files[i] };
+        
+        return parameters;
+    }
+      
+    private void encodeFontToFile(FSTextConstructor textGenerator, File file) throws Exception
+    {
+        int fontSize = 280;
+        int lineSpacing = fontSize;        
+        int margin = fontSize;
+                
+        FSMovie movie = new FSMovie();
+        ArrayList lines = new ArrayList();
+        char c = 0;
+
+        for (int i=0; i<32; i++)
+        {
+            StringBuffer line = new StringBuffer();
+            
+            for (int j=0; j<64; j++, c++)
+
+                line.append((char)c);
+
+            lines.add(line.toString());
+        }
+        
+        int fontId = movie.newIdentifier();
+        
+        FSDefineText2 text = textGenerator.defineTextBlock(movie.newIdentifier(), lines, fontSize, FSColorTable.black(), lineSpacing);
+        FSDefineFont2 font = textGenerator.defineFont();
+        
+        font.setIdentifier(fontId);
+
+        int screenWidth = text.getBounds().getWidth() + margin + margin;
+        int screenHeight = text.getBounds().getHeight() + margin + margin;
+            
+        movie.setFrameSize(new FSBounds(0, 0, screenWidth, screenHeight));
+        movie.setFrameRate(1.0f);
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        movie.add(font);
+        movie.add(text);
+        movie.add(new FSPlaceObject2(text.getIdentifier(), 1, margin , margin));
+        movie.add(new FSShowFrame());
+
+        movie.encodeToFile(file.getPath());
+    }
+}

Modified: trunk/src/com/flagstone/transform/test/TextDumpTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/TextDumpTest.java	2006-02-21 14:34:20 UTC (rev 61)
+++ trunk/src/com/flagstone/transform/test/TextDumpTest.java	2006-02-21 14:36:31 UTC (rev 62)
@@ -30,9 +30,7 @@
 package com.flagstone.transform.test;
 
 import java.io.*;
-import java.util.zip.*;
 
-import com.flagstone.transform.*;
 import com.flagstone.transform.tools.*;
 
 public class TextDumpTest



From smackay at berlios.de  Tue Feb 21 15:39:12 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 15:39:12 +0100
Subject: [Transform-svn] r63 - trunk/test/suites
Message-ID: <200602211439.k1LEdChm016984@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 15:38:41 +0100 (Tue, 21 Feb 2006)
New Revision: 63

Added:
   trunk/test/suites/FSImageConstructor.xml
   trunk/test/suites/FSTextConstructor.xml
Removed:
   trunk/test/suites/MovieTestResultsToText.xml
Modified:
   trunk/test/suites/FSMovie.xml
Log:
Added testng suites for FSImageConstructor and FSTextConstructor.
Restructured the tests for FSMovie so all the steps for regression
testing are included. Removed MovieTestResultsToText since this step
is now performed in FSMovieTest.java

Added: trunk/test/suites/FSImageConstructor.xml
===================================================================
--- trunk/test/suites/FSImageConstructor.xml	2006-02-21 14:36:31 UTC (rev 62)
+++ trunk/test/suites/FSImageConstructor.xml	2006-02-21 14:38:41 UTC (rev 63)
@@ -0,0 +1,24 @@
+<!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
+  
+<suite name="FSImageConstructorTest" verbose="10">
+
+    <test name="JPG Images">
+		<parameter name="srcDir" value="test/data/files/jpg"/>
+		<parameter name="dstDir" value="test/results/FSImageConstructor/jpg"/>
+		<parameter name="ext" value="jpg"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSImageConstructorTest"/>
+		</classes>
+  	</test>
+  	
+    <test name="PNG Images">
+		<parameter name="srcDir" value="test/data/files/png"/>
+		<parameter name="dstDir" value="test/results/FSImageConstructor/png"/>
+		<parameter name="ext" value="png"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSImageConstructorTest"/>
+		</classes>
+  	</test>
+  	
+</suite>
+

Modified: trunk/test/suites/FSMovie.xml
===================================================================
--- trunk/test/suites/FSMovie.xml	2006-02-21 14:36:31 UTC (rev 62)
+++ trunk/test/suites/FSMovie.xml	2006-02-21 14:38:41 UTC (rev 63)
@@ -1,31 +1,261 @@
 <!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
   
 <suite name="FSMovie">
-	<parameter name="dstDir"  value="test/results/FSMovie"/>
 	
-    <test name="Test SWF4">
-		<parameter name="srcDir"  value="test/data/movies/swf4"/>
+	<!--
+	    Create text dumps of the movies to use as a reference for comparing
+	    the files saved by the encode and clone tests.
+	-->
+    <test name="Reference SWF4">
+		<parameter name="srcDir" value="test/data/movies/swf4"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf4"/>
 		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest"/>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
 		</classes>
   	</test>
-    <test name="Test SWF5">
-		<parameter name="srcDir"  value="test/data/movies/swf5"/>
+
+    <test name="Reference SWF5">
+		<parameter name="srcDir" value="test/data/movies/swf5"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf5"/>
 		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest"/>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
 		</classes>
   	</test>
-    <test name="Test SWF6">
-		<parameter name="srcDir"  value="test/data/movies/swf6"/>
+
+    <test name="Reference SWF6">
+		<parameter name="srcDir" value="test/data/movies/swf6"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf6"/>
 		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest"/>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
 		</classes>
   	</test>
-    <test name="Test SWF7">
-		<parameter name="srcDir"  value="test/data/movies/swf7"/>
+
+    <test name="Reference SWF7">
+		<parameter name="srcDir" value="test/data/movies/swf7"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf7"/>
 		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest"/>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
 		</classes>
   	</test>
+
+    <!--
+        Decode then encode a movie. 
+    -->
+    <test name="Encode SWF4">
+		<parameter name="srcDir" value="test/data/movies/swf4"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf4"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="encode"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Encode SWF5">
+		<parameter name="srcDir" value="test/data/movies/swf5"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf5"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="encode"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Encode SWF6">
+		<parameter name="srcDir" value="test/data/movies/swf6"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf6"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="encode"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Encode SWF7">
+		<parameter name="srcDir" value="test/data/movies/swf7"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf7"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="encode"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <!--
+        Convert the results from the encode test to text to compare against
+        the reference files. 
+    -->
+    <test name="Encode ToText SWF4">
+		<parameter name="srcDir" value="test/results/FSMovie/encode/swf4"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf4"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Encode ToText SWF5">
+		<parameter name="srcDir" value="test/results/FSMovie/encode/swf5"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf5"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Encode ToText SWF6">
+		<parameter name="srcDir" value="test/results/FSMovie/encode/swf6"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf6"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Encode ToText SWF7">
+		<parameter name="srcDir" value="test/results/FSMovie/encode/swf7"/>
+		<parameter name="dstDir" value="test/results/FSMovie/encode/swf7"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <!--
+        Decode, clone then encode a movie. 
+    -->
+    <test name="Clone SWF4">
+		<parameter name="srcDir" value="test/data/movies/swf4"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf4"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="clone"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Clone SWF5">
+		<parameter name="srcDir" value="test/data/movies/swf5"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf5"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="clone"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Clone SWF6">
+		<parameter name="srcDir" value="test/data/movies/swf6"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf6"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="clone"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Clone SWF7">
+		<parameter name="srcDir" value="test/data/movies/swf7"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf7"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="clone"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+
+    <test name="Clone ToText SWF4">
+		<parameter name="srcDir" value="test/results/FSMovie/clone/swf4"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf4"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Clone ToText SWF5">
+		<parameter name="srcDir" value="test/results/FSMovie/clone/swf5"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf5"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Clone ToText SWF6">
+		<parameter name="srcDir" value="test/results/FSMovie/clone/swf6"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf6"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Clone ToText SWF7">
+		<parameter name="srcDir" value="test/results/FSMovie/clone/swf7"/>
+		<parameter name="dstDir" value="test/results/FSMovie/clone/swf7"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
 </suite>
 

Added: trunk/test/suites/FSTextConstructor.xml
===================================================================
--- trunk/test/suites/FSTextConstructor.xml	2006-02-21 14:36:31 UTC (rev 62)
+++ trunk/test/suites/FSTextConstructor.xml	2006-02-21 14:38:41 UTC (rev 63)
@@ -0,0 +1,34 @@
+<!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
+  
+<suite name="FSTextConstructorTest" verbose="10">
+
+	<parameter name="srcDir" value=""/>
+	<parameter name="dstDir" value=""/>
+	<parameter name="ext" value=""/>
+
+    <test name="TTF Fonts">
+		<parameter name="srcDir" value="test/data/files/ttf"/>
+		<parameter name="dstDir" value="test/results/FSTextConstructor/ttf"/>
+		<parameter name="ext" value="ttf"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSTextConstructorTest">
+      		    <methods>
+      				<include name="displayTrueTypeFont" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+  	
+    <test name="AWT Fonts">
+		<parameter name="dstDir" value="test/results/FSTextConstructor/awt"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSTextConstructorTest">
+      		    <methods>
+      				<include name="displayAWTFont" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+</suite>
+

Deleted: trunk/test/suites/MovieTestResultsToText.xml
===================================================================
--- trunk/test/suites/MovieTestResultsToText.xml	2006-02-21 14:36:31 UTC (rev 62)
+++ trunk/test/suites/MovieTestResultsToText.xml	2006-02-21 14:38:41 UTC (rev 63)
@@ -1,62 +0,0 @@
-<!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
-  
-<suite name="TextDumpMovieTestResults">
-    <test name="Encode SWF4">
-		<parameter name="srcDir" value="test/results/FSMovie/encode/swf4"/>
-		<parameter name="dstDir" value="test/results/FSMovie/encode/swf4"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-    <test name="Encode SWF5">
-		<parameter name="srcDir" value="test/results/FSMovie/encode/swf5"/>
-		<parameter name="dstDir" value="test/results/FSMovie/encode/swf5"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-    <test name="Encode SWF6">
-		<parameter name="srcDir" value="test/results/FSMovie/encode/swf6"/>
-		<parameter name="dstDir" value="test/results/FSMovie/encode/swf6"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-    <test name="Encode SWF7">
-		<parameter name="srcDir" value="test/results/FSMovie/encode/swf7"/>
-		<parameter name="dstDir" value="test/results/FSMovie/encode/swf7"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-  	
-    <test name="Clone SWF4">
-		<parameter name="srcDir" value="test/results/FSMovie/clone/swf4"/>
-		<parameter name="dstDir" value="test/results/FSMovie/clone/swf4"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-    <test name="Clone SWF5">
-		<parameter name="srcDir" value="test/results/FSMovie/clone/swf5"/>
-		<parameter name="dstDir" value="test/results/FSMovie/clone/swf5"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-    <test name="Clone SWF6">
-		<parameter name="srcDir" value="test/results/FSMovie/clone/swf6"/>
-		<parameter name="dstDir" value="test/results/FSMovie/clone/swf6"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>
-    <test name="Clone SWF7">
-		<parameter name="srcDir" value="test/results/FSMovie/clone/swf7"/>
-		<parameter name="dstDir" value="test/results/FSMovie/clone/swf7"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.TextDumpTest"/>
-		</classes>
-  	</test>  	
-</suite>
-



From smackay at berlios.de  Tue Feb 21 15:43:33 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 15:43:33 +0100
Subject: [Transform-svn] r64 - in trunk/test/data: . fonts fonts/orgdot fonts/vera
Message-ID: <200602211443.k1LEhXft019856@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 15:42:31 +0100 (Tue, 21 Feb 2006)
New Revision: 64

Added:
   trunk/test/data/fonts/
   trunk/test/data/fonts/orgdot/
   trunk/test/data/fonts/orgdot/COPYING.txt
   trunk/test/data/fonts/orgdot/FIXED_BO.TTF
   trunk/test/data/fonts/orgdot/FIXED_V0.TTF
   trunk/test/data/fonts/orgdot/FIXED_V1.TTF
   trunk/test/data/fonts/orgdot/FIXED_V2.TTF
   trunk/test/data/fonts/orgdot/FIXED_V3.TTF
   trunk/test/data/fonts/orgdot/FIXED_V4.TTF
   trunk/test/data/fonts/orgdot/FIXED_V5.TTF
   trunk/test/data/fonts/orgdot/GENOWN_V.TTF
   trunk/test/data/fonts/orgdot/KHARON4A1.TTF
   trunk/test/data/fonts/orgdot/KHARON4AB.TTF
   trunk/test/data/fonts/orgdot/KHARON4AM.TTF
   trunk/test/data/fonts/orgdot/ORG_V01.TTF
   trunk/test/data/fonts/orgdot/PIXELPUN.TTF
   trunk/test/data/fonts/orgdot/SERIF_V0.TTF
   trunk/test/data/fonts/orgdot/SWFIT1.TTF
   trunk/test/data/fonts/orgdot/SWFIT2.TTF
   trunk/test/data/fonts/orgdot/SWFIT_SL.TTF
   trunk/test/data/fonts/orgdot/TEACP.TTF
   trunk/test/data/fonts/orgdot/TEACPSS.TTF
   trunk/test/data/fonts/orgdot/TEACPSSB.TTF
   trunk/test/data/fonts/vera/
   trunk/test/data/fonts/vera/COPYRIGHT.TXT
   trunk/test/data/fonts/vera/README.TXT
   trunk/test/data/fonts/vera/RELEASENOTES.TXT
   trunk/test/data/fonts/vera/Vera.ttf
   trunk/test/data/fonts/vera/VeraBI.ttf
   trunk/test/data/fonts/vera/VeraBd.ttf
   trunk/test/data/fonts/vera/VeraIt.ttf
   trunk/test/data/fonts/vera/VeraMoBI.ttf
   trunk/test/data/fonts/vera/VeraMoBd.ttf
   trunk/test/data/fonts/vera/VeraMoIt.ttf
   trunk/test/data/fonts/vera/VeraMono.ttf
   trunk/test/data/fonts/vera/VeraSe.ttf
   trunk/test/data/fonts/vera/VeraSeBd.ttf
   trunk/test/data/fonts/vera/local.conf
Log:
test/data/fonts: Added two opensource fonts that can be used for
testing the FSTextConstructor class.


Property changes on: trunk/test/data/fonts
___________________________________________________________________
Name: svn:ignore
   + 
win32


Added: trunk/test/data/fonts/orgdot/COPYING.txt
===================================================================
--- trunk/test/data/fonts/orgdot/COPYING.txt	2006-02-21 14:38:41 UTC (rev 63)
+++ trunk/test/data/fonts/orgdot/COPYING.txt	2006-02-21 14:42:31 UTC (rev 64)
@@ -0,0 +1,17 @@
+/* (c) 2001 http://www.orgdot.com: you can copy, use, modify and distribute this 
+code and/or artwork for educational, commercial or recreational use. all we ask 
+is that you include this copyright notice in the materialyou distribute. for 
+compiled code, you will need to make accessible this copyright notice somewhere 
+in the distribution, and/or via a link on the web. there are several reasons for 
+this caveat - the most important being that open source is based on one main 
+principle: what you find and use, others should also have access to. don't keep 
+it to yourself! this software is provided by the author and contributors "as is" 
+and any express or implied warranties, including, but not limited to, the 
+implied warranties of merchantability and fitness for a particular purpose are 
+disclaimed. in no event shall the author or contributors be liable for any 
+direct, indirect, incidental, special, exemplary, or consequential damages 
+(including, but not limited to, procurement of substitute goods or services; 
+loss of use, data, or profits; or business interruption) however caused and on 
+any theory of liability, whether in contract, strict liability, or tort 
+(including negligence or otherwise) arising in any way out of the use of this 
+software, even if advised of the possibility of such damage. */
\ No newline at end of file

Added: trunk/test/data/fonts/orgdot/FIXED_BO.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_BO.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/FIXED_V0.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_V0.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/FIXED_V1.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_V1.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/FIXED_V2.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_V2.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/FIXED_V3.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_V3.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/FIXED_V4.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_V4.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/FIXED_V5.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/FIXED_V5.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/GENOWN_V.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/GENOWN_V.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/KHARON4A1.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/KHARON4A1.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/KHARON4AB.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/KHARON4AB.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/KHARON4AM.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/KHARON4AM.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/ORG_V01.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/ORG_V01.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/PIXELPUN.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/PIXELPUN.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/SERIF_V0.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/SERIF_V0.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/SWFIT1.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/SWFIT1.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/SWFIT2.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/SWFIT2.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/SWFIT_SL.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/SWFIT_SL.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/TEACP.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/TEACP.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/TEACPSS.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/TEACPSS.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/orgdot/TEACPSSB.TTF
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/orgdot/TEACPSSB.TTF
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/COPYRIGHT.TXT
===================================================================
--- trunk/test/data/fonts/vera/COPYRIGHT.TXT	2006-02-21 14:38:41 UTC (rev 63)
+++ trunk/test/data/fonts/vera/COPYRIGHT.TXT	2006-02-21 14:42:31 UTC (rev 64)
@@ -0,0 +1,124 @@
+Bitstream Vera Fonts Copyright
+
+The fonts have a generous copyright, allowing derivative works (as
+long as "Bitstream" or "Vera" are not in the names), and full
+redistribution (so long as they are not *sold* by themselves). They
+can be be bundled, redistributed and sold with any software.
+
+The fonts are distributed under the following copyright:
+
+Copyright
+=========
+
+Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved. Bitstream
+Vera is a trademark of Bitstream, Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of the fonts accompanying this license ("Fonts") and associated
+documentation files (the "Font Software"), to reproduce and distribute
+the Font Software, including without limitation the rights to use,
+copy, merge, publish, distribute, and/or sell copies of the Font
+Software, and to permit persons to whom the Font Software is furnished
+to do so, subject to the following conditions:
+
+The above copyright and trademark notices and this permission notice
+shall be included in all copies of one or more of the Font Software
+typefaces.
+
+The Font Software may be modified, altered, or added to, and in
+particular the designs of glyphs or characters in the Fonts may be
+modified and additional glyphs or characters may be added to the
+Fonts, only if the fonts are renamed to names not containing either
+the words "Bitstream" or the word "Vera".
+
+This License becomes null and void to the extent applicable to Fonts
+or Font Software that has been modified and is distributed under the
+"Bitstream Vera" names.
+
+The Font Software may be sold as part of a larger software package but
+no copy of one or more of the Font Software typefaces may be sold by
+itself.
+
+THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL
+BITSTREAM OR THE GNOME FOUNDATION BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL,
+OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT
+SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.
+
+Except as contained in this notice, the names of Gnome, the Gnome
+Foundation, and Bitstream Inc., shall not be used in advertising or
+otherwise to promote the sale, use or other dealings in this Font
+Software without prior written authorization from the Gnome Foundation
+or Bitstream Inc., respectively. For further information, contact:
+fonts at gnome dot org.
+
+Copyright FAQ
+=============
+
+   1. I don't understand the resale restriction... What gives?
+
+      Bitstream is giving away these fonts, but wishes to ensure its
+      competitors can't just drop the fonts as is into a font sale system
+      and sell them as is. It seems fair that if Bitstream can't make money
+      from the Bitstream Vera fonts, their competitors should not be able to
+      do so either. You can sell the fonts as part of any software package,
+      however.
+
+   2. I want to package these fonts separately for distribution and
+      sale as part of a larger software package or system.  Can I do so?
+
+      Yes. A RPM or Debian package is a "larger software package" to begin 
+      with, and you aren't selling them independently by themselves. 
+      See 1. above.
+
+   3. Are derivative works allowed?
+      Yes!
+
+   4. Can I change or add to the font(s)?
+      Yes, but you must change the name(s) of the font(s).
+
+   5. Under what terms are derivative works allowed?
+
+      You must change the name(s) of the fonts. This is to ensure the
+      quality of the fonts, both to protect Bitstream and Gnome. We want to
+      ensure that if an application has opened a font specifically of these
+      names, it gets what it expects (though of course, using fontconfig,
+      substitutions could still could have occurred during font
+      opening). You must include the Bitstream copyright. Additional
+      copyrights can be added, as per copyright law. Happy Font Hacking!
+
+   6. If I have improvements for Bitstream Vera, is it possible they might get 
+       adopted in future versions?
+
+      Yes. The contract between the Gnome Foundation and Bitstream has
+      provisions for working with Bitstream to ensure quality additions to
+      the Bitstream Vera font family. Please contact us if you have such
+      additions. Note, that in general, we will want such additions for the
+      entire family, not just a single font, and that you'll have to keep
+      both Gnome and Jim Lyles, Vera's designer, happy! To make sense to add
+      glyphs to the font, they must be stylistically in keeping with Vera's
+      design. Vera cannot become a "ransom note" font. Jim Lyles will be
+      providing a document describing the design elements used in Vera, as a
+      guide and aid for people interested in contributing to Vera.
+
+   7. I want to sell a software package that uses these fonts: Can I do so?
+
+      Sure. Bundle the fonts with your software and sell your software
+      with the fonts. That is the intent of the copyright.
+
+   8. If applications have built the names "Bitstream Vera" into them, 
+      can I override this somehow to use fonts of my choosing?
+
+      This depends on exact details of the software. Most open source
+      systems and software (e.g., Gnome, KDE, etc.) are now converting to
+      use fontconfig (see www.fontconfig.org) to handle font configuration,
+      selection and substitution; it has provisions for overriding font
+      names and subsituting alternatives. An example is provided by the
+      supplied local.conf file, which chooses the family Bitstream Vera for
+      "sans", "serif" and "monospace".  Other software (e.g., the XFree86
+      core server) has other mechanisms for font substitution.
+

Added: trunk/test/data/fonts/vera/README.TXT
===================================================================
--- trunk/test/data/fonts/vera/README.TXT	2006-02-21 14:38:41 UTC (rev 63)
+++ trunk/test/data/fonts/vera/README.TXT	2006-02-21 14:42:31 UTC (rev 64)
@@ -0,0 +1,11 @@
+Contained herin is the Bitstream Vera font family.
+
+The Copyright information is found in the COPYRIGHT.TXT file (along
+with being incoporated into the fonts themselves).
+
+The releases notes are found in the file "RELEASENOTES.TXT".
+
+We hope you enjoy Vera!
+
+                        Bitstream, Inc.
+			The Gnome Project

Added: trunk/test/data/fonts/vera/RELEASENOTES.TXT
===================================================================
--- trunk/test/data/fonts/vera/RELEASENOTES.TXT	2006-02-21 14:38:41 UTC (rev 63)
+++ trunk/test/data/fonts/vera/RELEASENOTES.TXT	2006-02-21 14:42:31 UTC (rev 64)
@@ -0,0 +1,162 @@
+Bitstream Vera Fonts - April 16, 2003
+=====================================
+
+The version number of these fonts is 1.10 to distinguish them from the
+beta test fonts.
+
+Note that the Vera copyright is incorporated in the fonts themselves.
+The License field in the fonts contains the copyright license as it
+appears below. The TrueType copyright field is not large enough to
+contain the full license, so the license is incorporated (as you might
+think if you thought about it) into the license field, which
+unfortunately can be obscure to find.  (In pfaedit, see: Element->Font
+Info->TTFNames->License).
+
+Our apologies for it taking longer to complete the fonts than planned.
+Beta testers requested a tighter line spacing (less leading) and Jim
+Lyles redesigned Vera's accents to bring its line spacing to more
+typical of other fonts.  This took additional time and effort.  Our
+thanks to Jim for this effort above and beyond the call of duty.
+
+There are four monospace and sans faces (normal, oblique, bold, bold
+oblique) and two serif faces (normal and bold). Fontconfig/Xft2 (see
+www.fontconfig.org) can artificially oblique the serif faces for you:
+this loses hinting and distorts the faces slightly, but is visibly
+different than normal and bold, and reasonably pleasing.
+
+On systems with fontconfig 2.0 or 2.1 installed, making your sans,
+serif and monospace fonts default to these fonts is very easy.  Just
+drop the file local.conf into your /etc/fonts directory.  This will
+make the Bitstream fonts your default fonts for all applications using
+fontconfig (if sans, serif, or monospace names are used, as they often
+are as default values in many desktops). The XML in local.conf may
+need modification to enable subpixel decimation, if appropriate,
+however, the commented out phrase does so for XFree86 4.3, in the case
+that the server does not have sufficient information to identify the
+use of a flat panel.  Fontconfig 2.2 adds Vera to the list of font
+families and will, by default use it as the default sans, serif and
+monospace fonts.
+
+During the testing of the final Vera fonts, we learned that screen
+fonts in general are only typically hinted to work correctly at
+integer pixel sizes.  Vera is coded internally for integer sizes only.
+We need to investigate further to see if there are commonly used fonts
+that are hinted to be rounded but are not rounded to integer sizes due
+to oversights in their coding.
+
+Most fonts work best at 8 pixels and below if anti-aliased only, as
+the amount of work required to hint well at smaller and smaller sizes
+becomes astronomical.  GASP tables are typically used to control
+whether hinting is used or not, but Freetype/Xft does not currently
+support GASP tables (which are present in Vera).
+
+To mitigate this problem, both for Vera and other fonts, there will be
+(very shortly) a new fontconfig 2.2 release that will, by default not
+apply hints if the size is below 8 pixels. if you should have a font
+that in fact has been hinted more agressively, you can use fontconfig
+to note this exception. We believe this should improve many hinted
+fonts in addition to Vera, though implemeting GASP support is likely
+the right long term solution.
+
+Font rendering in Gnome or KDE is the combination of algorithms in
+Xft2 and Freetype, along with hinting in the fonts themselves. It is
+vital to have sufficient information to disentangle problems that you
+may observe.
+
+Note that having your font rendering system set up correctly is vital
+to proper judgement of problems of the fonts:
+
+    * Freetype may or may not be configured to in ways that may
+      implement execution of possibly patented (in some parts of the world)
+      TrueType hinting algorithms, particularly at small sizes.  Best
+      results are obtained while using these algorithms.
+
+    * The freetype autohinter (used when the possibly patented
+      algorithms are not used) continues to improve with each release. If
+      you are using the autohinter, please ensure you are using an up to
+      date version of freetype before reporting problems.
+
+    * Please identify what version of freetype you are using in any
+      bug reports, and how your freetype is configured.
+
+    * Make sure you are not using the freetype version included in
+      XFree86 4.3, as it has bugs that significantly degrade most fonts,
+      including Vera. if you build XFree86 4.3 from source yourself, you may
+      have installed this broken version without intending it (as I
+      did). Vera was verified with the recently released Freetype 2.1.4. On
+      many systems, 'ldd" can be used to see which freetype shared library
+      is actually being used.
+
+    * Xft/X Render does not (yet) implement gamma correction.  This
+      causes significant problems rendering white text on a black background
+      (causing partial pixels to be insufficiently shaded) if the gamma of
+      your monitor has not been compensated for, and minor problems with
+      black text on a while background.  The program "xgamma" can be used to
+      set a gamma correction value in the X server's color pallette. Most
+      monitors have a gamma near 2.
+
+    * Note that the Vera family uses minimal delta hinting. Your
+      results on other systems when not used anti-aliased may not be
+      entirely satisfying. We are primarily interested in reports of
+      problems on open source systems implementing Xft2/fontconfig/freetype
+      (which implements antialiasing and hinting adjustements, and
+      sophisticated subpixel decimation on flatpanels).  Also, the
+      algorithms used by Xft2 adjust the hints to integer widths and the
+      results are crisper on open source systems than on Windows or
+      MacIntosh.
+
+    * Your fontconfig may (probably does) predate the release of
+      fontconfig 2.2, and you may see artifacts not present when the font is
+      used at very small sizes with hinting enabled. "vc-list -V" can be
+      used to see what version you have installed.
+
+We believe and hope that these fonts will resolve the problems
+reported during beta test.  The largest change is the reduction of
+leading (interline spacing), which had annoyed a number of people, and
+reduced Vera's utility for some applcations.  The Vera monospace font
+should also now make '0' and 'O' and '1' and 'l' more clearly
+distinguishable.
+
+The version of these fonts is version 1.10.  Fontconfig should be
+choosing the new version of the fonts if both the released fonts and
+beta test fonts are installed (though please discard them: they have
+names of form tt20[1-12]gn.ttf).  Note that older versions of
+fontconfig sometimes did not rebuild their cache correctly when new
+fonts are installed: please upgrade to fontconfig 2.2. "fc-cache -f"
+can be used to force rebuilding fontconfig's cache files.
+
+If you note problems, please send them to fonts at gnome dot org, with
+exactly which face and size and unicode point you observe the problem
+at. The xfd utility from XFree86 CVS may be useful for this (e.g. "xfd
+-fa sans").  A possibly more useful program to examine fonts at a
+variety of sizes is the "waterfall" program found in Keith Packard's
+CVS.
+
+        $ cvs -d :pserver:anoncvs at keithp.com:/local/src/CVS login
+        Logging in to :pserver:anoncvs at keithp.com:2401/local/src/CVS
+        CVS password: <hit return>
+        $ cvs -d :pserver:anoncvs at keithp.com:/local/src/CVS co waterfall
+        $ cd waterfall
+        $ xmkmf -a
+        $ make
+        # make install
+        # make install.man
+
+Again, please make sure you are running an up-to-date freetype, and
+that you are only examining integer sizes.
+
+Reporting Problems
+==================
+
+Please send problem reports to fonts at gnome org, with the following
+information:
+
+   1. Version of Freetype, Xft2 and fontconfig
+   2. Whether TT hinting is being used, or the autohinter
+   3. Application being used
+   4. Character/Unicode code point that has problems (if applicable)
+   5. Version of which operating system
+   6. Please include a screenshot, when possible.
+
+Please check the fonts list archives before reporting problems to cut
+down on duplication.

Added: trunk/test/data/fonts/vera/Vera.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/Vera.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraBI.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraBI.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraBd.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraBd.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraIt.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraIt.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraMoBI.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraMoBI.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraMoBd.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraMoBd.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraMoIt.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraMoIt.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraMono.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraMono.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraSe.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraSe.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/VeraSeBd.ttf
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/fonts/vera/VeraSeBd.ttf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/fonts/vera/local.conf
===================================================================
--- trunk/test/data/fonts/vera/local.conf	2006-02-21 14:38:41 UTC (rev 63)
+++ trunk/test/data/fonts/vera/local.conf	2006-02-21 14:42:31 UTC (rev 64)
@@ -0,0 +1,32 @@
+<?xml version="1.0"?>
+<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
+<!-- /etc/fonts.conf file to configure system font access -->
+<fontconfig>
+        <!--  Enable sub-pixel rendering
+        <match target="font">
+                <test qual="all" name="rgba">
+                        <const>unknown</const>
+                </test>
+                <edit name="rgba" mode="assign"><const>rgb</const></edit>
+        </match>
+         -->
+
+        <alias>
+                <family>serif</family>
+                <prefer>
+                        <family>Bitstream Vera Serif</family>
+                </prefer>
+        </alias>
+        <alias>
+                <family>sans-serif</family>
+                <prefer>
+                        <family>Bitstream Vera Sans</family>
+                </prefer>
+        </alias>
+        <alias>
+                <family>monospace</family>
+                <prefer>
+                        <family>Bitstream Vera Sans Mono</family>
+                </prefer>
+        </alias>
+</fontconfig>



From smackay at berlios.de  Tue Feb 21 15:50:29 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 15:50:29 +0100
Subject: [Transform-svn] r66 - trunk/test/data
Message-ID: <200602211450.k1LEoTFl023293@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 15:49:54 +0100 (Tue, 21 Feb 2006)
New Revision: 66

Added:
   trunk/test/data/sounds/
Log:
Added directory for test suites for sounds.



From smackay at berlios.de  Tue Feb 21 15:35:03 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 15:35:03 +0100
Subject: [Transform-svn] r61 - trunk/src/com/flagstone/transform/examples
Message-ID: <200602211435.k1LEZ3rw015066@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 15:34:20 +0100 (Tue, 21 Feb 2006)
New Revision: 61

Added:
   trunk/src/com/flagstone/transform/examples/ConstructButtons.java
   trunk/src/com/flagstone/transform/examples/ConstructImages.java
   trunk/src/com/flagstone/transform/examples/ConstructShapes.java
   trunk/src/com/flagstone/transform/examples/ConstructSounds.java
   trunk/src/com/flagstone/transform/examples/ConstructStreamingSounds.java
   trunk/src/com/flagstone/transform/examples/ConstructText.java
Modified:
   trunk/src/com/flagstone/transform/examples/Example.java
   trunk/src/com/flagstone/transform/examples/Import.java
Log:
com.flagstone.transform.examples: Added examples for the constructor
classes and tidied up some unused variables in existing examples.

Added: trunk/src/com/flagstone/transform/examples/ConstructButtons.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/ConstructButtons.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/ConstructButtons.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -0,0 +1,362 @@
+/*
+ *  BasicButtons.java
+ *  Transform
+ *
+ *  Created by Stuart MacKay on Wed Sep 03 2003.
+ *  Copyright (c) 2001-2004 Flagstone Software Ltd. All rights reserved.
+ *
+ *  This code is distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ *  EXPRESS OR IMPLIED, AND Flagstone HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING
+ *  WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ *  PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ */
+package com.flagstone.transform.examples;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+import java.util.*;
+
+/*
+ * This example shows how to create buttons using the FSDefineButton and FSDefineButton2
+ * classes. Each button displays a web page in a browser when clicked. The second button
+ * also plays a sound when clicked.
+ *
+ * To run this example, type the following on a command line:
+ *
+ *     java com.flagstone.transform.examples.ConstructButtons \
+ *         --font font-file \
+ *         --sound sound-file \
+ *         --label string \
+ *        [--resultDir path]
+ *
+ * where
+ *
+ *     font-file is the path to a file containing a font definition used to 
+ *     render the text for label on the button.
+ *
+ *     sound-file is the path to a file containing a WAVE or MP3 format sound
+ *     which is played when a button is clicked.
+ *
+ *     string the label that will be displayed on the button - enclose in quotes 
+ *     if the label contains spaces.
+ *
+ *     resultDir is the directory where the Flash file generated by the example 
+ *     is written to.
+ */
+public class ConstructButtons extends Example
+{
+    private FSTextConstructor textGenerator = null;
+    private FSSoundConstructor soundGenerator = null;
+    private FSShapeConstructor path = null;
+
+    public static void main(String[] args)
+    {
+        new ConstructButtons(args);
+    }
+
+    public ConstructButtons(String[] args)
+    {
+        super(args);
+    
+        String fontFile = getOption("font", "");
+        String soundFile = getOption("sound", "");
+    
+        try 
+        {
+            textGenerator = new FSTextConstructor(movie.newIdentifier(), fontFile);
+            soundGenerator = new FSSoundConstructor(soundFile);
+            path = new FSShapeConstructor();
+        }
+        catch (Exception e)
+        {
+            /* Several exceptions could be thrown to get to this point. The 
+             * exceptions are all caught in a single handler to make the code 
+             * more readable.
+             */
+            System.err.println("Cannot create the movie.");
+        }
+
+        createMovie();
+    
+        writeFile("BasicButtons.swf");
+    }
+    
+    void createMovie()
+    {
+        /*
+         * Arrays used to hold the objects added to the button definitions.
+         */
+        ArrayList records = null;
+        ArrayList actions = null;
+        ArrayList events = null;
+
+        /*
+         * If no label is defined when the example is run then the label 
+         * defaults to "Button".
+         */
+        String buttonLabel = getOption("label", "Button");
+
+        int layer = 1;       // initial layer in the display list
+        int fontSize = 280;  // 280 twips == 14 point, 1 point == 20 twips
+
+        /*
+         * Define margins added to define the width of the button relative to 
+         * the size of the label and the screen width relative to the width of 
+         * the button.
+         */
+        int buttonMargin = 200; // The margin between the label and the edge of the button.
+        int screenMargin = 400; // The margin between the edge of the button and the screen.
+
+        /*
+         * Define colours used to fill the buttons in each of its states.
+         */
+        FSColor lineColor = FSColorTable.black();
+        FSColor shadowColor = FSColorTable.gray();
+        FSColor upColor = FSColorTable.red();
+        FSColor overColor = FSColorTable.orange();
+
+        /*
+         * Define coordinate transform applied to the basic button shape 
+         * to perform a simple animation giving the impression the button
+         * was physically clicked.
+         */
+        FSCoordTransform recess = new FSCoordTransform(60, 60);
+
+        /*
+         * Define the shapes used to create the buttons.
+         *
+         * The size of the shapes is calculated relative to the bounding rectangle
+         * enclosing an arbitrary long label. The ascent of the text is used rather
+         * than the full height of the bounding rectangle as this gives better
+         * placement of the text relative to the button edges.
+         */
+        FSDefineShape3 label = textGenerator.defineShape(movie.newIdentifier(), 
+            buttonLabel, fontSize, lineColor);
+
+        // define a 10 pixel margin around the text.
+    
+        int buttonWidth = label.getBounds().getWidth() + buttonMargin;
+        int buttonHeight = -label.getBounds().getMinY() + buttonMargin;
+
+        int lineWidth = 20;
+        int cornerRadius = 100;
+
+        /*
+         * The button will cast as shadow when it in the up state. Recessing the 
+         * button by changing the location of the shapes when the button is 
+         * clicked allows a very simple animation to be performed. More complex 
+         * animations can be created by using movie clips.
+         */
+        int xShadow = 60;
+        int yShadow = 60;
+
+        /*
+         * Used to hold the width and height of the bounding rectangle that
+         * encloses the button labels.
+         */
+        int width = 0;
+        int height = 0;
+        
+        path.add(new FSSolidLine(lineWidth, shadowColor));
+        path.add(new FSSolidFill(shadowColor));
+        path.rect(0, 0, buttonWidth, buttonHeight, cornerRadius);
+        
+        FSDefineShape2 shadow = path.defineShape(movie.newIdentifier());
+            
+        path.set(0, new FSSolidLine(lineWidth, lineColor));
+        path.set(0, new FSSolidFill(upColor));
+        path.rect(0, 0, buttonWidth, buttonHeight, cornerRadius);
+        
+        FSDefineShape2 upShape = path.defineShape(movie.newIdentifier());
+
+        path.set(0, new FSSolidLine(lineWidth, lineColor));
+        path.set(0, new FSSolidFill(overColor));
+        path.rect(0, 0, buttonWidth, buttonHeight, cornerRadius);
+        
+        FSDefineShape2 overShape = path.defineShape(movie.newIdentifier());
+
+        /**************************
+         *      First Button
+         **************************/
+
+        /*
+         * This button is created using the FSDefineButton class which only 
+         * defines actions when the button is clicked. The FSDefineButton2 class 
+         * supports a more complex model that allows actions to be performed for 
+         * a wide range of different button events.
+         */
+        records = new ArrayList();
+        actions = new ArrayList();
+        events = new ArrayList();
+
+        /*
+         * Define the label. For the first button the label text is traced out 
+         * as a shape. In the second half of this example the text object is 
+         * used directly.
+         */
+        FSDefineShape3 firstLabel = textGenerator.defineShape(movie.newIdentifier(), 
+            buttonLabel, fontSize, lineColor);
+
+        /*
+         * Realign the labels so they are displayed in the centre of the button. 
+         * The ascent of the text is used rather than the full height of the 
+         * bounding rectangle.
+         */
+        width = firstLabel.getBounds().getWidth();
+        height = -firstLabel.getBounds().getMinY();
+
+        /*
+         * Create the FSButto objects that define the button's appearance. More 
+         * than one button record can be defined for a given state allowing for 
+         * example button definitions to be reused with only the label changing. 
+         * The layer number controls the order in which the shapes are displayed.
+         *
+         * Use one of the button shapes to define the active area where the 
+         * button will respond to events generated by the mouse.
+         */
+        records.add(new FSButton(FSButton.Active, upShape.getIdentifier(), layer++));
+
+        /*
+         * Define the appearance of the button in the up state. A shape giving a 
+         * drop shadow effect is placed in the background and the label is in 
+         * the foreground.
+         */
+        records.add(new FSButton(FSButton.Up, shadow.getIdentifier(), layer++, recess));
+        records.add(new FSButton(FSButton.Up, upShape.getIdentifier(), layer++));
+        records.add(new FSButton(FSButton.Up, firstLabel.getIdentifier(), layer++, 
+            new FSCoordTransform(-width/2, height/2)));
+
+        /*
+         * The button appears the same when the mouse is over the active area. 
+         * Only the colour changes to highlight the button. The drop shadow must 
+         * still be drawn.     
+         */
+        records.add(new FSButton(FSButton.Over, shadow.getIdentifier(), layer++, recess));
+        records.add(new FSButton(FSButton.Over, overShape.getIdentifier(), layer++));
+        records.add(new FSButton(FSButton.Over, firstLabel.getIdentifier(), layer++, 
+            new FSCoordTransform(-width/2, height/2)));
+
+        /*
+         * The button appears is recessed when it is clicked so the shape for the drop shadow is
+         * not required.
+         */
+        records.add(new FSButton(FSButton.Down, overShape.getIdentifier(), layer++, recess));
+        records.add(new FSButton(FSButton.Down, firstLabel.getIdentifier(), layer++, 
+            new FSCoordTransform(-width/2 + xShadow, height/2 + yShadow)));
+
+        /*
+         * When the button is clicked a web page will be loaded into the web 
+         * browser. The browser must be running for this to work, the Flash Player 
+         * won't launch the browser by itself.
+         */
+        actions.add(new FSGetUrl("http://www.flagstonesoftware.com", ""));
+
+        FSDefineButton firstButton = new FSDefineButton(movie.newIdentifier(), 
+            records, actions);
+
+
+        /**************************
+         *     Second Button
+         **************************/
+
+        /*
+         * The second button is created using the FSDefineButton2 class which 
+         * provides a richer model for responding to moue events. It is similar 
+         * in appearance to the first except that the label is created using 
+         * FSDefineText2 objects rather than tracing out the text as a shape.
+         */
+        records = new ArrayList();
+        actions = new ArrayList();
+        events = new ArrayList();
+    
+        /*
+         * The FSDefineText2 object contains an FSCoordTransform which is used 
+         * here to change the placement of the text so the label appears in the 
+         * middle of the button.
+         */
+        FSDefineText2 secondLabel = textGenerator.defineText(movie.newIdentifier(), 
+            buttonLabel, fontSize, lineColor);
+
+        width = secondLabel.getBounds().getWidth();
+        height = - secondLabel.getBounds().getMinY();
+
+        /*
+         * Add the button records that define the button's appearance
+         */
+        records.add(new FSButton(FSButton.Active, upShape.getIdentifier(), layer++));
+
+        records.add(new FSButton(FSButton.Up, shadow.getIdentifier(), layer++, recess));
+        records.add(new FSButton(FSButton.Up, upShape.getIdentifier(), layer++));
+        records.add(new FSButton(FSButton.Up, secondLabel.getIdentifier(), layer++, 
+            new FSCoordTransform(-width/2, height/2)));
+
+        records.add(new FSButton(FSButton.Over, shadow.getIdentifier(), layer++, recess));
+        records.add(new FSButton(FSButton.Over, overShape.getIdentifier(), layer++));
+        records.add(new FSButton(FSButton.Over, secondLabel.getIdentifier(), layer++, 
+            new FSCoordTransform(-width/2, height/2)));
+
+        records.add(new FSButton(FSButton.Down, overShape.getIdentifier(), layer++, recess));
+        records.add(new FSButton(FSButton.Down, secondLabel.getIdentifier(), layer++, 
+            new FSCoordTransform(-width/2 + xShadow, height/2 + yShadow)));
+
+        /*
+         * FSDefineButton2 contains a series of FSButtonEvent objects that define 
+         * the eactions performed in response to different mouse events. As in 
+         * the previous example a web page will be loaded into the web browser 
+         * when the button is clicked.
+         */
+        actions.add(new FSGetUrl("http://www.flagstonesoftware.com", ""));
+    
+        events.add(new FSButtonEvent(FSButtonEvent.Release, actions));
+
+        FSDefineButton2 secondButton = new FSDefineButton2(movie.newIdentifier(), 
+            FSDefineButton2.Push, records, events);
+
+        FSDefineSound sound = soundGenerator.defineSound(movie.newIdentifier());
+        
+        FSButtonSound buttonSound = new FSButtonSound(secondButton.getIdentifier(), 
+            FSButtonEvent.Release, new FSSound(sound.getIdentifier(), 0));    
+
+        /***************************************************
+         *     Put all the objects together in a movie
+         ***************************************************/
+
+        /*
+         * Make the screen tall enough for a column of five buttons.
+         */
+        int screenWidth = buttonWidth + 2*screenMargin;
+        int rowHeight = buttonHeight + screenMargin;
+        
+        movie.setFrameSize(new FSBounds(0, 0, screenWidth, rowHeight*2));
+        movie.setFrameRate(1.0f);
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+
+        // Add the font definition for the text labels
+        movie.add(textGenerator.defineFont());
+
+        // Add the shapes used to define the buttons
+        movie.add(shadow);
+        movie.add(upShape);
+        movie.add(overShape);
+
+        // Add the first button and show it in the first row
+        movie.add(firstLabel);
+        movie.add(firstButton);
+
+        movie.add(new FSPlaceObject2(firstButton.getIdentifier(), layer++, 
+            screenWidth/2 , rowHeight/2));
+
+        // Add the second button and show it in the second row
+        movie.add(secondLabel);
+        movie.add(secondButton);
+
+        movie.add(sound);
+        movie.add(buttonSound);
+
+        movie.add(new FSPlaceObject2(secondButton.getIdentifier(), layer++, 
+            screenWidth/2 , rowHeight + rowHeight/2));
+
+        movie.add(new FSShowFrame());
+    }
+}

Added: trunk/src/com/flagstone/transform/examples/ConstructImages.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/ConstructImages.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/ConstructImages.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -0,0 +1,120 @@
+/*
+ *  ShowImage.java
+ *  Examples
+ *
+ *  Created by Stuart MacKay on Fri Jul 25 2003.
+ *  Copyright (c) 2001-2004 Flagstone Software Ltd. All rights reserved.
+ *
+ *  This code is distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ *  EXPRESS OR IMPLIED, AND Flagstone HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING
+ *  WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ *  PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ */
+package com.flagstone.transform.examples;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+import java.io.*;
+
+/*
+ * This example shows how image can be displayed using the FSImageConstructor.
+ *
+ * To run this example, type the following on a command line:
+ *
+ *     java com.flagstone.transform.examples.ConstructImages 
+ *         --file image-file [--resultDir path]
+ *     
+ * where
+ *
+ *     image-file is the path to a file containing either BMP, PNG or JPEG image.
+ *
+ *     resultDir is the directory where the Flash file generated by the example 
+ *     is written to.
+ *
+ * The name of the Flash file generated is the same as the image file with the 
+ * file extension replaced with a '.swf' suffix.
+ */
+public class ConstructImages extends Example
+{
+    private FSImageConstructor imageGenerator = null;  
+
+    public static void main(String[] args)
+    {
+        new ConstructImages(args);
+    }
+    
+    public ConstructImages(String[] args)
+    {
+        super(args);
+    
+        String imageFile = getOption("file", "");
+            
+        try 
+        {
+            /* Create the FSImageConstructor object used to generate the object
+             * containing the image definition. Initialize it using the name of 
+             * the image file passed on the command line when the exanple was run.
+             */
+            imageGenerator = new FSImageConstructor(imageFile);  
+            
+            /* Create the name of the Flash file generated using the name of the 
+             * font file - adding a '.swf' suffix.
+             */
+            int first = imageFile.lastIndexOf(File.separatorChar);
+            int last = imageFile.lastIndexOf('.');
+            
+            String fileOut = resultDir + File.separator + imageFile.substring(first, last) + ".swf";
+    
+            createMovie(imageFile);
+            
+            movie.encodeToFile(fileOut);
+        }
+        catch (Exception e)
+        {
+            /* Several exceptions could be thrown to get to this point. FSImageConstructor
+             * will throw a FileNotFoundException, IOException or DataFormatException 
+             * if the image format is not support or if an error occurs while
+             * loading and decoding the image data.
+             * 
+             * The FSMovie will throw a FileNotFoundException or IOException if 
+             * there is a problem generating the Flash file.
+             * 
+             * The exceptions are all caught in a single handler to make the code more 
+             * readable.
+             */
+            System.err.println("Cannot create movie for the image: " + imageFile);
+        }
+     }
+    
+    public void createMovie(String filename)
+    {
+        int imageId = movie.newIdentifier();
+        int shapeId = movie.newIdentifier();
+        
+        int xOrigin = imageGenerator.getWidth()/2;
+        int yOrigin = imageGenerator.getHeight()/2;
+        
+        // Generate the image defintion
+        FSDefineObject image = imageGenerator.defineImage(imageId);
+        
+        /*
+         * All images must be displayed as a bitmap fill inside a shape. The 
+         * FSImageConstructor class generates the shape enclosing the image.
+         * If no border is required then the line style may be set to null.
+         */
+        FSDefineShape3 shape = imageGenerator.defineEnclosingShape(shapeId, imageId, 
+            -xOrigin, -yOrigin, new FSSolidLine(20, FSColorTable.black()));
+        
+        /* 
+         * Add all the objects together to create the movie.
+         */
+        movie.setFrameRate(1.0f);
+        movie.setFrameSize(shape.getBounds());
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        movie.add(image);
+        movie.add(shape);
+        movie.add(new FSPlaceObject2(shapeId, 1, 0, 0));
+        movie.add(new FSShowFrame());
+    }
+}
\ No newline at end of file

Added: trunk/src/com/flagstone/transform/examples/ConstructShapes.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/ConstructShapes.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/ConstructShapes.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -0,0 +1,230 @@
+/*
+ *  BasicShapes.java
+ *  Examples
+ *
+ *  Created by Stuart MacKay on Fri Jul 25 2003.
+ *  Copyright (c) 2001-2004 Flagstone Software Ltd. All rights reserved.
+ *
+ *  This code is distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ *  EXPRESS OR IMPLIED, AND Flagstone HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING
+ *  WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ *  PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ */
+package com.flagstone.transform.examples;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+/*
+ * This example shows how the drawing commands available in the FSShapeConstructor
+ * can be used to draw simple geometic shapes and arbitrary paths. The example 
+ * draws a series of simple geometic shapes and discusses how the line and fill
+ * styles are specified to render the paths drawn.
+ *
+ * To run this example, type the following on a command line:
+ *
+ *     java com.flagstone.transform.examples.ConstructShapes [--resultDir path]
+ 
+ * where
+ *
+ *     resultDir is the directory where the Flash file generated by the example 
+ *     is written to. The file will be written to the directory where the example
+ *     was run if omitted.
+ */
+public class ConstructShapes extends Example
+{
+    public static void main(String[] args)
+    {
+        new ConstructShapes(args);
+    }
+    
+    public ConstructShapes(String[] args)
+    {
+        super(args);
+    
+        createMovie();
+    
+        writeFile("BasicShapes.swf");
+    }
+    
+    public void createMovie()
+    {
+        FSShapeConstructor path = new FSShapeConstructor();
+        
+        /* The FSShapeConstructor allows coordinates to be specified either 
+         * in twips or pixels. Pixels makes life a little easier.
+         */
+        path.COORDINATES_ARE_PIXELS = true;
+        
+        int width = 150;
+        int height = 100;
+        int cornerRadius = 10;
+        int identifier = 0;
+        
+        /* The line and fill styles used to render the shapes should be 
+         * specified before drawing starts. The line style is the most 
+         * important since the thickness of the line determines the size of 
+         * the bounding rectangle which must completely enclose the shape for 
+         * it to be drawn correctly - particularly if overlapped by other 
+         * shapes on different layers in the display list or when used to draw
+         * buttons.
+         * 
+         * Here the same line and fill styles are being used to draw each of the 
+         * shapes. More typically the line and fille styles would be set for 
+         * each of the shapes drawn. The class provides getLineStyles() and 
+         * getFillStyles() methods to access the line and fill style arrays 
+         * allowing tight control over reusing or replacing styles as each
+         * shape is drawn.
+         */
+        path.add(new FSSolidLine(20, FSColorTable.black()));
+        path.add(new FSSolidFill(FSColorTable.red()));
+        
+        movie.setFrameRate(1.0f);
+        movie.setFrameSize(new FSBounds(-4000, -4000, 4000, 4000));
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        
+        /* Draw a rectangle with the origin at the centre of the shape.
+         * 
+         * First select the line and fill styles by specifying the order of the
+         * styles added to the FSShapeConstructor earlier - the styles are stored
+         * in two arrays one for the line styles and one for the fill styles.
+         * 
+         * All the methods used to draw geometic shapes allow the origin of the
+         * shape to be specified. The coordinate system of the shape is separate
+         * from the coordinate system of the movie. Specifying the origin controls 
+         * how the shape is drawn relative to the point on the screen where it 
+         * is placed.
+         * 
+         * The identifier variable is reused for each shape definition since they
+         * are not referred to other than to place them on the display list using
+         * the FSPlaceObject2 class.
+         * 
+         * All the methods provided to draw geometic shapes are implemented
+         * using the methods that perform the basic drawing commands supported
+         * by the FSShapeConstructor class. For example the rect() method used 
+         * here is implemented as:
+         * 
+         * public void rect(int x, int y, int width, int height)
+         * {
+         *     newPath();
+         *     setStyle(0, 0);
+         *     move(x-width/2, y-height/2);
+         *     rline(width, 0);
+         *     rline(0, height);
+         *     rline(-width, 0);
+         *     rline(0, -height);
+         *     closePath();
+         * }
+         */
+        identifier = movie.newIdentifier();
+        
+        path.rect(width/2, -height/2, width, height);
+        
+        /* Add the shape definition to the movie, place on the display list
+         * and render the frame.
+         */
+        movie.add(path.defineShape(identifier));
+        movie.add(new FSPlaceObject2(identifier, 1, 0, 0));
+        movie.add(new FSShowFrame());
+        
+        /*
+         * Draw a rectangle with rounded corners.
+         * 
+         * Here the first drawing command is a call to newPath() which clears
+         * any path currently being drawn. It should be the first command before
+         * and drawing or style selections are made.
+         */
+        identifier = movie.newIdentifier();
+
+        path.rect(width/2, height/2, width, height, cornerRadius);
+        
+        movie.add(path.defineShape(identifier));
+        movie.add(new FSPlaceObject2(identifier, 1));
+        movie.add(new FSShowFrame());
+
+        /*
+         * Draw a circle
+         */
+        identifier = movie.newIdentifier();
+
+        path.circle(-width/2, height/2, height/2);
+        
+        movie.add(path.defineShape(identifier));
+        movie.add(new FSPlaceObject2(identifier, 1));
+        movie.add(new FSShowFrame());
+        
+        /*
+         * Draw a elipse
+         */
+        identifier = movie.newIdentifier();
+
+        path.ellipse(-width/2, -height/2, width/2, height/2);
+        
+        movie.add(path.defineShape(identifier));
+        movie.add(new FSPlaceObject2(identifier, 1));
+        movie.add(new FSShowFrame());
+        
+        /*
+         * Draw a polyline.
+         * 
+         * The first point of a polyline is a move relative to the current 
+         * drawing point - which for a new path is (0,0). While the geometic
+         * shapes drawn previous were all closed the polygon method can be 
+         * used to draw part of a shape so the newPath() and styles must be 
+         * explicitly specified to draw the shape.
+         */
+        identifier = movie.newIdentifier();
+
+        int[] points = new int[] { 
+            0, -100, 
+            10, 0, 
+            0, 90, 
+            90, 0, 
+            0, 20,
+            -90, 0,
+            0, 90,
+            -20, 0,
+            0, -90,
+            -90, 0,
+            0, -20,
+            90, 0,
+            0, -90,
+            10, 0
+        };
+
+        path.newPath();
+        path.selectStyle(0, 0);
+        path.polygon(points);
+        
+        movie.add(path.defineShape(identifier));
+        movie.add(new FSPlaceObject2(identifier, 1));
+        movie.add(new FSShowFrame());
+        
+        /*
+         * Draw a cubic bezier curve
+         * 
+         * This simple curve is included to show how cubic Bezier curves are 
+         * drawn. Flash only directly supports quadratic Bezier curves. Converting
+         * from cubic to quadratic is mathematically difficult so the cubic curve
+         * is flattened and drawn as a series of striaght lines. The results are 
+         * visually appealing and the slight increase in the size of the Flash 
+         * file is compensated for by the increase in drawing performance.
+         * 
+         * Note that the path is closed before the shape is generated. The 
+         * FSImageConstructor tracks the initial and current drawing points. When
+         * a closePath() call is made it draws a straight line (if required)
+         * between the current point and the initial point to ensure that the 
+         * shape is closed and will be rendered correctly.
+         */
+        identifier = movie.newIdentifier();
+
+        path.newPath();
+        path.selectStyle(0, 0);
+        path.curve(0, -100, 150, -100, 150, 0);
+        path.closePath();
+        
+        movie.add(path.defineShape(identifier));
+        movie.add(new FSPlaceObject2(identifier, 1));
+        movie.add(new FSShowFrame());
+    }
+}
\ No newline at end of file

Added: trunk/src/com/flagstone/transform/examples/ConstructSounds.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/ConstructSounds.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/ConstructSounds.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -0,0 +1,134 @@
+/*
+ *  BasicSounds.java
+ *  Examples
+ *
+ *  Created by Stuart MacKay on Fri Jun 06 2003.
+ *  Copyright (c) 2001-2004 Flagstone Software Ltd. All rights reserved.
+ *
+ *  This code is distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ *  EXPRESS OR IMPLIED, AND Flagstone HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING
+ *  WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ *  PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ */
+package com.flagstone.transform.examples;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+import java.io.*;
+
+/*
+ * This example shows how the FSSoundConstructor class can be used to generate
+ * the objects used to play a sound in a movie.
+ *
+ * To run this example, type the following on a command line:
+ *
+ *     java com.flagstone.transform.examples.ConstructSounds 
+ *         --file sound-file [--resultDir path]
+ *
+ * where
+ *
+ *     sound-file is the path to a file containing a WAVE or MP3 format sound.
+ *
+ *     resultDir is the directory where the Flash file generated by the example 
+ *     is written to.
+ *
+ */
+public class ConstructSounds extends Example
+{    
+    private FSSoundConstructor soundGenerator = null;
+
+    public static void main(String[] args)
+    {
+        new ConstructSounds(args);
+    }
+
+    public ConstructSounds(String[] args)
+    {
+        super(args);
+    
+        String soundFile = getOption("file", "");
+            
+        /* Create the name of the Flash file generated using the name of the 
+         * sound file - replaciing the file extension with '.swf'.
+         */
+        int first = soundFile.lastIndexOf(File.separatorChar);
+        int last = soundFile.lastIndexOf('.');
+            
+        String fileOut = resultDir + File.separator + soundFile.substring(first, last) + ".swf";
+    
+        try 
+        {
+            /* Create the FSSoundConstructor object used to generate the object
+             * that defines the sound. Initialize it using the name of the 
+             * sound file passed on the command line when the exanple was run.
+             */
+            soundGenerator = new FSSoundConstructor(soundFile);
+
+            createMovie();
+    
+            movie.encodeToFile(fileOut);
+        }
+        catch (Exception e)
+        {
+            /* Several exceptions could be thrown to get to this point. The 
+             * FSSoundConstructor will throw a FileNotFoundException, IOException 
+             * or DataFormatException if the sound is not the correct format or
+             * if an error occurs while loading the file and extracting the
+             * sound.
+             * 
+             * The FSMovie will throw a FileNotFoundException or IOException if 
+             * there is a problem generating the Flash file.
+             * 
+             * The exceptions are all caught in a single handler to make the code 
+             * more readable.
+             */
+            System.err.println("Cannot create file for sound:" + soundFile);
+        }
+    }
+    
+    void createMovie()
+    {
+        float framesPerSecond = 12.0f;
+        int soundId = movie.newIdentifier();
+
+        /*
+         * Calculate the time it takes to play the sound and the number of frames 
+         * this represents.
+         */
+        float duration = ((float) soundGenerator.getSamplesPerChannel()) / 
+            ((float) soundGenerator.getSampleRate());
+            
+        int numberOfFrames = (int) (duration * framesPerSecond);
+        
+        /*
+         * Add the sound definition and the FSStartSound object which is used to start
+         * the sound playing.
+         */
+        
+        //if (soundGenerator.getFormat() == FSSound.PCM)
+        //    soundGenerator.compressADPCM(5);
+        
+        FSDefineSound sound = soundGenerator.defineSound(soundId);
+        
+        /* 
+         * Add all the objects together to create the movie.
+         */
+        movie.setFrameSize(new FSBounds(0, 0, 8000, 4000));
+        movie.setFrameRate(framesPerSecond);
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        movie.add(sound);
+        
+        /*
+         * Signal the Flash Player to begin playing the sound.
+         */
+        movie.add(new FSStartSound(new FSSound(soundId, FSSound.Start)));
+
+        /* 
+         * Add enough frames to give the sound time to play.
+         */
+        for (int i=0; i<numberOfFrames; i++)
+            movie.add(new FSShowFrame());
+
+    }
+}
\ No newline at end of file

Added: trunk/src/com/flagstone/transform/examples/ConstructStreamingSounds.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/ConstructStreamingSounds.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/ConstructStreamingSounds.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -0,0 +1,119 @@
+/*
+ *  StreamingSounds.java
+ *  Examples
+ *
+ *  Created by Stuart MacKay on Fri Jun 06 2003.
+ *  Copyright (c) 2001-2004 Flagstone Software Ltd. All rights reserved.
+ *
+ *  This code is distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, 
+ *  EITHER EXPRESS OR IMPLIED, AND Flagstone HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
+ *  INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR 
+ *  A PARTICULAR PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ */
+package com.flagstone.transform.examples;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+import java.io.*;
+
+/*
+ * This example shows how the FSSoundConstructor class can be used to generate
+ * the objects used to play streaming sounds in a movie.
+ *
+ * For an example of how to play a sound in response to a button being clicked see
+ * the Buttons example.
+ *
+ * To run this example, type the following on a command line:
+ *
+ *     java com.flagstone.transform.examples.ConstructStreamingSounds 
+ *         --file sound-file [--resultDir path]
+ *
+ * where
+ *
+ *     sound-file is the path to a file containing a WAVE or MP3 format sound.
+ *
+ *     resultDir is the directory where the Flash file generated by the example 
+ *     is written to.
+ *
+ */
+public class ConstructStreamingSounds extends Example
+{
+    private FSSoundConstructor soundGenerator = null;
+
+    public static void main(String[] args)
+    {
+        new ConstructStreamingSounds(args);
+    }
+
+    public ConstructStreamingSounds(String[] args)
+    {
+        super(args);
+    
+        String soundFile = getOption("file", "");
+            
+        /* Create the name of the Flash file generated using the name of the 
+         * sound file - replaciing the file extension with '.swf'.
+         */
+        int first = soundFile.lastIndexOf(File.separatorChar);
+        int last = soundFile.lastIndexOf('.');
+        
+        String fileOut = soundFile.substring(first, last) + ".swf";
+    
+        try 
+        {
+            soundGenerator = new FSSoundConstructor(soundFile);
+        }
+        catch (Exception e)
+        {
+            /* Several exceptions could be thrown to get to this point. The 
+             * FSSoundConstructor will throw a FileNotFoundException, IOException 
+             * or DataFormatException if the sound is not the correct format or
+             * if an error occurs while loading the file and extracting the
+             * sound.
+             * 
+             * The exceptions are all caught in a single handler to make the code 
+             * more readable.
+             */
+            System.err.println("Cannot load sound file:" + soundFile);
+        }
+
+        createMovie();
+    
+        writeFile(fileOut);
+    }
+    
+    void createMovie()
+    {
+        float framesPerSecond = 12.0f;
+
+        /*
+         * Calculate the number of decoded sound samples played for each frame and
+         * the size, in bytes, of each block compressed sound data.
+         */
+        int samplesPerBlock = soundGenerator.getSampleRate() / (int) framesPerSecond;
+        int numberOfBlocks = soundGenerator.getSamplesPerChannel() / samplesPerBlock;
+
+        /* 
+         * Add all the objects together to create the movie.
+         */
+        movie.setFrameSize(new FSBounds(0, 0, 8000, 4000));
+        movie.setFrameRate(framesPerSecond);
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+
+        /* 
+         * An FSSoundStreamHeader2 object defines the attributes of the streaming sound.
+         */
+        movie.add(soundGenerator.streamHeader(samplesPerBlock));
+
+        /* 
+         * Add a streaming block for each frame so the sound is played as each frame 
+         * is displayed.
+         */
+        for (int i=0; i<numberOfBlocks; i++)
+        {
+            movie.add(soundGenerator.streamBlock(i, samplesPerBlock));
+            movie.add(new FSShowFrame());
+        }
+    }
+}
\ No newline at end of file

Added: trunk/src/com/flagstone/transform/examples/ConstructText.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/ConstructText.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/ConstructText.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -0,0 +1,174 @@
+/*
+ *  ShowAWTFonts.java
+ *  Examples
+ *
+ *  Created by Stuart MacKay on Wed Sep 03 2003.
+ *  Copyright (c) 2001-2004 Flagstone Software Ltd. All rights reserved.
+ *
+ *  This code is distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ *  EXPRESS OR IMPLIED, AND Flagstone HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING
+ *  WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+ *  PURPOSE, AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ */
+package com.flagstone.transform.examples;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+import java.io.*;
+import java.util.*;
+import java.awt.*;
+
+/*
+ * This example shows how the FSTextConstructor class can be used to generate a 
+ * font defintion using the fonts built into the Java AWT toolkit. The example
+ * loads the font definition and generates a movie displaying the first 2048 
+ * characters as a block of text containing 32 rows of 64 characters - enough
+ * to display all the characters displayed in Latin and Cyrillic fonts along
+ * with the majority of special characters and symbols.
+ *
+ * To run this example, type the following on a command line:
+ *
+ *     java com.flagstone.transform.examples.ConstructText [--resultDir path]
+ *
+ * where
+ *
+ *     resultDir is the directory where the Flash files generated by the example 
+ *     is written to. The files will be written to the directory where the example
+ *     was run if omitted.
+ *
+ * The example will generate one Flash file for each of the fonts available. The 
+ * names of the font will be used as the filename with a '.swf' suffix added.
+ */
+public class ConstructText extends Example
+{
+    private FSTextConstructor textGenerator = null;
+    
+    public static void main(String[] args)
+    {
+        new ConstructText(args);
+    }
+
+    public ConstructText(String[] args)
+    {
+        super(args);
+    
+        String fontName = null;
+        String fileOut = null;
+        
+        try 
+        {
+            Font[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
+            
+            for (int i=0; i<fonts.length; i++)
+            {
+                movie = new FSMovie();
+
+                fontName = fonts[i].getFontName();
+                fileOut = resultDir + File.separator + fontName + ".swf";
+                
+                /*
+                 * Font definitions for AWT fonts are created by specifying the name
+                 * of the font. Flash and OpenType/TrueType fonts are generated by 
+                 * specifying the name of the file containing the font definition.
+                 */
+                textGenerator = new FSTextConstructor(movie.newIdentifier(), fontName);
+
+                createMovie();
+    
+                movie.encodeToFile(fileOut);
+            }
+        }
+        catch (Exception e)
+        {
+            /* Several exceptions could be thrown to get to this point. FSTextConstructor
+             * will throw an IllegalArgumentException font cannot be loaded from the 
+             * graphics environment. The constructor will also throw a FileNotFoundException,
+             * IOException or DataFormatException if the font is being loaded from a file.
+             * 
+             * The FSMovie will throw a FileNotFoundException or IOException if there is a 
+             * problem creating the file.
+             * 
+             * The exceptions are all caught in a single handler to make the code more 
+             * readable.
+             */
+            System.err.println("Cannot create movie for the font: " + fontName);
+            
+            e.printStackTrace();
+        }
+    }
+        
+    void createMovie()
+    {
+        int layer = 0;                // Starting layer for objects in the display list.
+        int fontSize = 280;           // Font size in twips 1 point = 20 twips
+        int lineSpacing = fontSize;   // The font size defines a suitable line spacing
+        
+        /*
+         * The movie will be sized to match the block of text generated.
+         * The margins are defined so the text is displayed without touching
+         * the edge of the Flash Player screen.
+         */
+        int leftMargin = fontSize;
+        int rightMargin = fontSize;
+        int topMargin = fontSize;
+        int bottomMargin = fontSize;
+        
+        /* Create the strings that will be used to display the text. The first
+         * 2048 characters availalbe in the font will be shown as a block of
+         * 32 lines each containing 64 characters.
+         */
+        ArrayList lines = new ArrayList();
+        char c = 0;
+
+        for (int i=0; i<32; i++)
+        {
+            StringBuffer line = new StringBuffer();
+            
+            for (int j=0; j<64; j++, c++)
+            {
+                line.append((char)c);
+            }
+            lines.add(line.toString());
+        }
+        
+        /* The block of text is generated before the font definition. This ensures
+         * that only the characters displayed will be included in the font. Unused
+         * characters will be omitted, greatly reducing the size of the Flash file
+         * generated. Once the FSDefineFont2 object has been generated any text 
+         * objects created with characters not previously used, will not be 
+         * displayed correctly - a new font definition would need to be generated
+         * to include the new characters.
+         * 
+         * The FSDefineText2 object contains an array of FSText objects, each
+         * specifying an offset relative to the origin of the entire block. These
+         * can easily be changed if a line needs to be indented or the line spacing
+         * adjusted. 
+         */
+        FSDefineText2 text = textGenerator.defineTextBlock(movie.newIdentifier(), 
+            lines, fontSize, FSColorTable.black(), lineSpacing);
+            
+        FSDefineFont2 font = textGenerator.defineFont();
+
+        /* Define the size of the Flash Player screen using the bounding 
+         * rectangle defined for the block of text plus a suitable margin so 
+         * the text does not touch the edge of the screen.
+         */
+        int screenWidth = text.getBounds().getWidth() + leftMargin + rightMargin;
+        int screenHeight = text.getBounds().getHeight() + topMargin + bottomMargin;
+        
+        /* 
+         * Add all the objects together to create the movie. The origin of the 
+         * block of text (0,0) is the top left corner as viewed on the Flash 
+         * Player screen. The left and top margins offsets the text correctly
+         * from the edge of the screen.
+         */
+        movie.setFrameSize(new FSBounds(0, 0, screenWidth, screenHeight));
+        movie.setFrameRate(1.0f);
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        movie.add(font);
+        movie.add(text);
+        movie.add(new FSPlaceObject2(text.getIdentifier(), layer++, leftMargin , topMargin));
+        movie.add(new FSShowFrame());
+    }
+}

Modified: trunk/src/com/flagstone/transform/examples/Example.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/Example.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/Example.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -13,11 +13,11 @@
 
 package com.flagstone.transform.examples;
 
-import com.flagstone.transform.*;
 import java.util.*;
 import java.util.zip.*;
 import java.io.*;
 
+import com.flagstone.transform.*;
 /*
  * The Example class is used as a parent class for each of the examples that 
  * illustrate how different Flash features are generated using the Transform SWF
@@ -167,7 +167,7 @@
      * @return the int associated with the option or the default value if 
      * the option was not specified on the command line.
      */
-       public int getOption(String name, int defaultValue)
+    public int getOption(String name, int defaultValue)
     {
         int value = defaultValue;
         

Modified: trunk/src/com/flagstone/transform/examples/Import.java
===================================================================
--- trunk/src/com/flagstone/transform/examples/Import.java	2006-02-20 20:31:39 UTC (rev 60)
+++ trunk/src/com/flagstone/transform/examples/Import.java	2006-02-21 14:34:20 UTC (rev 61)
@@ -49,9 +49,6 @@
     
     public void createMovie()
     {
-        int width = 3200;
-        int height = 2400;
-    
         int fontSize = 240;
         int leading = 80;
 



From smackay at berlios.de  Tue Feb 21 15:49:01 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 15:49:01 +0100
Subject: [Transform-svn] r65 - in trunk/test/data: . images images/bmp images/bmp/bmpsuite-ref images/png
Message-ID: <200602211449.k1LEn1k3022509@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 15:45:21 +0100 (Tue, 21 Feb 2006)
New Revision: 65

Added:
   trunk/test/data/images/
   trunk/test/data/images/bmp/
   trunk/test/data/images/bmp/bmpsuite-ref/
   trunk/test/data/images/bmp/bmpsuite-ref/01bg.png
   trunk/test/data/images/bmp/bmpsuite-ref/01bw.png
   trunk/test/data/images/bmp/bmpsuite-ref/01p1.png
   trunk/test/data/images/bmp/bmpsuite-ref/04.png
   trunk/test/data/images/bmp/bmpsuite-ref/04p4.png
   trunk/test/data/images/bmp/bmpsuite-ref/08.png
   trunk/test/data/images/bmp/bmpsuite-ref/08p64.png
   trunk/test/data/images/bmp/bmpsuite-ref/08w124.png
   trunk/test/data/images/bmp/bmpsuite-ref/08w125.png
   trunk/test/data/images/bmp/bmpsuite-ref/08w126.png
   trunk/test/data/images/bmp/bmpsuite-ref/16bf555.png
   trunk/test/data/images/bmp/bmpsuite-ref/16bf565.png
   trunk/test/data/images/bmp/bmpsuite-ref/24.png
   trunk/test/data/images/bmp/bmpsuite-ref/reference.html
   trunk/test/data/images/bmp/g01bg.bmp
   trunk/test/data/images/bmp/g01bw.bmp
   trunk/test/data/images/bmp/g01p1.bmp
   trunk/test/data/images/bmp/g01wb.bmp
   trunk/test/data/images/bmp/g04.bmp
   trunk/test/data/images/bmp/g04p4.bmp
   trunk/test/data/images/bmp/g04rle.bmp
   trunk/test/data/images/bmp/g08.bmp
   trunk/test/data/images/bmp/g08offs.bmp
   trunk/test/data/images/bmp/g08os2.bmp
   trunk/test/data/images/bmp/g08p256.bmp
   trunk/test/data/images/bmp/g08p64.bmp
   trunk/test/data/images/bmp/g08pi256.bmp
   trunk/test/data/images/bmp/g08pi64.bmp
   trunk/test/data/images/bmp/g08res11.bmp
   trunk/test/data/images/bmp/g08res21.bmp
   trunk/test/data/images/bmp/g08res22.bmp
   trunk/test/data/images/bmp/g08rle.bmp
   trunk/test/data/images/bmp/g08s0.bmp
   trunk/test/data/images/bmp/g08w124.bmp
   trunk/test/data/images/bmp/g08w125.bmp
   trunk/test/data/images/bmp/g08w126.bmp
   trunk/test/data/images/bmp/g16bf555.bmp
   trunk/test/data/images/bmp/g16bf565.bmp
   trunk/test/data/images/bmp/g16def555.bmp
   trunk/test/data/images/bmp/g24.bmp
   trunk/test/data/images/bmp/g32bf.bmp
   trunk/test/data/images/bmp/g32def.bmp
   trunk/test/data/images/bmp/readme.txt
   trunk/test/data/images/png/
   trunk/test/data/images/png/basi0g01.png
   trunk/test/data/images/png/basi0g02.png
   trunk/test/data/images/png/basi0g04.png
   trunk/test/data/images/png/basi0g08.png
   trunk/test/data/images/png/basi0g16.png
   trunk/test/data/images/png/basi2c08.png
   trunk/test/data/images/png/basi2c16.png
   trunk/test/data/images/png/basi3p01.png
   trunk/test/data/images/png/basi3p02.png
   trunk/test/data/images/png/basi3p04.png
   trunk/test/data/images/png/basi3p08.png
   trunk/test/data/images/png/basi4a08.png
   trunk/test/data/images/png/basi4a16.png
   trunk/test/data/images/png/basi6a08.png
   trunk/test/data/images/png/basi6a16.png
   trunk/test/data/images/png/basn0g01.png
   trunk/test/data/images/png/basn0g02.png
   trunk/test/data/images/png/basn0g04.png
   trunk/test/data/images/png/basn0g08.png
   trunk/test/data/images/png/basn0g16.png
   trunk/test/data/images/png/basn2c08.png
   trunk/test/data/images/png/basn2c16.png
   trunk/test/data/images/png/basn3p01.png
   trunk/test/data/images/png/basn3p02.png
   trunk/test/data/images/png/basn3p04.png
   trunk/test/data/images/png/basn3p08.png
   trunk/test/data/images/png/basn4a08.png
   trunk/test/data/images/png/basn4a16.png
   trunk/test/data/images/png/basn6a08.png
   trunk/test/data/images/png/basn6a16.png
   trunk/test/data/images/png/bgai4a08.png
   trunk/test/data/images/png/bgai4a16.png
   trunk/test/data/images/png/bgan6a08.png
   trunk/test/data/images/png/bgan6a16.png
   trunk/test/data/images/png/bgbn4a08.png
   trunk/test/data/images/png/bggn4a16.png
   trunk/test/data/images/png/bgwn6a08.png
   trunk/test/data/images/png/bgyn6a16.png
   trunk/test/data/images/png/ccwn2c08.png
   trunk/test/data/images/png/ccwn3p08.png
   trunk/test/data/images/png/cdfn2c08.png
   trunk/test/data/images/png/cdhn2c08.png
   trunk/test/data/images/png/cdsn2c08.png
   trunk/test/data/images/png/cdun2c08.png
   trunk/test/data/images/png/ch1n3p04.png
   trunk/test/data/images/png/ch2n3p08.png
   trunk/test/data/images/png/cm0n0g04.png
   trunk/test/data/images/png/cm7n0g04.png
   trunk/test/data/images/png/cm9n0g04.png
   trunk/test/data/images/png/cs3n2c16.png
   trunk/test/data/images/png/cs3n3p08.png
   trunk/test/data/images/png/cs5n2c08.png
   trunk/test/data/images/png/cs5n3p08.png
   trunk/test/data/images/png/cs8n2c08.png
   trunk/test/data/images/png/cs8n3p08.png
   trunk/test/data/images/png/ct0n0g04.png
   trunk/test/data/images/png/ct1n0g04.png
   trunk/test/data/images/png/ctzn0g04.png
   trunk/test/data/images/png/f00n0g08.png
   trunk/test/data/images/png/f00n2c08.png
   trunk/test/data/images/png/f01n0g08.png
   trunk/test/data/images/png/f01n2c08.png
   trunk/test/data/images/png/f02n0g08.png
   trunk/test/data/images/png/f02n2c08.png
   trunk/test/data/images/png/f03n0g08.png
   trunk/test/data/images/png/f03n2c08.png
   trunk/test/data/images/png/f04n0g08.png
   trunk/test/data/images/png/f04n2c08.png
   trunk/test/data/images/png/g03n0g16.png
   trunk/test/data/images/png/g03n2c08.png
   trunk/test/data/images/png/g03n3p04.png
   trunk/test/data/images/png/g04n0g16.png
   trunk/test/data/images/png/g04n2c08.png
   trunk/test/data/images/png/g04n3p04.png
   trunk/test/data/images/png/g05n0g16.png
   trunk/test/data/images/png/g05n2c08.png
   trunk/test/data/images/png/g05n3p04.png
   trunk/test/data/images/png/g07n0g16.png
   trunk/test/data/images/png/g07n2c08.png
   trunk/test/data/images/png/g07n3p04.png
   trunk/test/data/images/png/g10n0g16.png
   trunk/test/data/images/png/g10n2c08.png
   trunk/test/data/images/png/g10n3p04.png
   trunk/test/data/images/png/g25n0g16.png
   trunk/test/data/images/png/g25n2c08.png
   trunk/test/data/images/png/g25n3p04.png
   trunk/test/data/images/png/oi1n0g16.png
   trunk/test/data/images/png/oi1n2c16.png
   trunk/test/data/images/png/oi2n0g16.png
   trunk/test/data/images/png/oi2n2c16.png
   trunk/test/data/images/png/oi4n0g16.png
   trunk/test/data/images/png/oi4n2c16.png
   trunk/test/data/images/png/oi9n0g16.png
   trunk/test/data/images/png/oi9n2c16.png
   trunk/test/data/images/png/pngsuite.doc
   trunk/test/data/images/png/pngsuite_logo.png
   trunk/test/data/images/png/pp0n2c16.png
   trunk/test/data/images/png/pp0n6a08.png
   trunk/test/data/images/png/ps1n0g08.png
   trunk/test/data/images/png/ps1n2c16.png
   trunk/test/data/images/png/ps2n0g08.png
   trunk/test/data/images/png/ps2n2c16.png
   trunk/test/data/images/png/s01i3p01.png
   trunk/test/data/images/png/s01n3p01.png
   trunk/test/data/images/png/s02i3p01.png
   trunk/test/data/images/png/s02n3p01.png
   trunk/test/data/images/png/s03i3p01.png
   trunk/test/data/images/png/s03n3p01.png
   trunk/test/data/images/png/s04i3p01.png
   trunk/test/data/images/png/s04n3p01.png
   trunk/test/data/images/png/s05i3p02.png
   trunk/test/data/images/png/s05n3p02.png
   trunk/test/data/images/png/s06i3p02.png
   trunk/test/data/images/png/s06n3p02.png
   trunk/test/data/images/png/s07i3p02.png
   trunk/test/data/images/png/s07n3p02.png
   trunk/test/data/images/png/s08i3p02.png
   trunk/test/data/images/png/s08n3p02.png
   trunk/test/data/images/png/s09i3p02.png
   trunk/test/data/images/png/s09n3p02.png
   trunk/test/data/images/png/s32i3p04.png
   trunk/test/data/images/png/s32n3p04.png
   trunk/test/data/images/png/s33i3p04.png
   trunk/test/data/images/png/s33n3p04.png
   trunk/test/data/images/png/s34i3p04.png
   trunk/test/data/images/png/s34n3p04.png
   trunk/test/data/images/png/s35i3p04.png
   trunk/test/data/images/png/s35n3p04.png
   trunk/test/data/images/png/s36i3p04.png
   trunk/test/data/images/png/s36n3p04.png
   trunk/test/data/images/png/s37i3p04.png
   trunk/test/data/images/png/s37n3p04.png
   trunk/test/data/images/png/s38i3p04.png
   trunk/test/data/images/png/s38n3p04.png
   trunk/test/data/images/png/s39i3p04.png
   trunk/test/data/images/png/s39n3p04.png
   trunk/test/data/images/png/s40i3p04.png
   trunk/test/data/images/png/s40n3p04.png
   trunk/test/data/images/png/tbbn1g04.png
   trunk/test/data/images/png/tbbn2c16.png
   trunk/test/data/images/png/tbbn3p08.png
   trunk/test/data/images/png/tbgn2c16.png
   trunk/test/data/images/png/tbgn3p08.png
   trunk/test/data/images/png/tbrn2c08.png
   trunk/test/data/images/png/tbwn1g16.png
   trunk/test/data/images/png/tbwn3p08.png
   trunk/test/data/images/png/tbyn3p08.png
   trunk/test/data/images/png/tp0n1g08.png
   trunk/test/data/images/png/tp0n2c08.png
   trunk/test/data/images/png/tp0n3p08.png
   trunk/test/data/images/png/tp1n3p08.png
   trunk/test/data/images/png/x00n0g01.png
   trunk/test/data/images/png/xcrn0g04.png
   trunk/test/data/images/png/xlfn0g04.png
   trunk/test/data/images/png/z00n2c08.png
   trunk/test/data/images/png/z03n2c08.png
   trunk/test/data/images/png/z06n2c08.png
   trunk/test/data/images/png/z09n2c08.png
Log:
test/data/images: Added test suites for bmp and png format images.


Property changes on: trunk/test/data/images
___________________________________________________________________
Name: svn:ignore
   + 
jpg


Added: trunk/test/data/images/bmp/bmpsuite-ref/01bg.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/01bg.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/01bw.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/01bw.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/01p1.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/01p1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/04p4.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/04p4.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/08p64.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/08p64.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/08w124.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/08w124.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/08w125.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/08w125.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/08w126.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/08w126.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/16bf555.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/16bf555.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/16bf565.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/16bf565.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/24.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/bmpsuite-ref/24.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/bmpsuite-ref/reference.html
===================================================================
--- trunk/test/data/images/bmp/bmpsuite-ref/reference.html	2006-02-21 14:42:31 UTC (rev 64)
+++ trunk/test/data/images/bmp/bmpsuite-ref/reference.html	2006-02-21 14:45:21 UTC (rev 65)
@@ -0,0 +1,73 @@
+<html>
+
+<head>
+<title>BMP Suite Reference Images</title>
+</head>
+
+<body>
+<h1>BMP Suite Reference Images</h1>
+
+<table border=1>
+<tr><th>File</th><th>bpp</th><th>Comments</th><th>Reference</th></tr>
+
+<tr><td>g01bw.bmp</td><td>1</td><td>black and white palette (#000000,#FFFFFF)</td><td rowspan=2><img src=01bw.png></td></tr>
+<tr><td>g01wb.bmp</td><td>1</td><td>white and black palette (#FFFFFF,#000000). Should look the same
+as g01bw, not inverted.</td></tr>
+<tr><td>g01bg.bmp</td><td>1</td><td>blue and green palette (#4040FF,#40FF40)</td><td><img src=01bg.png></td></tr>
+<tr><td>g01p1.bmp</td><td>1</td><td>1-color (blue) palette (#4040FF)</td><td><img src=01p1.png></td></tr>
+
+<tr><td>g04.bmp</td><td>4</td><td>basic 4bpp (16 color) image</td><td rowspan=2><img src=04.png></td></tr>
+<tr><td>g04rle.bmp</td><td>4</td><td>RLE compressed.</td></tr>
+<tr><td>g04p4.bmp</td><td>4</td><td>4-color grayscale palette</td><td><img src=04p4.png></td></tr>
+
+<tr><td>g08.bmp</td><td>8</td><td>basic 8bpp (256 color) image</td><td rowspan=11><img src=08.png></td></tr>
+<tr><td>g08p256.bmp</td><td>8</td><td>biClrUsed=256, biClrImportant=0 [=256]</td></tr>
+<tr><td>g08pi256.bmp</td><td>8</td><td>biClrUsed=256, biClrImportant=256</td></tr>
+<tr><td>g08pi64.bmp</td><td>8</td><td>biClrUsed=256, biClrImportant=64. It's barely
+possible that some sophisticated viewers may display this image in grayscale, if
+there are a limited number of colors available.</td></tr>
+<tr><td>g08rle.bmp</td><td>8</td><td>RLE compressed.</td></tr>
+<tr><td>g08os2.bmp</td><td>8</td><td>OS/2-style bitmap. This is an obsolete variety of
+BMP that is still encountered sometimes. It has 3-byte palette entries (instead of 4),
+and 16-bit width/height fields (instead of 32).</td></tr>
+<tr><td>g08res22.bmp</td><td>8</td><td>resolution 7874x7874 pixels/meter (200x200 dpi)</td></tr>
+<tr><td>g08res11.bmp</td><td>8</td><td>resolution 3937x3937 pixels/meter (100x100 dpi)</td></tr>
+<tr><td>g08res21.bmp</td><td>8</td><td>resolution 7874x3937 pixels/meter (200x100 dpi).
+Some programs (e.g. Imaging for Windows) may display this image stretched vertically, which is the
+optimal thing to do if the program is primarily a viewer, rather than an editor.</td></tr>
+<tr><td>g08s0.bmp</td><td>8</td><td>bits size not given (set to 0). This is
+legal for uncompressed bitmaps.</td></tr>
+<tr><td>g08offs.bmp</td><td>8</td><td>bfOffBits in header not set to the usual
+value. There are 100 extra unused bytes between palette and bits.</td></tr>
+<tr><td>g08w126.bmp</td><td>8</td><td>size 126x63 (right and bottom slightly clipped)</td><td><img src=08w126.png></td></tr>
+<tr><td>g08w125.bmp</td><td>8</td><td>size 125x62</td><td><img src=08w125.png></td></tr>
+<tr><td>g08w124.bmp</td><td>8</td><td>size 124x61</td><td><img src=08w124.png></td></tr>
+<tr><td>g08p64.bmp</td><td>8</td><td>64-color grayscale palette</td><td><img src=08p64.png></td></tr>
+
+<tr><td>g16def555.bmp</td><td>16</td><td>15-bit color (1 bit wasted),
+biCompression=BI_RGB (no bitfields, defaults to 5-5-5)</td>
+  <td rowspan=2><img src=16bf555.png></td></tr>
+<tr><td>g16bf555.bmp</td><td>16</td><td>15-bit color,
+biCompression=BI_BITFIELDS (bitfields indicate 5-5-5)</td></tr>
+<tr><td>g16bf565.bmp</td><td>16</td><td>16-bit color,
+biCompression=BI_BITFIELDS (bitfields indicate 5-6-5)</td>
+  <td><img src=16bf565.png></td></tr>
+
+<tr><td>g24.bmp</td><td>24</td><td>24-bit color (BGR)</td>
+  <td rowspan=3><img src=24.png></td></tr>
+
+<tr><td>g32def.bmp</td><td>32</td><td>24-bit color (8 bits wasted),
+biCompression=BI_RGB (no bitfields, defaults to BGRx)</td></tr>
+
+<tr><td>g32bf.bmp</td><td>32</td><td>24-bit color (8 bits wasted),
+biCompression=BI_BITFIELDS (bitfields indicate BGRx)</td></tr>
+
+
+</table>
+
+<hr>
+<p><small><i>By <a href="http://pobox.com/%7Ejason1/">Jason Summers</a>,
+4/2001</i></small></p>
+
+</body>
+</html>

Added: trunk/test/data/images/bmp/g01bg.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g01bg.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g01bw.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g01bw.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g01p1.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g01p1.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g01wb.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g01wb.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g04.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g04.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g04p4.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g04p4.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g04rle.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g04rle.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08offs.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08offs.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08os2.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08os2.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08p256.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08p256.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08p64.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08p64.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08pi256.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08pi256.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08pi64.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08pi64.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08res11.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08res11.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08res21.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08res21.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08res22.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08res22.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08rle.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08rle.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08s0.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08s0.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08w124.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08w124.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08w125.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08w125.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g08w126.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g08w126.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g16bf555.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g16bf555.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g16bf565.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g16bf565.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g16def555.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g16def555.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g24.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g24.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g32bf.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g32bf.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/g32def.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/bmp/g32def.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/bmp/readme.txt
===================================================================
--- trunk/test/data/images/bmp/readme.txt	2006-02-21 14:42:31 UTC (rev 64)
+++ trunk/test/data/images/bmp/readme.txt	2006-02-21 14:45:21 UTC (rev 65)
@@ -0,0 +1,38 @@
+BMP Suite - sample BMP image files
+By Jason Summers <jason1 at pobox.com>
+
+Version: 2001.04.27
+
+For more information: http://pobox.com/~jason1/bmpsuite/
+
+Contents
+--------
+
+g01bw.bmp
+g01wb.bmp
+g01bg.bmp
+g01p1.bmp
+g04.bmp
+g04p4.bmp
+g08.bmp
+g08offs.bmp
+g08os2.bmp
+g08w126.bmp
+g08w125.bmp
+g08w124.bmp
+g08p256.bmp
+g08pi256.bmp
+g08pi64.bmp
+g08res22.bmp
+g08res21.bmp
+g08res11.bmp
+g08p64.bmp
+g08s0.bmp
+g16def555.bmp
+g16bf555.bmp
+g16bf565.bmp
+g024.bmp
+g32def.bmp
+g32bf.bmp
+
+-- end --

Added: trunk/test/data/images/png/basi0g01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi0g01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi0g02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi0g02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi4a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi4a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi4a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi4a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi6a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi6a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basi6a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basi6a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn0g01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn0g01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn0g02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn0g02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn4a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn4a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn4a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn4a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn6a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn6a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/basn6a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/basn6a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgai4a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgai4a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgai4a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgai4a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgan6a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgan6a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgan6a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgan6a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgbn4a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgbn4a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bggn4a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bggn4a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgwn6a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgwn6a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/bgyn6a16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/bgyn6a16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ccwn2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ccwn2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ccwn3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ccwn3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cdfn2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cdfn2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cdhn2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cdhn2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cdsn2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cdsn2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cdun2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cdun2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ch1n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ch1n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ch2n3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ch2n3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cm0n0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cm0n0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cm7n0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cm7n0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cm9n0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cm9n0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cs3n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cs3n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cs3n3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cs3n3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cs5n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cs5n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cs5n3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cs5n3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cs8n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cs8n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/cs8n3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/cs8n3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ct0n0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ct0n0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ct1n0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ct1n0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ctzn0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ctzn0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f00n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f00n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f00n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f00n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f01n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f01n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f01n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f01n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f02n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f02n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f02n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f02n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f03n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f03n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f03n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f03n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f04n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f04n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/f04n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/f04n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g03n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g03n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g03n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g03n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g03n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g03n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g04n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g04n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g04n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g04n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g04n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g04n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g05n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g05n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g05n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g05n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g05n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g05n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g07n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g07n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g07n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g07n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g07n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g07n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g10n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g10n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g10n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g10n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g10n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g10n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g25n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g25n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g25n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g25n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/g25n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/g25n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi1n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi1n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi1n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi1n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi2n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi2n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi2n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi2n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi4n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi4n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi4n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi4n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi9n0g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi9n0g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/oi9n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/oi9n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/pngsuite.doc
===================================================================
--- trunk/test/data/images/png/pngsuite.doc	2006-02-21 14:42:31 UTC (rev 64)
+++ trunk/test/data/images/png/pngsuite.doc	2006-02-21 14:45:21 UTC (rev 65)
@@ -0,0 +1,520 @@
+        PNGSUITE
+----------------
+
+        testset for PNG-(de)coders
+        created by Willem van Schaik
+------------------------------------
+
+This is a collection of graphics images created to test the png applications
+like viewers, converters and editors. All (as far as that is possible)
+formats supported by the PNG standard are represented.
+
+
+1.      INTRODUCTION
+--------------------
+
+1.1     PNG capabilities
+------------------------
+
+Supported color-types are:
+
+        -   grayscale
+        -   grayscale + alpha-channel
+        -   color palettes
+        -   rgb
+        -   rgb + alpha-channel
+
+Allowed bitdepths are depending on the color-type, but are in the range
+of 1-bit (grayscale, which is b&w) upto 16-bits.
+
+Special features are:
+
+        -   interlacing (Adam-7)
+        -   gamma-support
+        -   transparency (a poor-man's alpha solution)
+
+
+1.2     File naming
+-------------------
+
+Where possible, the testfiles are 32x32 bits icons. This results in a still
+reasonable size of the suite even with a large number of tests. The name
+of each test-file reflects thetype in the following way:
+
+        g04i2c08.png
+        || |||+---- bit-depth
+        || ||+----- color-type (descriptive)
+        || |+------ color-type (numerical)
+        || +------- interlaced or non-interlaced
+        |+--------- parameter of test (in this case gamma-value)
+        +---------- test feature (in this case gamma)
+
+
+1.3     PNG formats
+-------------------
+
+color-type:
+        0g          -   grayscale
+        2c          -   rgb color
+        3p          -   paletted
+        4a          -   grayscale + alpha channel
+        6a          -   rgb color + alpha channel
+
+bit-depth:
+        01          -   with color-type 0, 3
+        02          -   with color-type 0, 3
+        04          -   with color-type 0, 3
+        08          -   with color-type 0, 2, 3, 4, 6
+        16          -   with color-type 0, 2, 4, 6
+
+interlacing:
+        n           -   non-interlaced
+        i           -   interlaced
+
+
+2.      THE TESTS
+-----------------
+
+2.1     Sizes
+-------------
+
+These tests are there to check if your software handles pictures well, with
+picture sizes that are not a multiple of 8. This is particularly important
+with Adam-7 type interlacing. In the same way these tests check if pictures
+size 1x1 and similar are ok.
+
+        s01         -   1x1 pixel picture
+        s02         -   2x2 pixel picture
+        s03         -   3x3 pixel picture
+        s04         -   4x4 pixel picture
+        s05         -   5x5 pixel picture
+        s06         -   6x6 pixel picture
+        s07         -   7x7 pixel picture
+        s08         -   8x8 pixel picture
+        s09         -   9x9 pixel picture
+        s32         -   32x32 pixel picture
+        s33         -   33x33 pixel picture
+        s34         -   34x34 pixel picture
+        s35         -   35x35 pixel picture
+        s36         -   36x36 pixel picture
+        s37         -   37x37 pixel picture
+        s38         -   38x38 pixel picture
+        s39         -   39x39 pixel picture
+        s40         -   40x40 pixel picture
+
+
+2.2     Background
+------------------
+
+When the PNG file contains a background chunck, this should be used for
+pictures with alpha-channel or pictures with a transparency chunck. For
+pictures without this background-chunk, but with alpha, this testset
+assumes a black background.
+
+For the images in this test, the left-side should be 100% the background
+color, where moving to the right the color should gradually become the
+image pattern.
+
+        bga         -   alpha + no background
+        bgw         -   alpha + white background
+        bgg         -   alpha + gray background
+        bgb         -   alpha + black background
+        bgy         -   alpha + yellow background
+
+
+2.3     Transparency
+--------------------
+
+Transparency should be used together with a background chunk. To test the
+combination of the two the latter 4 tests are there. How to handle pictures
+with transparancy, but without a background, opinions can differ. Here we
+use black, but especially in the case of paletted images, the normal color
+would maybe even be better.
+
+        tp0         -   not transparent for reference
+        tp1         -   transparent, but no background chunk
+        tbw         -   transparent + white background
+        tbg         -   transparent + gray background
+        tbb         -   transparent + black background
+        tby         -   transparent + yellow background
+
+
+2.4     Gamma
+-------------
+
+To test if your viewer handles gamma-correction, 6 testfiles are available.
+They contain corrected color-ramps and a corresponding gamma-chunk with the
+file-gamma value. These are created in such a way that when the viewer does
+the gamma correction right, all 6 should be displayed identical.
+
+If they are different, probably the gamma correction is omitted. In that
+case, have a look at the two right coloumns in the 6 pictures. The image
+where those two look the same (when looked from far) reflects the gamma of
+your system. However, because of the limited size of the image, you should
+do more elaborate tests to determine your display gamma.
+
+        g03         -   file-gamma = 0.35, for display with gamma = 2.8
+        g04         -   file-gamma = 0.45, for display with gamma = 2.2 (PC)
+        g05         -   file-gamma = 0.55, for display with gamma = 1.8 (Mac)
+        g07         -   file-gamma = 0.70, for display with gamma = 1.4
+        g10         -   file-gamma = 1.00, for display with gamma = 1.0 (NeXT)
+        g25         -   file-gamma = 2.50, for display with gamma = 0.4
+
+
+2.5     Filtering
+-----------------
+
+PNG uses file-filtering, for optimal compression. Normally the type is of
+filtering is adjusted to the contents of the picture, but here each file
+has the same picture, with a different filtering.
+
+        f0          -   no filtering
+        f1          -   sub filtering
+        f2          -   up filtering
+        f3          -   average filtering
+        f4          -   paeth filtering
+
+
+2.6     Additional palettes
+---------------------------
+
+Besides the normal use of paletted images, palette chunks can in combination
+with true-color (and other) images also be used to select color lookup-tables
+when the video system is of limited capabilities. The suggested palette chunk
+is specially created for this purpose.
+
+        pp          -   normal palette chunk
+        ps          -   suggested palette chunk
+
+
+2.7     Ancillary chunks (under construction)
+------------------------
+
+To test the correct decoding of ancillary chunks, these test-files contain
+one or more examples of these chunkcs. Depending on the type of chunk, a
+number of typical values are selected to test. Unluckily, the testset can
+not contain all combinations, because that would be an endless set.
+
+The significant bits are used in files with the next higher bit-depth. They
+indicate howmany bits are valid.
+
+        cs3         -   3 significant bits
+        cs5         -   5 significant bits
+        cs8         -   8 significant bits (reference)
+        cs3         -   13 significant bits
+
+For the physical pixel dimensions, the result of each decoding should be
+a sqare picture. The first (cdf) image is an example of flat (horizontal)
+pixels, where the pHYS chunk (x is 1 per unit, y = 4 per unit) must take
+care of the correction. The second is just the other way round. The last
+example uses the unit specifier, for 1000 pixels per meter. This should
+result in a picture of 3.2 cm square.
+
+        cdf         -   physical pixel dimensions, 8x32 flat pixels
+        cdh         -   physical pixel dimensions, 32x8 high pixels
+        cds         -   physical pixel dimensions, 8x8 square pixels
+        cdu         -   physical pixel dimensions, with unit-specifier
+
+        ccw         -   primary chromaticities and white point
+
+        ch1         -   histogram 15 colors
+        ch2         -   histogram 256 colors
+
+        cm7         -   modification time, 01-jan-1970
+        cm9         -   modification time, 31-dec-1999
+        cm0         -   modification time, 01-jan-2000
+
+In the textual chunk, a number of the standard, and some non-standard
+text items are included.
+
+        ct0         -   no textual data
+        ct1         -   with textual data
+        ctz         -   with compressed textual data
+
+
+2.8     Chunk ordering (still under construction)
+----------------------
+
+These testfiles will test the obligatory ordering relations between various
+chunk types (not yet) as well as the number of data chunks used for the image.
+
+        oi1         -   mother image with 1 idat-chunk
+        oi2         -   image with 2 idat-chunks
+        oi4         -   image with 4 unequal sized idat-chunks
+        oi9         -   all idat-chunks of length one
+
+
+2.9     Compression level
+-------------------------
+
+Here you will find a set of images compressed by zlib, ranging from level 0 
+for no compression at maximum speed upto level 9 for maximum compression.
+
+        z00         -   zlib compression level 0 - none
+        z03         -   zlib compression level 3
+        z06         -   zlib compression level 6 - default
+        z09         -   zlib compression level 9 - maximum
+
+
+2.10     Corrupted files (under construction)
+-----------------------
+
+All these files are illegal. When decoding they should generate appropriate
+error-messages.
+
+        x00         -   empty IDAT chunk
+        xcr         -   added cr bytes
+        xlf         -   added lf bytes
+        xc0         -   color type 0
+        xc9         -   color type 9
+        xd0         -   bit-depth 0
+        xd3         -   bit-depth 3
+        xd9         -   bit-depth 99
+        xcs         -   incorrect IDAT checksum
+
+
+3.      TEST FILES
+------------------
+
+For each of the tests listed above, one or more test-files are created. A
+selection is made (for each test) for the color-type and bitdepth to be used
+for the tests. Further for a number of tests, both a non-interlaced as well
+as an interlaced version is available.
+
+
+3.1     Basic format test files (non-interlaced)
+------------------------------------------------
+
+        basn0g01    -   black & white
+        basn0g02    -   2 bit (4 level) grayscale
+        basn0g04    -   4 bit (16 level) grayscale
+        basn0g08    -   8 bit (256 level) grayscale
+        basn0g16    -   16 bit (64k level) grayscale
+        basn2c08    -   3x8 bits rgb color
+        basn2c16    -   3x16 bits rgb color
+        basn3p01    -   1 bit (2 color) paletted
+        basn3p02    -   2 bit (4 color) paletted
+        basn3p04    -   4 bit (16 color) paletted
+        basn3p08    -   8 bit (256 color) paletted
+        basn4a08    -   8 bit grayscale + 8 bit alpha-channel
+        basn4a16    -   16 bit grayscale + 16 bit alpha-channel
+        basn6a08    -   3x8 bits rgb color + 8 bit alpha-channel
+        basn6a16    -   3x16 bits rgb color + 16 bit alpha-channel
+
+
+3.2     Basic format test files (Adam-7 interlaced)
+---------------------------------------------------
+
+        basi0g01    -   black & white
+        basi0g02    -   2 bit (4 level) grayscale
+        basi0g04    -   4 bit (16 level) grayscale
+        basi0g08    -   8 bit (256 level) grayscale
+        basi0g16    -   16 bit (64k level) grayscale
+        basi2c08    -   3x8 bits rgb color
+        basi2c16    -   3x16 bits rgb color
+        basi3p01    -   1 bit (2 color) paletted
+        basi3p02    -   2 bit (4 color) paletted
+        basi3p04    -   4 bit (16 color) paletted
+        basi3p08    -   8 bit (256 color) paletted
+        basi4a08    -   8 bit grayscale + 8 bit alpha-channel
+        basi4a16    -   16 bit grayscale + 16 bit alpha-channel
+        basi6a08    -   3x8 bits rgb color + 8 bit alpha-channel
+        basi6a16    -   3x16 bits rgb color + 16 bit alpha-channel
+
+
+3.3     Sizes test files
+-----------------------
+
+        s01n3p01    -   1x1 paletted file, no interlacing
+        s02n3p01    -   2x2 paletted file, no interlacing
+        s03n3p01    -   3x3 paletted file, no interlacing
+        s04n3p01    -   4x4 paletted file, no interlacing
+        s05n3p02    -   5x5 paletted file, no interlacing
+        s06n3p02    -   6x6 paletted file, no interlacing
+        s07n3p02    -   7x7 paletted file, no interlacing
+        s08n3p02    -   8x8 paletted file, no interlacing
+        s09n3p02    -   9x9 paletted file, no interlacing
+        s32n3p04    -   32x32 paletted file, no interlacing
+        s33n3p04    -   33x33 paletted file, no interlacing
+        s34n3p04    -   34x34 paletted file, no interlacing
+        s35n3p04    -   35x35 paletted file, no interlacing
+        s36n3p04    -   36x36 paletted file, no interlacing
+        s37n3p04    -   37x37 paletted file, no interlacing
+        s38n3p04    -   38x38 paletted file, no interlacing
+        s39n3p04    -   39x39 paletted file, no interlacing
+        s40n3p04    -   40x40 paletted file, no interlacing
+
+        s01i3p01    -   1x1 paletted file, interlaced
+        s02i3p01    -   2x2 paletted file, interlaced
+        s03i3p01    -   3x3 paletted file, interlaced
+        s04i3p01    -   4x4 paletted file, interlaced
+        s05i3p02    -   5x5 paletted file, interlaced
+        s06i3p02    -   6x6 paletted file, interlaced
+        s07i3p02    -   7x7 paletted file, interlaced
+        s08i3p02    -   8x8 paletted file, interlaced
+        s09i3p02    -   9x9 paletted file, interlaced
+        s32i3p04    -   32x32 paletted file, interlaced
+        s33i3p04    -   33x33 paletted file, interlaced
+        s34i3p04    -   34x34 paletted file, interlaced
+        s35i3p04    -   35x35 paletted file, interlaced
+        s36i3p04    -   36x36 paletted file, interlaced
+        s37i3p04    -   37x37 paletted file, interlaced
+        s38i3p04    -   38x38 paletted file, interlaced
+        s39i3p04    -   39x39 paletted file, interlaced
+        s40i3p04    -   40x40 paletted file, interlaced
+
+
+3.4     Background test files (with alpha)
+------------------------------------------
+
+        bgai4a08    -   8 bit grayscale, alpha, no background chunk, interlaced
+        bgai4a16    -   16 bit grayscale, alpha, no background chunk, interlaced
+        bgan6a08    -   3x8 bits rgb color, alpha, no background chunk
+        bgan6a16    -   3x16 bits rgb color, alpha, no background chunk
+
+        bgbn4a08    -   8 bit grayscale, alpha, black background chunk
+        bggn4a16    -   16 bit grayscale, alpha, gray background chunk
+        bgwn6a08    -   3x8 bits rgb color, alpha, white background chunk
+        bgyn6a16    -   3x16 bits rgb color, alpha, yellow background chunk
+
+
+3.5     Transparency (and background) test files
+------------------------------------------------
+
+        tp0n1g08    -   not transparent for reference (logo on gray)
+        tbbn1g04    -   transparent, black background chunk
+        tbwn1g16    -   transparent, white background chunk
+        tp0n2c08    -   not transparent for reference (logo on gray)
+        tbrn2c08    -   transparent, red background chunk
+        tbgn2c16    -   transparent, green background chunk
+        tbbn2c16    -   transparent, blue background chunk
+        tp0n3p08    -   not transparent for reference (logo on gray)
+        tp1n3p08    -   transparent, but no background chunk
+        tbbn3p08    -   transparent, black background chunk
+        tbgn3p08    -   transparent, light-gray background chunk
+        tbwn3p08    -   transparent, white background chunk
+        tbyn3p08    -   transparent, yellow background chunk
+
+
+3.6     Gamma test files
+------------------------
+
+        g03n0g16    -   grayscale, file-gamma = 0.35
+        g04n0g16    -   grayscale, file-gamma = 0.45
+        g05n0g16    -   grayscale, file-gamma = 0.55
+        g07n0g16    -   grayscale, file-gamma = 0.70
+        g10n0g16    -   grayscale, file-gamma = 1.00
+        g25n0g16    -   grayscale, file-gamma = 2.50
+        g03n2c08    -   color, file-gamma = 0.35
+        g04n2c08    -   color, file-gamma = 0.45
+        g05n2c08    -   color, file-gamma = 0.55
+        g07n2c08    -   color, file-gamma = 0.70
+        g10n2c08    -   color, file-gamma = 1.00
+        g25n2c08    -   color, file-gamma = 2.50
+        g03n3p04    -   paletted, file-gamma = 0.35
+        g04n3p04    -   paletted, file-gamma = 0.45
+        g05n3p04    -   paletted, file-gamma = 0.55
+        g07n3p04    -   paletted, file-gamma = 0.70
+        g10n3p04    -   paletted, file-gamma = 1.00
+        g25n3p04    -   paletted, file-gamma = 2.50
+
+
+3.7     Filtering test files
+----------------------------
+
+        f00n0g08    -   grayscale, no interlacing, filter-type 0
+        f01n0g08    -   grayscale, no interlacing, filter-type 1
+        f02n0g08    -   grayscale, no interlacing, filter-type 2
+        f03n0g08    -   grayscale, no interlacing, filter-type 3
+        f04n0g08    -   grayscale, no interlacing, filter-type 4
+        f00n2c08    -   color, no interlacing, filter-type 0
+        f01n2c08    -   color, no interlacing, filter-type 1
+        f02n2c08    -   color, no interlacing, filter-type 2
+        f03n2c08    -   color, no interlacing, filter-type 3
+        f04n2c08    -   color, no interlacing, filter-type 4
+
+
+3.8     Additional palette chunk test files
+-------------------------------------------
+
+        pp0n2c16    -   six-cube palette-chunk in true-color image
+        pp0n6a08    -   six-cube palette-chunk in true-color+alpha image
+        ps1n0g08    -   six-cube suggested palette (1 byte) in grayscale image
+        ps1n2c16    -   six-cube suggested palette (1 byte) in true-color image
+        ps2n0g08    -   six-cube suggested palette (2 bytes) in grayscale image
+        ps2n2c16    -   six-cube suggested palette (2 bytes) in true-color image
+
+
+3.9     Ancillary chunks test files
+-----------------------------------
+
+        cs5n2c08    -   color, 5 significant bits
+        cs8n2c08    -   color, 8 significant bits (reference)
+        cs3n2c16    -   color, 13 significant bits
+        cs3n3p08    -   paletted, 3 significant bits
+        cs5n3p08    -   paletted, 5 significant bits
+        cs8n3p08    -   paletted, 8 significant bits (reference)
+
+        cdfn2c08    -   physical pixel dimensions, 8x32 flat pixels
+        cdhn2c08    -   physical pixel dimensions, 32x8 high pixels
+        cdsn2c08    -   physical pixel dimensions, 8x8 square pixels
+        cdun2c08    -   physical pixel dimensions, 1000 pixels per 1 meter
+
+        ccwn2c08    -   chroma chunk w:0.3127,0.3290 r:0.64,0.33 g:0.30,0.60 b:0.15,0.06
+        ccwn3p08    -   chroma chunk w:0.3127,0.3290 r:0.64,0.33 g:0.30,0.60 b:0.15,0.06
+
+        ch1n3p04    -   histogram 15 colors
+        ch2n3p08    -   histogram 256 colors
+
+        cm7n0g04    -   modification time, 01-jan-1970 00:00:00
+        cm9n0g04    -   modification time, 31-dec-1999 23:59:59
+        cm0n0g04    -   modification time, 01-jan-2000 12:34:56
+
+        ct0n0g04    -   no textual data
+        ct1n0g04    -   with textual data
+        ctzn0g04    -   with compressed textual data
+
+
+
+3.10    Chunk ordering
+----------------------
+
+        oi1n0g16    -   grayscale mother image with 1 idat-chunk
+        oi2n0g16    -   grayscale image with 2 idat-chunks
+        oi4n0g16    -   grayscale image with 4 unequal sized idat-chunks
+        oi9n0g16    -   grayscale image with all idat-chunks length one
+        oi1n2c16    -   color mother image with 1 idat-chunk
+        oi2n2c16    -   color image with 2 idat-chunks
+        oi4n2c16    -   color image with 4 unequal sized idat-chunks
+        oi9n2c16    -   color image with all idat-chunks length one
+
+
+
+3.11    Compression level
+-------------------------
+
+        z00n2c08    -   color, no interlacing, compression level 0 (none)
+        z03n2c08    -   color, no interlacing, compression level 3
+        z06n2c08    -   color, no interlacing, compression level 6 (default)
+        z09n2c08    -   color, no interlacing, compression level 9 (maximum)
+
+
+
+3.12     Currupted files
+-----------------------
+
+        x00n0g01    -   empty 0x0 grayscale file
+        xcrn0g04    -   added cr bytes
+        xlfn0g04    -   added lf bytes
+        xc0n0c08    -   color type 0
+        xc9n0c08    -   color type 9
+        xd0n2c00    -   bit-depth 0
+        xd3n2c03    -   bit-depth 3
+        xd9n2c99    -   bit-depth 99
+        xcsn2c08    -   incorrect IDAT checksum
+
+
+--------
+    (c) Willem van Schaik
+        willem at schaik.com
+        Singapore, October 1996

Added: trunk/test/data/images/png/pngsuite_logo.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/pngsuite_logo.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/pp0n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/pp0n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/pp0n6a08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/pp0n6a08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ps1n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ps1n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ps1n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ps1n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ps2n0g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ps2n0g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/ps2n2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/ps2n2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s01i3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s01i3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s01n3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s01n3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s02i3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s02i3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s02n3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s02n3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s03i3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s03i3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s03n3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s03n3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s04i3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s04i3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s04n3p01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s04n3p01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s05i3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s05i3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s05n3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s05n3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s06i3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s06i3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s06n3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s06n3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s07i3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s07i3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s07n3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s07n3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s08i3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s08i3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s08n3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s08n3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s09i3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s09i3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s09n3p02.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s09n3p02.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s32i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s32i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s32n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s32n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s33i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s33i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s33n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s33n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s34i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s34i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s34n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s34n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s35i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s35i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s35n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s35n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s36i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s36i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s36n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s36n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s37i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s37i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s37n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s37n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s38i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s38i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s38n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s38n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s39i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s39i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s39n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s39n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s40i3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s40i3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/s40n3p04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/s40n3p04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbbn1g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbbn1g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbbn2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbbn2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbbn3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbbn3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbgn2c16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbgn2c16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbgn3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbgn3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbrn2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbrn2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbwn1g16.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbwn1g16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbwn3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbwn3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tbyn3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tbyn3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tp0n1g08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tp0n1g08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tp0n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tp0n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tp0n3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tp0n3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/tp1n3p08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/tp1n3p08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/x00n0g01.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/x00n0g01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/xcrn0g04.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/xcrn0g04.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/xlfn0g04.png
===================================================================
--- trunk/test/data/images/png/xlfn0g04.png	2006-02-21 14:42:31 UTC (rev 64)
+++ trunk/test/data/images/png/xlfn0g04.png	2006-02-21 14:45:21 UTC (rev 65)
@@ -0,0 +1,13 @@
+?PNG
+
+
+
+
+
+IHDR  ???)?IDATx?]??
+?0P*@??#?
+
+#T??10lPF`??F=???IQ?*??u??`%qk?
+H????????m???????	??=,?f?OK
+
+???t??(???????F;?P????{xp?]9?/p?*$(?*?y??????????@?C? 	c?q??N?U#?)11?.??r??f?0???gh(??t???E???kIEND?B`?
\ No newline at end of file

Added: trunk/test/data/images/png/z00n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/z00n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/z03n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/z03n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/z06n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/z06n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/test/data/images/png/z09n2c08.png
===================================================================
(Binary files differ)


Property changes on: trunk/test/data/images/png/z09n2c08.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From smackay at berlios.de  Tue Feb 21 18:49:40 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 18:49:40 +0100
Subject: [Transform-svn] r67 - trunk/src/com/flagstone/transform/test
Message-ID: <200602211749.k1LHneaP024555@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 18:49:30 +0100 (Tue, 21 Feb 2006)
New Revision: 67

Modified:
   trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java
   trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
Log:
Updated findFiles so files with upper case extensions are caught.
Also able return cleanly if the source directory does not exist.

Modified: trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java	2006-02-21 14:49:54 UTC (rev 66)
+++ trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java	2006-02-21 17:49:30 UTC (rev 67)
@@ -54,17 +54,25 @@
     {
         FilenameFilter filter = new FilenameFilter() 
         {
-            public boolean accept(File directory, String name) {
-                return name.endsWith(extension);
+            public boolean accept(File directory, String name) 
+            {
+                String ext = name.substring(name.length()-extension.length()).toLowerCase();
+                
+                return ext.equals(extension);
             }
         };
         
-        String[] files = sourceDir.list(filter);
-        Object[][] parameters = new Object[files.length][1];
+        Object[][] parameters = new Object[0][0];
         
-        for (int i=0; i<files.length; i++)
-            parameters[i] = new Object[] { new File(sourceDir, files[i]) };
-        
+        if (sourceDir.exists())
+        {
+            String[] files = sourceDir.list(filter);
+            
+            parameters = new Object[files.length][1];
+            
+            for (int i=0; i<files.length; i++)
+                parameters[i] = new Object[] { new File(sourceDir, files[i]) };
+        }
         return parameters;
     }
     private void encodeImageToFile(FSImageConstructor generator, File file) throws Exception

Modified: trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2006-02-21 14:49:54 UTC (rev 66)
+++ trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2006-02-21 17:49:30 UTC (rev 67)
@@ -81,17 +81,25 @@
     {
         FilenameFilter filter = new FilenameFilter() 
         {
-            public boolean accept(File directory, String name) {
-                return name.endsWith(extension);
+            public boolean accept(File directory, String name) 
+            {
+                String ext = name.substring(name.length()-extension.length()).toLowerCase();
+                
+                return ext.equals(extension);
             }
         };
         
-        String[] files = sourceDir.list(filter);       
-
-        Object[][] parameters = new Object[files.length][1];
+        Object[][] parameters = new Object[0][0];
         
-        for (int i=0; i<files.length; i++)
-            parameters[i] = new Object[] { files[i] };
+        if (sourceDir.exists())
+        {
+            String[] files = sourceDir.list(filter);       
+    
+            parameters = new Object[files.length][1];
+            
+            for (int i=0; i<files.length; i++)
+                parameters[i] = new Object[] { files[i] };
+        }
         
         return parameters;
     }



From smackay at berlios.de  Tue Feb 21 18:50:22 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 18:50:22 +0100
Subject: [Transform-svn] r68 - trunk/src/com/flagstone/transform/util
Message-ID: <200602211750.k1LHoMvW025502@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 18:50:13 +0100 (Tue, 21 Feb 2006)
New Revision: 68

Modified:
   trunk/src/com/flagstone/transform/util/FSTextConstructor.java
Log:
Font files with upper case files names are now handled.

Modified: trunk/src/com/flagstone/transform/util/FSTextConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2006-02-21 17:49:30 UTC (rev 67)
+++ trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2006-02-21 17:50:13 UTC (rev 68)
@@ -342,11 +342,11 @@
         for (int i=0; i<65536; i++)
             orderTable[i] = -1;
             
-        if (fontName.endsWith(".swf"))
+        if (fontName.toLowerCase().endsWith(".swf"))
             decodeSWFFont(fontName);
-        else if (fontName.endsWith(".otf"))
+        else if (fontName.toLowerCase().endsWith(".otf"))
             decodeOpenTypeFont(fontName);
-        else if (fontName.endsWith(".ttf"))
+        else if (fontName.toLowerCase().endsWith(".ttf"))
             decodeOpenTypeFont(fontName);
         else
              decodeAWTFont(fontName);



From smackay at berlios.de  Tue Feb 21 18:51:17 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 18:51:17 +0100
Subject: [Transform-svn] r69 - trunk/test/suites
Message-ID: <200602211751.k1LHpH4b026897@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 18:51:13 +0100 (Tue, 21 Feb 2006)
New Revision: 69

Modified:
   trunk/test/suites/FSImageConstructor.xml
Log:
Updated paths to test files. Added a suite for bmp images.

Modified: trunk/test/suites/FSImageConstructor.xml
===================================================================
--- trunk/test/suites/FSImageConstructor.xml	2006-02-21 17:50:13 UTC (rev 68)
+++ trunk/test/suites/FSImageConstructor.xml	2006-02-21 17:51:13 UTC (rev 69)
@@ -1,9 +1,18 @@
 <!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
   
-<suite name="FSImageConstructorTest" verbose="10">
+<suite name="FSImageConstructorTest">
 
+    <test name="BMP Images">
+		<parameter name="srcDir" value="test/data/images/bmp"/>
+		<parameter name="dstDir" value="test/results/FSImageConstructor/jpg"/>
+		<parameter name="ext" value="jpg"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSImageConstructorTest"/>
+		</classes>
+  	</test>
+  	
     <test name="JPG Images">
-		<parameter name="srcDir" value="test/data/files/jpg"/>
+		<parameter name="srcDir" value="test/data/images/jpg"/>
 		<parameter name="dstDir" value="test/results/FSImageConstructor/jpg"/>
 		<parameter name="ext" value="jpg"/>
 		<classes>
@@ -12,7 +21,7 @@
   	</test>
   	
     <test name="PNG Images">
-		<parameter name="srcDir" value="test/data/files/png"/>
+		<parameter name="srcDir" value="test/data/images/png"/>
 		<parameter name="dstDir" value="test/results/FSImageConstructor/png"/>
 		<parameter name="ext" value="png"/>
 		<classes>



From smackay at berlios.de  Tue Feb 21 18:52:01 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 18:52:01 +0100
Subject: [Transform-svn] r70 - trunk/test/suites
Message-ID: <200602211752.k1LHq19w027385@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 18:51:50 +0100 (Tue, 21 Feb 2006)
New Revision: 70

Modified:
   trunk/test/suites/FSTextConstructor.xml
Log:
Added a test for fonts installed on windows systems.

Modified: trunk/test/suites/FSTextConstructor.xml
===================================================================
--- trunk/test/suites/FSTextConstructor.xml	2006-02-21 17:51:13 UTC (rev 69)
+++ trunk/test/suites/FSTextConstructor.xml	2006-02-21 17:51:50 UTC (rev 70)
@@ -1,14 +1,14 @@
 <!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
   
-<suite name="FSTextConstructorTest" verbose="10">
+<suite name="FSTextConstructorTest">
 
 	<parameter name="srcDir" value=""/>
 	<parameter name="dstDir" value=""/>
 	<parameter name="ext" value=""/>
 
-    <test name="TTF Fonts">
-		<parameter name="srcDir" value="test/data/files/ttf"/>
-		<parameter name="dstDir" value="test/results/FSTextConstructor/ttf"/>
+    <test name="TTF Fonts From OrgDot">
+		<parameter name="srcDir" value="test/data/fonts/orgdot"/>
+		<parameter name="dstDir" value="test/results/FSTextConstructor/orgdot"/>
 		<parameter name="ext" value="ttf"/>
 		<classes>
       		<class name="com.flagstone.transform.test.FSTextConstructorTest">
@@ -19,6 +19,32 @@
 		</classes>
   	</test>
   	
+    <test name="TTF Fonts From the Bitstream Vera collection">
+		<parameter name="srcDir" value="test/data/fonts/vera"/>
+		<parameter name="dstDir" value="test/results/FSTextConstructor/vera"/>
+		<parameter name="ext" value="ttf"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSTextConstructorTest">
+      		    <methods>
+      				<include name="displayTrueTypeFont" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+  	
+    <test name="TTF Fonts Installed in Windows">
+		<parameter name="srcDir" value="/windows/fonts"/>
+		<parameter name="dstDir" value="test/results/FSTextConstructor/windows"/>
+		<parameter name="ext" value="ttf"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSTextConstructorTest">
+      		    <methods>
+      				<include name="displayTrueTypeFont" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+  	
     <test name="AWT Fonts">
 		<parameter name="dstDir" value="test/results/FSTextConstructor/awt"/>
 		<classes>



From smackay at berlios.de  Tue Feb 21 19:11:22 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 19:11:22 +0100
Subject: [Transform-svn] r71 - in trunk: src/com/flagstone/transform/test test/suites
Message-ID: <200602211811.k1LIBMZT000369@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 19:11:14 +0100 (Tue, 21 Feb 2006)
New Revision: 71

Added:
   trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java
   trunk/test/suites/FSSoundConstructor.xml
Log:
Added a test for FSSoundConstructor.

Added: trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java	2006-02-21 17:51:50 UTC (rev 70)
+++ trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java	2006-02-21 18:11:14 UTC (rev 71)
@@ -0,0 +1,177 @@
+package com.flagstone.transform.test;
+
+import java.io.*;
+import java.util.*;
+import java.awt.*;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+public class FSSoundConstructorTest
+{
+    private File sourceDir = null;
+    private File destDir = null;
+    private String extension = null;
+    
+    public FSSoundConstructorTest()
+    {
+    }
+    /**
+     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
+     * @testng.parameters value = "srcDir dstDir ext"
+     */
+    public void configure(String srcDir, String dstDir, String ext)
+    {
+        sourceDir = new File(srcDir);
+        destDir = new File(dstDir);
+        extension = ext;
+    }
+	/**
+     * @testng.test dataProvider="files"
+	 */
+    public void playEventSound(String sndFile)
+    {
+        try 
+        {
+            File srcFile = new File(sourceDir, sndFile);
+            File destFile = new File(destDir, sndFile.substring(0, sndFile.lastIndexOf('.')) + ".swf");
+ 
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            FSSoundConstructor soundGenerator = new FSSoundConstructor(srcFile.getPath());
+            encodeEventSoundToFile(soundGenerator, destFile);
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+    /**
+     * @testng.test dataProvider="files"
+     */
+    public void playStreamingSound(String sndFile)
+    {
+        try 
+        {
+            File srcFile = new File(sourceDir, sndFile);
+            File destFile = new File(destDir, sndFile.substring(0, sndFile.lastIndexOf('.')) + ".swf");
+ 
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            FSSoundConstructor soundGenerator = new FSSoundConstructor(srcFile.getPath());
+            encodeStreamingSoundToFile(soundGenerator, destFile);
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+    /**
+     * @testng.data-provider name="files"
+     */
+    public Object[][] findFiles()
+    {
+        FilenameFilter filter = new FilenameFilter() 
+        {
+            public boolean accept(File directory, String name) 
+            {
+                String ext = name.substring(name.length()-extension.length()).toLowerCase();
+                
+                return ext.equals(extension);
+            }
+        };
+        
+        Object[][] parameters = new Object[0][0];
+        
+        if (sourceDir.exists())
+        {
+            String[] files = sourceDir.list(filter);       
+    
+            parameters = new Object[files.length][1];
+            
+            for (int i=0; i<files.length; i++)
+                parameters[i] = new Object[] { files[i] };
+        }
+        
+        return parameters;
+    }
+      
+    private void encodeEventSoundToFile(FSSoundConstructor soundGenerator, File file) throws Exception
+    {
+        FSMovie movie = new FSMovie();
+        
+        float framesPerSecond = 12.0f;
+
+        movie.setFrameSize(new FSBounds(0, 0, 8000, 4000));
+        movie.setFrameRate(framesPerSecond);
+    
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+
+        int soundId = movie.newIdentifier();
+
+        /*
+         * Calculate the time it takes to play the sound and the number of frames this
+         * represents.
+         */
+        float duration = ((float) soundGenerator.getSamplesPerChannel()) / ((float) soundGenerator.getSampleRate());
+        int numberOfFrames = (int) (duration * framesPerSecond);
+        
+        /*
+         * Add the sound definition and the FSStartSound object which is used to start
+         * the sound playing.
+         */
+        
+        FSDefineSound sound = soundGenerator.defineSound(soundId);
+        
+        movie.add(sound);
+        movie.add(new FSStartSound(new FSSound(soundId, FSSound.Start)));
+
+        /* 
+         * Add frames to give the sound time to play.
+         */
+        for (int j=0; j<numberOfFrames; j++)
+            movie.add(new FSShowFrame());
+
+        movie.encodeToFile(file.getPath());
+    }
+    private void encodeStreamingSoundToFile(FSSoundConstructor soundGenerator, File file) throws Exception
+    {
+        float framesPerSecond = 12.0f;
+
+        FSMovie movie = new FSMovie();
+
+        movie.setFrameSize(new FSBounds(0, 0, 8000, 4000));
+        movie.setFrameRate(framesPerSecond);
+    
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+
+        /*
+         * Play the Streaming Sound.
+         *
+         * Calculate the number of decoded sound samples played for each frame and
+         * the size, in bytes, of each block compressed sound data.
+         */
+        int samplesPerBlock = soundGenerator.getSampleRate() / (int) framesPerSecond;
+        int numberOfBlocks = soundGenerator.getSamplesPerChannel() / samplesPerBlock;
+
+        /* 
+         * An FSSoundStreamHeader2 object defines the attributes of the streaming sound.
+         */
+        movie.add(soundGenerator.streamHeader(samplesPerBlock));
+
+        /* 
+         * Add a streaming block for each frame so the sound is played as each frame 
+         * is displayed.
+         */
+        for (int j=0; j<numberOfBlocks; j++)
+        {
+            movie.add(soundGenerator.streamBlock(j, samplesPerBlock));
+            movie.add(new FSShowFrame());
+        }
+
+        movie.encodeToFile(file.getPath());
+    }
+
+}

Added: trunk/test/suites/FSSoundConstructor.xml
===================================================================
--- trunk/test/suites/FSSoundConstructor.xml	2006-02-21 17:51:50 UTC (rev 70)
+++ trunk/test/suites/FSSoundConstructor.xml	2006-02-21 18:11:14 UTC (rev 71)
@@ -0,0 +1,36 @@
+<!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
+  
+<suite name="FSSoundConstructorTest">
+
+	<parameter name="srcDir" value=""/>
+	<parameter name="dstDir" value=""/>
+	<parameter name="ext" value=""/>
+
+    <test name="WAV sounds installed in Windows - Event">
+		<parameter name="srcDir" value="/windows/media"/>
+		<parameter name="dstDir" value="test/results/FSSoundConstructor/event/windows"/>
+		<parameter name="ext" value="wav"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSSoundConstructorTest">
+      		    <methods>
+      				<include name="playEventSound" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+  	
+    <test name="WAV sounds installed in Windows - Streaming">
+		<parameter name="srcDir" value="/windows/media"/>
+		<parameter name="dstDir" value="test/results/FSSoundConstructor/streaming/windows"/>
+		<parameter name="ext" value="wav"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSSoundConstructorTest">
+      		    <methods>
+      				<include name="playStreamingSound" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+</suite>
+



From smackay at berlios.de  Tue Feb 21 19:12:51 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 19:12:51 +0100
Subject: [Transform-svn] r72 - trunk/src/com/flagstone/transform/test
Message-ID: <200602211812.k1LICpE0001108@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 19:11:53 +0100 (Tue, 21 Feb 2006)
New Revision: 72

Modified:
   trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java
Log:
Removed unused import directives.

Modified: trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java	2006-02-21 18:11:14 UTC (rev 71)
+++ trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java	2006-02-21 18:11:53 UTC (rev 72)
@@ -1,8 +1,6 @@
 package com.flagstone.transform.test;
 
 import java.io.*;
-import java.util.*;
-import java.awt.*;
 
 import com.flagstone.transform.*;
 import com.flagstone.transform.util.*;



From smackay at berlios.de  Tue Feb 21 19:22:11 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 19:22:11 +0100
Subject: [Transform-svn] r73 - in trunk: src/com/flagstone/transform/test test/suites
Message-ID: <200602211822.k1LIMBqR008563@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 19:22:03 +0100 (Tue, 21 Feb 2006)
New Revision: 73

Added:
   trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java
   trunk/test/suites/FSShapeConstructor.xml
Log:
Added a test for FSShapeConstructor.

Added: trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java	2006-02-21 18:11:53 UTC (rev 72)
+++ trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java	2006-02-21 18:22:03 UTC (rev 73)
@@ -0,0 +1,146 @@
+package com.flagstone.transform.test;
+
+import java.io.*;
+
+import com.flagstone.transform.*;
+import com.flagstone.transform.util.*;
+
+public class FSShapeConstructorTest
+{
+    private File destDir = null;
+    
+    public FSShapeConstructorTest()
+    {
+    }
+    /**
+     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
+     * @testng.parameters value = "dstDir"
+     */
+    public void configure(String dstDir)
+    {
+        destDir = new File(dstDir);
+    }
+	/**
+     * @testng.test
+	 */
+    public void basicShapes()
+    {
+        try 
+        {
+            File dstFile = new File(destDir, "BasicShapes.swf");
+            
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+
+            FSShapeConstructor path = new FSShapeConstructor();
+            FSMovie movie = new FSMovie();
+            
+            path.COORDINATES_ARE_PIXELS = true;
+            
+            int width = 150;
+            int height = 100;
+            int cornerRadius = 10;
+            
+            int identifier = 0;
+            
+            path.add(new FSSolidLine(20, FSColorTable.black()));
+            path.add(new FSSolidFill(FSColorTable.red()));
+            
+            movie.setFrameRate(1.0f);
+            movie.setFrameSize(new FSBounds(-4000, -4000, 4000, 4000));
+            movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+            
+            identifier = movie.newIdentifier();
+            
+            path.selectStyle(0, 0);
+            path.rect(width/2, -height/2, width, height);
+            movie.add(path.defineShape(identifier));
+            movie.add(new FSPlaceObject2(identifier, 1, 0, 0));
+            movie.add(new FSShowFrame());
+            
+            /*
+             * Draw a rectangle with rounded corners
+             */
+            identifier = movie.newIdentifier();
+
+            path.newPath();
+            path.selectStyle(0, 0);
+            path.rect(width/2, height/2, width, height, cornerRadius);
+            movie.add(path.defineShape(identifier));
+            movie.add(new FSPlaceObject2(identifier, 1));
+            movie.add(new FSShowFrame());
+
+            /*
+             * Draw a circle
+             */
+            identifier = movie.newIdentifier();
+
+            path.newPath();
+            path.selectStyle(0, 0);
+            path.circle(-width/2, height/2, height/2);
+            movie.add(path.defineShape(identifier));
+            movie.add(new FSPlaceObject2(identifier, 1));
+            movie.add(new FSShowFrame());
+            
+            /*
+             * Draw a elipse
+             */
+            identifier = movie.newIdentifier();
+
+            path.newPath();
+            path.selectStyle(0, 0);
+            path.ellipse(-width/2, -height/2, width/2, height/2);
+            movie.add(path.defineShape(identifier));
+            movie.add(new FSPlaceObject2(identifier, 1));
+            movie.add(new FSShowFrame());
+            
+            /*
+             * Draw a polyline
+             */
+            identifier = movie.newIdentifier();
+
+            int[] points = new int[] { 
+                0, -100, 
+                10, 0, 
+                0, 90, 
+                90, 0, 
+                0, 20,
+                -90, 0,
+                0, 90,
+                -20, 0,
+                0, -90,
+                -90, 0,
+                0, -20,
+                90, 0,
+                0, -90,
+                10, 0
+            };
+
+            path.newPath();
+            path.selectStyle(0, 0);
+            path.polygon(points);
+            movie.add(path.defineShape(identifier));
+            movie.add(new FSPlaceObject2(identifier, 1));
+            movie.add(new FSShowFrame());
+            
+            /*
+             * Draw a cubic bezier curve
+             */
+            identifier = movie.newIdentifier();
+
+            path.newPath();
+            path.selectStyle(0, 0);
+            path.curve(0, -100, 150, -100, 150, 0);
+            path.closePath();
+            movie.add(path.defineShape(identifier));
+            movie.add(new FSPlaceObject2(identifier, 1));
+            movie.add(new FSShowFrame());
+    
+            movie.encodeToFile(dstFile.getPath());
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+}

Added: trunk/test/suites/FSShapeConstructor.xml
===================================================================
--- trunk/test/suites/FSShapeConstructor.xml	2006-02-21 18:11:53 UTC (rev 72)
+++ trunk/test/suites/FSShapeConstructor.xml	2006-02-21 18:22:03 UTC (rev 73)
@@ -0,0 +1,15 @@
+<!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
+  
+<suite name="FSShapeConstructorTest">
+
+	<parameter name="dstDir" value=""/>
+
+    <test name="Basic Shapes">
+		<parameter name="dstDir" value="test/results/FSShapeConstructor"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSShapeConstructorTest"/>
+		</classes>
+  	</test>
+  	
+</suite>
+



From smackay at berlios.de  Tue Feb 21 19:52:45 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 19:52:45 +0100
Subject: [Transform-svn] r74 - in trunk: . doc
Message-ID: <200602211852.k1LIqjeZ021684@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 19:52:38 +0100 (Tue, 21 Feb 2006)
New Revision: 74

Modified:
   trunk/build.xml
   trunk/doc/CHANGES.txt
Log:
Updated the change log and incremented the version number.

Modified: trunk/build.xml
===================================================================
--- trunk/build.xml	2006-02-21 18:22:03 UTC (rev 73)
+++ trunk/build.xml	2006-02-21 18:52:38 UTC (rev 74)
@@ -37,7 +37,7 @@
 
     </description>
 
-    <property name="version" value="2.0.5"/>
+    <property name="version" value="2.0.6"/>
     
     <property name="src.dir" location="src"/>
     <property name="lib.dir" location="lib"/>

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-21 18:22:03 UTC (rev 73)
+++ trunk/doc/CHANGES.txt	2006-02-21 18:52:38 UTC (rev 74)
@@ -1,5 +1,18 @@
+2006-02-21 - smackay at flagstonesoftware.com
+
+    * Added the remaining test classes from Tranform Utilities to the project
+      and ported them to run under TestNG.
+      
+    * Changed FSTextConstructor() to handle filenames in upper case.
+    
+    * Updated the build version number to 2.0.6.
+
 2006-02-20 - smackay at flagstonesoftware.com
 
+    * Released 2.0.5. 
+    
+    Changes below took place after the release.
+
     * Build.xml:
           - The build target now includes all contributed classes.
           - Renamed the minor target 'optimized' to 'classes'.



From smackay at berlios.de  Tue Feb 21 20:35:46 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 20:35:46 +0100
Subject: [Transform-svn] r75 - trunk/src/com/flagstone/transform
Message-ID: <200602211935.k1LJZkmb005323@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 20:35:29 +0100 (Tue, 21 Feb 2006)
New Revision: 75

Modified:
   trunk/src/com/flagstone/transform/FSButtonColorTransform.java
   trunk/src/com/flagstone/transform/FSButtonSound.java
   trunk/src/com/flagstone/transform/FSCall.java
   trunk/src/com/flagstone/transform/FSDefineButton.java
   trunk/src/com/flagstone/transform/FSDefineFont.java
   trunk/src/com/flagstone/transform/FSDefineFont2.java
   trunk/src/com/flagstone/transform/FSDoAction.java
   trunk/src/com/flagstone/transform/FSExceptionHandler.java
   trunk/src/com/flagstone/transform/FSFontInfo.java
   trunk/src/com/flagstone/transform/FSFontInfo2.java
   trunk/src/com/flagstone/transform/FSInitialize.java
   trunk/src/com/flagstone/transform/FSNewFunction.java
   trunk/src/com/flagstone/transform/FSNewFunction2.java
   trunk/src/com/flagstone/transform/FSPush.java
   trunk/src/com/flagstone/transform/FSWith.java
Log:
Restored missing coder.endObject(name()); statements marking the
end of objects being encoded/decoded. These were removed by mistake 
in an earlier update.

Modified: trunk/src/com/flagstone/transform/FSButtonColorTransform.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonColorTransform.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSButtonColorTransform.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -170,6 +170,7 @@
         
         coder.writeWord(identifier, 2);
         colorTransform.encode(coder);
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -178,5 +179,6 @@
         
         identifier = coder.readWord(2, false);
         colorTransform = new FSColorTransform(coder);
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSButtonSound.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonSound.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSButtonSound.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -262,6 +262,7 @@
             else
                 coder.writeWord(0, 2);
         }
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -277,5 +278,6 @@
             else
                 coder.readWord(2, false);
         }
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSCall.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCall.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSCall.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -95,10 +95,12 @@
     void encode(FSCoder coder)
     {
         super.encode(coder);
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
     {
         super.decode(coder);
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSDefineButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineButton.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSDefineButton.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -388,6 +388,7 @@
             coder.writeBytes(encodedActions);
         }
         coder.writeWord(0, 1);
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -406,5 +407,7 @@
         
         while ((action = FSMovie.decodeAction(coder)) != null)
             actions.add(action);
+        
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSDefineFont.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSDefineFont.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -187,6 +187,8 @@
 
         coder.context[FSCoder.NumberOfFillBits] = 0;
         coder.context[FSCoder.NumberOfLineBits] = 0;
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -202,5 +204,7 @@
             
         for (int i=0; i<shapeCount; i++)
             shapes.add(new FSShape(coder));
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSDefineFont2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont2.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSDefineFont2.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -739,6 +739,8 @@
         coder.context[FSCoder.NumberOfFillBits] = 0;
         coder.context[FSCoder.NumberOfLineBits] = 0;
         coder.context[FSCoder.WideCodes] = 0;
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -813,6 +815,8 @@
         }
 
         coder.context[FSCoder.WideCodes] = 0;
+
+        coder.endObject(name());
     }
 
     private boolean containsLayoutInfo()

Modified: trunk/src/com/flagstone/transform/FSDoAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDoAction.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSDoAction.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -279,6 +279,8 @@
             coder.writeBytes(encodedActions);
         }
         coder.writeWord(0, 1);
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -290,5 +292,7 @@
         
         while ((action = FSMovie.decodeAction(coder)) != null)
             actions.add(action);
+
+        coder.endObject(name());
     }
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSExceptionHandler.java
===================================================================
--- trunk/src/com/flagstone/transform/FSExceptionHandler.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSExceptionHandler.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -517,6 +517,8 @@
                 }
             }
         }
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -593,5 +595,7 @@
                 }
             }
         }
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSFontInfo.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFontInfo.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSFontInfo.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -362,6 +362,8 @@
         
         for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
             coder.writeWord(((Integer)codesIterator.next()).intValue(), _containsWideCodes ? 2 : 1);    
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -389,5 +391,7 @@
             codes.add(new Integer(coder.readWord(_containsWideCodes ? 2 : 1, false)));
             bytesRead += (_containsWideCodes) ? 2 : 1;
         }
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSFontInfo2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFontInfo2.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSFontInfo2.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -339,6 +339,8 @@
     
         for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
             coder.writeWord(((Integer)codesIterator.next()).intValue(), 2);    
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -368,5 +370,7 @@
             codes.add(new Integer(coder.readWord(2, false)));
             bytesRead += 2;
         }
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSInitialize.java
===================================================================
--- trunk/src/com/flagstone/transform/FSInitialize.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSInitialize.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -243,6 +243,8 @@
             }
         }
         coder.writeWord(0, 1);
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -256,5 +258,7 @@
         
         while ((action = FSMovie.decodeAction(coder)) != null)
             actions.add(action);
+
+        coder.endObject(name());
     }
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSNewFunction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSNewFunction.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -427,5 +427,7 @@
             bytesRead += anAction.getLength() + ((anAction.getType() >= 128) ? 3 : 1);
             actions.add(anAction);
         }
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSNewFunction2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction2.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSNewFunction2.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -525,6 +525,8 @@
                 }
             }
         }
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -556,5 +558,7 @@
             bytesRead += anAction.getLength() + ((anAction.getType() >= 128) ? 3 : 1);
             actions.add(anAction);
         }
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSPush.java
===================================================================
--- trunk/src/com/flagstone/transform/FSPush.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSPush.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -567,6 +567,8 @@
                 coder.writeWord(((FSRegisterIndex)anObject).getIndex(), 1);
             }
         }
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -635,5 +637,7 @@
                     break;
             }
         }
+
+        coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSWith.java
===================================================================
--- trunk/src/com/flagstone/transform/FSWith.java	2006-02-21 18:52:38 UTC (rev 74)
+++ trunk/src/com/flagstone/transform/FSWith.java	2006-02-21 19:35:29 UTC (rev 75)
@@ -215,6 +215,8 @@
                 }
             }
         }
+
+        coder.endObject(name());
     }
     
     void decode(FSCoder coder)
@@ -236,5 +238,7 @@
             bytesRead += anAction.getLength() + ((anAction.getType() >= 128) ? 3 : 1);
             actions.add(anAction);
         }
+
+        coder.endObject(name());
     }
 }



From smackay at berlios.de  Tue Feb 21 21:11:22 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 21:11:22 +0100
Subject: [Transform-svn] r76 - trunk/src/com/flagstone/transform
Message-ID: <200602212011.k1LKBMJm024476@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 21:11:15 +0100 (Tue, 21 Feb 2006)
New Revision: 76

Modified:
   trunk/src/com/flagstone/transform/FSCoder.java
   trunk/src/com/flagstone/transform/FSMovie.java
   trunk/src/com/flagstone/transform/FSMovieEvent.java
   trunk/src/com/flagstone/transform/FSMovieListener.java
Log:
Deprecated the FSMovieListener interface, FSMovieEvent class and 
the methods on the FSMovie class that used them.

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2006-02-21 19:35:29 UTC (rev 75)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2006-02-21 20:11:15 UTC (rev 76)
@@ -161,14 +161,18 @@
             context[i] = 0;
     }
     /**
-     *
+     * @depracated The FSMovieListener interface does not enable recovery from
+     * coding errors or corrupt Flash files and therefore will no longer be 
+     * used. Instead errors will be reported through exceptions.
      */ 
     void setListener(FSMovieListener aListener) 
     {
         listener = aListener;
     }
     /**
-     *
+     * @depracated The FSMovieListener interface does not enable recovery from
+     * coding errors or corrupt Flash files and therefore will no longer be 
+     * used. Instead errors will be reported through exceptions.
      */ 
     FSMovieListener getListener()
     { 

Modified: trunk/src/com/flagstone/transform/FSMovie.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovie.java	2006-02-21 19:35:29 UTC (rev 75)
+++ trunk/src/com/flagstone/transform/FSMovie.java	2006-02-21 20:11:15 UTC (rev 76)
@@ -678,7 +678,7 @@
      * @param listener an FSMovieListener object where errors messages are
      * sent.
      *
-     *
+     * @deprecated
      */
     public FSMovie(String fileName, FSMovieListener listener)
     {
@@ -707,6 +707,8 @@
      * @param listener an FSMovieListener object where errors messages are
      * sent.
      *
+     * @deprecated using the constructor FSMovie(byte[]) which throws an
+     * exception if an error is detected.
      */
     public FSMovie(byte[] data, FSMovieListener listener)
     {
@@ -958,7 +960,9 @@
      * @param listener an FSMovieListener object where errors messages are
      * sent.
      *
-     *
+     * @deprecated use the decodeFromFile(String) method which throws an
+     * exception if an error is detected.
+     * 
      */
     public void decodeFromFile(String fileName, FSMovieListener listener)
     {
@@ -1045,7 +1049,8 @@
      * @param listener an FSMovieListener object where errors messages are
      * sent.
      *
-     *
+     * @deprecated use the decodeFromData(bytep[]) method which throws an
+     * exception if an error is detected.
      */
     public void decodeFromData(byte[] bytes, FSMovieListener listener)
     {
@@ -1123,7 +1128,8 @@
      * @param listener an FSMovieListener object where errors messages are
      * sent.
      *
-     * 
+     * @deprecated use the encodeToFile(String) method which throws an
+     * exception if an error is detected.
      */
     public void encodeToFile(String fileName, FSMovieListener listener)
     {
@@ -1224,7 +1230,8 @@
      * @param listener an FSMovieListener object where errors messages are
      * sent.
      *
-     * 
+     * @deprecated use the encode() method which throws an exception if an 
+     * error is detected.
      */
     public byte[] encode(FSMovieListener listener)
     {

Modified: trunk/src/com/flagstone/transform/FSMovieEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovieEvent.java	2006-02-21 19:35:29 UTC (rev 75)
+++ trunk/src/com/flagstone/transform/FSMovieEvent.java	2006-02-21 20:11:15 UTC (rev 76)
@@ -31,6 +31,12 @@
 package com.flagstone.transform;
 
 /**
+ * @deprecated the FSMovieEvent will no longer be supported in future releases
+ * to report decoding and encoding events and to report errors. Instead methods
+ * which report errors through exceptions are preferred. If an error occurs then
+ * it is due to an error which cannot be easily recovered from therefore the
+ * FSMovieEvent will no longer be used.
+ * 
  * The FSMovieEvent class is a container class for the information generated for events 
  * while a movie is being encoded or decoded.
  *

Modified: trunk/src/com/flagstone/transform/FSMovieListener.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovieListener.java	2006-02-21 19:35:29 UTC (rev 75)
+++ trunk/src/com/flagstone/transform/FSMovieListener.java	2006-02-21 20:11:15 UTC (rev 76)
@@ -31,15 +31,23 @@
 package com.flagstone.transform;
 
 /**
+ * @deprecated the FSMovieListener interface will no longer be used future 
+ * release to report decoding and encoding events and to report errors. Instead 
+ * methods which report errors through exceptions are preferred. If an error 
+ * occurs then it is due to a design error or corrupt data in a Flash file which 
+ * cannot be easily recovered from therefore the FSMovieListener interface will 
+ * no longer be used.
+
  * The FSMovieListener interface defines the methods required to register an object to 
  * receive event information from an FSMovie object as it encodes and decodes Flash 
  * movies.
  *
- *
  */
 public interface FSMovieListener
 {
     /**
+     * @deprecated
+     * 
      * The FSMovie object calls this method to send FSMovieEvent object to a registered
      * listener.
      * 



From smackay at berlios.de  Tue Feb 21 23:00:31 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 23:00:31 +0100
Subject: [Transform-svn] r77 - in trunk/src/com/flagstone/transform: . util
Message-ID: <200602212200.k1LM0VkK019843@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 23:00:21 +0100 (Tue, 21 Feb 2006)
New Revision: 77

Modified:
   trunk/src/com/flagstone/transform/FSButtonEvent.java
   trunk/src/com/flagstone/transform/FSClipEvent.java
   trunk/src/com/flagstone/transform/FSCoder.java
   trunk/src/com/flagstone/transform/FSDefineButton.java
   trunk/src/com/flagstone/transform/FSDefineMovieClip.java
   trunk/src/com/flagstone/transform/FSDoAction.java
   trunk/src/com/flagstone/transform/FSExceptionHandler.java
   trunk/src/com/flagstone/transform/FSInitialize.java
   trunk/src/com/flagstone/transform/FSNewFunction.java
   trunk/src/com/flagstone/transform/FSNewFunction2.java
   trunk/src/com/flagstone/transform/FSWith.java
   trunk/src/com/flagstone/transform/Transform.java
   trunk/src/com/flagstone/transform/util/FSImageConstructor.java
   trunk/src/com/flagstone/transform/util/FSSoundConstructor.java
Log:
Deprecated the flag Transform.DEBUG. Code using this flag was
removed from FSCoder and commented out elsewhere.

Modified: trunk/src/com/flagstone/transform/FSButtonEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonEvent.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSButtonEvent.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -388,13 +388,12 @@
                 {
                     coder.context[FSCoder.CodingError] = 1;
 
-                    if (Transform.DEBUG)
-                    {
+/*
                         if (delta < 0)
                             coder.logError("ActionOverflow", next, -delta);
                         else if (delta > 0)
                             coder.logError("ActionUnderflow", next, delta);
-                    }
+*/
                 }
             }
         }

Modified: trunk/src/com/flagstone/transform/FSClipEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSClipEvent.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSClipEvent.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -516,13 +516,12 @@
                 {
                     coder.context[FSCoder.CodingError] = 1;
 
-                    if (Transform.DEBUG)
-                    {
+/*
                         if (delta < 0)
                             coder.logError("ActionOverflow", next, -delta);
                         else if (delta > 0)
                             coder.logError("ActionUnderflow", next, delta);
-                    }
+*/
                 }
             }
         }

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -200,16 +200,10 @@
     {
         if (location < 0)
         {
-            if (Transform.DEBUG)
-                logError("PointerOutOfRange", location, 0);
-                
             location = 0;
         }
         else if (location > end)
         {
-            if (Transform.DEBUG)
-                logError("PointerOutOfRange", location, 0);
-                
             location = end;
         }
         ptr = location;
@@ -221,16 +215,10 @@
         
         if (ptr < 0)
         {
-            if (Transform.DEBUG)
-                logError("PointerOutOfRange", ptr, 0);
-                
             ptr = 0;
         }
         else if (ptr >= end)
         {
-            if (Transform.DEBUG)
-                logError("PointerOutOfRange", ptr, 0);
-                
             ptr = end;
         }
     }
@@ -322,12 +310,6 @@
         int value = 0;
         int start = ptr;
 
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", ptr, numberOfBits);
-        }
-    
         value = _readBits(numberOfBits, signed);
         ptr = start;
         
@@ -339,12 +321,6 @@
         int value = 0;
         int start = ptr;
 
-        if (Transform.DEBUG)
-        {
-            if (numberOfBytes < 0 || numberOfBytes > 4)
-                logError("ByteRangeError", ptr, numberOfBytes);
-        }
-    
         value = _readWord(numberOfBytes*8, signed);
         ptr = start;
         
@@ -356,17 +332,8 @@
         int location = ptr;
         int value = 0;
 
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", ptr, numberOfBits);
-        }
-    
         value = _readBits(numberOfBits, signed);
         
-        if (Transform.DEBUG)
-            logValue(new Integer(value), location, numberOfBits);
-    
         return value;
     }
     
@@ -374,16 +341,7 @@
     {
         int location = ptr;
     
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", location, numberOfBits);
-        }
-    
         _writeBits(value, numberOfBits);
-    
-        if (Transform.DEBUG)
-            logValue(new Integer(value), location, numberOfBits);
     }
 
     public int readWord(int numberOfBytes, boolean signed)
@@ -391,17 +349,8 @@
         int location = ptr;
         int value = 0;
 
-        if (Transform.DEBUG)
-        {
-            if (numberOfBytes < 0 || numberOfBytes > 4)
-                logError("ByteRangeError", ptr, numberOfBytes);
-        }
-    
         value = _readWord(numberOfBytes*8, signed);
         
-        if (Transform.DEBUG)
-            logValue(new Integer(value), location, numberOfBytes*8);
-    
         return value;
     }
         
@@ -409,16 +358,7 @@
     {
         int location = ptr;
     
-        if (Transform.DEBUG)
-        {
-            if (numberOfBytes < 0 || numberOfBytes > 4)
-                logError("ByteRangeError", location, numberOfBytes);
-        }
-    
         _writeWord(value, numberOfBytes*8);
-    
-        if (Transform.DEBUG)
-            logValue(new Integer(value), location, numberOfBytes*8);
     }
     
     public float readFixedBits(int numberOfBits, int fractionSize)
@@ -427,19 +367,7 @@
         float value = 0;
         float divisor = (float)(1 << fractionSize);
     
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", ptr, numberOfBits);
-
-            if (fractionSize < 0 || fractionSize > 32)
-                logError("ByteRangeError", ptr, fractionSize);
-        }
-    
         value = ((float)_readBits(numberOfBits, true)) / divisor;
-        
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, numberOfBits);
     
         return value;
     }
@@ -449,16 +377,7 @@
         int location = ptr; 
         float multiplier = (float)(1 << fractionSize);
     
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", ptr, numberOfBits);
-        }
-    
         _writeBits((int)(value*multiplier), numberOfBits);
-
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, numberOfBits);
     }
 
     public float readFixedWord(int mantissaSize, int fractionSize)
@@ -470,21 +389,12 @@
         float value = 0;
         float divisor = (float)(1 << fractionSize);
     
-        if (Transform.DEBUG)
-        {
-            if (mantissaSize < 0 || fractionSize < 0 || (mantissaSize+fractionSize) > 32)
-                logError("BitRangeError", ptr, mantissaSize);
-        }
-    
         fraction = _readWord(fractionSize, false);
         mantissa = _readWord(mantissaSize, true);
             
         mantissa <<= fractionSize;        
         value = (mantissa + fraction) / divisor;
         
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, mantissaSize+fractionSize);
-    
         return value;
     }
     
@@ -496,92 +406,13 @@
         
         float multiplier = (float)(1 << fractionSize);
     
-        if (Transform.DEBUG)
-        {
-            if (mantissaSize < 0 || fractionSize < 0 || (mantissaSize+fractionSize) > 32)
-                logError("BitRangeError", ptr, mantissaSize);
-        }
-    
         fraction = (int)(value*multiplier);
         mantissa = (int)value;
 
         _writeWord(fraction, fractionSize);
         _writeWord(mantissa, mantissaSize);
-
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, mantissaSize+fractionSize);
     }
-/*
-    float readShortFixed(int numberOfBits)
-    {
-        int location = ptr;
-        float value = 0;
-    
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 16)
-                logError("BitRangeError", ptr, numberOfBits);
-        }
-    
-        value = ((float)_readBits(numberOfBits, true)) / 256.0f;
 
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, numberOfBits);
-        
-        return value;
-    }
-    
-    void writeShortFixed(float value, int numberOfBits)
-    {
-        int location = ptr; 
-    
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 16)
-                logError("BitRangeError", ptr, numberOfBits);
-        }
-    
-        _writeBits((int)(value*256.0f), numberOfBits);
-
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, numberOfBits);
-    }
-
-    float readFixed(int numberOfBits)
-    {
-        int location = ptr;
-        float value = 0;
-    
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", ptr, numberOfBits);
-        }
-    
-        value = ((float)_readBits(numberOfBits, true)) / 65536.0f;
-
-        if (Transform.DEBUG)
-            logValue(new Float(value), ptr-numberOfBits, numberOfBits);
-        
-        return value;
-    }
-    
-    void writeFixed(float value, int numberOfBits)
-    {
-        int location = ptr; 
-    
-        if (Transform.DEBUG)
-        {
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", location, numberOfBits);
-        }
-    
-        _writeBits((int)(value*65536.0f), numberOfBits);
-
-        if (Transform.DEBUG)
-            logValue(new Float(value), location, numberOfBits);
-    }
-*/
     public double readDouble()
     {
         int location = ptr;
@@ -597,9 +428,6 @@
     
         value = Double.longBitsToDouble(longValue);
 
-        if (Transform.DEBUG)
-            logValue(new Double(value), location, 64);
-
         return value;
     }
 
@@ -614,9 +442,6 @@
     
         _writeWord(upperInt, 32);
         _writeWord(lowerInt, 32);
-
-        if (Transform.DEBUG)
-            logValue(new Double(value), location, 64);
     }
 
     public int readBytes(byte[] bytes)
@@ -626,9 +451,6 @@
     
         bytesRead = _readBytes(bytes);
     
-        if (Transform.DEBUG)
-            logValue("<Data>", location, bytesRead << 3);
-
         return bytesRead;
     }
 
@@ -639,9 +461,6 @@
     
         bytesWritten = _writeBytes(bytes);
     
-        if (Transform.DEBUG)
-            logValue("<Data>", location, bytesWritten << 3);
-
         return bytesWritten;
     }
     
@@ -654,9 +473,6 @@
     {
         if (length == 0)
         {
-            if (Transform.DEBUG)
-                logValue("", ptr, length<<3);
-                
             return "";
         }
             
@@ -673,10 +489,6 @@
         {
             value = "";
         }
-    
-        if (Transform.DEBUG)
-            logValue(value, location, length<<3);
-
         return value;
     }
 
@@ -714,9 +526,6 @@
         _readWord(8, false);
         len++;
     
-        if (Transform.DEBUG)
-            logValue(value, location, len<<3);
-
         return value;
     }
 
@@ -741,12 +550,6 @@
         if (numberOfBits == 0)
             return value;
         
-        if (Transform.DEBUG)
-        {
-            if (ptr >= end)
-                return 0;
-        }
-            
         try 
         {
             int index = ptr >> 3;
@@ -766,9 +569,6 @@
         }
         catch (ArrayIndexOutOfBoundsException e)
         {
-            if (Transform.DEBUG)
-                logError("DataReadOverflow", ptr, numberOfBits);
-
             value = 0;
         }
         return value;
@@ -781,15 +581,6 @@
         if (numberOfBits == 0)
             return value;
 
-        if (Transform.DEBUG)
-        {
-            if (ptr >= end)
-                return 0;
-                
-            if (ptr % 8 > 0)
-                logError("NotByteAligned", ptr, 0);
-        }
-    
         try 
         {
             int index = ptr >> 3;
@@ -805,9 +596,6 @@
         }
         catch (ArrayIndexOutOfBoundsException e)
         {
-            if (Transform.DEBUG)
-                logError("DataReadOverflow", ptr, numberOfBits);
-
             value = 0;
         }
         return value;
@@ -820,15 +608,6 @@
         if (bytes == null || bytes.length == 0)
             return bytesRead;
 
-        if (Transform.DEBUG)
-        {
-            if (ptr >= end)
-                return bytesRead;
-                
-            if (ptr % 8 > 0)
-                logError("NotByteAligned", ptr, 0);
-        }    
-        
         try 
         {
             int index = ptr >>> 3;
@@ -839,8 +618,6 @@
         }
         catch (ArrayIndexOutOfBoundsException e)
         {
-            if (Transform.DEBUG)
-                logError("DataReadOverflow", ptr, bytes.length << 3);
         }        
         return bytesRead;
     }
@@ -850,12 +627,6 @@
         if (numberOfBits == 0)
             return;
 
-        if (Transform.DEBUG)
-        {
-            if (ptr >= end)
-                return;
-        }
-            
         try 
         {
             int index = ptr >> 3;
@@ -875,22 +646,11 @@
         }
         catch (ArrayIndexOutOfBoundsException e)
         {
-            if (Transform.DEBUG)
-                logError("DataWriteOverflow", ptr, numberOfBits);
         }
     }
     
     private void _writeWord(int value, int numberOfBits)
     {
-        if (Transform.DEBUG)
-        {
-            if (ptr >= end)
-                return;
-                
-            if (ptr % 8 > 0)
-                logError("NotByteAligned", ptr, 0);
-        }
-    
         try 
         {
             int index = ptr >>> 3;
@@ -900,8 +660,6 @@
         }
         catch (ArrayIndexOutOfBoundsException e)
         {
-            if (Transform.DEBUG)
-                logError("DataWriteOverflow", ptr, numberOfBits);
         }
     }
 
@@ -912,15 +670,6 @@
         if (bytes == null || bytes.length == 0)
             return bytesWritten;
 
-        if (Transform.DEBUG)
-        {
-            if (ptr >= end)
-                return bytesWritten;
-                
-            if (ptr % 8 > 0)
-                logError("NotByteAligned", ptr, 0);
-        }
-    
         try 
         {
             int index = ptr >>> 3;
@@ -931,8 +680,6 @@
         }
         catch (ArrayIndexOutOfBoundsException e)
         {
-            if (Transform.DEBUG)
-                logError("DataWriteOverflow", ptr, bytes.length << 3);
         }
         
         return bytesWritten;
@@ -942,20 +689,11 @@
     {
         int currentLocation = ptr;
         
-        if (Transform.DEBUG)
-        {
-            if (numberOfBytes < 0 || numberOfBytes > 4)
-                logError("ByteRangeError", location, numberOfBytes);
-        }
-    
         ptr = location;
     
         _writeWord(value, numberOfBytes*8);
         
         ptr = currentLocation;
-    
-        if (Transform.DEBUG)
-            logValue(new Integer(value), location, numberOfBytes*8);
     }
     
 

Modified: trunk/src/com/flagstone/transform/FSDefineButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineButton.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSDefineButton.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -373,13 +373,12 @@
                 {
                     coder.context[FSCoder.CodingError] = 1;
     
-                    if (Transform.DEBUG)
-                    {
+/*
                         if (delta < 0)
                             coder.logError("ActionOverflow", next, -delta);
                         else if (delta > 0)
                             coder.logError("ActionUnderflow", next, delta);
-                    }
+*/
                 }
             }
         }

Modified: trunk/src/com/flagstone/transform/FSDefineMovieClip.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineMovieClip.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSDefineMovieClip.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -211,13 +211,12 @@
             {
                 coder.context[FSCoder.CodingError] = 1;
 
-                if (Transform.DEBUG)
-                {
+/*
                     if (delta < 0)
                         coder.logError("ObjectOverflow", next, -delta);
                     else if (delta > 0)
                         coder.logError("ObjectUnderflow", next, delta);
-                }
+*/
             }
         }
         coder.writeWord(0, 2);

Modified: trunk/src/com/flagstone/transform/FSDoAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDoAction.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSDoAction.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -263,13 +263,12 @@
                 {
                     coder.context[FSCoder.CodingError] = 1;
 
-                    if (Transform.DEBUG)
-                    {
+/*
                         if (delta < 0)
                             coder.logError("ActionOverflow", next, -delta);
                         else if (delta > 0)
                             coder.logError("ActionUnderflow", next, delta);
-                    }
+*/
                 }
                 coder.setPointer(next);
             }

Modified: trunk/src/com/flagstone/transform/FSExceptionHandler.java
===================================================================
--- trunk/src/com/flagstone/transform/FSExceptionHandler.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSExceptionHandler.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -450,13 +450,12 @@
             {
                 coder.context[FSCoder.CodingError] = 1;
 
-                if (Transform.DEBUG)
-                {
+/*
                     if (delta < 0)
                         coder.logError("ActionOverflow", next, -delta);
                     else if (delta > 0)
                         coder.logError("ActionUnderflow", next, delta);
-                }
+*/
             }
         }
 
@@ -478,13 +477,12 @@
                 {
                     coder.context[FSCoder.CodingError] = 1;
 
-                    if (Transform.DEBUG)
-                    {
+/*
                         if (delta < 0)
                             coder.logError("ActionOverflow", next, -delta);
                         else if (delta > 0)
                             coder.logError("ActionUnderflow", next, delta);
-                    }
+*/
                 }
             }
         }
@@ -507,13 +505,12 @@
                 {
                     coder.context[FSCoder.CodingError] = 1;
 
-                    if (Transform.DEBUG)
-                    {
+/*
                         if (delta < 0)
                             coder.logError("ActionOverflow", next, -delta);
                         else if (delta > 0)
                             coder.logError("ActionUnderflow", next, delta);
-                    }
+*/
                 }
             }
         }

Modified: trunk/src/com/flagstone/transform/FSInitialize.java
===================================================================
--- trunk/src/com/flagstone/transform/FSInitialize.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSInitialize.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -233,13 +233,12 @@
             {
                 coder.context[FSCoder.CodingError] = 1;
 
-                if (Transform.DEBUG)
-                {
+/*
                     if (delta < 0)
                         coder.logError("ActionOverflow", next, -delta);
                     else if (delta > 0)
                         coder.logError("ActionUnderflow", next, delta);
-                }
+*/
             }
         }
         coder.writeWord(0, 1);

Modified: trunk/src/com/flagstone/transform/FSNewFunction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSNewFunction.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -385,13 +385,12 @@
             {
                 coder.context[FSCoder.CodingError] = 1;
 
-                if (Transform.DEBUG)
-                {
+/*
                     if (delta < 0)
                         coder.logError("ActionOverflow", next, -delta);
                     else if (delta > 0)
                         coder.logError("ActionUnderflow", next, delta);
-                }
+*/
             }
         }
         coder.endObject(name());

Modified: trunk/src/com/flagstone/transform/FSNewFunction2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction2.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSNewFunction2.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -516,13 +516,12 @@
             {
                 coder.context[FSCoder.CodingError] = 1;
 
-                if (Transform.DEBUG)
-                {
+/*
                     if (delta < 0)
                         coder.logError("ActionOverflow", next, -delta);
                     else if (delta > 0)
                         coder.logError("ActionUnderflow", next, delta);
-                }
+*/
             }
         }
 

Modified: trunk/src/com/flagstone/transform/FSWith.java
===================================================================
--- trunk/src/com/flagstone/transform/FSWith.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/FSWith.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -206,13 +206,12 @@
             {
                 coder.context[FSCoder.CodingError] = 1;
 
-                if (Transform.DEBUG)
-                {
+/*
                     if (delta < 0)
                         coder.logError("ActionOverflow", next, -delta);
                     else if (delta > 0)
                         coder.logError("ActionUnderflow", next, delta);
-                }
+*/
             }
         }
 

Modified: trunk/src/com/flagstone/transform/Transform.java
===================================================================
--- trunk/src/com/flagstone/transform/Transform.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/Transform.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -38,6 +38,8 @@
 public final class Transform
 {
     /** 
+     * @deprecated No longer required for debugging.
+     * 
      * DEBUG is used to turn on additional logging and error checking.
      */
     public static final boolean DEBUG = false;
@@ -61,7 +63,7 @@
      * This number is incremented when an enhancement or bug fix has been made 
      * and the API is unchanged.
      */
-    public static final int RELEASE = 4;
+    public static final int RELEASE = 6;
     /** 
      * VALUE_NOT_SET is used to signify that a field has not yet assigned a value. Some Flash 
      * tags contain optional fields to reduce the size of the binary data when a tag is encoded. 
@@ -87,11 +89,8 @@
         System.out.println(
             " * Transform For Flash " + VERSION + ", Version " + version);
         
-        if (DEBUG)
-            System.out.println(" * Debug Edition.");
-                    
         System.out.println(" * ");
-        System.out.println(" * Copyright (c) Flagstone Software Limited, 2001-2005.");
+        System.out.println(" * Copyright (c) Flagstone Software Limited, 2001-2006.");
         System.out.println(" * All Rights Reserved.");
         System.out.println(" * ");
         System.out.println(" * Use of this software is subject to the terms in the license");

Modified: trunk/src/com/flagstone/transform/util/FSImageConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSImageConstructor.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/util/FSImageConstructor.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -1217,25 +1217,23 @@
                     break;
             }         
             length += 4; // include CRC at end of chunk
-
-            if (Transform.DEBUG)
-            {
-                int bytesRead = (coder.getPointer() - current) >> 3;
-                
-                byte[] chars = new byte[4];
-                
-                chars[3] = (byte)chunkType;
-                chars[2] = (byte)(chunkType >> 8);
-                chars[1] = (byte)(chunkType >> 16);
-                chars[0] = (byte)(chunkType >> 24);
-                
-                String chunk = new String(chars);
-                
-                if (bytesRead < length)
-                    System.err.println(chunk + " chunk underflowed by " + (length - bytesRead) + " bytes.");
-                else if (bytesRead > length)
-                    System.err.println(chunk + " chunk overflowed by " + (bytesRead - length) + " bytes.");
-            }
+/*
+            int bytesRead = (coder.getPointer() - current) >> 3;
+            
+            byte[] chars = new byte[4];
+            
+            chars[3] = (byte)chunkType;
+            chars[2] = (byte)(chunkType >> 8);
+            chars[1] = (byte)(chunkType >> 16);
+            chars[0] = (byte)(chunkType >> 24);
+            
+            String chunk = new String(chars);
+            
+            if (bytesRead < length)
+                System.err.println(chunk + " chunk underflowed by " + (length - bytesRead) + " bytes.");
+            else if (bytesRead > length)
+                System.err.println(chunk + " chunk overflowed by " + (bytesRead - length) + " bytes.");
+*/
             coder.setPointer(next);
             
             if (coder.eof())

Modified: trunk/src/com/flagstone/transform/util/FSSoundConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSSoundConstructor.java	2006-02-21 20:11:15 UTC (rev 76)
+++ trunk/src/com/flagstone/transform/util/FSSoundConstructor.java	2006-02-21 22:00:21 UTC (rev 77)
@@ -470,15 +470,14 @@
 
             int nextBlock = blockStart + (length << 3);
 
-            if (Transform.DEBUG)
-            {
-                int bytesRead = (coder.getPointer() - blockStart) >> 3;
-                
-                if (bytesRead < length)
-                    System.err.println(chunkType + " chunk underflowed by " + (length - bytesRead) + " bytes.");
-                else if (bytesRead > length)
-                    System.err.println(chunkType + " chunk overflowed by " + (bytesRead - length) + " bytes.");
-            }
+/*
+            int bytesRead = (coder.getPointer() - blockStart) >> 3;
+            
+            if (bytesRead < length)
+                System.err.println(chunkType + " chunk underflowed by " + (length - bytesRead) + " bytes.");
+            else if (bytesRead > length)
+                System.err.println(chunkType + " chunk overflowed by " + (bytesRead - length) + " bytes.");
+ */
             coder.setPointer(nextBlock);
             moreChunks = coder.eof() == false;
         }



From smackay at berlios.de  Tue Feb 21 23:01:06 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 21 Feb 2006 23:01:06 +0100
Subject: [Transform-svn] r78 - trunk/doc
Message-ID: <200602212201.k1LM16rB019950@sheep.berlios.de>

Author: smackay
Date: 2006-02-21 23:01:03 +0100 (Tue, 21 Feb 2006)
New Revision: 78

Modified:
   trunk/doc/CHANGES.txt
Log:
Updated.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-21 22:00:21 UTC (rev 77)
+++ trunk/doc/CHANGES.txt	2006-02-21 22:01:03 UTC (rev 78)
@@ -6,6 +6,12 @@
     * Changed FSTextConstructor() to handle filenames in upper case.
     
     * Updated the build version number to 2.0.6.
+    
+    * Deprecated the FSMovieListener interface, FSMovieEvent class and 
+      the methods on the FSMovie class that used them.
+      
+    * Deprecated the flag Transform.DEBUG. Code using this flag was removed from 
+      FSCoder and commented out elsewhere.
 
 2006-02-20 - smackay at flagstonesoftware.com
 



From smackay at berlios.de  Thu Feb 23 12:27:23 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Thu, 23 Feb 2006 12:27:23 +0100
Subject: [Transform-svn] r79 - trunk/src/com/flagstone/transform/test
Message-ID: <200602231127.k1NBRNXl014841@sheep.berlios.de>

Author: smackay
Date: 2006-02-23 12:27:20 +0100 (Thu, 23 Feb 2006)
New Revision: 79

Modified:
   trunk/src/com/flagstone/transform/test/FSMovieTest.java
Log:
Fixed an error is FSMovieTest so exceptions thrown when encoding or 
decoding files are now triggering assertions

Modified: trunk/src/com/flagstone/transform/test/FSMovieTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSMovieTest.java	2006-02-21 22:01:03 UTC (rev 78)
+++ trunk/src/com/flagstone/transform/test/FSMovieTest.java	2006-02-23 11:27:20 UTC (rev 79)
@@ -89,11 +89,11 @@
         }
         catch (DataFormatException e)
         {
-            assert true;
+            assert false;
         }
-        catch (IOException e)
+        catch (Exception e)
         {
-            assert true : e.getMessage();
+            assert false : e.getMessage();
         }
     }
     /**
@@ -116,11 +116,11 @@
         }
         catch (DataFormatException e)
         {
-            assert true;
+            assert false;
         }
         catch (IOException e)
         {
-            assert true : e.getMessage();
+            assert false : e.getMessage();
         }
     }
     /**



From smackay at berlios.de  Thu Feb 23 13:32:13 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Thu, 23 Feb 2006 13:32:13 +0100
Subject: [Transform-svn] r81 - trunk/src/com/flagstone/transform
Message-ID: <200602231232.k1NCWDS7016976@sheep.berlios.de>

Author: smackay
Date: 2006-02-23 13:32:07 +0100 (Thu, 23 Feb 2006)
New Revision: 81

Modified:
   trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java
   trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java
Log:
Improved the algorithm when decoding the encoding table in the 
classes FSDefineJPEGImage2 and FSDefineJPEGImage3.

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java	2006-02-23 12:31:20 UTC (rev 80)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java	2006-02-23 12:32:07 UTC (rev 81)
@@ -226,21 +226,34 @@
     {
         byte bytes[] = null;
 
+        int soi = 0xFFD8;
+        int eoi = 0xFFD9;
+        
         int start = coder.getPointer();
-        int word = coder.scanBits(16, false);
-
-        int soi = 0xFFD8;
-        int len = 0;
-
+        int end = start + ((length-2) << 3);
+        
+        int word = 0;
+ 
         do {
             word = coder.scanBits(16, false);
+            
+            if (word == soi) 
+            {
+                start = coder.getPointer();
+            }
+            else if (word == eoi) 
+            {
+                end = coder.getPointer()+16;
+                break;
+            }
             coder.adjustPointer(8);
-            len++;
-
-        } while (word != soi);
-
+        } 
+        while (coder.getPointer() < end);
+            
+        int len = (end-start) >>> 3; 
+        
         coder.setPointer(start);
-        bytes = new byte[len-1];
+        bytes = new byte[len];
         coder.readBytes(bytes);
 
         return bytes;

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java	2006-02-23 12:31:20 UTC (rev 80)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java	2006-02-23 12:32:07 UTC (rev 81)
@@ -277,21 +277,34 @@
     {
         byte bytes[] = null;
 
+        int soi = 0xFFD8;
+        int eoi = 0xFFD9;
+        
         int start = coder.getPointer();
-        int word = coder.scanBits(16, false);
-
-        int soi = 0xFFD8;
-        int len = 0;
-
+        int end = start + ((length-2) << 3);
+        
+        int word = 0;
+ 
         do {
             word = coder.scanBits(16, false);
+            
+            if (word == soi) 
+            {
+                start = coder.getPointer();
+            }
+            else if (word == eoi) 
+            {
+                end = coder.getPointer()+16;
+                break;
+            }
             coder.adjustPointer(8);
-            len++;
-
-        } while (word != soi);
-
+        } 
+        while (coder.getPointer() < end);
+            
+        int len = (end-start) >>> 3; 
+        
         coder.setPointer(start);
-        bytes = new byte[len-1];
+        bytes = new byte[len];
         coder.readBytes(bytes);
 
         return bytes;



From smackay at berlios.de  Thu Feb 23 13:32:57 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Thu, 23 Feb 2006 13:32:57 +0100
Subject: [Transform-svn] r82 - in trunk: doc src/com/flagstone/transform
Message-ID: <200602231232.k1NCWvSs017408@sheep.berlios.de>

Author: smackay
Date: 2006-02-23 13:32:43 +0100 (Thu, 23 Feb 2006)
New Revision: 82

Added:
   trunk/src/com/flagstone/transform/FSCoderException.java
Modified:
   trunk/doc/CHANGES.txt
   trunk/src/com/flagstone/transform/FSButtonEvent.java
   trunk/src/com/flagstone/transform/FSClipEvent.java
   trunk/src/com/flagstone/transform/FSCoder.java
   trunk/src/com/flagstone/transform/FSDefineButton.java
   trunk/src/com/flagstone/transform/FSDefineMovieClip.java
   trunk/src/com/flagstone/transform/FSDoAction.java
   trunk/src/com/flagstone/transform/FSExceptionHandler.java
   trunk/src/com/flagstone/transform/FSInitialize.java
   trunk/src/com/flagstone/transform/FSMovie.java
   trunk/src/com/flagstone/transform/FSNewFunction.java
   trunk/src/com/flagstone/transform/FSNewFunction2.java
   trunk/src/com/flagstone/transform/FSWith.java
Log:
    * Added a new exception class, FSCoderException to report when underflow or
      overflow errors occur when encoding or decoding objects. Previously only
      the more general IOException was reported. FSCoderException contains 
      information on the location of the data structure in the file that caused
      the error making diagnosis much easier.
      
    * Added new attributes to FSCoder so errors occurring during encoding or 
      decoding can be reported to the top level methods in FSMovie without
      having to report them using exceptions since not all encode(FSCoder) or
      decode(FSCoder) methods check for errors.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/doc/CHANGES.txt	2006-02-23 12:32:43 UTC (rev 82)
@@ -1,3 +1,24 @@
+2006-02-23 - smackay at flagstonesoftware.com
+
+    * Added a new exception class, FSCoderException to report when underflow or
+      overflow errors occur when encoding or decoding objects. Previously only
+      the more general IOException was reported. FSCoderException contains 
+      information on the location of the data structure in the file that caused
+      the error making diagnosis much easier.
+      
+    * Added new attributes to FSCoder so errors occurring during encoding or 
+      decoding can be reported to the top level methods in FSMovie without
+      having to report them using exceptions since not all encode(FSCoder) or
+      decode(FSCoder) methods check for errors.
+      
+    * Fixed an error is FSMovieTest so exceptions thrown when encoding or 
+      decoding files are now triggering assertions.
+
+2006-02-22 - smackay at flagstonesoftware.com
+
+    * Improved the algorithm when decoding the encoding table in the classes
+      FSDefineJPEGImage2 and FSDefineJPEGImage3.
+
 2006-02-21 - smackay at flagstonesoftware.com
 
     * Added the remaining test classes from Tranform Utilities to the project

Modified: trunk/src/com/flagstone/transform/FSButtonEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonEvent.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSButtonEvent.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -375,6 +375,7 @@
             {
                 FSActionObject action = (FSActionObject)i.next();
                 
+                int objStart = coder.getPointer();
                 int length = action.getLength();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
                 int next = start + (length << 3);
@@ -382,18 +383,15 @@
                 action.encode(coder);
                 coder.setPointer(next);
             
-                int delta = (next - coder.getPointer()) >> 3;
+                int delta = (coder.getPointer() - next) >> 3;
             
                 if (delta != 0)
                 {
                     coder.context[FSCoder.CodingError] = 1;
-
-/*
-                        if (delta < 0)
-                            coder.logError("ActionOverflow", next, -delta);
-                        else if (delta > 0)
-                            coder.logError("ActionUnderflow", next, delta);
-*/
+                    coder.context[FSCoder.TypeInError] = action.getType();
+                    coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                    coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                    coder.context[FSCoder.Delta] = delta;
                 }
             }
         }
@@ -412,6 +410,8 @@
         FSActionObject action = null;
         
         while ((action = FSMovie.decodeAction(coder)) != null)
-            actions.add(action);     
+        {
+            actions.add(action);
+        }
     }
 }

Modified: trunk/src/com/flagstone/transform/FSClipEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSClipEvent.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSClipEvent.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -503,6 +503,7 @@
             {
                 FSActionObject action = (FSActionObject)i.next();
                 
+                int objStart = coder.getPointer();
                 int length = action.getLength();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
                 int next = start + (length << 3);
@@ -510,18 +511,15 @@
                 action.encode(coder);
                 coder.setPointer(next);
             
-                int delta = (next - coder.getPointer()) >> 3;
+                int delta = (coder.getPointer() - next) >> 3;
             
                 if (delta != 0)
                 {
                     coder.context[FSCoder.CodingError] = 1;
-
-/*
-                        if (delta < 0)
-                            coder.logError("ActionOverflow", next, -delta);
-                        else if (delta > 0)
-                            coder.logError("ActionUnderflow", next, delta);
-*/
+                    coder.context[FSCoder.TypeInError] = action.getType();
+                    coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                    coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                    coder.context[FSCoder.Delta] = delta;
                 }
             }
         }
@@ -549,6 +547,8 @@
         FSActionObject anAction = null;
 
         while ((anAction = FSMovie.decodeAction(coder)) != null)
+        {
             actions.add(anAction);
+        }
     }
 }

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -55,6 +55,9 @@
     public static final int WideCodes = 12;
     public static final int Delta = 13;
     public static final int CodingError = 14;
+    public static final int TypeInError = 15;
+    public static final int StartOfError = 16;
+    public static final int ExpectedLength = 17;
     
     static int size(int value, boolean signed)
     {
@@ -125,7 +128,7 @@
     
     String stringEncoding = "UTF8";
     
-    public int[] context = new int[16];
+    public int[] context = new int[18];
     
     private byte[] data = null;
     private int ptr = 0;

Added: trunk/src/com/flagstone/transform/FSCoderException.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoderException.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSCoderException.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -0,0 +1,107 @@
+package com.flagstone.transform;
+
+import java.io.IOException;
+/**
+ * This exception is thrown when parse errors are encountered. 
+ * ParseExceptions contain information about the error that prevented 
+ * a file from being read and decoded. 
+ */
+public class FSCoderException extends IOException
+{
+    private int type = 0;
+    private int start = 0;
+    private int length = 0;
+    private int delta = 0;
+
+    /**
+     * Constructs an FSCoderException to report where a problem occured when 
+     * encoding or decoding a Flash (.swf) file.
+     * 
+     * @param type the type of object or action that was being encoded/decoded
+     * when the problem occurred.
+     * 
+     * @param start the address in the file where the data structure being 
+     * encoded/decoded is located. This is only valid for files being decoded
+     * since the encoded file will not be written if an exception occurs.
+     * 
+     * @param length the size in bytes that the data structure should take 
+     * when encoded.
+     * 
+     * @param delta the difference between the actual number of byes and the 
+     * expected length. This is negative for underflow errors and postive when
+     * the takes more bytes to encode/decode that the expected length.
+     * 
+     * @param message a message indicating the type of error - overflow or 
+     * underflow.
+     */
+    public FSCoderException(int type, int start, int length, int delta, String message)
+    {
+        super(message);
+        this.type = type;
+        this.start = start;
+        this.length = length;
+        this.delta = delta;
+    }
+    /**
+     * Returns the type identifying the FSMovieObject or FSActionObject that 
+     * caused the error.
+     * 
+     * @return the object type.
+     */
+    public int getType()
+    {
+        return type;
+    }
+    /**
+     * The byte address of the start of the object in the file being decoded.
+     * This address is not valid when encoding a Flash file since the file will
+     * probably not be encoded - though this is under the control of the software
+     * using Transform.
+     * 
+     * @return the address (offset) in bytes where the object is encoded.
+     */
+    public int getStart()
+    {
+        return start;
+    }
+    /**
+     * The calculated number of bytes the object will occupy when encoded.
+     * 
+     * @return the length in bytes that the object is expected to occupy when 
+     * encoded.
+     * 
+     */
+    public int getLength()
+    {
+        return length;
+    }
+    /**
+     * The difference between the calculated number of bytes and the actual 
+     * number of bytes when the object was encoded or decoded.
+     * 
+     * @return the difference between the actual and expected number of bytes
+     * encoded/decoded.
+     */
+    public int getDelta()
+    {
+        return delta;
+    }
+    /**
+     * Return a description of the error.
+     * 
+     * @return a string desscribing the error that caused the exception.
+     */
+    public String toString()
+    {
+        StringBuffer buffer = new StringBuffer();
+        
+        buffer.append("FSCoderException: { ");
+        buffer.append("type = ").append(type).append(", ");
+        buffer.append("location = ").append(start).append(", ");
+        buffer.append("length = ").append(length).append(", ");
+        buffer.append("delta = ").append(delta).append(", ");
+        buffer.append("message = \"").append(getMessage()).append("\" }");
+        
+        return buffer.toString();
+    }
+}

Modified: trunk/src/com/flagstone/transform/FSDefineButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineButton.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSDefineButton.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -361,24 +361,22 @@
             {
                 FSActionObject action = (FSActionObject)i.next();
                     
+                int objStart = coder.getPointer();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
                 int next = start + (action.getLength() << 3);
                 
                 action.encode(coder);
                 coder.setPointer(next);
                 
-                int delta = (next - coder.getPointer()) >> 3;
+                int delta = (coder.getPointer() - next) >> 3;
                 
                 if (delta != 0)
                 {
                     coder.context[FSCoder.CodingError] = 1;
-    
-/*
-                        if (delta < 0)
-                            coder.logError("ActionOverflow", next, -delta);
-                        else if (delta > 0)
-                            coder.logError("ActionUnderflow", next, delta);
-*/
+                    coder.context[FSCoder.TypeInError] = action.getType();
+                    coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                    coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                    coder.context[FSCoder.Delta] = delta;
                 }
             }
         }
@@ -404,9 +402,10 @@
         actions = new ArrayList();
         FSActionObject action = null;
         
-        while ((action = FSMovie.decodeAction(coder)) != null)
+        while ((action = FSMovie.decodeAction(coder)) != null) 
+        {
             actions.add(action);
-        
+        }
         coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSDefineMovieClip.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineMovieClip.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSDefineMovieClip.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -192,33 +192,8 @@
     {
         super.encode(coder);
         
-        coder.writeWord(numberOfFrames(), 2);
-    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
-
-            int objLength = object.getLength();
-            int start = coder.getPointer() + ((object.getExtendLength() || objLength >= 63) ? 48 : 16);
-            int next = start + (objLength << 3);
-            
-            object.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (next - coder.getPointer()) >> 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-
-/*
-                    if (delta < 0)
-                        coder.logError("ObjectOverflow", next, -delta);
-                    else if (delta > 0)
-                        coder.logError("ObjectUnderflow", next, delta);
-*/
-            }
-        }
+        coder.writeWord(numberOfFrames(), 2);        
+        FSMovie.encodeObjects(coder, objects);
         coder.writeWord(0, 2);
         coder.endObject(name());
     }

Modified: trunk/src/com/flagstone/transform/FSDoAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDoAction.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSDoAction.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -252,23 +252,21 @@
             {
                 FSActionObject action = (FSActionObject)i.next();
                 
+                int objStart = coder.getPointer();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
                 int next = start + (action.getLength() << 3);
             
                 action.encode(coder);
             
-                int delta = (next - coder.getPointer()) >> 3;
+                int delta = (coder.getPointer() - next) >> 3;
             
                 if (delta != 0)
                 {
                     coder.context[FSCoder.CodingError] = 1;
-
-/*
-                        if (delta < 0)
-                            coder.logError("ActionOverflow", next, -delta);
-                        else if (delta > 0)
-                            coder.logError("ActionUnderflow", next, delta);
-*/
+                    coder.context[FSCoder.TypeInError] = action.getType();
+                    coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                    coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                    coder.context[FSCoder.Delta] = delta;
                 }
                 coder.setPointer(next);
             }
@@ -289,9 +287,10 @@
         actions = new ArrayList();
         FSActionObject action = null;
         
-        while ((action = FSMovie.decodeAction(coder)) != null)
+        while ((action = FSMovie.decodeAction(coder)) != null) 
+        {
             actions.add(action);
-
+        }
         coder.endObject(name());
     }
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSExceptionHandler.java
===================================================================
--- trunk/src/com/flagstone/transform/FSExceptionHandler.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSExceptionHandler.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -438,24 +438,22 @@
         {
             FSActionObject action = (FSActionObject)i.next();
                 
+            int objStart = coder.getPointer();
             int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
             int next = start + (action.getLength() << 3);
             
             action.encode(coder);
             coder.setPointer(next);
             
-            int delta = (next - coder.getPointer()) >> 3;
+            int delta = (coder.getPointer() - next) >> 3;
             
             if (delta != 0)
             {
                 coder.context[FSCoder.CodingError] = 1;
-
-/*
-                    if (delta < 0)
-                        coder.logError("ActionOverflow", next, -delta);
-                    else if (delta > 0)
-                        coder.logError("ActionUnderflow", next, delta);
-*/
+                coder.context[FSCoder.TypeInError] = action.getType();
+                coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                coder.context[FSCoder.Delta] = delta;
             }
         }
 
@@ -465,24 +463,22 @@
             {
                 FSActionObject action = (FSActionObject)i.next();
                 
+                int objStart = coder.getPointer();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
                 int next = start + (action.getLength() << 3);
             
                 action.encode(coder);
                 coder.setPointer(next);
             
-                int delta = (next - coder.getPointer()) >> 3;
+                int delta = (coder.getPointer() - next) >> 3;
             
                 if (delta != 0)
                 {
                     coder.context[FSCoder.CodingError] = 1;
-
-/*
-                        if (delta < 0)
-                            coder.logError("ActionOverflow", next, -delta);
-                        else if (delta > 0)
-                            coder.logError("ActionUnderflow", next, delta);
-*/
+                    coder.context[FSCoder.TypeInError] = action.getType();
+                    coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                    coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                    coder.context[FSCoder.Delta] = delta;
                 }
             }
         }
@@ -493,24 +489,22 @@
             {
                 FSActionObject action = (FSActionObject)i.next();
                 
+                int objStart = coder.getPointer();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
                 int next = start + (action.getLength() << 3);
             
                 action.encode(coder);
                 coder.setPointer(next);
             
-                int delta = (next - coder.getPointer()) >> 3;
+                int delta = (coder.getPointer() - next) >> 3;
             
                 if (delta != 0)
                 {
                     coder.context[FSCoder.CodingError] = 1;
-
-/*
-                        if (delta < 0)
-                            coder.logError("ActionOverflow", next, -delta);
-                        else if (delta > 0)
-                            coder.logError("ActionUnderflow", next, delta);
-*/
+                    coder.context[FSCoder.TypeInError] = action.getType();
+                    coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                    coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                    coder.context[FSCoder.Delta] = delta;
                 }
             }
         }

Modified: trunk/src/com/flagstone/transform/FSInitialize.java
===================================================================
--- trunk/src/com/flagstone/transform/FSInitialize.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSInitialize.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -221,24 +221,22 @@
         {
             FSActionObject action = (FSActionObject)i.next();
                 
+            int objStart = coder.getPointer();
             int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
             int next = start + (action.getLength() << 3);
             
             action.encode(coder);
             coder.setPointer(next);
             
-            int delta = (next - coder.getPointer()) >> 3;
+            int delta = (coder.getPointer() - next) >> 3;
             
             if (delta != 0)
             {
                 coder.context[FSCoder.CodingError] = 1;
-
-/*
-                    if (delta < 0)
-                        coder.logError("ActionOverflow", next, -delta);
-                    else if (delta > 0)
-                        coder.logError("ActionUnderflow", next, delta);
-*/
+                coder.context[FSCoder.TypeInError] = action.getType();
+                coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                coder.context[FSCoder.Delta] = delta;
             }
         }
         coder.writeWord(0, 1);

Modified: trunk/src/com/flagstone/transform/FSMovie.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovie.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSMovie.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -160,10 +160,37 @@
 */  
 public final class FSMovie implements Cloneable
 {
+    static void encodeObjects(FSCoder coder, ArrayList array)
+    {
+        for (Iterator i = array.iterator(); i.hasNext();)
+        {
+            FSMovieObject object = (FSMovieObject)i.next();
+
+            int objStart = coder.getPointer();
+            int objLength = object.getLength();
+            int start = coder.getPointer() + ((object.getExtendLength() || objLength >= 63) ? 48 : 16);
+            int next = start + (objLength << 3);
+            
+            object.encode(coder);
+            coder.setPointer(next);
+            
+            int delta = (coder.getPointer() - next) >> 3;
+            
+            if (delta != 0)
+            {
+                coder.context[FSCoder.CodingError] = 1;
+                coder.context[FSCoder.TypeInError] = object.getType();
+                coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                coder.context[FSCoder.Delta] = delta;
+            }
+        }
+    }
     static FSMovieObject decodeObject(FSCoder coder)
     {
         FSMovieObject currentObject = null;
         
+        int objStart = coder.getPointer();
         int type = coder.scanWord(2, false) >> 6;
         int length = coder.scanWord(2, false) & 0x3F;
         int next = coder.getPointer() + 16 + (length << 3);
@@ -368,14 +395,17 @@
                 break;
         }
 
-        int delta = (next - coder.getPointer()) >> 3;
+        int delta = (coder.getPointer() - next) >> 3;
 
-        if (delta < 0)
-            coder.logError("ObjectOverflow", next, -delta);
-        else if (delta > 0)
-            coder.logError("ObjectUnderflow", next, delta);
-            
-        coder.context[FSCoder.Delta] = delta;
+        if (delta != 0)
+        {
+            coder.context[FSCoder.CodingError] = 1;
+            coder.context[FSCoder.TypeInError] = currentObject.getType();
+            coder.context[FSCoder.StartOfError] = objStart >>> 3;
+            coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+            coder.context[FSCoder.Delta] = delta;
+        }
+        
         coder.setPointer(next);
         
         if (identifier != 0)
@@ -388,6 +418,7 @@
     {
         FSActionObject anAction = null;
         
+        int objStart = coder.getPointer();
         int type = coder.scanWord(1, false);
         int length = 0;
         int start = coder.getPointer() + 8;
@@ -575,14 +606,17 @@
                 break;
         }
             
-        int delta = (next - coder.getPointer()) >> 3;
+        int delta = (coder.getPointer() - next) >> 3;
 
-        if (delta < 0)
-            coder.logError("ObjectOverflow", next, -delta);
-        else if (delta > 0)
-            coder.logError("ObjectUnderflow", next, delta);
+        if (delta != 0)
+        {
+            coder.context[FSCoder.CodingError] = 1;
+            coder.context[FSCoder.TypeInError] = anAction.getType();
+            coder.context[FSCoder.StartOfError] = objStart >>> 3;
+            coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+            coder.context[FSCoder.Delta] = delta;
+        }
 
-        coder.context[FSCoder.Delta] = delta;
         coder.setPointer(next);
 
         return anAction;
@@ -658,12 +692,13 @@
      * 	file to generate an array of objects representing the Flash file. If 
      * an error occurs while reading and parsing the file then an exception is 
      * thrown.
-        
-        @param fileName the path to the Flash file that will be parsed.
-        @throws FileNotFoundException - if an error occurs while reading the file.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the file.
-        */
+     * 
+     * @param fileName the path to the Flash file that will be parsed.
+     * @throws FileNotFoundException - if an error occurs while reading the file.
+     * @throws DataFormatException - if the file does not contain Flash data.
+     * @throws FSCoderException - if an error occurs while decoding the file.
+     * @throws IOException - if an I/O error occurs while reading the file.
+     */
     public FSMovie(String fileName) throws FileNotFoundException, DataFormatException, IOException
     {
         decodeFromFile(fileName);
@@ -689,10 +724,11 @@
      * Constructs an FSMovie object and decodes the binary data presented in the byte array to generate 
      * an array of objects representing the Flash data. If an error occurs while parsing the data then 
      * an Exception is thrown.
-             
+     *      
      * @param data an array of bytes containing the Flash binary data.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the data.
+     * @throws DataFormatException - if the file does not contain Flash data.
+     * @throws FSCoderException - if an error occurs while decoding the file.
+     * @throws IOException - if an I/O error occurs while reading the file.
      */
     public FSMovie(byte[] data) throws DataFormatException, IOException
     {
@@ -930,9 +966,10 @@
      * an error occurs while reading and parsing the file then an exception is thrown.
      *
      * @param fileName the path to the Flash file that will be parsed.
-        @throws FileNotFoundException - if an error occurs while reading the file.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the file.
+     * @throws FileNotFoundException - if an error occurs while reading the file.
+     * @throws DataFormatException - if the file does not contain Flash data.
+     * @throws FSCoderException - if an error occurs while decoding the file.
+     * @throws IOException - if an I/O error occurs while reading the file.
      */
     public void decodeFromFile(String fileName) throws FileNotFoundException, DataFormatException, IOException
     {
@@ -1005,9 +1042,10 @@
     * contain the last tag successfully decoded.
     *
     * @param bytes an array of bytes that contain the encoded Flash objects.
-    *
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the file.
+    * 
+    * @throws DataFormatException - if the file does not contain Flash data.
+    * @throws FSCoderException - if an error occurs while decoding the file.
+    * @throws IOException - if an I/O error occurs while reading the file.
     */
     public void decodeFromData(byte[] bytes) throws DataFormatException, IOException
     {
@@ -1029,13 +1067,20 @@
         frameCount = coder.readWord(2, false);
         
         coder.context[FSCoder.Version] = version;
-
+                      
         while ((object = decodeObject(coder)) != null)
         {
             objects.add(object);
             
-            if (coder.context[FSCoder.Delta] != 0)
-                throw new IOException("Movie object did not decode correctly.");
+            if (coder.context[FSCoder.CodingError] == 1)
+            {
+                throw new FSCoderException(
+                    coder.context[FSCoder.TypeInError],
+                    coder.context[FSCoder.StartOfError],
+                    coder.context[FSCoder.ExpectedLength],
+                    coder.context[FSCoder.Delta],
+                    (coder.context[FSCoder.Delta] > 0) ? "ObjectOverflow" : "ObjectUnderflow");
+            }
         }
         identifier = coder.context[FSCoder.Identifier];
     }
@@ -1106,8 +1151,9 @@
      *
      * @param fileName the path to the Flash file that the movie will be encoded to.
      *
-        @throws FileNotFoundException - if an error occurs while reading the file.
-        @throws IOException - if an error occurs while encoding and writing the file.
+     * @throws FileNotFoundException - if an error occurs while reading the file.
+     * @throws FSCoderException - if an error occurs while encoding the file.
+     * @throws IOException - if an I/O error occurs while reading the file.
      */
     public void encodeToFile(String fileName) throws FileNotFoundException, IOException
     {
@@ -1166,15 +1212,13 @@
      * If an error occurs while encoding the file then an exception is thrown.
      *
      * @return the array of bytes representing the encoded objects.
-       @throws IOException - if an error occurs while encoding the file.
+     * @throws FSCoderException - if an error occurs while encoding the file.
+     * @throws IOException - if an I/O error occurs while encoding the file.
      */
     public byte[] encode() throws IOException
     {
         FSCoder coder = new FSCoder();
         
-//        if (version > Transform.VERSION)
-//            throw new IOException("Cannot encode a file later than version " + Transform.VERSION + ".");
-        
         coder.context[FSCoder.Action]  = FSMovieEvent.Encode;        
         coder.context[FSCoder.Version] = version;
 
@@ -1200,8 +1244,15 @@
             object.encode(coder);
             coder.setPointer(next);
     
-            if ((coder.context[FSCoder.CodingError] == 1) || ((next - coder.getPointer()) >> 3) != 0)
-                throw new IOException("Movie object did not encode correctly.");
+            if (coder.context[FSCoder.CodingError] == 1)
+            {
+                throw new FSCoderException(
+                    coder.context[FSCoder.TypeInError],
+                    coder.context[FSCoder.StartOfError],
+                    coder.context[FSCoder.ExpectedLength],
+                    coder.context[FSCoder.Delta],
+                    (coder.context[FSCoder.Delta] > 0) ? "ObjectOverflow" : "ObjectUnderflow");
+            }
         }
         coder.writeWord(0, 2);
 
@@ -1267,7 +1318,7 @@
             object.encode(coder);
             coder.setPointer(next);
             
-            int delta = (next - coder.getPointer()) >> 3;
+            int delta = (coder.getPointer() - next) >> 3;
     
             if (delta < 0)
                 coder.logError("ObjectOverflow", next, -delta);
@@ -1283,13 +1334,6 @@
 
         try
         {
-            // if the version of the Flash file is greater than the 
-            // version supported by the framework then throw the 
-            // exception first so the data returned will be null.
-            
-//            if (version > Transform.VERSION)
-//                throw new DataFormatException();
-
             if (signature.equals("CWS"))
                 data = zip(coder.getData(), fileLength);
             else

Modified: trunk/src/com/flagstone/transform/FSNewFunction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSNewFunction.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -368,29 +368,27 @@
         }
         
         coder.writeWord(actionsLength, 2);
-            
+        
         for (Iterator i=actions.iterator(); i.hasNext();)
         {
             FSActionObject action = (FSActionObject)i.next();
                 
+            int objStart = coder.getPointer();
             int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
             int next = start + (action.getLength() << 3);
             
             action.encode(coder);
             coder.setPointer(next);
             
-            int delta = (next - coder.getPointer()) >> 3;
+            int delta = (coder.getPointer() - next) >> 3;
             
             if (delta != 0)
             {
                 coder.context[FSCoder.CodingError] = 1;
-
-/*
-                    if (delta < 0)
-                        coder.logError("ActionOverflow", next, -delta);
-                    else if (delta > 0)
-                        coder.logError("ActionUnderflow", next, delta);
-*/
+                coder.context[FSCoder.TypeInError] = action.getType();
+                coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                coder.context[FSCoder.Delta] = delta;
             }
         }
         coder.endObject(name());

Modified: trunk/src/com/flagstone/transform/FSNewFunction2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction2.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSNewFunction2.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -499,29 +499,27 @@
             ((FSRegisterVariable)i.next()).encode(coder);
 
         coder.writeWord(actionsLength, 2);
-            
+           
         for (Iterator i=actions.iterator(); i.hasNext();)
         {
             FSActionObject action = (FSActionObject)i.next();
                 
+            int objStart = coder.getPointer();
             int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
             int next = start + (action.getLength() << 3);
             
             action.encode(coder);
             coder.setPointer(next);
             
-            int delta = (next - coder.getPointer()) >> 3;
+            int delta = (coder.getPointer() - next) >> 3;
             
             if (delta != 0)
             {
                 coder.context[FSCoder.CodingError] = 1;
-
-/*
-                    if (delta < 0)
-                        coder.logError("ActionOverflow", next, -delta);
-                    else if (delta > 0)
-                        coder.logError("ActionUnderflow", next, delta);
-*/
+                coder.context[FSCoder.TypeInError] = action.getType();
+                coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                coder.context[FSCoder.Delta] = delta;
             }
         }
 

Modified: trunk/src/com/flagstone/transform/FSWith.java
===================================================================
--- trunk/src/com/flagstone/transform/FSWith.java	2006-02-23 12:32:07 UTC (rev 81)
+++ trunk/src/com/flagstone/transform/FSWith.java	2006-02-23 12:32:43 UTC (rev 82)
@@ -193,25 +193,23 @@
         for (Iterator i=actions.iterator(); i.hasNext();)
         {
             FSActionObject action = (FSActionObject)i.next();
-                
+              
+            int objStart = coder.getPointer();
             int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
             int next = start + (action.getLength() << 3);
             
             action.encode(coder);
             coder.setPointer(next);
             
-            int delta = (next - coder.getPointer()) >> 3;
+            int delta = (coder.getPointer() - next) >> 3;
             
             if (delta != 0)
             {
                 coder.context[FSCoder.CodingError] = 1;
-
-/*
-                    if (delta < 0)
-                        coder.logError("ActionOverflow", next, -delta);
-                    else if (delta > 0)
-                        coder.logError("ActionUnderflow", next, delta);
-*/
+                coder.context[FSCoder.TypeInError] = action.getType();
+                coder.context[FSCoder.StartOfError] = objStart >>> 3;
+                coder.context[FSCoder.ExpectedLength] = (next-objStart)>>>3;
+                coder.context[FSCoder.Delta] = delta;
             }
         }
 



From smackay at berlios.de  Thu Feb 23 13:31:29 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Thu, 23 Feb 2006 13:31:29 +0100
Subject: [Transform-svn] r80 - trunk/src/com/flagstone/transform/test
Message-ID: <200602231231.k1NCVTNM016697@sheep.berlios.de>

Author: smackay
Date: 2006-02-23 13:31:20 +0100 (Thu, 23 Feb 2006)
New Revision: 80

Modified:
   trunk/src/com/flagstone/transform/test/FSMovieTest.java
Log:
Fixed an error is FSMovieTest so exceptions thrown when encoding or 
decoding files are now triggering assertions.

Modified: trunk/src/com/flagstone/transform/test/FSMovieTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSMovieTest.java	2006-02-23 11:27:20 UTC (rev 79)
+++ trunk/src/com/flagstone/transform/test/FSMovieTest.java	2006-02-23 12:31:20 UTC (rev 80)
@@ -30,7 +30,6 @@
 package com.flagstone.transform.test;
 
 import java.io.*;
-import java.util.zip.*;
 
 import com.flagstone.transform.*;
 import com.flagstone.transform.tools.*;
@@ -62,14 +61,10 @@
         {
             new FSMovie(new File(sourceDir, file).getPath());
         }
-        catch (DataFormatException e)
+        catch (Exception e)
         {
-            assert true;
+            assert false : file+": "+e.toString();
         }
-        catch (IOException e)
-        {
-            assert true : e.getMessage();
-        }
     }
     /**
      * @testng.test dataProvider="files"
@@ -87,13 +82,9 @@
             FSMovie movie = new FSMovie(srcFile.getPath());
             movie.encodeToFile(destFile.getPath());
         }
-        catch (DataFormatException e)
-        {
-            assert false;
-        }
         catch (Exception e)
         {
-            assert false : e.getMessage();
+            assert false : file+": "+e.toString();
         }
     }
     /**
@@ -114,14 +105,10 @@
             FSMovie clone = (FSMovie)movie.clone();
             clone.encodeToFile(destFile.getPath());
         }
-        catch (DataFormatException e)
+        catch (Exception e)
         {
-            assert false;
+            assert false : file+": "+e.toString();
         }
-        catch (IOException e)
-        {
-            assert false : e.getMessage();
-        }
     }
     /**
      * @testng.test dataProvider="files"



From smackay at berlios.de  Sat Feb 25 19:36:25 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Sat, 25 Feb 2006 19:36:25 +0100
Subject: [Transform-svn] r83 - in trunk: doc src/com/flagstone/transform/tools
Message-ID: <200602251836.k1PIaPPI002434@sheep.berlios.de>

Author: smackay
Date: 2006-02-25 19:34:57 +0100 (Sat, 25 Feb 2006)
New Revision: 83

Modified:
   trunk/doc/CHANGES.txt
   trunk/src/com/flagstone/transform/tools/TextDump.java
Log:
Optimised the text dump tool

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-23 12:32:43 UTC (rev 82)
+++ trunk/doc/CHANGES.txt	2006-02-25 18:34:57 UTC (rev 83)
@@ -1,3 +1,7 @@
+2006-02-25 - smackay at flagstonesoftware.com
+
+    * Optimized the TextDump tool.
+
 2006-02-23 - smackay at flagstonesoftware.com
 
     * Added a new exception class, FSCoderException to report when underflow or

Modified: trunk/src/com/flagstone/transform/tools/TextDump.java
===================================================================
--- trunk/src/com/flagstone/transform/tools/TextDump.java	2006-02-23 12:32:43 UTC (rev 82)
+++ trunk/src/com/flagstone/transform/tools/TextDump.java	2006-02-25 18:34:57 UTC (rev 83)
@@ -36,6 +36,7 @@
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.PrintWriter;
 
 import javax.swing.tree.DefaultMutableTreeNode;
 /**
@@ -58,12 +59,11 @@
  */
 public class TextDump extends Tool
 {
-    private static String newline = System.getProperty("line.separator");
-    
     private static final int Begin = 0;
-    private static final int End = 1;
-    private static final int Error  = 2;
-    private static final int Value = 3;
+    private static final int BeginArray = 1;
+    private static final int End = 2;
+    private static final int Error  = 3;
+    private static final int Value = 4;
 
     private class SWF
     {
@@ -324,12 +324,12 @@
         
                 coder.context[SWFDecoder.Version] = version;
         
-                coder.beginObject("objects", "Array");
+                coder.beginArray("objects");
             
                 while (decodeObject(coder));
                     
-                coder.endObject("Array");        
-                coder.endObject("Movie");
+                coder.endObject();        
+                coder.endObject();
             }
             catch (DataFormatException e)
             {
@@ -590,7 +590,7 @@
             coder.beginObject(name, "Bounds");
             coder.alignToByte();
             
-            int fieldSize = coder.readBits("fieldSize", 5, false);
+            int fieldSize = coder.readBits("size", 5, false);
             
             coder.readBits("minX", fieldSize, true);
             coder.readBits("maxX", fieldSize, true);
@@ -599,7 +599,7 @@
             
             coder.alignToByte();
 
-            coder.endObject("Bounds");
+            coder.endObject();
         }
 
         void decodeColor(String name, SWFDecoder coder)
@@ -613,7 +613,7 @@
             if (coder.context[SWFDecoder.TransparentColors] != 0)
                 coder.readWord("alpha", 1, false);
 
-            coder.endObject("Color");
+            coder.endObject();
         }
 
         void decodeColorTransform(String name, SWFDecoder coder)
@@ -621,9 +621,9 @@
             coder.beginObject(name, "ColorTransform");
             coder.alignToByte();
 
-            boolean containsAddTerms = coder.readBool("containsAddTerms");
-            boolean containsMultiplyTerms = coder.readBool("containsMultiplyTerms");
-            int fieldSize = coder.readBits("fieldSize", 4, false);
+            boolean containsAddTerms = coder.readBool("hasAddTerms");
+            boolean containsMultiplyTerms = coder.readBool("hasMultiplyTerms");
+            int fieldSize = coder.readBits("size", 4, false);
             
             if (containsMultiplyTerms)
             {
@@ -645,7 +645,7 @@
                     coder.readBits("addAlpha", fieldSize, true);
             }
             coder.alignToByte();
-            coder.endObject("ColorTransform");
+            coder.endObject();
         }
 
         void decodeCoordTransform(String name, SWFDecoder coder)
@@ -653,14 +653,14 @@
             coder.beginObject(name, "CoordTransform");
             coder.alignToByte();
 
-            if (coder.readBool("containsScaling"))
+            if (coder.readBool("hasScaling"))
             {
                 int scaleFieldSize = coder.readBits("scalingFieldSize", 5, false);
                 coder.readFixed("scale0", scaleFieldSize);
                 coder.readFixed("scale1", scaleFieldSize);
             }
         
-            if (coder.readBool("containsRotation"))
+            if (coder.readBool("hasRotation"))
             {
                 int rotateFieldSize = coder.readBits("rotationFieldSize", 5, false);
                 coder.readFixed("rotate0", rotateFieldSize);
@@ -672,7 +672,7 @@
             coder.readBits("translateY", translateFieldSize, true);
             
             coder.alignToByte();
-            coder.endObject("CoordTransform");
+            coder.endObject();
         }
 
         void decodeSound(SWFDecoder coder)
@@ -682,10 +682,10 @@
             coder.readWord("identifier", 2, false);
             coder.readBits("mode", 4, false);
             
-            boolean _containsEnvelopes = coder.readBool("containsEnvelopes");
-            boolean _containsLoopCount = coder.readBool("containsLoopCount");
-            boolean _containsOutPoint = coder.readBool("containsOutPoint");
-            boolean _containsInPoint = coder.readBool("containsInPoint");
+            boolean _containsEnvelopes = coder.readBool("hasEnvelopes");
+            boolean _containsLoopCount = coder.readBool("hasLoopCount");
+            boolean _containsOutPoint = coder.readBool("hasOutPoint");
+            boolean _containsInPoint = coder.readBool("hasInPoint");
         
             if (_containsInPoint)
                 coder.readWord("inPoint", 4, false);
@@ -700,14 +700,14 @@
             {
                 int envelopeCount = coder.readWord("envelopeCount", 1, false);
 
-                coder.beginObject("envelopes", "Array");
+                coder.beginArray("envelopes");
                     
                 for (int i=0; i<envelopeCount; i++)
                     decodeEnvelope(coder);
                 
-                coder.endObject("Array");
+                coder.endObject();
             }
-            coder.endObject("Sound");
+            coder.endObject();
         }
 
         void decodeEnvelope(SWFDecoder coder)
@@ -716,43 +716,41 @@
             coder.readWord("mark", 4, false);
             coder.readWord("leftSoundLevel", 2, false);
             coder.readWord("rightSoundLevel", 2, false);
-            coder.endObject("Envelope");
+            coder.endObject();
         }
 
         void decodeCurve(SWFDecoder coder)
         {
             coder.beginObject("curve", "Curve");
 
-            coder.readBits("shapeType", 1, false);
-            coder.readBits("edgeType", 1, false); 
+            coder.readBits("type", 2, false);
             
-            int fieldSize = coder.readBits("fieldSize", 4, false) + 2;
+            int fieldSize = coder.readBits("size", 4, false) + 2;
             
-            coder.readBits("controlX", fieldSize, true);
-            coder.readBits("controlY", fieldSize, true);
-            coder.readBits("anchorX", fieldSize, true);
-            coder.readBits("anchorY", fieldSize, true);
+            coder.readBits("cx", fieldSize, true);
+            coder.readBits("cy", fieldSize, true);
+            coder.readBits("ax", fieldSize, true);
+            coder.readBits("ay", fieldSize, true);
 
-            coder.endObject("Curve");
+            coder.endObject();
         }
 
         void decodeLine(SWFDecoder coder)
         {
             coder.beginObject("line", "Line");
 
-            coder.readBits("shapeType", 1, false);
-            coder.readBits("edgeType", 1, false);
+            coder.readBits("type", 2, false);
             
-            int fieldSize = coder.readBits("fieldSize", 4, false)+2;
+            int fieldSize = coder.readBits("size", 4, false)+2;
 
-            if (coder.readBool("isGeneral"))
+            if (coder.readBool("hasXY"))
             {
                 coder.readBits("x", fieldSize, true);
                 coder.readBits("y", fieldSize, true);
             }
             else
             {
-                if (coder.readBool("isVertical"))
+                if (coder.readBool("hasY"))
                 {
                     coder.readBits("y", fieldSize, true);
                 }
@@ -761,7 +759,7 @@
                     coder.readBits("x", fieldSize, true);
                 }
             }
-            coder.endObject("Line");
+            coder.endObject();
         }
 
         void decodeShapeStyle(SWFDecoder coder)
@@ -771,16 +769,16 @@
 
             coder.beginObject("shapeStyle", "ShapeStyle");
 
-            coder.readBits("shapeType", 1, false);
-            boolean containsStyles = coder.readBool("containsStyles");
-            boolean containsLineStyle = coder.readBool("containsLineStyle");
-            boolean containsAltFillStyle = coder.readBool("containsAltFillStyle");
-            boolean containsFillStyle = coder.readBool("containsFillStyle");
-            boolean containsMove = coder.readBool("containsMove");
+            coder.readBits("type", 1, false);
+            boolean containsStyles = coder.readBool("hasStyles");
+            boolean containsLineStyle = coder.readBool("hasLineStyle");
+            boolean containsAltFillStyle = coder.readBool("hasAltFillStyle");
+            boolean containsFillStyle = coder.readBool("hasFillStyle");
+            boolean containsMove = coder.readBool("hasMove");
             
             if (containsMove)
             {
-                int moveFieldSize = coder.readBits("fieldSize", 5, false);
+                int moveFieldSize = coder.readBits("size", 5, false);
                 coder.readBits("x", moveFieldSize, true);
                 coder.readBits("y", moveFieldSize, true);
             }
@@ -803,7 +801,7 @@
                 if (coder.context[SWFDecoder.ArrayCountExtended] != 0 && fillStyleCount == 0xFF)
                     fillStyleCount = coder.readWord("fillStyleCountExtended", 2, false);
 
-                coder.beginObject("fillStyles", "Array");
+                coder.beginArray("fillStyles");
         
                 for (int i=0; i<fillStyleCount; i++)
                 {
@@ -825,19 +823,19 @@
                     }        
                 }
                 
-                coder.endObject("Array");
+                coder.endObject();
         
                 int lineStyleCount = coder.readWord("lineStyleCount", 1, false);
 
                 if (coder.context[SWFDecoder.ArrayCountExtended] != 0 && lineStyleCount == 0xFF)
                     lineStyleCount = coder.readWord("lineStyleCountExtended", 2, false);
 
-                coder.beginObject("lineStyles", "Array");
+                coder.beginArray("lineStyles");
         
                 for (int i=0; i<lineStyleCount; i++)
                     decodeSolidLine(coder);
                 
-                coder.endObject("Array");
+                coder.endObject();
         
                 numberOfFillBits = coder.readBits("numberOfFillBits", 4, false);
                 numberOfLineBits = coder.readBits("numberOfLineBits", 4, false);
@@ -845,7 +843,7 @@
                 coder.context[SWFDecoder.NumberOfFillBits] = numberOfFillBits;
                 coder.context[SWFDecoder.NumberOfLineBits] = numberOfLineBits;
             }
-            coder.endObject("ShapeStyle");
+            coder.endObject();
         }
 
         void decodeSolidLine(SWFDecoder coder)
@@ -853,7 +851,7 @@
             coder.beginObject("solidLine", "SolidLine");
             coder.readWord("width", 2, false);
             decodeColor("color", coder);
-            coder.endObject("SolidLine");
+            coder.endObject();
         }
       
         void decodeSolidFill(SWFDecoder coder)
@@ -861,7 +859,7 @@
             coder.beginObject("solidFill", "SolidFill");
             coder.readWord("type", 1, false);
             decodeColor("color", coder);
-            coder.endObject("SolidFill");
+            coder.endObject();
         }
 
         void decodeGradientFill(SWFDecoder coder)
@@ -871,13 +869,13 @@
             decodeCoordTransform("coordTransform", coder);
             int count = coder.readWord("gradientCount", 1, false);
 
-            coder.beginObject("gradients", "Array");
+            coder.beginArray("gradients");
 
             for (int i=0; i<count; i++)
                 decodeGradient(coder);
 
-            coder.endObject("Array");
-            coder.endObject("GradientFill");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodeGradient(SWFDecoder coder)
@@ -885,7 +883,7 @@
             coder.beginObject("gradient", "Gradient");
             coder.readWord("ratio", 1, false);
             decodeColor("color", coder);
-            coder.endObject("Gradient");
+            coder.endObject();
         }
         
         void decodeBitmapFill(SWFDecoder coder)
@@ -894,7 +892,7 @@
             coder.readWord("type", 1, false);
             coder.readWord("identifier", 2, false);
             decodeCoordTransform("coordTransform", coder);
-            coder.endObject("BitmapFill");
+            coder.endObject();
         }
         
         void decodeShape(SWFDecoder coder)
@@ -904,7 +902,7 @@
             coder.context[SWFDecoder.NumberOfFillBits] = coder.readBits("numberOfFillBits", 4, false);
             coder.context[SWFDecoder.NumberOfLineBits] = coder.readBits("numberOfLineBits", 4, false);
 
-            coder.beginObject("path", "Array");
+            coder.beginArray("path");
 
             while (coder.scanBits(6, false) > 0)
             {
@@ -922,8 +920,8 @@
             }
             coder.readBits("endOfShape", 6, false);
             coder.alignToByte();
-            coder.endObject("Array");
-            coder.endObject("Shape");
+            coder.endObject();
+            coder.endObject();
         }
 
         int decodeMovieObject(SWFDecoder coder)
@@ -962,14 +960,14 @@
                 length = coder.readWord("lengthExtended", 4, false);
             
             decodeColor("color", coder);
-            coder.endObject("SetBackgroundColor");
+            coder.endObject();
         }
 
         void decodeShowFrame(SWFDecoder coder)
         {
             coder.beginObject("showFrame", "ShowFrame");
             decodeMovieObject(coder);
-            coder.endObject("ShowFrame");
+            coder.endObject();
         }   
 
         void decodeDoAction(SWFDecoder coder)
@@ -977,12 +975,12 @@
             coder.beginObject("doAction", "DoAction");
             decodeMovieObject(coder);
             
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
             
             while (decodeAction(coder) != 0);
             
-           coder.endObject("Array");
-           coder.endObject("DoAction");
+           coder.endObject();
+           coder.endObject();
         }
 
         void decodeFontInfo(SWFDecoder coder)
@@ -999,19 +997,19 @@
             coder.readBool("isANSI");
             coder.readBool("isItalic");
             coder.readBool("isBold");
-            boolean containsWideCodes = coder.readBool("containsWideCodes"); 
+            boolean containsWideCodes = coder.readBool("hasWideCodes"); 
 
             int bytesRead = 3 + nameLength + 1;
 
-            coder.beginObject("codes", "Array");
+            coder.beginArray("codes");
 
             while (bytesRead < length)
             {
                 coder.readWord("code", containsWideCodes ? 2 : 1, false);
                 bytesRead += (containsWideCodes) ? 2 : 1;
             }
-            coder.endObject("Array");
-            coder.endObject("FontInfo");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodeJPEGEncodingTable(SWFDecoder coder)
@@ -1019,7 +1017,7 @@
             coder.beginObject("JPEGEncodingTable", "JPEGEncodingTable");
             int length = decodeMovieObject(coder);
             coder.readBytes("encodingTable", length);
-            coder.endObject("JPEGEncodingTable");
+            coder.endObject();
         }
 
         void decodePlaceObject(SWFDecoder coder)
@@ -1037,7 +1035,7 @@
             if (length > lengthRead)
                 decodeColorTransform("colorTransform", coder);
 
-            coder.endObject("PlaceObject");
+            coder.endObject();
         }
         
         void decodeRemoveObject(SWFDecoder coder)
@@ -1046,7 +1044,7 @@
             decodeMovieObject(coder);
             coder.readWord("identifier", 2, false);
             coder.readWord("layer", 2, false);
-            coder.endObject("RemoveObject");
+            coder.endObject();
         }
 
         void decodeSoundStreamBlock(SWFDecoder coder)
@@ -1054,7 +1052,7 @@
             coder.beginObject("soundStreamBlock", "SoundStreamBlock");
             int length = decodeMovieObject(coder);
             coder.readBytes("soundData", length); // 
-            coder.endObject("SoundStreamBlock");
+            coder.endObject();
         }
 
         void decodeSoundStreamHead(SWFDecoder coder)
@@ -1074,7 +1072,7 @@
             if (format == 2) // MP3
                 coder.readWord("latency", 2, true); 
 
-            coder.endObject("SoundStreamHead");
+            coder.endObject();
         }
 
         void decodeStartSound(SWFDecoder coder)
@@ -1082,7 +1080,7 @@
             coder.beginObject("startSound", "StartSound");
             decodeMovieObject(coder);
             decodeSound(coder);
-            coder.endObject("StartSound");
+            coder.endObject();
         }
 
         void decodeUnknownObject(SWFDecoder coder)
@@ -1090,7 +1088,7 @@
             coder.beginObject("unknownObject", "UnknownObject");
             int length = decodeMovieObject(coder);
             coder.readBytes("data", length); 
-            coder.endObject("UnknownObject");
+            coder.endObject();
         }
 
         int decodeActionObject(SWFDecoder coder)
@@ -1109,7 +1107,7 @@
             decodeActionObject(coder);
             coder.readString("url");
             coder.readString("target");
-            coder.endObject("GetUrl");
+            coder.endObject();
         }
 
         void decodeGotoFrame(SWFDecoder coder)
@@ -1117,7 +1115,7 @@
             coder.beginObject("gotoFrame", "GotoFrame");
             decodeActionObject(coder);
             coder.readWord("frameNumber", 2, false);
-            coder.endObject("GotoFrame");
+            coder.endObject();
         }
 
         void decodeUnknownAction(SWFDecoder coder)
@@ -1128,7 +1126,7 @@
             if (length > 0)
                 coder.readBytes("data", length);
 
-            coder.endObject("UnknownAction");
+            coder.endObject();
         }
         
         void decodeTextRecord(SWFDecoder coder)
@@ -1138,10 +1136,10 @@
             coder.readBits("type", 1, false); // 
             coder.readBits("reserved", 3, false); // 
             
-            boolean _containsFont = coder.readBool("containsFont");
-            boolean _containsColor = coder.readBool("containsColor");
-            boolean _containsBaseline = coder.readBool("containsBaseline");
-            boolean _containsIndent = coder.readBool("containsIndent");
+            boolean _containsFont = coder.readBool("hasFont");
+            boolean _containsColor = coder.readBool("hasColor");
+            boolean _containsBaseline = coder.readBool("hasBaseline");
+            boolean _containsIndent = coder.readBool("hasIndent");
 
             if (_containsFont)
                 coder.readWord("identifier", 2, false);
@@ -1158,15 +1156,15 @@
 
             int charCount = coder.readWord("characterCount", 1, false);
             
-            coder.beginObject("characters", "Array");
+            coder.beginArray("characters");
                 
             for (int i=0; i<charCount; i++)
                 decodeCharacter(coder);
             
             coder.alignToByte();
             
-            coder.endObject("Array");
-            coder.endObject("Text");
+            coder.endObject();
+            coder.endObject();
         }
         
         void decodeCharacter(SWFDecoder coder)
@@ -1174,7 +1172,7 @@
             coder.beginObject("character", "Character");
             coder.readBits("glyphIndex", coder.context[SWFDecoder.NumberOfGlyphBits], false);
             coder.readBits("advance", coder.context[SWFDecoder.NumberOfAdvanceBits], true);
-            coder.endObject("Character");
+            coder.endObject();
         }
 
         int decodeDefineObject(SWFDecoder coder)
@@ -1202,7 +1200,7 @@
             if (coder.context[SWFDecoder.Type] == DefineButton2)
                 decodeColorTransform("colorTransform", coder);
 
-            coder.endObject("Button");
+            coder.endObject();
         }
 
         void decodeDefineButton(SWFDecoder coder)
@@ -1210,21 +1208,21 @@
             coder.beginObject("defineButton", "DefineButton");
             decodeDefineObject(coder);
             
-            coder.beginObject("buttonRecords", "Array");
+            coder.beginArray("buttonRecords");
             
             while (coder.scanWord(1, false) != 0)
                 decodeButtonRecord(coder);
                 
             coder.readWord("endOfRecords", 1, false);
 
-            coder.endObject("Array");
+            coder.endObject();
 
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
             
             while (decodeAction(coder) != 0);
             
-            coder.endObject("Array");
-            coder.endObject("DefineButton");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodeDefineFont(SWFDecoder coder)
@@ -1234,19 +1232,19 @@
             
             int shapeCount = coder.scanWord(2, false) / 2;
 
-            coder.beginObject("offsetTable", "Array");
+            coder.beginArray("offsetTable");
 
             for (int i=0; i<shapeCount; i++)
                 coder.readWord("offset", 2, false);
                 
-            coder.endObject("Array");
-            coder.beginObject("glyphs", "Array");
+            coder.endObject();
+            coder.beginArray("glyphs");
 
             for (int i=0; i<shapeCount; i++)
                 decodeShape(coder);
 
-            coder.endObject("Array");
-            coder.endObject("DefineFont");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodeDefineJPEGImage(SWFDecoder coder)
@@ -1254,7 +1252,7 @@
             coder.beginObject("defineJPEGImage", "DefineJPEGImage");
             int length = decodeDefineObject(coder);
             coder.readBytes("image", length-2);
-            coder.endObject("DefineJPEGImage");
+            coder.endObject();
         }
 
         void decodeDefineShape(SWFDecoder coder)
@@ -1268,7 +1266,7 @@
 
             if (fillStyleCount > 0)
             {
-                coder.beginObject("fillStyles", "Array");
+                coder.beginArray("fillStyles");
                 
                 for (int i=0; i<fillStyleCount; i++)
                 {
@@ -1293,23 +1291,23 @@
                             break;
                     }        
                 }           
-                coder.endObject("Array");
+                coder.endObject();
             }
 
             int lineStyleCount = coder.readWord("lineStyleCount", 1, false);
 
             if (lineStyleCount > 0)
             {
-                coder.beginObject("lineStyles", "Array");
+                coder.beginArray("lineStyles");
         
                 for (int i=0; i<lineStyleCount; i++)
                     decodeSolidLine(coder);
         
-                coder.endObject("Array");
+                coder.endObject();
             }
             decodeShape(coder);
 
-            coder.endObject("DefineShape");
+            coder.endObject();
         }
         
         void decodeDefineSound(SWFDecoder coder)
@@ -1323,7 +1321,7 @@
             coder.readBits("playbackChannels", 1, false);
             coder.readWord("sampleCount", 4, false);
             coder.readBytes("sound data", length-7);
-            coder.endObject("DefineSound");
+            coder.endObject();
         }
         
         void decodeDefineText(SWFDecoder coder)
@@ -1365,17 +1363,17 @@
             coder.context[SWFDecoder.NumberOfGlyphBits] = coder.readWord("numberOfGlyphBits", 1, false);
             coder.context[SWFDecoder.NumberOfAdvanceBits] = coder.readWord("numberOfAdvanceBits", 1, false);
             
-            coder.beginObject("textRecords", "Array");
+            coder.beginArray("textRecords");
 
             while (coder.scanBits(8, false) != 0)
                 decodeTextRecord(coder);
 
             coder.readBits("endOfText", 8, false);
-            coder.endObject("Array");
+            coder.endObject();
 
             coder.context[SWFDecoder.NumberOfGlyphBits] = 0;
             coder.context[SWFDecoder.NumberOfAdvanceBits] = 0;
-            coder.endObject("DefineText");
+            coder.endObject();
         }
         
         int decodeAction(SWFDecoder coder)
@@ -1643,12 +1641,12 @@
             if (keyPress)
                 coder.readWord("keyCode", 1, false);
             
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
 
             while (decodeAction(coder) != 0);
 
-            coder.endObject("Array");
-            coder.endObject("ClipEvent");
+            coder.endObject();
+            coder.endObject();
         }
         
         void decodeMorphSolidLine(SWFDecoder coder)
@@ -1658,7 +1656,7 @@
             coder.readWord("endWidth", 2, false);
             decodeColor("startColor", coder);
             decodeColor("endColor", coder);
-            coder.endObject("MorphSolidLine");
+            coder.endObject();
         }
 
         void decodeMorphSolidFill(SWFDecoder coder)
@@ -1667,7 +1665,7 @@
             coder.readWord("type", 1, false);
             decodeColor("startColor", coder);
             decodeColor("endColor", coder);
-            coder.endObject("MorphSolidFill");
+            coder.endObject();
         }
         
         void decodeMorphGradientFill(SWFDecoder coder)
@@ -1679,13 +1677,13 @@
             
             int count = coder.readWord("gradientCount", 1, false);
                                 
-            coder.beginObject("gradients", "Array");
+            coder.beginArray("gradients");
                 
             for (int i=0; i<count; i++)
                 decodeMorphGradient(coder);
             
-            coder.endObject("Array");
-            coder.endObject("MorphGradientFill");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodeMorphGradient(SWFDecoder coder)
@@ -1695,7 +1693,7 @@
             decodeColor("startColor", coder);
             coder.readWord("endRatio", 1, false);
             decodeColor("endColor", coder);
-            coder.endObject("MorphGradient");
+            coder.endObject();
         }
 
         void decodeMorphBitmapFill(SWFDecoder coder)
@@ -1705,7 +1703,7 @@
             coder.readWord("identifier", 2, false); // 
             decodeCoordTransform("startTransform", coder);
             decodeCoordTransform("endTransform", coder);
-            coder.endObject("MorphBitmapFill");
+            coder.endObject();
         }
         
         void decodeButtonColorTransform(SWFDecoder coder)
@@ -1714,7 +1712,7 @@
             decodeMovieObject(coder);
             coder.readWord("identifier", 2, false);
             decodeColorTransform("colorTransform", coder);
-            coder.endObject("ButtonColorTransform");
+            coder.endObject();
         }
         
         void decodeButtonSound(SWFDecoder coder)
@@ -1730,7 +1728,7 @@
                 else
                     coder.readWord("none", 2, false);
             }
-            coder.endObject("ButtonSound");
+            coder.endObject();
         }
 
         void decodeEnableDebugger(SWFDecoder coder)
@@ -1738,7 +1736,7 @@
             coder.beginObject("enableDebugger", "EnableDebugger");
             decodeMovieObject(coder);
             coder.readString("password");
-            coder.endObject("EnableDebugger");
+            coder.endObject();
         }
 
         void decodeEnableDebugger2(SWFDecoder coder)
@@ -1747,7 +1745,7 @@
             decodeMovieObject(coder);
             coder.readWord("reserved", 2, false);
             coder.readString("password");
-            coder.endObject("EnableDebugger2");
+            coder.endObject();
         }
         
         void decodeExport(SWFDecoder coder)
@@ -1757,16 +1755,16 @@
             
             int count = coder.readWord("count", 2, false);
 
-            coder.beginObject("objects", "Array");
+            coder.beginArray("objects");
             for (int i=0; i<count; i++)
             {
                 coder.beginObject("exports", "Object");
                 coder.readWord("identifier", 2, false);
                 coder.readString("name");
-                coder.endObject("Object");
+                coder.endObject();
             }
-            coder.endObject("Array");
-            coder.endObject("Export");
+            coder.endObject();
+            coder.endObject();
         }
         
         void decodeFontInfo2(SWFDecoder coder)
@@ -1782,20 +1780,20 @@
             coder.readBits("encoding", 2, false);
             coder.readBool("isItalic");
             coder.readBool("isBold"); 
-            coder.readBool("containsWideCodes");
+            coder.readBool("hasWideCodes");
             coder.readWord("language", 1, false);
 
             int bytesRead = 4 + nameLength + 1;
             
-            coder.beginObject("codes", "Array");
+            coder.beginArray("codes");
 
             while (bytesRead < length)
             {
                 coder.readWord("code", 2, false);
                 bytesRead += 2;
             }
-            coder.endObject("Array");
-            coder.endObject("FontInfo2");
+            coder.endObject();
+            coder.endObject();
         }
         
         void decodeFrameLabel(SWFDecoder coder)
@@ -1815,7 +1813,7 @@
             if (coder.context[SWFDecoder.Version] > 5 && strlen < length)
                 coder.readWord("anchor", 1, false);
 
-            coder.endObject("FrameLabel");
+            coder.endObject();
         }
 
         void decodeFree(SWFDecoder coder)
@@ -1823,7 +1821,7 @@
             coder.beginObject("free", "Free");
             decodeMovieObject(coder);
             coder.readWord("identifier", 2, false);
-            coder.endObject("Free");
+            coder.endObject();
         }
 
         void decodeImport(SWFDecoder coder)
@@ -1834,16 +1832,16 @@
             
             int count = coder.readWord("count", 2, false);
 
-            coder.beginObject("objects", "Array");
+            coder.beginArray("objects");
             for (int i=0; i<count; i++)
             {
                 coder.beginObject("object", "Object");
                 coder.readWord("identifier", 2, false);
                 coder.readString("name");
-                coder.endObject("Object");
+                coder.endObject();
             }
-            coder.endObject("Array");
-            coder.endObject("Import");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodeInitialize(SWFDecoder coder)
@@ -1852,19 +1850,19 @@
             decodeMovieObject(coder);
             coder.readWord("identifier", 2, false);
             
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
             
             while (decodeAction(coder) != 0);
             
-            coder.endObject("Array");
-            coder.endObject("Initialize");
+            coder.endObject();
+            coder.endObject();
         }
 
         void decodePathsArePostscript(SWFDecoder coder)
         {
             coder.beginObject("pathsArePostscript", "PathsArePostscript");
             decodeMovieObject(coder);
-            coder.endObject("PathsArePostscript");
+            coder.endObject();
         }
         
         void decodePlaceObject2(SWFDecoder coder)
@@ -1875,12 +1873,12 @@
             
             decodeMovieObject(coder);
             
-            boolean containsClipEvents = coder.readBool("containsClipEvents");
-            boolean containsClippingDepth = coder.readBool("containsClippingDepth");
-            boolean containsName = coder.readBool("containsName");
-            boolean containsRatio = coder.readBool("containsRatio");
-            boolean containsColorTransform = coder.readBool("containsColorTransform");
-            boolean containsTransform = coder.readBool("containsCoordTransform");
+            boolean containsClipEvents = coder.readBool("hasClipEvents");
+            boolean containsClippingDepth = coder.readBool("hasClippingDepth");
+            boolean containsName = coder.readBool("hasName");
+            boolean containsRatio = coder.readBool("hasRatio");
+            boolean containsColorTransform = coder.readBool("hasColorTransform");
+            boolean containsTransform = coder.readBool("hasCoordTransform");
             
             int place = coder.readBits("placeType", 2, false);
             
@@ -1911,15 +1909,15 @@
                 coder.readWord("reserved", 2, false);
                 coder.readWord("eventMask", eventSize, false);
 
-                coder.beginObject("clipEvents", "Array");
+                coder.beginArray("clipEvents");
         
                 while (coder.scanWord(eventSize, false) != 0)
                     decodeClipEvent(coder);
      
                 coder.readWord("eventEnd", eventSize, false);
-                coder.endObject("Array");
+                coder.endObject();
             }
-            coder.endObject("PlaceObject2");
+            coder.endObject();
             coder.context[SWFDecoder.TransparentColors] = 0;
         }
 
@@ -1928,7 +1926,7 @@
             coder.beginObject("pointer", "Pointer");
             decodeMovieObject(coder);
             coder.readWord("pointer", 4, false);
-            coder.endObject("Pointer");
+            coder.endObject();
         }
 
         void decodeProtect(SWFDecoder coder)
@@ -1939,7 +1937,7 @@
             if ((coder.context[SWFDecoder.Version] > 4) && (length > 0))
                 coder.readString("password", length); 
 
-            coder.endObject("Protect");
+            coder.endObject();
         }
         
         void decodeQuicktimeMovie(SWFDecoder coder)
@@ -1947,7 +1945,7 @@
             coder.beginObject("quicktimeMovie", "QuicktimeMovie");
             decodeMovieObject(coder);
             coder.readString("name");
-            coder.endObject("QuicktimeMovie");
+            coder.endObject();
         }
 
         void decodeRemoveObject2(SWFDecoder coder)
@@ -1955,7 +1953,7 @@
             coder.beginObject("removeObject2", "RemoveObject2");
             decodeMovieObject(coder);
             coder.readWord("layer", 2, false);
-            coder.endObject("RemoveObject2");
+            coder.endObject();
         }
         
         void decodeSerialNumber(SWFDecoder coder)
@@ -1963,7 +1961,7 @@
             coder.beginObject("serialNumber", "SerialNumber");
             decodeMovieObject(coder);
             coder.readString("serialNumber");
-            coder.endObject("SerialNumber");
+            coder.endObject();
         }
         
         void decodeSoundStreamHead2(SWFDecoder coder)
@@ -1983,7 +1981,7 @@
             if (format == 2) // MP3
                 coder.readWord("latency", 2, true);
 
-            coder.endObject("SoundStreamHead2");
+            coder.endObject();
         }
 
         void decodeTabOrder(SWFDecoder coder)
@@ -1992,7 +1990,7 @@
             decodeMovieObject(coder);
             coder.readWord("layer", 2, false);
             coder.readWord("index", 2, false);
-            coder.endObject("TabOrder");
+            coder.endObject();
         }
 
         void decodeLimitScript(SWFDecoder coder)
@@ -2001,7 +1999,7 @@
             decodeMovieObject(coder);
             coder.readWord("depth", 2, false);
             coder.readWord("timeout", 2, false);
-            coder.endObject("LimitScript");
+            coder.endObject();
         }
 
         void decodeVideoFrame(SWFDecoder coder)
@@ -2012,16 +2010,14 @@
             coder.readWord("identifier", 2, false);
             coder.readWord("frameNumber", 2, false);
             coder.readBytes("video data", length-4);
-            coder.endObject("VideoFrame");
+            coder.endObject();
         }
 
         void decodeActionCode(SWFDecoder coder)
         {
             String name = null;
             
-            coder.beginObject("action", "Action");
-            
-            switch (coder.readWord("type", 1, false))
+            switch (coder.scanWord(1, false))
             {
                 case NextFrame:
                     name = "NextFrame";
@@ -2269,14 +2265,16 @@
                     name = "Action";
                     break;
             }
-            coder.endObject(name);
+            coder.beginObject("action", name);
+            coder.readWord("type", 1, false);
+            coder.endObject();
         }
 
         void decodeCall(SWFDecoder coder)
         {
             coder.beginObject("call", "Call");
             decodeActionObject(coder);
-            coder.endObject("Call");
+            coder.endObject();
         }
         
         void decodeExceptionHandler(SWFDecoder coder)
@@ -2285,9 +2283,9 @@
             decodeActionObject(coder);
             
             coder.readBits("reserved", 5, false);
-            boolean containsVariable = coder.readBool("containsVariable");
-            boolean containsCatch = coder.readBool("containsCatch");
-            boolean containsFinal = coder.readBool("containsFinal");
+            boolean containsVariable = coder.readBool("hasVariable");
+            boolean containsCatch = coder.readBool("hasCatch");
+            boolean containsFinal = coder.readBool("hasFinal");
 
             int tryLength = coder.readWord("tryLength", 2, false);
             int catchLength = coder.readWord("catchLength", 2, false);
@@ -2300,32 +2298,32 @@
                 coder.readWord("register", 1, false);
             }
 
-            coder.beginObject("tryActions", "Array");
+            coder.beginArray("tryActions");
 
             while (tryLength > 0)
                 tryLength -= decodeAction(coder);
                 
-            coder.endObject("Array");
+            coder.endObject();
 
             if (containsCatch)
             {
-                coder.beginObject("catchActions", "Array");
+                coder.beginArray("catchActions");
 
                 while (catchLength > 0)
                     catchLength -= decodeAction(coder);
-                coder.endObject("Array");
+                coder.endObject();
             }
 
             if (containsFinal)
             {
-                coder.beginObject("finalActions", "Array");
+                coder.beginArray("finalActions");
                 
                 while (finalLength > 0)
                     finalLength -= decodeAction(coder);
 
-                coder.endObject("Array");
+                coder.endObject();
             }
-            coder.endObject("ExceptionHandler");
+            coder.endObject();
         }
 
         void decodeGetUrl2(SWFDecoder coder)
@@ -2333,7 +2331,7 @@
             coder.beginObject("getUrl2", "GetUrl2");
             decodeActionObject(coder);
             coder.readWord("requestType", 1, false);
-            coder.endObject("GetUrl2");
+            coder.endObject();
         }
 
         void decodeGotoFrame2(SWFDecoder coder)
@@ -2341,13 +2339,13 @@
             coder.beginObject("gotoFrame2", "GotoFrame2");
             decodeActionObject(coder);
             coder.readBits("unused", 6, false);
-            boolean containsOffset = coder.readBool("containsFrameOffset");
+            boolean containsOffset = coder.readBool("hasFrameOffset");
             coder.readBool("playFrame");
 
             if (containsOffset)
                 coder.readWord("frameOffset", 2, false);
 
-            coder.endObject("GotoFrame2");
+            coder.endObject();
         }
 
         void decodeGotoLabel(SWFDecoder coder)
@@ -2355,7 +2353,7 @@
             coder.beginObject("gotoLabel", "GotoLabel");
             decodeActionObject(coder);
             coder.readString("label");
-            coder.endObject("GotoLabel");
+            coder.endObject();
         }
 
         void decodeIf(SWFDecoder coder)
@@ -2363,7 +2361,7 @@
             coder.beginObject("if", "If");
             decodeActionObject(coder);
             coder.readWord("offset", 2, true);
-            coder.endObject("If");
+            coder.endObject();
         }
 
         void decodeJump(SWFDecoder coder)
@@ -2371,7 +2369,7 @@
             coder.beginObject("jump", "Jump");
             decodeActionObject(coder);
             coder.readWord("offset", 2, true);
-            coder.endObject("Jump");
+            coder.endObject();
         }
 
         int decodeNewFunction(SWFDecoder coder)
@@ -2384,23 +2382,23 @@
             
             if (argumentCount > 0)
             {
-                coder.beginObject("arguments", "Array");
+                coder.beginArray("arguments");
 
                 for (int i=argumentCount; i>0; i--)
                     coder.readString("arg");
 
-                coder.endObject("Array");
+                coder.endObject();
             }
                 
             int actionsLength = coder.readWord("actionsLength", 2, false);
             
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
 
             while (actionsLength > 0)
                 actionsLength -= decodeAction(coder);
 
-            coder.endObject("Array");
-            coder.endObject("NewFunction");
+            coder.endObject();
+            coder.endObject();
             
             return length + actionsLength;
         }
@@ -2415,22 +2413,22 @@
             coder.readWord("registerCount", 1, false);
             coder.readBits("optimizations", 16, false);
             
-            coder.beginObject("registerVariables", "Array");
+            coder.beginArray("registerVariables");
 
             for (int i=0; i<argumentCount; i++)
                 decodeRegisterVariable(coder);
 
-            coder.endObject("Array");
+            coder.endObject();
                 
             int actionsLength = coder.readWord("actionsLength", 2, false);
             
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
 
             while (actionsLength > 0)
                 actionsLength -= decodeAction(coder);
                 
-            coder.endObject("Array");
-            coder.endObject("NewFunction2");
+            coder.endObject();
+            coder.endObject();
             
             return length + actionsLength;
         }
@@ -2440,7 +2438,7 @@
             coder.beginObject("push", "Push");
             int length = decodeActionObject(coder);
             
-            coder.beginObject("values", "Array");
+            coder.beginArray("values");
 
             while (length > 0)
             {
@@ -2480,8 +2478,8 @@
                         break;
                 }
             }
-            coder.endObject("Array");
-            coder.endObject("Push");
+            coder.endObject();
+            coder.endObject();
         }
 
         int decodeString(SWFDecoder coder)
@@ -2489,7 +2487,7 @@
             coder.beginObject("string", "String");
             coder.readWord("type", 1, false);
             int length = 2 + coder.readString("value");
-            coder.endObject("String");
+            coder.endObject();
             
             return length;
         }
@@ -2499,7 +2497,7 @@
             coder.beginObject("property", "Property");
             coder.readWord("type", 1, false); // type
             coder.readWord("value", 4, false); // property
-            coder.endObject("Property");
+            coder.endObject();
             
             return 5;
         }
@@ -2508,7 +2506,7 @@
         {
             coder.beginObject("null", "Null");
             coder.readWord("type", 1, false); // type
-            coder.endObject("Null");
+            coder.endObject();
             
             return 1;
         }
@@ -2517,7 +2515,7 @@
         {
             coder.beginObject("void", "Void");
             coder.readWord("type", 1, false); // type
-            coder.endObject("Void");
+            coder.endObject();
             
             return 1;
         }
@@ -2527,7 +2525,7 @@
             coder.beginObject("registerIndex", "RegisterIndex");
             coder.readWord("type", 1, false); // type
             coder.readWord("value", 1, false); // index
-            coder.endObject("RegisterIndex");
+            coder.endObject();
             
             return 2;
         }
@@ -2537,7 +2535,7 @@
             coder.beginObject("boolean", "Boolean");
             coder.readWord("type", 1, false); // type
             coder.readWord("value", 1, false); // value
-            coder.endObject("Boolean");
+            coder.endObject();
             
             return 2;
         }
@@ -2547,7 +2545,7 @@
             coder.beginObject("double", "Double");
             coder.readWord("type", 1, false); // type
             coder.readDouble("value"); // value
-            coder.endObject("Double");
+            coder.endObject();
             
             return 9;
         }
@@ -2557,7 +2555,7 @@
             coder.beginObject("integer", "Integer");
             coder.readWord("type", 1, false); // type
             coder.readWord("value", 4, true); // value
-            coder.endObject("Integer");
+            coder.endObject();
             
             return 5;
         }
@@ -2567,7 +2565,7 @@
             coder.beginObject("tableIndex", "TableIndex");
             coder.readWord("type", 1, false); // type
             coder.readWord("value", 1, true); // value
-            coder.endObject("TableIndex");
+            coder.endObject();
             
             return 2;
         }
@@ -2577,7 +2575,7 @@
             coder.beginObject("tableIndex", "TableIndex");
             coder.readWord("type", 1, false);
             coder.readWord("value", 2, true);
-            coder.endObject("TableIndex");
+            coder.endObject();
             
             return 3;
         }
@@ -2587,7 +2585,7 @@
             coder.beginObject("registerVariable", "RegisterVariable");
             coder.readWord("register", 1, false);
             coder.readString("name");
-            coder.endObject("RegisterVariable");
+            coder.endObject();
         }
 
         void decodeRegisterCopy(SWFDecoder coder)
@@ -2595,7 +2593,7 @@
             coder.beginObject("registerCopy", "RegisterCopy");
             decodeActionObject(coder);
             coder.readWord("register", 1, false);
-            coder.endObject("RegisterCopy");
+            coder.endObject();
         }
 
         void decodeSetTarget(SWFDecoder coder)
@@ -2603,7 +2601,7 @@
             coder.beginObject("setTarget", "SetTarget");
             decodeActionObject(coder);
             coder.readString("target");
-            coder.endObject("SetTarget");
+            coder.endObject();
         }
 
         void decodeTable(SWFDecoder coder)
@@ -2615,14 +2613,14 @@
             
             if (attributeCount > 0)
             {
-                coder.beginObject("strings", "Array");
+                coder.beginArray("strings");
         
                 for (int i=0; i<attributeCount; i++)
                     coder.readString("value");
         
-                coder.endObject("Array");
+                coder.endObject();
             }
-            coder.endObject("Table");
+            coder.endObject();
         }
 
         void decodeWaitForFrame(SWFDecoder coder)
@@ -2631,7 +2629,7 @@
             decodeActionObject(coder);
             coder.readWord("frameNumber", 2, false); 
             coder.readWord("actionCount", 1, false);
-            coder.endObject("WaitForFrame");
+            coder.endObject();
         }
         
         void decodeWaitForFrame2(SWFDecoder coder)
@@ -2639,7 +2637,7 @@
             coder.beginObject("waitForFrame2", "WaitForFrame2");
             decodeActionObject(coder);
             coder.readWord("actionCount", 1, false);
-            coder.endObject("WaitForFrame2");
+            coder.endObject();
         }
         
         void decodeWith(SWFDecoder coder)
@@ -2647,7 +2645,7 @@
             coder.beginObject("with", "With");
             decodeActionObject(coder);
             coder.readWord("actionsLength", 1, false);
-            coder.endObject("With");
+            coder.endObject();
         }
 
         int decodeButtonEvent(SWFDecoder coder)
@@ -2667,12 +2665,12 @@
             coder.readBits("keyCode", 7, false);
             coder.readBool("menuDragOut");
             
-            coder.beginObject("actions", "Array");
+            coder.beginArray("actions");
             
             while (decodeAction(coder) != 0);
             
-            coder.endObject("Array");
-            coder.endObject("ButtonEvent");
+            coder.endObject();
+            coder.endObject();
             
             return offsetToEnd;
         }
@@ -2687,26 +2685,26 @@
             coder.readWord("buttonType", 1, false);
             int actionsOffset = coder.readWord("actionsOffset", 2, false);
 
-            coder.beginObject("buttonRecords", "Array");
+            coder.beginArray("buttonRecords");
             
             while (coder.scanWord(1, false) != 0)
                 decodeButtonRecord(coder);
                 
             coder.readWord("endOfRecords", 1, false);
-            coder.endObject("Array");
+            coder.endObject();
 
             if (actionsOffset != 0)
             {
-                coder.beginObject("buttonEvents", "Array");
+                coder.beginArray("buttonEvents");
                     
                 do {
                     actionsOffset = decodeButtonEvent(coder);
                 } while (actionsOffset != 0);
 
-                coder.endObject("Array");
+                coder.endObject();
             }
             coder.context[SWFDecoder.TransparentColors] = 0;
-            coder.endObject("DefineButton2");
+            coder.endObject();
         }
 
         void decodeDefineFont2(SWFDecoder coder)
@@ -2715,14 +2713,14 @@
             int length = decodeDefineObject(coder);        
             int start = coder.getPointer() - 16;
 
-            boolean containsLayout = coder.readBool("containsLayout");
+            boolean containsLayout = coder.readBool("hasLayout");
             
             coder.readBool("isShiftJIS");
             coder.readBool("isSmall");
             coder.readBool("isANSI");
             
-            boolean containsWideOffsets = coder.readBool("containsWideOffsets");
-            boolean containsWideCodes = coder.readBool("containsWideCodes");
+            boolean containsWideOffsets = coder.readBool("hasWideOffsets");
+            boolean containsWideCodes = coder.readBool("hasWideCodes");
 
             coder.context[SWFDecoder.WideCodes] = containsWideCodes ? 1 : 0;
 
@@ -2733,28 +2731,28 @@
             coder.readString("name", nameLength);
             int glyphCount = coder.readWord("glyphCount", 2, false);
 
-            coder.beginObject("offsets", "Array");
+            coder.beginArray("offsets");
 
             for (int i=0; i<glyphCount; i++)
                 coder.readWord("offset", containsWideOffsets ? 4 : 2, false);
 
-            coder.endObject("Array");
+            coder.endObject();
 
             coder.readWord("codeOffset", (containsWideOffsets) ? 4 : 2, false); // codeOffset
 
-            coder.beginObject("glyphs", "Array");
+            coder.beginArray("glyphs");
 
             for (int i=0; i<glyphCount; i++)
                 decodeShape(coder);
                 
-            coder.endObject("Array");
+            coder.endObject();
 
-            coder.beginObject("codes", "Array");
+            coder.beginArray("codes");
 
             for (int i=0; i<glyphCount; i++)
                 coder.readWord("code", containsWideCodes ? 2 : 1, false);
 
-            coder.endObject("Array");
+            coder.endObject();
 
             if (containsLayout)
             {
@@ -2762,36 +2760,36 @@
                 coder.readWord("descent", 2, true);
                 coder.readWord("leading", 2, true);
                 
-                coder.beginObject("advances", "Array");
+                coder.beginArray("advances");
         
                 for (int i=0; i<glyphCount; i++)
                     coder.readWord("advance", 2, true);
 
-                coder.endObject("Array");
+                coder.endObject();
                 
                 
                 if (((coder.getPointer() - start) >> 3) < length)     
                 {
-                    coder.beginObject("bounds", "Array");
+                    coder.beginArray("bounds");
         
                     for (int i=0; i<glyphCount; i++)
                         decodeBounds("bounds", coder);
         
-                    coder.endObject("Array");
+                    coder.endObject();
             
                     int kerningCount = coder.readWord("kerningCount", 2, false);
         
-                    coder.beginObject("kernings", "Array");
+                    coder.beginArray("kernings");
             
                     for (int i=0; i<kerningCount; i++)
                         decodeKerning(coder);
         
-                    coder.endObject("Array");
+                    coder.endObject();
                 }
             }
 
             coder.context[SWFDecoder.WideCodes] = 0;
-            coder.endObject("DefineFont2");
+            coder.endObject();
         }
         
         void decodeKerning(SWFDecoder coder)
@@ -2802,7 +2800,7 @@
             coder.readWord("leftGlyphIndex", numberOfBytes, false);
             coder.readWord("rightGlyphIndex", numberOfBytes, false);
             coder.readWord("adjustment", 2, true);
-            coder.endObject("Kerning");
+            coder.endObject();
         }
 
         void decodeDefineImage(SWFDecoder coder)
@@ -2823,7 +2821,7 @@
             {
                 coder.readBytes("compressedData", length-7);
             }
-            coder.endObject("DefineImage");
+            coder.endObject();
         }
         
         void decodeDefineImage2(SWFDecoder coder)
@@ -2844,7 +2842,7 @@
             {
                 coder.readBytes("compressedData", length-7);
             }
-            coder.endObject("DefineImage2");
+            coder.endObject();
         }
 
         void decodeDefineJPEGImage2(SWFDecoder coder)
@@ -2853,7 +2851,7 @@
             int length = decodeDefineObject(coder);
             int tableLength = readJPEGStream(coder); // encodingTable
             coder.readBytes("image", length-tableLength-2);
-            coder.endObject("DefineJPEGImage2");
+            coder.endObject();
         }
 
         void decodeDefineJPEGImage3(SWFDecoder coder)
@@ -2864,7 +2862,7 @@
             int tableLength = readJPEGStream(coder); // encodingTable
             coder.readBytes("image", offset-tableLength);
             coder.readBytes("alpha", length-offset-6);        
-            coder.endObject("DefineJPEGImage3");
+            coder.endObject();
         }
         
         int readJPEGStream(SWFDecoder coder)
@@ -2908,7 +2906,7 @@
             if (coder.context[SWFDecoder.ArrayCountExtended] != 0 && fillStyleCount == 0xFF)
                 fillStyleCount = coder.readWord("fillStyleCountExtended", 2, false);
                 
-            coder.beginObject("fillStyles", "Array");
+            coder.beginArray("fillStyles");
                 
             for (int i=0; i<fillStyleCount; i++)
             {
@@ -2933,19 +2931,19 @@
                         break;
                 }
             }
-            coder.endObject("Array");
+            coder.endObject();
 
             int lineStyleCount = coder.readWord("lineStyleCount", 1, false);
 
             if (coder.context[SWFDecoder.ArrayCountExtended] != 0 && lineStyleCount == 0xFF)
                 lineStyleCount = coder.readWord("lineStyleCountExtended", 2, false);
 
-            coder.beginObject("lineStyles", "Array");
+            coder.beginArray("lineStyles");
 
             for (int i=0; i<lineStyleCount; i++)
                 decodeMorphSolidLine(coder);
 
-            coder.endObject("Array");
+            coder.endObject();
 
             decodeShape(coder); // startShape
             decodeShape(coder); // endShape
@@ -2953,7 +2951,7 @@
             coder.context[SWFDecoder.TransparentColors] = 0;
             coder.context[SWFDecoder.ArrayCountExtended] = 0;
             
-            coder.endObject("DefineMorphShape");
+            coder.endObject();
         }
 
         void decodeDefineMovieClip(SWFDecoder coder)
@@ -2963,13 +2961,13 @@
 
             coder.readWord("frameCount", 2, false);
 
-            coder.beginObject("objects", "Array");
+            coder.beginArray("objects");
 
             while (decodeObject(coder));
 
-            coder.endObject("Array");
+            coder.endObject();
             
-            coder.endObject("DefineMovieClip");
+            coder.endObject();
         }
         
         void decodeDefineShape2(SWFDecoder coder)
@@ -2986,7 +2984,7 @@
                 if (fillStyleCount == 0xFF)
                     fillStyleCount = coder.readWord("fillStyleCountExtended", 2, false);
                     
-                coder.beginObject("fillStyles", "Array");
+                coder.beginArray("fillStyles");
                 
                 for (int i=0; i<fillStyleCount; i++)
                 {
@@ -3012,7 +3010,7 @@
                     }        
                 }
                 
-                coder.endObject("Array");
+                coder.endObject();
             }
             
             int lineStyleCount = coder.readWord("lineStyleCount", 1, false);
@@ -3022,17 +3020,17 @@
                 if (lineStyleCount == 0xFF)
                     lineStyleCount = coder.readWord("lineStyleCountExtended", 2, false);
         
-                coder.beginObject("lineStyles", "Array");
+                coder.beginArray("lineStyles");
         
                 for (int i=0; i<lineStyleCount; i++)
                     decodeSolidLine(coder);
         
-                coder.endObject("Array");
+                coder.endObject();
             }
             coder.context[SWFDecoder.ArrayCountExtended] = 1;
             decodeShape(coder);
             coder.context[SWFDecoder.ArrayCountExtended] = 0;
-            coder.endObject("DefineShape2");
+            coder.endObject();
         }
         
         void decodeDefineShape3(SWFDecoder coder)
@@ -3051,7 +3049,7 @@
                 if (fillStyleCount == 0xFF)
                     fillStyleCount = coder.readWord("fillStyleCountExtended", 2, false);
                     
-                coder.beginObject("fillStyles", "Array");
+                coder.beginArray("fillStyles");
                 
                 for (int i=0; i<fillStyleCount; i++)
                 {
@@ -3076,7 +3074,7 @@
                             break;
                     }        
                 }
-                coder.endObject("Array");
+                coder.endObject();
             }
 
             int lineStyleCount = coder.readWord("lineStyleCount", 1, false);
@@ -3086,12 +3084,12 @@
                 if (lineStyleCount == 0xFF)
                     lineStyleCount = coder.readWord("lineStyleCountExtended", 2, false);
         
-                coder.beginObject("lineStyles", "Array");
+                coder.beginArray("lineStyles");
         
                 for (int i=0; i<lineStyleCount; i++)
                     decodeSolidLine(coder);
         
-                coder.endObject("Array");
+                coder.endObject();
             }
             coder.context[SWFDecoder.ArrayCountExtended] = 1;
 
@@ -3099,7 +3097,7 @@
 
             coder.context[SWFDecoder.ArrayCountExtended] = 0;
             coder.context[SWFDecoder.TransparentColors] = 0;
-            coder.endObject("DefineShape3");
+            coder.endObject();
         }
 
         void decodeDefineText2(SWFDecoder coder)
@@ -3143,18 +3141,18 @@
             coder.context[SWFDecoder.NumberOfGlyphBits] = coder.readWord("numberOfGlyphBits", 1, false);
             coder.context[SWFDecoder.NumberOfAdvanceBits] = coder.readWord("numberOfAdvanceBits", 1, false);
             
-            coder.beginObject("textRecords", "Array");
+            coder.beginArray("textRecords");
 
             while (coder.scanBits(8, false) != 0)
                 decodeTextRecord(coder);
 
             coder.readBits("endOfText", 8, false);
-            coder.endObject("Array");
+            coder.endObject();
 
             coder.context[SWFDecoder.NumberOfGlyphBits] = 0;
             coder.context[SWFDecoder.NumberOfAdvanceBits] = 0;
             coder.context[SWFDecoder.TransparentColors] = 0;
-            coder.endObject("DefineText2");
+            coder.endObject();
         }
 
         void decodeDefineTextField(SWFDecoder coder)
@@ -3166,17 +3164,17 @@
 
             decodeBounds("bounds", coder);
 
-            boolean _containsText = coder.readBool("containsText");
+            boolean _containsText = coder.readBool("hasText");
             coder.readBool("isWordWrapped");
             coder.readBool("isMultiline");
             coder.readBool("isPassword");
             coder.readBool("isReadOnly");
-            boolean _containsColor = coder.readBool("containsColor");
-            boolean _containsMaxLength = coder.readBool("containsMaxLength");
-            boolean _containsFont = coder.readBool("containsFont");
+            boolean _containsColor = coder.readBool("hasColor");
+            boolean _containsMaxLength = coder.readBool("hasMaxLength");
+            boolean _containsFont = coder.readBool("hasFont");
             coder.readBits("reserved1", 1, false);
             coder.readBool("isAutoSize");
-            boolean _containsLayout = coder.readBool("containsLayout");
+            boolean _containsLayout = coder.readBool("hasLayout");
             coder.readBool("isSelectable");
             coder.readBool("isBordered");
             coder.readBool("reserved2");
@@ -3209,7 +3207,7 @@
                 coder.readString("initialText");
 
             coder.context[SWFDecoder.TransparentColors] = 0;
-            coder.endObject("DefineTextField");
+            coder.endObject();
         }
 
         void decodeDefineVideo(SWFDecoder coder)
@@ -3224,7 +3222,7 @@
             coder.readBits("deblocking", 2, false);
             coder.readBool("smoothing");
             coder.readWord("codec", 1, false);
-            coder.endObject("DefineVideo");
+            coder.endObject();
         }
     }
     private class SWFDecoder 
@@ -3267,32 +3265,11 @@
         }
         public void setPointer(int location)
         {
-            if (location < 0)
-            {
-                logError("PointerOutOfRange", location, 0);
-                location = 0;
-            }
-            else if (location > end)
-            {
-                logError("PointerOutOfRange", location, 0);            
-                location = end;
-            }
             ptr = location;
         }
         public void adjustPointer(int offset)
         {
             ptr += offset;
-            
-            if (ptr < 0)
-            {
-                logError("PointerOutOfRange", ptr, 0);
-                ptr = 0;
-            }
-            else if (ptr >= end)
-            {
-                logError("PointerOutOfRange", ptr, 0);                    
-                ptr = end;
-            }
         }
         public void alignToByte()
         {
@@ -3300,32 +3277,29 @@
         }
         public void beginObject(String name, String type)
         {
-            if (listener != null)
-                listener.recordMovieEvent(TextDump.Begin, name, ptr, 0, type);
+            listener.recordMovieEvent(TextDump.Begin, name, ptr, 0, type);
         }
-        public void endObject(String name)
+        public void beginArray(String name)
         {
-            if (listener != null)
-                listener.recordMovieEvent(TextDump.End, null, ptr, 0, name);
+            listener.recordMovieEvent(TextDump.BeginArray, name, ptr, 0, "Array");
         }
+        public void endObject()
+        {
+            listener.recordMovieEvent(TextDump.End, null, ptr, 0, null);
+        }
         public void logValue(String name, Object anObject, int location, int numberOfBits)
         {
-            if (listener != null)
-                listener.recordMovieEvent(TextDump.Value, name, location, numberOfBits, anObject);
+            listener.recordMovieEvent(TextDump.Value, name, location, numberOfBits, anObject);
         }
         public void logError(String errorKey, int location, int length)
         {
-            if (listener != null)
-                listener.recordMovieEvent(TextDump.Error, null, location, length, errorKey);
+            listener.recordMovieEvent(TextDump.Error, null, location, length, errorKey);
         }
         public int scanBits(int numberOfBits, boolean signed)
         {
             int value = 0;
             int start = ptr;
 
-            if (numberOfBits < 0 || numberOfBits > 32)
-               logError("BitRangeError", ptr, numberOfBits);
-        
             value = _readBits(numberOfBits, signed);
             ptr = start;
             
@@ -3336,9 +3310,6 @@
             int value = 0;
             int start = ptr;
 
-            if (numberOfBytes < 0 || numberOfBytes > 4)
-                logError("ByteRangeError", ptr, numberOfBytes);
-        
             value = _readWord(numberOfBytes*8, signed);
             ptr = start;
             
@@ -3397,9 +3368,6 @@
         {
             float value = 0;
         
-            if (numberOfBits < 0 || numberOfBits > 32)
-                logError("BitRangeError", ptr, numberOfBits);
-        
             value = ((float)_readBits(numberOfBits, true)) / 65536.0f;
 
 
@@ -3532,9 +3500,6 @@
             if (ptr >= end)
                 return 0;
                 
-            if (ptr % 8 > 0)
-                logError("NotByteAligned", ptr, 0);
-        
             try 
             {
                 int index = ptr >> 3;
@@ -3565,9 +3530,6 @@
             if (ptr >= end)
                 return bytesRead;
                 
-            if (ptr % 8 > 0)
-                logError("NotByteAligned", ptr, 0);
-
             try 
             {
                 int index = ptr >>> 3;
@@ -3587,30 +3549,35 @@
     {
         private static final long serialVersionUID = 0;
 
-        private String name = null;
-        private int reference = 0;
-        private int location = 0;
-        private int length = 0;
+        private String name;
+        private int index;
+        private int location;
+        private int length;
+        private boolean isArray;
 
-        MovieNode(MovieNode parent, String name, int location, int length, Object value)
+        MovieNode(MovieNode parent, boolean isArray, int index, String name, int location, int length, Object value)
         {
             super(parent);
                    
-            if (parent != null)
-                setReference(parent.getChildCount());
+            this.name = name;
+            this.isArray = isArray;
+            this.location = location;
+            this.length = length;
+            this.index = index;
 
-            setName(name);
-            setLocation(location);
-            setLength(length);
             setUserObject(value);
         }   
-        int getReference()
+        boolean isArray()
         {
-            return reference;
+            return isArray;
+        }
+        int getIndex()
+        {
+            return index;
         }    
-        void setReference(int aValue)
+        void setIndex(int aValue)
         {
-            reference = aValue;
+            index = aValue;
         }
         int getLocation()
         {
@@ -3638,19 +3605,19 @@
         }
         String displayName()
         {
-            if (parent == null)
-                return "movie";
+            String str;
             
-            String parentName = ((MovieNode)parent).getUserObject().toString();
-            String str = null;
-            
-            if (parentName.equals("Array"))
-                str = "[" + reference + "] : " + getUserObject().toString();
+            if (index != -1)
+                str = "[" + index + "] : " + getUserObject().toString();
             else
                 str = name;
                 
             return str;
         }
+        public String toString()
+        {
+            return displayName();
+        }
     }
 
     public static void main(String[] args)
@@ -3658,6 +3625,9 @@
         new TextDump(args);
     }
     
+    File fileIn = null;
+    File fileOut = null;
+
     private MovieNode nodes = null;
     private MovieNode currentNode = null;
 
@@ -3665,24 +3635,39 @@
     {
         super(args);
         
-        if (options.containsKey("fileIn") && options.containsKey("fileOut"))
+        try
         {
-            StringBuffer buffer = new StringBuffer();
+            if (options.containsKey("fileIn") && options.containsKey("fileOut"))
+            {
+                fileIn = new File(options.get("fileIn").toString());
+                fileOut = new File(options.get("fileOut").toString());
+                
+                byte[] fileData = new byte[(int)fileIn.length()];
+    
+                nodes = new MovieNode(null, false, -1, "Movie", 0, 0, "FSMovie");
+                currentNode = nodes;
+                
+                readFromFile(fileIn, fileData);
+                
+                new SWF().decodeMovie(fileData, this);
 
-            File fileIn = new File(options.get("fileIn").toString());
-            File fileOut = new File(options.get("fileOut").toString());
-            byte[] fileData = new byte[(int)fileIn.length()];
-
-            nodes = new MovieNode(null, null, 0, 0, "FSMovie");
-            currentNode = nodes;
-            
-            readFromFile(fileIn, fileData);
-            
-            new SWF().decodeMovie(fileData, this);
-
-            describeNode(nodes, buffer, 0);
-            writeToFile(fileOut, buffer);
+                FileOutputStream stream = new FileOutputStream(fileOut);
+                PrintWriter pw = new PrintWriter(stream);
+                
+                describeNode(nodes, pw, 0);
+                
+                pw.close();
+                stream.close();                    
+            }
         }
+        catch (Exception e)
+        {         
+            System.err.println(e.toString());
+        }
+        catch (Error e)
+        {
+            System.err.println(e.toString());
+        }
     }
     private void readFromFile(File file, byte[] bytes)
     {
@@ -3702,77 +3687,54 @@
             
         }
     }
-    private void writeToFile(File file, StringBuffer buffer)
+    private void describeNode(MovieNode node, PrintWriter pw, int level)
     {
-        try
-        {
-            FileOutputStream stream = new FileOutputStream(file);
-            byte[] bytes = buffer.toString().getBytes();
-            
-            stream.write(bytes);
-            stream.close();
-        }
-        catch (IOException e)
-        {
-            
-        }
-    }
-    private void describeNode(MovieNode node, StringBuffer buffer, int level)
-    {
         for (int i=0; i<level; i++)
-            buffer.append('\t');
+            pw.print('\t');
         
-        if (node.getParent() == null)
-        {
-            buffer.append("Movie");   
-        }
+        if (node.getIndex() != -1)
+            pw.print("[" + node.getIndex() + "]");
         else
-        {
-            String parentName = ((MovieNode)node.getParent()).getUserObject().toString();
-            
-            if (parentName.equals("Array"))
-                buffer.append("[" + node.getReference() + "]");
-            else
-                buffer.append(node.displayName());
-            
-        }
+            pw.print(node.displayName());
         
+        
         if (node.getChildCount() > 0)
         {
-            buffer.append(" = ");
-            buffer.append(node.getUserObject().toString());
-            buffer.append(": {");
-            buffer.append(newline);
+            pw.print(" = ");
+            pw.print(node.getUserObject().toString());
+            pw.println(" {");
             
             for (Enumeration e = node.children() ; e.hasMoreElements() ;) 
-                describeNode((MovieNode)e.nextElement(), buffer, level+1);
+                describeNode((MovieNode)e.nextElement(), pw, level+1);
     
             for (int i=0; i<level; i++)
-                buffer.append('\t');
+                pw.print('\t');
     
-            buffer.append("};").append(newline);
+            pw.println("};");
         }
         else
         {
-            buffer.append(" = ");
+            pw.print(" = ");
             
             if (node.isLeaf() == false)
             {
-                if (node.getUserObject().toString().equals("Array"))
-                    buffer.append("{}");
+                if (node.isArray())
+                    pw.print("{}");
             }
             else
             {
                 if (node.getUserObject() instanceof String)
-                    buffer.append("\"" + node.getUserObject() + "\"");
+                    pw.print("\"" + node.getUserObject() + "\"");
                 else
-                    buffer.append(node.getUserObject().toString());
+                    pw.print(node.getUserObject().toString());
             }
-            buffer.append(";").append(newline);
+            pw.println(";");
         }
     }
     private void recordMovieEvent(int event, String name, int location, int length, Object value)
     {
+        int index = currentNode.isArray() ? currentNode.getChildCount() : -1;
+        
         switch (event)
         {
             case Begin:
@@ -3784,14 +3746,27 @@
                 }
                 else
                 {
-                    MovieNode node = new MovieNode(currentNode, name, location, length, value);
+                    MovieNode node = new MovieNode(currentNode, false, index, name, location, length, value);
                     currentNode.add(node);
                     currentNode = node;
                 }
                 break;
+            case BeginArray:
+                if (nodes.getChildCount() == 0)
+                {
+                    nodes.setLocation(location);
+                    nodes.setLength(length);
+                    nodes.setUserObject(value);
+                }
+                else
+                {
+                    MovieNode node = new MovieNode(currentNode, true, index, name, location, length, value);
+                    currentNode.add(node);
+                    currentNode = node;
+                }
+                break;
             case End:
                 currentNode.setLength(location - currentNode.getLocation());
-                currentNode.setUserObject(value);
                 
                 if (currentNode.getParent() != null)
                     currentNode = (MovieNode)currentNode.getParent();
@@ -3799,7 +3774,7 @@
                     currentNode = nodes;
                 break;
             case Value:
-                currentNode.add(new MovieNode(currentNode, name, location, length, value));
+                currentNode.add(new MovieNode(currentNode, false, index ,name, location, length, value));
                 break;
             default:
                 break;



From smackay at berlios.de  Sun Feb 26 17:20:21 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Sun, 26 Feb 2006 17:20:21 +0100
Subject: [Transform-svn] r84 - trunk/test/suites
Message-ID: <200602261620.k1QGKLOL019952@sheep.berlios.de>

Author: smackay
Date: 2006-02-26 17:20:18 +0100 (Sun, 26 Feb 2006)
New Revision: 84

Modified:
   trunk/test/suites/FSImageConstructor.xml
Log:
Now correctly running test with bmp suite.

Modified: trunk/test/suites/FSImageConstructor.xml
===================================================================
--- trunk/test/suites/FSImageConstructor.xml	2006-02-25 18:34:57 UTC (rev 83)
+++ trunk/test/suites/FSImageConstructor.xml	2006-02-26 16:20:18 UTC (rev 84)
@@ -4,8 +4,8 @@
 
     <test name="BMP Images">
 		<parameter name="srcDir" value="test/data/images/bmp"/>
-		<parameter name="dstDir" value="test/results/FSImageConstructor/jpg"/>
-		<parameter name="ext" value="jpg"/>
+		<parameter name="dstDir" value="test/results/FSImageConstructor/bmp"/>
+		<parameter name="ext" value="bmp"/>
 		<classes>
       		<class name="com.flagstone.transform.test.FSImageConstructorTest"/>
 		</classes>



From smackay at berlios.de  Sun Feb 26 17:21:13 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Sun, 26 Feb 2006 17:21:13 +0100
Subject: [Transform-svn] r85 - trunk/test/suites
Message-ID: <200602261621.k1QGLDDA020021@sheep.berlios.de>

Author: smackay
Date: 2006-02-26 17:21:11 +0100 (Sun, 26 Feb 2006)
New Revision: 85

Added:
   trunk/test/suites/FSMovieReference.xml
Modified:
   trunk/test/suites/FSMovie.xml
Log:
Split the FSMovie test into two, putting the steps to create the 
reference data in a separate test to reduce time it takes to run
the full suite repeatedly.

Modified: trunk/test/suites/FSMovie.xml
===================================================================
--- trunk/test/suites/FSMovie.xml	2006-02-26 16:20:18 UTC (rev 84)
+++ trunk/test/suites/FSMovie.xml	2006-02-26 16:21:11 UTC (rev 85)
@@ -2,58 +2,6 @@
   
 <suite name="FSMovie">
 	
-	<!--
-	    Create text dumps of the movies to use as a reference for comparing
-	    the files saved by the encode and clone tests.
-	-->
-    <test name="Reference SWF4">
-		<parameter name="srcDir" value="test/data/movies/swf4"/>
-		<parameter name="dstDir" value="test/results/FSMovie/reference/swf4"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest">
-      			<methods>
-      				<include name="toText"/>
-      			</methods>
-      		</class>
-		</classes>
-  	</test>
-
-    <test name="Reference SWF5">
-		<parameter name="srcDir" value="test/data/movies/swf5"/>
-		<parameter name="dstDir" value="test/results/FSMovie/reference/swf5"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest">
-      			<methods>
-      				<include name="toText"/>
-      			</methods>
-      		</class>
-		</classes>
-  	</test>
-
-    <test name="Reference SWF6">
-		<parameter name="srcDir" value="test/data/movies/swf6"/>
-		<parameter name="dstDir" value="test/results/FSMovie/reference/swf6"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest">
-      			<methods>
-      				<include name="toText"/>
-      			</methods>
-      		</class>
-		</classes>
-  	</test>
-
-    <test name="Reference SWF7">
-		<parameter name="srcDir" value="test/data/movies/swf7"/>
-		<parameter name="dstDir" value="test/results/FSMovie/reference/swf7"/>
-		<classes>
-      		<class name="com.flagstone.transform.test.FSMovieTest">
-      			<methods>
-      				<include name="toText"/>
-      			</methods>
-      		</class>
-		</classes>
-  	</test>
-
     <!--
         Decode then encode a movie. 
     -->

Added: trunk/test/suites/FSMovieReference.xml
===================================================================
--- trunk/test/suites/FSMovieReference.xml	2006-02-26 16:20:18 UTC (rev 84)
+++ trunk/test/suites/FSMovieReference.xml	2006-02-26 16:21:11 UTC (rev 85)
@@ -0,0 +1,58 @@
+<!DOCTYPE suite SYSTEM "http://beust.com/testng/testng-1.0.dtd" >
+  
+<suite name="FSMovie">
+	
+	<!--
+	    Create text dumps of the movies to use as a reference for comparing
+	    the files saved by the encode and clone tests.
+	-->
+    <test name="Reference SWF4">
+		<parameter name="srcDir" value="test/data/movies/swf4"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf4"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Reference SWF5">
+		<parameter name="srcDir" value="test/data/movies/swf5"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf5"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Reference SWF6">
+		<parameter name="srcDir" value="test/data/movies/swf6"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf6"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Reference SWF7">
+		<parameter name="srcDir" value="test/data/movies/swf7"/>
+		<parameter name="dstDir" value="test/results/FSMovie/reference/swf7"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSMovieTest">
+      			<methods>
+      				<include name="toText"/>
+      			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+</suite>
+



From smackay at berlios.de  Sun Feb 26 18:12:19 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Sun, 26 Feb 2006 18:12:19 +0100
Subject: [Transform-svn] r86 - trunk/src/com/flagstone/transform/util
Message-ID: <200602261712.k1QHCJln008597@sheep.berlios.de>

Author: smackay
Date: 2006-02-26 18:12:16 +0100 (Sun, 26 Feb 2006)
New Revision: 86

Modified:
   trunk/src/com/flagstone/transform/util/TransformUtil.java
Log:
TransformUtil is now deprecated.

Modified: trunk/src/com/flagstone/transform/util/TransformUtil.java
===================================================================
--- trunk/src/com/flagstone/transform/util/TransformUtil.java	2006-02-26 16:21:11 UTC (rev 85)
+++ trunk/src/com/flagstone/transform/util/TransformUtil.java	2006-02-26 17:12:16 UTC (rev 86)
@@ -67,15 +67,12 @@
 tracks the string generated so, if required, the font definition object generated only 
 contains the glyphs used, greatly reducing the size of the Flash file generated.</td></tr>
 
-<tr><td>FSCodec</td><td>Supports reading and writing of data from an array of bytes. Similar 
-to stream classes the FSCodec also supports reading and writing of bit fields at any bit 
-position with in the data. The FSCodec class can be used to process data loaded from files 
-from either the FSImageConstructor or FSSoundConstructor classes.</td></tr>
-
 </table>
 <p></P>
 \endhtmlonly
  * 
+ * @deprecated No longer used with the merging of Transform Utilties into the 
+ * main Transform SWF distribution.
  */
 public final class TransformUtil 
 {



From smackay at berlios.de  Sun Feb 26 18:15:11 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Sun, 26 Feb 2006 18:15:11 +0100
Subject: [Transform-svn] r87 - in trunk: doc src/com/flagstone/transform src/com/flagstone/transform/test src/com/flagstone/transform/util
Message-ID: <200602261715.k1QHFBeA011123@sheep.berlios.de>

Author: smackay
Date: 2006-02-26 18:14:50 +0100 (Sun, 26 Feb 2006)
New Revision: 87

Modified:
   trunk/doc/CHANGES.txt
   trunk/src/com/flagstone/transform/FSActionObject.java
   trunk/src/com/flagstone/transform/FSCoder.java
   trunk/src/com/flagstone/transform/FSDefineFont.java
   trunk/src/com/flagstone/transform/FSDefineFont2.java
   trunk/src/com/flagstone/transform/FSMovie.java
   trunk/src/com/flagstone/transform/test/FSColorTest.java
   trunk/src/com/flagstone/transform/util/FSCodec.java
   trunk/src/com/flagstone/transform/util/FSImageConstructor.java
   trunk/src/com/flagstone/transform/util/FSSoundConstructor.java
   trunk/src/com/flagstone/transform/util/FSTextConstructor.java
Log:
Tidied up the FSCoder class, making all methods more reliable 
merging in functionality from Transform Utilities FSCodec. All 
decoding and encoding of data is now performed using FSCoder. 
FSCodec is deprecated.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/doc/CHANGES.txt	2006-02-26 17:14:50 UTC (rev 87)
@@ -1,3 +1,12 @@
+2006-02-26 - smackay at flagstonesoftware.com
+
+    * Tidied up the FSCoder class, making all methods more reliable merging in
+      functionality from Transform Utilities FSCodec. All decoding and encoding 
+      of data is now performed using FSCoder. FSCodec is deprecated.
+      
+    * The class TransformUtil is now deprecated.
+    
+
 2006-02-25 - smackay at flagstonesoftware.com
 
     * Optimized the TextDump tool.

Modified: trunk/src/com/flagstone/transform/FSActionObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSActionObject.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/FSActionObject.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -105,7 +105,6 @@
     static final int _NewFunction2     = 142;
     static final int _ExceptionHandler = 143;
 
-
     protected int type = 0;
     protected int size = 0;
     protected int length = 0;
@@ -140,7 +139,7 @@
     {
         int encodedLength = (type > 128) ? 3 : 1;
         
-        encodedLength += length(new FSCoder());
+        encodedLength += length(new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]));
         
         return encodedLength;
     }

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -32,33 +32,51 @@
 
 import java.io.*;
 
+/**
+ * FSCoder is a similar to Java stream classes, allowing words and bit fields 
+ * to be read and written from an internal array of bytes. FSCoder supports both 
+ * little-endian and big-endian byte ordering.
+ * 
+ * The FSCoder class maintains an internal pointer which points to the next bit 
+ * in the internal array where data will be read or written. When calculating an 
+ * offset in bytes to jump to simply multiply the offset by 8 for the correct 
+ * bit position. The class provides accessor methods, getPointer() and 
+ * setPointer() to change the location of the internal pointer.
+ * 
+ * When writing to an array the size of the array is changed dynamically should 
+ * a write operation cause a buffer overflow. For reads if an overflow results 
+ * then the bits/bytes that overflowed will be set to zero, rather than throwing 
+ * an exception. The eof() method can be used to determine whether the end of 
+ * the buffer has been reached.
+ */
 public final class FSCoder 
 {
+    /** 
+     * Identifies that multibyte words are stored in little-endian format with 
+     * the least significant byte in a word stored first.
+     */
     public static final int LITTLE_ENDIAN = 0;
+    /** 
+     * Identifies that multibyte words are stored in big-endian format with the 
+     * most significant byte in a word stored first.
+     */
     public static final int BIG_ENDIAN = 1;
     
     /*
-     * Index values for the context array in FSCoder.
+     * Methods used to calculate the size of fields when encoded.
      */
-    public static final int Action = 0;
-    public static final int Version = 1;
-    public static final int Type = 2;
-    public static final int Empty = 3;
-    public static final int Identifier = 4;
-    public static final int TransparentColors = 5;
-    public static final int NumberOfFillBits = 6;
-    public static final int NumberOfLineBits = 7;
-    public static final int NumberOfAdvanceBits = 8;
-    public static final int NumberOfGlyphBits = 9;
-    public static final int NumberOfShapeBits = 10;
-    public static final int ArrayCountExtended = 11;
-    public static final int WideCodes = 12;
-    public static final int Delta = 13;
-    public static final int CodingError = 14;
-    public static final int TypeInError = 15;
-    public static final int StartOfError = 16;
-    public static final int ExpectedLength = 17;
     
+    /**
+     * Calculates the minimum number of bits required to encoded an integer
+     * in a bit field.
+     * 
+     * @param value the value to be encoded.
+     * 
+     * @param signed where the value will be encoded as a signed or unsigned
+     * integer.
+     * 
+     * @return the number of bits required to encode the value.
+     */
     static int size(int value, boolean signed)
     {
         int size = 0, i = 0;
@@ -79,7 +97,17 @@
         }
         return size;
     }
-
+    /**
+     * Calculates the minimum number of bits required to encoded an array of
+     * integer values in a series of bit fields.
+     * 
+     * @param values the values to be encoded.
+     * 
+     * @param signed where the values will be encoded as a signed or unsigned
+     * integers.
+     * 
+     * @return the minimum number of bits required to encode all the values.
+     */
     static int size(int[] values, boolean signed)
     {
         int size = 0;
@@ -89,14 +117,28 @@
 
         return size;
     }
-
+    /**
+     * Calculates the minimum number of bits required to encoded a floating
+     * point number as a fixed point number in 8.8 format. 
+     * 
+     * @param value the value to be encoded.
+     * 
+     * @return the number of bits required to encode the value.
+     */
     static int fixedShortSize(float aNumber)
     {
         float floatValue = aNumber * 256.0f;
         
         return size((int)floatValue, true);
     }
-
+    /**
+     * Calculates the minimum number of bits required to encoded a series of
+     * floating point numbers in a fixed point number in 8.8 format. 
+     * 
+     * @param value the values to be encoded.
+     * 
+     * @return the minimum number of bits required to encode all the values.
+     */
     static int fixedShortSize(float[] values)
     {
         int size = 0;
@@ -106,14 +148,28 @@
 
         return size;
     }
-    
+    /**
+     * Calculates the minimum number of bits required to encoded a floating
+     * point number as a fixed point number in 16.16 format. 
+     * 
+     * @param value the value to be encoded.
+     * 
+     * @return the number of bits required to encode the value.
+    */
     static int fixedSize(float aNumber)
     {
         float floatValue = aNumber * 65536.0f;
         
         return size((int)floatValue, true);
     }
-
+    /**
+     * Calculates the minimum number of bits required to encoded a series of
+     * floating point numbers in a fixed point number in 16.16 format. 
+     * 
+     * @param value the values to be encoded.
+     * 
+     * @return the number of bits required to encode the value.
+     */
     static int fixedSize(float[] values)
     {
         int size = 0;
@@ -123,22 +179,84 @@
 
         return size;
     }
+    /**
+     * Calculates the length of a string when encoded.
+     * 
+     * @param string the string to be encoded.
+     * 
+     * @param encoding the format used to encode the string characters.
+     * 
+     * @param appendNull whether the string should be terminated with a null
+     * byte.
+     * 
+     * @return the number of bytes required to encode the string.
+     */
+    static int strlen(String string, String encoding, boolean appendNull)
+    {    
+        int length = 0;
+        
+        if (string != null)
+        {
+            try 
+            {
+                length += string.getBytes(encoding).length;
+                length += appendNull ? 1 : 0;
+            }
+            catch (UnsupportedEncodingException e) 
+            {
+            }
+        }
+        return length;
+    }
+    /**
+     * Calculates the length of a string when encoded.
+     * 
+     * @param string the string to be encoded.
+     * 
+     * @param appendNull whether the string should be terminated with a null
+     * byte.
+     * 
+     * @return the number of bytes required to encode the string.
+     */
+    static int strlen(String string, boolean appendNull)
+    {    
+        int length = 0;
+        
+        if (string != null)
+        {
+            try 
+            {
+                length += string.getBytes("UTF8").length;
+                length += appendNull ? 1 : 0;
+            }
+            catch (UnsupportedEncodingException e) 
+            {
+            }
+        }
+        return length;
+    }
     
     private FSMovieListener listener = null;
     
-    String stringEncoding = "UTF8";
+    String encoding = "UTF8";
     
-    public int[] context = new int[18];
-    
+    private int byteOrder = LITTLE_ENDIAN;
     private byte[] data = null;
     private int ptr = 0;
     private int end = 0;
     
-    public FSCoder(int size)
+    /**
+     * Constructs an FSCoder object containing an array of bytes with the 
+     * specified byte ordering.
+     * 
+     * @param order the byte-order for words, eitherLITTLE_ENDIAN or BIG_ENDIAN.
+     * @param size the size of the internal buffer to be created.
+     */
+    public FSCoder(int order, int size)
     {
-        for (int i=0; i<context.length; i++)
-            context[i] = 0;
+        clearContext();
             
+        byteOrder = order;
         data = new byte[size];
         
         for (int i=0; i<size; i++)
@@ -147,24 +265,25 @@
         ptr = 0;
         end = data.length << 3;
     }
-        
-    public FSCoder(byte[] bytes)
+    /**
+     * Constructs an FSCoder object containing an array of bytes with the
+     * specified byte order.
+     * 
+     * @param order the byte-order for words, either LITTLE_ENDIAN or BIG_ENDIAN.
+     * @param bytes an array of bytes where the data will be read or written.
+     */
+    public FSCoder(int order, byte[] bytes)
     {
-        for (int i=0; i<context.length; i++)
-            context[i] = 0;
+        clearContext();
             
+        byteOrder = order;
         data = bytes;
         ptr = 0;
         end = data.length << 3;
     }
         
-    public FSCoder()
-    {
-        for (int i=0; i<context.length; i++)
-            context[i] = 0;
-    }
     /**
-     * @depracated The FSMovieListener interface does not enable recovery from
+     * @deprecated The FSMovieListener interface does not enable recovery from
      * coding errors or corrupt Flash files and therefore will no longer be 
      * used. Instead errors will be reported through exceptions.
      */ 
@@ -173,7 +292,7 @@
         listener = aListener;
     }
     /**
-     * @depracated The FSMovieListener interface does not enable recovery from
+     * @deprecated The FSMovieListener interface does not enable recovery from
      * coding errors or corrupt Flash files and therefore will no longer be 
      * used. Instead errors will be reported through exceptions.
      */ 
@@ -181,312 +300,584 @@
     { 
        return listener; 
     }
+    /**
+     * @deprecated
+     * 
+     * @param name
+     */
+    void beginObject(String name)
+    {
+        if (listener != null)
+            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Begin, ptr, 0, name));
+    }
+    /**
+     * @deprecated
+     * 
+     * @param name
+     */
+    void endObject(String name)
+    {
+        if (listener != null)
+            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.End, ptr, 0, name));
+    }
+    /**
+     * @deprecated
+     * 
+     */
+    void logValue(Object anObject, int location, int numberOfBits)
+    {
+        if (listener != null)
+            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Value, location, numberOfBits, anObject));
+    }
+    /**
+     * @deprecated
+     * 
+     */
+    void logError(String errorKey, int location, int length)
+    {
+        if (listener != null)
+            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Error, location, length, errorKey));
+    }
+    
+    /**
+     * Return the string representation of the character encoding scheme used
+     * when encoding or decoding strings as a sequence of bytes.
+     * 
+     * @return the string the name of the encoding schemd for characters.
+     */
+    public String getEncoding()
+    {
+        return encoding;
+    }
+    /**
+     * Sets the string representation of the character encoding scheme used
+     * when encoding or decoding strings as a sequence of bytes.
+     * 
+     * @return enc, the string the name of the encoding schemd for characters.
+     */
+    public void setEncoding(String enc)
+    {
+        encoding = enc;
+    }
 
+    /*
+     * Methods for accessing the encoded data
+     */
+
+    /**
+     * Returns a copy of the array of bytes.
+     * 
+     * @return a copy of the internal buffer.
+     */
     public byte[] getData()
     {
-        return data;
+        int length = (ptr + 7) >> 3;
+        
+        byte[] bytes = new byte[length];
+        System.arraycopy(data, 0, bytes, 0, length);
+        
+        return bytes;
+    }    
+    /**
+     * Sets the array of bytes used to read or write data to.
+     * 
+     * @param order the byte-order for words, either FSCoder.LITTLE_ENDIAN or 
+     * FSCoder.BIG_ENDIAN.
+     * 
+     * @param bytes a byte array that will be used as the internal buffer.
+     */
+    public void setData(int order, byte[] bytes)
+    {
+        byteOrder = order;
+        data = new byte[bytes.length];
+        System.arraycopy(bytes, 0, data, 0, bytes.length);
+
+        ptr = 0;
+        end = data.length << 3;
     }
-
-    public void setData(byte[] bytes)
+    /**
+     * Increases the size of the internal buffer. This method is used when 
+     * encoding data to automatically adjust the buffer size to avoid overflows.
+     *  
+     * @param size the number of bytes to add to the buffer.
+     */
+    public void addCapacity(int size)
     {
+        int length = (end >>> 3) + size;
+        byte[] bytes = new byte[length];
+        
+        System.arraycopy(data, 0, bytes, 0, data.length);
         data = bytes;
-        ptr = 0;
+        
         end = data.length << 3;
     }
     
+   /**
+    * Return the size of the internal buffer in bytes.
+    * 
+    * @return the size of the buffer.
+    */
+    public int getCapacity()
+    {
+        return end >>> 3;
+    }
+    
+    /*
+     * Methods for adjusting the locaion from where data is read or written
+     */
+    /**
+     * Returns the offset, in bits, from the start of the buffer where the next 
+     * value will be read or written.
+     * 
+     * @return the offset in bits where the next value will be read or written. 
+     */
     public int getPointer()
     {
         return ptr;
     }
-
+    /**
+     * Sets the offset, in bits, from the start of the buffer where the next 
+     * value will be read or written. If the offset falls outside of the bits 
+     * range supported by the buffer then an IllegalArgumentException will
+     * be thrown.
+     *  
+     * @param offset the offset in bits from the start of the array of bytes.
+     */
     public void setPointer(int location)
     {
-        if (location < 0)
-        {
-            location = 0;
-        }
-        else if (location > end)
-        {
-            location = end;
-        }
+        if (location < 0 || location > end)
+            throw new IllegalArgumentException();
+
         ptr = location;
     }
-
+    /**
+     * Adds offset, in bits, to the internal pointer to change the location 
+     * where the next value will be read or written. If the offset falls outside 
+     * of the range supported by the buffer then an IllegalArgumentException 
+     * will be thrown.
+     *  
+     * @param offset the offset in bits from the start of the array of bytes.
+     */
     public void adjustPointer(int offset)
     {
+        if (ptr+offset < 0 || ptr+offset > end)
+            throw new IllegalArgumentException();
+
         ptr += offset;
-        
-        if (ptr < 0)
-        {
-            ptr = 0;
-        }
-        else if (ptr >= end)
-        {
-            ptr = end;
-        }
     }
-    
+    /**
+     * Moves the internal pointer forward so it is aligned on a byte boundary. 
+     * All word values read and written to the internal buffer must be 
+     * byte-aligned.
+     */
     public void alignToByte()
     {
-        ptr += (ptr % 8 > 0) ? 8 - (ptr % 8) : 0;
+        ptr = (ptr+7) & ~7;
     }
-    
+    /**
+     * Returns true of the internal pointer is at the end of the buffer.
+     * 
+     * @return true if the pointer is at the end of the buffer, false otherwise.
+     */
     public boolean eof()
     {
         return ptr >= end;
     }
-
-    public void beginObject(String name)
+    
+    /*
+     * Core methods for readig and writing bits and multibyte words
+     */
+    /**
+     * Read a bit field from the internal buffer.
+     * 
+     * If a buffer overflow would occur then the bits which would cause the 
+     * error when read will be set to zero.
+     * 
+     * @param numberOfBits the number of bits to read.
+     * 
+     * @param signed a boolean flag indicating whether the value read should 
+     * be sign extended.
+     * 
+     * @return the value read.
+     */    
+    public int readBits(int numberOfBits, boolean signed)
     {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Begin, ptr, 0, name));
-    }
+        int value = 0;
+        
+        if (numberOfBits < 0 || numberOfBits > 32)
+            throw new IllegalArgumentException("Number of bits must be in the range 1..32.");
+        
+        if (numberOfBits == 0)
+            return 0;
+        
+        int index = ptr >> 3;
+        int base = (data.length - index > 4) ? 0 : (4 - (data.length - index))*8;
+        
+        for (int i=32; i>base; i-=8, index++)
+            value |= (data[index] & 0x000000FF) << (i-8);
 
-    public void endObject(String name)
-    {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.End, ptr, 0, name));
+        value <<= ptr % 8;
+
+        if (signed)
+            value >>= 32 - numberOfBits;
+        else 
+            value >>>= 32 - numberOfBits;
+
+        ptr += numberOfBits;
+
+        if (ptr > (data.length << 3))
+            ptr = data.length << 3;
+
+        return value;
     }
-    
-    public void logValue(Object anObject, int location, int numberOfBits)
+    /**
+     * Write a bit value to the internal buffer. The buffer will resize 
+     * automatically if required.
+     * 
+     * @param value an integer containing the value to be written.
+     * @param numberOfBits the least significant n bits from the value that 
+     * will be written to the buffer.
+     */
+    public void writeBits(int value, int numberOfBits)
     {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Value, location, numberOfBits, anObject));
+        if (numberOfBits < 0 || numberOfBits > 32)
+            throw new IllegalArgumentException("Number of bits must be in the range 1..32.");
+        
+        if (ptr+numberOfBits > end)
+            addCapacity(data.length/2);
+        
+        int index = ptr >> 3;
+
+        value <<= (32 - numberOfBits);    
+        value = value >>> (ptr % 8);
+        value = value | (data[index] << 24);
+
+        for (int i=24; i>=0; i-=8, index++)
+            data[index] = (byte)(value >>> i);
+        
+        ptr += numberOfBits;
+
+        if (ptr > (data.length << 3))
+            ptr = data.length << 3;
     }
-
-    public void logError(String errorKey, int location, int length)
+    /**
+     * Read a word from the internal buffer.
+     * 
+     * If a buffer overflow would occur then the bytes which would cause the 
+     * error when read will be set to zero.
+     * 
+     * @param numberOfBytes the number of bytes read in the range 1..4.
+     * 
+     * @param signed a boolean flag indicating whether the value read should be 
+     * sign extended.
+     * 
+     * @return the value read.
+     */
+    public int readWord(int numberOfBytes, boolean signed)
     {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Error, location, length, errorKey));
-    }
-    
-    public int strlen(String string, boolean appendNull)
-    {    
-        int length = 0;
+        int value = 0;
         
-        if (string != null)
+        if (numberOfBytes < 0 || numberOfBytes > 4)
+            throw new IllegalArgumentException("Number of bytes must be in the range 1..4.");
+        
+        int index = ptr >> 3;
+        
+        if (index + numberOfBytes > data.length)
+            numberOfBytes = data.length - index;
+        
+        int numberOfBits = numberOfBytes*8;
+
+        if (byteOrder == LITTLE_ENDIAN)
         {
-            try 
+            for (int i=0; i<numberOfBits; i+=8, ptr+=8, index++)
+                value += (data[index] & 0x000000FF) << i;
+        }
+        else
+        {
+            for (int i=0; i<numberOfBits; i+=8, ptr+=8, index++)
             {
-                length += string.getBytes(stringEncoding).length;
-                length += appendNull ? 1 : 0;
+                value = value << 8;
+                value += data[index] & 0x000000FF;
             }
-            catch (UnsupportedEncodingException e) 
-            {
-            }
         }
-        return length;
-    }
-    
-    public boolean findBits(int value, int numberOfBits, int step)
-    {
-        boolean found = false;
         
-        for (; ptr < end; ptr += step)
+        if (signed)
         {
-            if (scanBits(numberOfBits, false) == value)
-            {
-                found = true;
-                break;
-            }
+            value <<= 32 - numberOfBits;
+            value >>= 32 - numberOfBits;
         }
-        return found;
+
+        return value;
     }
-
-    public boolean findWord(int value, int numberOfBytes, int step)
+    /**
+     * Write a word to the internal buffer. The buffer will resize automatically
+     * if required.
+     * 
+     * @param value an integer containing the value to be written.
+     * @param numberOfBytes the least significant n bytes from the value that 
+     * will be written to the buffer.
+     */
+    public void writeWord(int value, int numberOfBytes)
     {
-        boolean found = false;
+        if (numberOfBytes < 0 || numberOfBytes > 4)
+            throw new IllegalArgumentException("Number of bytes must be in the range 1..4.");
+            
+        int numberOfBits = numberOfBytes*8;
         
-        for (; ptr < end; ptr += step)
+        if (ptr+numberOfBits > end)
+            addCapacity(data.length/2);
+        
+        if (byteOrder == LITTLE_ENDIAN)
         {
-            if (scanWord(numberOfBytes, false) == value)
-            {
-                found = true;
-                break;
-            }
+            int index = ptr >>> 3;
+            
+            for (int i=0; i<numberOfBits; i+=8, ptr+=8, value >>>= 8, index++)
+                data[index] = (byte)value;
         }
-        return found;
+        else
+        {
+            int index = (ptr + numberOfBits - 8) >>> 3;
+            
+            for (int i=0; i<numberOfBits; i+=8, ptr+=8, value >>>= 8, index--)
+                data[index] = (byte)value;
+        }
     }
-
-    public int scanBits(int numberOfBits, boolean signed)
+    /**
+     * Reads an array of bytes from the internal buffer. If a read overflow 
+     * would occur while reading the internal buffer then the remaining bytes 
+     * in the array will not be filled. The method returns the number of bytes 
+     * read.
+     * 
+     * @param bytes the array that will contain the bytes read.
+     * @return the number of bytes read from the buffer.
+     */
+    public int readBytes(byte[] bytes)
     {
-        int value = 0;
-        int start = ptr;
+        int bytesRead = 0;
+        
+        if (bytes == null || bytes.length == 0)
+            return bytesRead;
 
-        value = _readBits(numberOfBits, signed);
-        ptr = start;
+        int index = ptr >>> 3;
+        int numberOfBytes = bytes.length;
         
-        return value;
+        if (index + numberOfBytes > data.length)
+            numberOfBytes = data.length - index;
+
+        for (int i=0; i<numberOfBytes; i++, ptr+=8, index++, bytesRead++)
+            bytes[i] = data[index];
+
+        return bytesRead;
     }
-    
-    public int scanWord(int numberOfBytes, boolean signed)
+    /**
+     * Writes an array of bytes from the internal buffer. The internal buffer 
+     * will be resized automatically if required.
+     * 
+     * @param bytes the array containing the data to be written.
+     * @return the number of bytes written to the buffer.
+     */
+    public int writeBytes(byte[] bytes)
     {
-        int value = 0;
-        int start = ptr;
-
-        value = _readWord(numberOfBytes*8, signed);
-        ptr = start;
+        int bytesWritten = 0;
         
-        return value;
-    }
+        if (ptr+(bytes.length << 3) > end)
+            addCapacity(data.length/2);
         
-    public int readBits(int numberOfBits, boolean signed)
-    {
-        int location = ptr;
-        int value = 0;
+        if (bytes == null || bytes.length == 0)
+            return bytesWritten;
 
-        value = _readBits(numberOfBits, signed);
+        int index = ptr >>> 3;
+        int numberOfBytes = bytes.length;
+
+        for (int i=0; i<numberOfBytes; i++, ptr+=8, index++, bytesWritten++)
+            data[index] = bytes[i];
         
-        return value;
+        return bytesWritten;
     }
     
-    public void writeBits(int value, int numberOfBits)
+    /*
+     * Methods to lookahead at the data without reading.
+     */
+    /**
+     * Read a bit field without adjusting the internal pointer.
+     * 
+     * @param numberOfBits the number of bits to read.
+     * 
+     * @param signed a boolean flag indicating whether the value read should 
+     * be sign extended.
+     * 
+     * @return the value read.
+     */
+    public int scanBits(int numberOfBits, boolean signed)
     {
-        int location = ptr;
-    
-        _writeBits(value, numberOfBits);
+        int start = ptr;
+        int value = readBits(numberOfBits, signed);
+        ptr = start;
+        
+        return value;
     }
-
-    public int readWord(int numberOfBytes, boolean signed)
+    /**
+     * Read a word without adjusting the internal pointer.
+     * 
+     * @param numberOfBytes the number of bytes to read.
+     * 
+     * @param signed a boolean flag indicating whether the value read should 
+     * be sign extended.
+     * 
+     * @return the value read.
+     */
+    public int scanWord(int numberOfBytes, boolean signed)
     {
-        int location = ptr;
-        int value = 0;
-
-        value = _readWord(numberOfBytes*8, signed);
+        int start = ptr;
+        int value = readWord(numberOfBytes, signed);
+        ptr = start;
         
         return value;
     }
-        
-    public void writeWord(int value, int numberOfBytes)
-    {
-        int location = ptr;
     
-        _writeWord(value, numberOfBytes*8);
-    }
-    
+    /*
+     * Methods for accessing fixed point (8.8) and (16.16) values.
+     */
+    /**
+     * Read a fixed point number, in either (8.8) or (16.16) format from a bit 
+     * field.
+     * 
+     * @param numberOfBits the number of bits the number is encoded in.
+     * @param fractionSize the number of bits occupied by the fractional
+     * part of the number. The integer part will be signed extended.
+     * 
+     * @return the value read as a floating-point number.
+     */    
     public float readFixedBits(int numberOfBits, int fractionSize)
     {
-        int location = ptr;
-        float value = 0;
-        float divisor = (float)(1 << fractionSize);
+        float divisor = (float)(1 << fractionSize);    
+        float value = ((float)readBits(numberOfBits, true)) / divisor;
     
-        value = ((float)_readBits(numberOfBits, true)) / divisor;
-    
         return value;
     }
-    
+    /**
+     * Write a fixed point number, in either (8.8) or (16.16) format to a bit 
+     * field.
+     * 
+     * @param the value to be ecoded.
+     * @param numberOfBits the number of bits the number is encoded in.
+     * @param fractionSize the number of bits occupied by the fractional
+     * part of the number. The integer part will be signed extended.
+     */    
     public void writeFixedBits(float value, int numberOfBits, int fractionSize)
     {
-        int location = ptr; 
-        float multiplier = (float)(1 << fractionSize);
-    
-        _writeBits((int)(value*multiplier), numberOfBits);
+        float multiplier = (float)(1 << fractionSize);   
+        writeBits((int)(value*multiplier), numberOfBits);
     }
-
+    /**
+     * Read a fixed point number, in either (8.8) or (16.16) format from a 
+     * word field, accounting for the byte-ordering used.
+     * 
+     * @param mantissaSize the number of bits occupied by the integer
+     * part of the number. This will be signed extended.
+     * @param fractionSize the number of bits occupied by the fractional
+     * part of the number.
+     * 
+     * @return the value read as a floating-point number.
+     */    
     public float readFixedWord(int mantissaSize, int fractionSize)
     {
-        int location = ptr;
-        int mantissa = 0;
-        int fraction = 0;
+        float divisor = (float)(1 << (fractionSize*8));    
+        int fraction = readWord(fractionSize, false);
+        int mantissa = readWord(mantissaSize, true) << (fractionSize*8);
         
-        float value = 0;
-        float divisor = (float)(1 << fractionSize);
-    
-        fraction = _readWord(fractionSize, false);
-        mantissa = _readWord(mantissaSize, true);
-            
-        mantissa <<= fractionSize;        
-        value = (mantissa + fraction) / divisor;
-        
-        return value;
+        return (mantissa + fraction) / divisor;
     }
-    
+    /**
+     * Write a fixed point number, in either (8.8) or (16.16) format to a 
+     * word field, accounting for the byte-ordering used.
+     * 
+     * @value the value to be written.
+     * @param mantissaSize the number of bits occupied by the integer
+     * part of the number.
+     * @param fractionSize the number of bits occupied by the fractional
+     * part of the number.
+     */    
     public void writeFixedWord(float value, int mantissaSize, int fractionSize)
     {
-        int location = ptr; 
-        int mantissa = 0;
-        int fraction = 0;
-        
-        float multiplier = (float)(1 << fractionSize);
-    
-        fraction = (int)(value*multiplier);
-        mantissa = (int)value;
+        float multiplier = (float)(1 << (fractionSize*8));   
+        int fraction = (int)(value*multiplier);
+        int mantissa = (int)value;
 
-        _writeWord(fraction, fractionSize);
-        _writeWord(mantissa, mantissaSize);
+        writeWord(fraction, fractionSize);
+        writeWord(mantissa, mantissaSize);
     }
+    
+    /*
+     * Methods for reading specific data types
+     */
+    
+    /**
+     * Read a double-precision floating point number from a sequence of bytes
+     * using the byte-ordering of the buffer.
+     * 
+     * @return the value.
+     */
 
     public double readDouble()
     {
-        int location = ptr;
-        double value = 0.0;
+        int upperInt = readWord(4, false);
+        int lowerInt = readWord(4, false);
     
-        int upperInt = _readWord(32, false);
-        int lowerInt = _readWord(32, false);
-    
-        long longValue = 0;
-    
-        longValue |= (long)upperInt << 32;
+        long longValue = (long)upperInt << 32;
         longValue |= (long)lowerInt & 0x00000000FFFFFFFFL;
     
-        value = Double.longBitsToDouble(longValue);
-
-        return value;
+        return Double.longBitsToDouble(longValue);
     }
-
+    /**
+     * Write a double-precision floating point number as a sequence of bytes
+     * using the byte-ordering of the buffer.
+     * 
+     * @param value the value to be written.
+     */
     public void writeDouble(double value)
     {
-        int location = ptr;
-    
         long longValue = Double.doubleToLongBits(value);
     
         int lowerInt = (int)longValue;
         int upperInt = (int)(longValue >>> 32);
     
-        _writeWord(upperInt, 32);
-        _writeWord(lowerInt, 32);
+        writeWord(upperInt, 4);
+        writeWord(lowerInt, 4);
     }
-
-    public int readBytes(byte[] bytes)
-    {
-        int location = ptr;
-        int bytesRead = 0;
-    
-        bytesRead = _readBytes(bytes);
-    
-        return bytesRead;
-    }
-
-    public int writeBytes(byte[] bytes)
-    {
-        int location = ptr;
-        int bytesWritten = 0;
-    
-        bytesWritten = _writeBytes(bytes);
-    
-        return bytesWritten;
-    }
-    
+    /**
+     * Read a string containing the specified number of characters using the 
+     * default character encoding scheme.
+     * 
+     * @param length the number of characters to read.
+     * 
+     * @return the string containing the specified number of characters.
+     */
     public String readString(int length)
     {
-        return readString(length, stringEncoding);
+        return readString(length, encoding);
     }
-
-    public String readString(int length, String encoding)
+    /**
+     * Read a string containing the specified number of characters with the  
+     * given character encoding scheme.
+     * 
+     * @param length the number of characters to read.
+     * @return enc, the string the name of the encoding schemd for characters.
+     * 
+     * @return the string containing the specified number of characters.
+     */
+    public String readString(int length, String enc)
     {
         if (length == 0)
-        {
             return "";
-        }
             
-        int location = ptr;
         String value = null;
         byte[] str = new byte[length];
     
-        int len = _readBytes(str);
+        int len = readBytes(str);
         
         try { 
-            value = new String(str, 0, len, encoding); 
+            value = new String(str, 0, len, enc); 
         }
         catch (java.io.UnsupportedEncodingException e) 
         {
@@ -494,20 +885,22 @@
         }
         return value;
     }
-
+    /**
+     * Read a null-terminated string using the default character encoding scheme.
+     * 
+     * @return the string read from the internal buffer.
+     */
     public String readString()
     {
-        return readString(stringEncoding);
+        return readString(encoding);
     }
-    
-    public int writeString(String str)
-    {            
-        return writeString(str, stringEncoding);
-    }
-
-    public String readString(String encoding)
+    /**
+     * Read a null-terminated string using the specified character encoding scheme.
+     * 
+     * @return the string read from the internal buffer.
+     */
+    public String readString(String enc)
     {
-        int location = ptr;
         String value = null;
     
         int start = ptr>>3;
@@ -516,29 +909,48 @@
         while (start < data.length && data[start++] != 0) length++;
     
         byte[] str = new byte[length];
-        int len = _readBytes(str);
+        int len = readBytes(str);
 
         try { 
-            value = new String(str, 0, len, encoding); 
+            value = new String(str, 0, len, enc); 
         }
         catch (java.io.UnsupportedEncodingException e) 
         {
             value = "";
         }
 
-        _readWord(8, false);
+        readWord(1, false);
         len++;
     
         return value;
     }
-
-    public int writeString(String str, String encoding)
+    /**
+     * Write a string to the internal buffer using the default character 
+     * encoding scheme.
+     * 
+     * @param str the string.
+     * 
+     * @return the number of bytes written.
+     */
+    public int writeString(String str)
     {            
+        return writeString(str, encoding);
+    }
+    /**
+     * Write a string to the internal buffer using the specified character 
+     * encoding scheme.
+     * 
+     * @param str the string.
+     * 
+     * @return the number of bytes written.
+     */
+    public int writeString(String str, String enc)
+    {            
         int bytesWritten = 0;
 
         try 
         {
-            bytesWritten = writeBytes(str.getBytes(encoding)); 
+            bytesWritten = writeBytes(str.getBytes(enc)); 
         }
         catch (java.io.UnsupportedEncodingException e) 
         {
@@ -546,158 +958,125 @@
         return bytesWritten;
     }
 
-    private int _readBits(int numberOfBits, boolean signed)
+    /*
+     * Methods for searching the data
+     */
+    
+    /**
+     * Searches the internal buffer for a bit pattern and advances the pointer 
+     * to the start of the bit field, returning true to signal a successful 
+     * search. If the bit pattern cannot be found then the method returns false 
+     * and the position of the internal pointer is not changed.
+     * 
+     * The step, in bits, added to the pointer can be specified, allowing the
+     * number of bits being searched to be independent of the location in the 
+     * internal buffer. This is useful for example when searching for a bit 
+     * field that begins on a byte or word boundary.
+     *  
+     * @param value an integer containing the bit patter to search for.
+     * @param numberOfBits least significant n bits in the value to search for.
+     * @param step the increment in bits to add to the internal pointer as the 
+     * buffer is searched.
+     * 
+     * @return true if the pattern was found, false otherwise.
+     */
+    public boolean findBits(int value, int numberOfBits, int step)
     {
-        int value = 0;
-    
-        if (numberOfBits == 0)
-            return value;
+        boolean found = false;
         
-        try 
+        for (; ptr < end; ptr += step)
         {
-            int index = ptr >> 3;
-            int base = (data.length - index > 4) ? 0  : (4 - (data.length - index))*8;
-            
-            for (int i=32; i>base; i-=8, index++)
-                value |= (data[index] & 0x000000FF) << (i-8);
-    
-            value <<= ptr % 8;
-    
-            if (signed)
-                value >>= 32 - numberOfBits;
-            else 
-                value >>>= 32 - numberOfBits;
-    
-            adjustPointer(numberOfBits);
+            if (scanBits(numberOfBits, false) == value)
+            {
+                found = true;
+                break;
+            }
         }
-        catch (ArrayIndexOutOfBoundsException e)
-        {
-            value = 0;
-        }
-        return value;
+        return found;
     }
-    
-    private int _readWord(int numberOfBits, boolean signed)
+    /**
+     * Searches the internal buffer for a word and advances the pointer to the 
+     * location where the word was found, returning true to signal a successful 
+     * search. The search will begin on the next byte boundary. If word cannot 
+     * be found then the method returns false and the position of the internal 
+     * pointer is not changed.
+     * 
+     * Specifying the number of bytes in the search value allows word of either 
+     * 8, 16, 24 or 32 bits to be searched for. Searches for words are performed 
+     * faster than using the findBits() method.
+     * 
+     * @param value an integer containing the word to search for.
+     * 
+     * @param numberOfBytes least significant n bytes in the value to search 
+     * for.
+     * 
+     * @param step the increment in bits to add to the internal pointer as the 
+     * buffer is searched.
+     * 
+     * @return true if the pattern was found, false otherwise.
+     */
+    public boolean findWord(int value, int numberOfBytes, int step)
     {
-        int value = 0;
-    
-        if (numberOfBits == 0)
-            return value;
-
-        try 
+        boolean found = false;
+        
+        for (; ptr < end; ptr += step)
         {
-            int index = ptr >> 3;
-    
-            for (int i=0; i<numberOfBits; i+=8, ptr+=8, index++)
-                value += (data[index] & 0x000000FF) << i;
-            
-            if (signed)
+            if (scanWord(numberOfBytes, false) == value)
             {
-                value <<= 32 - numberOfBits;
-                value >>= 32 - numberOfBits;
+                found = true;
+                break;
             }
         }
-        catch (ArrayIndexOutOfBoundsException e)
-        {
-            value = 0;
-        }
-        return value;
+        return found;
     }
-    
-    private int _readBytes(byte[] bytes)
-    {
-        int bytesRead = 0;
-    
-        if (bytes == null || bytes.length == 0)
-            return bytesRead;
 
-        try 
-        {
-            int index = ptr >>> 3;
-            int numberOfBytes = bytes.length;
+    /*
+     * Context variables are used to pass information between objects when
+     * they are being encoded or decoded. Context variables are primarily 
+     * used within the Transform classes however they are also used when 
+     * performing unit tests on classes.
+     */
     
-            for (int i=0; i<numberOfBytes; i++, ptr+=8, index++, bytesRead++)
-                bytes[i] = data[index];
-        }
-        catch (ArrayIndexOutOfBoundsException e)
-        {
-        }        
-        return bytesRead;
-    }
+    /**
+     * TransparentColors is used to pass information to FSCOlor objects when
+     * they are being encoded or decoded so that the alpha channel will be 
+     * included.
+     */
+    public static final int TransparentColors = 0;
 
-    private void _writeBits(int value, int numberOfBits)
-    {
-        if (numberOfBits == 0)
-            return;
+    static final int Action = 1;
+    static final int Version = 2;
+    static final int Type = 3;
+    static final int Empty = 4;
+    static final int Identifier = 5;
+    static final int NumberOfFillBits = 6;
+    static final int NumberOfLineBits = 7;
+    static final int NumberOfAdvanceBits = 8;
+    static final int NumberOfGlyphBits = 9;
+    static final int NumberOfShapeBits = 10;
+    static final int ArrayCountExtended = 11;
+    static final int WideCodes = 12;
+    static final int Delta = 13;
+    static final int CodingError = 14;
+    static final int TypeInError = 15;
+    static final int StartOfError = 16;
+    static final int ExpectedLength = 17;
 
-        try 
-        {
-            int index = ptr >> 3;
-            int base = (data.length - index > 4) ? 0 : (4 - (data.length - index))*8;
-
-            value <<= (32 - numberOfBits);    
-            value = value >>> (ptr % 8);
-            value = value | (data[index] << 24);
+    int[] context = new int[18];
     
-            for (int i=24; i>=base; i-=8, index++)
-                data[index] = (byte)(value >>> i);
-            
-            ptr += numberOfBits;
-    
-            if (ptr > (data.length << 3))
-                ptr = data.length << 3;
-        }
-        catch (ArrayIndexOutOfBoundsException e)
-        {
-        }
+    private void clearContext()
+    {
+        for (int i=0; i<context.length; i++)
+            context[i] = 0;
     }
     
-    private void _writeWord(int value, int numberOfBits)
+    public int getContext(int key)
     {
-        try 
-        {
-            int index = ptr >>> 3;
-    
-            for (int i=0; i<numberOfBits; i+=8, ptr+=8, value >>>= 8, index++)
-                data[index] = (byte)value;
-        }
-        catch (ArrayIndexOutOfBoundsException e)
-        {
-        }
+        return context[key];
     }
-
-    private int _writeBytes(byte[] bytes)
-    {
-        int bytesWritten = 0;
     
-        if (bytes == null || bytes.length == 0)
-            return bytesWritten;
-
-        try 
-        {
-            int index = ptr >>> 3;
-            int numberOfBytes = bytes.length;
-    
-            for (int i=0; i<numberOfBytes; i++, ptr+=8, index++, bytesWritten++)
-                data[index] = bytes[i];
-        }
-        catch (ArrayIndexOutOfBoundsException e)
-        {
-        }
-        
-        return bytesWritten;
-    }
-
-    void writeWordAt(int location, int value, int numberOfBytes)
+    public void setContext(int key, int value)
     {
-        int currentLocation = ptr;
-        
-        ptr = location;
-    
-        _writeWord(value, numberOfBytes*8);
-        
-        ptr = currentLocation;
+        context[key] = value;
     }
-    
-
 }

Modified: trunk/src/com/flagstone/transform/FSDefineFont.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/FSDefineFont.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -173,7 +173,10 @@
         coder.context[FSCoder.NumberOfFillBits] = 1;
         coder.context[FSCoder.NumberOfLineBits] = 0;
 
-         int tableStart = coder.getPointer();
+        int currentLocation;
+        int offset;
+        
+        int tableStart = coder.getPointer();
         int tableEntry = tableStart;
    
         for (int i=0; i<shapes.size(); i++)
@@ -181,7 +184,13 @@
 
         for (Iterator i=shapes.iterator(); i.hasNext(); tableEntry += 16) 
         {
-            coder.writeWordAt(tableEntry, ((coder.getPointer() - tableStart) >> 3), 2);
+            currentLocation = coder.getPointer();
+            offset = (coder.getPointer() - tableStart) >> 3;
+            
+            coder.setPointer(tableEntry);
+            coder.writeWord(offset, 2);
+            coder.setPointer(currentLocation);
+            
             ((FSTransformObject)i.next()).encode(coder);
         }
 

Modified: trunk/src/com/flagstone/transform/FSDefineFont2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont2.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/FSDefineFont2.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -697,10 +697,14 @@
         coder.writeWord(coder.context[FSCoder.Version] > 5 ? language : 0, 1);
         coder.writeWord(coder.strlen(name, false), 1);
 
-         coder.writeString(name);
+        coder.writeString(name);
         coder.writeWord(shapes.size(), 2);
 
-         int tableStart = coder.getPointer();
+
+        int currentLocation;
+        int offset;
+        
+        int tableStart = coder.getPointer();
         int tableEntry = tableStart;
         int entrySize = wideOffsets ? 4 : 2;
    
@@ -709,11 +713,22 @@
 
         for (Iterator i=shapes.iterator(); i.hasNext(); tableEntry += entrySize << 3) 
         {
-            coder.writeWordAt(tableEntry, ((coder.getPointer() - tableStart) >> 3), entrySize);
+            currentLocation = coder.getPointer();
+            offset = (coder.getPointer() - tableStart) >> 3;
+            
+            coder.setPointer(tableEntry);
+            coder.writeWord(offset, entrySize);
+            coder.setPointer(currentLocation);
+
             ((FSTransformObject)i.next()).encode(coder);
         }
 
-        coder.writeWordAt(tableEntry, ((coder.getPointer() - tableStart) >> 3), entrySize);
+        currentLocation = coder.getPointer();
+        offset = (coder.getPointer() - tableStart) >> 3;
+        
+        coder.setPointer(tableEntry);
+        coder.writeWord(offset, entrySize);
+        coder.setPointer(currentLocation);
 
         for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
             coder.writeWord(((Integer)codesIterator.next()).intValue(), (wideCodes == 1) ? 2 : 1);

Modified: trunk/src/com/flagstone/transform/FSMovie.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovie.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/FSMovie.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -1049,21 +1049,21 @@
     */
     public void decodeFromData(byte[] bytes) throws DataFormatException, IOException
     {
-        FSCoder coder = new FSCoder();
+        FSCoder coder = null;
         FSMovieObject object = null;
 
         isFlash(bytes);
 
         if (bytes[0] == 0x43)
-            coder.setData(unzip(bytes));
+            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
         else
-            coder.setData(bytes);
+            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
         
         signature = coder.readString(3, "UTF8");
         version = coder.readWord(1, false);
         /* length */ coder.readWord(4, false);
         frameSize = new FSBounds(coder);
-        frameRate = coder.readFixedWord(8, 8);
+        frameRate = coder.readFixedWord(1, 1);
         frameCount = coder.readWord(2, false);
         
         coder.context[FSCoder.Version] = version;
@@ -1099,29 +1099,27 @@
      */
     public void decodeFromData(byte[] bytes, FSMovieListener listener)
     {
-        FSCoder coder = new FSCoder();
-
-        FSMovieObject object = null;
+        FSCoder coder = null;
+        FSMovieObject object = null;       
         
-        coder.context[FSCoder.Action]  = FSMovieEvent.Decode;
-        coder.setListener(listener);
-        
         try
         {
             isFlash(bytes);
     
             if (bytes[0] == 0x43)
-                coder.setData(unzip(bytes));
+                coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
             else
-                coder.setData(bytes);
+                coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
         
+            coder.context[FSCoder.Action]  = FSMovieEvent.Decode;
+            coder.setListener(listener);
             coder.beginObject("FSMovie");
     
             signature = coder.readString(3, "UTF8");
             version = coder.readWord(1, false);
             length = coder.readWord(4, false);
             frameSize = new FSBounds(coder);
-            frameRate = coder.readFixedWord(8, 8);
+            frameRate = coder.readFixedWord(1, 1);
             frameCount = coder.readWord(2, false);
     
             coder.context[FSCoder.Version] = version;
@@ -1217,20 +1215,20 @@
      */
     public byte[] encode() throws IOException
     {
-        FSCoder coder = new FSCoder();
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]);
         
         coder.context[FSCoder.Action]  = FSMovieEvent.Encode;        
         coder.context[FSCoder.Version] = version;
 
         int fileLength = length(coder);
 
-         coder.setData(new byte[fileLength]);         
+        coder.setData(FSCoder.LITTLE_ENDIAN, new byte[fileLength]);         
 
         coder.writeString(signature, "UTF8");
         coder.writeWord(version, 1);
         coder.writeWord(fileLength, 4);
         frameSize.encode(coder);
-        coder.writeFixedWord(frameRate, 8, 8);
+        coder.writeFixedWord(frameRate, 1, 1);
         coder.writeWord(numberOfFrames(), 2);        
 
         for (Iterator i = objects.iterator(); i.hasNext();)
@@ -1286,14 +1284,14 @@
      */
     public byte[] encode(FSMovieListener listener)
     {
-        FSCoder coder = new FSCoder();
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]);
         
         coder.context[FSCoder.Action]  = FSMovieEvent.Encode;        
         coder.context[FSCoder.Version] = version;
 
         int fileLength = length(coder);
         
-         coder.setData(new byte[fileLength]);         
+         coder.setData(FSCoder.LITTLE_ENDIAN, new byte[fileLength]);         
          coder.setListener(listener);
          
         coder.beginObject("FSMovie");

Modified: trunk/src/com/flagstone/transform/test/FSColorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSColorTest.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/test/FSColorTest.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -125,9 +125,10 @@
     private void checkEncode(int count)
     {
         FSColor colour = null;
-        FSCoder coder = new FSCoder(count);
-        coder.context[FSCoder.TransparentColors] = (count == 4) ? 1:0;
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, count);
         
+        coder.setContext(FSCoder.TransparentColors, (count == 4) ? 1:0);
+        
         for (int i=0; i<testValues.length; i++) 
         {
             if (count == 3)
@@ -146,11 +147,11 @@
     }
     private void checkDecode(int count)
     {
-        FSCoder coder = new FSCoder(count);
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, count);
         
         for (int i=0; i<testValues.length; i++) 
         {
-            coder.setData(testData[i]);
+            coder.setData(FSCoder.LITTLE_ENDIAN, testData[i]);
             
             compareAttributes(new FSColor(coder), testValues[i], count);
 

Modified: trunk/src/com/flagstone/transform/util/FSCodec.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSCodec.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/util/FSCodec.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -31,6 +31,9 @@
 package com.flagstone.transform.util;
 
 /**
+ * @deprecated FSCoded is replaced by FSCoder from com.flagstone.transform so
+ * there is only one class for reading and writing data.
+ * 
  * FSCodec is a similar to Java stream classes, allowing words and bit fields to be read
  * and written from an internal array of bytes. FSCodec supports both little-endian
  * and big-endian byte ordering. The primary use of the class is to support post-processing

Modified: trunk/src/com/flagstone/transform/util/FSImageConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSImageConstructor.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/util/FSImageConstructor.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -39,8 +39,8 @@
 import com.flagstone.transform.FSDefineImage2;
 import com.flagstone.transform.FSDefineJPEGImage2;
 import com.flagstone.transform.FSDefineShape3;
-import com.flagstone.transform.Transform;
 
+import com.flagstone.transform.FSCoder;
 import com.flagstone.transform.FSShape;
 import com.flagstone.transform.FSCoordTransform;
 import com.flagstone.transform.FSBounds;
@@ -828,24 +828,24 @@
     
     private boolean jpegInfo()
     {
-        FSCodec coder = new FSCodec(FSCodec.BIG_ENDIAN, jpegImage);
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, jpegImage);
                  
-        if (coder.readShort(false) != 0xffd8)
+        if (coder.readWord(2, false) != 0xffd8)
             return false;
 
         while (true) 
         {
-            int marker = coder.readShort(false);
-            int size = coder.readShort(false);
+            int marker = coder.readWord(2, false);
+            int size = coder.readWord(2, false);
             
             if ((marker & 0xff00) != 0xff00) 
                 return false;
             
             if (marker >= 0xffc0 && marker <= 0xffcf && marker != 0xffc4 && marker != 0xffc8) 
             {
-                coder.readByte();
-                height = coder.readShort(false);
-                width = coder.readShort(false);
+                coder.readWord(1, false);
+                height = coder.readWord(2, false);
+                width = coder.readWord(2, false);
                 return true;
             } 
             else 
@@ -866,18 +866,18 @@
 
     private void decodeBMP(byte[] bytes) throws DataFormatException
     {
-        FSCodec coder = new FSCodec(FSCodec.LITTLE_ENDIAN, bytes);
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
         
         for (int i=0; i<2; i++)
         {
-            if (coder.readByte() != bmpSignature[i])
+            if (coder.readWord(1, false) != bmpSignature[i])
                 throw new DataFormatException("Not a valid BMP file");
         }
 
-        coder.readInt(); // fileSize
-        coder.readInt(); // reserved
-        int offset = coder.readInt();
-        int headerSize = coder.readInt();
+        coder.readWord(4, false); // fileSize
+        coder.readWord(4, false); // reserved
+        int offset = coder.readWord(4, false);
+        int headerSize = coder.readWord(4, false);
         
         int bitsPerPixel = 0;
         int coloursUsed = 0;
@@ -885,22 +885,22 @@
         switch (headerSize)
         {
             case 12:
-                width = coder.readShort(false);
-                height = coder.readShort(false);
-                coder.readShort(false); // bitPlanes
-                bitsPerPixel = coder.readShort(false);
+                width = coder.readWord(2, false);
+                height = coder.readWord(2, false);
+                coder.readWord(2, false); // bitPlanes
+                bitsPerPixel = coder.readWord(2, false);
                 break;
             case 40:
-                width = coder.readInt();
-                height = coder.readInt();
-                coder.readShort(false); // bitPlanes
-                bitsPerPixel = coder.readShort(false);
-                attributes[COMPRESSION_METHOD] = coder.readInt();
-                coder.readInt(); //imageSize
-                coder.readInt(); // horizontalResolution
-                coder.readInt(); // verticalResolution
-                coloursUsed = coder.readInt();
-                coder.readInt(); // importantColours
+                width = coder.readWord(4, false);
+                height = coder.readWord(4, false);
+                coder.readWord(2, false); // bitPlanes
+                bitsPerPixel = coder.readWord(2, false);
+                attributes[COMPRESSION_METHOD] = coder.readWord(4, false);
+                coder.readWord(4, false); //imageSize
+                coder.readWord(4, false); // horizontalResolution
+                coder.readWord(4, false); // verticalResolution
+                coloursUsed = coder.readWord(4, false);
+                coder.readWord(4, false); // importantColours
                 break;
             default:
                 break;
@@ -908,9 +908,9 @@
         
         if (attributes[COMPRESSION_METHOD] == BI_BITFIELDS)
         {
-            attributes[RED_MASK] = coder.readInt();
-            attributes[GREEN_MASK] = coder.readInt();
-            attributes[BLUE_MASK] = coder.readInt();
+            attributes[RED_MASK] = coder.readWord(4, false);
+            attributes[GREEN_MASK] = coder.readWord(4, false);
+            attributes[BLUE_MASK] = coder.readWord(4, false);
         }
         
         switch (bitsPerPixel)
@@ -935,19 +935,19 @@
                 for (int i=0; i < coloursUsed; i++) 
                 {
                     colourTable[i][3] = (byte)0xFF;
-                    colourTable[i][2] = (byte)coder.readByte();
-                    colourTable[i][1] = (byte)coder.readByte();
-                    colourTable[i][0] = (byte)coder.readByte();
+                    colourTable[i][2] = (byte)coder.readWord(1, false);
+                    colourTable[i][1] = (byte)coder.readWord(1, false);
+                    colourTable[i][0] = (byte)coder.readWord(1, false);
                 }
             }
             else
             {
                 for (int i=0; i < coloursUsed; i++)
                 {
-                    colourTable[i][0] = (byte)coder.readByte();
-                    colourTable[i][1] = (byte)coder.readByte();
-                    colourTable[i][2] = (byte)coder.readByte();
-                    colourTable[i][3] = (byte)(coder.readByte() | 0xFF);
+                    colourTable[i][0] = (byte)coder.readWord(1, false);
+                    colourTable[i][1] = (byte)coder.readWord(1, false);
+                    colourTable[i][2] = (byte)coder.readWord(1, false);
+                    colourTable[i][3] = (byte)(coder.readWord(1, false) | 0xFF);
                 }
             }
                 
@@ -975,7 +975,7 @@
         }
     }
 
-    private void decodeIDX8(FSCodec coder)
+    private void decodeIDX8(FSCoder coder)
     {
         int h = 0;
         int w = 0;
@@ -993,7 +993,7 @@
         }
     }
 
-    private void decodeRLE4(FSCodec coder)
+    private void decodeRLE4(FSCoder coder)
     {
         int row = height-1;
         int col = 0;
@@ -1002,11 +1002,11 @@
 
         while (containsMorePixels) 
         {       
-            int count = coder.readByte();
+            int count = coder.readWord(1, false);
         
             if (count == 0)
             {
-                int code = coder.readByte();
+                int code = coder.readWord(1, false);
                 
                 switch (code)
                 {
@@ -1018,8 +1018,8 @@
                         containsMorePixels = false; 
                         break;
                     case 2: 
-                        col += coder.readShort(false);
-                        row -= coder.readShort(false);
+                        col += coder.readWord(2, false);
+                        row -= coder.readWord(2, false);
                     default:
                         for (int i=0; i<code; i+=2)
                         {
@@ -1027,7 +1027,7 @@
                             indexedImage[row][col++] = (byte) coder.readBits(4, false);
                         }
                         
-                        if ((code & 2) == 2) coder.readByte();
+                        if ((code & 2) == 2) coder.readWord(1, false);
                         break;
                 }
             }
@@ -1042,7 +1042,7 @@
         }
     }
     
-    private void decodeRLE8(FSCodec coder)
+    private void decodeRLE8(FSCoder coder)
     {
         int row = height-1;
         int col = 0;
@@ -1051,11 +1051,11 @@
 
         while (containsMorePixels) 
         {       
-            int count = coder.readByte();
+            int count = coder.readWord(1, false);
         
             if (count == 0)
             {
-                int code = coder.readByte();
+                int code = coder.readWord(1, false);
                 
                 switch (code)
                 {
@@ -1067,19 +1067,19 @@
                         containsMorePixels = false; 
                         break;
                     case 2: 
-                        col += coder.readShort(false);
-                        row -= coder.readShort(false);
+                        col += coder.readWord(2, false);
+                        row -= coder.readWord(2, false);
                     default:
                         for (int i=0; i<code; i++)
-                            indexedImage[row][col++] = (byte) coder.readByte();
+                            indexedImage[row][col++] = (byte) coder.readWord(1, false);
                         
-                        if ((code & 1) == 1) coder.readByte();
+                        if ((code & 1) == 1) coder.readWord(1, false);
                         break;
                 }
             }
             else
             {
-                byte index = (byte)coder.readByte();
+                byte index = (byte)coder.readWord(1, false);
                 
                 for (int i=0; i<count; i++) 
                     indexedImage[row][col++] = index;
@@ -1087,7 +1087,7 @@
         }
     }
     
-    private void decodeRGB5(FSCodec coder)
+    private void decodeRGB5(FSCoder coder)
     {
         int h = 0;
         int w = 0;
@@ -1099,7 +1099,7 @@
             {
                 for (w=0, bitsRead=0; w<width; w++)
                 {                
-                    int colour = coder.readShort(false) & 0xFFFF;
+                    int colour = coder.readWord(2, false) & 0xFFFF;
                     
                     colorImage[h][w][0] = (byte)((colour & 0x7C00) >> 7);
                     colorImage[h][w][1] = (byte)((colour & 0x03E0) >> 2);
@@ -1118,7 +1118,7 @@
             {
                 for (w=0, bitsRead=0; w<width; w++)
                 {
-                    int colour = coder.readShort(false) & 0xFFFF;
+                    int colour = coder.readWord(2, false) & 0xFFFF;
                     
                     if (attributes[RED_MASK] == 0x7C00 && attributes[GREEN_MASK] == 0x03E0 && attributes[BLUE_MASK] == 0x001F)
                     {
@@ -1143,7 +1143,7 @@
         
     }
 
-    private void decodeRGB8(FSCodec coder)
+    private void decodeRGB8(FSCoder coder)
     {
         int h = 0;
         int w = 0;
@@ -1165,7 +1165,7 @@
         }
     }
 
-    private void decodeRGBA(FSCodec coder)
+    private void decodeRGBA(FSCoder coder)
     {
         int h = 0;
         int w = 0;
@@ -1174,10 +1174,10 @@
         {
             for (w=0; w<width; w++)
             {
-                colorImage[h][w][2] = (byte)coder.readByte();
-                colorImage[h][w][1] = (byte)coder.readByte();
-                colorImage[h][w][0] = (byte)coder.readByte();
-                colorImage[h][w][3] = (byte)coder.readByte();
+                colorImage[h][w][2] = (byte)coder.readWord(1, false);
+                colorImage[h][w][1] = (byte)coder.readWord(1, false);
+                colorImage[h][w][0] = (byte)coder.readWord(1, false);
+                colorImage[h][w][3] = (byte)coder.readWord(1, false);
                 colorImage[h][w][3] = (byte)0xFF;
             }
         }
@@ -1185,7 +1185,7 @@
 
     private void decodePNG(byte[] bytes) throws DataFormatException
     {
-        FSCodec coder = new FSCodec(FSCodec.BIG_ENDIAN, bytes);
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
 
         int length = 0;
         int chunkType = 0;
@@ -1193,14 +1193,14 @@
 
         for (int i=0; i<8; i++)
         {
-            if (coder.readByte() != pngSignature[i])
+            if (coder.readWord(1, false) != pngSignature[i])
                 throw new DataFormatException("Not a valid PNG file");
         }
         
         while (moreChunks)
         {
-            length = coder.readInt();
-            chunkType = coder.readInt();
+            length = coder.readWord(4, false);
+            chunkType = coder.readWord(4, false);
             
             int current = coder.getPointer();
             int next = current + ((length+4) << 3);
@@ -1242,20 +1242,20 @@
         decodeImage();
     }
 
-    private void decodeIHDR(FSCodec coder, int length)
+    private void decodeIHDR(FSCoder coder, int length)
     {
-        width = coder.readInt();
-        height = coder.readInt();
-        attributes[BIT_DEPTH] = coder.readByte();
-        attributes[COLOUR_TYPE] = coder.readByte();
-        attributes[COMPRESSION_METHOD] = coder.readByte();
-        attributes[FILTER_METHOD] = coder.readByte();
-        attributes[INTERLACE_METHOD] = coder.readByte();
+        width = coder.readWord(4, false);
+        height = coder.readWord(4, false);
+        attributes[BIT_DEPTH] = coder.readWord(1, false);
+        attributes[COLOUR_TYPE] = coder.readWord(1, false);
+        attributes[COMPRESSION_METHOD] = coder.readWord(1, false);
+        attributes[FILTER_METHOD] = coder.readWord(1, false);
+        attributes[INTERLACE_METHOD] = coder.readWord(1, false);
         
-        coder.readInt(); // crc
+        coder.readWord(4, false); // crc
     }
 
-    private void decodePLTE(FSCodec coder, int length)
+    private void decodePLTE(FSCoder coder, int length)
     {
         if (attributes[COLOUR_TYPE] == 3)
         {
@@ -1266,41 +1266,41 @@
             for (int i=0; i<paletteSize; i++)
             {
                 colourTable[i][3] = (byte)0xFF;
-                colourTable[i][2] = (byte)coder.readByte();
-                colourTable[i][1] = (byte)coder.readByte();
-                colourTable[i][0] = (byte)coder.readByte();
+                colourTable[i][2] = (byte)coder.readWord(1, false);
+                colourTable[i][1] = (byte)coder.readWord(1, false);
+                colourTable[i][0] = (byte)coder.readWord(1, false);
             }
         }
         else
         {
             coder.adjustPointer(length << 3);
         }        
-        coder.readInt(); // crc
+        coder.readWord(4, false); // crc
     }
 
-    private void decodeTRNS(FSCodec coder, int length)
+    private void decodeTRNS(FSCoder coder, int length)
     {
         switch(attributes[COLOUR_TYPE])
         {
             case GREYSCALE:
-                attributes[TRANSPARENT_GREY] = coder.readShort(false);
+                attributes[TRANSPARENT_GREY] = coder.readWord(2, false);
                 break;
             case TRUE_COLOUR:
-                attributes[TRANSPARENT_RED] = coder.readShort(false);
-                attributes[TRANSPARENT_GREEN] = coder.readShort(false);
-                attributes[TRANSPARENT_BLUE] = coder.readShort(false);
+                attributes[TRANSPARENT_RED] = coder.readWord(2, false);
+                attributes[TRANSPARENT_GREEN] = coder.readWord(2, false);
+                attributes[TRANSPARENT_BLUE] = coder.readWord(2, false);
                 break;
             case INDEXED_COLOUR:
                 for (int i=0; i<length; i++)
-                    colourTable[i][3] = (byte)coder.readByte();
+                    colourTable[i][3] = (byte)coder.readWord(1, false);
                 break;
             default:
                 break;
         }
-        coder.readInt(); // crc
+        coder.readWord(4, false); // crc
     }
 
-    private void decodeIDAT(FSCodec coder, int length)
+    private void decodeIDAT(FSCoder coder, int length)
     {
         int currentLength = chunkData.length;
         int newLength = currentLength + length;
@@ -1310,11 +1310,11 @@
         System.arraycopy(chunkData, 0, data, 0, currentLength);
 
         for (int i=currentLength; i<newLength; i++)
-            data[i] = (byte)coder.readByte();
+            data[i] = (byte)coder.readWord(1, false);
             
         chunkData = data;
         
-        coder.readInt(); // crc
+        coder.readWord(4, false); // crc
     }
 
     private void decodeImage() throws DataFormatException
@@ -1419,7 +1419,7 @@
         
                 System.arraycopy(current, 0, previous, 0, scanLength);
                         
-                FSCodec coder = new FSCodec(FSCodec.BIG_ENDIAN, current);
+                FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, current);
                 
                 for (col=colStart; col<width; col+=colInc)
                 {
@@ -1450,7 +1450,7 @@
         return c;
     }
 
-    private void decodeGreyscale(FSCodec coder, int row, int col)
+    private void decodeGreyscale(FSCoder coder, int row, int col)
     {
         int pixel = 0;
         byte colour = 0;
@@ -1460,8 +1460,8 @@
             case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; break;
             case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; break;
             case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; break;
-            case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
-            case 16: pixel = coder.readShort(false); colour = (byte) (pixel >> 8); break;
+            case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; break;
+            case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel >> 8); break;
         }                    
 
         colorImage[row][col][0] = colour;
@@ -1470,7 +1470,7 @@
         colorImage[row][col][3] = (byte)attributes[TRANSPARENT_GREY];
     }
     
-    private void decodeTrueColour(FSCodec coder, int row, int col)
+    private void decodeTrueColour(FSCoder coder, int row, int col)
     {
         int pixel = 0;
         byte colour = 0;
@@ -1479,15 +1479,15 @@
         {
             switch (attributes[BIT_DEPTH])
             {
-                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
-                case 16: pixel = coder.readShort(false); colour = (byte) (pixel >> 8); break;
+                case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; break;
+                case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel >> 8); break;
             }                    
             colorImage[row][col][i] = colour;
         }
         colorImage[row][col][3] = (byte)attributes[TRANSPARENT_RED];
     }
     
-    private void decodeIndexedColour(FSCodec coder, int row, int col)
+    private void decodeIndexedColour(FSCoder coder, int row, int col)
     {
         int index = 0;
         
@@ -1496,13 +1496,13 @@
             case 1:  index = coder.readBits(1, false); break;
             case 2:  index = coder.readBits(2, false); break;
             case 4:  index = coder.readBits(4, false); break;
-            case 8:  index = coder.readByte(); break;
-            case 16: index = coder.readShort(false); break;
+            case 8:  index = coder.readWord(1, false); break;
+            case 16: index = coder.readWord(2, false); break;
         }                    
         indexedImage[row][col] = (byte)index;
     }
     
-    private void decodeAlphaGreyscale(FSCodec coder, int row, int col)
+    private void decodeAlphaGreyscale(FSCoder coder, int row, int col)
     {
         int pixel = 0;
         byte colour = 0;
@@ -1513,8 +1513,8 @@
             case 1:  pixel = coder.readBits(1, false); colour = (byte) monochrome[pixel]; alpha = coder.readBits(1, false); break;
             case 2:  pixel = coder.readBits(2, false); colour = (byte) greyscale2[pixel]; alpha = coder.readBits(2, false); break;
             case 4:  pixel = coder.readBits(4, false); colour = (byte) greyscale4[pixel]; alpha = coder.readBits(4, false); break;
-            case 8:  pixel = coder.readByte(); colour = (byte) pixel; alpha = coder.readByte(); break;
-            case 16: pixel = coder.readShort(false); colour = (byte) (pixel >> 8); alpha = coder.readShort(false) >> 8; break;
+            case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; alpha = coder.readWord(1, false); break;
+            case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel >> 8); alpha = coder.readWord(2, false) >> 8; break;
         }                    
 
         colorImage[row][col][0] = colour;
@@ -1523,7 +1523,7 @@
         colorImage[row][col][3] = (byte) alpha;
     }
     
-    private void decodeAlphaTrueColour(FSCodec coder, int row, int col)
+    private void decodeAlphaTrueColour(FSCoder coder, int row, int col)
     {
         int pixel = 0;
         byte colour = 0;
@@ -1532,8 +1532,8 @@
         {
             switch (attributes[BIT_DEPTH])
             {
-                case 8:  pixel = coder.readByte(); colour = (byte) pixel; break;
-                case 16: pixel = coder.readShort(false); colour = (byte) (pixel >> 8); break;
+                case 8:  pixel = coder.readWord(1, false); colour = (byte) pixel; break;
+                case 16: pixel = coder.readWord(2, false); colour = (byte) (pixel >> 8); break;
             }                    
             colorImage[row][col][i] = colour;
         }

Modified: trunk/src/com/flagstone/transform/util/FSSoundConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSSoundConstructor.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/util/FSSoundConstructor.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -434,7 +434,7 @@
 
     private void decodeWAV(String filename) throws FileNotFoundException, IOException, DataFormatException
     {
-        FSCodec coder = new FSCodec(FSCodec.LITTLE_ENDIAN, dataFromFile(filename));
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, dataFromFile(filename));
         
         int length = 0;
         int chunkType = 0;
@@ -442,22 +442,22 @@
 
         for (int i=0; i<4; i++)
         {
-            if (coder.readByte() != riffSignature[i])
+            if (coder.readWord(1, false) != riffSignature[i])
                 throw new DataFormatException("Not a valid RIFF file");
         }
         
-        coder.readInt();
+        coder.readWord(4, false);
         
         for (int i=0; i<4; i++)
         {
-            if (coder.readByte() != wavSignature[i])
+            if (coder.readWord(1, false) != wavSignature[i])
                 throw new DataFormatException("Not a valid WAV file");
         }
        
         while (moreChunks)
         {
-            chunkType = coder.readInt();
-            length = coder.readInt();
+            chunkType = coder.readWord(4, false);
+            length = coder.readWord(4, false);
             
             int blockStart = coder.getPointer();
             
@@ -483,21 +483,21 @@
         }
     }
 
-    private void decodeFMT(FSCodec coder) throws DataFormatException
+    private void decodeFMT(FSCoder coder) throws DataFormatException
     {
         format = FSSound.PCM;
         
-        if (coder.readShort(false) != 1)
+        if (coder.readWord(2, false) != 1)
             throw new DataFormatException("Compressed WAV files are not currently supported.");
         
-        numberOfChannels = coder.readShort(false);
-        sampleRate = coder.readInt();
-        coder.readInt(); // total data length
-        coder.readShort(false); // total bytes per sample
-        sampleSize = coder.readShort(false) / 8;
+        numberOfChannels = coder.readWord(2, false);
+        sampleRate = coder.readWord(4, false);
+        coder.readWord(4, false); // total data length
+        coder.readWord(2, false); // total bytes per sample
+        sampleSize = coder.readWord(2, false) / 8;
     }
     
-    private void decodeDATA(FSCodec coder, int length)
+    private void decodeDATA(FSCoder coder, int length)
     {
         samplesPerChannel = length / (sampleSize*numberOfChannels);
 
@@ -509,7 +509,7 @@
 
     private void decodeMP3(byte[] bytes) throws DataFormatException
     {
-        FSCodec coder = new FSCodec(FSCodec.LITTLE_ENDIAN, bytes);
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
         
         format = FSSound.MP3;
         sampleSize = 2;
@@ -517,11 +517,11 @@
         coder.findBits(0x7FF, 11, 8);
         
         int frameStart = coder.getPointer();
-        int dataLength = coder.getBuffer().length - (coder.getPointer() >> 3);
+        int dataLength = coder.getCapacity() - (coder.getPointer() >> 3);
         
         sound = new byte[dataLength];
         
-        System.arraycopy(coder.getBuffer(), (coder.getPointer() >> 3), sound, 0, dataLength);
+        System.arraycopy(coder.getData(), (coder.getPointer() >> 3), sound, 0, dataLength);
         
         int numberOfFrames = 0;
         
@@ -601,7 +601,7 @@
     
     private void initFrameTable(byte[] bytes)
     {
-        FSCodec coder = new FSCodec(FSCodec.LITTLE_ENDIAN, bytes);
+        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
                 
         coder.findBits(0x7FF, 11, 8);
         
@@ -640,7 +640,7 @@
         }
     }
     
-    private int MP3FrameSize(FSCodec coder)
+    private int MP3FrameSize(FSCoder coder)
     {
         int frameSize = 4;
         

Modified: trunk/src/com/flagstone/transform/util/FSTextConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2006-02-26 17:12:16 UTC (rev 86)
+++ trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2006-02-26 17:14:50 UTC (rev 87)
@@ -1105,14 +1105,14 @@
 
     private void decodeOpenTypeFont(String fontName) throws FileNotFoundException, IOException, DataFormatException
     {
-        FSCodec coder = new FSCodec(FSCodec.BIG_ENDIAN, dataFromFile(fontName));
+        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, dataFromFile(fontName));
         
         float version = coder.readFixedBits(32, 16);
 
-        int tableCount = coder.readShort(false);
-        int searchRange = coder.readShort(false);
-        int entrySelector = coder.readShort(false);
-        int rangeShift = coder.readShort(false);
+        int tableCount = coder.readWord(2, false);
+        int searchRange = coder.readWord(2, false);
+        int entrySelector = coder.readWord(2, false);
+        int rangeShift = coder.readWord(2, false);
         
         int os_2Offset = 0;
         int headOffset = 0;
@@ -1141,10 +1141,10 @@
         
         for (int i=0; i<tableCount; i++) 
         {
-            chunkType = coder.readInt();
-            checksum = coder.readInt();
-            offset = coder.readInt() << 3;
-            length = coder.readInt();
+            chunkType = coder.readWord(4, false);
+            checksum = coder.readWord(4, false);
+            offset = coder.readWord(4, false) << 3;
+            length = coder.readWord(4, false);
             
             /* 
              * Chunks are encoded in ascending alphabetical order so
@@ -1197,21 +1197,21 @@
         glyphTable[spaceIndex].shape = new FSShape();
         glyphTable[spaceIndex].advance = 250;
     }
-    private void decodeHEAD(FSCodec coder)
+    private void decodeHEAD(FSCoder coder)
     {
         byte[] date = new byte[8];
     
         coder.readFixedBits(32, 16); // table version 
         coder.readFixedBits(32, 16); // font version 
-        coder.readInt(); // checksum adjustment
-        coder.readInt(); // magic number
+        coder.readWord(4, false); // checksum adjustment
+        coder.readWord(4, false); // magic number
         coder.readBits(1, false); // baseline at y=0
         coder.readBits(1, false); // side bearing at x=0;
         coder.readBits(1, false); // instructions depend on point size
         coder.readBits(1, false); // force ppem to integer values
         coder.readBits(1, false); // instructions may alter advance
         coder.readBits(11, false);
-        attributes[SCALE] = coder.readShort(false) / 1024;  // units per em
+        attributes[SCALE] = coder.readWord(2, false) / 1024;  // units per em
 
         if (attributes[SCALE] == 0) 
             attributes[SCALE] = 1;
@@ -1219,10 +1219,10 @@
         coder.readBytes(date); // number of seconds since midnight, Jan 01 1904
         coder.readBytes(date); // number of seconds since midnight, Jan 01 1904
     
-        coder.readShort(true); // xMin for all glyph bounding boxes
-        coder.readShort(true); // yMin for all glyph bounding boxes
-        coder.readShort(true); // xMax for all glyph bounding boxes
-        coder.readShort(true); // yMax for all glyph bounding boxes
+        coder.readWord(2, true); // xMin for all glyph bounding boxes
+        coder.readWord(2, true); // yMin for all glyph bounding boxes
+        coder.readWord(2, true); // xMax for all glyph bounding boxes
+        coder.readWord(2, true); // yMax for all glyph bounding boxes
     
         /*
          * Next two byte define font appearance on Macs, values are 
@@ -1232,70 +1232,70 @@
         isItalic = coder.readBits(1, false) != 0;
         coder.readBits(14, false); // 
 
-        coder.readShort(false);// smallest readable size in pixels
-        coder.readShort(true); // font direction hint
-        attributes[GLYPH_OFFSET_SIZE] = coder.readShort(true); 
-        coder.readShort(true); // glyph data format
+        coder.readWord(2, false);// smallest readable size in pixels
+        coder.readWord(2, true); // font direction hint
+        attributes[GLYPH_OFFSET_SIZE] = coder.readWord(2, true); 
+        coder.readWord(2, true); // glyph data format
     }
-    private void decodeHHEA(FSCodec coder)
+    private void decodeHHEA(FSCoder coder)
     {
         coder.readFixedBits(32, 16); // table version
     
-        ascent = coder.readShort(true);
-        descent = coder.readShort(true);
-        leading = coder.readShort(true);
+        ascent = coder.readWord(2, true);
+        descent = coder.readWord(2, true);
+        leading = coder.readWord(2, true);
         
-        coder.readShort(false); // maximum advance in the htmx table
-        coder.readShort(true); // minimum left side bearing in the htmx table
-        coder.readShort(true); // minimum right side bearing in the htmx table
-        coder.readShort(true); // maximum extent
-        coder.readShort(true); // caret slope rise 
-        coder.readShort(true); // caret slope run
-        coder.readShort(true); // caret offset
+        coder.readWord(2, false); // maximum advance in the htmx table
+        coder.readWord(2, true); // minimum left side bearing in the htmx table
+        coder.readWord(2, true); // minimum right side bearing in the htmx table
+        coder.readWord(2, true); // maximum extent
+        coder.readWord(2, true); // caret slope rise 
+        coder.readWord(2, true); // caret slope run
+        coder.readWord(2, true); // caret offset
     
-        coder.readShort(false); // reserved
-        coder.readShort(false); // reserved
-        coder.readShort(false); // reserved
-        coder.readShort(false); // reserved
+        coder.readWord(2, false); // reserved
+        coder.readWord(2, false); // reserved
+        coder.readWord(2, false); // reserved
+        coder.readWord(2, false); // reserved
     
-        coder.readShort(true); // metric data format 
+        coder.readWord(2, true); // metric data format 
         
-        attributes[NUMBER_OF_METRICS] = coder.readShort(false);    
+        attributes[NUMBER_OF_METRICS] = coder.readWord(2, false);    
     }
-    private void decodeOS_2(FSCodec coder)
+    private void decodeOS_2(FSCoder coder)
     {
         byte[] panose = new byte[10];
         int[] unicodeRange = new int[4];
         byte[] vendor = new byte[4];
 
-        int version = coder.readShort(false); // version
-        coder.readShort(true); // average character width
+        int version = coder.readWord(2, false); // version
+        coder.readWord(2, true); // average character width
         
-        switch (coder.readShort(false)) // weight class
+        switch (coder.readWord(2, false)) // weight class
         {
             case FONT_WEIGHT_BOLD: isBold = true; break;
             default: break;
         }
 
-        coder.readShort(false); // width class
-        coder.readShort(false); // embedding licence
+        coder.readWord(2, false); // width class
+        coder.readWord(2, false); // embedding licence
         
-        coder.readShort(true); // subscript x size
-        coder.readShort(true); // subscript y size
-        coder.readShort(true); // subscript x offset
-        coder.readShort(true); // subscript y offset
-        coder.readShort(true); // superscript x size
-        coder.readShort(true); // superscript y size
-        coder.readShort(true); // superscript x offset
-        coder.readShort(true); // superscript y offset
-        coder.readShort(true); // width of strikeout stroke
-        coder.readShort(true); // strikeout stroke position
-        coder.readShort(true); // font family class
+        coder.readWord(2, true); // subscript x size
+        coder.readWord(2, true); // subscript y size
+        coder.readWord(2, true); // subscript x offset
+        coder.readWord(2, true); // subscript y offset
+        coder.readWord(2, true); // superscript x size
+        coder.readWord(2, true); // superscript y size
+        coder.readWord(2, true); // superscript x offset
+        coder.readWord(2, true); // superscript y offset
+        coder.readWord(2, true); // width of strikeout stroke
+        coder.readWord(2, true); // strikeout stroke position
+        coder.readWord(2, true); // font family class
     
         coder.readBytes(panose);
         
         for (int i=0; i<4; i++)
-            unicodeRange[i] = coder.readInt();
+            unicodeRange[i] = coder.readWord(4, false);
             
         coder.readBytes(vendor); // font vendor identification
         
@@ -1304,46 +1304,46 @@
         isBold = coder.readBits(1, false) != 0;
         coder.readBits(10, false);
         
-        coder.readShort(false); // first unicode character code
-        coder.readShort(false); // last unicode character code
+        coder.readWord(2, false); // first unicode character code
+        coder.readWord(2, false); // last unicode character code
         
-        ascent = coder.readShort(false);
-        descent = coder.readShort(false);
-        leading = coder.readShort(false);
+        ascent = coder.readWord(2, false);
+        descent = coder.readWord(2, false);
+        leading = coder.readWord(2, false);
     
-        coder.readShort(false); // ascent in Windows
-        coder.readShort(false); // descent in Windows
+        coder.readWord(2, false); // ascent in Windows
+        coder.readWord(2, false); // descent in Windows
         
         if (version > 0)
         {
-            coder.readInt(); // code page range 
-            coder.readInt(); // code page range
+            coder.readWord(4, false); // code page range 
+            coder.readWord(4, false); // code page range
 
             if (version > 1)
             {
-                coder.readShort(true); // height
-                coder.readShort(true); // Capitals height
-                missingGlyph = coder.readShort(false);
-                coder.readShort(false); // break character
-                coder.readShort(false); // maximum context
+                coder.readWord(2, true); // height
+                coder.readWord(2, true); // Capitals height
+                missingGlyph = coder.readWord(2, false);
+                coder.readWord(2, false); // break character
+                coder.readWord(2, false); // maximum context
             }
         }
     }
-    private void decodeNAME(FSCodec coder)
+    private void decodeNAME(FSCoder coder)
     {
-        int format = coder.readShort(false);
-        int numberOfNameRecords = coder.readShort(false);
-        int stringTable = coder.readShort(false);
+        int format = coder.readWord(2, false);
+        int numberOfNameRecords = coder.readWord(2, false);
+        int stringTable = coder.readWord(2, false);
         
         for (int i=0; i<numberOfNameRecords; i++) 
         {
-            int platformId = coder.readShort(false);
-            int encodingId = coder.readShort(false);
-            int languageId = coder.readShort(false);
-            int nameId = coder.readShort(false);
+            int platformId = coder.readWord(2, false);
+            int encodingId = coder.readWord(2, false);
+            int languageId = coder.readWord(2, false);
+            int nameId = coder.readWord(2, false);
             
-            int stringLength = coder.readShort(false);
-            int stringOffset = coder.readShort(false);
+            int stringLength = coder.readWord(2, false);
+            int stringOffset = coder.readWord(2, false);
             
             int current = coder.getPointer();
             
@@ -1384,36 +1384,36 @@
             coder.setPointer(current);
         }
     }
-    private void decodeMAXP(FSCodec coder)
+    private void decodeMAXP(FSCoder coder)
     {
         float version = coder.readFixedBits(32, 16);
-        numberOfGlyphs = coder.readShort(false);
+        numberOfGlyphs = coder.readWord(2, false);
         
         if (version == 1.0)
         {
-            coder.readShort(false); // maximum number of points in a simple glyph
-            coder.readShort(false); // maximum number of contours in a simple glyph
-            coder.readShort(false); // maximum number of points in a composite glyph
-            coder.readShort(false); // maximum number of contours in a composite glyph
-            coder.readShort(false); // maximum number of zones
-            coder.readShort(false); // maximum number of point in Z0
-            coder.readShort(false); // number of storage area locations
-            coder.readShort(false); // maximum number of FDEFs
-            coder.readShort(false); // maximum number of IDEFs
-            coder.readShort(false); // maximum stack depth
-            coder.readShort(false); // maximum byte count for glyph instructions
-            coder.readShort(false); // maximum number of components for composite glyphs
-            coder.readShort(false); // maximum level of recursion
+            coder.readWord(2, false); // maximum number of points in a simple glyph
+            coder.readWord(2, false); // maximum number of contours in a simple glyph
+            coder.readWord(2, false); // maximum number of points in a composite glyph
+            coder.readWord(2, false); // maximum number of contours in a composite glyph
+            coder.readWord(2, false); // maximum number of zones
+            coder.readWord(2, false); // maximum number of point in Z0
+            coder.readWord(2, false); // number of storage area locations
+            coder.readWord(2, false); // maximum number of FDEFs
+            coder.readWord(2, false); // maximum number of IDEFs
+            coder.readWord(2, false); // maximum stack depth
+            coder.readWord(2, false); // maximum byte count for glyph instructions
+            coder.readWord(2, false); // maximum number of components for composite glyphs
+            coder.readWord(2, false); // maximum level of recursion
         }
     }
-    private void decodeHMTX(FSCodec coder)
+    private void decodeHMTX(FSCoder coder)
     {
         int i = 0;
         
         for (i=0; i<attributes[NUMBER_OF_METRICS]; i++) 
         {
-            glyphTable[i].advance = (coder.readShort(false) / attributes[SCALE]);
-            coder.readShort(true); // left side bearing
+            glyphTable[i].advance = (coder.readWord(2, false) / attributes[SCALE]);
+            coder.readWord(2, true); // left side bearing
         }
         
         int advance = glyphTable[i-1].advance;
@@ -1422,14 +1422,14 @@
             glyphTable[i].advance = advance;
 
         for (; i<numberOfGlyphs; i++)
-            coder.readShort(true);
+            coder.readWord(2, true);
     }
-    private void decodeCMAP(FSCodec coder)
+    private void decodeCMAP(FSCoder coder)
     {
         int tableStart = coder.getPointer();
         
-        int version = coder.readShort(false);
-        int numberOfTables = coder.readShort(false);
+        int version = coder.readWord(2, false);
+        int numberOfTables = coder.readWord(2, false);
         
         int platformId = 0;
         int encodingId = 0;
@@ -1452,9 +1452,9 @@
         
         for (i=0; i<numberOfTables; i++)
         {
-            platformId = coder.readShort(false);
-            encodingId = coder.readShort(false);
-            offset = coder.readInt() << 3;
+            platformId = coder.readWord(2, false);
+            encodingId = coder.readWord(2, false);
+            offset = coder.readWord(4, false) << 3;
             current = coder.getPointer();
             
             if (platformId == 0) // Unicode
@@ -1482,22 +1482,22 @@
 
             coder.setPointer(tableStart+offset);
             
-            format = coder.readShort(false);
-            length = coder.readShort(false);
-            language = coder.readShort(false);
+            format = coder.readWord(2, false);
+            length = coder.readWord(2, false);
+            language = coder.readWord(2, false);
             
             switch (format) 
             {
                 case 0: 
                     for (n=0; n<256; n++)
-                        characterTable[n] = (short)coder.readByte();
+                        characterTable[n] = (short)coder.readWord(1, false);
                     break;
                 case 4:
-                    segmentCount = coder.readShort(false) / 2;
+                    segmentCount = coder.readWord(2, false) / 2;
     
-                    coder.readShort(false); // search range
-                    coder.readShort(false); // entry selector
-                    coder.readShort(false); // range shift
+                    coder.readWord(2, false); // search range
+                    coder.readWord(2, false); // entry selector
+                    coder.readWord(2, false); // range shift
 
                     startCount = new int[segmentCount];
                     endCount = new int[segmentCount];
@@ -1506,20 +1506,20 @@
                     rangeAdr = new int[segmentCount];
                     
                     for (n=0; n<segmentCount; n++)
-                        endCount[n] = coder.readShort(false);
+                        endCount[n] = coder.readWord(2, false);
 
-                    coder.readShort(false); // reserved padding
+                    coder.readWord(2, false); // reserved padding
                 
                     for (n=0; n<segmentCount; n++)
-                        startCount[n] = coder.readShort(false);
+                        startCount[n] = coder.readWord(2, false);
                 
                     for (n=0; n<segmentCount; n++)
-                        delta[n] = coder.readShort(true);
+                        delta[n] = coder.readWord(2, true);
                 
                     for (n=0; n<segmentCount; n++)
                     {
                         rangeAdr[n] = coder.getPointer() >> 3;
-                        range[n] = coder.readShort(true);
+                        range[n] = coder.readWord(2, true);
                     }
 
                     int glyphIndex = 0;
@@ -1533,7 +1533,7 @@
                             {
                                 location = rangeAdr[n] + range[n] + ((code - startCount[n]) << 1);
                                 coder.setPointer(location << 3);
-                                glyphIndex = coder.readShort(false);
+                                glyphIndex = coder.readWord(2, false);
                                 
                                 if (glyphIndex != 0)
                                     glyphIndex = (glyphIndex + delta[n]) % 65536;
@@ -1557,7 +1557,7 @@
         }
         encoding = FSText.SJIS;
     }
-    private void decodeGlyphs(FSCodec coder, int glyfOffset)
+    private void decodeGlyphs(FSCoder coder, int glyfOffset)
     {
         int numberOfContours = 0;
         int glyphStart = 0;
@@ -1566,16 +1566,16 @@
         int[] offsets = new int[numberOfGlyphs];
         
         if (attributes[GLYPH_OFFSET_SIZE] == ITLF_SHORT)
-            offsets[0] = glyfOffset + (coder.readShort(false)*2 << 3);
+            offsets[0] = glyfOffset + (coder.readWord(2, false)*2 << 3);
         else
-            offsets[0] = glyfOffset + (coder.readInt() << 3);
+            offsets[0] = glyfOffset + (coder.readWord(4, false) << 3);
 
         for (int i=1; i<numberOfGlyphs; i++)
         {
             if (attributes[GLYPH_OFFSET_SIZE] == ITLF_SHORT)
-                offsets[i] = glyfOffset + (coder.readShort(false)*2 << 3);
+                offsets[i] = glyfOffset + (coder.readWord(2, false)*2 << 3);
             else
-                offsets[i] = glyfOffset + (coder.readInt() << 3);
+                offsets[i] = glyfOffset + (coder.readWord(4, false) << 3);
             
             if (offsets[i] == offsets[i-1])
                 offsets[i-1] = 0;
@@ -1593,7 +1593,7 @@
             {
                 coder.setPointer(offsets[i]);
                 
-                numberOfContours = coder.readShort(true);
+                numberOfContours = coder.readWord(2, true);
                 
                 if (numberOfContours >= 0)
                     decodeSimpleGlyph(coder, i, numberOfContours);
@@ -1608,29 +1608,29 @@
             {
                 coder.setPointer(offsets[i]);
             
-                if (coder.readShort(true) == -1)
+                if (coder.readWord(2, true) == -1)
                     decodeCompositeGlyph(coder, i);
             }
         }
         coder.setPointer(end);
     }
-    private void decodeSimpleGlyph(FSCodec coder, int glyphIndex, int numberOfContours)
+    private void decodeSimpleGlyph(FSCoder coder, int glyphIndex, int numberOfContours)
     {
-        int xMin = coder.readShort(true) / attributes[SCALE];
-        int yMin = coder.readShort(true) / attributes[SCALE];
-        int xMax = coder.readShort(true) / attributes[SCALE];
-        int yMax = coder.readShort(true) / attributes[SCALE];
+        int xMin = coder.readWord(2, true) / attributes[SCALE];
+        int yMin = coder.readWord(2, true) / attributes[SCALE];
+        int xMax = coder.readWord(2, true) / attributes[SCALE];
+        int yMax = coder.readWord(2, true) / attributes[SCALE];
         
         int[] endPtsOfContours = new int[numberOfContours];
 
         for (int i=0; i<numberOfContours; i++)
-            endPtsOfContours[i] = coder.readShort(false);
+            endPtsOfContours[i] = coder.readWord(2, false);
 
-        int instructionCount = coder.readShort(false);   
+        int instructionCount = coder.readWord(2, false);   
         int[] instructions = new int[instructionCount];
             
         for (int i=0; i<instructionCount; i++)
-            instructions[i] = coder.readByte();
+            instructions[i] = coder.readWord(1, false);
                 
         int numberOfPoints = (numberOfContours == 0) ? 0 : endPtsOfContours[endPtsOfContours.length-1]+1;
         
@@ -1651,11 +1651,11 @@
             } 
             else 
             {
-                flags[i] = coder.readByte();
+                flags[i] = coder.readWord(1, false);
                     
                 if ((flags[i] & REPEAT_FLAG) > 0) 
                 {
-                    repeatCount = coder.readByte();
+                    repeatCount = coder.readWord(1, false);
                     repeatFlag = flags[i];
                 }
             }
@@ -1669,16 +1669,16 @@
             if ((flags[i] & X_SHORT) > 0) 
             {
                 if ((flags[i] & X_POSITIVE) > 0)
-                    last = xCoordinates[i] = last + coder.readByte();
+                    last = xCoordinates[i] = last + coder.readWord(1, false);
                 else 
-                    last = xCoordinates[i] = last - coder.readByte();
+                    last = xCoordinates[i] = last - coder.readWord(1, false);
             } 
             else 
             {
                 if ((flags[i] & X_SAME) > 0)
                     last = xCoordinates[i] = last;
                 else
-                    last = xCoordinates[i] = last + coder.readShort(true);
+                    last = xCoordinates[i] = last + coder.readWord(2, true);
             }
         }
 
@@ -1689,16 +1689,16 @@
             if ((flags[i] & Y_SHORT) > 0)
             {
                 if ((flags[i] & Y_POSITIVE) > 0)
-                    last = yCoordinates[i] = last + coder.readByte();
+                    last = yCoordinates[i] = last + coder.readWord(1, false);
                 else 
-                    last = yCoordinates[i] = last - coder.readByte();
+                    last = yCoordinates[i] = last - coder.readWord(1, false);
             } 
             else 
             {
                 if ((flags[i] & Y_SAME) > 0)
                     last = yCoordinates[i] = last;
                 else 
-                    last = yCoordinates[i] = last + coder.readShort(true);
+                    last = yCoordinates[i] = last + coder.readWord(2, true);
             }
         }
             
@@ -1780,15 +1780,15 @@
         glyphTable[glyphIndex].onCurve = onCurve;
         glyphTable[glyphIndex].endPoints = endPtsOfContours;
     }
-      private void decodeCompositeGlyph(FSCodec coder, int glyphIndex)
+      private void decodeCompositeGlyph(FSCoder coder, int glyphIndex)
     {
         FSShape shape = new FSShape();
         FSCoordTransform transform = null;
                         
-        int xMin = coder.readShort(true);
-        int yMin = coder.readShort(true);
-        int xMax = coder.readShort(true);
-        int yMax = coder.readShort(true);
+        int xMin = coder.readWord(2, true);
+        int yMin = coder.readWord(2, true);
+        int xMax = coder.readWord(2, true);
+        int yMax = coder.readWord(2, true);
         
         FSGlyph points = null;
         
@@ -1811,8 +1811,8 @@
         do {
             transform = new FSCoordTransform();
             
-            flags = coder.readShort(false);
-            sourceGlyph = coder.readShort(false);
+            flags = coder.readWord(2, false);
+            sourceGlyph = coder.readWord(2, false);
             
             if (sourceGlyph >= glyphTable.length || glyphTable[sourceGlyph] == null)
             {
@@ -1846,8 +1846,8 @@
             
             if ((flags & ARG_1_AND_2_ARE_WORDS) == 0 && (flags & ARGS_ARE_XY_VALUES) == 0)
             {
-                destIndex = coder.readByte();
-                sourceIndex = coder.readByte();
+                destIndex = coder.readWord(1, false);
+                sourceIndex = coder.readWord(1, false);
                 
                 //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
                 //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
@@ -1855,14 +1855,14 @@
             }
             else if ((flags & ARG_1_AND_2_ARE_WORDS) == 0 && (flags & ARGS_ARE_XY_VALUES) > 0)
             {
-                xOffset = (coder.readByte() << 24) >> 24;
-                yOffset = (coder.readByte() << 24) >> 24;
+                xOffset = (coder.readWord(1, false) << 24) >> 24;
+                yOffset = (coder.readWord(1, false) << 24) >> 24;
                 transform.translate(xOffset, yOffset);
             }
             else if ((flags & ARG_1_AND_2_ARE_WORDS) > 0 && (flags & ARGS_ARE_XY_VALUES) == 0)
             {
-                destIndex = coder.readShort(false);
-                sourceIndex = coder.readShort(false);
+                destIndex = coder.readWord(2, false);
+                sourceIndex = coder.readWord(2, false);
                 
                 //xCoordinates[destIndex] = glyphTable[sourceGlyph].xCoordinates[sourceIndex];
                 //yCoordinates[destIndex] = glyphTable[sourceGlyph].yCoordinates[sourceIndex];
@@ -1870,8 +1870,8 @@
             }
             else
             {
-                xOffset = coder.readShort(true);
-                yOffset = coder.readShort(true);
+                xOffset = coder.readWord(2, true);
+                yOffset = coder.readWord(2, true);
                 transform.translate(xOffset, yOffset);
             }
             



From denis_bohm at berlios.de  Sun Feb 26 23:36:42 2006
From: denis_bohm at berlios.de (denis_bohm at berlios.de)
Date: Sun, 26 Feb 2006 23:36:42 +0100
Subject: [Transform-svn] r88 - trunk/doc
Message-ID: <200602262236.k1QMag66013601@sheep.berlios.de>

Author: denis_bohm
Date: 2006-02-26 23:36:37 +0100 (Sun, 26 Feb 2006)
New Revision: 88

Modified:
   trunk/doc/CHANGES.txt
Log:
Add comments for changes made on 2006-02-17.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-26 17:14:50 UTC (rev 87)
+++ trunk/doc/CHANGES.txt	2006-02-26 22:36:37 UTC (rev 88)
@@ -122,6 +122,20 @@
     * Updated the README.txt file with information on running tests using
       FSMovieTest.
 
+2006-02-17 - denis at fireflydesign.com
+
+    * Fixed text bounding box calculation in FSTextConstructor.
+
+    * Fixed clipping depth off by one problem in FSPlaceObject2.
+
+    * Removed extra line segment in FSImageConstructor.defineEnclosingShape
+      that caused very strange drawing behavior when rotating.
+
+    * Added an new constructor to FSSoundConstructor to can be used when you
+      want to set the sound data (rather than load it).
+
+    * Fixed array out of bounds problem in FSCodec.
+
 2006-02-12 - smackay at flagstonesoftware.com
 
     * Started adding code and testng suites for testing the framework and 



From smackay at berlios.de  Tue Feb 28 14:20:51 2006
From: smackay at berlios.de (smackay at berlios.de)
Date: Tue, 28 Feb 2006 14:20:51 +0100
Subject: [Transform-svn] r89 - in trunk: doc src/com/flagstone/transform/test src/com/flagstone/transform/util test/suites
Message-ID: <200602281320.k1SDKpsR026988@sheep.berlios.de>

Author: smackay
Date: 2006-02-28 14:20:03 +0100 (Tue, 28 Feb 2006)
New Revision: 89

Added:
   trunk/src/com/flagstone/transform/util/FSCharacterTable.java
Modified:
   trunk/doc/CHANGES.txt
   trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
   trunk/src/com/flagstone/transform/util/FSTextConstructor.java
   trunk/test/suites/FSTextConstructor.xml
Log:
Added FSTextConstructor.willDisplay(char[]) to allow sets of 
characters to be defined before creating any test objects. This 
solves the bug where characters were encoded in the order they were 
used but not in ascending order of character code.
      
Added FSCharacterTable class to com.flagstone.transform.util to 
provide predefined sets of characters to use with the willDisplay() 
method.
      
Added a corresponding canDisplay(char[]) method to see if a font 
can display all of the characters in a set.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2006-02-26 22:36:37 UTC (rev 88)
+++ trunk/doc/CHANGES.txt	2006-02-28 13:20:03 UTC (rev 89)
@@ -1,3 +1,18 @@
+2006-02-27 - smackay at flagstonesoftware.com
+
+    * Added FSTextConstructor.willDisplay(char[]) to allow sets of characters
+      to be defined before creating any test objects. This solves the bug where
+      characters were encoded in the order they were used but not in ascending
+      order of character code.
+      
+      Added FSCharacterTable class to com.flagstone.transform.util to provide
+      predefined sets of characters to use with the willDisplay() method.
+      
+      Added a corresponding canDisplay(char[]) method to see if a font can 
+      display all of the characters in a set.
+      
+    * Updated FSTextConstructor test to include the new willDisplay method.
+
 2006-02-26 - smackay at flagstonesoftware.com
 
     * Tidied up the FSCoder class, making all methods more reliable merging in
@@ -4,8 +19,7 @@
       functionality from Transform Utilities FSCodec. All decoding and encoding 
       of data is now performed using FSCoder. FSCodec is deprecated.
       
-    * The class TransformUtil is now deprecated.
-    
+    * The class TransformUtil is now deprecated.  
 
 2006-02-25 - smackay at flagstonesoftware.com
 

Modified: trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2006-02-26 22:36:37 UTC (rev 88)
+++ trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2006-02-28 13:20:03 UTC (rev 89)
@@ -75,6 +75,50 @@
         }
     }
     /**
+     * @testng.test dataProvider="character-sets"
+     */
+    public void displayCharacterSets(Integer code, String name)
+    {
+        try 
+        {
+            File destFile = new File(destDir, name+".swf");
+            
+            FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
+         
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            encodeCharacterSet(textGenerator, 
+                FSCharacterTable.characterSet(code.intValue()), destFile);
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+    /**
+     * @testng.test dataProvider="locales"
+     */
+    public void displayLocales(Locale locale, String name)
+    {
+        try 
+        {
+            File destFile = new File(destDir, name+".swf");
+            
+            FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
+         
+            if (destDir.exists() == false)
+                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+            
+            encodeCharacterSet(textGenerator, 
+                FSCharacterTable.characterSetForLocale(locale), destFile);
+        }
+        catch (Exception e)
+        {
+            assert false;
+        }
+    }
+    /**
      * @testng.data-provider name="files"
      */
     public Object[][] findFiles()
@@ -103,6 +147,38 @@
         
         return parameters;
     }
+    /**
+     * @testng.data-provider name="character-sets"
+     */
+    public Object[][] characterSets()
+    {
+        Object[][] parameters = new Object[][] {
+            new Object[] { new Integer(FSCharacterTable.euro), "euro" },                       
+            new Object[] { new Integer(FSCharacterTable.iso_646), "iso-646" },                       
+            new Object[] { new Integer(FSCharacterTable.iso_8859_1), "iso-8859-1" },                       
+        };
+        
+        return parameters;
+    }
+    /**
+     * @testng.data-provider name="locales"
+     */
+    public Object[][] locales()
+    {
+        Object[][] parameters = new Object[][] {
+            new Object[] { new Locale("de", "DE"), "de_DE" },                       
+            new Object[] { new Locale("dk", "DK"), "dk_DK" },                       
+            new Object[] { new Locale("en", "GB"), "en_GB" },                       
+            new Object[] { new Locale("en", "UK"), "en_UK" },                       
+            new Object[] { new Locale("en", "US"), "en_US" },                       
+            new Object[] { new Locale("es", "ES"), "es_ES" },                       
+            new Object[] { new Locale("fi", "FI"), "fi_FI" },                       
+            new Object[] { new Locale("fr", "FR"), "fr_FR" },                       
+            new Object[] { new Locale("pt", "PT"), "pt_PT" },                       
+        };
+        
+        return parameters;
+    }
       
     private void encodeFontToFile(FSTextConstructor textGenerator, File file) throws Exception
     {
@@ -145,4 +221,55 @@
 
         movie.encodeToFile(file.getPath());
     }
+    private void encodeCharacterSet(FSTextConstructor textGenerator, char[] chars, File file) throws Exception
+    {
+        int fontSize = 280;
+        int lineSpacing = fontSize;        
+        int margin = fontSize;
+        int charsPerline = 32;
+                
+        FSMovie movie = new FSMovie();
+        ArrayList lines = new ArrayList();
+        
+        char c = 0;
+
+        StringBuffer line = new StringBuffer();
+
+        for (int i=0; i<chars.length; i++)
+        {
+            line.append(chars[i]);
+
+            if (i % charsPerline == charsPerline-1)
+            {
+                lines.add(line.toString());
+                line = new StringBuffer();
+            }
+        }
+        
+        if (line.length() > 0)
+            lines.add(line.toString());
+            
+        
+        int fontId = movie.newIdentifier();
+        
+        textGenerator.willDisplay(chars);
+        
+        FSDefineFont2 font = textGenerator.defineFont();
+        FSDefineText2 text = textGenerator.defineTextBlock(movie.newIdentifier(), lines, fontSize, FSColorTable.black(), lineSpacing);
+        
+        font.setIdentifier(fontId);
+
+        int screenWidth = text.getBounds().getWidth() + margin + margin;
+        int screenHeight = text.getBounds().getHeight() + margin + margin;
+            
+        movie.setFrameSize(new FSBounds(0, 0, screenWidth, screenHeight));
+        movie.setFrameRate(1.0f);
+        movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
+        movie.add(font);
+        movie.add(text);
+        movie.add(new FSPlaceObject2(text.getIdentifier(), 1, margin , margin));
+        movie.add(new FSShowFrame());
+
+        movie.encodeToFile(file.getPath());
+    }
 }

Added: trunk/src/com/flagstone/transform/util/FSCharacterTable.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSCharacterTable.java	2006-02-26 22:36:37 UTC (rev 88)
+++ trunk/src/com/flagstone/transform/util/FSCharacterTable.java	2006-02-28 13:20:03 UTC (rev 89)
@@ -0,0 +1,576 @@
+/*
+ *  FSCharacterTable.java
+ *  Transform Utilities
+ *
+ * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
+ *    may be used to endorse or promote products derived from this software 
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.flagstone.transform.util;
+
+import java.util.Locale;
+
+/**
+ * The FSCharacterTable class provides predefined arrays of characters that can
+ * be used with the FSTextConstructor's willDisplay() method to predefine the 
+ * characters that will be displayed using a given font.
+ * 
+ * Character sets are simply list of characters to use. The names used to 
+ * identify collections of characters use official character set names, such
+ * as iso_8859_1. However they do NOT indicate how the characters are encoded
+ * as such (all strings are encoded using UTF-8) they are simply a way of 
+ * naming a group of characters in a recognized (and standard) way.
+ * 
+ * Other sets that use characters appropriate for a specific country and 
+ * language also use ISO designations for a specific locale such as en_US
+ * or pt_BR.
+ *
+ */
+public class FSCharacterTable 
+{
+    /*
+     * List of character sets supported. 
+     */
+    
+    /**
+     * Code identifying a set containing the single character for the euro
+     * currency symbol. It is included as a separate set as manly formal 
+     * coded character sets do not include it. A separate set makes it easier
+     * to match different sets of characters together.
+     * 
+     * The (Unicode) character code for this symbol is 0x20AC so it will
+     * typically be the last character set passed to the FSTextConstructor's
+     * willDisplay() method.
+     */
+    public static final int euro = 0;
+    /**
+     * Code identifying formal the characters defined in ISO 646.
+     * 
+     * Alias: ASCII
+     */
+    public static final int iso_646 = 1;
+    /**
+     * Code identifying formal the characters defined in ISO-8859-1.
+     * 
+     * Alias: Latin-1
+     */
+    public static final int iso_8859_1 = 2;
+    
+    /*
+     * The ISO 646 character set is used as a base for other characters sets.
+     * Other character sets are created by including these characters in the 
+     * array returned by the characterSetWithCode() method. This saves space
+     * and more importantly makes it easier to correct errors.
+     */
+    private final static char[] iso_646_chars = {
+        '\u0020', // space
+        '\u0021', // exclamation mark
+        '\u0022', // quotation mark
+        '\u0023', // number sign
+        '\u0024', // dollar sign
+        '\u0025', // percent sign
+        '\u0026', // ampersand
+        '\'',     // apostrophe
+        '\u0028', // left parenthesis
+        '\u0029', // right parenthesis
+        '\u002A', // asterisk
+        '\u002B', // plus sign
+        '\u002C', // comma
+        '\u002D', // hyphen or minus
+        '\u002E', // full stop
+        '\u002F', // forward slash
+        '\u0030', // digit zero
+        '\u0031', // digit one
+        '\u0032', // digit two
+        '\u0033', // digit three
+        '\u0034', // digit four
+        '\u0035', // digit five
+        '\u0036', // digit six
+        '\u0037', // digit seven
+        '\u0038', // digit eight
+        '\u0039', // digit nine
+        '\u003A', // colon
+        '\u003B', // semicolon
+        '\u003C', // less than sign
+        '\u003D', // equals sign
+        '\u003E', // greater than sign
+        '\u003F', // question mark
+        '\u0040', // commercial at
+        '\u0041', // upper case A
+        '\u0042', // upper case B
+        '\u0043', // upper case C
+        '\u0044', // upper case D
+        '\u0045', // upper case E
+        '\u0046', // upper case F
+        '\u0047', // upper case G
+        '\u0048', // upper case H
+        '\u0049', // upper case I
+        '\u004A', // upper case J
+        '\u004B', // upper case K
+        '\u004C', // upper case L
+        '\u004D', // upper case M
+        '\u004E', // upper case N
+        '\u004F', // upper case O
+        '\u0050', // upper case P
+        '\u0051', // upper case Q
+        '\u0052', // upper case R
+        '\u0053', // upper case S
+        '\u0054', // upper case T
+        '\u0055', // upper case U
+        '\u0056', // upper case V
+        '\u0057', // upper case W
+        '\u0058', // upper case X
+        '\u0059', // upper case Y
+        '\u005A', // upper case Z
+        '\u005B', // left square bracket
+        '\\',     // backslash
+        '\u005D', // right square bracket
+        '\u005E', // circumflex
+        '\u005F', // underscore
+        '\u0060', // grave
+        '\u0061', // lower case A
+        '\u0062', // lower case B
+        '\u0063', // lower case C
+        '\u0064', // lower case D
+        '\u0065', // lower case E
+        '\u0066', // lower case F
+        '\u0067', // lower case G
+        '\u0068', // lower case H
+        '\u0069', // lower case I
+        '\u006A', // lower case J
+        '\u006B', // lower case K
+        '\u006C', // lower case L
+        '\u006D', // lower case M
+        '\u006E', // lower case N
+        '\u006F', // lower case O
+        '\u0070', // lower case P
+        '\u0071', // lower case Q
+        '\u0072', // lower case R
+        '\u0073', // lower case S
+        '\u0074', // lower case T
+        '\u0075', // lower case U
+        '\u0076', // lower case V
+        '\u0077', // lower case W
+        '\u0078', // lower case X
+        '\u0079', // lower case Y
+        '\u007A', // lower case Z
+        '\u007B', // left curly bracket
+        '\u007C', // vertical line
+        '\u007D', // right curly bracket
+        '\u007E', // tilde
+    };
+    
+    private static final char[] iso_8859_1_chars = new char[] {
+        '\u00A0', // non-breaking space
+        '\u00A1', // inverted exclamation mark
+        '\u00A2', // cent sign
+        '\u00A3', // pound sign
+        '\u00A4', // currency sign
+        '\u00A5', // yen sign
+        '\u00A6', // broken BAR
+        '\u00A7', // section sign
+        '\u00A8', // diaresis
+        '\u00A9', // copyright sign
+        '\u00AA', // feminine ordinal indicator
+        '\u00AB', // left pointing double angle quotation mark
+        '\u00AC', // not sign
+        '\u00AD', // soft hyphen
+        '\u00AE', // registered trademark sign
+        '\u00AF', // macron
+        '\u00B0', // degree sign
+        '\u00B1', // plus-minus sign
+        '\u00B2', // superscript two
+        '\u00B3', // superscript three
+        '\u00B4', // acute accent
+        '\u00B5', // micro sign
+        '\u00B6', // pilcrow sign
+        '\u00B7', // middle dot
+        '\u00B8', // cedilla
+        '\u00B9', // superscript ONE
+        '\u00BA', // masculine ordinal indicator
+        '\u00BB', // right pointing double angle quotation mark
+        '\u00BC', // vulgar fraction one quarter
+        '\u00BD', // vulgar fraction one half
+        '\u00BE', // vulgar fraction three quarters
+        '\u00BF', // inverted question mark
+        '\u00C0', // upper case letter A with grave
+        '\u00C1', // upper case letter A with acute
+        '\u00C2', // upper case letter A with circumflex
+        '\u00C3', // upper case letter A with tilde
+        '\u00C4', // upper case letter A with diaresis
+        '\u00C5', // upper case letter A with ring above
+        '\u00C6', // upper case letter AE
+        '\u00C7', // upper case letter C with cedilla
+        '\u00C8', // upper case letter E with grave
+        '\u00C9', // upper case letter E with acute
+        '\u00CA', // upper case letter E with circumflex
+        '\u00CB', // upper case letter E with diaresis
+        '\u00CC', // upper case letter I with grave
+        '\u00CD', // upper case letter I with acute
+        '\u00CE', // upper case letter I with circumflex
+        '\u00CF', // upper case letter I with diaresis
+        '\u00D0', // upper case letter Eth (Icelandic)
+        '\u00D1', // upper case letter N with tilde
+        '\u00D2', // upper case letter O with grave
+        '\u00D3', // upper case letter O with acute
+        '\u00D4', // upper case letter O with circumflex
+        '\u00D5', // upper case letter O with tilde
+        '\u00D6', // upper case letter O with diaresis
+        '\u00D7', // multiplication sign
+        '\u00D8', // upper case letter O with stroke
+        '\u00D9', // upper case letter U with grave
+        '\u00DA', // upper case letter U with acute
+        '\u00DB', // upper case letter U with circumflex
+        '\u00DC', // upper case letter U with diaresis
+        '\u00DD', // upper case letter Y with acute
+        '\u00DE', // upper case letter Thorn (Icelandic)
+        '\u00DF', // lower case letter Sharp S (German)
+        '\u00E0', // lower case letter A with grave
+        '\u00E1', // lower case letter A with acute
+        '\u00E2', // lower case letter A with circumflex
+        '\u00E3', // lower case letter A with tilde
+        '\u00E4', // lower case letter A with diaresis
+        '\u00E5', // lower case letter A with ring above
+        '\u00E6', // lower case letter AE
+        '\u00E7', // lower case letter C with cedilla
+        '\u00E8', // lower case letter E with grave
+        '\u00E9', // lower case letter E with acute
+        '\u00EA', // lower case letter E with circumflex
+        '\u00EB', // lower case letter E with diaresis
+        '\u00EC', // lower case letter I with grave
+        '\u00ED', // lower case letter I with acute
+        '\u00EE', // lower case letter I with circumflex
+        '\u00EF', // lower case letter I with diaresis
+        '\u00F0', // lower case letter Eth (Icelandic)
+        '\u00F1', // lower case letter N with tilde
+        '\u00F2', // lower case letter O with grave
+        '\u00F3', // lower case letter O with acute
+        '\u00F4', // lower case letter O with circumflex
+        '\u00F5', // lower case letter O with tilde
+        '\u00F6', // lower case letter O with diaresis
+        '\u00F7', // division sign
+        '\u00F8', // lower case letter O with stroke
+        '\u00F9', // lower case letter U with grave
+        '\u00FA', // lower case letter U with acute
+        '\u00FB', // lower case letter U with circumflex
+        '\u00FC', // lower case letter U with diaresis
+        '\u00FD', // lower case letter Y with acute
+        '\u00FE', // lower case letter Thorn (Icelandic)
+        '\u00FF', // lower case letter Y with diaresis
+    };
+
+    private final static char[] euroChar = { 
+        '\u20AC', // Euro currency symbol
+    };
+    
+    private final static char[] de_DE = {
+        '\u00A2', // cent sign
+        '\u00C1', // upper case letter A with acute
+        '\u00D6', // upper case letter O with diaresis
+        '\u00DC', // upper case letter U with diaresis
+        '\u00DF', // lower case letter Sharp S (German)
+        '\u00E1', // lower case letter A with acute
+        '\u00F6', // lower case letter O with diaresis
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] dk_DK = {
+        '\u00C5', // upper case letter A with ring above
+        '\u00C6', // upper case letter AE
+        '\u00D8', // upper case letter O with stroke
+        '\u00E5', // lower case letter A with ring above
+        '\u00E6', // lower case letter AE
+        '\u00F8', // lower case letter O with stroke
+    };
+
+    private final static char[] en_GB = {
+        '\u00A2', // cent sign
+        '\u00A3', // pound sign
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] en_US = {
+    };
+    
+    private final static char[] es_ES = {
+        '\u00A2', // cent sign
+        '\u00C1', // upper case letter A with acute
+        '\u00C9', // upper case letter E with acute
+        '\u00CD', // upper case letter I with acute
+        '\u00D1', // upper case letter N with tilde
+        '\u00D3', // upper case letter O with acute
+        '\u00DA', // upper case letter U with acute
+        '\u00DC', // upper case letter U with diaresis
+        '\u00E1', // lower case letter A with acute
+        '\u00E9', // lower case letter E with acute
+        '\u00ED', // lower case letter I with acute
+        '\u00F1', // lower case letter N with tilde
+        '\u00F3', // lower case letter O with acute
+        '\u00FA', // lower case letter U with acute
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    /**
+     * TODO Add ?? ?? ?? ??
+     */
+    private final static char[] fi_FI = { 
+        '\u00A2', // cent sign
+        '\u00C5', // upper case letter A with ring above
+        '\u00E5', // lower case letter A with ring above
+        '\u20AC', // Euro currency symbol
+    };
+    
+    /**
+     * TODO Add ? ?
+     */
+    private final static char[] fr_FR = {
+        '\u00A2', // cent sign
+        '\u00C0', // upper case letter A with grave
+        '\u00C2', // upper case letter A with circumflex
+        '\u00C7', // upper case letter C with cedilla
+        '\u00C8', // upper case letter E with grave
+        '\u00C9', // upper case letter E with acute
+        '\u00CA', // upper case letter E with circumflex
+        '\u00CB', // upper case letter E with diaresis
+        '\u00CE', // upper case letter I with circumflex
+        '\u00CF', // upper case letter I with diaresis
+        '\u00D4', // upper case letter O with circumflex
+        '\u00DA', // upper case letter U with acute
+        '\u00DC', // upper case letter U with diaresis
+        '\u00E0', // lower case letter A with grave
+        '\u00E2', // lower case letter A with circumflex
+        '\u00E7', // lower case letter C with cedilla
+        '\u00E8', // lower case letter E with grave
+        '\u00E9', // lower case letter E with acute
+        '\u00EA', // lower case letter E with circumflex
+        '\u00EB', // lower case letter E with diaresis
+        '\u00EE', // lower case letter I with circumflex
+        '\u00EF', // lower case letter I with diaresis
+        '\u00F4', // lower case letter O with circumflex
+        '\u00FA', // lower case letter U with acute
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+    private final static char[] pt_PT = {
+        '\u00A2', // cent sign
+        '\u00C0', // upper case letter A with grave
+        '\u00C1', // upper case letter A with acute
+        '\u00C2', // upper case letter A with circumflex
+        '\u00C3', // upper case letter A with tilde
+        '\u00C7', // upper case letter C with cedilla
+        '\u00C9', // upper case letter E with acute
+        '\u00CA', // upper case letter E with circumflex
+        '\u00CD', // upper case letter I with acute
+        '\u00D3', // upper case letter O with acute
+        '\u00D4', // upper case letter O with circumflex
+        '\u00D5', // upper case letter O with tilde
+        '\u00DA', // upper case letter U with acute
+        '\u00DC', // upper case letter U with diaresis
+        '\u00E0', // lower case letter A with grave
+        '\u00E1', // lower case letter A with acute
+        '\u00E2', // lower case letter A with circumflex
+        '\u00E3', // lower case letter A with tilde
+        '\u00E7', // lower case letter C with cedilla
+        '\u00E9', // lower case letter E with acute
+        '\u00EA', // lower case letter E with circumflex
+        '\u00ED', // lower case letter I with acute
+        '\u00F3', // lower case letter O with acute
+        '\u00F4', // lower case letter O with circumflex
+        '\u00F5', // lower case letter O with tilde
+        '\u00FA', // lower case letter U with acute
+        '\u00FC', // lower case letter U with diaresis
+        '\u20AC', // Euro currency symbol
+    };
+
+/**
+     * Return a predefined set of characters. An integer code is used to select 
+     * the set to avoid possible formatting issues with names of character sets
+     * specified as strings.
+     * 
+     * @param code a predefine constant identifying the character set to 
+     * return.
+     * 
+     * @return an char[] contains all the characters for a given character 
+     * set. If an unknown code is used then an empty array will be returned.
+     */
+    public static final char[] characterSet(int code)
+    {
+        char[] set = new char[0];
+        int index = 0;
+        
+        switch (code)
+        {
+            case euro: set=euroChar; break;
+            case iso_646: set=iso_646_chars; break;
+            case iso_8859_1:
+                set = new char[iso_646_chars.length+iso_8859_1_chars.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<iso_8859_1_chars.length; i++, index++)
+                    set[index] = iso_8859_1_chars[i];
+                 
+                break;
+            default:
+                break;
+        }
+        
+        return set;
+    }
+    /**
+     * Return a character set for a given country and language. This method is
+     * used to generate smaller character sets which will also reduce the size 
+     * of the font definitions.
+     * 
+     * @param a Locale identifying the country and optional language used to 
+     * select a character set.
+     * 
+     * @return an array containing all the characters suitable for display
+     * using the specified country and language.
+     */
+    public static final char[] characterSetForLocale(Locale locale)
+    {
+        char[] set = new char[0];
+        
+        String country = locale.getCountry();
+        String language = locale.getLanguage();
+        
+        int index = 0;
+
+        if (language.equals("de"))
+        {
+            if (country.equals("DE"))
+            {
+                set = new char[iso_646_chars.length+de_DE.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<de_DE.length; i++, index++)
+                    set[index] = de_DE[i];            
+            }
+        }
+        else if (language.equals("dk"))
+        {
+            if (country.equals("DK"))
+            {
+                set = new char[iso_646_chars.length+dk_DK.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<dk_DK.length; i++, index++)
+                    set[index] = dk_DK[i];            
+            }
+        }
+        else if (language.equals("en"))
+        {
+            if (country.equals("US"))
+            {
+                set = new char[iso_646_chars.length+en_US.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<en_US.length; i++, index++)
+                    set[index] = en_US[i];            
+            }
+            else if (country.equals("GB") || country.equals("UK"))
+            {
+                set = new char[iso_646_chars.length+en_GB.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<en_GB.length; i++, index++)
+                    set[index] = en_GB[i];            
+            }
+            else
+            {
+                set = new char[iso_646_chars.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+            }
+        }
+        else if (language.equals("es"))
+        {
+            if (country.equals("ES"))
+            {
+                set = new char[iso_646_chars.length+es_ES.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<es_ES.length; i++, index++)
+                    set[index] = es_ES[i];            
+            }
+        }
+        else if (language.equals("fi"))
+        {
+            if (country.equals("FI"))
+            {
+                set = new char[iso_646_chars.length+fi_FI.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<fi_FI.length; i++, index++)
+                    set[index] = fi_FI[i];            
+            }
+        }
+        else if (language.equals("fr"))
+        {
+            if (country.equals("FR"))
+            {
+                set = new char[iso_646_chars.length+fr_FR.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<fr_FR.length; i++, index++)
+                    set[index] = fr_FR[i];            
+            }
+        }
+        else if (language.equals("pt"))
+        {
+            if (country.equals("PT"))
+            {
+                set = new char[iso_646_chars.length+pt_PT.length];
+                
+                for (int i=0; i<iso_646_chars.length; i++, index++)
+                    set[index] = iso_646_chars[i];
+                
+                for (int i=0; i<pt_PT.length; i++, index++)
+                    set[index] = pt_PT[i];            
+            }
+        }
+        return set;
+    }
+
+}

Modified: trunk/src/com/flagstone/transform/util/FSTextConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2006-02-26 22:36:37 UTC (rev 88)
+++ trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2006-02-28 13:20:03 UTC (rev 89)
@@ -41,8 +41,8 @@
 import java.util.zip.*;
 
 /**
- * The FSTextConstructor class greatly simplifies the use of fonts and text when creating
- * Flash files. Font definitions can be created in three ways:
+ * The FSTextConstructor class greatly simplifies the use of fonts and text when 
+ * creating Flash files. Font definitions can be created in three ways:
  * 
  * <ol>
  * <li>Using TrueType or OpenType font definition stored in a file.</li>
@@ -50,8 +50,8 @@
  * <li>Using a given Java AWT font as a template.</li>
  * </ol>
  * 
- * <P>Font definitions from TrueType, OpenType or Flash files are created by specifying the 
- * name of the file:</p>
+ * <P>Font definitions from TrueType, OpenType or Flash files are created by 
+ * specifying the name of the file:</p>
  * 
  * <pre>
  *     FSTextConstructor font = new FSTextConstructor(identifier, "Arial.otf");
@@ -60,27 +60,30 @@
  *     FSTextConstructor font = new FSTextConstructor(identifier, "TimesNewRoman.swf");
  * </pre>
  * 
- * <P>The OpenType or TrueType file is parsed to construct the font definition. File with the
- * extensions ".otf" or ".ttf" may be used. Files containing collections of fonts ".otc" are 
- * not currently supported. For Flash files the first font definition encountered is used and 
- * all the text definition objects associated with the font are used to obtain the advance 
- * information for each character. An example Flash file can be found in the resources directory 
+ * <P>The OpenType or TrueType file is parsed to construct the font definition. 
+ * Files with the extensions ".otf" or ".ttf" may be used. Files containing 
+ * collections of fonts ".otc" are not currently supported. For Flash files the 
+ * first font definition encountered is used and all the text definition objects 
+ * associated with the font are used to obtain the advance information for each 
+ * character. An example Flash file can be found in the resources directory 
  * included in this release.</p>
  * 
- * <P>Font definitions from AWT templates are created by specifying the name of the font:</p>
+ * <P>Font definitions from AWT templates are created by specifying the name of 
+ * the font:</p>
  * 
  * <pre>
  *     FSTextConstructor font = new FSTextConstructor(identifier, "Times New Roman Bold");
  * </pre>
  * 
- * <p>Only the font or file name needs to specified. Unlike Java fonts, font definitions in
- * Flash are size  independent, the size and colour in which a given string in rendered
- * is specified in the object  that defines the text to be displayed avoiding the need
- * to create multiple font definitions for  the same font name.</p>
+ * <p>Only the font or file name needs to specified. Unlike Java fonts, font 
+ * definitions in Flash are size  independent, the size and colour in which a 
+ * given string in rendered is specified in the object  that defines the text to 
+ * be displayed avoiding the need to create multiple font definitions for  the 
+ * same font name.</p>
  *
- * <P>An array of FSGlyph objects are created from the font definition. Each object 
- * contains the glyph for the font, the associated character code and information used to
- * lay out each glyph when it is displayed.</P>
+ * <P>An array of FSGlyph objects are created from the font definition. Each 
+ * object contains the glyph for the font, the associated character code and 
+ * information used to lay out each glyph when it is displayed.</P>
  * 
  * <P>Once a font has been created text strings can be generated:</p>
  * 
@@ -90,45 +93,50 @@
  *    FSDefineText2 aString = font.defineText("This is a string", fontSize, fontColor);
  * </pre>
  * 
- * <P>The defineText method returns FSDefineText2 objects since they support transparent
- * colours, while FSDefineText only supports opaque colours.</P>
+ * <P>The defineText method returns FSDefineText2 objects since they support 
+ * transparent colours, while FSDefineText only supports opaque colours.</P>
  *
- * <P>Once all the strings to be displayed have been generated the font definition object 
- * containing the glyphs can be generated.</p>
+ * <P>Once all the strings to be displayed have been generated the font 
+ * definition object containing the glyphs can be generated.</p>
  * 
  * <pre>
  *    FSDefineFont2 defineFont = font.defineFont();
  * </pre>
  * 
- * <P>Remember however that objects in a Flash file must be defined before they are used so
- * the font object must be added to the file before the first FSDefineText object that
- * references the glyphs in the font.</p>
+ * <P>Remember however that objects in a Flash file must be defined before they 
+ * are used so the font object must be added to the file before the first 
+ * FSDefineText object that references the glyphs in the font.</p>
  * 
- * <P>To reduce the size of the Flash file only the glyphs actually displayed can be included
- * in a font definition object. When a FSDefineText object is created the glyphs used are 
- * marked. This is why the text definition objects are generated before the font definition.</P>
+ * <P>To reduce the size of the Flash file only the glyphs actually displayed 
+ * can be included in a font definition object. When a FSDefineText object is 
+ * created the glyphs used are marked. This is why the text definition objects 
+ * are generated before the font definition.</P>
  *
- * <P>Glyphs are included in the font in the order they are used with each FSDefineText2 object 
- * referencing a glyph by its position in the array of glyphs contained in a font definition.
- * Any unused glyphs can then easily be omitted.</P>
+ * <P>Glyphs are included in the font in the order they are used with each 
+ * FSDefineText2 object referencing a glyph by its position in the array of 
+ * glyphs contained in a font definition. Any unused glyphs can then easily be 
+ * omitted.</P>
  * 
- * <P>When the font definition is created only the glyphs used (up to that point) are included. 
- * If subsequent FSDefineText objects are generated that include glyphs not previously used then 
- * the text will not be displayed correctly.</p>
+ * <P>When the font definition is created only the glyphs used (up to that 
+ * point) are included. If subsequent FSDefineText objects are generated that 
+ * include glyphs not previously used then the text will not be displayed 
+ * correctly.</p>
  *
  * <b>Text Fields</b><br/>
  *
- * <P>When creating text fields using the FSDefineTextField class, there are two options when 
- * specifying the font used to display the characters entered into the field:
+ * <P>When creating text fields using the FSDefineTextField class, there are two 
+ * options when specifying the font used to display the characters entered into 
+ * the field:
  *
  * <ol>
  * <li>The glyphs for the font may be loaded from the host platform.</li>
  * <li>The glyphs for the font are taken from a font definition object.</li>
  * </ol>
  *
- * <P>Using the glyphs loaded from the host platform is by far the easiest way of using text fields.
- * First a font definition is created that specifies only the name of the font which will be loaded
- * from the host platform. Then creating the text fields set the useFontGlyphs attribute to false.</P>
+ * <P>Using the glyphs loaded from the host platform is by far the easiest way 
+ * of using text fields. First a font definition is created that specifies only 
+ * the name of the font which will be loaded from the host platform. Then 
+ * creating the text fields set the useFontGlyphs attribute to false.</P>
  *
  * <pre>
  *    FSDefineFont2 fontDefinition = new FSDefineFont2(movie.newIdentifier(), "Arial");
@@ -138,64 +146,48 @@
  *    textField.setUseFontGlyphs(false);
  * </pre>
  *
- * <P>This approach only works if the font is defined on the host platform otherwise the Flash Player
- * will substitute a default font.</P>
+ * <P>This approach only works if the font is defined on the host platform 
+ * otherwise the Flash Player will substitute a default font.</P>
  *
- * <P>When using a font definition contained in the Flash file obviously the glyphs for all possible 
- * characters must be defined otherwise the character will not be displayed correctly. There are 
- * two ways to do this, either generate FSDefineText objects which contain all possible characters
- * (the object need not be added to the Flash file)</P>
- *
+ * <P>When using a font definition contained in the Flash file obviously the 
+ * glyphs for all possible characters must be defined otherwise the character 
+ * will not be displayed correctly. When using text fields the characters must 
+ * be defined in the font, sorted by ascending character code, otherwise the
+ * text will not be displayed correctly. To do this the FSCharacterTable class
+ * provides arrays of characters sorted in the correct order. The array is 
+ * passed to the willDisplay() method and the FSTextConstructor will add the 
+ * glyphs for the characters in the order they appear in the array:</p>
+ * 
  * <pre>
- *    int fontSize = 280;
- *    FSColor fontColor = FSColorTable.black();
- *
- *    String lowerCaseLetters = "abcdefghijklmnopqrstuvwxyz";
- *    String upperCaseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
- *    String numbers = "1234567890";
- *    String everythingElse = "`!@#$%^&*()-=[]\\:\"<>?~_+{}|;',./";
- *
- *    FSDefineText2 aString = null;
- *
- *    font.defineText(lowerCaseLetters, fontSize, fontColor);
- *    font.defineText(upperCaseLetters, fontSize, fontColor);
- *    font.defineText(numbers, fontSize, fontColor);
- *    font.defineText(everythingElse, fontSize, fontColor);
- *
- *    FSDefineFont2 defineFont = font.defineFont();
+ *     char[] characterSet = FSCharacterTable.ascii();
+ *     
+ *     textConstructor.willDisplay(characterSet);
  * </pre>
+ * 
+ * <P>This will add ALL of the characters in the array to the font definition.
+ * Several character sets are provided in the FSCharacterTable class but any 
+ * array of characters could be passed to the willDisplay() method - allowing
+ * smaller font definitions to be created when only a few characters are 
+ * displayed.</p>
  *
- * <p>or alternatively define a range of characters to be included:</p>
- *
- * <pre>
- *     char first = 'a';
- *     char last = 'z';
- *
- *     for (int i=first; i&lt;=last; i++)
- *            font.defineText(new String(i), fontSize, fontColor);
- * </pre>
- *
- * <P>This will include all the glyphs representing the range of characters in the 
- * font definition.</P>
- *
  * <b>Missing Characters</b><br/>
  *
- * <P>Characters that cannot be displayed using the font are handled by a displaying a 
- * default glyph which typically represents a space or an empty box. Both Java AWT and
- * True/Open Type definitions explicitly define the missing glyph. For fonts parsed
- * from Flash files the missing glyph is assumed (by default) to be the first glyph 
- * in the font definition.</p>
+ * <P>Characters that cannot be displayed using the font are handled by a 
+ * displaying a default glyph which typically represents a space or an empty 
+ * box. Both Java AWT and True/Open Type definitions explicitly define the 
+ * missing glyph. For fonts parsed from Flash files the missing glyph is assumed 
+ * (by default) to be the first glyph in the font definition.</p>
  * 
  * <P>When a font is loaded the missing glyph is added automatically to the font 
- * definition so there is no need to explicitly include it by creating a text object
- * to force it to be included. The missing glyph will always be the first glyph in the
- * font definition generated by the FSTextConstructor object so it may be substituted
- * by another suitable shape if required.</P>
+ * definition so there is no need to explicitly include it by creating a text 
+ * object to force it to be included. The missing glyph will always be the first 
+ * glyph in the font definition generated by the FSTextConstructor object so it 
+ * may be substituted by another suitable shape if required.</P>
  * 
  * <P>Whether a string can be displayed using a font can be determined by the 
- * <em>canDisplay()</em> method which returns the index of the first character that 
- * cannot be displayed (the missing glyph will be displayed instead) or -1 if all the 
- * characters are represented in the font.</P>
+ * <em>canDisplay()</em> method which returns the index of the first character 
+ * that cannot be displayed (the missing glyph will be displayed instead) or -1 
+ * if all the characters are represented in the font.</P>
  */
 public final class FSTextConstructor
 {
@@ -352,15 +344,41 @@
              decodeAWTFont(fontName);
      }
     /**
-     * Indicates whether or not this FSTextConstructor can display a specified Unicode
-     * String. This method returns the index of the first character that cannot be
-     * displayed using this font. If the Font can display all characters, -1 is
-     * returned.
+     * Indicates whether or not this FSTextConstructor can display all the 
+     * characters specified in the array. This method returns the index of the 
+     * first character that cannot be displayed using this font. If the Font can 
+     * display all characters, -1 is returned.
      *
+     * @param chars an array containing all the characters to be displayed.
+     *
+     * @return the index of the first character that cannot be displayed, -1 
+     * otherwise.
+     */
+    public int canDisplay(char[] chars)
+    {
+        int firstMissingChar = -1;
+
+        for (int i=0; i<chars.length; i++)
+        {
+            if (canDisplay(chars[i]) == false)
+            {
+                firstMissingChar = i;
+                break;
+            }
+        }
+        return firstMissingChar;
+    }
+    /**
+     * Indicates whether or not this FSTextConstructor can display a specified 
+     * Unicode String. This method returns the index of the first character that 
+     * cannot be displayed using this font. If the Font can display all 
+     * characters, -1 is returned.
+     *
      * @param aString the String to be displayed.
      *
-     * @return the index of the first character that cannot be displayed, -1 otherwise.
-     */
+     * @return the index of the first character that cannot be displayed, -1 
+     * otherwise.
+     */
     public int canDisplay(String aString)
     {
         int firstMissingChar = -1;
@@ -377,12 +395,39 @@
         return firstMissingChar;
     }
     /**
+     * willDisplay is used to predefine the set of characters that will be 
+     * used when defining text objects.
+     * 
+     * @see FSCharacterTable for lists of predefined character sets that can be
+     * used with different spoken languages.
+     * 
+     * @param chars an array of characters defining the character set that will
+     * be used when defining text objects and fonts. The characters must be 
+     * sorted by the code used to represent the character.
+     */
+    public void willDisplay(char[] chars)
+    {
+       for (int i=0; i<chars.length; i++)
+       {
+           int glyphIndex = characterTable[chars[i]];
+           
+           for (int index=0; index<65536; index++)
+           {
+               if (orderTable[index] == glyphIndex)
+                   break;
+               else if (orderTable[index] == -1)
+               {
+                   orderTable[index] = (short)glyphIndex;
+                   break;
+               }
+           }
+       }
+    }
+    /**
      * Generates a FSDefineFont2 object containing a complete definition of the font.
      *
-     * <P>NOTE: Only the glyphs referenced in the FSDefineText2 objects created using the 
-     * defineText method will be included in the font definition. If FSDefineText2 objects 
-     * are created after the font is generated and the text references a glyph not 
-     * previously used then the text string will not be displayed correctly.</P>
+     * <P>NOTE: Only the glyphs specified in the array of characters passed to
+     * the willDisplay method will be shown.</P>
      *
      * @return a FSDefineFont2 object generated from the font definition.
      */
@@ -444,12 +489,6 @@
      * <P>If any of the Unicode characters in the String cannot be displayed using this font
      * then the missing glyph is substituted.</p>
      * 
-     * <P>All the FSDefineText2 objects should be created before the font definition. Only 
-     * the glyphs referenced up to that point will be included in the font. If text objects
-     * are created after the font definition has been generated and a glyph is referenced 
-     * that is not in the font then the text will not be displayed correctly and may even
-     * crash the Flash Player.
-     *
      * @param anIdentifier a unique identifier for the object.
      * @param text the String to be displayed.
      * @param fontSize the size of the font in twips.
@@ -487,12 +526,6 @@
      * <P>If any of the Unicode characters in the String cannot be displayed using this font
      * then the missing glyph is substituted.</p>
      * 
-     * <P>All the FSDefineText2 objects should be created before the font definition. Only 
-     * the glyphs referenced up to that point will be included in the font. If text objects
-     * are created after the font definition has been generated and a glyph is referenced 
-     * that is not in the font then the text will not be displayed correctly and may even
-     * crash the Flash Player.
-     *
      * @param anIdentifier a unique identifier for the object.
      * @param lines an array containing the lines of text to be displayed.
      * @param fontSize the size of the font in twips.
@@ -1780,7 +1813,7 @@
         glyphTable[glyphIndex].onCurve = onCurve;
         glyphTable[glyphIndex].endPoints = endPtsOfContours;
     }
-      private void decodeCompositeGlyph(FSCoder coder, int glyphIndex)
+    private void decodeCompositeGlyph(FSCoder coder, int glyphIndex)
     {
         FSShape shape = new FSShape();
         FSCoordTransform transform = null;

Modified: trunk/test/suites/FSTextConstructor.xml
===================================================================
--- trunk/test/suites/FSTextConstructor.xml	2006-02-26 22:36:37 UTC (rev 88)
+++ trunk/test/suites/FSTextConstructor.xml	2006-02-28 13:20:03 UTC (rev 89)
@@ -56,5 +56,27 @@
 		</classes>
   	</test>
 
+    <test name="Character Sets">
+		<parameter name="dstDir" value="test/results/FSTextConstructor/character-sets"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSTextConstructorTest">
+      		    <methods>
+      				<include name="displayCharacterSets" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+
+    <test name="Character Sets">
+		<parameter name="dstDir" value="test/results/FSTextConstructor/locales"/>
+		<classes>
+      		<class name="com.flagstone.transform.test.FSTextConstructorTest">
+      		    <methods>
+      				<include name="displayLocales" />
+    			</methods>
+      		</class>
+		</classes>
+  	</test>
+
 </suite>
 



