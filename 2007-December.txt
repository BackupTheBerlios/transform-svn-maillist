From smackay at mail.berlios.de  Fri Dec 21 17:16:02 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Fri, 21 Dec 2007 17:16:02 +0100
Subject: [Transform-svn] r258 - trunk/src/com/flagstone/transform
Message-ID: <200712211616.lBLGG2PV025172@sheep.berlios.de>

Author: smackay
Date: 2007-12-21 17:15:59 +0100 (Fri, 21 Dec 2007)
New Revision: 258

Modified:
   trunk/src/com/flagstone/transform/FSButton.java
Log:
Corrected errors in documentation.

Modified: trunk/src/com/flagstone/transform/FSButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButton.java	2007-11-19 04:12:05 UTC (rev 257)
+++ trunk/src/com/flagstone/transform/FSButton.java	2007-12-21 16:15:59 UTC (rev 258)
@@ -1,38 +1,38 @@
 /*
  * FSButton.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 package com.flagstone.transform;
 
 /**
-FSButton identifies the shape that is drawn when a button is in a particular state. 
- 
+FSButton identifies the shape that is drawn when a button is in a particular state.
+
 <p>Shapes can be drawn for each of three button states, Over, Up and Down. Creating a button with more than one FSButton object each referencing a different shape allows the button to be animated as it is clicked.</p>
 
 <p>A shape is also used to define active area of the button. When defining the active area the outline of the shape defines the boundary of the area. The shape is not drawn when the button is displayed. The button will only respond to mouse events when the cursor is placed inside the active area.</p>
@@ -63,7 +63,7 @@
 
 <tr>
 <td><a name="FSButton_3">colorTransform</a></td>
-<td>an optional FSColorTransform object that can be used to change the shape's 
+<td>an optional FSColorTransform object that can be used to change the shape's
 colour when it is drawn.</td>
 </tr>
 
@@ -84,7 +84,7 @@
 
 <p>The FSButton class represents the ButtonRecord structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.</p>
 
- */  
+ */
 public class FSButton extends FSTransformObject
 {
     /** Code for the button in the up state. */
@@ -95,18 +95,18 @@
     public static final int Down = 4;
     /** Code for the active area of the button. */
     public static final int Active = 8;
-    
+
     private int state = 0;
     private int identifier = 0;
     private int layer = 0;
-    
+
     private FSCoordTransform transform = null;
     private FSColorTransform colorTransform = null;
 
     /**
      * Construct an FSButton object, initalizing it with values decoded from
      * an encoded object.
-     * 
+     *
      * @param coder an FSCoder containing the binary data.
      */
     public FSButton(FSCoder coder)
@@ -171,7 +171,7 @@
         identifier = obj.identifier;
         layer = obj.layer;
         transform = new FSCoordTransform(obj.transform);
-        
+
         if (obj.colorTransform != null)
             colorTransform = new FSColorTransform(obj.colorTransform);
     }
@@ -206,7 +206,7 @@
         */
     public boolean isUp() { return ((state & Up) != 0) ? true : false; }
 
-    /** Gets the identifier of the shape that this FSButton applies to. 
+    /** Gets the identifier of the shape that this FSButton applies to.
 
         @return the identifier of the shape.
         */
@@ -232,11 +232,11 @@
 
     /** Set the state(s) of the button when the shape is drawn. The shape may be drawn for more than one state. Multiple states can be defined by bitwise-OR'ing individual states together, e.g.  Up | Over.
 
-        @return the state of the button when the shape is drawn.
+        @param aNumber the state of the button when the shape is drawn.
         */
     public void setState(int aNumber) { state = aNumber; }
 
-    /** Sets the identifier of the  FSDefineShape, FSDefineShape2 or FSDefineShape3 object that defines the appearance of the button when it is in the specified state(s). 
+    /** Sets the identifier of the  FSDefineShape, FSDefineShape2 or FSDefineShape3 object that defines the appearance of the button when it is in the specified state(s).
 
         @param anIdentifier the identifier of the shape object that defines the shape's appearance.
         */
@@ -275,7 +275,7 @@
     public Object clone()
     {
         FSButton anObject = (FSButton)super.clone();
-        
+
         anObject = (FSButton)super.clone();
         anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
         anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
@@ -283,9 +283,9 @@
         return anObject;
     }
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
+    /**
+     * Returns true if anObject is equal to this one. Objects are considered
+     * equal if they would generate identical binary data when they are encoded
      * to a Flash file.
      *
      * @return true if this object would be identical to anObject when encoded.
@@ -293,11 +293,11 @@
     public boolean equals(Object anObject)
     {
         boolean result = false;
-        
+
         if (super.equals(anObject))
         {
             FSButton typedObject = (FSButton)anObject;
-            
+
             result = state == typedObject.state;
             result = result && identifier == typedObject.identifier;
             result = result && layer == typedObject.layer;
@@ -334,7 +334,7 @@
     public int length(FSCoder coder)
     {
         int length = 0;
-    
+
         length += 5;
         length += transform.length(coder);
 // Flash 3
@@ -343,7 +343,7 @@
 // End Flash 3
         return length;
     }
-    
+
     public void encode(FSCoder coder)
     {
         coder.writeBits(0, 4);
@@ -356,11 +356,11 @@
             colorTransform.encode(coder);
 // End Flash 3
     }
-    
+
     public void decode(FSCoder coder)
     {
         coder.readBits(4, false);
-        
+
         state = coder.readBits(4, false);
         identifier = coder.readWord(2, false);
         layer = coder.readWord(2, false);



From smackay at mail.berlios.de  Fri Dec 21 17:17:33 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Fri, 21 Dec 2007 17:17:33 +0100
Subject: [Transform-svn] r259 - trunk/src/com/flagstone/transform
Message-ID: <200712211617.lBLGHXOH025343@sheep.berlios.de>

Author: smackay
Date: 2007-12-21 17:17:29 +0100 (Fri, 21 Dec 2007)
New Revision: 259

Modified:
   trunk/src/com/flagstone/transform/FSFrameLabel.java
Log:
Corrected errors in documentation.

Modified: trunk/src/com/flagstone/transform/FSFrameLabel.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFrameLabel.java	2007-12-21 16:15:59 UTC (rev 258)
+++ trunk/src/com/flagstone/transform/FSFrameLabel.java	2007-12-21 16:17:29 UTC (rev 259)
@@ -1,30 +1,30 @@
 /*
  * FSFrameLabel.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
@@ -34,8 +34,8 @@
 import java.util.Iterator;
 
 /**
-FSFrameLabel defines a name for the current frame in a movie or movie clip. 
-  
+FSFrameLabel defines a name for the current frame in a movie or movie clip.
+
 <p>The name can be referenced from other objects such as FSGotoFrame2 to simplify the creation of scripts to control movies by using a predefined name rather than the frame number. The label assigned to a particular frame should be unique. Frames may also be reference externally when specifying the movie to play using a URL - similar to the way names links are used in HTML. When the Flash Player loaded a movie it will begin playing at the frame specified in the URL.</p>
 
 <table class="datasheet">
@@ -149,14 +149,14 @@
 <h1 class="datasheet">History</h1>
 
 <p>The FSFrameLabel class represents the FrameLabel tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3. In Flash 6 the label can support named anchors which allows a frame to be specified as the starting point when displaying a Flash movie in a web browser.</p>
- */  
+ */
 public class FSFrameLabel extends FSMovieObject
 {
     private String label = null;
 // Flash 6
     private boolean anchor = false;
 // End Flash 6
-        
+
     FSFrameLabel()
     {
         super(FrameLabel);
@@ -165,7 +165,7 @@
     /**
      * Construct an FSFrameLabel object, initalizing it with values decoded from
      * an encoded object.
-     * 
+     *
      * @param coder an FSCoder containing the binary data.
      */
     public FSFrameLabel(FSCoder coder)
@@ -173,7 +173,7 @@
         super(FrameLabel);
         decode(coder);
     }
-    /** Constructs an FSFrameLabel object with the specified name. 
+    /** Constructs an FSFrameLabel object with the specified name.
 
         @param aString the string that defines the label that will be assigned to the current frame.
         */
@@ -183,10 +183,10 @@
         setLabel(aString);
     }
 // Flash 6
-    /** Constructs an FSFrameLabel object with the specified name. If the isAnchor 
-     *  flag is true then the frame will be directly selectable by a URL and the 
+    /** Constructs an FSFrameLabel object with the specified name. If the isAnchor
+     *  flag is true then the frame will be directly selectable by a URL and the
      *  Flash Player will begin playing the movie at the specified frame.
-     * 
+     *
      *  @param aString the string that defines the label that will be assigned to the current frame.
      *  @param isAnchor if true the name will be used as an anchor when referencing the frame in a URL.
      */
@@ -198,7 +198,7 @@
     }
 // End Flash 6
     /**
-     * Constructs an FSFrameLabel object by copying values from an existing 
+     * Constructs an FSFrameLabel object by copying values from an existing
      * object.
      *
      * @param obj an FSFrameLabel object.
@@ -208,7 +208,7 @@
         super(obj);
         label = new String(label);
         anchor = obj.anchor;
-    }    
+    }
 
     /** Gets the label.
 
@@ -227,7 +227,7 @@
 
 // Flash 6
     /** Sets the label defining whether it will be referenced as an anchor or not.
-     * 
+     *
      *  @param aString the string that defines the label that will be assigned to the current frame.
      *  @param isAnchor if true the name will be used as an anchor when referencing the frame in a URL.
      */
@@ -237,19 +237,19 @@
         anchor = isAnchor;
     }
 
-    /** Gets the flag indicating whether the frame name is also used as an anchor 
+    /** Gets the flag indicating whether the frame name is also used as an anchor
      *  so the frame can be referenced from outside of the movie.
-     * 
+     *
      *  @return true if the frame is an anchor frame, false otherwise.
      */
     public boolean getAnchor() { return anchor; }
 
-    /** Sets the flag indicating whether the frame name is also used as an anchor 
+    /** Sets the flag indicating whether the frame name is also used as an anchor
      *  so the frame can be referenced from outside of the movie.
-     * 
-     *  @return isAnchor true if the frame is an anchor frame, false otherwise.
+     *
+     *  @param isAnchor true if the frame is an anchor frame, false otherwise.
      */
-     public void setAnchor(boolean isAnchor)
+    public void setAnchor(boolean isAnchor)
     {
         anchor = isAnchor;
     }
@@ -258,18 +258,18 @@
     public boolean equals(Object anObject)
     {
         boolean result = false;
-        
+
         if (super.equals(anObject))
         {
             FSFrameLabel typedObject = (FSFrameLabel)anObject;
-            
+
             if (label != null)
                 result = label.equals(typedObject.label);
             else
                 result = typedObject.label == null;
-                
+
 // Flash 6
-            result = result &&  anchor == typedObject.anchor;                
+            result = result &&  anchor == typedObject.anchor;
 // Flash 7
         }
         return result;
@@ -278,14 +278,14 @@
     public void appendDescription(StringBuffer buffer, int depth)
     {
         buffer.append(name());
-        
+
         if (depth > 0)
         {
             buffer.append(": { ");
             Transform.append(buffer, "label", label);
 // Flash 6
             Transform.append(buffer, "anchor", anchor);
-// End Flash 6            
+// End Flash 6
             buffer.append("}");
         }
     }
@@ -299,32 +299,32 @@
 // Flash 6
         length += anchor ? 1 : 0;
 // End Flash 6
-            
+
         return length;
     }
-    
+
     public void encode(FSCoder coder)
     {
         super.encode(coder);
         coder.writeString(label);
         coder.writeWord(0, 1);
-        
+
 // Flash 6
         if (anchor)
             coder.writeWord(1, 1);
 // End Flash 6
         coder.endObject(name());
     }
-    
+
     public void decode(FSCoder coder)
     {
         super.decode(coder);
 
         int start = coder.getPointer();
         int strlen = 0;
-        
+
         for (strlen=0; coder.scanWord(1, false) != 0; coder.adjustPointer(8), strlen++);
-        
+
         coder.setPointer(start);
         label = coder.readString(strlen++);
         coder.adjustPointer(8);



From smackay at mail.berlios.de  Sat Dec 22 16:33:41 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:33:41 +0100
Subject: [Transform-svn] r260 - trunk
Message-ID: <200712221533.lBMFXfdV008849@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:33:37 +0100 (Sat, 22 Dec 2007)
New Revision: 260

Modified:
   trunk/build.xml
Log:
Removed the tools and docs targets so the build file only supports the framework classes, contributed classes and examples.

Modified: trunk/build.xml
===================================================================
--- trunk/build.xml	2007-12-21 16:17:29 UTC (rev 259)
+++ trunk/build.xml	2007-12-22 15:33:37 UTC (rev 260)
@@ -2,66 +2,51 @@
 <project name="transform" default="build" basedir=".">
 
     <description>ANT build file for Transform.
-    
+
         The following major targets are available:
-        
+
         build      used to create a version of Transform that can be used in
-	               production code. It compiles a clean, optimized version of 
+	               production code. It compiles a clean, optimized version of
                    the classes in the framework and packages them in a JAR.
-                   The core classes in the framework  and any classes in the 
-                   contrib directory are used, examples, tools and test classes 
+                   The core classes in the framework  and any classes in the
+                   contrib directory are used. The examples and test classes
                    are excluded.
-        
-        The following minor targets provide more control over the compiling 
-        and packaging of classes, allowing for example a JAR file to be 
+
+        The following minor targets provide more control over the compiling
+        and packaging of classes, allowing for example a JAR file to be
         created containing the framework classes and the examples.
-        
-        clean      remove all the files generated by the compile targets. This 
-                   deletes the build directory which contains the compiled 
+
+        clean      remove all the files generated by the compile targets. This
+                   deletes the build directory which contains the compiled
                    classes along with any JAR files created.
 
-        classes    compile the classes in the packages com.flagstone.transform 
+        classes    compile the classes in the packages com.flagstone.transform
                    and com.flagstone.transform,util.
-         
+
         examples   compile the examples.
-        
-        tools      compile the tools.
-        
+
         contrib    compile all the classes contributed to the framework.
-        
-        docs       generate javadoc datasheets for all the classes in the 
-                   source tree.
-                     
+
         jar        packages all of the compiled classes in the build directory
                    into the JAR file, transform.jar.
 
     </description>
 
-    <property name="version" value="2.1.5"/>
-    
+    <property name="version" value="2.1.6"/>
+
     <property name="src.dir" location="src"/>
     <property name="lib.dir" location="lib"/>
     <property name="build.dir" location="build"/>
-    
+
     <property name="package.name" value="transform"/>
     <property name="package.dir" value="com/flagstone/${package.name}"/>
-    <property name="package.main.class" value="Transform.java"/>
-    <property name="package.util.dir" value="${package.dir}/util"/>
-    <property name="package.example.dir" value="${package.dir}/examples"/>
-    <property name="package.tool.dir" value="${package.dir}/tools"/>
-    <property name="package.test.dir" value="${package.dir}/test"/>
     <property name="package.contrib.dir" value="${package.name}/contrib"/>
-    
-    <property name="doc.root.dir" location="doc"/>
-    <property name="doc.css.dir" value="${doc.root.dir}/css"/>
-    <property name="doc.datasheet.dir" value="${doc.root.dir}/datasheets"/>
-    <property name="doc.release.dir" value="${doc.root.dir}/releases"/>
-        
+
 <!-- **********************************************************
          Major targets for compiling and packaging the classes.
      ********************************************************** -->
-     
-    <target name="build" depends="clean,classes,contrib,jar" 
+
+    <target name="build" depends="clean,classes,contrib,jar"
         description="Compile optimized versions of the classes for deployment"/>
 
 <!-- *******************************************************************
@@ -74,73 +59,51 @@
     </target>
 
     <target name="classes" description="Compile the transform and utilities classes">
-    
+
         <mkdir dir="${build.dir}"/>
-        
-        <javac srcdir="${src.dir}" destdir="${build.dir}" 
+
+        <javac srcdir="${src.dir}" destdir="${build.dir}"
             debug="off" optimize="on" source="1.4">
             <include name="${package.dir}/*.java" />
-            <include name="${package.util.dir}/*.java" />
+            <include name="${package.dir}/util/*.java" />
         </javac>
-        
+
     </target>
 
     <target name="examples" description="Compile the examples">
-    
-        <mkdir dir="${build.dir}"/>
-        
-        <javac srcdir="${src.dir}" destdir="${build.dir}" debug="on" optimize="off">
-            <include name="${package.example.dir}/*.java" />
-        </javac>
-        
-    </target>
 
-    <target name="tools" description="Compile the tools">
-    
         <mkdir dir="${build.dir}"/>
-        
+
         <javac srcdir="${src.dir}" destdir="${build.dir}" debug="on" optimize="off">
-            <include name="${package.tool.dir}/*.java" />
+            <include name="${package.dir}/examples/*.java" />
         </javac>
-        
+
     </target>
 
     <target name="contrib" description="Compile the classes contributed to the framework">
-    
+
         <mkdir dir="${build.dir}"/>
-        
-        <javac srcdir="${src.dir}" 
+
+        <javac srcdir="${src.dir}"
                destdir="${build.dir}"
                classpath="${build.dir}"
-               debug="off" 
+               debug="off"
                optimize="on"
                source="1.4">
+            <compilerarg value="-Xlint"/>
             <include name="${package.contrib.dir}/**" />
         </javac>
-        
-    </target>
 
-    <target name="docs" description="Generate javadoc datasheets for each class">
-     
-        <mkdir dir="${doc.datasheet.dir}"/>
-
-        <javadoc destdir="${doc.datasheet.dir}" stylesheetfile="${doc.css.dir}/datasheet.css">
-            <packageset dir="${src.dir}" defaultexcludes="yes">
-                <include name="${package.dir}" />
-                <include name="${package.util.dir}" />
-            </packageset>
-        </javadoc>
-
     </target>
 
     <target name="jar" description="Package all of the classes in a JAR file">
-    
+
         <jar jarfile="${package.name}.jar">
             <fileset dir="${build.dir}">
                 <include name="${package.dir}/**"/>
             </fileset>
         </jar>
-        
+
     </target>
 
 </project>



From smackay at mail.berlios.de  Sat Dec 22 16:36:22 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:36:22 +0100
Subject: [Transform-svn] r261 - trunk
Message-ID: <200712221536.lBMFaMDq009204@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:36:15 +0100 (Sat, 22 Dec 2007)
New Revision: 261

Modified:
   trunk/developer.xml
Log:
Removed patch target and added test target to compile the unit test classes. Merged generation of class datasheets into the dest target. Also simplified the way releases are packaged.

Modified: trunk/developer.xml
===================================================================
--- trunk/developer.xml	2007-12-22 15:33:37 UTC (rev 260)
+++ trunk/developer.xml	2007-12-22 15:36:15 UTC (rev 261)
@@ -2,102 +2,103 @@
 <project name="transform-developer" default="dist" basedir=".">
 
     <description>Developer targets
-        
-        This build file is used by the developers on  the Transform project.
+
+        This build file is used by the developers on the Transform project.
         It contains the following major targets:
-            
-        debug      used to create a developer version of Transform. Debug flags 
-                   in the source code are enabled and the classes are compiled 
+
+        debug      used to create a developer version of Transform. Debug flags
+                   in the source code are enabled and the classes are compiled
                    with debug information and unoptimised.
-         
-        dist       creates a complete distribution of the Transform framework.
-                
-        patch      packages a list of classes as a source code only release.
-                   The classes are listed in the first task of the target -
-                   this allows classes from different packages to be easily 
-                   listed.
         
+        test       compile the classes used for unit testing.
+
+        dist       creates a distribution of the Transform framework.
+
     </description>
-    
+
     <import file="build.xml"/>
 
+    <property name="main.class" value="Transform.java"/>
+
     <property name="dist.name" value="${package.name}-${version}"/>
-    <property name="patch.name" value="${dist.name}-patch-${patch.number}"/>
-
+
     <property name="dist.root.dir" location="dist"/>
     <property name="dist.dir" value="${dist.root.dir}/${dist.name}"/>
 
-    <property name="patch.number" value="1"/>
-    <property name="patch.dir" value="${dist.root.dir}/${dist.name}-patch-${patch.number}"/>
-
 <!-- *******************************************************************
          Minor targets to compile and package different sets of classes.
      ******************************************************************* -->
 
     <target name="debug" description="Compile debug versions of the classes">
-    
+
         <mkdir dir="${build.dir}"/>
-        
+
         <replace dir="${src.dir}" token="DEBUG = false" value="DEBUG = true">
-            <include name="${package.dir}/${package.main.class}"/>
+            <include name="${package.dir}/${main.class}"/>
         </replace>
-                
-        <javac srcdir="${src.dir}" destdir="${build.dir}" 
+
+        <javac srcdir="${src.dir}" destdir="${build.dir}"
             debug="on" optimize="off" source="1.4">
             <include name="${package.dir}/*.java" />
-            <include name="${package.util.dir}/*.java" />
+            <include name="${package.dir}/util/*.java" />
         </javac>
-        
+
     </target>
-     
+
+    <target name="test" description="Compile the test classes">
+
+        <mkdir dir="${build.dir}"/>
+
+        <javac srcdir="${src.dir}" destdir="${build.dir}" classpath="lib/junit.jar"
+            debug="on" optimize="off" source="1.4">
+            <include name="${package.dir}/test/*.java" />
+        </javac>
+
+    </target>
+
 <!-- ***************************************
        Package the files for distribution.
-     *************************************** --> 
-    <target name="dist" depends="build,docs" description="Create a full distribution">
-        
+     *************************************** -->
+    <target name="dist" depends="build" description="Create a distribution">
+
         <delete dir="${dist.dir}" failonerror="false"/>
 
         <mkdir dir="${dist.dir}"/>
-            
+
         <copy todir="${dist.dir}/src" overwrite="true">
             <fileset dir="${src.dir}">
-                <include name="${package.dir}/*" />
-                <include name="${package.dir}/doc-files/*" />
-                <include name="${package.example.dir}/*" />
-                <include name="${package.test.dir}/*" />
-                <include name="${package.tool.dir}/*" />
-                <include name="${package.util.dir}/*" />
-                <include name="${package.contrib.dir}/*" />
+                <include name="${package.dir}/*.java" />
+                <include name="${package.dir}/util/*.java" />
+                <include name="${package.dir}/examples/*.java" />
+                <include name="${package.contrib.dir}/**" />
             </fileset>
         </copy>
 
+        <copy todir="${dist.dir}" overwrite="true">
+            <fileset dir="doc">
+                <include name="*.txt" />
+            </fileset>
+        </copy>
+
         <copy todir="${dist.dir}/doc" overwrite="true">
             <fileset dir="doc">
                 <exclude name="css/**" />
-                <exclude name="web/**" />
+                <exclude name="*.txt" />
             </fileset>
         </copy>
 
-        <copy todir="${dist.dir}/test" overwrite="true">
-            <fileset dir="test">
-                <include name="suites/*" />
-                <include name="data/*" />
-                <include name="results/readme.txt" />
-                <include name="reports/readme.txt" />
-            </fileset>
-        </copy>
-
-        <copy todir="${dist.dir}/lib" overwrite="true">
-            <fileset dir="lib">
-                <include name="testng-4.7-jdk14.jar" />
-                <include name="testng-4.7-jdk15.jar" />
-            </fileset>
-        </copy>
-
+        <mkdir dir="${dist.dir}/doc/datasheets"/>
+
+        <javadoc destdir="${dist.dir}/doc/datasheets" stylesheetfile="doc/css/datasheet.css">
+            <packageset dir="${src.dir}" defaultexcludes="yes">
+                <include name="${package.dir}" />
+                <include name="${package.dir}/util" />
+            </packageset>
+        </javadoc>
+
         <copy todir="${dist.dir}" overwrite="true">
             <fileset dir=".">
                 <include name="build.xml" />
-                <include name="test.xml" />
                 <include name="${package.name}.jar" />
              </fileset>
         </copy>
@@ -106,13 +107,13 @@
              basedir="${dist.dir}"
              compression="gzip"
         />
-        
+
         <exec dir="${dist.root.dir}" executable="md5sums" output="${dist.root.dir}/${dist.name}.tar.md5">
             <arg value="-n" />
             <arg value="-b" />
             <arg value="${dist.name}.tar.gz" />
         </exec>
-        
+
         <zip destfile="${dist.root.dir}/${dist.name}.zip"
              basedir="${dist.dir}"
         />
@@ -122,11 +123,11 @@
             <arg value="-b" />
             <arg value="${dist.name}.zip" />
         </exec>
-        
-        <echo file="${dist.root.dir}/${dist.name}-gpg.txt" append="false" 
+
+        <echo file="${dist.root.dir}/${dist.name}-gpg.txt" append="false"
             message="gpg --local-user support --armor --detach-sign --output ${dist.name}.tar.asc ${dist.name}.tar.gz${line.separator}"/>
-        <echo file="${dist.root.dir}/${dist.name}-gpg.txt" append="true" 
+        <echo file="${dist.root.dir}/${dist.name}-gpg.txt" append="true"
             message="gpg --local-user support --armor --detach-sign --output ${dist.name}.zip.asc ${dist.name}.zip"/>
     </target>
- 
+
 </project>



From smackay at mail.berlios.de  Sat Dec 22 16:37:28 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:37:28 +0100
Subject: [Transform-svn] r262 - trunk/test
Message-ID: <200712221537.lBMFbSvw009229@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:37:24 +0100 (Sat, 22 Dec 2007)
New Revision: 262

Removed:
   trunk/test/results/
Log:
No longer included in distributions.



From smackay at mail.berlios.de  Sat Dec 22 16:38:20 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:38:20 +0100
Subject: [Transform-svn] r263 - trunk/test
Message-ID: <200712221538.lBMFcKXS009314@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:38:17 +0100 (Sat, 22 Dec 2007)
New Revision: 263

Removed:
   trunk/test/reports/
   trunk/test/suites/
Log:
TestNG replaced by JUnit so the suites and reports directories are no longer used.



From smackay at mail.berlios.de  Sat Dec 22 16:39:37 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:39:37 +0100
Subject: [Transform-svn] r264 - trunk/doc
Message-ID: <200712221539.lBMFdb5f009351@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:39:26 +0100 (Sat, 22 Dec 2007)
New Revision: 264

Modified:
   trunk/doc/README.txt
Log:
removed references to TestNG from file.

Modified: trunk/doc/README.txt
===================================================================
--- trunk/doc/README.txt	2007-12-22 15:38:17 UTC (rev 263)
+++ trunk/doc/README.txt	2007-12-22 15:39:26 UTC (rev 264)
@@ -1,38 +1,41 @@
 ------------------
   Transform SWF
 ------------------
-The Transform SWF framework is a collection of classes for each of the data 
-structures and tags that make up the Flash File Format Specification from 
+The Transform SWF framework is a collection of classes for each of the data
+structures and tags that make up the Flash File Format Specification from
 Macromedia. The classes provide a completely object-oriented API to encode
 and decode Flash (.swf) files. Transform SWF supports Flash MX 2004 (Flash 7).
 
 The framework also contains classes that provide a higher level interface
-supporting the addition of shapes, images, sounds, fonts and text from 
+supporting the addition of shapes, images, sounds, fonts and text from
 external file formats.
 
-The documentation that accompanied this release contains a description of the 
-each of the classes along with examples on how they may be used to decode, 
-process and encode Flash (.swf) files. Flagstone Software's web site, 
+The documentation that accompanied this release contains a description of the
+each of the classes along with examples on how they may be used to decode,
+process and encode Flash (.swf) files. Flagstone Software's web site,
 www.flagstonesoftware.com also contains more detailed information and advanced
 examples.
 
+IMPORTANT: If you downloaded Transform then the framework only contains the
+classes for reading and writing Flash files along with some examples. All the
+classes used to perform testing and benchmarking are not included. If you want
+to do any development then you should check out all the files directly from the
+Subversion repository: https://svn.berlios.de/svnroot/repos/transform/trunk
+
 -------------
   Licencing
 -------------
-Transform SWF is made available under the terms of the Berkeley Software 
-Distribution (BSD) license. This allow you complete freedom to use and 
+Transform SWF is made available under the terms of the Berkeley Software
+Distribution (BSD) license. This allow you complete freedom to use and
 distribute the code in source and/or binary form as long as you respect
 the original copyright. Please see the LiCENCE.txt file for exact terms.
 
-The class libraries shipped with Transform in the lib directory each have their 
-own licence. For more details please see the 'Libraries' section below.
-
 -----------------
   Contributions
 -----------------
-Contributions by other authors are also avaiable in the contrib directory. 
-Unless otherwise stated in the contribution's documentation, each is licensed 
-for use and redistribution under the terms of the Berkeley Software Distribution 
+Contributions by other authors are also available in the contrib directory.
+Unless otherwise stated in the contribution's documentation, each is licensed
+for use and redistribution under the terms of the Berkeley Software Distribution
 (BSD) license.
 
 ----------------
@@ -46,82 +49,73 @@
   Building the Framework
 --------------------------
 The ANT build file, build.xml contains the following major targets:
-    
-    build   compile with optimisation all the classes in the 
+
+    build   compile with optimisation all the classes in the
             transform and transform utilities and package them
             in transform.jar (examples and test classes are not
             included).
-            
-Minor targets provide more control over the compiling and packaging 
-of classes, allowing for example a JAR file to be created containing 
+
+Minor targets provide more control over the compiling and packaging
+of classes, allowing for example a JAR file to be created containing
 the framework classes and the examples. Targets include:
-            
+
     clean    remove all the compiled classes and jars.
-    debug    compile the framework classes for debugging.
-    optimize compile the framework classes for production.
-    examples compile the examples (com.flagstone.transform.examples).
-    tools    compile the tools (om.flagstone.transform.tools).
-    docs     generate the class datasheets using javadoc.
+    classes  compile the framework classes for production.
+    examples compile the examples.
+    contrib  compile the contributed classes.
     jar      package all the compiled classes in a JAR.
-    
+
 -------------------------
   Testing the Framework
 -------------------------
-Transform comes with code to test that the classes in the framework are encoding
-and decoding Flash files correctly. The tests use the TestNG framework developed 
-by Cedric Beust, http://www.testng.org.
+If you check out Transform from the repository then the source tree contains
+code to test that the classes in the framework are encoding and decoding Flash
+files correctly. The tests use JUnit 3.8.2 framework, which you can find out
+more about at http://www.junit.org. Testing is designed to be performed within
+an development environment, such as Eclipse, where the unit tests can be run
+directly. The Junit JAR file is not included.
 
-The lib directory of the release contains the jar files neccessary to run the
-TestNG suites. Two versions of TestNG are available for Java 1.4 and Java 1.5
-depending on which version of Java you are using.
+The package com.flagstone.transform.test contains tests for individual classes
+as well as suites of tests for groups of classes. The class AllTests will run
+the entire suite of tests available.
 
-The Ant build file, test.xml, contains the following targets to run the tests:
-
-	clean-test  delete all the test reports and any directories generated when
-	            running the tests.
-	           
-	build-test  compile the test classes.
-	
-    test-all    run a full test of all the classes in the framework.
-    test-class  run unit tests for a specific class.
-    
-The reports generated by TestNG are written to the directory test/reports. A 
-separate directroy is created for each test and is named after the class being
-test while the report generated while testing the entire framework is written
-to the directory, Transform.
-
 ---------------------------
   Using Files For Testing
 ---------------------------
 The directory test/data is designed to hold sets of files that can be used to
 test the classes in the framework. The files augment the test patterns in the
-unit tests. This is particularly important for more complex classes such as 
-images, fonts and sounds where the volume and/or variation in data can be 
+unit tests. This is particularly important for more complex classes such as
+images, fonts and sounds where the volume and/or variation in data can be
 significant.
 
-The directories are organized according to the type of file that is used in 
-testing: 
+The directories are organized according to the type of file that is used in
+testing:
 
 test
   |
   +- data
-	   |
-	   +- swf
-	   +- ttf
-	   +- bmp
-	   +- png
-       
-        
+  |   |
+  |   +- swf
+  |   +- ttf
+  |   +- bmp
+  |   +- png
+  |
+  +- results
+
 The swf directory contain sample Flash files with a representative selection
 of encoded data structures for a particular class. These files were extracted
-from 'real-world' Flash files and so provide a useful sanity check for Flash 
+from 'real-world' Flash files and so provide a useful sanity check for Flash
 files that will be processed with the Transform framework.
 
-These files have been assembled from a number of different sources. Different 
-sets of files such as fonts and images are subject to specific terms and 
+These files have been assembled from a number of different sources. Different
+sets of files such as fonts and images are subject to specific terms and
 conditions however all can be distributed by Flagstone as part of this package.
 Details of the terms and conditions are included in each directory.
 
+The results directory are where the files generated during testing are written.
+A separate sub-directory will be created for each class. Within this directory
+sub-directories will be created for the files generated in each test.
+
 -----------------------
   Using the Framework
 -----------------------
@@ -133,228 +127,12 @@
 To use the classes, place the following import statement in your code:
 
     com.flagstone.transform.*;
-    
+
 If you build the framework using the ANT target develop then the examples
-and test classes can be used with the import statements:
-    
+can be used with the import statements:
+
     com.flagstone.transform.examples.*;
-    com.flagstone.transform.test.*;
 
--------------
-  Libraries
--------------
-Transform SWF is distributed with the following libraries:
-
-    * TestNG from Cedric Beust, et al, http://www.testng.org/
-    
-These libraries are not covered by the licence associated with Transform. 
-Details of the licence terms are listed below:
-
-----------
-  TestNG 
-----------
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
 --------------------------
   Additional Information
 --------------------------



From smackay at mail.berlios.de  Sat Dec 22 16:40:09 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:40:09 +0100
Subject: [Transform-svn] r265 - trunk/doc
Message-ID: <200712221540.lBMFe9v0009413@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:40:05 +0100 (Sat, 22 Dec 2007)
New Revision: 265

Modified:
   trunk/doc/LICENCE.txt
Log:
Updated year.

Modified: trunk/doc/LICENCE.txt
===================================================================
--- trunk/doc/LICENCE.txt	2007-12-22 15:39:26 UTC (rev 264)
+++ trunk/doc/LICENCE.txt	2007-12-22 15:40:05 UTC (rev 265)
@@ -1,30 +1,29 @@
 /*
- * All the files in this library, except those in the src/transform/contrib, 
- * test/data and lib directories, are  covered under the terms of the Berkeley 
+ * All the files in this library are  covered under the terms of the Berkeley
  * Software Distribution (BSD) License:
  *
- * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
+ * Copyright (c) 2001-2007 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */



From smackay at mail.berlios.de  Sat Dec 22 16:41:33 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:41:33 +0100
Subject: [Transform-svn] r266 - trunk/src/com/flagstone/transform/test
Message-ID: <200712221541.lBMFfXBV009429@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:41:10 +0100 (Sat, 22 Dec 2007)
New Revision: 266

Added:
   trunk/src/com/flagstone/transform/test/AllTests.java
   trunk/src/com/flagstone/transform/test/ConstructorTests.java
   trunk/src/com/flagstone/transform/test/DataTypeTests.java
   trunk/src/com/flagstone/transform/test/FSMovieBenchmark.java
   trunk/src/com/flagstone/transform/test/MovieObjectTests.java
   trunk/src/com/flagstone/transform/test/MovieTests.java
Removed:
   trunk/src/com/flagstone/transform/test/FSClassTest.java
   trunk/src/com/flagstone/transform/test/TextDumpTest.java
Modified:
   trunk/src/com/flagstone/transform/test/FSColorTest.java
   trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java
   trunk/src/com/flagstone/transform/test/FSMovieTest.java
   trunk/src/com/flagstone/transform/test/FSProtectTest.java
   trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java
   trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java
   trunk/src/com/flagstone/transform/test/FSShowFrameTest.java
   trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java
   trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
Log:
Refactored test package classes to use JUnit.

Added: trunk/src/com/flagstone/transform/test/AllTests.java
===================================================================
--- trunk/src/com/flagstone/transform/test/AllTests.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/AllTests.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -0,0 +1,17 @@
+package com.flagstone.transform.test;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class AllTests
+{
+    public static Test suite()
+    {
+        TestSuite suite= new TestSuite();
+        suite.addTest(DataTypeTests.suite());
+        suite.addTest(MovieObjectTests.suite());
+        suite.addTest(MovieTests.suite());
+        suite.addTest(ConstructorTests.suite());
+        return suite;
+    }
+}

Added: trunk/src/com/flagstone/transform/test/ConstructorTests.java
===================================================================
--- trunk/src/com/flagstone/transform/test/ConstructorTests.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/ConstructorTests.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -0,0 +1,17 @@
+package com.flagstone.transform.test;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class ConstructorTests
+{
+    public static Test suite()
+    {
+        TestSuite suite= new TestSuite();
+        suite.addTestSuite(FSImageConstructorTest.class);
+        suite.addTestSuite(FSShapeConstructorTest.class);
+        suite.addTestSuite(FSSoundConstructorTest.class);
+        suite.addTestSuite(FSTextConstructorTest.class);
+        return suite;
+    }
+}

Added: trunk/src/com/flagstone/transform/test/DataTypeTests.java
===================================================================
--- trunk/src/com/flagstone/transform/test/DataTypeTests.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/DataTypeTests.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -0,0 +1,14 @@
+package com.flagstone.transform.test;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class DataTypeTests
+{
+    public static Test suite()
+    {
+        TestSuite suite= new TestSuite();
+        suite.addTestSuite(FSColorTest.class);
+        return suite;
+    }
+}

Deleted: trunk/src/com/flagstone/transform/test/FSClassTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSClassTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSClassTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,128 +0,0 @@
-/*
- * FSSetBackgroundColorTest.java
- * Transform
- * 
- * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package com.flagstone.transform.test;
-
-import com.flagstone.transform.*;
-
-public abstract class FSClassTest 
-{               
-    public FSClassTest()
-    {        
-    }
-    
-    protected void checkType(int expected, int actual)
-    {
-        assert expected == actual : "Types are not identical.";    
-    }
-
-    protected void checkIdentical(Object expected, Object actual)
-    {
-        assert expected == actual : "References are not to the same object.";    
-    }
-
-    protected void checkNotIdentical(Object expected, Object actual)
-    {
-        assert expected != actual : "References are to the same object.";    
-    }
-
-    protected void checkEqual(Object expected, Object actual)
-    {
-        if (expected == null && actual != null)
-            assert false : "Objects do not match.";    
-        else if (expected != null && actual == null)
-            assert false : "Objects do not match.";            
-        else if (expected != null && actual != null)
-            assert actual.equals(expected) : "Objects do not match.";    
-    }
-
-    protected void checkNotEqual(Object expected, Object actual)
-    {
-        if (expected == null && actual == null)
-            assert false : "Objects should not match.";    
-        else if (expected != null && actual != null)
-            assert actual.equals(expected) == false : "Objects should not match.";    
-    }
-
-    protected void checkEncode(FSTransformObject obj, int[] bytes)
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes.length);
-        
-        checkEncode(coder, obj, bytes);
-    }
-    
-    protected void checkEncode(FSCoder coder, FSTransformObject obj, int[] bytes)
-    {
-        int length = obj.length(coder);
-        
-        if (obj instanceof FSMovieObject)
-            length += (length < 63) ? 2 : 6;
-        
-        coder.setPointer(0);
-        obj.encode(coder);
-        
-        assert (length == bytes.length) : "Calculated length does not match expected.";
-
-        compareData(coder.getData(), bytes);
-    }
-    
-    protected void checkDecode(FSCoder coder, int length)
-    {
-        int delta = (coder.getPointer() >>> 3) - length;
-        
-        if (delta < 0)
-            assert false : "Actual length is less than expected by "+(-delta)+" bytes.";
-        else if (delta > 0)
-            assert false : "Actual length is greater than expected by "+delta+" bytes.";
-    }
-    
-    protected void compareData(byte[] actual, int[] expected)
-    {
-        int delta = actual.length - expected.length;
-        
-        if (delta < 0)
-            assert false : "Actual length is less than expected by "+(-delta)+" bytes.";
-        else if (delta > 0)
-            assert false : "Actual length is greater than expected by "+delta+" bytes.";
-        
-        for (int i=0; i<expected.length; i++) {
-            assert(actual[i] == (byte)expected[i]) : "Encoded byte does not match expected value";
-        }
-    }
-
-    protected byte[] compact(int[] ints)
-    {
-        byte[] bytes = new byte[ints.length];
-        
-        for (int i=0; i<ints.length; i++)
-            bytes[i] = (byte)ints[i];
-        
-        return bytes;
-    }
-}

Modified: trunk/src/com/flagstone/transform/test/FSColorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSColorTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSColorTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,302 +1,209 @@
 /*
  * FSColorTest.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package com.flagstone.transform.test;
 
-import com.flagstone.transform.*;
+import com.flagstone.transform.FSColor;
+import com.flagstone.transform.FSCoder;
 
-public class FSColorTest extends FSClassTest
-{    
-    private static int[][] opaque = new int[][] {
-        {  0,   0,   0},
-        { 51,   0,   0},
-        { 51, 102,   0},
-        {  0, 102,   0},
-        {  0, 102, 153},
-        {  0,   0, 153},
-        { 51,   0, 153},
-        { 51, 102, 153},
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
+public class FSColorTest extends TestCase
+{
+    private static int[][] rgb = new int[][] {
+        {0x00, 0x00, 0x00},
+        {0x33, 0x00, 0x00},
+        {0x33, 0x66, 0x00},
+        {0x00, 0x66, 0x00},
+        {0x00, 0x66, 0xCC},
+        {0x00, 0x00, 0xCC},
+        {0x33, 0x00, 0xCC},
+        {0x33, 0x66, 0xCC},
     };
-    
-    private static int[][] alpha = new int[][] {
-        { 51, 102, 153,   0},
-        { 51, 102, 153, 204},
-        { 51,   0, 153, 204},
-        { 51,   0, 153,   0},
-        {  0,   0, 153,   0},
-        {  0,   0, 153, 204},
-        {  0, 102, 153, 204},
-        {  0, 102, 153,   0},
-        {  0, 102,   0,   0},
-        {  0, 102,   0, 204},
-        { 51, 102,   0, 204},
-        { 51, 102,   0,   0},
-        { 51,   0,   0,   0},
-        { 51,   0,   0, 204},
-        {  0,   0,   0, 204},
-        {  0,   0,   0,   0},
+
+    private static int[][] rgba = new int[][] {
+        { 0x33, 0x66, 0x99, 0x00},
+        { 0x33, 0x66, 0x99, 0x22},
+        { 0x33, 0x66, 0x99, 0x44},
+        { 0x33, 0x66, 0x99, 0x88},
     };
-    
-    private static FSColor[] colours = null;
-    private static FSColor[] coloursWithAlpha = null;
-    
-    public static FSColor[] colours()
+
+    public void testConstructors()
     {
-        if (colours == null)
-        {
-            colours = new FSColor[opaque.length];
-            
-            for (int i=0; i<opaque.length; i++) {
-                colours[i] = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2]);
-            }       
-       }
-       return colours;
-    }
-    
-    public static int[][] encodedColours()
-    {
-        int[][] data = new int[opaque.length][];
-        
-        for (int i=0; i<opaque.length; i++)
-        {
-            data[i] = new int[opaque[i].length];
-            
-            for (int j=0; j<opaque[i].length; j++) {
-                data[i][j] = opaque[i][j];
-            }
+        for (int i=0; i<rgb.length; i++) {
+            checkColours(new FSColor(rgb[i][0], rgb[i][1], rgb[i][2]), rgb[i]);
         }
-        return data;
+
+        for (int i=0; i<rgba.length; i++) {
+            checkColours(new FSColor(rgba[i][0], rgba[i][1], rgba[i][2], rgba[i][3]), rgba[i]);
+        }
     }
-    
-    public static FSColor[] coloursWithAlpha()
+
+    public void testCopyConstructors()
     {
-        if (coloursWithAlpha == null)
+        for (int i=0; i<rgb.length; i++)
         {
-            coloursWithAlpha = new FSColor[alpha.length];
-            
-            for (int i=0; i<alpha.length; i++) 
-            {
-                coloursWithAlpha[i] = new FSColor(alpha[i][0], alpha[i][1], alpha[i][2], alpha[i][3]);
-            }       
-       }
-       return colours;
-    }
-    
-    /**
-     * @testng.test groups="color, constructors"
-     */
-    public void checkConstructors()
-    {
-        FSColor colour = null;
-        
-        for (int i=0; i<opaque.length; i++) 
-        {
-            colour = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2]);
-            
-            checkColours(colour, opaque[i]);
+            FSColor colour = new FSColor(rgb[i][0], rgb[i][1], rgb[i][2]);
+            checkColours(new FSColor(colour), rgb[i]);
         }
-    }   
-    /**
-     * @testng.test groups="color, constructors"
-     */
-    public void checkConstructorsWithAlpha()
-    {
-        FSColor colour = null;
-        
-        for (int i=0; i<alpha.length; i++) 
+
+        for (int i=0; i<rgba.length; i++)
         {
-            colour = new FSColor(alpha[i][0], alpha[i][1], alpha[i][2], alpha[i][3]);
-            
-            checkColours(colour, alpha[i]);
+            FSColor colour = new FSColor(rgba[i][0], rgba[i][1], rgba[i][2], rgba[i][3]);
+            checkColours(new FSColor(colour), rgba[i]);
         }
     }
-    /**
-     * @testng.test groups="color, constructors"
-     */
-    public void checkCopyConstructors()
+
+    public void testAccessors()
     {
-        for (int i=0; i<opaque.length; i++) 
-        {
-            FSColor colour = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2]);
-            
-            checkColours(new FSColor(colour), opaque[i]);
-        }
-   }    
-    /**
-     * @testng.test groups="color, constructors"
-     */
-    public void checkCopyConstructorsWithAlpha()
-    {
-        for (int i=0; i<alpha.length; i++) 
-        {
-            FSColor colour = new FSColor(alpha[i][0], alpha[i][1], alpha[i][2], alpha[i][3]);
-            
-            checkColours(new FSColor(colour), alpha[i]);
-        }
-    }    
-    /**
-     * @testng.test groups="color, accessors"
-     */
-    public void checkAccessors()
-    {
         FSColor colour = new FSColor(-1, -1, -1);
-        
-        for (int i=0; i<opaque.length; i++) 
+
+        for (int i=0; i<rgb.length; i++)
         {
-            colour.setRed(opaque[i][0]);
-            colour.setGreen(opaque[i][1]);
-            colour.setBlue(opaque[i][2]);
-            
-            checkColours(colour, opaque[i]);
+            colour.setRed(rgb[i][0]);
+            colour.setGreen(rgb[i][1]);
+            colour.setBlue(rgb[i][2]);
+
+            checkColours(colour, rgb[i]);
+
+            colour.setChannels(rgb[i][0], rgb[i][1], rgb[i][2]);
+
+            checkColours(colour, rgb[i]);
         }
 
-        colour = new FSColor(-1, -1, -1);
-        
-        for (int i=0; i<opaque.length; i++) 
+        for (int i=0; i<rgba.length; i++)
         {
-            colour.setChannels(opaque[i][0], opaque[i][1], opaque[i][2]);            
-            
-            checkColours(colour, opaque[i]);
+            colour.setRed(rgba[i][0]);
+            colour.setGreen(rgba[i][1]);
+            colour.setBlue(rgba[i][2]);
+            colour.setAlpha(rgba[i][3]);
+            checkColours(colour, rgba[i]);
+
+            colour.setChannels(rgba[i][0], rgba[i][1], rgba[i][2], rgba[i][3]);
+            checkColours(colour, rgba[i]);
         }
     }
-    /**
-     * @testng.test groups="color, accessors"
-     */
-    public void checkAccessorsWithAlpha()
+
+    public void testEquals()
     {
-        FSColor colour = new FSColor(-1, -1, -1, -1);
-        
-        for (int i=0; i<alpha.length; i++) 
+        for (int i=0; i<rgb.length; i++)
         {
-            colour.setRed(alpha[i][0]);
-            colour.setGreen(alpha[i][1]);
-            colour.setBlue(alpha[i][2]);
-            colour.setAlpha(alpha[i][3]);
-            
-            checkColours(colour, alpha[i]);
-        }
+            int next = (i+1)%rgb.length;
 
-        colour = new FSColor(-1, -1, -1, -1);
-        
-        for (int i=0; i<alpha.length; i++) 
-        {
-            colour.setChannels(alpha[i][0], alpha[i][1], alpha[i][2], alpha[i][3]);
-            
-            checkColours(colour, alpha[i]);
+            FSColor a = new FSColor(rgb[i][0], rgb[i][1], rgb[i][2]);
+
+            FSColor b = new FSColor(rgb[i][0], rgb[i][1], rgb[i][2]);
+            FSColor c = new FSColor(rgb[next][0], rgb[next][1], rgb[next][2]);
+            FSColor d = new FSColor(rgb[i][0], rgb[i][1], rgb[i][2], 0xFF);
+            FSColor e = new FSColor(rgb[i][0], rgb[i][1], rgb[i][2], 0x80);
+
+            assertEquals(a,b);
+            assertTrue(!a.equals(c));
+            assertEquals(a,d);
+            assertTrue(!a.equals(e));
         }
     }
-    /**
-     * @testng.test groups="color, utilities"
-     */
-    public void checkEquals()
+
+    public void testEncode()
     {
-       for (int i=0; i<opaque.length; i++)
+        FSCoder coder;
+        FSColor colour;
+
+        for (int i=0; i<rgb.length; i++)
         {
-            int next = (i+1)%opaque.length;
-            
-            FSColor a = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2]);
-            FSColor b = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2]);
-            FSColor c = new FSColor(opaque[next][0], opaque[next][1], opaque[next][2]);
-            FSColor d = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2], 255);
-            FSColor e = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2], 128);
-            
-            checkEqual(a, b);
-            checkNotEqual(a, c);
-            checkEqual(a, d);
-            checkNotEqual(a, e);
+        	coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+
+            colour = new FSColor(rgb[i][0], rgb[i][1], rgb[i][2]);
+            colour.encode(coder);
+
+            assertTrue(coder.equals(initCoder(rgb[i], true)));
+            checkColours(colour, rgb[i]);
         }
-    }
-    /**
-     * @testng.test groups="color, encode"
-     */
-    public void checkEncode()
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
-             
-        for (int i=0; i<opaque.length; i++) 
+
+        for (int i=0; i<rgba.length; i++)
         {
-            FSColor colour = new FSColor(opaque[i][0], opaque[i][1], opaque[i][2]);
-            
-            checkEncode(coder, colour, opaque[i]);
-            checkColours(colour, opaque[i]);
+        	coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+            coder.setContext(FSCoder.TransparentColors, 1);
+
+            colour = new FSColor(rgba[i][0], rgba[i][1], rgba[i][2], rgba[i][3]);
+            colour.encode(coder);
+
+            assertTrue(coder.equals(initCoder(rgba[i], true)));
+            checkColours(colour, rgba[i]);
         }
     }
-    /**
-     * @testng.test groups="color, encode"
-     */
-    public void checkEncodeWithAlpha()
+
+    public void testDecode()
     {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
-        coder.setContext(FSCoder.TransparentColors, 1);
-             
-        for (int i=0; i<alpha.length; i++) 
+        for (int i=0; i<rgb.length; i++)
         {
-            FSColor colour = new FSColor(alpha[i][0], alpha[i][1], alpha[i][2], alpha[i][3]);
-            
-            checkEncode(coder, colour, alpha[i]);
-            checkColours(colour, alpha[i]);
+            FSCoder coder = initCoder(rgb[i], false);
+            FSColor colour = new FSColor(coder);
+
+            assertEquals(coder.getPointer() >> 3, rgb[i].length);
+            checkColours(colour, rgb[i]);
         }
-    }
-    /**
-     * @testng.test groups="color, decode"
-     */
-    public void checkDecode()
-    {
-        for (int i=0; i<opaque.length; i++) 
+
+        for (int i=0; i<rgba.length; i++)
         {
-            FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, compact(opaque[i]));            
-            checkColours(new FSColor(coder), opaque[i]);
-            checkDecode(coder, opaque[i].length);
+            FSCoder coder = initCoder(rgba[i], false);
+            coder.setContext(FSCoder.TransparentColors, 1);
+            FSColor colour = new FSColor(coder);
+
+            assertEquals(coder.getPointer() >> 3, rgba[i].length);
+            checkColours(colour, rgba[i]);
         }
     }
-    /**
-     * @testng.test groups="color, decode"
-     */
-    public void checkDecodeWithAlpha()
+
+    private void checkColours(FSColor colour, int[] expected)
     {
-        for (int i=0; i<opaque.length; i++) 
-        {
-            FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, compact(alpha[i]));            
-            coder.setContext(FSCoder.TransparentColors, 1);
+    	assertTrue("Red channel does not match expected value", colour.getRed() == expected[0]);
+    	assertTrue("Green channel does not match expected value", colour.getGreen() == expected[1]);
+    	assertTrue("Blue channel does not match expected value", colour.getBlue() == expected[2]);
 
-            checkColours(new FSColor(coder), alpha[i]);
-            checkDecode(coder, alpha[i].length);
+        if (expected.length == 4) {
+        	assertTrue("Alpha channel does not match expected value", colour.getAlpha() == expected[3]);
         }
     }
     
-    private void checkColours(FSColor colour, int[] expected)
+    private FSCoder initCoder(int[] data, boolean atEnd)
     {
-        assert(colour.getRed() == expected[0]) : "Red channel does not match expected value";
-        assert(colour.getGreen() == expected[1]) : "Green channel does not match expected value";
-        assert(colour.getBlue() == expected[2]) : "Blue channel does not match expected value";
-        
-        if (expected.length == 4)
-            assert(colour.getAlpha() == expected[3]) : "Alpha channel does not match expected value";
+    	FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+
+        for (int i=0; i<data.length; i++) {
+            coder.writeWord(data[i], 1);
+        }
+
+        if (!atEnd) {
+        	coder.setPointer(0);
+        }
+        return coder;
     }
 }

Modified: trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSImageConstructorTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,96 +1,103 @@
 package com.flagstone.transform.test;
 
-import java.io.*;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.zip.DataFormatException;
 
 import com.flagstone.transform.*;
 import com.flagstone.transform.util.*;
 
-public class FSImageConstructorTest
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
+public class FSImageConstructorTest extends TestCase
 {
     private File sourceDir = null;
     private File destDir = null;
     private String extension = null;
-    
-    public FSImageConstructorTest()
+
+    public void testBMP()
     {
+		sourceDir = new File("test/data/bmp");
+		destDir = new File("test/results/FSImageConstructor/bmp");
+		extension = "bmp";
+
+		displayImage();
     }
-    /**
-     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
-     * @testng.parameters value = "srcDir dstDir ext"
-     */
-    public void configure(String srcDir, String dstDir, String ext)
+
+    public void testPNG()
     {
-        sourceDir = new File(srcDir);
-        destDir = new File(dstDir);
-        extension = ext;
+		sourceDir = new File("test/data/png");
+		destDir = new File("test/results/FSImageConstructor/png");
+		extension = "png";
+
+		displayImage();
     }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void displayImage(File imageFile)
+
+    public void displayImage()
     {
-        try 
+        File sourceFile = null;
+        File destFile = null;
+
+        try
         {
-            String fileName = imageFile.getName();
-            fileName = fileName.substring(0, fileName.lastIndexOf('.')) + ".swf";
-    
-            File destFile = new File(destDir, fileName);
- 
+            FilenameFilter filter = new FilenameFilter()
+            {
+                public boolean accept(File directory, String name)
+                {
+                    String ext = name.substring(name.length()-extension.length()).toLowerCase();
+
+                    return ext.equals(extension);
+                }
+            };
+
+            assertTrue(sourceDir.exists());
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            FSImageConstructor imageConstructor = new FSImageConstructor(imageFile.getPath());
-            encodeImageToFile(imageConstructor, destFile);
+                assertTrue("Count not create directory: "+destDir, destDir.mkdirs());
+
+            String[] files = sourceDir.list(filter);
+
+            for (int i=0; i<files.length; i++)
+            {
+            	try
+            	{
+	                sourceFile = new File(sourceDir, files[i]);
+	                destFile = new File(destDir, files[i].substring(0, files[i].lastIndexOf('.')) + ".swf");
+	
+	                FSImageConstructor imageConstructor = new FSImageConstructor(sourceFile.getPath());
+	                encodeImageToFile(imageConstructor, destFile);
+            	}
+            	catch (DataFormatException e)
+            	{
+            		if (!sourceFile.getName().startsWith("x")) {
+                        fail("Cannot decode file: "+sourceFile.getName() + ", "+e.toString());
+            		}      		
+            	}
+            }
         }
         catch (Exception e)
         {
-            assert false;
+        	fail(e.toString());
         }
     }
-    /**
-     * @testng.data-provider name="files"
-     */
-    public Object[][] findFiles()
-    {
-        FilenameFilter filter = new FilenameFilter() 
-        {
-            public boolean accept(File directory, String name) 
-            {
-                String ext = name.substring(name.length()-extension.length()).toLowerCase();
-                
-                return ext.equals(extension);
-            }
-        };
-        
-        Object[][] parameters = new Object[0][0];
-        
-        if (sourceDir.exists())
-        {
-            String[] files = sourceDir.list(filter);
-            
-            parameters = new Object[files.length][1];
-            
-            for (int i=0; i<files.length; i++)
-                parameters[i] = new Object[] { new File(sourceDir, files[i]) };
-        }
-        return parameters;
-    }
+
     private void encodeImageToFile(FSImageConstructor generator, File file) throws Exception
     {
         FSMovie movie = new FSMovie();
-        
+
         int imageId = movie.newIdentifier();
         int shapeId = movie.newIdentifier();
-        
+
         int xOrigin = generator.getWidth()/2;
         int yOrigin = generator.getHeight()/2;
-        
+
         FSSolidLine borderStyle = new FSSolidLine(20, FSColorTable.black());
-        
+
         FSDefineObject image = generator.defineImage(imageId);
-        FSDefineShape3 shape = generator.defineEnclosingShape(shapeId, imageId, 
+        FSDefineShape3 shape = generator.defineEnclosingShape(shapeId, imageId,
             -xOrigin, -yOrigin, borderStyle);
-        
+
         movie.setFrameRate(1.0f);
         movie.setFrameSize(shape.getBounds());
         movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
@@ -98,7 +105,7 @@
         movie.add(shape);
         movie.add(new FSPlaceObject2(shapeId, 1, 0, 0));
         movie.add(new FSShowFrame());
-        
+
         movie.encodeToFile(file.getPath());
     }
 }

Added: trunk/src/com/flagstone/transform/test/FSMovieBenchmark.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSMovieBenchmark.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSMovieBenchmark.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -0,0 +1,309 @@
+/*
+ * FSMovieTest.java
+ * Transform
+ *
+ * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.flagstone.transform.test;
+
+import java.io.*;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import com.flagstone.transform.*;
+
+public class FSMovieBenchmark extends TestCase
+{
+    private static String newline = System.getProperty("line.separator");
+    private static int iterations = 1000;
+
+    /**
+     * The main method allows the tests to be run outside of the JUnit
+     * environment. Usage:
+     *
+     *  FSMovieBenchmark <source> <dest>
+     *
+     *  where,
+     *
+     *   <source> - the source directory where the flash files may be found.
+     *   <dest> - the destination directory where files will be written to.
+     *
+     * @param args arguments passed to the class when executed.
+     */
+    public static void main(String[] args)
+    {
+        junit.textui.TestRunner.run(suite(args[0], args[1]));
+    }
+
+    public static Test suite(String source, String dest)
+    {
+        TestSuite suite= new TestSuite();
+        suite.addTest(new FSMovieBenchmark(source, dest, "testDecode"));
+        suite.addTest(new FSMovieBenchmark(source, dest, "testEncode"));
+        suite.addTest(new FSMovieBenchmark(source, dest, "testClone"));
+        suite.addTest(new FSMovieBenchmark(source, dest, "testLazyDecode"));
+        suite.addTest(new FSMovieBenchmark(source, dest, "testLazyEncode"));
+        return suite;
+    }
+
+    private File sourceDir;
+    private File destDir;
+    
+    private String[] files;
+    private File log;
+    private StringBuffer buffer;
+
+    public FSMovieBenchmark()
+    {
+        sourceDir = new File("test/data/swf");
+        destDir = new File("test/results/Benchmark");
+    }
+
+    public FSMovieBenchmark(String srcDir, String dstDir, String method)
+    {
+    	super(method);
+
+    	sourceDir = new File(srcDir);
+        destDir = new File(dstDir);
+    }
+
+    protected void setUp()
+    {
+        FilenameFilter filter = new FilenameFilter()
+        {
+            public boolean accept(File directory, String name) {
+                return name.endsWith(".swf");
+            }
+        };
+
+        assertTrue("Source directory does not exist", sourceDir.exists());
+
+        files = sourceDir.list(filter);
+
+        if (!destDir.exists()) {
+            assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+        }
+
+        buffer = new StringBuffer();
+    }
+
+    protected void tearDown()
+    {
+        if (log != null)
+        {
+            try
+            {
+                FileOutputStream stream = new FileOutputStream(log);
+                stream.write(buffer.toString().getBytes());
+                stream.close();
+            }
+            catch (IOException e)
+            {
+                fail("Cannot write log file: "+log.getPath());
+            }
+        }
+    }
+
+    public void testBenchmarkDecode()
+    {       
+        log = new File(destDir, "decode.log");
+
+        for (int i=0; i<files.length; i++)
+    	{
+            try
+            {
+                File swfFile = new File(sourceDir, files[i]);
+
+                byte[] bytes = new byte[(int)swfFile.length()];
+
+                FileInputStream stream = new FileInputStream(swfFile);
+                stream.read(bytes);
+                stream.close();
+
+                System.gc();
+
+                double before = (double)System.currentTimeMillis();
+
+                for (int j=0; j<iterations; j++)
+                {
+                    new FSMovie().decodeFromData(bytes);
+                }
+
+                double duration = (System.currentTimeMillis() - before)/(double)iterations;
+
+                buffer.append(files[i]);
+                
+                int count = 35-files[i].length() - ((duration > 10) ? 1 : 0);
+                
+                for (int k=0; k<count; k++) {
+                	buffer.append(' ');
+                }
+                
+                buffer.append(duration).append(newline);
+            }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
+            }
+    	}
+    }
+
+    public void testBenchmarkEncode()
+    {
+        log = new File(destDir, "encode.log");
+
+    	for (int i=0; i<files.length; i++)
+    	{
+            try
+            {
+                File srcFile = new File(sourceDir, files[i]);
+
+                FSMovie movie = new FSMovie(srcFile.getPath());
+
+                System.gc();
+
+                double before = (double)System.currentTimeMillis();
+
+                for (int j=0; j<iterations; j++)
+                {
+                    movie.encode();
+                }
+
+                double duration = (System.currentTimeMillis() - before)/(double)iterations;
+
+                buffer.append(files[i]);
+                
+                int count = 35-files[i].length() - ((duration > 10) ? 1 : 0);
+                
+                for (int k=0; k<count; k++) {
+                	buffer.append(' ');
+                }
+
+                buffer.append(duration).append(newline);
+            }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
+            }
+    	}
+    }
+
+    public void testBenchmarkLazyDecode()
+    {
+        log = new File(destDir, "lazy_decode.log");
+
+    	for (int i=0; i<files.length; i++)
+    	{
+            try
+            {
+                File swfFile = new File(sourceDir, files[i]);
+
+                byte[] bytes = new byte[(int)swfFile.length()];
+
+                FileInputStream stream = new FileInputStream(swfFile);
+                stream.read(bytes);
+                stream.close();
+
+                System.gc();
+
+                double before = (double)System.currentTimeMillis();
+
+                for (int j=0; j<iterations; j++)
+                {
+                    FSMovie movie = new FSMovie();
+                    movie.setDecodeActions(false);
+                    movie.setDecodeShapes(false);
+                    movie.setDecodeGlyphs(false);
+                    movie.decodeFromData(bytes);
+                }
+
+                double duration = (System.currentTimeMillis() - before)/(double)iterations;
+
+                buffer.append(files[i]);
+                
+                int count = 35-files[i].length() - ((duration > 10) ? 1 : 0);
+                
+                for (int k=0; k<count; k++) {
+                	buffer.append(' ');
+                }
+
+                buffer.append(duration).append(newline);
+            }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
+            }
+    	}
+    }
+
+    public void testBenchmarkLazyEncode()
+    {
+        log = new File(destDir, "lazy_encode.log");
+
+    	for (int i=0; i<files.length; i++)
+    	{
+            try
+            {
+                File srcFile = new File(sourceDir, files[i]);
+
+                FSMovie movie = new FSMovie();
+
+                movie.setDecodeActions(false);
+                movie.setDecodeShapes(false);
+                movie.setDecodeGlyphs(false);
+
+                movie.decodeFromFile(srcFile.getPath());
+
+                System.gc();
+
+                double before = (double)System.currentTimeMillis();
+
+                for (int j=0; j<iterations; j++)
+                {
+                    movie.encode();
+                }
+
+                double duration = (System.currentTimeMillis() - before)/(double)iterations;
+
+                buffer.append(files[i]);
+                
+                int count = 35-files[i].length() - ((duration > 10) ? 1 : 0);
+                
+                for (int k=0; k<count; k++) {
+                	buffer.append(' ');
+                }
+
+                buffer.append(duration).append(newline);
+            }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
+            }
+    	}
+    }
+}

Modified: trunk/src/com/flagstone/transform/test/FSMovieTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSMovieTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSMovieTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,435 +1,230 @@
 /*
  * FSMovieTest.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package com.flagstone.transform.test;
 
 import java.io.*;
-import java.lang.reflect.*;
 
 import com.flagstone.transform.*;
-import com.flagstone.transform.tools.*;
 
-public class FSMovieTest
+import junit.framework.Assert;
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+public class FSMovieTest extends TestCase
 {
-    private static String newline = System.getProperty("line.separator");
-    private static int iterations = 100;
-    
     /**
-     * The main method allows the tests to be run outside of the TestNG 
-     * environment. Usage:
-     * 
-     *  FSMovieTest --test <name> --src <path> [--dst <path>] [--log <path>]
-     *  
+     * The main method allows the tests to be run from the command line:
+     *
+     *  FSMovieTest <source> <dest>
+     *
      *  where,
-     * 
-     *   --tst <name> - the name of the test to be executed.
-     *   --src <path> - the source directory where the flash files may be found.
-     *   --dst <path> - the destination directory where files will be written to.
-     *   --log <path> - the path to a log file where information about the test is recorded. optional.
-     *   
-     * The --dst option is not used when tests decoding Flash files are run.
-     * The --log option is only used when running the benchmark tests.
-     *   
+     *
+     *   <source> the source directory where the flash files may be found.
+     *   <dest>   the destination directory where files will be written to.
+     *
      * @param args arguments passed to the class when executed.
      */
     public static void main(String[] args)
     {
-        try
-        {
-            String testName = null;
-            String srcPath = null;
-            String dstPath = null;
-            String logPath = null;
-            
-            int count = args.length-1;
-            
-            for (int i=0; i<count; i++)
-            {
-                if (args[i].equals("--tst"))
-                    testName = args[i+1];
-                else if (args[i].equals("--src"))
-                    srcPath = args[i+1];
-                else if (args[i].equals("--dest"))
-                    dstPath = args[i+1];
-                else if (args[i].equals("--log"))
-                    logPath = args[i+1];
-            }
-            
-            FSMovieTest test = new FSMovieTest();
-            Method method = test.getClass().getMethod(testName, new Class[] { String.class });        
-            
-            test.configure(srcPath, dstPath, logPath);
-            Object[][] files = test.findFiles();
-    
-            for (int i=0; i<files.length; i++) {
-                method.invoke(test, files[i]);
-            }
-            
-            test.finish();
-        }
-        catch (Throwable t)
-        {
-            System.err.println(t);
-        }
+        junit.textui.TestRunner.run(suite(args[0], args[1]));
     }
-    
+
+    public static Test suite(String source, String dest)
+    {
+        TestSuite suite= new TestSuite();
+
+        suite.addTest(new FSMovieTest(source, dest, "testDecode"));
+        suite.addTest(new FSMovieTest(source, dest, "testEncode"));
+        suite.addTest(new FSMovieTest(source, dest, "testClone"));
+        suite.addTest(new FSMovieTest(source, dest, "testLazyDecode"));
+        suite.addTest(new FSMovieTest(source, dest, "testLazyEncode"));
+
+        return suite;
+    }
+
     private File sourceDir = null;
     private File destDir = null;
-    private File log = null;
-    
-    private StringBuffer buffer = null;
-    
-    private String extension = ".swf";
-    
+    private String[] files = null;
+
     public FSMovieTest()
     {
+        sourceDir = new File("test/data/swf");
+        destDir = new File("test/results/FSMovie");
     }
-    /**
-     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
-     * @testng.parameters value = "srcDir dstDir logFile"
-     */
-    public void configure(String srcDir, String dstDir, String logFile)
+
+    public FSMovieTest(String srcDir, String dstDir, String method)
     {
-        assert srcDir != null && srcDir.length() > 0 : "No source directory specified";
-        
-        sourceDir = new File(srcDir);
+    	super(method);
 
-        if (dstDir != null && dstDir.length() > 0)
+    	sourceDir = new File(srcDir);
+        destDir = new File(dstDir);
+    }
+
+    protected void setUp()
+    {
+        FilenameFilter filter = new FilenameFilter()
         {
-            destDir = new File(dstDir);
-            
-            if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create destination directory: "+destDir;
+            public boolean accept(File directory, String name) {
+                return name.endsWith(".swf");
+            }
+        };
+
+        assertTrue("Source directory does not exist", sourceDir.exists());
+
+        files = sourceDir.list(filter);
+
+        if (destDir.exists() == false) {
+            assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
         }
-            
-        if (logFile != null && logFile.length() > 0)
-        {
-            log = new File(logFile);
-            buffer = new StringBuffer();
-        }
     }
-    /**
-     * @testng.configuration afterTest = "true" alwaysRun = "true" 
-     */
-    public void finish()
+
+    public void testDecode()
     {
-        if (log != null)
-        {
+    	for (int i=0; i<files.length; i++)
+    	{
             try
             {
-                FileOutputStream stream = new FileOutputStream(log);
-                stream.write(buffer.toString().getBytes());
-                stream.close();
+                new FSMovie(new File(sourceDir, files[i]).getPath());
             }
-            catch (IOException e)
+            catch (Exception e)
             {
-                assert false : "Cannot write log file: "+log.getPath();
+                fail(files[i]+": "+e.toString());
             }
-        }
+    	}
     }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void decode(String file)
-    {
-        try 
-        {
-            new FSMovie(new File(sourceDir, file).getPath());
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void encode(String file)
-    {
-        try 
-        {
-            File srcFile = new File(sourceDir, file);
-            File destFile = new File(destDir, file);
-            
-            FSMovie movie = new FSMovie(srcFile.getPath());
 
-            movie.encodeToFile(destFile.getPath());
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void lazyDecode(String file)
+    public void testEncode()
     {
-        try 
-        {
-            File srcFile = new File(sourceDir, file);
-            
-            FSMovie movie = new FSMovie();
-            
-            movie.setDecodeActions(false);
-            movie.setDecodeShapes(false);
-            movie.setDecodeGlyphs(false);
-            
-            movie.decodeFromFile(srcFile.getPath());            
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void lazyEncode(String file)
-    {
-        try 
-        {
-            File srcFile = new File(sourceDir, file);
-            File destFile = new File(destDir, file);
-            
-            FSMovie movie = new FSMovie();
-            
-            movie.setDecodeActions(false);
-            movie.setDecodeShapes(false);
-            movie.setDecodeGlyphs(false);
-            
-            movie.decodeFromFile(srcFile.getPath());            
- 
-            movie.encodeToFile(destFile.getPath());
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void clone(String file)
-    {
-        try 
-        {
-            File srcFile = new File(sourceDir, file);
-            File destFile = new File(destDir, file);
-            
-            FSMovie movie = new FSMovie(srcFile.getPath());
-            
-            FSMovie clone = (FSMovie)movie.clone();
-            clone.encodeToFile(destFile.getPath());
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void toText(String file)
-    {
-        try
-        {
-            File srcFile = new File(sourceDir, file);
-            File dstFile = new File(destDir, file.substring(0, file.length()-3)+"txt");
-            
-            new TextDump(new String[] {
-                            "--fileIn", srcFile.getPath(), 
-                            "--fileOut", dstFile.getPath()});
-        }
-        catch (Throwable e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
+		File dir = new File(destDir, "encode");
 
-    /*
-     * Methods for benchmarking
-     */
-    
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void benchmarkDecode(String file)
-    {
-        try 
-        {
-            File swfFile = new File(sourceDir, file);
-            
-            byte[] bytes = new byte[(int)swfFile.length()];
-            
-            FileInputStream stream = new FileInputStream(swfFile);            
-            stream.read(bytes);
-            stream.close();
-            
-            System.gc();
-            
-            double before = (double)System.currentTimeMillis();
-            
-            for (int i=0; i<iterations; i++)
+		if (!dir.exists()) {
+			assertTrue(dir.mkdirs());
+		}
+
+		for (int i=0; i<files.length; i++)
+    	{
+            try
             {
-                new FSMovie().decodeFromData(bytes);
+                File srcFile = new File(sourceDir, files[i]);
+                File destFile = new File(dir, files[i]);
+
+                FSMovie movie = new FSMovie(srcFile.getPath());
+
+                movie.encodeToFile(destFile.getPath());
             }
-            
-            double duration = (System.currentTimeMillis() - before)/(double)iterations;
-            
-            buffer.append(file).append('\t').append(duration).append(newline);
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
+            }
+    	}
     }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void benchmarkEncode(String file)
+
+    public void testClone()
     {
-        try 
-        {
-            File srcFile = new File(sourceDir, file);
-           
-            FSMovie movie = new FSMovie(srcFile.getPath());
+		File dir = new File(destDir, "clone");
 
-            System.gc();
-            
-            double before = (double)System.currentTimeMillis();
-            
-            for (int i=0; i<iterations; i++)
+		if (!dir.exists()) {
+			assertTrue(dir.mkdirs());
+		}
+
+    	for (int i=0; i<files.length; i++)
+    	{
+            try
             {
-                movie.encode();
+                File srcFile = new File(sourceDir, files[i]);
+                File destFile = new File(dir, files[i]);
+
+                FSMovie movie = new FSMovie(srcFile.getPath());
+
+                FSMovie clone = (FSMovie)movie.clone();
+                clone.encodeToFile(destFile.getPath());
+           }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
             }
-            
-            double duration = (System.currentTimeMillis() - before)/(double)iterations;
-            
-            buffer.append(file).append('\t').append(duration).append(newline);
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
+    	}
     }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void benchmarkLazyDecode(String file)
+
+    public void testLazyDecode()
     {
-        try 
-        {
-            File swfFile = new File(sourceDir, file);
-            
-            byte[] bytes = new byte[(int)swfFile.length()];
-            
-            FileInputStream stream = new FileInputStream(swfFile);            
-            stream.read(bytes);
-            stream.close();
-            
-            System.gc();
-            
-            double before = (double)System.currentTimeMillis();
-            
-            for (int i=0; i<iterations; i++)
+    	for (int i=0; i<files.length; i++)
+    	{
+            try
             {
+                File srcFile = new File(sourceDir, files[i]);
+
                 FSMovie movie = new FSMovie();
+
                 movie.setDecodeActions(false);
                 movie.setDecodeShapes(false);
                 movie.setDecodeGlyphs(false);
-                movie.decodeFromData(bytes);
+
+                movie.decodeFromFile(srcFile.getPath());
             }
-            
-            double duration = (System.currentTimeMillis() - before)/(double)iterations;
-            
-            buffer.append(file).append('\t').append(duration).append(newline);
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void benchmarkLazyEncode(String file)
-    {
-        try 
-        {
-            File srcFile = new File(sourceDir, file);
-            
-            FSMovie movie = new FSMovie();
-            
-            movie.setDecodeActions(false);
-            movie.setDecodeShapes(false);
-            movie.setDecodeGlyphs(false);
-            
-            movie.decodeFromFile(srcFile.getPath());            
- 
-            System.gc();
-            
-            double before = (double)System.currentTimeMillis();
-            
-            for (int i=0; i<iterations; i++)
+            catch (Exception e)
             {
-                movie.encode();
+                fail(files[i]+": "+e.toString());
             }
-            
-            double duration = (System.currentTimeMillis() - before)/(double)iterations;
-            
-            buffer.append(file).append('\t').append(duration).append(newline);
-        }
-        catch (Exception e)
-        {
-            assert false : file+": "+e.toString();
-        }
+    	}
     }
-    /**
-     * @testng.data-provider name="files"
-     */
-    public Object[][] findFiles()
+
+    public void testLazyEncode()
     {
-        FilenameFilter filter = new FilenameFilter() 
-        {
-            public boolean accept(File directory, String name) {
-                return name.endsWith(extension);
-            }
-        };
-        
-        String[] files = sourceDir.list(filter);       
+		File dir = new File(destDir, "lazyEncode");
 
-        Object[][] parameters = new Object[files.length][1];
-        
-        for (int i=0; i<files.length; i++)
-            parameters[i] = new Object[] { files[i] };
-        
-        return parameters;
+		if (!dir.exists()) {
+			assertTrue(dir.mkdirs());
+		}
+
+		for (int i=0; i<files.length; i++)
+    	{
+            try
+            {
+                File srcFile = new File(sourceDir, files[i]);
+                File destFile = new File(dir, files[i]);
+
+                FSMovie movie = new FSMovie();
+
+                movie.setDecodeActions(false);
+                movie.setDecodeShapes(false);
+                movie.setDecodeGlyphs(false);
+
+                movie.decodeFromFile(srcFile.getPath());
+                movie.encodeToFile(destFile.getPath());
+            }
+            catch (Exception e)
+            {
+                fail(files[i]+": "+e.toString());
+            }
+    	}
     }
 }

Modified: trunk/src/com/flagstone/transform/test/FSProtectTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSProtectTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSProtectTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,159 +1,165 @@
 /*
  * FSProtectTest.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package com.flagstone.transform.test;
 
-import com.flagstone.transform.*;
+import com.flagstone.transform.FSMovieObject;
+import com.flagstone.transform.FSProtect;
+import com.flagstone.transform.FSCoder;
 
-public class FSProtectTest extends FSClassTest
-{    
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
+public class FSProtectTest extends TestCase
+{
     private static String[] passwords = new String[] {
         null,
         "",
         "5F4DCC3B5AA765D61D8327DEB882CF99", // "password"
     };
-           
+
     private static int[][] encodedObjects = new int[][] {
-        { 0x00, 0x06 },         
-        { 0x00, 0x06 },         
-        { 0x23, 0x06, 0x00, 0x00, 
-          0x35, 0x46, 0x34, 0x44, 0x43, 0x43, 0x33, 0x42, 
-          0x35, 0x41, 0x41, 0x37, 0x36, 0x35, 0x44, 0x36, 
-          0x31, 0x44, 0x38, 0x33, 0x32, 0x37, 0x44, 0x45, 
-          0x42, 0x38, 0x38, 0x32, 0x43, 0x46, 0x39, 0x39, 0x00}, 
+        { 0x00, 0x06 },
+        { 0x00, 0x06 },
+        { 0x23, 0x06, 0x00, 0x00,
+          0x35, 0x46, 0x34, 0x44, 0x43, 0x43, 0x33, 0x42,
+          0x35, 0x41, 0x41, 0x37, 0x36, 0x35, 0x44, 0x36,
+          0x31, 0x44, 0x38, 0x33, 0x32, 0x37, 0x44, 0x45,
+          0x42, 0x38, 0x38, 0x32, 0x43, 0x46, 0x39, 0x39, 0x00},
     };
-    
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkConstructors()
+
+    public void testConstructors()
     {
         for (int i=0; i<passwords.length; i++)
         {
             FSProtect background = new FSProtect(passwords[i]);
-            
-            checkType(FSMovieObject.Protect, background.getType());
-            checkEqual(passwords[i], background.getPassword());
+
+            assertEquals(FSMovieObject.Protect, background.getType());
+            assertEquals(passwords[i], background.getPassword());
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkCopyConstructor()
+
+    public void testCopyConstructor()
     {
         for (int i=0; i<passwords.length; i++)
         {
             FSProtect original = new FSProtect(passwords[i]);
             FSProtect copy = new FSProtect(original);
-            
-            checkEqual(passwords[i], copy.getPassword());
-            checkNotIdentical(passwords[i], copy.getPassword());
+
+            assertEquals(passwords[i], copy.getPassword());
+            assertNotSame(passwords[i], copy.getPassword());
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkClone()
+
+    public void testClone()
     {
         for (int i=0; i<passwords.length; i++)
         {
             FSProtect original = new FSProtect(passwords[i]);
             FSProtect clone = (FSProtect)original.clone();
-            
-            checkEqual(original, clone);
-            checkNotIdentical(original, clone);
+
+            assertEquals(original, clone);
+            assertNotSame(original, clone);
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, accessors"
-     */
+
     public void checkAccessors()
     {
         FSProtect original = new FSProtect("");
-        
+
         for (int i=0; i<passwords.length; i++)
         {
             original.setPassword(passwords[i]);
-            checkEqual(passwords[i], original.getPassword());
+            assertEquals(passwords[i], original.getPassword());
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, utilities"
-     */
+
     public void checkEquals()
     {
         for (int i=0; i<passwords.length; i++)
         {
             FSProtect a = new FSProtect(passwords[i]);
             FSProtect b = new FSProtect(passwords[i]);
-            
-            checkEqual(a, b);
+
+            assertEquals(a, b);
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, encode"
-     */
-    public void checkEncode()
+
+    public void testEncode()
     {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);            
-        coder.setContext(FSCoder.Version, 5);
+        FSCoder coder;
 
-        for (int i=0; i<encodedObjects.length; i++) {
-            checkEncode(coder, new FSProtect(passwords[i]), encodedObjects[i]);
+        for (int i=0; i<encodedObjects.length; i++)
+        {
+            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+            new FSProtect(passwords[i]).encode(coder);
+
+            assertEquals(coder, initCoder(encodedObjects[i], true));
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, decode"
-     */
-    public void checkDecode()
-    {       
-        for (int i=0; i<encodedObjects.length; i++) 
+
+    public void testDecode()
+    {
+        for (int i=0; i<encodedObjects.length; i++)
         {
-            FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, compact(encodedObjects[i]));            
-            coder.setContext(FSCoder.Version, 5);
+            FSCoder coder = initCoder(encodedObjects[i], false);
 
             /*
              * If a password is an empty string then the object is encoded as
              * if the password was null. Therefore if the expected value is an
-             * empty string then it must be replaced by null for the test to 
+             * empty string then it must be replaced by null for the test to
              * pass.
              */
             String expectedValue = passwords[i];
-            
+
             if (expectedValue != null && expectedValue.length() == 0)
                 expectedValue = null;
 
             FSProtect obj = new FSProtect(coder);
-            
-            checkDecode(coder, encodedObjects[i].length);
-            checkType(FSMovieObject.Protect, obj.getType());
-            checkEqual(expectedValue, obj.getPassword());
+
+            assertEquals(coder.getPointer()>>>3, encodedObjects[i].length);
+            assertEquals(FSMovieObject.Protect, obj.getType());
+            assertEquals(expectedValue, obj.getPassword());
         }
     }
+    
+    private FSCoder initCoder(int[] data, boolean atEnd)
+    {
+    	FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+
+        for (int i=0; i<data.length; i++) {
+            coder.writeWord(data[i], 1);
+        }
+
+        if (!atEnd) {
+        	coder.setPointer(0);
+        }
+        return coder;
+    }
 }

Modified: trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSSetBackgroundColorTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,38 +1,45 @@
 /*
  * FSSetBackgroundColorTest.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package com.flagstone.transform.test;
 
-import com.flagstone.transform.*;
+import com.flagstone.transform.FSMovieObject;
+import com.flagstone.transform.FSProtect;
+import com.flagstone.transform.FSSetBackgroundColor;
+import com.flagstone.transform.FSColor;
+import com.flagstone.transform.FSCoder;
 
-public class FSSetBackgroundColorTest extends FSClassTest
-{    
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
+public class FSSetBackgroundColorTest extends TestCase
+{
     private static FSColor[] colours = new FSColor[] {
         new FSColor(  0,   0,   0),
         new FSColor(255,   0,   0),
@@ -43,115 +50,110 @@
         new FSColor(255,   0, 255),
         new FSColor(255, 255, 255),
     };
-           
+
     private static int[][] encodedObjects = new int[][] {
-        { 0x43, 0x02, 0x00, 0x00, 0x00 }, 
-        { 0x43, 0x02, 0xFF, 0x00, 0x00 }, 
-        { 0x43, 0x02, 0xFF, 0xFF, 0x00 }, 
-        { 0x43, 0x02, 0x00, 0xFF, 0x00 }, 
-        { 0x43, 0x02, 0x00, 0xFF, 0xFF }, 
-        { 0x43, 0x02, 0x00, 0x00, 0xFF }, 
-        { 0x43, 0x02, 0xFF, 0x00, 0xFF }, 
-        { 0x43, 0x02, 0xFF, 0xFF, 0xFF }, 
+        { 0x43, 0x02, 0x00, 0x00, 0x00 },
+        { 0x43, 0x02, 0xFF, 0x00, 0x00 },
+        { 0x43, 0x02, 0xFF, 0xFF, 0x00 },
+        { 0x43, 0x02, 0x00, 0xFF, 0x00 },
+        { 0x43, 0x02, 0x00, 0xFF, 0xFF },
+        { 0x43, 0x02, 0x00, 0x00, 0xFF },
+        { 0x43, 0x02, 0xFF, 0x00, 0xFF },
+        { 0x43, 0x02, 0xFF, 0xFF, 0xFF },
     };
-    
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkConstructors()
+
+    public void testConstructors()
     {
         for (int i=0; i<colours.length; i++)
         {
             FSSetBackgroundColor background = new FSSetBackgroundColor(colours[i]);
-            
-            checkType(FSMovieObject.SetBackgroundColor, background.getType());
-            checkEqual(colours[i], background.getColor());
+
+            assertEquals(FSMovieObject.SetBackgroundColor, background.getType());
+            assertEquals(colours[i], background.getColor());
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkCopyConstructor()
+
+    public void testCopyConstructor()
     {
         for (int i=0; i<colours.length; i++)
         {
             FSSetBackgroundColor original = new FSSetBackgroundColor(colours[i]);
             FSSetBackgroundColor copy = new FSSetBackgroundColor(original);
-            
-            checkEqual(colours[i], copy.getColor());
-            checkNotIdentical(colours[i], copy.getColor());
+
+            assertEquals(colours[i], copy.getColor());
+            assertNotSame(colours[i], copy.getColor());
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkContainsReference()
+
+    public void testClone()
     {
         FSColor colour = new FSColor(0, 0, 0);
         FSSetBackgroundColor background = new FSSetBackgroundColor(colour);
-        
-        checkIdentical(colour, background.getColor());
-    }
-    /**
-     * @testng.test groups="setbackgroundcolor, constructors"
-     */
-    public void checkClone()
-    {
-        FSColor colour = new FSColor(0, 0, 0);
-        FSSetBackgroundColor background = new FSSetBackgroundColor(colour);
         FSSetBackgroundColor clone = (FSSetBackgroundColor)background.clone();
-        
-        checkEqual(background, clone);
-        checkNotIdentical(background, clone);
+
+        assertEquals(background, clone);
+        assertNotSame(background, clone);
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, accessors"
-     */
-    public void checkAccessors()
+
+    public void testAccessors()
     {
         FSSetBackgroundColor background = new FSSetBackgroundColor(new FSColor(-1, -1, -1));
-        
+
         for (int i=0; i<colours.length; i++)
         {
             background.setColor(colours[i]);
-            checkEqual(colours[i], background.getColor());
+            assertEquals(colours[i], background.getColor());
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, utilities"
-     */
-    public void checkEquals()
+
+    public void testEquals()
     {
         for (int i=0; i<colours.length; i++)
         {
             FSSetBackgroundColor a = new FSSetBackgroundColor(colours[i]);
             FSSetBackgroundColor b = new FSSetBackgroundColor(colours[i]);
-            
-            checkEqual(a, b);
+
+            assertEquals(a, b);
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, encode"
-     */
-    public void checkEncode()
+
+    public void testEncode()
     {
-        for (int i=0; i<encodedObjects.length; i++) {
-            checkEncode(new FSSetBackgroundColor(colours[i]), encodedObjects[i]);
+        FSCoder coder;
+
+        for (int i=0; i<encodedObjects.length; i++)
+        {
+            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+            new FSSetBackgroundColor(colours[i]).encode(coder);
+
+            assertEquals(coder, initCoder(encodedObjects[i], true));
         }
     }
-    /**
-     * @testng.test groups="setbackgroundcolor, decode"
-     */
-    public void checkDecode()
-    {       
-        for (int i=0; i<encodedObjects.length; i++) 
+
+    public void testDecode()
+    {
+        for (int i=0; i<encodedObjects.length; i++)
         {
-            FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, compact(encodedObjects[i]));            
+            FSCoder coder = initCoder(encodedObjects[i], false);
             FSSetBackgroundColor background = new FSSetBackgroundColor(coder);
 
-            checkDecode(coder, encodedObjects[i].length);
-            checkType(FSMovieObject.SetBackgroundColor, background.getType());
-            checkEqual(colours[i], background.getColor());
+            assertEquals(coder.getPointer()>>>3, encodedObjects[i].length);
+            assertEquals(FSMovieObject.SetBackgroundColor, background.getType());
+            assertEquals(colours[i], background.getColor());
         }
     }
+    
+    private FSCoder initCoder(int[] data, boolean atEnd)
+    {
+    	FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+
+        for (int i=0; i<data.length; i++) {
+            coder.writeWord(data[i], 1);
+        }
+
+        if (!atEnd) {
+        	coder.setPointer(0);
+        }
+        return coder;
+    }
 }

Modified: trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSShapeConstructorTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -5,59 +5,52 @@
 import com.flagstone.transform.*;
 import com.flagstone.transform.util.*;
 
-public class FSShapeConstructorTest
+import junit.framework.TestCase;
+
+public class FSShapeConstructorTest extends TestCase
 {
     private File destDir = null;
-    
-    public FSShapeConstructorTest()
+
+    public void setup()
     {
+        destDir = new File("test/results/FSShapeConstructor");
     }
-    /**
-     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
-     * @testng.parameters value = "dstDir"
-     */
-    public void configure(String dstDir)
+
+    public void testBasicShapes()
     {
-        destDir = new File(dstDir);
-    }
-	/**
-     * @testng.test
-	 */
-    public void basicShapes()
-    {
-        try 
+        try
         {
             File dstFile = new File(destDir, "BasicShapes.swf");
-            
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
 
             FSShapeConstructor path = new FSShapeConstructor();
             FSMovie movie = new FSMovie();
-            
+
             path.COORDINATES_ARE_PIXELS = true;
-            
+
             int width = 150;
             int height = 100;
             int cornerRadius = 10;
-            
+
             int identifier = 0;
-            
+
             path.add(new FSSolidLine(20, FSColorTable.black()));
             path.add(new FSSolidFill(FSColorTable.red()));
-            
+
             movie.setFrameRate(1.0f);
             movie.setFrameSize(new FSBounds(-4000, -4000, 4000, 4000));
             movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
-            
+
             identifier = movie.newIdentifier();
-            
+
             path.selectStyle(0, 0);
             path.rect(width/2, -height/2, width, height);
             movie.add(path.defineShape(identifier));
             movie.add(new FSPlaceObject2(identifier, 1, 0, 0));
             movie.add(new FSShowFrame());
-            
+
             /*
              * Draw a rectangle with rounded corners
              */
@@ -81,7 +74,7 @@
             movie.add(path.defineShape(identifier));
             movie.add(new FSPlaceObject2(identifier, 1));
             movie.add(new FSShowFrame());
-            
+
             /*
              * Draw a elipse
              */
@@ -93,17 +86,17 @@
             movie.add(path.defineShape(identifier));
             movie.add(new FSPlaceObject2(identifier, 1));
             movie.add(new FSShowFrame());
-            
+
             /*
              * Draw a polyline
              */
             identifier = movie.newIdentifier();
 
-            int[] points = new int[] { 
-                0, -100, 
-                10, 0, 
-                0, 90, 
-                90, 0, 
+            int[] points = new int[] {
+                0, -100,
+                10, 0,
+                0, 90,
+                90, 0,
                 0, 20,
                 -90, 0,
                 0, 90,
@@ -122,7 +115,7 @@
             movie.add(path.defineShape(identifier));
             movie.add(new FSPlaceObject2(identifier, 1));
             movie.add(new FSShowFrame());
-            
+
             /*
              * Draw a cubic bezier curve
              */
@@ -135,7 +128,7 @@
             movie.add(path.defineShape(identifier));
             movie.add(new FSPlaceObject2(identifier, 1));
             movie.add(new FSShowFrame());
-    
+
             movie.encodeToFile(dstFile.getPath());
         }
         catch (Exception e)

Modified: trunk/src/com/flagstone/transform/test/FSShowFrameTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSShowFrameTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSShowFrameTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,104 +1,117 @@
 /*
  * FSSetBackgroundColorTest.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package com.flagstone.transform.test;
 
-import com.flagstone.transform.*;
+import com.flagstone.transform.FSMovieObject;
+import com.flagstone.transform.FSProtect;
+import com.flagstone.transform.FSShowFrame;
+import com.flagstone.transform.FSCoder;
 
-public class FSShowFrameTest extends FSClassTest
-{    
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
+public class FSShowFrameTest extends TestCase
+{
     private static int[][] encodedObjects = new int[][] {
-        { 0x40, 0x00 }, 
+        { 0x40, 0x00 },
     };
-    
-    /**
-     * @testng.test groups="showframe, constructors"
-     */
-    public void checkConstructors()
+
+    public void testConstructors()
     {
         FSShowFrame obj = new FSShowFrame();
-        
-        checkType(FSMovieObject.ShowFrame, obj.getType());
+
+        assertEquals(FSMovieObject.ShowFrame, obj.getType());
     }
-    /**
-     * @testng.test groups="showframe, constructors"
-     */
-    public void checkCopyConstructor()
+
+    public void testCopyConstructor()
     {
         FSShowFrame original = new FSShowFrame();
         FSShowFrame copy = new FSShowFrame(original);
-        
-        checkEqual(original, copy);
-        checkNotIdentical(original, copy);
+
+        assertEquals(original, copy);
+        assertNotSame(original, copy);
     }
-    /**
-     * @testng.test groups="showframe, constructors"
-     */
-    public void checkClone()
+
+    public void testClone()
     {
         FSShowFrame original = new FSShowFrame();
         FSShowFrame clone = (FSShowFrame)original.clone();
-        
-        checkEqual(original, clone);
-        checkNotIdentical(original, clone);
+
+        assertEquals(original, clone);
+        assertNotSame(original, clone);
     }
-    /**
-     * @testng.test groups="showframe, utilities"
-     */
+
     public void checkEquals()
     {
         FSShowFrame a = new FSShowFrame();
         FSShowFrame b = new FSShowFrame();
-        
-        checkEqual(a, b);
+
+        assertEquals(a, b);
     }
-    /**
-     * @testng.test groups="showframe, encode"
-     */
+
     public void checkEncode()
     {
-        for (int i=0; i<encodedObjects.length; i++) {
-            checkEncode(new FSShowFrame(), encodedObjects[i]);
+        FSCoder coder;
+
+        for (int i=0; i<encodedObjects.length; i++)
+        {
+            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+            new FSShowFrame().encode(coder);
+
+            assertEquals(coder, initCoder(encodedObjects[i], true));
         }
     }
-    /**
-     * @testng.test groups="showframe, decode"
-     */
+
     public void checkDecode()
-    {       
-        for (int i=0; i<encodedObjects.length; i++) 
+    {
+        for (int i=0; i<encodedObjects.length; i++)
         {
-            FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, compact(encodedObjects[i]));            
+            FSCoder coder = initCoder(encodedObjects[i], false);
             FSShowFrame obj = new FSShowFrame(coder);
 
-            checkDecode(coder, encodedObjects[i].length);
-            checkType(FSMovieObject.ShowFrame, obj.getType());
+            assertEquals(coder.getPointer()>>>3, encodedObjects[i].length);
+            assertEquals(FSMovieObject.ShowFrame, obj.getType());
         }
     }
+    
+    private FSCoder initCoder(int[] data, boolean atEnd)
+    {
+    	FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, 0);
+
+        for (int i=0; i<data.length; i++) {
+            coder.writeWord(data[i], 1);
+        }
+
+        if (!atEnd) {
+        	coder.setPointer(0);
+        }
+        return coder;
+    }
 }

Modified: trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSSoundConstructorTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,110 +1,115 @@
 package com.flagstone.transform.test;
 
-import java.io.*;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.zip.DataFormatException;
 
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
 import com.flagstone.transform.*;
 import com.flagstone.transform.util.*;
 
-public class FSSoundConstructorTest
+public class FSSoundConstructorTest extends TestCase
 {
-    private File sourceDir = null;
-    private File destDir = null;
-    private String extension = null;
-    
-    public FSSoundConstructorTest()
+    public void testEventSound()
     {
-    }
-    /**
-     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
-     * @testng.parameters value = "srcDir dstDir ext"
-     */
-    public void configure(String srcDir, String dstDir, String ext)
-    {
-        sourceDir = new File(srcDir);
-        destDir = new File(dstDir);
-        extension = ext;
-    }
-	/**
-     * @testng.test dataProvider="files"
-	 */
-    public void playEventSound(String sndFile)
-    {
-        try 
+        FilenameFilter filter = new FilenameFilter() {
+            public boolean accept(File directory, String name) {
+                return name.endsWith(".wav");
+            }
+        };
+
+        try
         {
-            File srcFile = new File(sourceDir, sndFile);
-            File destFile = new File(destDir, sndFile.substring(0, sndFile.lastIndexOf('.')) + ".swf");
- 
+            File sourceDir = new File("/windows/media");
+            File destDir = new File("test/results/FSSoundConstructor/event/windows");
+
+            assertTrue(sourceDir.exists());
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            FSSoundConstructor soundGenerator = new FSSoundConstructor(srcFile.getPath());
-            encodeEventSoundToFile(soundGenerator, destFile);
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            String[] files = sourceDir.list(filter);
+            File sourceFile = null;
+            File destFile = null;
+
+            for (int i=0; i<files.length; i++)
+            {
+            	try
+            	{
+	            	sourceFile = new File(sourceDir, files[i]);
+	            	destFile = new File(destDir, files[i].substring(0, files[i].lastIndexOf('.')) + ".swf");
+	
+	            	FSSoundConstructor soundGenerator = new FSSoundConstructor(sourceFile.getPath());
+	            	encodeEventSoundToFile(soundGenerator, destFile);
+            	}
+                catch (DataFormatException e)
+                {
+                    System.err.println(sourceFile+": "+e.toString());
+                }
+            }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void playStreamingSound(String sndFile)
+
+    public void testStreamingSound()
     {
-        try 
+        try
         {
-            File srcFile = new File(sourceDir, sndFile);
-            File destFile = new File(destDir, sndFile.substring(0, sndFile.lastIndexOf('.')) + ".swf");
- 
+            FilenameFilter filter = new FilenameFilter() {
+                public boolean accept(File directory, String name) {
+                    return name.endsWith(".wav");
+                }
+            };
+
+            File sourceDir = new File("/windows/media");
+            File destDir = new File("test/results/FSSoundConstructor/streaming/windows");
+
+            assertTrue(sourceDir.exists());
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            FSSoundConstructor soundGenerator = new FSSoundConstructor(srcFile.getPath());
-            encodeStreamingSoundToFile(soundGenerator, destFile);
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            String[] files = sourceDir.list(filter);
+
+            File sourceFile = null;
+            File destFile = null;
+
+            for (int i=0; i<files.length; i++)
+            {
+            	try
+            	{
+	            	sourceFile = new File(sourceDir, files[i]);
+	                destFile = new File(destDir, files[i].substring(0, files[i].lastIndexOf('.')) + ".swf");
+	
+		            FSSoundConstructor soundGenerator = new FSSoundConstructor(sourceFile.getPath());
+		            encodeStreamingSoundToFile(soundGenerator, destFile);
+            	}
+                catch (DataFormatException e)
+                {
+                    System.err.println(sourceFile+": "+e.toString());
+                }
+            }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.data-provider name="files"
-     */
-    public Object[][] findFiles()
-    {
-        FilenameFilter filter = new FilenameFilter() 
-        {
-            public boolean accept(File directory, String name) 
-            {
-                String ext = name.substring(name.length()-extension.length()).toLowerCase();
-                
-                return ext.equals(extension);
-            }
-        };
-        
-        Object[][] parameters = new Object[0][0];
-        
-        if (sourceDir.exists())
-        {
-            String[] files = sourceDir.list(filter);       
-    
-            parameters = new Object[files.length][1];
-            
-            for (int i=0; i<files.length; i++)
-                parameters[i] = new Object[] { files[i] };
-        }
-        
-        return parameters;
-    }
-      
+
     private void encodeEventSoundToFile(FSSoundConstructor soundGenerator, File file) throws Exception
     {
         FSMovie movie = new FSMovie();
-        
+
         float framesPerSecond = 12.0f;
 
         movie.setFrameSize(new FSBounds(0, 0, 8000, 4000));
         movie.setFrameRate(framesPerSecond);
-    
+
         movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
 
         int soundId = movie.newIdentifier();
@@ -115,18 +120,18 @@
          */
         float duration = ((float) soundGenerator.getSamplesPerChannel()) / ((float) soundGenerator.getSampleRate());
         int numberOfFrames = (int) (duration * framesPerSecond);
-        
+
         /*
          * Add the sound definition and the FSStartSound object which is used to start
          * the sound playing.
          */
-        
+
         FSDefineSound sound = soundGenerator.defineSound(soundId);
-        
+
         movie.add(sound);
         movie.add(new FSStartSound(new FSSound(soundId, FSSound.Start)));
 
-        /* 
+        /*
          * Add frames to give the sound time to play.
          */
         for (int j=0; j<numberOfFrames; j++)
@@ -134,6 +139,7 @@
 
         movie.encodeToFile(file.getPath());
     }
+
     private void encodeStreamingSoundToFile(FSSoundConstructor soundGenerator, File file) throws Exception
     {
         float framesPerSecond = 12.0f;
@@ -142,7 +148,7 @@
 
         movie.setFrameSize(new FSBounds(0, 0, 8000, 4000));
         movie.setFrameRate(framesPerSecond);
-    
+
         movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
 
         /*
@@ -154,13 +160,13 @@
         int samplesPerBlock = soundGenerator.getSampleRate() / (int) framesPerSecond;
         int numberOfBlocks = soundGenerator.getSamplesPerChannel() / samplesPerBlock;
 
-        /* 
+        /*
          * An FSSoundStreamHeader2 object defines the attributes of the streaming sound.
          */
         movie.add(soundGenerator.streamHeader(samplesPerBlock));
 
-        /* 
-         * Add a streaming block for each frame so the sound is played as each frame 
+        /*
+         * Add a streaming block for each frame so the sound is played as each frame
          * is displayed.
          */
         for (int j=0; j<numberOfBlocks; j++)

Modified: trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/FSTextConstructorTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -4,245 +4,257 @@
 import java.util.*;
 import java.awt.*;
 
+import junit.framework.TestCase;
+import junit.framework.Assert;
+
 import com.flagstone.transform.*;
 import com.flagstone.transform.util.*;
 
-public class FSTextConstructorTest
+public class FSTextConstructorTest extends TestCase
 {
-    private File sourceDir = null;
-    private File destDir = null;
-    private String extension = null;
-    
-    public FSTextConstructorTest()
+    public void testAWTFont()
     {
-    }
-    /**
-     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
-     * @testng.parameters value = "srcDir dstDir ext"
-     */
-    public void configure(String srcDir, String dstDir, String ext)
-    {
-        sourceDir = new File(srcDir);
-        destDir = new File(dstDir);
-        extension = ext;
-    }
-	/**
-     * @testng.test
-	 */
-    public void displayAWTFont()
-    {
-        try 
+        try
         {
+            File destDir = new File("test/results/FSTextConstructor/fonts/awt");
             Font[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
 
             for (int i=0; i<fonts.length; i++)
             {
                 String fontName = fonts[i].getFontName();
-    
+
                 File destFile = new File(destDir, fontName + ".swf");
-     
+
                 if (destDir.exists() == false)
-                    assert destDir.mkdirs() : "Count not create directory: "+destDir;
-                
-                FSTextConstructor textGenerator = new FSTextConstructor(1, fontName);            
+                    assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, fontName);
                 encodeFontToFile(textGenerator, destFile);
             }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-	/**
-     * @testng.test dataProvider="files"
-	 */
-    public void displayTrueTypeFont(String fontFile)
+
+    public void testTrueTypeFont()
     {
-        try 
+        FilenameFilter filter = new FilenameFilter() {
+            public boolean accept(File directory, String name) {
+                return name.endsWith(".ttf");
+            }
+        };
+
+        try
         {
-            File srcFile = new File(sourceDir, fontFile);
-            File destFile = new File(destDir, fontFile.substring(0, fontFile.lastIndexOf('.')) + ".swf");
- 
+            File sourceDir = new File("test/data/ttf");
+            File destDir = new File("test/results/FSTextConstructor/fonts/ttf");
+
+            assertTrue(sourceDir.exists());
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            FSTextConstructor textGenerator = new FSTextConstructor(1, srcFile.getPath());          
-            encodeFontToFile(textGenerator, destFile);
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            String[] files = sourceDir.list(filter);
+            File sourceFile = null;
+            File destFile = null;
+
+            for (int i=0; i<files.length; i++)
+            {
+            	sourceFile = new File(sourceDir, files[i]);
+            	destFile = new File(destDir, files[i].substring(0, files[i].lastIndexOf('.')) + ".swf");
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, sourceFile.getPath());
+                encodeFontToFile(textGenerator, destFile);
+            }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.test dataProvider="character-sets"
-     */
-    public void displayCharacterSets(Integer code, String name)
+
+    public void testWindowsFont()
     {
-        try 
+        FilenameFilter filter = new FilenameFilter() {
+            public boolean accept(File directory, String name) {
+                return name.endsWith(".ttf");
+            }
+        };
+
+        try
         {
-            File destFile = new File(destDir, name+".swf");
-            
-            FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
-         
+            File sourceDir = new File("/windows/fonts");
+            File destDir = new File("test/results/FSTextConstructor/fonts/win");
+
+            assertTrue(sourceDir.exists());
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            encodeCharacterSet(textGenerator, 
-                FSCharacterTable.characterSet(code.intValue()), destFile);
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            String[] files = sourceDir.list(filter);
+            File sourceFile = null;
+            File destFile = null;
+
+            for (int i=0; i<files.length; i++)
+            {
+            	sourceFile = new File(sourceDir, files[i]);
+            	destFile = new File(destDir, files[i].substring(0, files[i].lastIndexOf('.')) + ".swf");
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, sourceFile.getPath());
+                encodeFontToFile(textGenerator, destFile);
+            }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.test dataProvider="locales"
-     */
-    public void boundedCharacters(Locale locale, String name)
+
+    public void testCharacterSets(Integer code, String name)
     {
-        try 
+        try
         {
-            File destFile = new File(destDir, name+".swf");
-            
-            FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
-         
+            Object[][] parameters = new Object[][] {
+                new Object[] { new Integer(FSCharacterTable.euro), "euro" },
+                new Object[] { new Integer(FSCharacterTable.iso_646), "iso-646" },
+                new Object[] { new Integer(FSCharacterTable.iso_8859_1), "iso-8859-1" },
+            };
+
+            File destDir = new File("test/results/FSTextConstructor/character-sets");
+            File destFile = null;
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            encodeBoundedCharacterSet(textGenerator, 
-                FSCharacterTable.characterSetForLocale(locale), destFile);
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            for (int i=0; i<parameters.length; i++)
+            {
+                destFile = new File(destDir, parameters[i][1]+".swf");
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
+                encodeCharacterSet(textGenerator, FSCharacterTable.characterSet(((Integer)parameters[i][1]).intValue()), destFile);
+            }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.test dataProvider="locales"
-     */
-    public void displayLocales(Locale locale, String name)
+
+    public void testBoundedCharacters(Locale locale, String name)
     {
-        try 
+        try
         {
-            File destFile = new File(destDir, name+".swf");
-            
-            FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
-         
+            Object[][] parameters = new Object[][] {
+                new Object[] { new Locale("de", "DE"), "de_DE" },
+                new Object[] { new Locale("dk", "DK"), "dk_DK" },
+                new Object[] { new Locale("en", "GB"), "en_GB" },
+                new Object[] { new Locale("en", "UK"), "en_UK" },
+                new Object[] { new Locale("en", "US"), "en_US" },
+                new Object[] { new Locale("es", "ES"), "es_ES" },
+                new Object[] { new Locale("fi", "FI"), "fi_FI" },
+                new Object[] { new Locale("fr", "FR"), "fr_FR" },
+                new Object[] { new Locale("pt", "PT"), "pt_PT" },
+            };
+
+            File destDir = new File("test/results/FSTextConstructor/locales");
+            File destFile = null;
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            encodeCharacterSet(textGenerator, 
-                FSCharacterTable.characterSetForLocale(locale), destFile);
-        }
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            for (int i=0; i<parameters.length; i++)
+            {
+                destFile = new File(destDir, parameters[i][1]+".swf");
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
+
+                encodeBoundedCharacterSet(textGenerator,
+                                FSCharacterTable.characterSetForLocale((Locale)parameters[i][1]), destFile);
+            }
+       }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.test dataProvider="strings"
-     */
-    public void displayStrings(String str, String title)
+
+    public void testLocales(Locale locale, String name)
     {
-        try 
+        try
         {
-            File destFile = new File(destDir, title+".swf");
-            
-            FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
-         
+            Object[][] parameters = new Object[][] {
+                new Object[] { new Locale("de", "DE"), "de_DE" },
+                new Object[] { new Locale("dk", "DK"), "dk_DK" },
+                new Object[] { new Locale("en", "GB"), "en_GB" },
+                new Object[] { new Locale("en", "UK"), "en_UK" },
+                new Object[] { new Locale("en", "US"), "en_US" },
+                new Object[] { new Locale("es", "ES"), "es_ES" },
+                new Object[] { new Locale("fi", "FI"), "fi_FI" },
+                new Object[] { new Locale("fr", "FR"), "fr_FR" },
+                new Object[] { new Locale("pt", "PT"), "pt_PT" },
+            };
+
+            File destDir = new File("test/results/FSTextConstructor/locales");
+            File destFile = null;
+
             if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            encodeString(textGenerator, str, destFile);
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            for (int i=0; i<parameters.length; i++)
+            {
+                destFile = new File(destDir, parameters[i][1]+".swf");
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
+
+                encodeCharacterSet(textGenerator,
+                                FSCharacterTable.characterSetForLocale((Locale)parameters[i][0]), destFile);
+            }
         }
         catch (Exception e)
         {
-            assert false;
+            fail(e.toString());
         }
     }
-    /**
-     * @testng.data-provider name="files"
-     */
-    public Object[][] findFiles()
+
+    public void testStrings(String str, String title)
     {
-        FilenameFilter filter = new FilenameFilter() 
+        try
         {
-            public boolean accept(File directory, String name) 
+            Object[][] parameters = new Object[][] {
+                new Object[] { "The quick brown, fox jumped over the lazy dog.", "atoz" },
+                new Object[] { "This line contains the same no. of characters.", "fixed" },
+                new Object[] { "Lorem ipsum dolor sit amet, consectetuer elit.", "latin" },
+                new Object[] { "Rato roeu a rolha da garrafa do rei da Russia.", "rhyme" },
+            };
+
+            File destDir = new File("test/results/FSTextConstructor/strings");
+            File destFile = null;
+
+            if (destDir.exists() == false)
+                assertTrue("Count not create destination directory: "+destDir, destDir.mkdirs());
+
+            for (int i=0; i<parameters.length; i++)
             {
-                String ext = name.substring(name.length()-extension.length()).toLowerCase();
-                
-                return ext.equals(extension);
-            }
-        };
-        
-        Object[][] parameters = new Object[0][0];
-        
-        if (sourceDir.exists())
+                destFile = new File(destDir, parameters[i][1]+".swf");
+
+                FSTextConstructor textGenerator = new FSTextConstructor(1, "Arial");
+                encodeString(textGenerator, (String)parameters[i][0], destFile);
+           }
+        }
+        catch (Exception e)
         {
-            String[] files = sourceDir.list(filter);       
-    
-            parameters = new Object[files.length][1];
-            
-            for (int i=0; i<files.length; i++)
-                parameters[i] = new Object[] { files[i] };
+            fail(e.toString());
         }
-        
-        return parameters;
     }
-    /**
-     * @testng.data-provider name="character-sets"
-     */
-    public Object[][] characterSets()
-    {
-        Object[][] parameters = new Object[][] {
-            new Object[] { new Integer(FSCharacterTable.euro), "euro" },                       
-            new Object[] { new Integer(FSCharacterTable.iso_646), "iso-646" },                       
-            new Object[] { new Integer(FSCharacterTable.iso_8859_1), "iso-8859-1" },                       
-        };
-        
-        return parameters;
-    }
-    /**
-     * @testng.data-provider name="locales"
-     */
-    public Object[][] locales()
-    {
-        Object[][] parameters = new Object[][] {
-            new Object[] { new Locale("de", "DE"), "de_DE" },                       
-            new Object[] { new Locale("dk", "DK"), "dk_DK" },                       
-            new Object[] { new Locale("en", "GB"), "en_GB" },                       
-            new Object[] { new Locale("en", "UK"), "en_UK" },                       
-            new Object[] { new Locale("en", "US"), "en_US" },                       
-            new Object[] { new Locale("es", "ES"), "es_ES" },                       
-            new Object[] { new Locale("fi", "FI"), "fi_FI" },                       
-            new Object[] { new Locale("fr", "FR"), "fr_FR" },                       
-            new Object[] { new Locale("pt", "PT"), "pt_PT" },                       
-        };
-        
-        return parameters;
-    }
-    /**
-     * @testng.data-provider name="strings"
-     */
-    public Object[][] strings()
-    {
-        Object[][] parameters = new Object[][] {
-            new Object[] { "The quick brown, fox jumped over the lazy dog.", "atoz" },                       
-            new Object[] { "This line contains the same no. of characters.", "fixed" },                       
-            new Object[] { "Lorem ipsum dolor sit amet, consectetuer elit.", "latin" },                       
-            new Object[] { "Rato roeu a rolha da garrafa do rei da Russia.", "rhyme" },                       
-        };
-        
-        return parameters;
-    }
-    
+
     private void encodeFontToFile(FSTextConstructor textGenerator, File file) throws Exception
     {
         int fontSize = 280;
-        int lineSpacing = fontSize;        
+        int lineSpacing = fontSize;
         int margin = fontSize;
-                
+
         FSMovie movie = new FSMovie();
         ArrayList lines = new ArrayList();
         char c = 0;
@@ -250,24 +262,24 @@
         for (int i=0; i<32; i++)
         {
             StringBuffer line = new StringBuffer();
-            
+
             for (int j=0; j<64; j++, c++)
 
                 line.append((char)c);
 
             lines.add(line.toString());
         }
-        
+
         int fontId = movie.newIdentifier();
-        
+
         FSDefineText2 text = textGenerator.defineTextBlock(movie.newIdentifier(), lines, fontSize, FSColorTable.black(), lineSpacing);
         FSDefineFont2 font = textGenerator.defineFont();
-        
+
         font.setIdentifier(fontId);
 
         int screenWidth = text.getBounds().getWidth() + margin + margin;
         int screenHeight = text.getBounds().getHeight() + margin + margin;
-            
+
         movie.setFrameSize(new FSBounds(0, 0, screenWidth, screenHeight));
         movie.setFrameRate(1.0f);
         movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
@@ -281,14 +293,12 @@
     private void encodeCharacterSet(FSTextConstructor textGenerator, char[] chars, File file) throws Exception
     {
         int fontSize = 280;
-        int lineSpacing = fontSize;        
+        int lineSpacing = fontSize;
         int margin = fontSize;
         int charsPerline = 32;
-                
+
         FSMovie movie = new FSMovie();
         ArrayList lines = new ArrayList();
-        
-        char c = 0;
 
         StringBuffer line = new StringBuffer();
 
@@ -302,23 +312,23 @@
                 line = new StringBuffer();
             }
         }
-        
+
         if (line.length() > 0)
             lines.add(line.toString());
-            
-        
+
+
         int fontId = movie.newIdentifier();
-        
+
         textGenerator.willDisplay(chars);
-        
+
         FSDefineFont2 font = textGenerator.defineFont();
         FSDefineText2 text = textGenerator.defineTextBlock(movie.newIdentifier(), lines, fontSize, FSColorTable.black(), lineSpacing);
-        
+
         font.setIdentifier(fontId);
 
         int screenWidth = text.getBounds().getWidth() + margin + margin;
         int screenHeight = text.getBounds().getHeight() + margin + margin;
-            
+
         movie.setFrameSize(new FSBounds(0, 0, screenWidth, screenHeight));
         movie.setFrameRate(1.0f);
         movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
@@ -332,9 +342,9 @@
         int shapeId = movie.newIdentifier();
 
         path.add(new FSSolidLine(1, FSColorTable.darkblue()));
-        path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(), 
+        path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(),
                         textWidth, textHeight);
-        
+
         movie.add(path.defineShape(shapeId));
         movie.add(new FSPlaceObject2(shapeId, 2, margin+textWidth/2, margin+textHeight/2));
         movie.add(new FSShowFrame());
@@ -344,23 +354,23 @@
     private void encodeBoundedCharacterSet(FSTextConstructor textGenerator, char[] chars, File file) throws Exception
     {
         int fontSize = 280;
-        int lineSpacing = fontSize;        
+        int lineSpacing = fontSize;
         int margin = fontSize;
         int charsPerLine = 32;
         int layer = 1;
-                
+
         FSMovie movie = new FSMovie();
         FSShapeConstructor path = new FSShapeConstructor();
-         
+
         textGenerator.willDisplay(chars);
-        
-        int maxWidth = 0;                        
+
+        int maxWidth = 0;
         int x = margin;
         int y = margin;
 
         int fontId = movie.newIdentifier();
         FSDefineFont2 font = textGenerator.defineFont();
-        font.setIdentifier(fontId);        
+        font.setIdentifier(fontId);
 
         movie.setFrameSize(new FSBounds(0, 0, 0, 0));
         movie.setFrameRate(1.0f);
@@ -369,29 +379,29 @@
 
         for (int i=0; i<chars.length; i++)
         {
-            FSDefineText2 text = textGenerator.defineText(movie.newIdentifier(), String.valueOf(chars[i]), fontSize, FSColorTable.black());        
+            FSDefineText2 text = textGenerator.defineText(movie.newIdentifier(), String.valueOf(chars[i]), fontSize, FSColorTable.black());
 
             int textWidth = text.getBounds().getWidth();
             int textHeight = text.getBounds().getHeight();
             int advance = textGenerator.advanceForChar(chars[i], fontSize) + 40;
-                
+
             int shapeId = movie.newIdentifier();
-            
+
             path.newPath();
             path.add(new FSSolidLine(1, FSColorTable.darkblue()));
-            path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(), 
+            path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(),
                             textWidth, textHeight);
-            
+
             movie.add(path.defineShape(shapeId));
-            movie.add(new FSPlaceObject2(shapeId, layer++, x+textWidth/2, y+textHeight/2));        
-             
+            movie.add(new FSPlaceObject2(shapeId, layer++, x+textWidth/2, y+textHeight/2));
+
             movie.add(text);
             movie.add(new FSPlaceObject2(text.getIdentifier(), layer++, x, y));
 
             if (i % charsPerLine == charsPerLine-1)
             {
                 maxWidth = x+advance+margin > maxWidth ? x+advance+margin : maxWidth;
-                
+
                 x = margin;
                 y += lineSpacing;
             }
@@ -412,34 +422,34 @@
         int layer = 1;
         int x = margin;
         int y = margin;
-                
+
         FSMovie movie = new FSMovie();
         FSShapeConstructor path = new FSShapeConstructor();
-         
+
         textGenerator.willDisplay(str.toCharArray());
-        
+
         int fontId = movie.newIdentifier();
         FSDefineFont2 font = textGenerator.defineFont();
-        font.setIdentifier(fontId);        
+        font.setIdentifier(fontId);
 
         movie.setFrameRate(1.0f);
         movie.add(new FSSetBackgroundColor(FSColorTable.lightblue()));
         movie.add(font);
 
-        FSDefineText2 text = textGenerator.defineText(movie.newIdentifier(), str, fontSize, FSColorTable.black());        
+        FSDefineText2 text = textGenerator.defineText(movie.newIdentifier(), str, fontSize, FSColorTable.black());
 
         int textWidth = text.getBounds().getWidth();
-        int textHeight = text.getBounds().getHeight();            
+        int textHeight = text.getBounds().getHeight();
         int shapeId = movie.newIdentifier();
-        
+
         path.newPath();
         path.add(new FSSolidLine(1, FSColorTable.darkblue()));
-        path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(), 
+        path.rect(text.getBounds().getMinX(), text.getBounds().getMinY(),
                         textWidth, textHeight);
-        
+
         movie.add(path.defineShape(shapeId));
-        movie.add(new FSPlaceObject2(shapeId, layer++, x+textWidth/2, y+textHeight/2));        
-         
+        movie.add(new FSPlaceObject2(shapeId, layer++, x+textWidth/2, y+textHeight/2));
+
         movie.add(text);
         movie.add(new FSPlaceObject2(text.getIdentifier(), layer++, x, y));
         movie.add(new FSShowFrame());

Added: trunk/src/com/flagstone/transform/test/MovieObjectTests.java
===================================================================
--- trunk/src/com/flagstone/transform/test/MovieObjectTests.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/MovieObjectTests.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -0,0 +1,16 @@
+package com.flagstone.transform.test;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class MovieObjectTests
+{
+    public static Test suite()
+    {
+        TestSuite suite= new TestSuite();
+        suite.addTestSuite(FSProtectTest.class);
+        suite.addTestSuite(FSSetBackgroundColorTest.class);
+        suite.addTestSuite(FSShowFrameTest.class);
+        return suite;
+    }
+}

Added: trunk/src/com/flagstone/transform/test/MovieTests.java
===================================================================
--- trunk/src/com/flagstone/transform/test/MovieTests.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/MovieTests.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -0,0 +1,15 @@
+package com.flagstone.transform.test;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+public class MovieTests
+{
+    public static Test suite()
+    {
+        TestSuite suite= new TestSuite();
+        suite.addTestSuite(FSMovieTest.class);
+        suite.addTestSuite(FSMovieBenchmark.class);
+        return suite;
+    }
+}

Deleted: trunk/src/com/flagstone/transform/test/TextDumpTest.java
===================================================================
--- trunk/src/com/flagstone/transform/test/TextDumpTest.java	2007-12-22 15:40:05 UTC (rev 265)
+++ trunk/src/com/flagstone/transform/test/TextDumpTest.java	2007-12-22 15:41:10 UTC (rev 266)
@@ -1,97 +0,0 @@
-/*
- * TextDumpTest.java
- * Transform
- * 
- * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
- *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package com.flagstone.transform.test;
-
-import java.io.*;
-
-import com.flagstone.transform.tools.*;
-
-public class TextDumpTest
-{
-    private File sourceDir = null;
-    private File destDir = null;
-    private String extension = ".swf";
-    
-    public TextDumpTest()
-    {
-    }
-    /**
-     * @testng.configuration beforeTest = "true" alwaysRun = "true" 
-     * @testng.parameters value = "srcDir dstDir"
-     */
-    public void configure(String srcDir, String dstDir)
-    {
-        sourceDir = new File(srcDir);
-        destDir = new File(dstDir);
-    }
-    /**
-     * @testng.test dataProvider="files"
-     */
-    public void toText(String file)
-    {
-        try
-        {
-            File srcFile = new File(sourceDir, file);
-            File dstFile = new File(destDir, file.substring(0, file.length()-3)+"txt");
-            
-            if (destDir.exists() == false)
-                assert destDir.mkdirs() : "Count not create directory: "+destDir;
-            
-            new TextDump(new String[] {
-                            "--fileIn", srcFile.getPath(), 
-                            "--fileOut", dstFile.getPath()});
-        }
-        catch (Throwable e)
-        {
-            assert false : file+": "+e.toString();
-        }
-    }
-    /**
-     * @testng.data-provider name="files"
-     */
-    public Object[][] findFiles()
-    {
-        FilenameFilter filter = new FilenameFilter() 
-        {
-            public boolean accept(File directory, String name) {
-                return name.endsWith(extension);
-            }
-        };
-        
-        String[] files = sourceDir.list(filter);       
-
-        Object[][] parameters = new Object[files.length][1];
-        
-        for (int i=0; i<files.length; i++)
-            parameters[i] = new Object[] { files[i] };
-        
-        return parameters;
-    }
-}



From smackay at mail.berlios.de  Sat Dec 22 16:42:27 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:42:27 +0100
Subject: [Transform-svn] r267 - trunk/src/com/flagstone/transform
Message-ID: <200712221542.lBMFgRZn009482@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:42:25 +0100 (Sat, 22 Dec 2007)
New Revision: 267

Removed:
   trunk/src/com/flagstone/transform/tools/
Log:
tools package is not longer used for testing.



From smackay at mail.berlios.de  Sat Dec 22 16:44:21 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:44:21 +0100
Subject: [Transform-svn] r268 - trunk/src/com/flagstone/transform/util
Message-ID: <200712221544.lBMFiLAe009579@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:44:19 +0100 (Sat, 22 Dec 2007)
New Revision: 268

Modified:
   trunk/src/com/flagstone/transform/util/FSImageConstructor.java
Log:


Modified: trunk/src/com/flagstone/transform/util/FSImageConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSImageConstructor.java	2007-12-22 15:42:25 UTC (rev 267)
+++ trunk/src/com/flagstone/transform/util/FSImageConstructor.java	2007-12-22 15:44:19 UTC (rev 268)
@@ -1601,7 +1601,7 @@
         deflater.setInput(image);
         deflater.finish();
         
-        byte[] compressedData = new byte[image.length];
+        byte[] compressedData = new byte[image.length*2];
         int bytesCompressed = deflater.deflate(compressedData);
 
         byte[] newData = new byte[bytesCompressed];



From smackay at mail.berlios.de  Sat Dec 22 16:47:46 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:47:46 +0100
Subject: [Transform-svn] r269 - trunk/src/com/flagstone/transform
Message-ID: <200712221547.lBMFlkS6009778@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:47:37 +0100 (Sat, 22 Dec 2007)
New Revision: 269

Modified:
   trunk/src/com/flagstone/transform/FSCoder.java
Log:
A method, boolean equals(Object obj), was added to FSCoder to support unit testing.

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2007-12-22 15:44:19 UTC (rev 268)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2007-12-22 15:47:37 UTC (rev 269)
@@ -61,7 +61,7 @@
      * most significant byte in a word stored first.
      */
     public static final int BIG_ENDIAN = 1;
-    
+
     /*
      * Methods used to calculate the size of fields when encoded.
      */
@@ -281,6 +281,20 @@
         ptr = 0;
         end = data.length << 3;
     }
+
+    public boolean equals(FSCoder coder)
+    {
+        boolean result = true;
+
+        result = result && byteOrder == coder.byteOrder;
+        result = result && ptr == coder.ptr;
+
+        for (int i=0; i<data.length; i++) {
+            result = result && data[i] == coder.data[i];
+        }
+
+        return result;
+    }
         
     /**
      * @deprecated The FSMovieListener interface does not enable recovery from



From smackay at mail.berlios.de  Sat Dec 22 16:58:48 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 16:58:48 +0100
Subject: [Transform-svn] r270 - trunk/src/com/flagstone/transform
Message-ID: <200712221558.lBMFwmrv010159@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 16:58:45 +0100 (Sat, 22 Dec 2007)
New Revision: 270

Modified:
   trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java
   trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java
Log:
Fixed bug 12769 where the SOI and EOI markers were reversed.

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java	2007-12-22 15:47:37 UTC (rev 269)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java	2007-12-22 15:58:45 UTC (rev 270)
@@ -1,42 +1,42 @@
 /*
  * FSDefineJPEGImage2.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage2 is used to define a JPEG encoded image with an integrated 
-encoding table. 
-  
-<p>It extends the FSDefineJPEGImage class by including a separate encoding table, 
-rather than using an FSJPEGEncodingTable object to store the encoding table. 
-This allows multiple JPEG images with different amounts of compression to be 
+FSDefineJPEGImage2 is used to define a JPEG encoded image with an integrated
+encoding table.
+
+<p>It extends the FSDefineJPEGImage class by including a separate encoding table,
+rather than using an FSJPEGEncodingTable object to store the encoding table.
+This allows multiple JPEG images with different amounts of compression to be
 included within a Flash file.</p>
 
 <table class="datasheet">
@@ -49,7 +49,7 @@
 
 <tr>
 <td><a name="FSDefineJPEGImage2_1">identifier</a></td>
-<td>A unique identifier, in the range 1..65535, that is used to reference the 
+<td>A unique identifier, in the range 1..65535, that is used to reference the
 image from other objects.</td>
 </tr>
 
@@ -64,16 +64,16 @@
 </tr>
 </table>
 
-<p>Although the encoding table defines how the image is compressed it is not 
-essential. If an FSDefineJPEGImage3 object is created with an empty encoding 
-table then the Flash Player will still display the JPEG image correctly. The 
-empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8, 
-0xFF, 0xD9. For convenience passing a null reference to any of the constructors 
+<p>Although the encoding table defines how the image is compressed it is not
+essential. If an FSDefineJPEGImage3 object is created with an empty encoding
+table then the Flash Player will still display the JPEG image correctly. The
+empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8,
+0xFF, 0xD9. For convenience passing a null reference to any of the constructors
 or to the setEncodingTable method will create an empty table.</p>
 
 <h1 class="datasheet">Examples</h1>
 
-<p>The simplest way to use the FSDefineJPEGImage2 class is to use the constructor 
+<p>The simplest way to use the FSDefineJPEGImage2 class is to use the constructor
 that specifies the JPEG file to initialise the object:</p>
 
 <pre>
@@ -81,7 +81,7 @@
 byte[] bytes = new byte[(int)aFile.length()];
 
 try {
-    FileInputStream imageContents = new FileInputStream(aFile);            
+    FileInputStream imageContents = new FileInputStream(aFile);
     imageContents.read(bytes);
     imageContents.close();
 }
@@ -107,9 +107,9 @@
     private byte[] encodingTable = null;
 
     /**
-     * Construct an FSDefineJPEGImage2 object, initalizing it with values decoded 
+     * Construct an FSDefineJPEGImage2 object, initalizing it with values decoded
      * from an encoded object.
-     * 
+     *
      * @param coder an FSCoder containing the binary data.
      */
     public FSDefineJPEGImage2(FSCoder coder)
@@ -141,7 +141,7 @@
         setEncodingTable(null);
     }
     /**
-     * Constructs an FSDefineJPEGImage2 object by copying values from an 
+     * Constructs an FSDefineJPEGImage2 object by copying values from an
      * existing object.
      *
      * @param obj an FSDefineJPEGImage2 object.
@@ -181,7 +181,7 @@
     public void setEncodingTable(byte[] bytes)
     {
         if (bytes == null) {
-            bytes = new byte[] { (byte)0xFF, (byte)0xD8, (byte)0xFF, (byte)0xD9 };
+            bytes = new byte[] { (byte)0xFF, (byte)0xD9, (byte)0xFF, (byte)0xD8 };
         }
         encodingTable = bytes;
     }
@@ -189,21 +189,21 @@
     public Object clone()
     {
         FSDefineJPEGImage2 anObject = (FSDefineJPEGImage2)super.clone();
-        
+
         anObject.image = Transform.clone(image);
         anObject.encodingTable = Transform.clone(encodingTable);
-        
+
         return anObject;
     }
 
     public boolean equals(Object anObject)
     {
         boolean result = false;
-        
+
         if (super.equals(anObject))
         {
             FSDefineJPEGImage2 typedObject = (FSDefineJPEGImage2)anObject;
-            
+
             result = Transform.equals(image, typedObject.image);
             result = result && Transform.equals(encodingTable, typedObject.encodingTable);
         }
@@ -213,7 +213,7 @@
     public void appendDescription(StringBuffer buffer, int depth)
     {
         buffer.append(name());
-        
+
         if (depth > 0)
         {
             buffer.append(": { ");
@@ -226,13 +226,13 @@
     public int length(FSCoder coder)
     {
         super.length(coder);
-        
+
         length += encodingTable.length;
         length += image.length;
 
         return length;
     }
-    
+
     public void encode(FSCoder coder)
     {
         super.encode(coder);
@@ -240,9 +240,9 @@
         coder.writeBytes(image);
         coder.endObject(name());
     }
-    
+
     public void decode(FSCoder coder)
-    {        
+    {
         super.decode(coder);
         setEncodingTable(readJPEGStream(coder));
         byte[] data = new byte[length-encodingTable.length-2];
@@ -250,30 +250,30 @@
         setImage(data);
         coder.endObject(name());
     }
-    
+
     private byte[] readJPEGStream(FSCoder coder)
     {
         byte bytes[] = null;
+        
+        int start = coder.getPointer();
+        int end = start + ((length-2) << 3);
+        int word = coder.readBits(16, false);
+        int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
 
-        int eoi = 0xFFD9;        
-        int start = coder.getPointer();
-        int end = start + ((length-2) << 3);        
-        int word = 0;
- 
         do {
             word = coder.scanBits(16, false);
-            
-            if (word == eoi) 
+
+            if (word == eoi)
             {
                 end = coder.getPointer()+16;
                 break;
             }
             coder.adjustPointer(8);
-        } 
+        }
         while (coder.getPointer() < end);
-            
-        int len = (end-start) >>> 3; 
-        
+
+        int len = (end-start) >>> 3;
+
         coder.setPointer(start);
         bytes = new byte[len];
         coder.readBytes(bytes);

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java	2007-12-22 15:47:37 UTC (rev 269)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java	2007-12-22 15:58:45 UTC (rev 270)
@@ -1,37 +1,37 @@
 /*
  * FSDefineJPEGImage3.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage3 is used to define a transparent JPEG encoded image. 
+FSDefineJPEGImage3 is used to define a transparent JPEG encoded image.
 
 <p>It extends the FSDefineJPEGImage3 class by including a separate zlib compressed table of alpha channel values. This allows the transparency of existing JPEG encoded images to be changed without re-encoding the original image.</p>
 
@@ -60,19 +60,19 @@
 
 <tr>
 <td><a name="FSDefineJPEGImage3_3">alpha</a></td>
-<td>An array of bytes containing the zlib encoded alpha channel data for each 
+<td>An array of bytes containing the zlib encoded alpha channel data for each
 pixel in the image.</td>
 </tr>
 </table>
 
-<p>Although the encoding table defines how the image is compressed it is not 
-essential. If an FSDefineJPEGImage3 object is created with an empty encoding 
-table then the Flash Player will still display the JPEG image correctly. The 
-empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8, 
-0xFF, 0xD9. For convenience passing a null reference to any of the constructors 
+<p>Although the encoding table defines how the image is compressed it is not
+essential. If an FSDefineJPEGImage3 object is created with an empty encoding
+table then the Flash Player will still display the JPEG image correctly. The
+empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8,
+0xFF, 0xD9. For convenience passing a null reference to any of the constructors
 or to the setEncodingTable method will create an empty table.</p>
 
-<p>The simplest way to use the FSDefineJPEGImage3 class is to use the constructor 
+<p>The simplest way to use the FSDefineJPEGImage3 class is to use the constructor
 that specifies the JPEG file to initialise the object:</p>
 
 <pre>
@@ -82,26 +82,26 @@
 byte[] compressedAlpha = null;
 
 try {
-    FileInputStream imageContents = new FileInputStream(aFile);            
+    FileInputStream imageContents = new FileInputStream(aFile);
     imageContents.read(bytes);
     imageContents.close();
-    
+
     // Set the level of transparency;
-    
+
     for (int i=0; i&lt;bytes.length; i++)
         alpha[i] = (byte)128;
 
     Deflater deflater = new Deflater();
-    
+
     byte[] tmp = new byte[alpha.length];
-    
+
     deflater.setInput(alpha);
     deflater.finish();
-    
+
     int bytesCompressed = deflater.deflate(tmp);
-    
+
     compressedAlpha = new byte[bytesCompressed];
-    
+
     for (int i=0; i&lt;bytesCompressed; i++)
         compressedAlpha[i] = tmp[i];
 }
@@ -115,15 +115,15 @@
 movie.add(new FSDefineJPEGImage3(movie.newIdentifier(), bytes, null, compressedAlpha));
 </pre>
 
-<p>This generates an object with an empty encoding table, however the image will 
-still be displayed correctly. The empty encoding table is not a null object. The 
+<p>This generates an object with an empty encoding table, however the image will
+still be displayed correctly. The empty encoding table is not a null object. The
 alpha channel data is set so the image is completely opaque.</P>
 
 <h1 class="datasheet">History</h1>
 
-<p>The FSDefineJPEGImage3 class represents the DefineBitsJPEG3 tag from the 
+<p>The FSDefineJPEGImage3 class represents the DefineBitsJPEG3 tag from the
 Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.</p>
- */  
+ */
 public class FSDefineJPEGImage3 extends FSDefineObject
 {
     private byte[] image = null;
@@ -131,9 +131,9 @@
     private byte[] alpha = null;
 
     /**
-     * Construct an FSDefineJPEGImage3 object, initalizing it with values 
+     * Construct an FSDefineJPEGImage3 object, initalizing it with values
      * decoded from an encoded object.
-     * 
+     *
      * @param coder an FSCoder containing the binary data.
      */
     public FSDefineJPEGImage3(FSCoder coder)
@@ -157,7 +157,7 @@
         setCompressedAlpha(alphaBytes);
     }
     /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing 
+     * Constructs an FSDefineJPEGImage object by copying values from an existing
      * object.
      *
      * @param obj an FSDefineJPEGImage object.
@@ -195,7 +195,7 @@
     public void setEncodingTable(byte[] bytes)
     {
         if (bytes == null) {
-            bytes = new byte[] { (byte)0xFF, (byte)0xD8, (byte)0xFF, (byte)0xD9 };
+            bytes = new byte[] { (byte)0xFF, (byte)0xD9, (byte)0xFF, (byte)0xD8 };
         }
         encodingTable = bytes;
     }
@@ -221,22 +221,22 @@
     public Object clone()
     {
         FSDefineJPEGImage3 anObject = (FSDefineJPEGImage3)super.clone();
-        
+
         anObject.image = Transform.clone(image);
         anObject.encodingTable = Transform.clone(encodingTable);
         anObject.alpha = Transform.clone(alpha);
-        
+
         return anObject;
     }
 
     public boolean equals(Object anObject)
     {
         boolean result = false;
-        
+
         if (super.equals(anObject))
         {
             FSDefineJPEGImage3 typedObject = (FSDefineJPEGImage3)anObject;
-            
+
             result = Transform.equals(image, typedObject.image);
             result = result && Transform.equals(encodingTable, typedObject.encodingTable);
             result = result && Transform.equals(alpha, typedObject.alpha);
@@ -247,7 +247,7 @@
     public void appendDescription(StringBuffer buffer, int depth)
     {
         buffer.append(name());
-        
+
         if (depth > 0)
         {
             buffer.append(": { ");
@@ -261,7 +261,7 @@
     public int length(FSCoder coder)
     {
         super.length(coder);
-    
+
         length += 4;
         length += encodingTable.length;
         length += image.length;
@@ -270,11 +270,11 @@
 
         return length;
     }
-    
+
     public void encode(FSCoder coder)
     {
         super.encode(coder);
-        
+
         coder.writeWord(encodingTable.length+image.length, 4);
         coder.writeBytes(encodingTable);
         coder.writeBytes(image);
@@ -284,13 +284,13 @@
 
         coder.endObject(name());
     }
-    
+
     public void decode(FSCoder coder)
     {
         super.decode(coder);
-        
+
         int offset = coder.readWord(4, false);
-        
+
         setEncodingTable(readJPEGStream(coder));
         byte[] imageIn = new byte[offset-encodingTable.length];
         coder.readBytes(imageIn);
@@ -298,33 +298,33 @@
         byte[] alphaIn = new byte[length-offset-6];
         coder.readBytes(alphaIn);
          setCompressedAlpha(alphaIn);
-        
+
         coder.endObject(name());
     }
 
     private byte[] readJPEGStream(FSCoder coder)
     {
         byte bytes[] = null;
-
-        int eoi = 0xFFD9;        
+        
         int start = coder.getPointer();
-        int end = start + ((length-2) << 3);        
-        int word = 0;
+        int end = start + ((length-2) << 3);
+        int word = coder.readBits(16, false);
+        int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
 
         do {
             word = coder.scanBits(16, false);
-            
-            if (word == eoi) 
+
+            if (word == eoi)
             {
                 end = coder.getPointer()+16;
                 break;
             }
             coder.adjustPointer(8);
-        } 
+        }
         while (coder.getPointer() < end);
-            
-        int len = (end-start) >>> 3; 
-        
+
+        int len = (end-start) >>> 3;
+
         coder.setPointer(start);
         bytes = new byte[len];
         coder.readBytes(bytes);



From smackay at mail.berlios.de  Sat Dec 22 17:00:30 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:00:30 +0100
Subject: [Transform-svn] r271 - trunk/src/com/flagstone/transform
Message-ID: <200712221600.lBMG0UkU010324@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:00:25 +0100 (Sat, 22 Dec 2007)
New Revision: 271

Modified:
   trunk/src/com/flagstone/transform/FSDefineFont2.java
   trunk/src/com/flagstone/transform/FSFontInfo.java
   trunk/src/com/flagstone/transform/FSFontInfo2.java
Log:
Fixed bug 12768, trailing null bytes are now removed from font name.

Modified: trunk/src/com/flagstone/transform/FSDefineFont2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont2.java	2007-12-22 15:58:45 UTC (rev 270)
+++ trunk/src/com/flagstone/transform/FSDefineFont2.java	2007-12-22 16:00:25 UTC (rev 271)
@@ -702,7 +702,7 @@
     
         length += shapes.size()*((wideCodes == 1) ? 2 : 1);
     
-            if (containsLayoutInfo())
+        if (containsLayoutInfo())
         {
             length += 6;
             length += shapes.size()*2;
@@ -853,6 +853,11 @@
         language = coder.readBits(8, false);
         nameLength = coder.readWord(1, false);
         name = coder.readString(nameLength);
+        
+        while (name.charAt(name.length()-1) == 0) {
+        	name = name.substring(0, name.length()-1);
+        }
+        
         glyphCount = coder.readWord(2, false);
 
         int offsetStart = coder.getPointer();

Modified: trunk/src/com/flagstone/transform/FSFontInfo.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFontInfo.java	2007-12-22 15:58:45 UTC (rev 270)
+++ trunk/src/com/flagstone/transform/FSFontInfo.java	2007-12-22 16:00:25 UTC (rev 271)
@@ -406,6 +406,11 @@
         identifier = coder.readWord(2, false);
         nameLength = coder.readWord(1, false);
         name = coder.readString(nameLength);
+
+        while (name.charAt(name.length()-1) == 0) {
+        	name = name.substring(0, name.length()-1);
+        }
+        
         /* reserved */ coder.readBits(2, false);
         small = coder.readBits(1, false) != 0 ? true : false;
         encoding = coder.readBits(2, false);

Modified: trunk/src/com/flagstone/transform/FSFontInfo2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFontInfo2.java	2007-12-22 15:58:45 UTC (rev 270)
+++ trunk/src/com/flagstone/transform/FSFontInfo2.java	2007-12-22 16:00:25 UTC (rev 271)
@@ -381,6 +381,11 @@
         identifier = coder.readWord(2, false);
         nameLength = coder.readWord(1, false);
         name = coder.readString(nameLength);
+
+        while (name.charAt(name.length()-1) == 0) {
+        	name = name.substring(0, name.length()-1);
+        }
+        
         /* reserved */ coder.readBits(2, false);
         small = coder.readBits(1, false) != 0 ? true : false;
         encoding = coder.readBits(2, false);



From smackay at mail.berlios.de  Sat Dec 22 17:02:28 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:02:28 +0100
Subject: [Transform-svn] r272 - trunk/src/com/flagstone/transform
Message-ID: <200712221602.lBMG2STF010424@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:02:14 +0100 (Sat, 22 Dec 2007)
New Revision: 272

Modified:
   trunk/src/com/flagstone/transform/FSButtonEvent.java
   trunk/src/com/flagstone/transform/FSClipEvent.java
   trunk/src/com/flagstone/transform/FSDefineButton.java
   trunk/src/com/flagstone/transform/FSDoAction.java
   trunk/src/com/flagstone/transform/FSInitialize.java
Log:
Fixed bug 9806. End Of Action markers (0x00) in the middle of a sequence of actions are now handled and the complete set of actions is decoded correctly.

Modified: trunk/src/com/flagstone/transform/FSButtonEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonEvent.java	2007-12-22 16:00:25 UTC (rev 271)
+++ trunk/src/com/flagstone/transform/FSButtonEvent.java	2007-12-22 16:02:14 UTC (rev 272)
@@ -184,26 +184,15 @@
     private ArrayList actions = null;
     private byte[] encodedActions = null;
    
-    /*
-     * This constructor is used only then lazily decoding actions.
-     */
-    FSButtonEvent(FSCoder coder, int len)
-    {
-        length = len-2;
-        
-        if (coder.context[FSCoder.DecodeActions] == 0)
-            encodedActions = new byte[len-3];
-        
-        decode(coder);
-    }
     /**
-     * Construct an FSButtonEvent object, initalizing it with values 
+     * Construct an FSButtonEvent object, initializing it with values 
      * decoded from an encoded object.
      * 
      * @param coder an FSCoder containing the binary data.
      */
-    public FSButtonEvent(FSCoder coder)
+    public FSButtonEvent(FSCoder coder, int len)
     {
+        length = len-2;
         decode(coder);
     }
     /** Constructs an FSButtonEvent object that defines the array of actions that will be executed when a particular event occurs.
@@ -397,20 +386,28 @@
     
         if (actions != null)
         {
+        	FSActionObject currentAction = null;
+        	
             for (Iterator i = actions.iterator(); i.hasNext();)
             {
-                FSActionObject currentAction = (FSActionObject)i.next();
+                currentAction = (FSActionObject)i.next();
             
                 length += currentAction.length(coder);
                 length += (currentAction.getType() > 128) ? 3 : 1;
             }
+            
+            if (currentAction.getType() != FSAction.End) {
+            	length += 1;
+            }
         }
         else
         {
             length += encodedActions.length;
-        }
-        length += 1;
-        
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+            	length += 1;
+            }
+        }        
         return length;
     }
     
@@ -420,9 +417,11 @@
 
         if (actions != null)
         {
+        	FSActionObject action = null;
+        	
             for (Iterator i=actions.iterator(); i.hasNext();)
             {
-                FSActionObject action = (FSActionObject)i.next();
+                action = (FSActionObject)i.next();
                 
                 int objStart = coder.getPointer();
                 int length = action.getLength();
@@ -443,12 +442,19 @@
                     coder.context[FSCoder.Delta] = delta;
                 }
             }
+            
+            if (action.getType() != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
         else
         {
             coder.writeBytes(encodedActions);
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
-        coder.writeWord(0, 1);
     }
     
     public void decode(FSCoder coder)
@@ -461,7 +467,7 @@
 
             int start;
             
-            while (length > 1) 
+            while (length > 0) 
             {
                 start = coder.getPointer();
                 
@@ -471,8 +477,8 @@
         }
         else
         {
+            encodedActions = new byte[length];
             coder.readBytes(encodedActions);
         }
-        coder.readWord(1, false);
     }
 }

Modified: trunk/src/com/flagstone/transform/FSClipEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSClipEvent.java	2007-12-22 16:00:25 UTC (rev 271)
+++ trunk/src/com/flagstone/transform/FSClipEvent.java	2007-12-22 16:02:14 UTC (rev 272)
@@ -482,20 +482,28 @@
     
         if (actions != null)
         {
+        	FSActionObject currentAction = null;
+        	
             for (Iterator i = actions.iterator(); i.hasNext();)
             {
-                FSActionObject currentAction = (FSActionObject)i.next();
+                currentAction = (FSActionObject)i.next();
             
                 length += currentAction.length(coder);
                 length += (currentAction.getType() > 128) ? 3 : 1;
             }
-         }
+            
+            if (currentAction.getType() != FSAction.End) {
+            	length += 1;
+            }
+        }
         else
         {
             length += encodedActions.length;
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+            	length += 1;
+            }
         }
-        length += 1;
-
         return length;
     }
     
@@ -506,18 +514,28 @@
         int offset = 1; // End of actions marker
         
         if (actions != null)
-        {        
+        {       
+        	FSActionObject currentAction = null;
+        	
             for (Iterator i = actions.iterator(); i.hasNext();)
             {
-                FSActionObject currentAction = (FSActionObject)i.next();
+            	currentAction = (FSActionObject)i.next();
             
                 offset += currentAction.getLength();
                 offset += (currentAction.getType() > 128) ? 3 : 1;
             }
+            
+            if (currentAction.getType() != FSAction.End) {
+            	offset += 1;
+            }
         }
         else
         {
             offset += encodedActions.length;
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+            	offset += 1;
+            }
         }
 
 // Flash 6
@@ -534,9 +552,11 @@
         
         if (actions != null)
         { 
+        	FSActionObject action = null;
+        	
             for (Iterator i=actions.iterator(); i.hasNext();)
             {
-                FSActionObject action = (FSActionObject)i.next();
+                action = (FSActionObject)i.next();
                 
                 int objStart = coder.getPointer();
                 int length = action.getLength();
@@ -557,12 +577,19 @@
                     coder.context[FSCoder.Delta] = delta;
                 }
             }
+            
+            if (action.getType() != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
         else
         {
            coder.writeBytes(encodedActions);
+
+           if (encodedActions[encodedActions.length-1] != FSAction.End) {
+               coder.writeWord(0, 1);
+           }
         }
-        coder.writeWord(0, 1);
     }
     
     public void decode(FSCoder coder)
@@ -585,7 +612,7 @@
             
             int start;
             
-            while (length > 1) 
+            while (length > 0) 
             {
                 start = coder.getPointer();
                 
@@ -595,9 +622,8 @@
         }
         else
         {
-            encodedActions = new byte[length-1];
+            encodedActions = new byte[length];
             coder.readBytes(encodedActions);
         }
-        coder.readWord(1, false);
     }
 }

Modified: trunk/src/com/flagstone/transform/FSDefineButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineButton.java	2007-12-22 16:00:25 UTC (rev 271)
+++ trunk/src/com/flagstone/transform/FSDefineButton.java	2007-12-22 16:02:14 UTC (rev 272)
@@ -373,19 +373,28 @@
     
         if (actions != null)
         {
+        	FSActionObject currentAction = null;
+        	
             for (Iterator i = actions.iterator(); i.hasNext();)
             {
-                FSActionObject currentAction = (FSActionObject)i.next();
+                currentAction = (FSActionObject)i.next();
             
                 length += currentAction.length(coder);
                 length += (currentAction.getType() > 128) ? 3 : 1;
             }
+            
+            if (currentAction.getType() != FSAction.End) {
+            	length += 1;
+            }
         }
         else
         {
             length += encodedActions.length;
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+            	length += 1;
+            }
         }
-        length += 1;
 
         return length;
     }
@@ -401,9 +410,11 @@
     
         if (actions != null)
         {
+        	FSActionObject action = null;
+        	
             for (Iterator i=actions.iterator(); i.hasNext();)
             {
-                FSActionObject action = (FSActionObject)i.next();
+                action = (FSActionObject)i.next();
                     
                 int objStart = coder.getPointer();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
@@ -423,12 +434,19 @@
                     coder.context[FSCoder.Delta] = delta;
                 }
             }
+            
+            if (action.getType() != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
         else
         {
             coder.writeBytes(encodedActions);
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
-        coder.writeWord(0, 1);
         coder.endObject(name());
     }
     
@@ -436,7 +454,7 @@
     {
         super.decode(coder);
         
-        int start = coder.getPointer();
+        int start = coder.getPointer() - 16;
         
         buttonRecords = new ArrayList();
         
@@ -445,28 +463,25 @@
             
         coder.readWord(1, false); // character end
         
-        int actionsLength = (coder.getPointer()-start) >>> 3;
+        int actionsLength = length - ((coder.getPointer()-start) >>> 3);
         
         if (coder.context[FSCoder.DecodeActions] == 1)
         {
             actions = new ArrayList();
             
-            int len = actionsLength;
-            
-            while (len > 1) 
+            while (actionsLength > 0) 
             {
                 start = coder.getPointer();
                 
                 actions.add(FSMovie.decodeAction(coder));
-                len -= (coder.getPointer() - start) >>> 3;
+                actionsLength -= (coder.getPointer() - start) >>> 3;
             }
         }
         else
         {
-            encodedActions = new byte[actionsLength-1];
+            encodedActions = new byte[actionsLength];
             coder.readBytes(encodedActions);
         }
-        coder.readWord(1, false);
         coder.endObject(name());
     }
 }

Modified: trunk/src/com/flagstone/transform/FSDoAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDoAction.java	2007-12-22 16:00:25 UTC (rev 271)
+++ trunk/src/com/flagstone/transform/FSDoAction.java	2007-12-22 16:02:14 UTC (rev 272)
@@ -275,19 +275,28 @@
 
         if (actions != null)
         {
+        	FSActionObject currentAction = null;
+        	
             for (int i=0; i<actions.size(); i++)
             {
-                FSActionObject currentAction = (FSActionObject)actions.get(i);
+                currentAction = (FSActionObject)actions.get(i);
             
                 length += currentAction.length(coder);
                 length += (currentAction.getType() > 128) ? 3 : 1;
             }
+            
+            if (currentAction.getType() != FSAction.End) {
+            	length += 1;
+            }
         }
         else
         {
             length += encodedActions.length;
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+            	length += 1;
+            }
         }
-        length += 1;
         return length;
     }
     
@@ -297,9 +306,11 @@
         
         if (actions != null)
         {
+        	FSActionObject action = null;
+        	
             for (Iterator i=actions.iterator(); i.hasNext();)
             {
-                FSActionObject action = (FSActionObject)i.next();
+                action = (FSActionObject)i.next();
                 
                 int objStart = coder.getPointer();
                 int start = coder.getPointer() + ((action.getType() > 128) ? 24 : 8);
@@ -319,12 +330,19 @@
                 }
                 coder.setPointer(next);
             }
+            
+            if (action.getType() != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
         else
         {
             coder.writeBytes(encodedActions);
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
-        coder.writeWord(0, 1);
         coder.endObject(name());
     }
     

Modified: trunk/src/com/flagstone/transform/FSInitialize.java
===================================================================
--- trunk/src/com/flagstone/transform/FSInitialize.java	2007-12-22 16:00:25 UTC (rev 271)
+++ trunk/src/com/flagstone/transform/FSInitialize.java	2007-12-22 16:02:14 UTC (rev 272)
@@ -295,20 +295,28 @@
 
         if (actions != null)
         {
+        	FSActionObject currentAction = null;
+        	
             for (Iterator i = actions.iterator(); i.hasNext();)
             {
-                FSActionObject currentAction = (FSActionObject)i.next();
+                currentAction = (FSActionObject)i.next();
             
                 length += currentAction.length(coder);
                 length += (currentAction.getType() > 128) ? 3 : 1;
             }
+            
+            if (currentAction.getType() != FSAction.End) {
+            	length += 1;
+            }
         }
         else
         {
             length += encodedActions.length;
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+            	length += 1;
+            }
         }
-        length += 1;
-        
         return length;
     }
     
@@ -320,9 +328,11 @@
 
         if (actions != null)
         {
+        	FSActionObject action = null;
+        	
             for (Iterator i=actions.iterator(); i.hasNext();)
             {
-                FSActionObject action = (FSActionObject)i.next();
+                action = (FSActionObject)i.next();
                 
                 int objStart = coder.getPointer();
                 int length = action.getLength();
@@ -343,13 +353,19 @@
                     coder.context[FSCoder.Delta] = delta;
                 }
             }
+            
+            if (action.getType() != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
         else
         {
             coder.writeBytes(encodedActions);
+
+            if (encodedActions[encodedActions.length-1] != FSAction.End) {
+                coder.writeWord(0, 1);
+            }
         }
-        coder.writeWord(0, 1);
-
         coder.endObject(name());
     }
     
@@ -366,7 +382,7 @@
             int len = length-2;
             int start;
             
-            while (len > 1) 
+            while (len > 0) 
             {
                 start = coder.getPointer();
                 
@@ -376,10 +392,9 @@
         }
         else
         {
-            encodedActions = new byte[length-3];
+            encodedActions = new byte[length-2];
             coder.readBytes(encodedActions);
         }
-        coder.readWord(1, false);
         coder.endObject(name());
     }
 }
\ No newline at end of file



From smackay at mail.berlios.de  Sat Dec 22 17:03:52 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:03:52 +0100
Subject: [Transform-svn] r273 - trunk/src/com/flagstone/transform
Message-ID: <200712221603.lBMG3qqo010516@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:03:45 +0100 (Sat, 22 Dec 2007)
New Revision: 273

Modified:
   trunk/src/com/flagstone/transform/FSDefineTextField.java
Log:
Fixed bug 12747. Leading in FSDefineTextField is now decoded as an unsigned integer.

Modified: trunk/src/com/flagstone/transform/FSDefineTextField.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineTextField.java	2007-12-22 16:02:14 UTC (rev 272)
+++ trunk/src/com/flagstone/transform/FSDefineTextField.java	2007-12-22 16:03:45 UTC (rev 273)
@@ -1074,7 +1074,7 @@
             leftMargin = coder.readWord(2, false);
             rightMargin = coder.readWord(2, false);
             indent = coder.readWord(2, false);
-            leading = coder.readWord(2, false);
+            leading = coder.readWord(2, true);
         }
 
         variableName = coder.readString();



From smackay at mail.berlios.de  Sat Dec 22 17:07:33 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:07:33 +0100
Subject: [Transform-svn] r274 - trunk/src/com/flagstone/transform
Message-ID: <200712221607.lBMG7XH4010673@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:07:30 +0100 (Sat, 22 Dec 2007)
New Revision: 274

Modified:
   trunk/src/com/flagstone/transform/FSSerialNumber.java
Log:
Fixed bug 12730. FSSerialNumber will now decode correctly if string contains null.


Modified: trunk/src/com/flagstone/transform/FSSerialNumber.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSerialNumber.java	2007-12-22 16:03:45 UTC (rev 273)
+++ trunk/src/com/flagstone/transform/FSSerialNumber.java	2007-12-22 16:07:30 UTC (rev 274)
@@ -159,7 +159,7 @@
     public void decode(FSCoder coder)
     {
         super.decode(coder);
-        serialNumber = coder.readString();
+        serialNumber = coder.readString(length);
         coder.endObject(name());
     }
 }
\ No newline at end of file



From smackay at mail.berlios.de  Sat Dec 22 17:11:10 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:11:10 +0100
Subject: [Transform-svn] r275 - trunk/src/com/flagstone/transform
Message-ID: <200712221611.lBMGBAvC010817@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:11:04 +0100 (Sat, 22 Dec 2007)
New Revision: 275

Modified:
   trunk/src/com/flagstone/transform/FSProtect.java
Log:
Fixed bug 12729. Flash 4 files containing a Protect data structure with an MD5 encoded password are now decoded correctly.

Fixed bug 12728. FSProtect with a string that contains null will be decoded correctly.

Modified: trunk/src/com/flagstone/transform/FSProtect.java
===================================================================
--- trunk/src/com/flagstone/transform/FSProtect.java	2007-12-22 16:07:30 UTC (rev 274)
+++ trunk/src/com/flagstone/transform/FSProtect.java	2007-12-22 16:11:04 UTC (rev 275)
@@ -147,7 +147,7 @@
     {
         super.length(coder);
         
-        if ((coder.context[FSCoder.Version] >= 5) && (password != null) && (password.length() > 0))
+        if ((password != null) && (password.length() > 0))
             length += 2 + coder.strlen(password, true);
 
         return length;
@@ -157,7 +157,7 @@
     {
         super.encode(coder);
         
-        if ((coder.context[FSCoder.Version] >= 5) && (password != null) && (password.length() > 0))
+        if ((password != null) && (password.length() > 0))
         {
             coder.writeWord(0, 2);
             coder.writeString(password);
@@ -175,10 +175,10 @@
          * Force a read of the entire password field, including any 
          * zero bytes that are encountered.
          */
-        if ((coder.context[FSCoder.Version] >= 5) && (length > 0))
+        if (length > 0)
         {
             coder.readWord(2, false);
-            password = coder.readString();
+            password = coder.readString(length-2);
         }        
         coder.endObject(name());
     }



From smackay at mail.berlios.de  Sat Dec 22 17:17:54 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:17:54 +0100
Subject: [Transform-svn] r276 - trunk/src/com/flagstone/transform
Message-ID: <200712221617.lBMGHsQt011004@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:17:49 +0100 (Sat, 22 Dec 2007)
New Revision: 276

Modified:
   trunk/src/com/flagstone/transform/FSDefineImage.java
   trunk/src/com/flagstone/transform/FSDefineImage2.java
Log:
Equals on FSDefineImage and FSDefineImage2 compares uncompressed images.

Modified: trunk/src/com/flagstone/transform/FSDefineImage.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineImage.java	2007-12-22 16:11:04 UTC (rev 275)
+++ trunk/src/com/flagstone/transform/FSDefineImage.java	2007-12-22 16:17:49 UTC (rev 276)
@@ -1,38 +1,41 @@
 /*
  * FSDefineImage.java
  * Transform
- * 
+ *
  * Copyright (c) 2001-2006 Flagstone Software Ltd. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
  *  * Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright notice, 
- *    this list of conditions and the following disclaimer in the documentation 
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
- *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors 
- *    may be used to endorse or promote products derived from this software 
+ *  * Neither the name of Flagstone Software Ltd. nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 package com.flagstone.transform;
 
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+
 /**
-FSDefineImage is used to define an image compressed using the lossless zlib compression algorithm. 
- 
+FSDefineImage is used to define an image compressed using the lossless zlib compression algorithm.
+
 <p>The class supports colour-mapped images where the image data contains an index into a colour table or images where the image data specifies the colour directly.</p>
 
 <table class="datasheet">
@@ -103,13 +106,13 @@
 
     private int pixelSize = 8;
     private int tableSize = 0;
-    
+
     private byte[] compressedData = null;
 
     /**
-     * Construct an FSDefineImage object, initalizing it with values decoded 
+     * Construct an FSDefineImage object, initalizing it with values decoded
      * from an encoded object.
-     * 
+     *
      * @param coder an FSCoder containing the binary data.
      */
     public FSDefineImage(FSCoder coder)
@@ -119,7 +122,7 @@
         decode(coder);
     }
     /** Constructs an FSDefineImage object defining a colour-mapped image.
-        
+
         @param anIdentifier    the unique identifier for this object
         @param width the width of the image.
         @param height the height of the image.
@@ -138,7 +141,7 @@
     }
 
     /** Constructs an FSDefineImage object defining an image that specifies the colour directly.
-        
+
         @param anIdentifier    the unique identifier for this object
         @param width the width of the image.
         @param height the height of the image.
@@ -154,9 +157,9 @@
         setPixelSize(aPixelSize);
         setTableSize(0);
         setCompressedData(compressedBytes);
-    }    
+    }
     /**
-     * Constructs an FSDefineImage object by copying values from an existing 
+     * Constructs an FSDefineImage object by copying values from an existing
      * object.
      *
      * @param obj an FSDefineImage object.
@@ -168,17 +171,17 @@
         height = obj.height;
         pixelSize = obj.pixelSize;
         tableSize = obj.tableSize;
-        compressedData = Transform.clone(obj.compressedData);        
-    }    
+        compressedData = Transform.clone(obj.compressedData);
+    }
 
-    /** Gets the width of the image. 
+    /** Gets the width of the image.
 
         @return the width of the image.
         */
     public int getWidth()
     {
-        return width; 
-    }    
+        return width;
+    }
 
     /** Gets the height of the image.
 
@@ -264,33 +267,57 @@
     public Object clone()
     {
         FSDefineImage anObject = (FSDefineImage)super.clone();
-        
+
         anObject.compressedData = Transform.clone(compressedData);
-        
+
         return anObject;
     }
 
     public boolean equals(Object anObject)
     {
         boolean result = false;
-        
+
         if (super.equals(anObject))
         {
             FSDefineImage typedObject = (FSDefineImage)anObject;
-            
+
             result = pixelSize == typedObject.pixelSize;
             result = result && width == typedObject.width;
             result = result && height == typedObject.height;
             result = result && tableSize == typedObject.tableSize;
-            result = result && Transform.equals(compressedData, typedObject.compressedData);
+
+            try
+            {
+            	result = result && Transform.equals(unzip(compressedData), unzip(typedObject.compressedData));
+            }
+            catch (DataFormatException e)
+            {
+            	result = false;
+            }
         }
         return result;
     }
 
+    private byte[] unzip(byte[] bytes) throws DataFormatException
+    {
+        byte[] data = new byte[width*height*8];
+        int count = 0;
+
+        Inflater inflater = new Inflater();
+        inflater.setInput(bytes);
+        count = inflater.inflate(data);
+
+        byte[] uncompressedData = new byte[count];
+
+        System.arraycopy(data, 0, uncompressedData, 0, count);
+
+        return uncompressedData;
+    }
+
     public void appendDescription(StringBuffer buffer, int depth)
     {
         buffer.append(name());
-        
+
         if (depth > 0)
         {
             buffer.append(": { ");
@@ -310,10 +337,10 @@
         length += 5;
         length += (pixelSize == 8) ? 1 : 0;
         length += compressedData.length;
-        
+
         return length;
     }
-    
+
     public void encode(FSCoder coder)
     {
         coder.beginObject(name());
@@ -332,21 +359,21 @@
                 coder.writeWord(5, 1);
                 break;
         }
-        
+
         coder.writeWord(width, 2);
         coder.writeWord(height, 2);
 
         if (pixelSize == 8)
             coder.writeWord(tableSize-1, 1);
-        
+
         coder.writeBytes(compressedData);
         coder.endObject(name());
     }
-    
+
     public void decode(FSCoder coder)
     {
         super.decode(coder);
-        
+
         switch (coder.readWord(1, false))
         {
             case 3:
@@ -359,7 +386,7 @@
                 pixelSize = 24;
                 break;
         }
-        
+
         width = coder.readWord(2, false);
         height = coder.readWord(2, false);
 

Modified: trunk/src/com/flagstone/transform/FSDefineImage2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineImage2.java	2007-12-22 16:11:04 UTC (rev 275)
+++ trunk/src/com/flagstone/transform/FSDefineImage2.java	2007-12-22 16:17:49 UTC (rev 276)
@@ -30,6 +30,9 @@
 
 package com.flagstone.transform;
 
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+
 /**
 FSDefineImage2 is used to define a transparent image compressed using the lossless 
 zlib compression algorithm. 
@@ -271,11 +274,35 @@
             result = result && width == typedObject.width;
             result = result && height == typedObject.height;
             result = result && tableSize == typedObject.tableSize;
-            result = result && Transform.equals(compressedData, typedObject.compressedData);
+
+            try
+            {
+            	result = result && Transform.equals(unzip(compressedData), unzip(typedObject.compressedData));
+            }
+            catch (DataFormatException e)
+            {
+            	result = false;
+            }
         }
         return result;
     }
 
+    private byte[] unzip(byte[] bytes) throws DataFormatException
+    {
+        byte[] data = new byte[width*height*8];
+        int count = 0;
+
+        Inflater inflater = new Inflater();
+        inflater.setInput(bytes);
+        count = inflater.inflate(data);
+
+        byte[] uncompressedData = new byte[count];
+
+        System.arraycopy(data, 0, uncompressedData, 0, count);
+
+        return uncompressedData;
+    }
+
     public void appendDescription(StringBuffer buffer, int depth)
     {
         buffer.append(name());



From smackay at mail.berlios.de  Sat Dec 22 17:20:44 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sat, 22 Dec 2007 17:20:44 +0100
Subject: [Transform-svn] r277 - in trunk: . doc doc/releases
Message-ID: <200712221620.lBMGKieJ011133@sheep.berlios.de>

Author: smackay
Date: 2007-12-22 17:20:29 +0100 (Sat, 22 Dec 2007)
New Revision: 277

Removed:
   trunk/test.xml
Modified:
   trunk/doc/CHANGES.txt
   trunk/doc/releases/transform-pre-2.1.6.txt
Log:
Updated changes and release notes.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2007-12-22 16:17:49 UTC (rev 276)
+++ trunk/doc/CHANGES.txt	2007-12-22 16:20:29 UTC (rev 277)
@@ -1,5 +1,56 @@
+2007-12-22 - smackay at flagstonesoftware.com
+
+    * build.xml: Removed the tools and docs targets so the build file only
+      supports the framework classes, contributed classes and examples.
+      
+    * developer.xml: removed patch target and added test target to compile 
+      the unit test classes. Merged generation of class datasheets into the
+      dest target. Also simplified the way releases are packaged.
+      
+    * Refactored test package classes to use JUnit instead of TestNG.
+    
+    * Removed com.flagstone.transform.tools package.
+    
+    * FSImageContructor.java: increase the buffer spaced used during compression
+      of images for the rare occasion where the compressed image is larger than
+      the original.
+      
+    * FSCoder.java: A method, boolean equals(Object obj), was added to FSCoder 
+      to support unit testing.
+      
+    * Fixed bug 12769 where the encoding tables with reversed SOI and EOI 
+      markers are now decoded correctly.
+      
+    * Fixed bug 9806. End Of Action markers (0x00) in the middle of a sequence 
+      of actions are now handled and the complete set of actions is decoded 
+      correctly. 
+
+    * Fixed bug 12747. Leading in FSDefineTextField is now decoded as an 
+      unsigned integer.
+      
+    * Fixed bug 12730. FSSerialNumber will now decode correctly if string 
+      contains null.
+      
+    * Fixed bug 12729. Flash 4 files containing a Protect data structure with 
+      an MD5 encoded password are now decoded correctly.
+      
+    * Fixed bug 12728. FSProtect with a string that contains null will be
+      decoded correctly.
+      
+    * Equals on FSDefineImage and FSDefineImage2 compares uncompressed images.
+
+If a password string contains a null byte in the middle of the string it will 
+still be decoded correctly.
+    
+2007-01-05 - smackay at flagstonesoftware.com
+
+    * Added main() method to FSMovieTest to allow tests to be run from the 
+      command line.
+
 2007-01-03 - smackay at flagstonesoftware.com
 
+    * released version 2.1.5.
+
     * Fixed Bug #9807. Latency for MP3 encoded streams is not optional.
     
     * Fixed Bug #9805. Trailing FSSound objects are optional if not set.
@@ -26,8 +77,7 @@
     * FSShapeConstructor: fixed a bug where drawing ellipses using pixels resulted
       in distorted shapes.
       
-      Updated bug list (#9718), reporting the error.
-      
+      Updated bug list (#9718), reporting the error.   
 
 2006-09-28 - smackay at flagstonesoftware.com
   

Modified: trunk/doc/releases/transform-pre-2.1.6.txt
===================================================================
--- trunk/doc/releases/transform-pre-2.1.6.txt	2007-12-22 16:17:49 UTC (rev 276)
+++ trunk/doc/releases/transform-pre-2.1.6.txt	2007-12-22 16:20:29 UTC (rev 277)
@@ -3,35 +3,139 @@
 ------------------------------------------------------------
 
 The release fixes a number of bugs and improves reliability when dealing with
-file that are "outside" of the Flash specification.
+file that are "outside" of the Flash specification. Testing is now carried out 
+using JUnit and way each release is packaged was simplified.
 
-
 Bug Fixes
-    None scheduled
+    12769. JPEG SOI and EOI markers are swapped on null encoding tables.
+    12768. Font name in FSDefineFont2, FSFontInfo[2] has trailing null.
+    12747. Leading in FSDefineTextField is decoded as unsigned.
+    12730. FSSerialNumber does not decode if string contains null.
+    12729. FSProtect will not decode Flash 4 files with passwords.
+    12728. FSProtect does not decode if string contains null.
+     9806. Transform cannot handle obfuscated actions.
 
 Class Changes
-    None scheduled
+    Equals method added to FSCoder.
+    Increased compression buffer on FSImageConstructor.
+    Equals on FSDefineImage and FSDefineImage2 compares uncompressed images.
     
 Testing Changes
-    None scheduled
+    JUnit replaces TestNG
+    Testing is simplified
     
 Package Changes
-    None scheduled
-
+    Releases simplified.
+	Tools package was removed.
   
 -------------
   Bug Fixes  
 -------------
 
+12769. JPEG SOI and EOI markers are swapped on null encoding tables.
+
+The readJPEGStream methods in FSDefineJPEG2 and FSDefineJPEG3 was updated and 
+the classes are now better able to decode encoding tables where the Start of 
+Image (SOI) and End of Image (EOI) markers are reversed.
+
+In FSDefineJPEG2 the order of the markers when specifying a NULL encoding table
+was incorrectly reversed. The correct order, 0xFFD8 (SOI), 0xFFD9 (EOI) is now
+used.
+
+12768. Font name in FSDefineFont2, FSFontInfo[2] has trailing null.
+
+The trailing null byte that was used to terminate the string in the FSDefineFont2, 
+FSFontInfo and FSFontInfo2 classes has now been removed.
+
+12747. Leading in FSDefineTextField is decoded as unsigned.
+
+The leading field, which defines the spacing between lines is now correctly 
+decoded as a signed integer.
+
+12730. FSSerialNumber does not decode if string contains null.
+
+If a serial number contains a null byte in the middle of the string it will 
+still be decoded correctly.
+
+12729. FSProtect will not decode Flash 4 files with passwords.
+
+Flash 4 files containing a Protect data structure with an MD5 encoded password
+are now decoded correctly.
+
+12728. FSProtect does not decode if string contains null.
+
+If a password string contains a null byte in the middle of the string it will 
+still be decoded correctly.
+
+9806. Transform cannot handle obfuscated actions.
+
+The decoding of actions in FSButtonEvent, FSClipEvent, FSDefineButton, 
+FSDoAction and FSInitialize is now able to handle causes where End of Action
+markers (0x00) are injected into the sequences of actions - perhaps as an 
+obfuscation technique to prematurely stop the decoding of actions.
+
 -----------------
   Class Changes  
 -----------------
 
+1. Equals method added to FSCoder.
+
+A method, boolean equals(Object obj), was added to FSCoder to support unit 
+testing.
+
+2. Increased compression buffer on FSImageConstructor.
+
+Increase the buffer spaced used during compression of images for the rare 
+occasion where the compressed image is larger than the original.
+
+3. Equals on FSDefineImage and FSDefineImage2 compares uncompressed images.
+
+The equals method on FSDefineImage and FSDefineImage2 now unzips the compressed
+images before comparing objects. This allows objects that contain identical 
+images but which were compressed with different parameters to pass as being 
+equal.
+
+This change was introduced primarily for testing to compare images created 
+by the Flash authoring tool to be compared with images compressed by the 
+Transform framework.
+
 -------------------
   Testing Changes  
 -------------------
 
+1. JUnit replaces TestNG.
+
+The classes used to unit test the framework were refactored to use JUnit. While
+TestNG is probably the more powerful of the two the simplicity and ease of use 
+of JUnit is hard to beat, especially since there is good support for executing 
+tests from within IDEs such as Eclipse.
+
+2. Testing is simplified.
+
+With the adoption of JUnit the approach to testing has been simplified. Testing 
+is now a simple pass/fail approach with the JUnit tests used to verify changes 
+made to the framework. This is ideal to verify correct operation of the classes,
+for example when testing different image or sound files or for verifying changes
+when submitting bug fixes.
+
+More detailed testing, particularly for significant changes to the way files 
+are encoded or decoded is now handled by a separate project where the way objects
+are encoded is verified using the Flash authoring tool as a reference.
+
 -------------------
   Package Changes  
 -------------------
 
+1. Releases simplified.
+
+Releases of the framework now only include documentation, jar file and source
+for the framework classes, contributed classes and examples. The goal is to
+strip down releases so they are easier to use within other projects. All the 
+files used to debug and test the framework  are still available from the 
+Subversion repository: https://svn.berlios.de/svnroot/repos/transform/trunk
+
+2. 	Tools package was removed.
+
+With the simplification of the way the framework is tested the TextDump class
+was no longer used and the package was removed from the release. If this causes
+any inconvenience please contact Flagstone.

Deleted: trunk/test.xml
===================================================================
--- trunk/test.xml	2007-12-22 16:17:49 UTC (rev 276)
+++ trunk/test.xml	2007-12-22 16:20:29 UTC (rev 277)
@@ -1,113 +0,0 @@
-<?xml version="1.0"?>
-<project name="transform-test" default="test" basedir=".">
-
-    <description>Test targets
-    
-        clean-test remove all the files generated when running any of the tests.
-        
-        build-test compile the classes used to test the framework.
-                    
-        test       run a full test of all the classes in the framework.
-        
-        class-test run the unit tests for an individual class. The target will
-                   prompt for the name of the class to test.
-        
-        benchmark  run a benchmark suite. The target will prompt for the name of
-                   the suite to run.   
-
-    </description>
-        
-    <import file="build.xml"/>
-
-    <property name="test.dir" location="test"/>
-    <property name="test.data.dir" value="${test.dir}/data"/>
-    <property name="test.suite.dir" value="${test.dir}/suites"/>
-    <property name="test.benchmark.dir" value="${test.dir}/benchmarks"/>
-    <property name="test.result.dir" value="${test.dir}/results"/>
-    <property name="test.report.dir" value="${test.dir}/reports"/>
-    
-    <condition property="testng.jar" value="testng-4.7-jdk14.jar">
-        <equals arg1="${ant.java.version}" arg2="1.4"/>
-    </condition>
-    
-    <condition property="testng.jar" value="testng-4.7-jdk15.jar">
-        <equals arg1="${ant.java.version}" arg2="1.5"/>
-    </condition>
-    
-    <taskdef resource="testngtasks"  classpath="${lib.dir}/${testng.jar}"/>
-    
-    <target name="clean-test" 
-        description="Remove all the files and reports generating during testing">
-        
-        <delete failonerror="false" includeemptydirs="true">
-            <fileset dir="${test.result.dir}" includes="**/*"/>
-        </delete>
-        
-        <delete failonerror="false" includeemptydirs="true">
-            <fileset dir="${test.report.dir}" includes="**/*"/>
-        </delete>
-        
-    </target>
-
-    <target name="build-test" description="Compile test classes">
-    
-        <mkdir dir="${build.dir}"/>
-        <javac srcdir="${src.dir}" destdir="${build.dir}" 
-            debug="off" optimize="on" source="1.4">
-            <include name="${package.test.dir}/*.java" />
-        </javac>
-        
-    </target>
-         
-    <target name="test" depends="build,build-test" 
-        description="Test the classes in the framework">
-
-        <antcall target="class-test">
-            <param name="test.class" value="Transform"/>
-        </antcall>
-        
-    </target>
-
-    <target name="class-test" description="Unit test a specific class in the framework">
-    
-        <input message="Enter the name of the class to test:"
-            addProperty="test.class"/>
-
-        <mkdir dir="${test.report.dir}/${test.class}"/>
-        
-        <delete failonerror="false" includeemptydirs="true">
-            <fileset dir="${test.report.dir}/${test.class}" includes="**/*"/>
-        </delete>
-
-        <testng classpath="${build.dir}" 
-                outputDir="${test.report.dir}/${test.class}"
-                sourceDir = "src/${package.test.dir}"
-                haltOnFailure = "true">
-            <jvmarg value="-ea" />
-            <xmlfileset dir="${test.suite.dir}" includes="${test.class}.xml"/>
-        </testng>
-        
-    </target>
-        
-    <target name="benchmark" description="Run a benchmark suite">
-    
-        <input message="Enter the name of the benchmark to run:"
-            addProperty="benchmark.suite"/>
-
-        <mkdir dir="${test.report.dir}/${benchmark.suite}"/>
-        
-        <delete failonerror="false" includeemptydirs="true">
-            <fileset dir="${test.report.dir}/${benchmark.suite}" includes="**/*"/>
-        </delete>
-
-        <testng classpath="${build.dir}" 
-                outputDir="${test.report.dir}/${benchmark.suite}"
-                sourceDir = "src/${package.test.dir}"
-                haltOnFailure = "true">
-            <jvmarg value="-ea" />
-            <xmlfileset dir="${test.benchmark.dir}" includes="${benchmark.suite}.xml"/>
-        </testng>
-        
-    </target>
-        
-</project>



From smackay at mail.berlios.de  Sun Dec 23 08:21:56 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Sun, 23 Dec 2007 08:21:56 +0100
Subject: [Transform-svn] r278 - trunk/src/com/flagstone/transform/util
Message-ID: <200712230721.lBN7LuIW006413@sheep.berlios.de>

Author: smackay
Date: 2007-12-23 08:21:53 +0100 (Sun, 23 Dec 2007)
New Revision: 278

Modified:
   trunk/src/com/flagstone/transform/util/FSTextConstructor.java
Log:
Fixed bug 12776. The offset to the string table in the NAME block of TrueType files is not calculated relative to the start of the block rather than an absolute address.

Modified: trunk/src/com/flagstone/transform/util/FSTextConstructor.java
===================================================================
--- trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2007-12-22 16:20:29 UTC (rev 277)
+++ trunk/src/com/flagstone/transform/util/FSTextConstructor.java	2007-12-23 07:21:53 UTC (rev 278)
@@ -1474,9 +1474,11 @@
     }
     private void decodeNAME(FSCoder coder)
     {
+    	int stringTableBase = coder.getPointer() >>> 3;
+    	
         int format = coder.readWord(2, false);
         int numberOfNameRecords = coder.readWord(2, false);
-        int stringTable = coder.readWord(2, false);
+        int stringTable = coder.readWord(2, false) + stringTableBase;
         
         for (int i=0; i<numberOfNameRecords; i++) 
         {



From smackay at mail.berlios.de  Mon Dec 31 14:52:30 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Mon, 31 Dec 2007 14:52:30 +0100
Subject: [Transform-svn] r279 - trunk/doc/releases
Message-ID: <200712311352.lBVDqUJe015534@sheep.berlios.de>

Author: smackay
Date: 2007-12-31 14:52:25 +0100 (Mon, 31 Dec 2007)
New Revision: 279

Modified:
   trunk/doc/releases/transform-pre-2.1.6.txt
Log:
Updated with latest changes.

Modified: trunk/doc/releases/transform-pre-2.1.6.txt
===================================================================
--- trunk/doc/releases/transform-pre-2.1.6.txt	2007-12-23 07:21:53 UTC (rev 278)
+++ trunk/doc/releases/transform-pre-2.1.6.txt	2007-12-31 13:52:25 UTC (rev 279)
@@ -7,6 +7,7 @@
 using JUnit and way each release is packaged was simplified.
 
 Bug Fixes
+    12776. NAME block in TrueType fonts is not decoded correctly.
     12769. JPEG SOI and EOI markers are swapped on null encoding tables.
     12768. Font name in FSDefineFont2, FSFontInfo[2] has trailing null.
     12747. Leading in FSDefineTextField is decoded as unsigned.
@@ -26,12 +27,17 @@
     
 Package Changes
     Releases simplified.
-	Tools package was removed.
+    Tools package was removed.
   
 -------------
   Bug Fixes  
 -------------
 
+12776. NAME block in TrueType fonts is not decoded correctly.
+
+The NAME block in TrueType font files which contains the name of the font, 
+copyright information and other font related strings is now decoded correctly.
+
 12769. JPEG SOI and EOI markers are swapped on null encoding tables.
 
 The readJPEGStream methods in FSDefineJPEG2 and FSDefineJPEG3 was updated and 
@@ -134,7 +140,7 @@
 files used to debug and test the framework  are still available from the 
 Subversion repository: https://svn.berlios.de/svnroot/repos/transform/trunk
 
-2. 	Tools package was removed.
+2. Tools package was removed.
 
 With the simplification of the way the framework is tested the TextDump class
 was no longer used and the package was removed from the release. If this causes



From smackay at mail.berlios.de  Mon Dec 31 14:53:08 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Mon, 31 Dec 2007 14:53:08 +0100
Subject: [Transform-svn] r280 - trunk/doc/releases
Message-ID: <200712311353.lBVDr8ac015591@sheep.berlios.de>

Author: smackay
Date: 2007-12-31 14:53:04 +0100 (Mon, 31 Dec 2007)
New Revision: 280

Added:
   trunk/doc/releases/transform-2.1.6.txt
Log:
Added final release notes for 2.1.6.

Added: trunk/doc/releases/transform-2.1.6.txt
===================================================================
--- trunk/doc/releases/transform-2.1.6.txt	2007-12-31 13:52:25 UTC (rev 279)
+++ trunk/doc/releases/transform-2.1.6.txt	2007-12-31 13:53:04 UTC (rev 280)
@@ -0,0 +1,147 @@
+------------------------------------------------------------
+  Release Notes for Transform SWF for Java, Version 2.1.6.
+------------------------------------------------------------
+
+The release fixes a number of bugs and improves reliability when dealing with
+file that are "outside" of the Flash specification. Testing is now carried out 
+using JUnit and way each release is packaged was simplified.
+
+Bug Fixes
+    12776. NAME block in TrueType fonts is not decoded correctly.
+    12769. JPEG SOI and EOI markers are swapped on null encoding tables.
+    12768. Font name in FSDefineFont2, FSFontInfo[2] has trailing null.
+    12747. Leading in FSDefineTextField is decoded as unsigned.
+    12730. FSSerialNumber does not decode if string contains null.
+    12729. FSProtect will not decode Flash 4 files with passwords.
+    12728. FSProtect does not decode if string contains null.
+     9806. Transform cannot handle obfuscated actions.
+
+Class Changes
+    Equals method added to FSCoder.
+    Increased compression buffer on FSImageConstructor.
+    Equals on FSDefineImage and FSDefineImage2 compares uncompressed images.
+    
+Testing Changes
+    JUnit replaces TestNG
+    Testing is simplified
+    
+Package Changes
+    Releases simplified.
+    Tools package was removed.
+  
+-------------
+  Bug Fixes  
+-------------
+
+12776. NAME block in TrueType fonts is not decoded correctly.
+
+The NAME block in TrueType font files which contains the name of the font, 
+copyright information and other font related strings is now decoded correctly.
+
+12769. JPEG SOI and EOI markers are swapped on null encoding tables.
+
+The readJPEGStream methods in FSDefineJPEG2 and FSDefineJPEG3 was updated and 
+the classes are now better able to decode encoding tables where the Start of 
+Image (SOI) and End of Image (EOI) markers are reversed.
+
+In FSDefineJPEG2 the order of the markers when specifying a NULL encoding table
+was incorrectly reversed. The correct order, 0xFFD8 (SOI), 0xFFD9 (EOI) is now
+used.
+
+12768. Font name in FSDefineFont2, FSFontInfo[2] has trailing null.
+
+The trailing null byte that was used to terminate the string in the FSDefineFont2, 
+FSFontInfo and FSFontInfo2 classes has now been removed.
+
+12747. Leading in FSDefineTextField is decoded as unsigned.
+
+The leading field, which defines the spacing between lines is now correctly 
+decoded as a signed integer.
+
+12730. FSSerialNumber does not decode if string contains null.
+
+If a serial number contains a null byte in the middle of the string it will 
+still be decoded correctly.
+
+12729. FSProtect will not decode Flash 4 files with passwords.
+
+Flash 4 files containing a Protect data structure with an MD5 encoded password
+are now decoded correctly.
+
+12728. FSProtect does not decode if string contains null.
+
+If a password string contains a null byte in the middle of the string it will 
+still be decoded correctly.
+
+9806. Transform cannot handle obfuscated actions.
+
+The decoding of actions in FSButtonEvent, FSClipEvent, FSDefineButton, 
+FSDoAction and FSInitialize is now able to handle causes where End of Action
+markers (0x00) are injected into the sequences of actions - perhaps as an 
+obfuscation technique to prematurely stop the decoding of actions.
+
+-----------------
+  Class Changes  
+-----------------
+
+1. Equals method added to FSCoder.
+
+A method, boolean equals(Object obj), was added to FSCoder to support unit 
+testing.
+
+2. Increased compression buffer on FSImageConstructor.
+
+Increase the buffer spaced used during compression of images for the rare 
+occasion where the compressed image is larger than the original.
+
+3. Equals on FSDefineImage and FSDefineImage2 compares uncompressed images.
+
+The equals method on FSDefineImage and FSDefineImage2 now unzips the compressed
+images before comparing objects. This allows objects that contain identical 
+images but which were compressed with different parameters to pass as being 
+equal.
+
+This change was introduced primarily for testing to compare images created 
+by the Flash authoring tool to be compared with images compressed by the 
+Transform framework.
+
+-------------------
+  Testing Changes  
+-------------------
+
+1. JUnit replaces TestNG.
+
+The classes used to unit test the framework were refactored to use JUnit. While
+TestNG is probably the more powerful of the two the simplicity and ease of use 
+of JUnit is hard to beat, especially since there is good support for executing 
+tests from within IDEs such as Eclipse.
+
+2. Testing is simplified.
+
+With the adoption of JUnit the approach to testing has been simplified. Testing 
+is now a simple pass/fail approach with the JUnit tests used to verify changes 
+made to the framework. This is ideal to verify correct operation of the classes,
+for example when testing different image or sound files or for verifying changes
+when submitting bug fixes.
+
+More detailed testing, particularly for significant changes to the way files 
+are encoded or decoded is now handled by a separate project where the way objects
+are encoded is verified using the Flash authoring tool as a reference.
+
+-------------------
+  Package Changes  
+-------------------
+
+1. Releases simplified.
+
+Releases of the framework now only include documentation, jar file and source
+for the framework classes, contributed classes and examples. The goal is to
+strip down releases so they are easier to use within other projects. All the 
+files used to debug and test the framework  are still available from the 
+Subversion repository: https://svn.berlios.de/svnroot/repos/transform/trunk
+
+2. Tools package was removed.
+
+With the simplification of the way the framework is tested the TextDump class
+was no longer used and the package was removed from the release. If this causes
+any inconvenience please contact Flagstone.



From smackay at mail.berlios.de  Mon Dec 31 14:53:26 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Mon, 31 Dec 2007 14:53:26 +0100
Subject: [Transform-svn] r281 - trunk/doc
Message-ID: <200712311353.lBVDrQ8N015607@sheep.berlios.de>

Author: smackay
Date: 2007-12-31 14:53:21 +0100 (Mon, 31 Dec 2007)
New Revision: 281

Modified:
   trunk/doc/CHANGES.txt
Log:
Updated with latest changes.

Modified: trunk/doc/CHANGES.txt
===================================================================
--- trunk/doc/CHANGES.txt	2007-12-31 13:53:04 UTC (rev 280)
+++ trunk/doc/CHANGES.txt	2007-12-31 13:53:21 UTC (rev 281)
@@ -1,3 +1,12 @@
+2007-12-31 - smackay at flagstonesoftware.com
+
+    * released 2.1.6.
+
+2007-12-23 - smackay at flagstonesoftware.com
+
+    * Fixed bug 12776 so that the strings stored in a TrueType font file are
+      decoded correctly.
+
 2007-12-22 - smackay at flagstonesoftware.com
 
     * build.xml: Removed the tools and docs targets so the build file only



From smackay at mail.berlios.de  Mon Dec 31 14:56:03 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Mon, 31 Dec 2007 14:56:03 +0100
Subject: [Transform-svn] r282 - trunk/src/com/flagstone/transform
Message-ID: <200712311356.lBVDu3nM015743@sheep.berlios.de>

Author: smackay
Date: 2007-12-31 14:55:47 +0100 (Mon, 31 Dec 2007)
New Revision: 282

Modified:
   trunk/src/com/flagstone/transform/FSCoder.java
Log:
corrected errors in documentation.

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2007-12-31 13:53:21 UTC (rev 281)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2007-12-31 13:55:47 UTC (rev 282)
@@ -357,7 +357,7 @@
      * Return the string representation of the character encoding scheme used
      * when encoding or decoding strings as a sequence of bytes.
      * 
-     * @return the string the name of the encoding schemd for characters.
+     * @return the string the name of the encoding scheme for characters.
      */
     public String getEncoding()
     {
@@ -367,7 +367,7 @@
      * Sets the string representation of the character encoding scheme used
      * when encoding or decoding strings as a sequence of bytes.
      * 
-     * @return enc, the string the name of the encoding schemd for characters.
+     * @param enc, the string the name of the encoding scheme for characters.
      */
     public void setEncoding(String enc)
     {



From smackay at mail.berlios.de  Mon Dec 31 14:57:34 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Mon, 31 Dec 2007 14:57:34 +0100
Subject: [Transform-svn] r283 - trunk/src/com/flagstone/transform
Message-ID: <200712311357.lBVDvYvq015906@sheep.berlios.de>

Author: smackay
Date: 2007-12-31 14:57:30 +0100 (Mon, 31 Dec 2007)
New Revision: 283

Modified:
   trunk/src/com/flagstone/transform/FSCoder.java
Log:
Removed comma after parameter name

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2007-12-31 13:55:47 UTC (rev 282)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2007-12-31 13:57:30 UTC (rev 283)
@@ -367,7 +367,7 @@
      * Sets the string representation of the character encoding scheme used
      * when encoding or decoding strings as a sequence of bytes.
      * 
-     * @param enc, the string the name of the encoding scheme for characters.
+     * @param enc the string the name of the encoding scheme for characters.
      */
     public void setEncoding(String enc)
     {



From smackay at mail.berlios.de  Mon Dec 31 15:58:10 2007
From: smackay at mail.berlios.de (smackay at mail.berlios.de)
Date: Mon, 31 Dec 2007 15:58:10 +0100
Subject: [Transform-svn] r284 - tags
Message-ID: <200712311458.lBVEwAQO019195@sheep.berlios.de>

Author: smackay
Date: 2007-12-31 15:58:06 +0100 (Mon, 31 Dec 2007)
New Revision: 284

Added:
   tags/rel-2-1-6/
Log:


Copied: tags/rel-2-1-6 (from rev 283, trunk)



