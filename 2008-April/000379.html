<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Transform-svn] r439 - trunk/src/com/flagstone/transform
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/transform-svn/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r439%20-%20trunk/src/com/flagstone/transform&In-Reply-To=%3C200804041350.m34Do9Gf028377%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000374.html">
   <LINK REL="Next"  HREF="000375.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Transform-svn] r439 - trunk/src/com/flagstone/transform</H1>
    <B>smackay at mail.berlios.de</B> 
    <A HREF="mailto:transform-svn%40lists.berlios.de?Subject=Re%3A%20%5BTransform-svn%5D%20r439%20-%20trunk/src/com/flagstone/transform&In-Reply-To=%3C200804041350.m34Do9Gf028377%40sheep.berlios.de%3E"
       TITLE="[Transform-svn] r439 - trunk/src/com/flagstone/transform">smackay at mail.berlios.de
       </A><BR>
    <I>Fri Apr  4 15:50:09 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000374.html">[Transform-svn] r438 - dev/dev-3-0/src/com/flagstone/transform
</A></li>
        <LI>Next message: <A HREF="000375.html">[Transform-svn] r440 - dev/dev-3-0/src/com/flagstone/transform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#379">[ date ]</a>
              <a href="thread.html#379">[ thread ]</a>
              <a href="subject.html#379">[ subject ]</a>
              <a href="author.html#379">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: smackay
Date: 2008-04-04 15:47:40 +0200 (Fri, 04 Apr 2008)
New Revision: 439

Modified:
   trunk/src/com/flagstone/transform/FSAction.java
   trunk/src/com/flagstone/transform/FSActionObject.java
   trunk/src/com/flagstone/transform/FSAudioData.java
   trunk/src/com/flagstone/transform/FSBitmapFill.java
   trunk/src/com/flagstone/transform/FSBounds.java
   trunk/src/com/flagstone/transform/FSButton.java
   trunk/src/com/flagstone/transform/FSButtonColorTransform.java
   trunk/src/com/flagstone/transform/FSButtonEvent.java
   trunk/src/com/flagstone/transform/FSButtonSound.java
   trunk/src/com/flagstone/transform/FSCall.java
   trunk/src/com/flagstone/transform/FSCharacter.java
   trunk/src/com/flagstone/transform/FSClipEvent.java
   trunk/src/com/flagstone/transform/FSCoder.java
   trunk/src/com/flagstone/transform/FSCoderException.java
   trunk/src/com/flagstone/transform/FSColor.java
   trunk/src/com/flagstone/transform/FSColorTable.java
   trunk/src/com/flagstone/transform/FSColorTransform.java
   trunk/src/com/flagstone/transform/FSCoordTransform.java
   trunk/src/com/flagstone/transform/FSCurve.java
   trunk/src/com/flagstone/transform/FSDefineButton.java
   trunk/src/com/flagstone/transform/FSDefineButton2.java
   trunk/src/com/flagstone/transform/FSDefineFont.java
   trunk/src/com/flagstone/transform/FSDefineFont2.java
   trunk/src/com/flagstone/transform/FSDefineImage.java
   trunk/src/com/flagstone/transform/FSDefineImage2.java
   trunk/src/com/flagstone/transform/FSDefineJPEGImage.java
   trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java
   trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java
   trunk/src/com/flagstone/transform/FSDefineMorphShape.java
   trunk/src/com/flagstone/transform/FSDefineMovieClip.java
   trunk/src/com/flagstone/transform/FSDefineObject.java
   trunk/src/com/flagstone/transform/FSDefineShape.java
   trunk/src/com/flagstone/transform/FSDefineShape2.java
   trunk/src/com/flagstone/transform/FSDefineShape3.java
   trunk/src/com/flagstone/transform/FSDefineSound.java
   trunk/src/com/flagstone/transform/FSDefineText.java
   trunk/src/com/flagstone/transform/FSDefineText2.java
   trunk/src/com/flagstone/transform/FSDefineTextField.java
   trunk/src/com/flagstone/transform/FSDefineVideo.java
   trunk/src/com/flagstone/transform/FSDoAction.java
   trunk/src/com/flagstone/transform/FSEnableDebugger.java
   trunk/src/com/flagstone/transform/FSEnableDebugger2.java
   trunk/src/com/flagstone/transform/FSEnvelope.java
   trunk/src/com/flagstone/transform/FSExceptionHandler.java
   trunk/src/com/flagstone/transform/FSExport.java
   trunk/src/com/flagstone/transform/FSFillStyle.java
   trunk/src/com/flagstone/transform/FSFontInfo.java
   trunk/src/com/flagstone/transform/FSFontInfo2.java
   trunk/src/com/flagstone/transform/FSFrame.java
   trunk/src/com/flagstone/transform/FSFrameLabel.java
   trunk/src/com/flagstone/transform/FSFree.java
   trunk/src/com/flagstone/transform/FSGetUrl.java
   trunk/src/com/flagstone/transform/FSGetUrl2.java
   trunk/src/com/flagstone/transform/FSGotoFrame.java
   trunk/src/com/flagstone/transform/FSGotoFrame2.java
   trunk/src/com/flagstone/transform/FSGotoLabel.java
   trunk/src/com/flagstone/transform/FSGradient.java
   trunk/src/com/flagstone/transform/FSGradientFill.java
   trunk/src/com/flagstone/transform/FSHeader.java
   trunk/src/com/flagstone/transform/FSIf.java
   trunk/src/com/flagstone/transform/FSImageBlock.java
   trunk/src/com/flagstone/transform/FSImport.java
   trunk/src/com/flagstone/transform/FSInitialize.java
   trunk/src/com/flagstone/transform/FSJPEGEncodingTable.java
   trunk/src/com/flagstone/transform/FSJump.java
   trunk/src/com/flagstone/transform/FSKerning.java
   trunk/src/com/flagstone/transform/FSLayer.java
   trunk/src/com/flagstone/transform/FSLimitScript.java
   trunk/src/com/flagstone/transform/FSLine.java
   trunk/src/com/flagstone/transform/FSLineStyle.java
   trunk/src/com/flagstone/transform/FSMorphBitmapFill.java
   trunk/src/com/flagstone/transform/FSMorphGradient.java
   trunk/src/com/flagstone/transform/FSMorphGradientFill.java
   trunk/src/com/flagstone/transform/FSMorphSolidFill.java
   trunk/src/com/flagstone/transform/FSMorphSolidLine.java
   trunk/src/com/flagstone/transform/FSMovie.java
   trunk/src/com/flagstone/transform/FSMovieEvent.java
   trunk/src/com/flagstone/transform/FSMovieListener.java
   trunk/src/com/flagstone/transform/FSMovieObject.java
   trunk/src/com/flagstone/transform/FSNewFunction.java
   trunk/src/com/flagstone/transform/FSNewFunction2.java
   trunk/src/com/flagstone/transform/FSNull.java
   trunk/src/com/flagstone/transform/FSPathsArePostscript.java
   trunk/src/com/flagstone/transform/FSPlaceObject.java
   trunk/src/com/flagstone/transform/FSPlaceObject2.java
   trunk/src/com/flagstone/transform/FSPointer.java
   trunk/src/com/flagstone/transform/FSProperty.java
   trunk/src/com/flagstone/transform/FSProtect.java
   trunk/src/com/flagstone/transform/FSPush.java
   trunk/src/com/flagstone/transform/FSQuicktimeMovie.java
   trunk/src/com/flagstone/transform/FSRegisterCopy.java
   trunk/src/com/flagstone/transform/FSRegisterIndex.java
   trunk/src/com/flagstone/transform/FSRegisterVariable.java
   trunk/src/com/flagstone/transform/FSRemoveObject.java
   trunk/src/com/flagstone/transform/FSRemoveObject2.java
   trunk/src/com/flagstone/transform/FSScreenVideoPacket.java
   trunk/src/com/flagstone/transform/FSSerialNumber.java
   trunk/src/com/flagstone/transform/FSSetBackgroundColor.java
   trunk/src/com/flagstone/transform/FSSetTarget.java
   trunk/src/com/flagstone/transform/FSShape.java
   trunk/src/com/flagstone/transform/FSShapeStyle.java
   trunk/src/com/flagstone/transform/FSShowFrame.java
   trunk/src/com/flagstone/transform/FSSolidFill.java
   trunk/src/com/flagstone/transform/FSSolidLine.java
   trunk/src/com/flagstone/transform/FSSound.java
   trunk/src/com/flagstone/transform/FSSoundStreamBlock.java
   trunk/src/com/flagstone/transform/FSSoundStreamHead.java
   trunk/src/com/flagstone/transform/FSSoundStreamHead2.java
   trunk/src/com/flagstone/transform/FSStartSound.java
   trunk/src/com/flagstone/transform/FSTabOrder.java
   trunk/src/com/flagstone/transform/FSTable.java
   trunk/src/com/flagstone/transform/FSTableIndex.java
   trunk/src/com/flagstone/transform/FSText.java
   trunk/src/com/flagstone/transform/FSTransformObject.java
   trunk/src/com/flagstone/transform/FSUnknownAction.java
   trunk/src/com/flagstone/transform/FSUnknownObject.java
   trunk/src/com/flagstone/transform/FSVideo.java
   trunk/src/com/flagstone/transform/FSVideoData.java
   trunk/src/com/flagstone/transform/FSVideoFrame.java
   trunk/src/com/flagstone/transform/FSVideoMetaData.java
   trunk/src/com/flagstone/transform/FSVideoObject.java
   trunk/src/com/flagstone/transform/FSVoid.java
   trunk/src/com/flagstone/transform/FSWaitForFrame.java
   trunk/src/com/flagstone/transform/FSWaitForFrame2.java
   trunk/src/com/flagstone/transform/FSWith.java
   trunk/src/com/flagstone/transform/Transform.java
Log:
Cleaned up an formatted documentation.

Modified: trunk/src/com/flagstone/transform/FSAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSAction.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSAction.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,1178 +30,2050 @@
 
 package com.flagstone.transform;
 
-/** 
-The FSAction class is used to represent stack-based actions, defined by simple byte-codes, that 
-are executed by the Flash Player.
- 
-&lt;p&gt;The operations supported by the FSAction class are:&lt;/p&gt;
+/**
+ * The FSAction class is used to represent stack-based actions, defined by
+ * simple byte-codes, that are executed by the Flash Player.
+ * 
+ * &lt;p&gt;
+ * The operations supported by the FSAction class are:
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Stack Manipulation&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Pop&lt;/td&gt;
+ * &lt;td&gt;Pop value from the top of the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Duplicate&lt;/td&gt;
+ * &lt;td&gt;Duplicate the value at the top of the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA -- valueA valueA)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 -- 4 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Swap&lt;/td&gt;
+ * &lt;td&gt;Swap the top two values on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA valueB -- valueB valueA)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 3 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSPush is used to push literals onto the Stack. See also FSRegisterCopy which
+ * copies the value on top of the Stack to one of the Flash Player's internal
+ * registers.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Arithmetic&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Add&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Add: A + B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 7)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Subtract&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Subtract: A - B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Multiply&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Multiply: A * B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 12)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Divide&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Divide: A / B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 1.333)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Modulo&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Modulo: A % B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Increment&lt;/td&gt;
+ * &lt;td&gt;Add 1 to the value on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Decrement&lt;/td&gt;
+ * &lt;td&gt;Subtracted 1 from the value on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Arithmetic add is supported by two actions. IntegerAdd was introduced in
+ * Flash 4. It was replaced in Flash 5 by the more flexible Add action which is
+ * able to add any two numbers and also concatenate strings. If a string and a
+ * number are added then the number is converted to its string representation
+ * before concatenation.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Comparison&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Less&lt;/td&gt;
+ * &lt;td&gt;LessThan: A &lt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringLess&lt;/td&gt;
+ * &lt;td&gt;String compare: stringA &lt; stringB&lt;/td&gt;
+ * &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Equals&lt;/td&gt;
+ * &lt;td&gt;Equals: A == B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(23 23 -- 1 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringEquals&lt;/td&gt;
+ * &lt;td&gt;String compare: stringA == stringB&lt;/td&gt;
+ * &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; &quot;abc&quot; -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StrictEquals&lt;/td&gt;
+ * &lt;td&gt;Equals: A === B, are the types as well as the values equal.&lt;/td&gt;
+ * &lt;td nowrap&gt;(valueA valueB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;23&quot; 23 -- 0 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Greater&lt;/td&gt;
+ * &lt;td&gt;Greater Than: A &gt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringGreater&lt;/td&gt;
+ * &lt;td&gt;String compare: stringA &gt; stringB&lt;/td&gt;
+ * &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The less than comparison is supported by IntegerLess introduced in Flash 4
+ * and Less introduced in Flash 5. The Less action is more flexible allowing
+ * comparison between any combination of two numbers and strings. In Flash 4
+ * comparisons were only supported on values of the same type using either
+ * IntegerLess or StringLess.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The equals comparison is supported by IntegerEquals introduced in Flash 4 and
+ * Equals introduced in Flash 5. The Equals action is more flexible allowing
+ * comparison between any combination of two numbers and strings. In Flash 4
+ * comparisons were only supported on values of the same type using either
+ * IntegerEquals or StringEquals.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Logical&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;And&lt;/td&gt;
+ * &lt;td&gt;Logical And: A &amp;&amp; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 0 -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Or&lt;/td&gt;
+ * &lt;td&gt;Logical Or: A || B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 0 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Not&lt;/td&gt;
+ * &lt;td&gt;Logical Not: !A&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 -- 0)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Bitwise&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;BitwiseAnd&lt;/td&gt;
+ * &lt;td&gt;Bitwise And: A &amp; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(5 4 -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;BitwiseOr&lt;/td&gt;
+ * &lt;td&gt;Bitwise Or: A | B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(5 4 -- 5)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;BitwiseXOr&lt;/td&gt;
+ * &lt;td&gt;Bitwise Exclusive-Or: A ^ B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(5 4 -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;LogicalShiftLeft&lt;/td&gt;
+ * &lt;td&gt;Logical Shift Left: A &lt;&lt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(4 1 -- 8)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;LogicalShiftRight&lt;/td&gt;
+ * &lt;td&gt;Logical Shift Right: A &gt;&gt;&gt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(8 1 -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ArithmeticShiftRight&lt;/td&gt;
+ * &lt;td&gt;Arithmetic Shift Right (sign extension): A &gt;&gt; B&lt;/td&gt;
+ * &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(-1 1 -- -1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;String&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringAdd&lt;/td&gt;
+ * &lt;td&gt;Concatenate two strings&lt;/td&gt;
+ * &lt;td nowrap&gt;(string string -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;ab&quot; &quot;cd&quot; -- &quot;abcd&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringLength&lt;/td&gt;
+ * &lt;td&gt;Returns the length of a string&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBStringLength&lt;/td&gt;
+ * &lt;td&gt;Returns the length of a string that contains characters from an extended
+ * set such as Unicode.&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StringExtract&lt;/td&gt;
+ * &lt;td&gt;Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string starting at
+ * position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBStringExtract&lt;/td&gt;
+ * &lt;td&gt;Multi-byte Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string
+ * starting at position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Type Conversion&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToInteger&lt;/td&gt;
+ * &lt;td&gt;Converts the value to an integer&lt;/td&gt;
+ * &lt;td nowrap&gt; ( num -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt; ( 3.2 -- 3 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToNumber&lt;/td&gt;
+ * &lt;td&gt;Converts the string value to a number.&lt;/td&gt;
+ * &lt;td nowrap&gt; ( string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt; ( &quot;3.2&quot; -- 3.2 )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToString&lt;/td&gt;
+ * &lt;td&gt;Converts the value to a string.&lt;/td&gt;
+ * &lt;td nowrap&gt; ( num -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt; ( 3.2 -- &quot;3.2&quot; )&lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;CharToAscii&lt;/td&gt;
+ * &lt;td&gt;Convert the first character of a string to its ASCII value.&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 97)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBCharToAscii&lt;/td&gt;
+ * &lt;td&gt;Convert the first character of string to its Unicode value.&lt;/td&gt;
+ * &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;abc&quot; -- 61)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;AsciiToChar&lt;/td&gt;
+ * &lt;td&gt;Convert the ASCII value to the equivalent character.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(97 -- &quot;a&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;MBAsciiToChar&lt;/td&gt;
+ * &lt;td&gt;Convert a Unicode value to the equivalent character.&lt;/td&gt;
+ * &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
+ * &lt;td nowrap&gt;(61 -- &quot;a&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Variables&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetVariable&lt;/td&gt;
+ * &lt;td&gt;Push the value for the specified variable on the stack&lt;/td&gt;
+ * &lt;td nowrap&gt;(variableName -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;FlashVersion&quot; -- 4)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetVariable&lt;/td&gt;
+ * &lt;td&gt;Set the value of the specified variable&lt;/td&gt;
+ * &lt;td nowrap&gt;(variableName value --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Var1&quot; 123 --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetType&lt;/td&gt;
+ * &lt;td&gt;Returns the type of the object or value at the top of the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value -- value type)&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewVariable&lt;/td&gt;
+ * &lt;td&gt;Create a new user-defined variable.&lt;/td&gt;
+ * &lt;td nowrap&gt;(name --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;x&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;InitVariable&lt;/td&gt;
+ * &lt;td&gt;Create and initialise a user-defined variable.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value name --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(1 &quot;x&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewArray&lt;/td&gt;
+ * &lt;td&gt;Create an array.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value+ count -- array)&lt;/td&gt;
+ * &lt;td nowrap&gt;(1 2 3 4 4 -- array)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;DeleteVariable&lt;/td&gt;
+ * &lt;td&gt;Deletes a variable, returning true if the variable was deleted, false
+ * otherwise.&lt;/td&gt;
+ * &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Delete&lt;/td&gt;
+ * &lt;td&gt;Deletes an object or variable, returning true if the object was deleted,
+ * false otherwise.&lt;/td&gt;
+ * &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Functions&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ExecuteFunction&lt;/td&gt;
+ * &lt;td&gt;Execute the built-in function.&lt;/td&gt;
+ * &lt;td nowrap&gt;(arg* functionName -- result*)&lt;/td&gt;
+ * &lt;td nowrap&gt;(12.3 &quot;isFinite&quot; -- &quot;1&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Return&lt;/td&gt;
+ * &lt;td&gt;Return control from the function.&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Objects&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetAttribute&lt;/td&gt;
+ * &lt;td&gt;Push the value of an objects attribute on the stack&lt;/td&gt;
+ * &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Key&quot; &quot;SPACE&quot; -- 32)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetAttribute&lt;/td&gt;
+ * &lt;td&gt;Set the value of a attribute of an object&lt;/td&gt;
+ * &lt;td nowrap&gt;(variable string value --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&lt;_root&gt; &quot;variable&quot; 1 --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ExecuteMethod&lt;/td&gt;
+ * &lt;td&gt;Execute a method of an object&lt;/td&gt;
+ * &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Key&quot; &quot;getCode&quot; -- num)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewMethod&lt;/td&gt;
+ * &lt;td&gt;Define a new method for an object&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NamedObject&lt;/td&gt;
+ * &lt;td&gt;Construct an instance of a built-in object.&lt;/td&gt;
+ * &lt;td nowrap&gt;(arg* count className -- instance)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;My String&quot; 1 &quot;String&quot; -- instance)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NewObject&lt;/td&gt;
+ * &lt;td&gt;Define a new class.&lt;/td&gt;
+ * &lt;td nowrap&gt;((name value)* count -- instance)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;Account&quot; &quot;123456&quot; 1 -- value)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Enumerate&lt;/td&gt;
+ * &lt;td&gt;Enumerate through the attributes of the object referenced by the name of
+ * the variable on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;( -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;EnumerateObject&lt;/td&gt;
+ * &lt;td&gt;Enumerate through the attributes of the object on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;( -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Movie Control&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetTarget&lt;/td&gt;
+ * &lt;td&gt;Returns a string representing the path to the movie clip in which the
+ * current action is executed.&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- clipName )&lt;/td&gt;
+ * &lt;td nowrap&gt;( -- &quot;_root/MovieClip&quot;)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetTarget2&lt;/td&gt;
+ * &lt;td&gt;Change the context of the Flash Player so subsequent actions are applied
+ * to the movie clip, &lt;i&gt;clipName&lt;/i&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;(clipName -- )&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;MovieClip&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetProperty&lt;/td&gt;
+ * &lt;td&gt;Push the value of the specified property on the stack. Properties are
+ * identified by reserved values, see the FSPush class for more details.&lt;/td&gt;
+ * &lt;td nowrap&gt;(value -- value)&lt;/td&gt;
+ * &lt;td nowrap&gt;( &lt;_totalframes&gt; -- 36 )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;SetProperty&lt;/td&gt;
+ * &lt;td&gt;Set the value of a property&lt;/td&gt;
+ * &lt;td nowrap&gt;(value propertyName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( 8000 &lt;_width&gt; -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;CloneSprite&lt;/td&gt;
+ * &lt;td&gt;Duplicate a movie clip &lt;i&gt;clipName&lt;/i&gt;, on the display list layer
+ * &lt;i&gt;depth&lt;/i&gt; with the name &lt;i&gt;newName&lt;/i&gt;.&lt;/td&gt;
+ * &lt;td nowrap&gt;( depth clipName newName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( 19 &quot;_root/MovieClip&quot; &quot;newClip&quot; -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;RemoveSprite&lt;/td&gt;
+ * &lt;td&gt;Delete a movie clip&lt;/td&gt;
+ * &lt;td nowrap&gt;( clipName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( &quot;_root/MovieClip&quot; -- )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StartDrag&lt;/td&gt;
+ * &lt;td&gt;Starts dragging a movie clip with an optional constraining rectangle
+ * defined by the corner points (x1,y1), (x2,y2).&lt;/td&gt;
+ * &lt;td nowrap&gt;( x1 y1 x2 y2 1 clipName --)&lt;br&gt;
+ * &lt;br&gt;( 0 clipName --)&lt;/td&gt;
+ * &lt;td nowrap&gt;( 0 0 400 400 1 &quot;movieClip&quot; - )&lt;br&gt;
+ * &lt;br&gt;( 0 &quot;movieClip&quot; - )&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;EndDrag&lt;/td&gt;
+ * &lt;td&gt;Stops dragging a movie clip&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;NextFrame&lt;/td&gt;
+ * &lt;td&gt;Go to the next frame of the current movie&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;PreviousFrame&lt;/td&gt;
+ * &lt;td&gt;Go to the previous frame of the current movie&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- )&lt;/td&nbsp;&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Play&lt;/td&gt;
+ * &lt;td&gt;Start playing the current movie at the current frame&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Stop&lt;/td&gt;
+ * &lt;td&gt;Stop playing the current movie&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;ToggleQuality&lt;/td&gt;
+ * &lt;td&gt;Toggle the movie between high and low quality&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;StopSounds&lt;/td&gt;
+ * &lt;td&gt;Stop playing all sounds&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;ActionScript 2.0&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Starting with Flash 6 Macromedia extended the syntax of ActionScript to make
+ * it more object-oriented, moving the language closer to Java than JavaScript.
+ * Several actions were added to support the new keywords introduced into
+ * ActionScript 2.0.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;InstanceOf&lt;/td&gt;
+ * &lt;td&gt;Return true or false to the stack if the object can be created using the
+ * constructor function.&lt;/td&gt;
+ * &lt;td nowrap&gt;( object function -- true | false)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Implements&lt;/td&gt;
+ * &lt;td&gt;Identifies a class implements a defined interface.&lt;/td&gt;
+ * &lt;td nowrap&gt;( (function) count function --)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Extends&lt;/td&gt;
+ * &lt;td&gt;Identifies that a class inherits from a class - used to increase the
+ * execution speed of ActionScript code.&lt;/td&gt;
+ * &lt;td nowrap&gt;( subclass superclass --)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Cast&lt;/td&gt;
+ * &lt;td&gt;Casts the type of an object on the stack, returning the object if it is
+ * the same type as the constructor function, null otherwise.&lt;/td&gt;
+ * &lt;td nowrap&gt;(function object -- object | null)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Throw&lt;/td&gt;
+ * &lt;td&gt;Throw an exception.&lt;/td&gt;
+ * &lt;td nowrap&gt;(--)&lt;/td&gt;
+ * &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Miscellaneous&lt;/h1&gt;
+ * 
+ * &lt;table class=&quot;actions&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th&gt;Action&lt;/th&gt;
+ * &lt;th&gt;Description&lt;/th&gt;
+ * &lt;th&gt;Stack Notation&lt;/th&gt;
+ * &lt;th&gt;Example&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;Trace&lt;/td&gt;
+ * &lt;td&gt;Append value to debugging window&lt;/td&gt;
+ * &lt;td nowrap&gt;(value --)&lt;/td&gt;
+ * &lt;td nowrap&gt;(&quot;X = 3&quot; --)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;GetTime&lt;/td&gt;
+ * &lt;td&gt;Push the number of milliseconds that have elapsed since the player
+ * started on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(-- 1274832)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr valign=&quot;top&quot;&gt;
+ * &lt;td&gt;RandomNumber&lt;/td&gt;
+ * &lt;td&gt;Push a random number on the stack.&lt;/td&gt;
+ * &lt;td nowrap&gt;(maximumValue -- num)&lt;/td&gt;
+ * &lt;td nowrap&gt;(10 -- 3)&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Notes&lt;/b&gt;
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The Add action was updated in Flash 5 so it can be used to perform
+ * arithmetic add and string concatenation depending on whether the values on
+ * the stack can be interpreted as numeric values or strings. The original add
+ * action (Code = 10) should not be used.&lt;/li&gt;
+ * 
+ * &lt;li&gt;For the division operation, if a divide by zero error occurs then the
+ * string &quot;#ERROR&quot; is pushed onto the stack.&lt;/li&gt;
+ * 
+ * &lt;li&gt;The Equals and Less actions were updated in Flash 5 so it can be used to
+ * perform arithmetic and string comparison depending on whether the values on
+ * the stack can be interpreted as numeric values or strings. The original Less
+ * action (code = 15) and Equals action (code = 14) should not be used.&lt;/li&gt;
+ * 
+ * &lt;li&gt;Type conversion of string characters is now handled by the String
+ * object, introduced in Flash 5. The ToInteger action is now supported by the
+ * Math object also introduced in Flash 5. The type conversion functions are
+ * only included for completeness.&lt;/li&gt;
+ * 
+ * &lt;li&gt;Flash version 5 supports built-in and user defined objects. For a full
+ * description of the objects supported please consult an ActionScript 5
+ * reference guide.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSActionObject class defines a series of constants that lists the type of
+ * actions supported in the current release. Actions may be created by
+ * specifying the action type in the constructor:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSAction anAction = new FSAction(Add);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPush class is used to push values onto the Flash Player's stack before
+ * an action is executed. For example to execute the expression (1+2)*3 when a
+ * frame is displayed the following sequence of actions are created:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction frameAction = new FSDoAction();
+ * 
+ * frameAction.add(new FSPush(1));
+ * frameAction.add(new FSPush(2));
+ * frameAction.add(new FSAction(Add));
+ * frameAction.add(new FSPush(3));
+ * frameAction.add(new FSAction(Multiply));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The Flash Player also supported classes and object that represent different
+ * complex data types and system resources such as the mouse. These objects and
+ * the functions they support are referenced by name. String containing the
+ * names and the values (and number) of the arguments required are pushed onto
+ * the stack:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(aValue));
+ * frameAction.add(new FSPush(aValue));
+ * frameAction.add(new FSPush(2));
+ * 
+ * // Place the name on the stack then execute the function.
+ * 
+ * frameAction.add(new FSPush(&quot;FunctionName&quot;));
+ * frameAction.add(new FSAction(ExecuteFunction));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To execute a method on a given object a reference to the object is retrieved
+ * and the name of the method and any arguments are specified. For example to
+ * play a movie clip starting at a named frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(&quot;frameName&quot;));
+ * frameAction.add(new FSPush(1));
+ * 
+ * // Get a reference to the object.
+ * 
+ * frameAction.add(new FSPush(&quot;_root&quot;));
+ * frameAction.add(new FSPush(&quot;movieClip&quot;));
+ * frameAction.add(new FSAction(GetAttribute));
+ * 
+ * // Place the name of the method on the stack then execute it.
+ * 
+ * frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * frameAction.add(new FSAction(ExecuteMethod));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Note: The FSPush class allows more than one value to be pushed onto the stack
+ * at a time. In the above examples separate FSPush objects are created to make
+ * the code a little more readable.
+ * &lt;/p&gt;
+ * 
+ */
+public class FSAction extends FSActionObject
+{
+	/** Type identifying the end of a sequence of actions. */
+	public static final int End = 0;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Stack Manipulation&lt;/h1&gt;
+	/** Type identifying a NextFrame stack-based action. */
+	public static final int NextFrame = 4;
 
-&lt;table class=&quot;actions&quot;&gt;
+	/** Type identifying a PrevFrame stack-based action. */
+	public static final int PrevFrame = 5;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	/** Type identifying a Play stack-based action. */
+	public static final int Play = 6;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Pop&lt;/td&gt;
-    &lt;td&gt;Pop value from the top of the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA -- )&lt;/td&gt;
-    &lt;td nowrap&gt;(4 -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Duplicate&lt;/td&gt;
-    &lt;td&gt;Duplicate the value at the top of the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA -- valueA valueA)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 -- 4 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Swap&lt;/td&gt;
-    &lt;td&gt;Swap the top two values on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA valueB -- valueB valueA)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 3 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Type identifying a Stop stack-based action. */
+	public static final int Stop = 7;
 
-&lt;p&gt;FSPush is used to push literals onto the Stack. See also FSRegisterCopy which 
-copies the value on top of the Stack to one of the Flash Player's internal 
-registers.&lt;/p&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Arithmetic&lt;/h1&gt;
+	/** Type identifying a ToggleQuality stack-based action. */
+	public static final int ToggleQuality = 8;
 
-&lt;table class=&quot;actions&quot;&gt;
+	/** Type identifying a StopSounds stack-based action. */
+	public static final int StopSounds = 9;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// Flash 4
+	// / Type identifying an IntegerAdd stack-based action.
+	public static final int IntegerAdd = 10;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Add&lt;/td&gt;
-    &lt;td&gt;Arithmetic Add: A + B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 7)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Subtract&lt;/td&gt;
-    &lt;td&gt;Arithmetic Subtract: A - B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Multiply&lt;/td&gt;
-    &lt;td&gt;Arithmetic Multiply: A * B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 12)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Divide&lt;/td&gt;
-    &lt;td&gt;Arithmetic Divide: A / B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 1.333)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Modulo&lt;/td&gt;
-    &lt;td&gt;Arithmetic Modulo: A % B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 3 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Increment&lt;/td&gt;
-    &lt;td&gt;Add 1 to the value on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Decrement&lt;/td&gt;
-    &lt;td&gt;Subtracted 1 from the value on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a Subtract stack-based action.
+	public static final int Subtract = 11;
 
-&lt;p&gt;Arithmetic add is supported by two actions. IntegerAdd was introduced in Flash 4. 
-It was replaced in Flash 5 by the more flexible Add action which is able to add 
-any two numbers and also concatenate strings. If a string and a number are added 
-then the number is converted to its string representation before concatenation.&lt;/p&gt;
+	// / Type identifying a Multiply stack-based action.
+	public static final int Multiply = 12;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Comparison&lt;/h1&gt;
+	// / Type identifying a Divide stack-based action.
+	public static final int Divide = 13;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying an IntegerEquals stack-based action.
+	public static final int IntegerEquals = 14;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying an IntegerLess stack-based action.
+	public static final int IntegerLess = 15;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Less&lt;/td&gt;
-    &lt;td&gt;LessThan: A &lt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringLess&lt;/td&gt;
-    &lt;td&gt;String compare: stringA &lt; stringB&lt;/td&gt;
-    &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Equals&lt;/td&gt;
-    &lt;td&gt;Equals: A == B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(23 23 -- 1 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringEquals&lt;/td&gt;
-    &lt;td&gt;String compare: stringA == stringB&lt;/td&gt;
-    &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; &quot;abc&quot; -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StrictEquals&lt;/td&gt;
-    &lt;td&gt;Equals: A === B, are the types as well as the values equal.&lt;/td&gt;
-    &lt;td nowrap&gt;(valueA valueB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;23&quot; 23 -- 0 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Greater&lt;/td&gt;
-    &lt;td&gt;Greater Than: A &gt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(10 9 -- 0 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringGreater&lt;/td&gt;
-    &lt;td&gt;String compare: stringA &gt; stringB&lt;/td&gt;
-    &lt;td nowrap&gt;(stringA stringB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; &quot;ab&quot; -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying an And stack-based action.
+	public static final int And = 16;
 
-&lt;p&gt;The less than comparison is supported by IntegerLess introduced in Flash 4 
-and Less introduced in Flash 5. The Less action is more flexible allowing comparison 
-between any combination of two numbers and strings. In Flash 4 comparisons were 
-only supported on values of the same type using either IntegerLess or StringLess.&lt;/p&gt;
+	// / Type identifying an Or stack-based action.
+	public static final int Or = 17;
 
-&lt;p&gt;The equals comparison is supported by IntegerEquals introduced in Flash 4 and 
-Equals introduced in Flash 5. The Equals action is more flexible allowing 
-comparison between any combination of two numbers and strings. In Flash 4 
-comparisons were only supported on values of the same type using either
-IntegerEquals or StringEquals.&lt;/p&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Logical&lt;/h1&gt;
+	// / Type identifying a Not stack-based action.
+	public static final int Not = 18;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a StringEquals stack-based action.
+	public static final int StringEquals = 19;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a StringLength stack-based action.
+	public static final int StringLength = 20;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;And&lt;/td&gt;
-    &lt;td&gt;Logical And: A &amp;&amp; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 0 -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Or&lt;/td&gt;
-    &lt;td&gt;Logical Or: A || B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 0 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Not&lt;/td&gt;
-    &lt;td&gt;Logical Not: !A&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 -- 0)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Bitwise&lt;/h1&gt;
+	// / Type identifying a StringExtract stack-based action.
+	public static final int StringExtract = 21;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a Pop stack-based action.
+	public static final int Pop = 23;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a ToInteger stack-based action.
+	public static final int ToInteger = 24;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;BitwiseAnd&lt;/td&gt;
-    &lt;td&gt;Bitwise And: A &amp; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(5 4 -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;BitwiseOr&lt;/td&gt;
-    &lt;td&gt;Bitwise Or: A | B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(5 4 -- 5)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;BitwiseXOr&lt;/td&gt;
-    &lt;td&gt;Bitwise Exclusive-Or: A ^ B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(5 4 -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;LogicalShiftLeft&lt;/td&gt;
-    &lt;td&gt;Logical Shift Left: A &lt;&lt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(4 1 -- 8)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;LogicalShiftRight&lt;/td&gt;
-    &lt;td&gt;Logical Shift Right: A &gt;&gt;&gt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(8 1 -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ArithmeticShiftRight&lt;/td&gt;
-    &lt;td&gt;Arithmetic Shift Right (sign extension): A &gt;&gt; B&lt;/td&gt;
-    &lt;td nowrap&gt;(numA numB -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(-1 1 -- -1)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a GetVariable stack-based action.
+	public static final int GetVariable = 28;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;String&lt;/h1&gt;
+	// / Type identifying a SetVariable stack-based action.
+	public static final int SetVariable = 29;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a SetTarget2 stack-based action.
+	public static final int SetTarget2 = 32;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a StringAdd stack-based action.
+	public static final int StringAdd = 33;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringAdd&lt;/td&gt;
-    &lt;td&gt;Concatenate two strings&lt;/td&gt;
-    &lt;td nowrap&gt;(string string -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;ab&quot; &quot;cd&quot; -- &quot;abcd&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringLength&lt;/td&gt;
-    &lt;td&gt;Returns the length of a string&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBStringLength&lt;/td&gt;
-    &lt;td&gt;Returns the length of a string that contains characters from an extended set such as Unicode.&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StringExtract&lt;/td&gt;
-    &lt;td&gt;Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string starting at position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBStringExtract&lt;/td&gt;
-    &lt;td&gt;Multi-byte Substring. Extract &lt;I&gt;count&lt;/I&gt; characters from string starting at position &lt;em&gt;index&lt;/em&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;(count index string -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(3 2 &quot;abcde&quot; -- &quot;bcd&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a GetProperty stack-based action.
+	public static final int GetProperty = 34;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Type Conversion&lt;/h1&gt;
+	// / Type identifying a SetProperty stack-based action.
+	public static final int SetProperty = 35;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a CloneSprite stack-based action.
+	public static final int CloneSprite = 36;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a RemoveSprite stack-based action.
+	public static final int RemoveSprite = 37;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToInteger&lt;/td&gt;
-    &lt;td&gt;Converts the value to an integer&lt;/td&gt;
-    &lt;td nowrap&gt; ( num -- num)&lt;/td&gt;
-    &lt;td nowrap&gt; ( 3.2 -- 3 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToNumber&lt;/td&gt;
-    &lt;td&gt;Converts the string value to a number.&lt;/td&gt;
-    &lt;td nowrap&gt; ( string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt; ( &quot;3.2&quot; -- 3.2 )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToString&lt;/td&gt;
-    &lt;td&gt;Converts the value to a string.&lt;/td&gt;
-    &lt;td nowrap&gt; ( num -- string)&lt;/td&gt;
-    &lt;td nowrap&gt; ( 3.2 -- &quot;3.2&quot; )&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;CharToAscii&lt;/td&gt;
-    &lt;td&gt;Convert the first character of a string to its ASCII value.&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 97)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBCharToAscii&lt;/td&gt;
-    &lt;td&gt;Convert the first character of string to its Unicode value.&lt;/td&gt;
-    &lt;td nowrap&gt;(string -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;abc&quot; -- 61)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;AsciiToChar&lt;/td&gt;
-    &lt;td&gt;Convert the ASCII value to the equivalent character.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(97 -- &quot;a&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;MBAsciiToChar&lt;/td&gt;
-    &lt;td&gt;Convert a Unicode value to the equivalent character.&lt;/td&gt;
-    &lt;td nowrap&gt;(num -- string)&lt;/td&gt;
-    &lt;td nowrap&gt;(61 -- &quot;a&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a Trace stack-based action.
+	public static final int Trace = 38;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Variables&lt;/h1&gt;
+	// / Type identifying a StartDrag stack-based action.
+	public static final int StartDrag = 39;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a EndDrag stack-based action.
+	public static final int EndDrag = 40;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a StringLess stack-based action.
+	public static final int StringLess = 41;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetVariable&lt;/td&gt;
-    &lt;td&gt;Push the value for the specified variable on the stack&lt;/td&gt;
-    &lt;td nowrap&gt;(variableName -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;FlashVersion&quot; -- 4)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetVariable&lt;/td&gt;
-    &lt;td&gt;Set the value of the specified variable&lt;/td&gt;
-    &lt;td nowrap&gt;(variableName value --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Var1&quot; 123 --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetType&lt;/td&gt;
-    &lt;td&gt;Returns the type of the object or value at the top of the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(value -- value type)&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewVariable&lt;/td&gt;
-    &lt;td&gt;Create a new user-defined variable.&lt;/td&gt;
-    &lt;td nowrap&gt;(name --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;x&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;InitVariable&lt;/td&gt;
-    &lt;td&gt;Create and initialise a user-defined variable.&lt;/td&gt;
-    &lt;td nowrap&gt;(value name --)&lt;/td&gt;
-    &lt;td nowrap&gt;(1 &quot;x&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewArray&lt;/td&gt;
-    &lt;td&gt;Create an array.&lt;/td&gt;
-    &lt;td nowrap&gt;(value+ count -- array)&lt;/td&gt;
-    &lt;td nowrap&gt;(1 2 3 4 4 -- array)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;DeleteVariable&lt;/td&gt;
-    &lt;td&gt;Deletes a variable, returning true if the variable was deleted, false otherwise.&lt;/td&gt;
-    &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Delete&lt;/td&gt;
-    &lt;td&gt;Deletes an object or variable, returning true if the object was deleted, false otherwise.&lt;/td&gt;
-    &lt;td nowrap&gt;(name -- boolean)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;x&quot; -- 1)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a RandomNumber stack-based action.
+	public static final int RandomNumber = 48;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Functions&lt;/h1&gt;
+	// / Type identifying a MBStringLength stack-based action.
+	public static final int MBStringLength = 49;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a CharToAscii stack-based action.
+	public static final int CharToAscii = 50;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a AsciiToChar stack-based action.
+	public static final int AsciiToChar = 51;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ExecuteFunction&lt;/td&gt;
-    &lt;td&gt;Execute the built-in function.&lt;/td&gt;
-    &lt;td nowrap&gt;(arg* functionName -- result*)&lt;/td&gt;
-    &lt;td nowrap&gt;(12.3 &quot;isFinite&quot; -- &quot;1&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Return&lt;/td&gt;
-    &lt;td&gt;Return control from the function.&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a GetTime stack-based action.
+	public static final int GetTime = 52;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Objects&lt;/h1&gt;
+	// / Type identifying an MBStringExtract stack-based action.
+	public static final int MBStringExtract = 53;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying an MBCharToAscii stack-based action.
+	public static final int MBCharToAscii = 54;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying an MBAsciiToChar stack-based action.
+	public static final int MBAsciiToChar = 55;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetAttribute&lt;/td&gt;
-    &lt;td&gt;Push the value of an objects attribute on the stack&lt;/td&gt;
-    &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Key&quot; &quot;SPACE&quot; -- 32)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetAttribute&lt;/td&gt;
-    &lt;td&gt;Set the value of a attribute of an object&lt;/td&gt;
-    &lt;td nowrap&gt;(variable string value --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&lt;_root&gt; &quot;variable&quot; 1 --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ExecuteMethod&lt;/td&gt;
-    &lt;td&gt;Execute a method of an object&lt;/td&gt;
-    &lt;td nowrap&gt;(string string -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Key&quot; &quot;getCode&quot; -- num)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewMethod&lt;/td&gt;
-    &lt;td&gt;Define a new method for an object&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NamedObject&lt;/td&gt;
-    &lt;td&gt;Construct an instance of a built-in object.&lt;/td&gt;
-    &lt;td nowrap&gt;(arg* count className -- instance)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;My String&quot; 1 &quot;String&quot; -- instance)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NewObject&lt;/td&gt;
-    &lt;td&gt;Define a new class.&lt;/td&gt;
-    &lt;td nowrap&gt;((name value)* count -- instance)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;Account&quot; &quot;123456&quot; 1 -- value)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Enumerate&lt;/td&gt;
-    &lt;td&gt;Enumerate through the attributes of the object referenced by the name of the variable on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
-    &lt;td nowrap&gt;( -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;EnumerateObject&lt;/td&gt;
-    &lt;td&gt;Enumerate through the attributes of the object on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;( &quot;var&quot; -- )&lt;/td&gt;
-    &lt;td nowrap&gt;( -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// Flash 5
+	// / Type identifying a DeleteVariable stack-based action.
+	public static final int DeleteVariable = 58;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Movie Control&lt;/h1&gt;
+	// / Type identifying a Delete stack-based action.
+	public static final int Delete = 59;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a InitVariable stack-based action.
+	public static final int InitVariable = 60;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a ExecuteFunction stack-based action.
+	public static final int ExecuteFunction = 61;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetTarget&lt;/td&gt;
-    &lt;td&gt;Returns a string representing the path to the movie clip in which the current action is executed.&lt;/td&gt;
-    &lt;td nowrap&gt;(-- clipName )&lt;/td&gt;
-    &lt;td nowrap&gt;( -- &quot;_root/MovieClip&quot;)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetTarget2&lt;/td&gt;
-    &lt;td&gt;Change the context of the Flash Player so subsequent actions are applied to the movie clip, &lt;i&gt;clipName&lt;/i&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;(clipName -- )&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;MovieClip&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetProperty&lt;/td&gt;
-    &lt;td&gt;Push the value of the specified property on the stack. Properties are identified by reserved values, see the FSPush class for more details.&lt;/td&gt;
-    &lt;td nowrap&gt;(value -- value)&lt;/td&gt;
-    &lt;td nowrap&gt;( &lt;_totalframes&gt; -- 36 )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;SetProperty&lt;/td&gt;
-    &lt;td&gt;Set the value of a property&lt;/td&gt;
-    &lt;td nowrap&gt;(value propertyName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( 8000 &lt;_width&gt; -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;CloneSprite&lt;/td&gt;
-    &lt;td&gt;Duplicate a movie clip &lt;i&gt;clipName&lt;/i&gt;, on the display list layer &lt;i&gt;depth&lt;/i&gt; with the name &lt;i&gt;newName&lt;/i&gt;.&lt;/td&gt;
-    &lt;td nowrap&gt;( depth clipName newName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( 19 &quot;_root/MovieClip&quot; &quot;newClip&quot; -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;RemoveSprite&lt;/td&gt;
-    &lt;td&gt;Delete a movie clip&lt;/td&gt;
-    &lt;td nowrap&gt;( clipName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( &quot;_root/MovieClip&quot; -- )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StartDrag&lt;/td&gt;
-    &lt;td&gt;Starts dragging a movie clip with an optional constraining rectangle defined by the corner points (x1,y1), (x2,y2).&lt;/td&gt;
-    &lt;td nowrap&gt;( x1 y1 x2 y2 1 clipName --)&lt;br&gt;&lt;br&gt;( 0 clipName --)&lt;/td&gt;
-    &lt;td nowrap&gt;( 0 0 400 400 1 &quot;movieClip&quot; - )&lt;br&gt;&lt;br&gt;( 0 &quot;movieClip&quot; - )&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;EndDrag&lt;/td&gt;
-    &lt;td&gt;Stops dragging a movie clip&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;NextFrame&lt;/td&gt;
-    &lt;td&gt;Go to the next frame of the current movie&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;PreviousFrame&lt;/td&gt;
-    &lt;td&gt;Go to the previous frame of the current movie&lt;/td&gt;
-    &lt;td nowrap&gt;(-- )&lt;/td&nbsp;&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Play&lt;/td&gt;
-    &lt;td&gt;Start playing the current movie at the current frame&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Stop&lt;/td&gt;
-    &lt;td&gt;Stop playing the current movie&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;ToggleQuality&lt;/td&gt;
-    &lt;td&gt;Toggle the movie between high and low quality&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;StopSounds&lt;/td&gt;
-    &lt;td&gt;Stop playing all sounds&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;    
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;ActionScript 2.0&lt;/h1&gt;
+	// / Type identifying a Return stack-based action.
+	public static final int Return = 62;
 
-&lt;p&gt;Starting with Flash 6 Macromedia extended the syntax of ActionScript to make 
-it more object-oriented, moving the language closer to Java than JavaScript. 
-Several actions were added to support the new keywords introduced into ActionScript 
-2.0.&lt;/p&gt;
+	// / Type identifying a Modulo stack-based action.
+	public static final int Modulo = 63;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a NamedObject stack-based action.
+	public static final int NamedObject = 64;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a NewVariable stack-based action.
+	public static final int NewVariable = 65;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;InstanceOf&lt;/td&gt;
-    &lt;td&gt;Return true or false to the stack if the object can be created using the constructor function.&lt;/td&gt;
-    &lt;td nowrap&gt;( object function -- true | false)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Implements&lt;/td&gt;
-    &lt;td&gt;Identifies a class implements a defined interface.&lt;/td&gt;
-    &lt;td nowrap&gt;( (function) count function --)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Extends&lt;/td&gt;
-    &lt;td&gt;Identifies that a class inherits from a class - used to increase the execution speed of ActionScript code.&lt;/td&gt;
-    &lt;td nowrap&gt;( subclass superclass --)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Cast&lt;/td&gt;
-    &lt;td&gt;Casts the type of an object on the stack, returning the object if it is the same type as the constructor function, null otherwise.&lt;/td&gt;
-    &lt;td nowrap&gt;(function object -- object | null)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Throw&lt;/td&gt;
-    &lt;td&gt;Throw an exception.&lt;/td&gt;
-    &lt;td nowrap&gt;(--)&lt;/td&gt;
-    &lt;td nowrap&gt;&nbsp;&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
-    
-&lt;h1 class=&quot;datasheet&quot;&gt;Miscellaneous&lt;/h1&gt;
+	// / Type identifying a NewArray stack-based action.
+	public static final int NewArray = 66;
 
-&lt;table class=&quot;actions&quot;&gt;
+	// / Type identifying a NewObject stack-based action.
+	public static final int NewObject = 67;
 
-&lt;tr&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Stack Notation&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;/tr&gt;
+	// / Type identifying a GetType stack-based action.
+	public static final int GetType = 68;
 
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;Trace&lt;/td&gt;
-    &lt;td&gt;Append value to debugging window&lt;/td&gt;
-    &lt;td nowrap&gt;(value --)&lt;/td&gt;
-    &lt;td nowrap&gt;(&quot;X = 3&quot; --)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;GetTime&lt;/td&gt;
-    &lt;td&gt;Push the number of milliseconds that have elapsed since the player started on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(-- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(-- 1274832)&lt;/td&gt;&lt;/tr&gt;
-&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;RandomNumber&lt;/td&gt;
-    &lt;td&gt;Push a random number on the stack.&lt;/td&gt;
-    &lt;td nowrap&gt;(maximumValue -- num)&lt;/td&gt;
-    &lt;td nowrap&gt;(10 -- 3)&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	// / Type identifying a GetTarget stack-based action.
+	public static final int GetTarget = 69;
 
-&lt;p&gt;&lt;b&gt;Notes&lt;/b&gt;&lt;/p&gt;
+	// / Type identifying an Enumerate stack-based action.
+	public static final int Enumerate = 70;
 
-&lt;ul&gt;
-&lt;li&gt;The Add action was updated in Flash 5 so it can be used to perform arithmetic add and string concatenation depending on whether the values on the stack can be interpreted as numeric values or strings. The original add action (Code = 10) should not be used.&lt;/li&gt;
+	// / Type identifying an Add stack-based action.
+	public static final int Add = 71;
 
-&lt;li&gt;For the division operation, if a divide by zero error occurs then the string &quot;#ERROR&quot; is pushed onto the stack.&lt;/li&gt;
+	// / Type identifying a Less stack-based action.
+	public static final int Less = 72;
 
-&lt;li&gt;The Equals and Less actions were updated in Flash 5 so it can be used to perform arithmetic and string comparison depending on whether the values on the stack can be interpreted as numeric values or strings. The original Less action (code = 15) and Equals action (code = 14) should not be used.&lt;/li&gt;
+	// / Type identifying an Equals stack-based action.
+	public static final int Equals = 73;
 
-&lt;li&gt;Type conversion of string characters is now handled by the String object, introduced in Flash 5. The ToInteger action is now supported by the Math object also introduced in Flash 5. The type conversion functions are only included for completeness.&lt;/li&gt;
+	// / Type identifying a ToNumber stack-based action.
+	public static final int ToNumber = 74;
 
-&lt;li&gt;Flash version 5 supports built-in and user defined objects. For a full description of the objects supported please consult an ActionScript 5 reference guide.&lt;/li&gt;
-&lt;/ul&gt;
+	// / Type identifying a ToString stack-based action.
+	public static final int ToString = 75;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	// / Type identifying a Duplicate stack-based action.
+	public static final int Duplicate = 76;
 
-&lt;p&gt;The FSActionObject class defines a series of constants that lists the type of actions supported in the current release. Actions may be created by specifying the action type in the constructor:&lt;/p&gt;
+	// / Type identifying a Swap stack-based action.
+	public static final int Swap = 77;
 
-&lt;pre&gt;
-FSAction anAction = new FSAction(FSAction.Add);
-&lt;/pre&gt;
+	// / Type identifying a GetAttribute stack-based action.
+	public static final int GetAttribute = 78;
 
-&lt;p&gt;The FSPush class is used to push values onto the Flash Player's stack before an action is executed. For example to execute the expression (1+2)*3 when a frame is displayed the following sequence of actions are created:&lt;/p&gt;
+	// / Type identifying a SetAttribute stack-based action.
+	public static final int SetAttribute = 79;
 
-&lt;pre&gt;
-FSDoAction frameAction = new FSDoAction();
+	// / Type identifying an Increment stack-based action.
+	public static final int Increment = 80;
 
-frameAction.add(new FSPush(1));
-frameAction.add(new FSPush(2));
-frameAction.add(new FSAction(FSAction.Add));
-frameAction.add(new FSPush(3));
-frameAction.add(new FSAction(FSAction.Multiply));
-&lt;/pre&gt;
+	// / Type identifying a Decrement stack-based action.
+	public static final int Decrement = 81;
 
-&lt;p&gt;The Flash Player also supported classes and object that represent different complex data types and system resources such as the mouse. These objects and the functions they support are referenced by name. String containing the names and the values (and number) of the arguments required are pushed onto the stack:&lt;/p&gt;
+	// / Type identifying an ExecuteMethod stack-based action.
+	public static final int ExecuteMethod = 82;
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+	// / Type identifying a NewMethod stack-based action.
+	public static final int NewMethod = 83;
 
-frameAction.add(new FSPush(aValue));
-frameAction.add(new FSPush(aValue));
-frameAction.add(new FSPush(2));
+	// / Type identifying a BitwiseAnd stack-based action.
+	public static final int BitwiseAnd = 96;
 
-// Place the name on the stack then execute the function.
+	// / Type identifying a BitwiseOr stack-based action.
+	public static final int BitwiseOr = 97;
 
-frameAction.add(new FSPush(&quot;FunctionName&quot;));
-frameAction.add(new FSAction(FSAction.ExecuteFunction));
-&lt;/pre&gt;
+	// / Type identifying a BitwiseXOr stack-based action.
+	public static final int BitwiseXOr = 98;
 
-&lt;p&gt;To execute a method on a given object a reference to the object is retrieved and the name of the method and any arguments are specified. For example to play a movie clip starting at a named frame:&lt;/p&gt;
+	// / Type identifying a LogicalShiftLeft stack-based action.
+	public static final int LogicalShiftLeft = 99;
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+	// / Type identifying an ArithmeticShiftRight stack-based action.
+	public static final int ArithmeticShiftRight = 100;
 
-frameAction.add(new FSPush(&quot;frameName&quot;));
-frameAction.add(new FSPush(1));
+	// / Type identifying a LogicalShiftRight stack-based action.
+	public static final int LogicalShiftRight = 101;
 
-// Get a reference to the object.
+	// Flash 6
+	// / Type identifying an InstanceOf stack-based action.
+	public static final int InstanceOf = 84;
 
-frameAction.add(new FSPush(&quot;_root&quot;));
-frameAction.add(new FSPush(&quot;movieClip&quot;));
-frameAction.add(new FSAction(FSAction.GetAttribute));
+	// / Type identifying an EnumerateObject stack-based action.
+	public static final int EnumerateObject = 85;
 
-// Place the name of the method on the stack then execute it.
+	// / Type identifying a StrictEquals stack-based action.
+	public static final int StrictEquals = 102;
 
-frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
-frameAction.add(new FSAction(FSAction.ExecuteMethod));
-&lt;/pre&gt;
+	// / Type identifying a Greater stack-based action.
+	public static final int Greater = 103;
 
-&lt;p&gt;Note: The FSPush class allows more than one value to be pushed onto the stack at a time. In the above examples separate FSPush objects are created to make the code a little more readable.&lt;/p&gt;
+	// / Type identifying a StringGreater stack-based action.
+	public static final int StringGreater = 104;
 
-*/  
-public class FSAction extends FSActionObject
-{
-    /** Type identifying the end of a sequence of actions. */
-    public static final int End              = 0;
-    /** Type identifying a NextFrame stack-based action. */
-    public static final int NextFrame        = 4;
-    /** Type identifying a PrevFrame stack-based action. */
-    public static final int PrevFrame        = 5;
-    /** Type identifying a Play stack-based action. */
-    public static final int Play             = 6;
-    /** Type identifying a Stop stack-based action. */
-    public static final int Stop             = 7;
-    /** Type identifying a ToggleQuality stack-based action. */
-    public static final int ToggleQuality    = 8;
-    /** Type identifying a StopSounds stack-based action. */
-    public static final int StopSounds       = 9;
-// Flash 4
-    /// Type identifying an IntegerAdd stack-based action.
-    public static final int IntegerAdd       = 10;
-    /// Type identifying a Subtract stack-based action.
-    public static final int Subtract         = 11;
-    /// Type identifying a Multiply stack-based action.
-    public static final int Multiply         = 12;
-    /// Type identifying a Divide stack-based action.
-    public static final int Divide           = 13;
-    /// Type identifying an IntegerEquals stack-based action.
-    public static final int IntegerEquals    = 14;
-    /// Type identifying an IntegerLess stack-based action.
-    public static final int IntegerLess      = 15;
-    /// Type identifying an And stack-based action.
-    public static final int And              = 16;
-    /// Type identifying an Or stack-based action.
-    public static final int Or               = 17;
-    /// Type identifying a Not stack-based action.
-    public static final int Not              = 18;
-    /// Type identifying a StringEquals stack-based action.
-    public static final int StringEquals     = 19;
-    /// Type identifying a StringLength stack-based action. 
-    public static final int StringLength     = 20;
-    /// Type identifying a StringExtract stack-based action.
-    public static final int StringExtract    = 21;
-    /// Type identifying a Pop stack-based action.
-    public static final int Pop              = 23;
-    /// Type identifying a ToInteger stack-based action.
-    public static final int ToInteger        = 24;
-    /// Type identifying a GetVariable stack-based action.
-    public static final int GetVariable      = 28;
-    /// Type identifying a SetVariable stack-based action.
-    public static final int SetVariable      = 29;
-    /// Type identifying a SetTarget2 stack-based action.
-    public static final int SetTarget2       = 32;
-    /// Type identifying a StringAdd stack-based action.
-    public static final int StringAdd        = 33;
-    /// Type identifying a GetProperty stack-based action.
-    public static final int GetProperty      = 34;
-    /// Type identifying a SetProperty stack-based action.
-    public static final int SetProperty      = 35;
-    /// Type identifying a CloneSprite stack-based action.
-    public static final int CloneSprite      = 36;
-    /// Type identifying a RemoveSprite stack-based action.
-    public static final int RemoveSprite     = 37;
-    /// Type identifying a Trace stack-based action.
-    public static final int Trace            = 38;
-    /// Type identifying a StartDrag stack-based action.
-    public static final int StartDrag        = 39;
-    /// Type identifying a EndDrag stack-based action.
-    public static final int EndDrag          = 40;
-    /// Type identifying a StringLess stack-based action.
-    public static final int StringLess       = 41;
-    /// Type identifying a RandomNumber stack-based action.
-    public static final int RandomNumber     = 48;
-    /// Type identifying a MBStringLength stack-based action.
-    public static final int MBStringLength   = 49;
-    /// Type identifying a CharToAscii stack-based action.
-    public static final int CharToAscii      = 50;
-    /// Type identifying a AsciiToChar stack-based action.
-    public static final int AsciiToChar      = 51;
-    /// Type identifying a GetTime stack-based action.
-    public static final int GetTime          = 52;
-    /// Type identifying an MBStringExtract stack-based action.
-    public static final int MBStringExtract  = 53;
-    /// Type identifying an MBCharToAscii stack-based action.
-    public static final int MBCharToAscii    = 54;
-    /// Type identifying an MBAsciiToChar stack-based action.
-    public static final int MBAsciiToChar    = 55;
-// Flash 5
-    /// Type identifying a DeleteVariable stack-based action.
-    public static final int DeleteVariable   = 58;
-    /// Type identifying a Delete stack-based action.
-    public static final int Delete             = 59;
-    /// Type identifying a InitVariable stack-based action.
-    public static final int InitVariable     = 60;
-    /// Type identifying a ExecuteFunction stack-based action.
-    public static final int ExecuteFunction  = 61;
-    /// Type identifying a Return stack-based action.
-    public static final int Return           = 62;
-    /// Type identifying a Modulo stack-based action.
-    public static final int Modulo             = 63;
-    /// Type identifying a NamedObject stack-based action.
-    public static final int NamedObject      = 64;
-    /// Type identifying a NewVariable stack-based action.
-    public static final int NewVariable      = 65;
-    /// Type identifying a NewArray stack-based action.
-    public static final int NewArray         = 66;
-    /// Type identifying a NewObject stack-based action.
-    public static final int NewObject        = 67;
-    /// Type identifying a GetType stack-based action.
-    public static final int GetType          = 68;
-    /// Type identifying a GetTarget stack-based action.
-    public static final int GetTarget        = 69;
-    /// Type identifying an Enumerate stack-based action.
-    public static final int Enumerate        = 70;
-    /// Type identifying an Add stack-based action.
-    public static final int Add              = 71;
-    /// Type identifying a Less stack-based action.
-    public static final int Less             = 72;
-    /// Type identifying an Equals stack-based action.
-    public static final int Equals           = 73;
-    /// Type identifying a ToNumber stack-based action.
-    public static final int ToNumber         = 74;
-    /// Type identifying a ToString stack-based action.
-    public static final int ToString         = 75;
-    /// Type identifying a Duplicate stack-based action.
-    public static final int Duplicate        = 76;
-    /// Type identifying a Swap stack-based action.
-    public static final int Swap             = 77;
-    /// Type identifying a GetAttribute stack-based action.
-    public static final int GetAttribute     = 78;
-    /// Type identifying a SetAttribute stack-based action.
-    public static final int SetAttribute     = 79;
-    /// Type identifying an Increment stack-based action.
-    public static final int Increment        = 80;
-    /// Type identifying a Decrement stack-based action.
-    public static final int Decrement        = 81;
-    /// Type identifying an ExecuteMethod stack-based action.
-    public static final int ExecuteMethod    = 82;
-    /// Type identifying a NewMethod stack-based action.
-    public static final int NewMethod        = 83;
-    /// Type identifying a BitwiseAnd stack-based action.
-    public static final int BitwiseAnd       = 96;
-    /// Type identifying a BitwiseOr stack-based action.
-    public static final int BitwiseOr        = 97;
-    /// Type identifying a BitwiseXOr stack-based action.
-    public static final int BitwiseXOr       = 98;
-    /// Type identifying a LogicalShiftLeft stack-based action.
-    public static final int LogicalShiftLeft = 99;
-    /// Type identifying an ArithmeticShiftRight stack-based action.
-    public static final int ArithmeticShiftRight = 100;
-    /// Type identifying a LogicalShiftRight stack-based action.
-    public static final int LogicalShiftRight    = 101;
-// Flash 6
-    /// Type identifying an InstanceOf stack-based action.
-    public static final int InstanceOf      = 84;
-    /// Type identifying an EnumerateObject stack-based action.
-    public static final int EnumerateObject = 85;
-    /// Type identifying a StrictEquals stack-based action.
-    public static final int StrictEquals    = 102;
-    /// Type identifying a Greater stack-based action.
-    public static final int Greater         = 103;
-    /// Type identifying a StringGreater stack-based action.
-    public static final int StringGreater   = 104;
-// Flash 7
-    /// Type identifying a Throw stack-based action.
-    public static final int Throw      = 42;
-    /// Type identifying a Cast stack-based action.
-    public static final int Cast       = 43;
-    /// Type identifying an Implements stack-based action.
-    public static final int Implements = 44;
-    /// Type identifying an Extends stack-based action.
-    public static final int Extends    = 105;
-    
-    static String[] names = {
-        &quot;End&quot;,              // 0
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;NextFrame&quot;,        // 4;
-        &quot;PrevFrame&quot;,        // 5;
-        &quot;Play&quot;,             // 6;
-        &quot;Stop&quot;,             // 7;
-        &quot;ToggleQuality&quot;,    // 8;
-        &quot;StopSounds&quot;,       // 9;
-        &quot;IntegerAdd&quot;,       // 10;
-        &quot;Subtract&quot;,         // 11;
-        &quot;Multiply&quot;,         // 12;
-        &quot;Divide&quot;,           // 13;
-        &quot;IntegerEquals&quot;,    // 14;
-        &quot;IntegerLess&quot;,      // 15;
-        &quot;And&quot;,              // 16;
-        &quot;Or&quot;,               // 17;
-        &quot;Not&quot;,              // 18;
-        &quot;StringEquals&quot;,     // 19;
-        &quot;StringLength&quot;,     // 20;
-        &quot;StringExtract&quot;,    // 21;
-        &quot;&quot;, 
-        &quot;Pop&quot;,              // 23;
-        &quot;ToInteger&quot;,        // 24;
-        &quot;&quot;,
-        &quot;&quot;, 
-        &quot;&quot;,
-        &quot;GetVariable&quot;,      // 28;
-        &quot;SetVariable&quot;,      // 29;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;SetTarget2&quot;,       // 32;
-        &quot;StringAdd&quot;,        // 33;
-        &quot;GetProperty&quot;,      // 34;
-        &quot;SetProperty&quot;,      // 35;
-        &quot;CloneSprite&quot;,      // 36;
-        &quot;RemoveSprite&quot;,     // 37;
-        &quot;Trace&quot;,            // 38;
-        &quot;StartDrag&quot;,        // 39;
-        &quot;EndDrag&quot;,          // 40;
-        &quot;StringLess&quot;,       // 41;
-        &quot;Throw&quot;,            // 42;
-        &quot;Cast&quot;,             // 43;
-        &quot;Implements&quot;,       // 44;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;RandomNumber&quot;,     // 48;
-        &quot;MBStringLength&quot;,   // 49;
-        &quot;CharToAscii&quot;,      // 50;
-        &quot;AsciiToChar&quot;,      // 51;
-        &quot;GetTime&quot;,          // 52;
-        &quot;MBStringExtract&quot;,  // 53;
-        &quot;MBCharToAscii&quot;,    // 54;
-        &quot;MBAsciiToChar&quot;,    // 55;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;DeleteVariable&quot;,   // 58;
-        &quot;Delete&quot;,            // 59;
-        &quot;InitVariable&quot;,     // 60;
-        &quot;ExecuteFunction&quot;,  // 61;
-        &quot;Return&quot;,           // 62;
-        &quot;Modulo&quot;,           // 63;
-        &quot;NamedObject&quot;,      // 64;
-        &quot;NewVariable&quot;,      // 65;
-        &quot;NewArray&quot;,         // 66;
-        &quot;NewObject&quot;,        // 67;
-        &quot;GetType&quot;,          // 68;
-        &quot;GetTarget&quot;,        // 69;
-        &quot;Enumerate&quot;,        // 70;
-        &quot;Add&quot;,              // 71;
-        &quot;Less&quot;,             // 72;
-        &quot;Equals&quot;,           // 73;
-        &quot;ToNumber&quot;,         // 74;
-        &quot;ToString&quot;,         // 75;
-        &quot;Duplicate&quot;,        // 76;
-        &quot;Swap&quot;,             // 77;
-        &quot;GetAttribute&quot;,     // 78;
-        &quot;SetAttribute&quot;,     // 79;
-        &quot;Increment&quot;,        // 80;
-        &quot;Decrement&quot;,        // 81;
-        &quot;ExecuteMethod&quot;,    // 82;
-        &quot;NewMethod&quot;,        // 83;
-        &quot;InstanceOf&quot;,       // 84;
-        &quot;EnumerateObject&quot;,  // 85;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;BitwiseAnd&quot;,           // 96;
-        &quot;BitwiseOr&quot;,            // 97;
-        &quot;BitwiseXOr&quot;,           // 98;
-        &quot;LogicalShiftLeft&quot;,     // 99;
-        &quot;ArithmeticShiftRight&quot;, // 100;
-        &quot;LogicalShiftRight&quot;,    // 101;
-        &quot;StrictEquals&quot;,         // 102;
-        &quot;Greater&quot;,              // 103;
-        &quot;StringGreater&quot;,        // 104;
-        &quot;Extends&quot;,              // 105;
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,
-        &quot;&quot;,  // 127
-    };
+	// Flash 7
+	// / Type identifying a Throw stack-based action.
+	public static final int Throw = 42;
 
-    private static final FSAction[] actions = {
-        new FSAction(FSAction.End),              // 0;
-        new FSAction(1),
-        new FSAction(2),
-        new FSAction(3),
-        new FSAction(FSAction.NextFrame),        // 4;
-        new FSAction(FSAction.PrevFrame),        // 5;
-        new FSAction(FSAction.Play),             // 6;
-        new FSAction(FSAction.Stop),             // 7;
-        new FSAction(FSAction.ToggleQuality),    // 8;
-        new FSAction(FSAction.StopSounds),       // 9;
-        new FSAction(FSAction.IntegerAdd),       // 10;
-        new FSAction(FSAction.Subtract),         // 11;
-        new FSAction(FSAction.Multiply),         // 12;
-        new FSAction(FSAction.Divide),           // 13;
-        new FSAction(FSAction.IntegerEquals),    // 14;
-        new FSAction(FSAction.IntegerLess),      // 15;
-        new FSAction(FSAction.And),              // 16;
-        new FSAction(FSAction.Or),               // 17;
-        new FSAction(FSAction.Not),              // 18;
-        new FSAction(FSAction.StringEquals),     // 19;
-        new FSAction(FSAction.StringLength),     // 20;
-        new FSAction(FSAction.StringExtract),    // 21;
-        new FSAction(22), 
-        new FSAction(FSAction.Pop),              // 23;
-        new FSAction(FSAction.ToInteger),        // 24;
-        new FSAction(25),
-        new FSAction(26), 
-        new FSAction(27),
-        new FSAction(FSAction.GetVariable),      // 28;
-        new FSAction(FSAction.SetVariable),      // 29;
-        new FSAction(30),
-        new FSAction(31),
-        new FSAction(FSAction.SetTarget2),       // 32;
-        new FSAction(FSAction.StringAdd),        // 33;
-        new FSAction(FSAction.GetProperty),      // 34;
-        new FSAction(FSAction.SetProperty),      // 35;
-        new FSAction(FSAction.CloneSprite),      // 36;
-        new FSAction(FSAction.RemoveSprite),     // 37;
-        new FSAction(FSAction.Trace),            // 38;
-        new FSAction(FSAction.StartDrag),        // 39;
-        new FSAction(FSAction.EndDrag),          // 40;
-        new FSAction(FSAction.StringLess),       // 41;
-        new FSAction(FSAction.Throw),            // 42;
-        new FSAction(FSAction.Cast),             // 43;
-        new FSAction(FSAction.Implements),       // 44;
-        new FSAction(45),
-        new FSAction(46),
-        new FSAction(47),
-        new FSAction(FSAction.RandomNumber),     // 48;
-        new FSAction(FSAction.MBStringLength),   // 49;
-        new FSAction(FSAction.CharToAscii),      // 50;
-        new FSAction(FSAction.AsciiToChar),      // 51;
-        new FSAction(FSAction.GetTime),          // 52;
-        new FSAction(FSAction.MBStringExtract),  // 53;
-        new FSAction(FSAction.MBCharToAscii),    // 54;
-        new FSAction(FSAction.MBAsciiToChar),    // 55;
-        new FSAction(56),
-        new FSAction(57),
-        new FSAction(FSAction.DeleteVariable),   // 58;
-        new FSAction(FSAction.Delete),           // 59;
-        new FSAction(FSAction.InitVariable),     // 60;
-        new FSAction(FSAction.ExecuteFunction),  // 61;
-        new FSAction(FSAction.Return),           // 62;
-        new FSAction(FSAction.Modulo),           // 63;
-        new FSAction(FSAction.NamedObject),      // 64;
-        new FSAction(FSAction.NewVariable),      // 65;
-        new FSAction(FSAction.NewArray),         // 66;
-        new FSAction(FSAction.NewObject),        // 67;
-        new FSAction(FSAction.GetType),          // 68;
-        new FSAction(FSAction.GetTarget),        // 69;
-        new FSAction(FSAction.Enumerate),        // 70;
-        new FSAction(FSAction.Add),              // 71;
-        new FSAction(FSAction.Less),             // 72;
-        new FSAction(FSAction.Equals),           // 73;
-        new FSAction(FSAction.ToNumber),         // 74;
-        new FSAction(FSAction.ToString),         // 75;
-        new FSAction(FSAction.Duplicate),        // 76;
-        new FSAction(FSAction.Swap),             // 77;
-        new FSAction(FSAction.GetAttribute),     // 78;
-        new FSAction(FSAction.SetAttribute),     // 79;
-        new FSAction(FSAction.Increment),        // 80;
-        new FSAction(FSAction.Decrement),        // 81;
-        new FSAction(FSAction.ExecuteMethod),    // 82;
-        new FSAction(FSAction.NewMethod),        // 83;
-        new FSAction(FSAction.InstanceOf),       // 84;
-        new FSAction(FSAction.EnumerateObject),  // 85;
-        new FSAction(86),
-        new FSAction(87),
-        new FSAction(88),
-        new FSAction(89),
-        new FSAction(90),
-        new FSAction(91),
-        new FSAction(92),
-        new FSAction(93),
-        new FSAction(94),
-        new FSAction(95),
-        new FSAction(FSAction.BitwiseAnd),           // 96;
-        new FSAction(FSAction.BitwiseOr),            // 97;
-        new FSAction(FSAction.BitwiseXOr),           // 98;
-        new FSAction(FSAction.LogicalShiftLeft),     // 99;
-        new FSAction(FSAction.ArithmeticShiftRight), // 100;
-        new FSAction(FSAction.LogicalShiftRight),    // 101;
-        new FSAction(FSAction.StrictEquals),         // 102;
-        new FSAction(FSAction.Greater),              // 103;
-        new FSAction(FSAction.StringGreater),        // 104;
-        new FSAction(FSAction.Extends),              // 105;
-        new FSAction(106),
-        new FSAction(107),
-        new FSAction(108),
-        new FSAction(109),
-        new FSAction(110),
-        new FSAction(111),
-        new FSAction(112),
-        new FSAction(113),
-        new FSAction(114),
-        new FSAction(115),
-        new FSAction(116),
-        new FSAction(117),
-        new FSAction(118),
-        new FSAction(119),
-        new FSAction(120),
-        new FSAction(121),
-        new FSAction(122),
-        new FSAction(123),
-        new FSAction(124),
-        new FSAction(125),
-        new FSAction(126),
-        new FSAction(127),  // 127
-    };
+	// / Type identifying a Cast stack-based action.
+	public static final int Cast = 43;
 
-    static FSAction getInstance(int type) { return actions[type]; }
+	// / Type identifying an Implements stack-based action.
+	public static final int Implements = 44;
 
-    /** Factory method for generating an FSAction object representing the end of a sequence of actions. */
-    public static FSAction End() { return actions[FSAction.End]; }
-    /** Factory method for generating an FSAction object representing a NextFrame action. */
-    public static FSAction NextFrame() { return actions[FSAction.NextFrame]; }
-    /** Factory method for generating an FSAction object representing a PrevFrame action. */
-    public static FSAction PrevFrame() { return actions[FSAction.PrevFrame]; }
-    /** Factory method for generating an FSAction object representing a Play action. */
-    public static FSAction Play() { return actions[FSAction.Play]; }
-    /** Factory method for generating an FSAction object representing a Stop action. */
-    public static FSAction Stop() { return actions[FSAction.Stop]; }
-    /** Factory method for generating an FSAction object representing a ToggleQuality action. */
-    public static FSAction ToggleQuality() { return actions[FSAction.ToggleQuality]; }
-    /** Factory method for generating an FSAction object representing a StopSounds action. */
-    public static FSAction StopSounds() { return actions[FSAction.StopSounds]; }
-// Flash 4    
-    /// Factory method for generating an FSAction object representing a Subtract action.
-    public static FSAction Subtract() { return actions[FSAction.Subtract]; }
-    /// Factory method for generating an FSAction object representing a Multiply action.
-    public static FSAction Multiply() { return actions[FSAction.Multiply]; }
-    /// Factory method for generating an FSAction object representing a Divide action.
-    public static FSAction Divide() { return actions[FSAction.Divide]; }
-    /// Factory method for generating an FSAction object representing a And action.
-    public static FSAction And() { return actions[FSAction.And]; }
-    /// Factory method for generating an FSAction object representing a Or action.
-    public static FSAction Or() { return actions[FSAction.Or]; }
-    /// Factory method for generating an FSAction object representing a Not action.
-    public static FSAction Not() { return actions[FSAction.Not]; }
-    /// Factory method for generating an FSAction object representing a StringEquals action.
-    public static FSAction StringEquals() { return actions[FSAction.StringEquals]; }
-    /// Factory method for generating an FSAction object representing a StringLength action.
-    public static FSAction StringLength() { return actions[FSAction.StringLength]; }
-    /// Factory method for generating an FSAction object representing a StringExtract action.
-    public static FSAction StringExtract() { return actions[FSAction.StringExtract]; }
-    /// Factory method for generating an FSAction object representing a Pop action.
-    public static FSAction Pop() { return actions[FSAction.Pop]; }
-    /// Factory method for generating an FSAction object representing a ToInteger action.
-    public static FSAction ToInteger() { return actions[FSAction.ToInteger]; }
-    /// Factory method for generating an FSAction object representing a GetVariable action.
-    public static FSAction GetVariable() { return actions[FSAction.GetVariable]; }
-    /// Factory method for generating an FSAction object representing a SetVariable action.
-    public static FSAction SetVariable() { return actions[FSAction.SetVariable]; }
-    /// Factory method for generating an FSAction object representing a SetTarget2 action.
-    public static FSAction SetTarget2() { return actions[FSAction.SetTarget2]; }
-    /// Factory method for generating an FSAction object representing a StringAdd action.
-    public static FSAction StringAdd() { return actions[FSAction.StringAdd]; }
-    /// Factory method for generating an FSAction object representing a GetProperty action.
-    public static FSAction GetProperty() { return actions[FSAction.GetProperty]; }
-    /// Factory method for generating an FSAction object representing a SetProperty action.
-    public static FSAction SetProperty() { return actions[FSAction.SetProperty]; }
-    /// Factory method for generating an FSAction object representing a CloneSprite action.
-    public static FSAction CloneSprite() { return actions[FSAction.CloneSprite]; }
-    /// Factory method for generating an FSAction object representing a RemoveSprite action.
-    public static FSAction RemoveSprite() { return actions[FSAction.RemoveSprite]; }
-    /// Factory method for generating an FSAction object representing a Trace action.
-    public static FSAction Trace() { return actions[FSAction.Trace]; }
-    /// Factory method for generating an FSAction object representing a StartDrag action.
-    public static FSAction StartDrag() { return actions[FSAction.StartDrag]; }
-    /// Factory method for generating an FSAction object representing a EndDrag action.
-    public static FSAction EndDrag() { return actions[FSAction.EndDrag]; }
-    /// Factory method for generating an FSAction object representing a StringLess action.
-    public static FSAction StringLess() { return actions[FSAction.StringLess]; }
-    /// Factory method for generating an FSAction object representing a RandomNumber action.
-    public static FSAction RandomNumber() { return actions[FSAction.RandomNumber]; }
-    /// Factory method for generating an FSAction object representing a MBStringLength action.
-    public static FSAction MBStringLength() { return actions[FSAction.MBStringLength]; }
-    /// Factory method for generating an FSAction object representing a CharToAscii action.
-    public static FSAction CharToAscii() { return actions[FSAction.CharToAscii]; }
-    /// Factory method for generating an FSAction object representing a AsciiToChar action.
-    public static FSAction AsciiToChar() { return actions[FSAction.AsciiToChar]; }
-    /// Factory method for generating an FSAction object representing a GetTime action.
-    public static FSAction GetTime() { return actions[FSAction.GetTime]; }
-    /// Factory method for generating an FSAction object representing a MBStringExtract action.
-    public static FSAction MBStringExtract() { return actions[FSAction.MBStringExtract]; }
-    /// Factory method for generating an FSAction object representing a MBCharToAscii action.
-    public static FSAction MBCharToAscii() { return actions[FSAction.MBCharToAscii]; }
-    /// Factory method for generating an FSAction object representing a MBAsciiToChar action.
-    public static FSAction MBAsciiToChar() { return actions[FSAction.MBAsciiToChar]; }
-// Flash 5
-    /// Factory method for generating an FSAction object representing a DeleteVariable action.
-    public static FSAction DeleteVariable() { return actions[FSAction.DeleteVariable]; }
-    /// Factory method for generating an FSAction object representing a Delete action.
-    public static FSAction Delete() { return actions[FSAction.Delete]; }
-    /// Factory method for generating an FSAction object representing a InitVariable action.
-    public static FSAction InitVariable() { return actions[FSAction.InitVariable]; }
-    /// Factory method for generating an FSAction object representing a ExecuteFunction action.
-    public static FSAction ExecuteFunction() { return actions[FSAction.ExecuteFunction]; }
-    /// Factory method for generating an FSAction object representing a Return action.
-    public static FSAction Return() { return actions[FSAction.Return]; }
-    /// Factory method for generating an FSAction object representing a Modulo action.
-    public static FSAction Modulo() { return actions[FSAction.Modulo]; }
-    /// Factory method for generating an FSAction object representing a NamedObject action.
-    public static FSAction NamedObject() { return actions[FSAction.NamedObject]; }
-    /// Factory method for generating an FSAction object representing a NewVariable action.
-    public static FSAction NewVariable() { return actions[FSAction.NewVariable]; }
-    /// Factory method for generating an FSAction object representing a NewArray action.
-    public static FSAction NewArray() { return actions[FSAction.NewArray]; }
-    /// Factory method for generating an FSAction object representing a NewObject action.
-    public static FSAction NewObject() { return actions[FSAction.NewObject]; }
-    /// Factory method for generating an FSAction object representing a GetType action.
-    public static FSAction GetType() { return actions[FSAction.GetType]; }
-    /// Factory method for generating an FSAction object representing a GetTarget action.
-    public static FSAction GetTarget() { return actions[FSAction.GetTarget]; }
-    /// Factory method for generating an FSAction object representing a Enumerate action.
-    public static FSAction Enumerate() { return actions[FSAction.Enumerate]; }
-    /// Factory method for generating an FSAction object representing a Add action.
-    public static FSAction Add() { return actions[FSAction.Add]; }
-    /// Factory method for generating an FSAction object representing a Less action.
-    public static FSAction Less() { return actions[FSAction.Less]; }
-    /// Factory method for generating an FSAction object representing a Equals action.
-    public static FSAction Equals() { return actions[FSAction.Equals]; }
-    /// Factory method for generating an FSAction object representing a ToNumber action.
-    public static FSAction ToNumber() { return actions[FSAction.ToNumber]; }
-    /// Factory method for generating an FSAction object representing a ToString action.
-    public static FSAction ToString() { return actions[FSAction.ToString]; }
-    /// Factory method for generating an FSAction object representing a Duplicate action.
-    public static FSAction Duplicate() { return actions[FSAction.Duplicate]; }
-    /// Factory method for generating an FSAction object representing a Swap action.
-    public static FSAction Swap() { return actions[FSAction.Swap]; }
-    /// Factory method for generating an FSAction object representing a GetAttribute action.
-    public static FSAction GetAttribute() { return actions[FSAction.GetAttribute]; }
-    /// Factory method for generating an FSAction object representing a SetAttribute action.
-    public static FSAction SetAttribute() { return actions[FSAction.SetAttribute]; }
-    /// Factory method for generating an FSAction object representing a Increment action.
-    public static FSAction Increment() { return actions[FSAction.Increment]; }
-    /// Factory method for generating an FSAction object representing a Decrement action.
-    public static FSAction Decrement() { return actions[FSAction.Decrement]; }
-    /// Factory method for generating an FSAction object representing a ExecuteMethod action.
-    public static FSAction ExecuteMethod() { return actions[FSAction.ExecuteMethod]; }
-    /// Factory method for generating an FSAction object representing a NewMethod action.
-    public static FSAction NewMethod() { return actions[FSAction.NewMethod]; }
-    /// Factory method for generating an FSAction object representing a BitwiseAnd action.
-    public static FSAction BitwiseAnd() { return actions[FSAction.BitwiseAnd]; }
-    /// Factory method for generating an FSAction object representing a BitwiseOr action.
-    public static FSAction BitwiseOr() { return actions[FSAction.BitwiseOr]; }
-    /// Factory method for generating an FSAction object representing a BitwiseXOr action.
-    public static FSAction BitwiseXOr() { return actions[FSAction.BitwiseXOr]; }
-    /// Factory method for generating an FSAction object representing a LogicalShiftLeft action.
-    public static FSAction LogicalShiftLeft() { return actions[FSAction.LogicalShiftLeft]; }
-    /// Factory method for generating an FSAction object representing a ArithmeticShiftRight action.
-    public static FSAction ArithmeticShiftRight() { return actions[FSAction.ArithmeticShiftRight]; }
-    /// Factory method for generating an FSAction object representing a LogicalShiftRight action.
-    public static FSAction LogicalShiftRight() { return actions[FSAction.LogicalShiftRight]; }
-// Flash 6
-    /// Factory method for generating an FSAction object representing a InstanceOf action.
-    public static FSAction InstanceOf() { return actions[FSAction.InstanceOf]; }
-    /// Factory method for generating an FSAction object representing a EnumerateObject action.
-    public static FSAction EnumerateObject() { return actions[FSAction.EnumerateObject]; }
-    /// Factory method for generating an FSAction object representing a Greater action.
-    public static FSAction Greater() { return actions[FSAction.Greater]; }
-    /// Factory method for generating an FSAction object representing a StringGreater action.
-    public static FSAction StringGreater() { return actions[FSAction.StringGreater]; }
-    /// Factory method for generating an FSAction object representing a StrictEquals action.
-    public static FSAction StrictEquals() { return actions[FSAction.StrictEquals]; }
-// Flash 7
-    /// Factory method for generating an FSAction object representing a Cast action.
-    public static FSAction Cast() { return actions[FSAction.Cast]; }
-    /// Factory method for generating an FSAction object representing a Implements action.
-    public static FSAction Implements() { return actions[FSAction.Implements]; }
-    /// Factory method for generating an FSAction object representing a Throw action.
-    public static FSAction Throw() { return actions[FSAction.Throw]; }
-    /// Factory method for generating an FSAction object representing a Extends action.
-    public static FSAction Extends() { return actions[FSAction.Extends]; }
-    
-    /**
-     * Construct an FSAction object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSAction(FSCoder coder)
-    {
-        super(0);
-        decode(coder);
-    }
-    /** 
-     * Constructs a stack-based action with the specified type.
-     * 
-     * @param aType the code used to denote the type of action performed.
-     */
-    public FSAction(int aType)
-    {
-        super(aType);
-    }
-    /**
-     * Constructs an FSAction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSAction object.
-     */
-    public FSAction(FSAction obj)
-    {
-        super(obj);
-    }    
-    /**
-     * Returns a string identifying the type of stack-based action that the 
-     * object represents.
-     * 
-     * @return a string containing the name of the action.
-     */
-    public String name()
-    {
-        return names[type];
-    }
+	// / Type identifying an Extends stack-based action.
+	public static final int Extends = 105;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        coder.endObject(name());
-    }
+	static String[] names =
+	{
+		&quot;End&quot;, // 0
+		&quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;NextFrame&quot;, // 4;
+		&quot;PrevFrame&quot;, // 5;
+		&quot;Play&quot;, // 6;
+		&quot;Stop&quot;, // 7;
+		&quot;ToggleQuality&quot;, // 8;
+		&quot;StopSounds&quot;, // 9;
+		&quot;IntegerAdd&quot;, // 10;
+		&quot;Subtract&quot;, // 11;
+		&quot;Multiply&quot;, // 12;
+		&quot;Divide&quot;, // 13;
+		&quot;IntegerEquals&quot;, // 14;
+		&quot;IntegerLess&quot;, // 15;
+		&quot;And&quot;, // 16;
+		&quot;Or&quot;, // 17;
+		&quot;Not&quot;, // 18;
+		&quot;StringEquals&quot;, // 19;
+		&quot;StringLength&quot;, // 20;
+		&quot;StringExtract&quot;, // 21;
+		&quot;&quot;,
+		&quot;Pop&quot;, // 23;
+		&quot;ToInteger&quot;, // 24;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;GetVariable&quot;, // 28;
+		&quot;SetVariable&quot;, // 29;
+		&quot;&quot;, &quot;&quot;,
+		&quot;SetTarget2&quot;, // 32;
+		&quot;StringAdd&quot;, // 33;
+		&quot;GetProperty&quot;, // 34;
+		&quot;SetProperty&quot;, // 35;
+		&quot;CloneSprite&quot;, // 36;
+		&quot;RemoveSprite&quot;, // 37;
+		&quot;Trace&quot;, // 38;
+		&quot;StartDrag&quot;, // 39;
+		&quot;EndDrag&quot;, // 40;
+		&quot;StringLess&quot;, // 41;
+		&quot;Throw&quot;, // 42;
+		&quot;Cast&quot;, // 43;
+		&quot;Implements&quot;, // 44;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;RandomNumber&quot;, // 48;
+		&quot;MBStringLength&quot;, // 49;
+		&quot;CharToAscii&quot;, // 50;
+		&quot;AsciiToChar&quot;, // 51;
+		&quot;GetTime&quot;, // 52;
+		&quot;MBStringExtract&quot;, // 53;
+		&quot;MBCharToAscii&quot;, // 54;
+		&quot;MBAsciiToChar&quot;, // 55;
+		&quot;&quot;, &quot;&quot;,
+		&quot;DeleteVariable&quot;, // 58;
+		&quot;Delete&quot;, // 59;
+		&quot;InitVariable&quot;, // 60;
+		&quot;ExecuteFunction&quot;, // 61;
+		&quot;Return&quot;, // 62;
+		&quot;Modulo&quot;, // 63;
+		&quot;NamedObject&quot;, // 64;
+		&quot;NewVariable&quot;, // 65;
+		&quot;NewArray&quot;, // 66;
+		&quot;NewObject&quot;, // 67;
+		&quot;GetType&quot;, // 68;
+		&quot;GetTarget&quot;, // 69;
+		&quot;Enumerate&quot;, // 70;
+		&quot;Add&quot;, // 71;
+		&quot;Less&quot;, // 72;
+		&quot;Equals&quot;, // 73;
+		&quot;ToNumber&quot;, // 74;
+		&quot;ToString&quot;, // 75;
+		&quot;Duplicate&quot;, // 76;
+		&quot;Swap&quot;, // 77;
+		&quot;GetAttribute&quot;, // 78;
+		&quot;SetAttribute&quot;, // 79;
+		&quot;Increment&quot;, // 80;
+		&quot;Decrement&quot;, // 81;
+		&quot;ExecuteMethod&quot;, // 82;
+		&quot;NewMethod&quot;, // 83;
+		&quot;InstanceOf&quot;, // 84;
+		&quot;EnumerateObject&quot;, // 85;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;BitwiseAnd&quot;, // 96;
+		&quot;BitwiseOr&quot;, // 97;
+		&quot;BitwiseXOr&quot;, // 98;
+		&quot;LogicalShiftLeft&quot;, // 99;
+		&quot;ArithmeticShiftRight&quot;, // 100;
+		&quot;LogicalShiftRight&quot;, // 101;
+		&quot;StrictEquals&quot;, // 102;
+		&quot;Greater&quot;, // 103;
+		&quot;StringGreater&quot;, // 104;
+		&quot;Extends&quot;, // 105;
+		&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
+		&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, // 127
+	};
+
+	private static final FSAction[] actions =
+	{
+		new FSAction(End), // 0;
+		new FSAction(1),
+		new FSAction(2),
+		new FSAction(3),
+		new FSAction(NextFrame), // 4;
+		new FSAction(PrevFrame), // 5;
+		new FSAction(Play), // 6;
+		new FSAction(Stop), // 7;
+		new FSAction(ToggleQuality), // 8;
+		new FSAction(StopSounds), // 9;
+		new FSAction(IntegerAdd), // 10;
+		new FSAction(Subtract), // 11;
+		new FSAction(Multiply), // 12;
+		new FSAction(Divide), // 13;
+		new FSAction(IntegerEquals), // 14;
+		new FSAction(IntegerLess), // 15;
+		new FSAction(And), // 16;
+		new FSAction(Or), // 17;
+		new FSAction(Not), // 18;
+		new FSAction(StringEquals), // 19;
+		new FSAction(StringLength), // 20;
+		new FSAction(StringExtract), // 21;
+		new FSAction(22),
+		new FSAction(Pop), // 23;
+		new FSAction(ToInteger), // 24;
+		new FSAction(25),
+		new FSAction(26),
+		new FSAction(27),
+		new FSAction(GetVariable), // 28;
+		new FSAction(SetVariable), // 29;
+		new FSAction(30),
+		new FSAction(31),
+		new FSAction(SetTarget2), // 32;
+		new FSAction(StringAdd), // 33;
+		new FSAction(GetProperty), // 34;
+		new FSAction(SetProperty), // 35;
+		new FSAction(CloneSprite), // 36;
+		new FSAction(RemoveSprite), // 37;
+		new FSAction(Trace), // 38;
+		new FSAction(StartDrag), // 39;
+		new FSAction(EndDrag), // 40;
+		new FSAction(StringLess), // 41;
+		new FSAction(Throw), // 42;
+		new FSAction(Cast), // 43;
+		new FSAction(Implements), // 44;
+		new FSAction(45),
+		new FSAction(46),
+		new FSAction(47),
+		new FSAction(RandomNumber), // 48;
+		new FSAction(MBStringLength), // 49;
+		new FSAction(CharToAscii), // 50;
+		new FSAction(AsciiToChar), // 51;
+		new FSAction(GetTime), // 52;
+		new FSAction(MBStringExtract), // 53;
+		new FSAction(MBCharToAscii), // 54;
+		new FSAction(MBAsciiToChar), // 55;
+		new FSAction(56),
+		new FSAction(57),
+		new FSAction(DeleteVariable), // 58;
+		new FSAction(Delete), // 59;
+		new FSAction(InitVariable), // 60;
+		new FSAction(ExecuteFunction), // 61;
+		new FSAction(Return), // 62;
+		new FSAction(Modulo), // 63;
+		new FSAction(NamedObject), // 64;
+		new FSAction(NewVariable), // 65;
+		new FSAction(NewArray), // 66;
+		new FSAction(NewObject), // 67;
+		new FSAction(GetType), // 68;
+		new FSAction(GetTarget), // 69;
+		new FSAction(Enumerate), // 70;
+		new FSAction(Add), // 71;
+		new FSAction(Less), // 72;
+		new FSAction(Equals), // 73;
+		new FSAction(ToNumber), // 74;
+		new FSAction(ToString), // 75;
+		new FSAction(Duplicate), // 76;
+		new FSAction(Swap), // 77;
+		new FSAction(GetAttribute), // 78;
+		new FSAction(SetAttribute), // 79;
+		new FSAction(Increment), // 80;
+		new FSAction(Decrement), // 81;
+		new FSAction(ExecuteMethod), // 82;
+		new FSAction(NewMethod), // 83;
+		new FSAction(InstanceOf), // 84;
+		new FSAction(EnumerateObject), // 85;
+		new FSAction(86),
+		new FSAction(87),
+		new FSAction(88),
+		new FSAction(89),
+		new FSAction(90),
+		new FSAction(91),
+		new FSAction(92),
+		new FSAction(93),
+		new FSAction(94),
+		new FSAction(95),
+		new FSAction(BitwiseAnd), // 96;
+		new FSAction(BitwiseOr), // 97;
+		new FSAction(BitwiseXOr), // 98;
+		new FSAction(LogicalShiftLeft), // 99;
+		new FSAction(ArithmeticShiftRight), // 100;
+		new FSAction(LogicalShiftRight), // 101;
+		new FSAction(StrictEquals), // 102;
+		new FSAction(Greater), // 103;
+		new FSAction(StringGreater), // 104;
+		new FSAction(Extends), // 105;
+		new FSAction(106), new FSAction(107), new FSAction(108),
+		new FSAction(109), new FSAction(110), new FSAction(111),
+		new FSAction(112), new FSAction(113), new FSAction(114),
+		new FSAction(115), new FSAction(116), new FSAction(117),
+		new FSAction(118), new FSAction(119), new FSAction(120),
+		new FSAction(121), new FSAction(122), new FSAction(123),
+		new FSAction(124), new FSAction(125), new FSAction(126),
+		new FSAction(127), // 127
+	};
+
+	static FSAction getInstance(int type)
+	{
+		return actions[type];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing the end of
+	 * a sequence of actions.
+	 */
+	public static FSAction End()
+	{
+		return actions[End];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a NextFrame
+	 * action.
+	 */
+	public static FSAction NextFrame()
+	{
+		return actions[NextFrame];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a PrevFrame
+	 * action.
+	 */
+	public static FSAction PrevFrame()
+	{
+		return actions[PrevFrame];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a Play
+	 * action.
+	 */
+	public static FSAction Play()
+	{
+		return actions[Play];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a Stop
+	 * action.
+	 */
+	public static FSAction Stop()
+	{
+		return actions[Stop];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a
+	 * ToggleQuality action.
+	 */
+	public static FSAction ToggleQuality()
+	{
+		return actions[ToggleQuality];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a
+	 * StopSounds action.
+	 */
+	public static FSAction StopSounds()
+	{
+		return actions[StopSounds];
+	}
+
+	// Flash 4
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * Subtract action. 
+	 */
+	public static FSAction Subtract()
+	{
+		return actions[Subtract];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * Multiply action. 
+	 * */
+	public static FSAction Multiply()
+	{
+		return actions[Multiply];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Divide 
+	 * action. 
+	 */
+	public static FSAction Divide()
+	{
+		return actions[Divide];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a And
+	 * action. 
+	 */
+	public static FSAction And()
+	{
+		return actions[And];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Or 
+	 * action. 
+	 */
+	public static FSAction Or()
+	{
+		return actions[Or];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Not 
+	 * action. 
+	 */
+	public static FSAction Not()
+	{
+		return actions[Not];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StringEquals action. 
+	 */
+	public static FSAction StringEquals()
+	{
+		return actions[StringEquals];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a 
+	 * StringLength action. 
+	 */
+	public static FSAction StringLength()
+	{
+		return actions[StringLength];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StringExtract action. 
+	 */
+	public static FSAction StringExtract()
+	{
+		return actions[StringExtract];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a Pop
+	 * action. 
+	 */
+	public static FSAction Pop()
+	{
+		return actions[Pop];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a 
+	 * ToInteger action. 
+	 */
+	public static FSAction ToInteger()
+	{
+		return actions[ToInteger];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * GetVariable action. 
+	 */
+	public static FSAction GetVariable()
+	{
+		return actions[GetVariable];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * SetVariable action. 
+	 */
+	public static FSAction SetVariable()
+	{
+		return actions[SetVariable];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * SetTarget2 action. 
+	 */
+	public static FSAction SetTarget2()
+	{
+		return actions[SetTarget2];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StringAdd action. 
+	 */
+	public static FSAction StringAdd()
+	{
+		return actions[StringAdd];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * GetProperty action. 
+	 */
+	public static FSAction GetProperty()
+	{
+		return actions[GetProperty];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a 
+	 * SetProperty action. 
+	 */
+	public static FSAction SetProperty()
+	{
+		return actions[SetProperty];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * CloneSprite action. 
+	 */
+	public static FSAction CloneSprite()
+	{
+		return actions[CloneSprite];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * RemoveSprite action. 
+	 */
+	public static FSAction RemoveSprite()
+	{
+		return actions[RemoveSprite];
+	}
+
+	/** Factory method for generating an FSAction object representing a Trace
+	 * action. 
+	 */
+	public static FSAction Trace()
+	{
+		return actions[Trace];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StartDrag action. 
+	 */
+	public static FSAction StartDrag()
+	{
+		return actions[StartDrag];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a EndDrag
+	 * action. 
+	 */
+	public static FSAction EndDrag()
+	{
+		return actions[EndDrag];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StringLess action. 
+	 */
+	public static FSAction StringLess()
+	{
+		return actions[StringLess];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * RandomNumber action.
+	 */
+	public static FSAction RandomNumber()
+	{
+		return actions[RandomNumber];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * MBStringLength action. 
+	 */
+	public static FSAction MBStringLength()
+	{
+		return actions[MBStringLength];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * CharToAscii action.
+	 */
+	public static FSAction CharToAscii()
+	{
+		return actions[CharToAscii];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * AsciiToChar action. 
+	 */
+	public static FSAction AsciiToChar()
+	{
+		return actions[AsciiToChar];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a GetTime
+	 * action. 
+	 */
+	public static FSAction GetTime()
+	{
+		return actions[GetTime];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * MBStringExtract action. 
+	 */
+	public static FSAction MBStringExtract()
+	{
+		return actions[MBStringExtract];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * MBCharToAscii action. 
+	 */
+	public static FSAction MBCharToAscii()
+	{
+		return actions[MBCharToAscii];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a
+	 * MBAsciiToChar action. 
+	 */
+	public static FSAction MBAsciiToChar()
+	{
+		return actions[MBAsciiToChar];
+	}
+
+	// Flash 5
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * DeleteVariable action. 
+	 */
+	public static FSAction DeleteVariable()
+	{
+		return actions[DeleteVariable];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Delete
+	 *  action. 
+	 */
+	public static FSAction Delete()
+	{
+		return actions[Delete];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * InitVariable action. 
+	 */
+	public static FSAction InitVariable()
+	{
+		return actions[InitVariable];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * ExecuteFunction action. 
+	 */
+	public static FSAction ExecuteFunction()
+	{
+		return actions[ExecuteFunction];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Return
+	 * action. 
+	 */
+	public static FSAction Return()
+	{
+		return actions[Return];
+	}
+
+	/**
+	 * Factory method for generating an FSAction object representing a Modulo
+	 * action. 
+	 */
+	public static FSAction Modulo()
+	{
+		return actions[Modulo];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * NamedObject action. 
+	 */
+	public static FSAction NamedObject()
+	{
+		return actions[NamedObject];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * NewVariable action. 
+	 */
+	public static FSAction NewVariable()
+	{
+		return actions[NewVariable];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * NewArray action. 
+	 */
+	public static FSAction NewArray()
+	{
+		return actions[NewArray];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * NewObject action. 
+	 */
+	public static FSAction NewObject()
+	{
+		return actions[NewObject];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a GetType
+	 * action. 
+	 */
+	public static FSAction GetType()
+	{
+		return actions[GetType];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * GetTarget action. 
+	 */
+	public static FSAction GetTarget()
+	{
+		return actions[GetTarget];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * Enumerate action. 
+	 */
+	public static FSAction Enumerate()
+	{
+		return actions[Enumerate];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Add
+	 * action. 
+	 */
+	public static FSAction Add()
+	{
+		return actions[Add];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Less
+	 * action. 
+	 */
+	public static FSAction Less()
+	{
+		return actions[Less];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Equals
+	 * action. 
+	 */
+	public static FSAction Equals()
+	{
+		return actions[Equals];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * ToNumber action. 
+	 */
+	public static FSAction ToNumber()
+	{
+		return actions[ToNumber];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * ToString action. 
+	 */
+	public static FSAction ToString()
+	{
+		return actions[ToString];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * Duplicate action. 
+	 */
+	public static FSAction Duplicate()
+	{
+		return actions[Duplicate];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Swap
+	 * action. 
+	 */
+	public static FSAction Swap()
+	{
+		return actions[Swap];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * GetAttribute action. 
+	 */
+	public static FSAction GetAttribute()
+	{
+		return actions[GetAttribute];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * SetAttribute action. 
+	 */
+	public static FSAction SetAttribute()
+	{
+		return actions[SetAttribute];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * Increment action. 
+	 */
+	public static FSAction Increment()
+	{
+		return actions[Increment];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * Decrement action. 
+	 */
+	public static FSAction Decrement()
+	{
+		return actions[Decrement];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * ExecuteMethod action. 
+	 */
+	public static FSAction ExecuteMethod()
+	{
+		return actions[ExecuteMethod];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * NewMethod action. 
+	 */
+	public static FSAction NewMethod()
+	{
+		return actions[NewMethod];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * BitwiseAnd action. 
+	 */
+	public static FSAction BitwiseAnd()
+	{
+		return actions[BitwiseAnd];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * BitwiseOr action. 
+	 */
+	public static FSAction BitwiseOr()
+	{
+		return actions[BitwiseOr];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * BitwiseXOr action. 
+	 */
+	public static FSAction BitwiseXOr()
+	{
+		return actions[BitwiseXOr];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * LogicalShiftLeft action. 
+	 */
+	public static FSAction LogicalShiftLeft()
+	{
+		return actions[LogicalShiftLeft];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * ArithmeticShiftRight action. 
+	 */
+	public static FSAction ArithmeticShiftRight()
+	{
+		return actions[ArithmeticShiftRight];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * LogicalShiftRight action. 
+	 */
+	public static FSAction LogicalShiftRight()
+	{
+		return actions[LogicalShiftRight];
+	}
+
+	// Flash 6
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * InstanceOf action. 
+	 */
+	public static FSAction InstanceOf()
+	{
+		return actions[InstanceOf];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * EnumerateObject action. 
+	 */
+	public static FSAction EnumerateObject()
+	{
+		return actions[EnumerateObject];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Greater
+	 * action. 
+	 */
+	public static FSAction Greater()
+	{
+		return actions[Greater];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StringGreater action. 
+	 */
+	public static FSAction StringGreater()
+	{
+		return actions[StringGreater];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a
+	 * StrictEquals action. 
+	 */
+	public static FSAction StrictEquals()
+	{
+		return actions[StrictEquals];
+	}
+
+	// Flash 7
+	/** 
+	 * Factory method for generating an FSAction object representing a Cast 
+	 * action. 
+	 */
+	public static FSAction Cast()
+	{
+		return actions[Cast];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing an 
+	 * Implements action. 
+	 */
+	public static FSAction Implements()
+	{
+		return actions[Implements];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Throw
+	 * action. 
+	 */
+	public static FSAction Throw()
+	{
+		return actions[Throw];
+	}
+
+	/** 
+	 * Factory method for generating an FSAction object representing a Extends
+	 * action. 
+	 */
+	public static FSAction Extends()
+	{
+		return actions[Extends];
+	}
+
+	/**
+	 * Construct an FSAction object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSAction(FSCoder coder)
+	{
+		super(0);
+		decode(coder);
+	}
+
+	/**
+	 * Constructs a stack-based action with the specified type.
+	 * 
+	 * @param aType
+	 *            the code used to denote the type of action performed.
+	 */
+	public FSAction(int aType)
+	{
+		super(aType);
+	}
+
+	/**
+	 * Constructs an FSAction object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSAction object.
+	 */
+	public FSAction(FSAction obj)
+	{
+		super(obj);
+	}
+
+	/**
+	 * Returns a string identifying the type of stack-based action that the
+	 * object represents.
+	 * 
+	 * @return a string containing the name of the action.
+	 */
+	public String name()
+	{
+		return names[type];
+	}
+
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSActionObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSActionObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSActionObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,146 +30,170 @@
 
 package com.flagstone.transform;
 
-/** The FSActionObject is a base class for the classes that represent the different types 
- * of actions defined in the Flash file format specification. The function of the class 
- * is the same as the FSMovieObject class however the format of the encoded binary data 
- * is different.
+/**
+ * The FSActionObject is a base class for the classes that represent the
+ * different types of actions defined in the Flash file format specification.
+ * The function of the class is the same as the FSMovieObject class however the
+ * format of the encoded binary data is different.
  * 
- * This class is primarily used internally in the library however the getType() method is 
- * useful when manipulating decoded Flash files. Rather than use run-time type inspection 
- * provided by the programming environment the method can be used to identify the action that a 
- * given object represents. The getType() method is essential when examining FSAction objects
- * which represent a large number byte-codes which perform stack-based operations such as 
- * add, subtract, etc.
+ * This class is primarily used internally in the library however the getType()
+ * method is useful when manipulating decoded Flash files. Rather than use
+ * run-time type inspection provided by the programming environment the method
+ * can be used to identify the action that a given object represents. The
+ * getType() method is essential when examining FSAction objects which represent
+ * a large number byte-codes which perform stack-based operations such as add,
+ * subtract, etc.
  */
 public abstract class FSActionObject extends FSTransformObject
 {
-    /** Type identifying a GotoFrame action. */
-    public static final int GotoFrame     = 129;
-    /** Type identifying a GetUrl action. */
-    public static final int GetUrl        = 131;
-// Flash 3
-    /// Type identifying a WaitForFrame action.
-    public static final int WaitForFrame  = 138;
-    /// Type identifying a SetTarget action.
-    public static final int SetTarget     = 139;
-    /// Type identifying a GotoLabel action.
-    public static final int GotoLabel     = 140;
-// Flash 4
-    /// Type identifying a WaitForFrame2 action.
-    public static final int WaitForFrame2 = 141;
-    /// Type identifying a Push action.
-    public static final int Push          = 150;
-    /// Type identifying a Jump action.
-    public static final int Jump          = 153;
-    /// Type identifying a GetUrl2 action.
-    public static final int GetUrl2       = 154;
-    /// Type identifying an If action.
-    public static final int If            = 157;
-    /// Type identifying a Call action.
-    public static final int Call          = 158;
-    /// Type identifying a GotoFrame2 action.
-    public static final int GotoFrame2    = 159;
-// Flash 5
-    /// Type identifying a RegisterCopy action.
-    public static final int RegisterCopy  = 135;
-    /// Type identifying a Table action.
-    public static final int Table         = 136;
-    /// Type identifying a With action.
-    public static final int With          = 148;
-    /// Type identifying a NewFunction action.
-    public static final int NewFunction   = 155;
-// Flash 7
-    /// Type identifying a NewFunction2 action.
-    public static final int NewFunction2     = 142;
-    /// Type identifying a ExceptionHandler action.
-    public static final int ExceptionHandler = 143;
+	/** Type identifying a GotoFrame action. */
+	public static final int GotoFrame = 129;
 
-    protected int type = 0;
-    protected int length = 0;
-    
-    protected FSActionObject(int aType)
-    {
-        type = aType;
-    }
-    protected FSActionObject(FSActionObject obj)
-    {
-        type = obj.type;
-        length = obj.length;
-    }  
-    /** Gets the code used that identifies the type of the action when it is encoded. 
+	/** Type identifying a GetUrl action. */
+	public static final int GetUrl = 131;
 
-        @return the code used to denote the type of action performed.
-        */
-    public int getType() 
-    {
-        return type;
-    }
+	// Flash 3
+	// / Type identifying a WaitForFrame action.
+	public static final int WaitForFrame = 138;
 
-    int getLength() 
-    {
-        return length;
-    }
-    
-    /**
-     * Length is used to calculate the then of the action when it is encoded to 
-     * the binary Flash file format. This method can be used to calculate the size 
-     * of offsets and jumps for FSIf and FSJump actions.
-     *
-     * @return the length of the encoded action in bytes.
-     */
-    public int length()
-    {
-        int encodedLength = (type &gt; 128) ? 3 : 1;
-        
-        encodedLength += length(new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]));
-        
-        return encodedLength;
-    }
+	// / Type identifying a SetTarget action.
+	public static final int SetTarget = 139;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false; 
-        
-        if (super.equals(anObject))
-        {
-            result = type == ((FSActionObject)anObject).type;
-        }
-        return result;
-    }
+	// / Type identifying a GotoLabel action.
+	public static final int GotoLabel = 140;
 
-    public int length(FSCoder coder)
-    {
-        length = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
-        coder.writeWord(type, 1);
+	// Flash 4
+	// / Type identifying a WaitForFrame2 action.
+	public static final int WaitForFrame2 = 141;
 
-        if (type &gt;= 128)
-            coder.writeWord(length, 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        coder.beginObject(name());
-        
-        type = coder.readWord(1, false);
-        
-        if (type &gt;= 128)
-            length = coder.readWord(2, false);
-        else
-            length = 0;
-    }
+	// / Type identifying a Push action.
+	public static final int Push = 150;
+
+	// / Type identifying a Jump action.
+	public static final int Jump = 153;
+
+	// / Type identifying a GetUrl2 action.
+	public static final int GetUrl2 = 154;
+
+	// / Type identifying an If action.
+	public static final int If = 157;
+
+	// / Type identifying a Call action.
+	public static final int Call = 158;
+
+	// / Type identifying a GotoFrame2 action.
+	public static final int GotoFrame2 = 159;
+
+	// Flash 5
+	// / Type identifying a RegisterCopy action.
+	public static final int RegisterCopy = 135;
+
+	// / Type identifying a Table action.
+	public static final int Table = 136;
+
+	// / Type identifying a With action.
+	public static final int With = 148;
+
+	// / Type identifying a NewFunction action.
+	public static final int NewFunction = 155;
+
+	// Flash 7
+	// / Type identifying a NewFunction2 action.
+	public static final int NewFunction2 = 142;
+
+	// / Type identifying a ExceptionHandler action.
+	public static final int ExceptionHandler = 143;
+
+	protected int type = 0;
+
+	protected int length = 0;
+
+	protected FSActionObject(int aType)
+	{
+		type = aType;
+	}
+
+	protected FSActionObject(FSActionObject obj)
+	{
+		type = obj.type;
+		length = obj.length;
+	}
+
+	/**
+	 * Gets the code used that identifies the type of the action when it is
+	 * encoded.
+	 * 
+	 * @return the code used to denote the type of action performed.
+	 */
+	public int getType()
+	{
+		return type;
+	}
+
+	int getLength()
+	{
+		return length;
+	}
+
+	/**
+	 * Length is used to calculate the then of the action when it is encoded to
+	 * the binary Flash file format. This method can be used to calculate the
+	 * size of offsets and jumps for FSIf and FSJump actions.
+	 * 
+	 * @return the length of the encoded action in bytes.
+	 */
+	public int length()
+	{
+		int encodedLength = (type &gt; 128) ? 3 : 1;
+
+		encodedLength += length(new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]));
+
+		return encodedLength;
+	}
+
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
+
+		if (super.equals(anObject))
+		{
+			result = type == ((FSActionObject) anObject).type;
+		}
+		return result;
+	}
+
+	public int length(FSCoder coder)
+	{
+		length = 0;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
+		coder.writeWord(type, 1);
+
+		if (type &gt;= 128)
+			coder.writeWord(length, 2);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		coder.beginObject(name());
+
+		type = coder.readWord(1, false);
+
+		if (type &gt;= 128)
+			length = coder.readWord(2, false);
+		else
+			length = 0;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSAudioData.java
===================================================================
--- trunk/src/com/flagstone/transform/FSAudioData.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSAudioData.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -29,8 +29,8 @@
  */
 package com.flagstone.transform;
 
-/** 
- * FSAudioData is used to define sounds for a Flash Video (flv) file. It is 
+/**
+ * FSAudioData is used to define sounds for a Flash Video (flv) file. It is
  * similar in function to the FSDefineSound class.
  * 
  * &lt;table class=&quot;datasheet&quot;&gt;
@@ -39,20 +39,22 @@
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
- * &lt;td&gt;&lt;a name=&quot;FSAudioData_0&quot;&gt;timestamp&lt;/a&gt;&lt;/td&gt;
- * &lt;td&gt;The time in milliseconds at which the sound will be played. The timestamp 
- * is used exclusively for determining when sound or video will be played. Any 
- * internal timing information in the audio or video data is ignored.&lt;/td&gt;
+ * &lt;td&gt;timestamp&lt;/td&gt;
+ * &lt;td&gt;The time in milliseconds at which the sound will be played. The
+ * timestamp is used exclusively for determining when sound or video will be
+ * played. Any internal timing information in the audio or video data is
+ * ignored.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;format&lt;/td&gt;
- * &lt;td&gt;The format of the sound data - PCM, ADPCM,  MP3, NATIVE_PCM or NELLYMOSER.&lt;/td&gt;
+ * &lt;td&gt;The format of the sound data - NATIVE_PCM, ADPCM, MP3, NELLYMOSER_8K or
+ * NELLYMOSER.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;playbackRate&lt;/td&gt;
- * &lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100. 
+ * &lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100.
  * Note: sounds encoded using the Nellymoser have a fixed playback rate of 8KHz.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
@@ -67,7 +69,7 @@
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
- * &lt;td&gt;&lt;a name=&quot;FSAudioData_5&quot;&gt;sound&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;sound&lt;/td&gt;
  * &lt;td&gt;The sampled sound data.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
@@ -76,33 +78,36 @@
  * Five encoded formats for the sound data are supported:
  * 
  * &lt;ul&gt;
- * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 
- * bytes. For two-byte samples the byte order is dependent on the platform on which 
- * the Flash Player is hosted. Sounds created on a platform which supports big-endian 
- * byte order will not be played correctly when listened to on a platform which 
- * supports little-endian byte order.&lt;/li&gt;
+ * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or
+ * 2 bytes. For two-byte samples the byte order is dependent on the platform on
+ * which the Flash Player is hosted. Sounds created on a platform which supports
+ * big-endian byte order will not be played correctly when listened to on a
+ * platform which supports little-endian byte order.&lt;/li&gt;
  * 
- * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes 
- * with the latter presented in Little-Endian byte order. This ensures that sounds 
- * can be played across different platforms.&lt;/li&gt;
+ * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded
+ * and compressed by comparing the difference between successive sound sample
+ * which dramatically reduces the size of the encoded sound when compared to the
+ * uncompressed PCM formats. Use this format or MP3 whenever possible.&lt;/li&gt;
  * 
- * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded and 
- * compressed by comparing the difference between successive sound sample which 
- * dramatically reduces the size of the encoded sound when compared to the 
- * uncompressed PCM formats. Use this format whenever possible.&lt;/li&gt;
- * 
  * &lt;li&gt;MP3 - compressed MPEG Audio Layer-3.&lt;/li&gt;
  * 
- * &lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate sound 
- * for improving synchronisation between the sound and frame rate of movies.&lt;/li&gt;
+ * &lt;li&gt;NELLYMOSER_8K - compressed Nellymoser Asao format at 8KHz supporting low 
+ * bit-rate sound for improved synchronisation between the sound and frame rate of
+ * movies. This format is not supported in SWF files.&lt;/li&gt;
+ * 
+ * &lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate
+ * sound for improved synchronisation between the sound and frame rate of
+ * movies.&lt;/li&gt;
  * &lt;/ul&gt;
  * 
  * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&lt;
  * 
- * &lt;p&gt;The FSAudioData class represents the FLV Tag with the Audio Data section 
- * from Macromedia's Flash (SWF) File Format Specification. It was added in 
- * Flash Video 1.&lt;/p&gt;
- */  
+ * &lt;p&gt;
+ * The FSAudioData class represents the FLV Tag with the Audio Data section from
+ * Macromedia's Flash (SWF) File Format Specification. It was added in Flash
+ * Video 1.
+ * &lt;/p&gt;
+ */
 public final class FSAudioData extends FSVideoObject
 {
 	private int format = 0;
@@ -111,174 +116,198 @@
 	private int playbackSampleSize = 1;
 	private byte[] soundData = null;
 
-	FSAudioData(FSCoder coder)
+	/**
+	 * Construct an FSAudioData object and initialise it from encoded data.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSAudioData encoded as binary
+	 *            data.
+	 */
+	public FSAudioData(FSCoder coder)
 	{
-        super(FSVideoObject.AudioData, 0);
+		super(FSVideoObject.AudioData, 0);
 		decode(coder);
 	}
 
-    /** 
-     * Constructs an FSAudioData object specifying the parameters required to 
-     * describe the sound.
-     * 
-     * @param timestamp time in milliseconds from the start of the file that the 
-     * sound will be played..
-     * @param aFormat the encoding format for the sound, either FSSound.NATIVE_PCM, 
-     * FSSound.PCM, FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
-     * @param rate the number of samples per second that the sound is played at, 
-     * either 5512, 11025, 22050 or 44100.
-     * @param channels the number of channels in the sound, either 1 (Mono) or 
-     * 2 (Stereo).
-     * @param sampleSize the size of an uncompressed sound sample in bits, 
-     * either 8 or 16.
-     * @param bytes the sound data.
-     */
+	/**
+	 * Constructs an FSAudioData object specifying the parameters required to
+	 * describe the sound.
+	 * 
+	 * @param timestamp
+	 *            time in milliseconds from the start of the file that the sound
+	 *            will be played..
+	 * @param aFormat
+	 *            the encoding format for the sound, either FSDefineSound.NATIVE_PCM,
+	 *            FSDefineSound.ADPCM, FSDefineSound.MP3, FSDefineSound.NELLYMOSER_8K 
+	 *            or FSDefineSound.NELLYMOSER.
+	 * @param rate
+	 *            the number of samples per second that the sound is played at,
+	 *            either 5512, 11025, 22050 or 44100.
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 * @param sampleSize
+	 *            the size of an uncompressed sound sample in bytes, either 1 or
+	 *            2.
+	 * @param bytes
+	 *            the sound data.
+	 */
 	public FSAudioData(int timestamp, int aFormat, int rate, int channels, int sampleSize, byte[] bytes)
 	{
 		super(FSVideoObject.AudioData, timestamp);
 		setFormat(aFormat);
 		setPlaybackRate(rate);
-        setPlaybackChannels(channels);
+		setPlaybackChannels(channels);
 		setPlaybackSampleSize(sampleSize);
 		setSoundData(bytes);
 	}
 
-    /**	
-     * Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM, 
-     * FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
-     * 
-     * @return a constant defining the type of compression.
-     */
-    public int getFormat() 
-    {
-        return format;
-    }
+	/**
+	 * Gets the compression format used, either FSDefineSound.NATIVE_PCM, FSDefineSound.ADPCM, 
+	 * FSDefineSound.MP3, FSDefineSound.NELLYMOSER_8K or FSDefineSound.NELLYMOSER.
+	 * 
+	 * @return a constant defining the type of compression.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-    /** 
-     * Sets the encoding format used, either FSSound.NATIVE_PCM, FSSound.PCM, 
-     * FSSound.ADPCM, FSSound.MP3 or FSSound.NELLYMOSER.
-     * 
-     * @param encoding the format for the sound.
-     */
-    public void setFormat(int encoding)
+	/**
+	 * Sets the encoding format used, either FSDefineSound.NATIVE_PCM, FSDefineSound.ADPCM,
+	 * FSDefineSound.MP3, FSDefineSound.NELLYMOSER_8K or FSDefineSound.NELLYMOSER.
+	 * 
+	 * @param encoding
+	 *            the format for the sound.
+	 */
+	public void setFormat(int encoding)
 	{
 		format = encoding;
 	}
 
-    /** 
-     * Gets the rate at which the sound will be played, in Hertz: 5512, 11025, 
-     * 22050 or 44100. Note that the playback rate for Nellymoser encoded audio 
-     * is fixed at 8Khz so the playback rate attribute has no effect.
-     * 
-     * @return the rate at which the sound was sampled.
-     */
-    public int getPlaybackRate()
-    {
-        return playbackRate;
-    }
+	/**
+	 * Gets the rate at which the sound will be played, in Hertz: 5512, 11025,
+	 * 22050 or 44100. Note that the playback rate for NELLYMOSER_8K encoded audio
+	 * is fixed at 8Khz so the playback rate attribute has no effect.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-    /** 
-     * Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or 
-     * 44100.
-     * 
-     * @param rate the rate at which the sounds is played in Hz.
-     */
-    public void setPlaybackRate(int rate)
+	/**
+	 * Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or
+	 * 44100.
+	 * 
+	 * @param rate
+	 *            the rate at which the sounds is played in Hz.
+	 */
+	public void setPlaybackRate(int rate)
 	{
 		playbackRate = rate;
 	}
 
-    /** 
-     * Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
-     * 
-     * @return the number of channels.
-     */
-    public int getPlaybackChannels()
-    {
-        return playbackChannels;
-    }
+	/**
+	 * Gets the number of sound channels, 1 (Mono) or 2 (Stereo). Both 
+	 * NELLYMOSER_8K and NELLYMOSER are encoded as mono so the playbackChannels
+	 * attribute has no effect.
+	 * 
+	 * @return the number of channels.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-    /** 
-     * Sets the number of channels defined in the sound.
-     * 
-     * @param channels the number of channels in the sound, either 1 (Mono) or 
-     * 2 (Stereo).
-     */
-    public void setPlaybackChannels(int channels)
-    {
-        playbackChannels = channels;
-    }
+	/**
+	 * Sets the number of channels defined in the sound.
+	 * 
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 */
+	public void setPlaybackChannels(int channels)
+	{
+		playbackChannels = channels;
+	}
 
-    /** 
-     * Gets the size of an uncompressed sample in bytes.
-     * 
-     * @return the number of bytes per sample when the sound is uncompressed.
-     */
-    public int getPlaybackSampleSize() 
-    {
-        return playbackSampleSize;
-    }
+	/**
+	 * Gets the size of an uncompressed sample in bytes.
+	 * 
+	 * @return the number of bytes per sample when the sound is uncompressed.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-    /** 
-     * Sets the sample size in bytes. Must be either 1 or 2.
-     * 
-     * @param sampleSize the size of sound samples in bytes.
-     */
-    public void setPlaybackSampleSize(int sampleSize)
+	/**
+	 * Sets the sample size in bytes. Must be either 1 or 2.
+	 * 
+	 * @param sampleSize
+	 *            the size of sound samples in bytes.
+	 */
+	public void setPlaybackSampleSize(int sampleSize)
 	{
 		playbackSampleSize = sampleSize;
 	}
 
-    /** 
-     * Gets the sound data.
-     * 
-     * @return an array of bytes containing the sampled sound.
-     */
-    public byte[] getSoundData()
-    {
-        return soundData;
-    }
+	/**
+	 * Gets the sound data.
+	 * 
+	 * @return an array of bytes containing the sampled sound.
+	 */
+	public byte[] getSoundData()
+	{
+		return soundData;
+	}
 
-    /** 
-     * Sets the sound data.
-     * 
-     * @param bytes the sound data.
-     */
-    public void setSoundData(byte[] bytes)
+	/**
+	 * Sets the sound data.
+	 * 
+	 * @param bytes
+	 *            the sound data.
+	 */
+	public void setSoundData(byte[] bytes)
 	{
 		soundData = bytes;
 	}
 
-    public Object clone()
+	public Object clone()
 	{
-        FSAudioData anObject = (FSAudioData)super.clone();
-        
-        anObject.soundData = Transform.clone(soundData);
-        
+		FSAudioData anObject = (FSAudioData) super.clone();
+
+		anObject.soundData = Transform.clone(soundData);
+
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSAudioData typedObject = (FSAudioData)anObject;
-            
-            result = format == typedObject.format;
-            result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-            result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-            result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-            result = result &amp;&amp; Transform.equals(soundData, typedObject.soundData);
-        }
+		{
+			FSAudioData typedObject = (FSAudioData) anObject;
+
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result
+							&amp;&amp; Transform.equals(soundData,
+											typedObject.soundData);
+		}
 		return result;
 	}
 
 	public void appendDescription(StringBuffer buffer, int depth)
 	{
 		buffer.append(name());
-		
+
 		if (depth &gt; 0)
 		{
 			buffer.append(&quot;: { &quot;);
@@ -287,8 +316,7 @@
 			Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
 			Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
 			buffer.append(&quot;}&quot;);
-		}
-		else
+		} else
 		{
 			buffer.append(name());
 		}
@@ -297,63 +325,63 @@
 	int length(FSCoder coder)
 	{
 		super.length(coder);
-	
+
 		length += 1 + soundData.length;
-	
+
 		return length;
 	}
-	
+
 	void encode(FSCoder coder)
 	{
-        super.encode(coder);
-		
+		super.encode(coder);
+
 		coder.writeBits(format, 4);
-        
-        switch (playbackRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(playbackSampleSize-1, 1);
-		coder.writeBits(playbackChannels-1, 1);
+
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
 		coder.writeBytes(soundData);
 	}
-	
+
 	void decode(FSCoder coder)
 	{
 		super.decode(coder);
-		
+
 		format = coder.readBits(4, false);
 
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                playbackRate = 5512;
-                break;
-            case 1:
-                playbackRate = 11025;
-                break;
-            case 2:
-                playbackRate = 22050;
-                break;
-            case 3:
-                playbackRate = 44100;
-                break;
-        }
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
 
-        playbackSampleSize = coder.readBits(1, false)+1;
-		playbackChannels = coder.readBits(1, false)+1;	
-		soundData = new byte[length-1];
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
+		soundData = new byte[length - 1];
 		coder.readBytes(soundData);
 	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSBitmapFill.java
===================================================================
--- trunk/src/com/flagstone/transform/FSBitmapFill.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSBitmapFill.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,232 +31,295 @@
 package com.flagstone.transform;
 
 /**
-The FSBitmapFill class is used to fill a shape with an image. 
- 
-&lt;p&gt;Two types of bitmap fill are supported:&lt;/p&gt;
+ * The FSBitmapFill class is used to fill a shape with an image.
+ * 
+ * &lt;p&gt;
+ * Two types of bitmap fill are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Clipped&lt;/td&gt;
+ * &lt;td&gt;If the area to be filled is larger than the image then the colour at the
+ * edge of the image is used to fill the remainder of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Tiled&lt;/td&gt;
+ * &lt;td&gt;If the area to be filled is larger than the image then the image is
+ * tiled across the area to be filled.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Unsmoothed Clipped&lt;/td&gt;
+ * &lt;td&gt;If the area to be filled is larger than the image then the colour at the
+ * edge of the image is used to fill the remainder of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Unsmoothed Tiled&lt;/td&gt;
+ * &lt;td&gt;If the area to be filled is larger than the image then the image is
+ * tiled without smoothing to fill the area.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;!-- Blank paragraph to provide spacing between tables --&gt;
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;The type of bitmap fill, either FSFillStyle.Tiled or
+ * FSFillStyle.Clipped.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the object that contains the
+ * image that will be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;An FSCoordTransform object that defines the coordinate transformation
+ * that will be applied to the image, to change its size, location relative to
+ * the origin of the shape, orientation, etc., when it is displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The type attribute may be used when iterating through an array of fill style
+ * objects to identify the type of fill style without using run-time type
+ * checking.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When an image is loaded its width and height default to twips rather than
+ * pixels. An image 300 x 200 pixels will be displayed as 300 x 200 twips (15 x
+ * 10 pixels). Scaling the image by 20 (20 twips = 1 pixel) using the
+ * FSCoordTransform object will restore it to its original size.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The image is drawn with the top left corner placed at the origin (0, 0) of
+ * the shape being filled. Depending on how the shape is drawn the coordinate
+ * transform may also need to specify a translation to place the image at the
+ * desired location.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;When To Use&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * In addition to filling shapes with images that represent textures or complex
+ * fill patterns the FSBitmapFill class is required to display any image in a
+ * Flash file - image can only be displayed in Flash inside a shape definition.
+ * The classes that define images only contain the image data, not how it is
+ * displayed. To simply display an image, the selected line style of a shape may
+ * be set to zero so that the image is displayed without a border.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following code fragment centres the image in the centre of the shape -
+ * assuming the shape is drawn with the origin at the centre. The transform
+ * constructor allows the translation and scaling transform to be specified in a
+ * single step rather than compositing the transforms.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform composite = new FSCoordTransform(-imageWidth / 2,
+ * 				-imageHeight / 2, 20.0, 20.0);
+ * 
+ * fillStyles.add(new FSBitmapFill(FSFillStyle.Clipped, imageId, composite));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSBitmapFill class represents the FillStyle structure from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSBitmapFill extends FSFillStyle
+{
+	private int identifier = 0;
+	private FSCoordTransform transform = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSBitmapFill object an initialize it with values decoded
+	 * from an encoded FSBitmapFill object.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSBitmapFill encoded as binary
+	 *            data.
+	 */
+	public FSBitmapFill(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;Clipped&lt;/td&gt;
-&lt;td&gt;If the area to be filled is larger than the image then the colour at the edge 
-of the image is used to fill the remainder of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSBitmapFill object, specifying whether the image is tiled
+	 * or clipped within the shape, the identifier of the object containing the
+	 * image data and the coordinate transform used to change the appearance of
+	 * the image and place it relative to the origin of the shape.
+	 * 
+	 * @param aType
+	 *            the type of bitmap fill, FSFillStyle.Clipped or
+	 *            FSFillStyle.Tiled.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object containing the image to be
+	 *            displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that changes the appearance of the
+	 *            image.
+	 */
+	public FSBitmapFill(int aType, int anIdentifier, FSCoordTransform aTransform)
+	{
+		super(aType);
 
-&lt;tr&gt;
-&lt;td&gt;Tiled&lt;/td&gt;
-&lt;td&gt;If the area to be filled is larger than the image then the image is tiled 
-across the area to be filled.&lt;/td&gt;
-&lt;/tr&gt;
+		setType(aType);
+		setIdentifier(anIdentifier);
+		setTransform(aTransform);
+	}
 
-&lt;tr&gt;
-&lt;td valign=&quot;top&quot;&gt;Unsmoothed Clipped&lt;/td&gt;
-&lt;td&gt;If the area to be filled is larger than the image then the colour at the edge 
-of the image is used to fill the remainder of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSBitmapFill object by copying an existing object.
+	 * 
+	 * @param obj
+	 *            an FSBitmapFill object.
+	 */
+	public FSBitmapFill(FSBitmapFill obj)
+	{
+		super(obj.type);
+		identifier = obj.identifier;
+		transform = new FSCoordTransform(obj.transform);
+	}
 
-&lt;tr&gt;
-&lt;td valign=&quot;top&quot;&gt;Unsmoothed Tiled&lt;/td&gt;
-&lt;td&gt;If the area to be filled is larger than the image then the image is tiled 
-without smoothing to fill the area.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the object containing the image to be displayed.
+	 * 
+	 * @return the identifier of the image object to be displayed.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
+	/**
+	 * Sets the identifier of the object containing the image to be displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object containing the image to be
+	 *            displayed.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the coordinate transform applied to the image.
+	 * 
+	 * @return the transform that will be applied to the image when it is
+	 *         displayed.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;p&gt;&lt;!-- Blank paragraph to provide spacing between tables --&gt;&lt;/p&gt;
+	/**
+	 * Sets the coordinate transform applied to the image to display it inside
+	 * the shape.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that changes the appearance and
+	 *            location of the image inside the shape.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	public Object clone()
+	{
+		FSBitmapFill anObject = (FSBitmapFill) (super.clone());
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		anObject.transform = (transform != null) ? (FSCoordTransform) (transform
+						.clone())
+						: null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBitmapFill_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The type of bitmap fill, either FSFillStyle.Tiled or FSFillStyle.Clipped.&lt;/td&gt;
-&lt;/tr&gt;
+		return anObject;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBitmapFill_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the object that contains the image that will be displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBitmapFill_2&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSCoordTransform object that defines the coordinate transformation that will be applied to the image, to change its size, location relative to the origin of the shape, orientation, etc., when it is displayed.&lt;/td&gt;
-&lt;/tr&gt;
+		if (super.equals(anObject))
+		{
+			FSBitmapFill typedObject = (FSBitmapFill) anObject;
 
-&lt;/table&gt;
+			result = identifier == typedObject.identifier;
 
-&lt;p&gt;The type attribute may be used when iterating through an array of fill style objects to identify the type of fill style without using run-time type checking.&lt;/p&gt;
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
+		}
+		return result;
+	}
 
-&lt;p&gt;When an image is loaded its width and height default to twips rather than pixels. An image 300 x 200 pixels will be displayed as 300 x 200 twips (15 x 10 pixels). Scaling the image by 20 (20 twips = 1 pixel) using the FSCoordTransform object will restore it to its original size.&lt;/p&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;The image is drawn with the top left corner placed at the origin (0, 0) of the shape being filled. Depending on how the shape is drawn the coordinate transform may also need to specify a translation to place the image at the desired location.&lt;/p&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;When To Use&lt;/h1&gt;
+	public int length(FSCoder coder)
+	{
+		int length = super.length(coder);
 
-&lt;p&gt;In addition to filling shapes with images that represent textures or complex fill patterns the FSBitmapFill class is required to display any image in a Flash file - image can only be displayed in Flash inside a shape definition. The classes that define images only contain the image data, not how it is displayed. To simply display an image, the selected line style of a shape may be set to zero so that the image is displayed without a border.&lt;/p&gt;
+		length += 2;
+		length += transform.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+		return length;
+	}
 
-&lt;p&gt;The following code fragment centres the image in the centre of the shape - assuming  the shape is drawn with the origin at the centre. The transform constructor allows the translation and scaling transform to be specified in a single step rather than compositing the transforms.&lt;/p&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-&lt;pre&gt;
-FSCoordTransform composite = new FSCoordTransform(-imageWidth/2, -imageHeight/2, 20.0, 20.0);
+		coder.writeWord(identifier, 2);
+		transform.encode(coder);
+	}
 
-fillStyles.add(new FSBitmapFill(FSFillStyle.Clipped, imageId, composite));
-&lt;/pre&gt;
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSBitmapFill class represents the FillStyle structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSBitmapFill extends FSFillStyle
-{
-    private int identifier = 0;
-    private FSCoordTransform transform = null;
-    
-    /**
-     * Construct an FSBitmapFill object an initialize it with values decoded 
-     * from an encoded FSBitmapFill object.
-     * 
-     * @param coder an FSCoder object containing an FSBitmapFill encoded as 
-     * binary data.
-     */
-    public FSBitmapFill(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSBitmapFill object, specifying whether the image is tiled
-     * or clipped within the shape, the identifier of the object containing the
-     * image data and the coordinate transform used to change the appearance of
-     * the image and place it relative to the origin of the shape.
- 
-        @param aType the type of bitmap fill, FSFillStyle.Clipped or FSFillStyle.Tiled.
-
-        @param anIdentifier the identifier of the object containing the image to 
-        be displayed.
-        
-        @param aTransform an FSCoordTransform object that changes the appearance 
-        of the image.
-        */
-    public FSBitmapFill(int aType, int anIdentifier, FSCoordTransform aTransform)
-    {
-        super(aType);
-        
-        setType(aType);
-        setIdentifier(anIdentifier);
-        setTransform(aTransform);
-    }
-    /**
-     * Construct an FSBitmapFill object by copying an existing object.
-     * 
-     * @param obj an FSBitmapFill object. 
-     */
-    public FSBitmapFill(FSBitmapFill obj)
-    {
-        identifier = obj.identifier;
-        transform = new FSCoordTransform(obj.transform);
-    }   
-
-    /** Gets the identifier of the object containing the image to be displayed.
-
-        @return the identifier of the image object to be displayed.
-        */
-    public int getIdentifier() { return identifier; }
-
-    /** Sets the identifier of the object containing the image  to be displayed. 
-
-        @param anIdentifier the identifier of the object containing the image to 
-        be displayed.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-
-    /** Gets the coordinate transform applied to the image.
-
-        @return the transform that will be applied to the image when it is displayed.
-        */
-    public FSCoordTransform getTransform() { return transform; }
-
-    /** 
-     * Sets the coordinate transform applied to the image to display it inside 
-     * the shape.
-
-        @param aTransform an FSCoordTransform object that changes the appearance 
-        and location of the image inside the shape.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
-
-    public Object clone()
-    {
-        FSBitmapFill anObject = (FSBitmapFill)(super.clone());
-        
-        anObject.transform = (transform != null) ? (FSCoordTransform)(transform.clone()) : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSBitmapFill typedObject = (FSBitmapFill)anObject;
-            
-            result = identifier == typedObject.identifier;
-
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = super.length(coder);
-
-        length += 2;
-        length += transform.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(identifier, 2);
-        transform.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        identifier = coder.readWord(2, false);
-        transform = new FSCoordTransform(coder);
-    }
+		identifier = coder.readWord(2, false);
+		transform = new FSCoordTransform(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSBounds.java
===================================================================
--- trunk/src/com/flagstone/transform/FSBounds.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSBounds.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,321 +31,400 @@
 package com.flagstone.transform;
 
 /**
-The FSBounds class is used to define the area inside which shapes, text fields and 
-characters are drawn.
- 
-&lt;p&gt;In Flash the axes are specified relative to the top left corner of the screen and the bounding area is defined by two pairs of coordinates that identify the top left and bottom right corners of a rectangle.&lt;/p&gt;
+ * The FSBounds class is used to define the area inside which shapes, text
+ * fields and characters are drawn.
+ * 
+ * &lt;p&gt;
+ * In Flash the axes are specified relative to the top left corner of the screen
+ * and the bounding area is defined by two pairs of coordinates that identify
+ * the top left and bottom right corners of a rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/bounds.gif&quot;&gt;
+ * 
+ * &lt;P&gt;
+ * &lt;!-- blank paragraph to add space between the image and the next table --&gt;
+ * &lt;/P&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;minX&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of the upper left corner of the rectangle.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;minY&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of the upper left corner of the rectangle.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;maxX&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of the lower right corner of the rectangle.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;maxY&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of the lower right corner of the rectangle.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The coordinates for each corner also specify the coordinate range so
+ * specifying a bounding rectangle with the points (-100,-100) and (100,100)
+ * defines a rectangle 200 twips by 200 twips with the point (0,0) located in
+ * the centre. Specifying the points (0,0) and (200,200) defines a rectangle
+ * with the same size however the centre is now located at (100,100).
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The bounding rectangle does not clip the object when it is drawn. Lines and
+ * curves drawn outside of the rectangle will still be displayed. However when
+ * the bounding rectangle is defined for an FSMovie object then this defines the
+ * size of the Flash Player screen and shapes drawn outside of the bounding
+ * rectangle will not be displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * To create an FSBounds object simply specify the coordinates of the corners of
+ * the rectangle in the following order: top left x, top left y, bottom right x,
+ * bottom right y.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSBounds bounds = new FSBounds(0, 0, 100, 200);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Creates a bounding rectangle for an object which is 100 twips wide and 200
+ * twips high. The coordinate range for the object is from 0..100 along the
+ * x-axis and 0..200 along the y-axis. The origin (0,0) will be at the top left
+ * corner of the object as it is displayed on the screen.
+ * 
+ * &lt;pre&gt;
+ * FSBounds bounds = new FSBounds(-100, -200, 100, 200);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Creates a bounding rectangle for an object which is 200 twips wide and 400
+ * twips high. The coordinate range for the object is from -100..100 along the
+ * x-axis and -200..200 along the y-axis. The origin (0,0) will be in the middle
+ * of the object as it is displayed on the screen.
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSBounds class corresponds to the RECT data type, in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSBounds extends FSTransformObject
+{
+	private int minX = 0;
+	private int minY = 0;
+	private int maxX = 0;
+	private int maxY = 0;
 
-&lt;img src=&quot;doc-files/bounds.gif&quot;&gt;
+	/**
+	 * Construct an FSBounds object an initialise it with values decoded from a
+	 * binary encoded FSBounds object.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSBounds encoded as binary
+	 *            data.
+	 */
+	public FSBounds(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;P&gt;&lt;!-- blank paragraph to add space between the image and the next table --&gt;&lt;/P&gt;
+	/**
+	 * Constructs an FSBounds object representing a rectangle with the top left
+	 * corner at (xl,yl) and bottom right corner at (xr,yr).
+	 * 
+	 * @param xl
+	 *            x-coordinate of the top left corner.
+	 * @param yl
+	 *            y-coordinate of the top left corner.
+	 * @param xr
+	 *            x-coordinate of bottom right corner.
+	 * @param yr
+	 *            y-coordinate of bottom right corner.
+	 */
+	public FSBounds(int xl, int yl, int xr, int yr)
+	{
+		setMinX(xl);
+		setMinY(yl);
+		setMaxX(xr);
+		setMaxY(yr);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSBounds object and initialise it with value from another
+	 * FSBounds object.
+	 * 
+	 * @param obj
+	 *            an FSBounds object.
+	 */
+	public FSBounds(FSBounds obj)
+	{
+		minX = obj.minX;
+		maxX = obj.maxX;
+		minY = obj.minY;
+		maxY = obj.maxY;
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Gets the x-coordinate of the top left corner of the bounding rectangle.
+	 * 
+	 * @return the x-coordinate of the lower left corner of the bounding
+	 *         rectangle.
+	 */
+	public int getMinX()
+	{
+		return minX;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBounds_0&quot;&gt;minX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of the upper left corner of the rectangle.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the x-coordinate of the bottom right corner of the bounding
+	 * rectangle.
+	 * 
+	 * @return the x-coordinate of the bottom right corner of the bounding
+	 *         rectangle.
+	 */
+	public int getMaxX()
+	{
+		return maxX;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBounds_1&quot;&gt;minY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of the upper left corner of the rectangle.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the y-coordinate of the top left corner of the bounding rectangle.
+	 * 
+	 * @return the y-coordinate of the top left corner of the bounding
+	 *         rectangle.
+	 */
+	public int getMinY()
+	{
+		return minY;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBounds_2&quot;&gt;maxX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of the lower right corner of the rectangle.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the y-coordinate of the bottom right corner of the bounding
+	 * rectangle.
+	 * 
+	 * @return the y-coordinate of the bottom right corner of the bounding
+	 *         rectangle.
+	 */
+	public int getMaxY()
+	{
+		return maxY;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSBounds_3&quot;&gt;maxY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of the lower right corner of the rectangle.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the x-coordinate of the top left corner of the bounding rectangle.
+	 * 
+	 * @param aNumber
+	 *            x-coordinate of the lower left corner of the bounding
+	 *            rectangle.
+	 */
+	public void setMinX(int aNumber)
+	{
+		minX = aNumber;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the x-coordinate of the bottom right corner of the bounding
+	 * rectangle.
+	 * 
+	 * @param aNumber
+	 *            x-coordinate of the bottom right corner of the bounding
+	 *            rectangle.
+	 */
+	public void setMaxX(int aNumber)
+	{
+		maxX = aNumber;
+	}
 
-&lt;p&gt;The coordinates for each corner also specify the coordinate range so specifying 
-a bounding rectangle with the points (-100,-100) and (100,100) defines a rectangle 
-200 twips by 200 twips with the point (0,0) located in the centre. Specifying the 
-points (0,0) and (200,200) defines a rectangle with the same size however the centre 
-is now located at (100,100).&lt;/p&gt;
+	/**
+	 * Sets the y-coordinate of the upper left corner of the bounding rectangle.
+	 * 
+	 * @param aNumber
+	 *            y-coordinate of the lower left corner of the bounding
+	 *            rectangle.
+	 */
+	public void setMinY(int aNumber)
+	{
+		minY = aNumber;
+	}
 
-&lt;p&gt;The bounding rectangle does not clip the object when it is drawn. Lines and curves 
-drawn outside of the rectangle will still be displayed. However when the bounding 
-rectangle is defined for an FSMovie object then this defines the size of the Flash 
-Player screen and shapes drawn outside of the bounding rectangle will not be displayed.&lt;/p&gt;
+	/**
+	 * Sets the y-coordinate of the bottom right corner of the bounding
+	 * rectangle.
+	 * 
+	 * @param aNumber
+	 *            x-coordinate of the bottom right corner of the bounding
+	 *            rectangle.
+	 */
+	public void setMaxY(int aNumber)
+	{
+		maxY = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the width of the rectangle.
+	 * 
+	 * @return the width of the rectangle.
+	 */
+	public int getWidth()
+	{
+		return maxX - minX;
+	}
 
-&lt;p&gt;To create an FSBounds object simply specify the coordinates of the corners of the 
-rectangle in the following order: top left x, top left y, bottom right x, bottom 
-right y.&lt;/p&gt;
+	/**
+	 * Gets the height of the rectangle.
+	 * 
+	 * @return the height of the rectangle.
+	 */
+	public int getHeight()
+	{
+		return maxY - minY;
+	}
 
-&lt;pre&gt;
-FSBounds bounds = new FSBounds(0, 0, 100, 200);
-&lt;/pre&gt;
+	/**
+	 * Sets the x and y coordinates of the lower corner.
+	 * 
+	 * @param xl
+	 *            the x-coordinate of the top left corner point.
+	 * @param yl
+	 *            the y-coordinate of the top left corner point.
+	 */
+	public void setMin(int xl, int yl)
+	{
+		minX = xl;
+		minY = yl;
+	}
 
-&lt;p&gt;Creates a bounding rectangle for an object which is 100 twips wide and 200 twips high. The coordinate range for the object is from 0..100 along the x-axis and 0..200 along the y-axis. The origin (0,0) will be at the top left corner of the object as it is displayed on the screen.
+	/**
+	 * Sets the x and y coordinates of the upper corner.
+	 * 
+	 * @param xr
+	 *            the x-coordinate of the bottom right corner point.
+	 * @param yr
+	 *            the y-coordinate of the bottom right corner point.
+	 */
+	public void setMax(int xr, int yr)
+	{
+		maxX = xr;
+		maxY = yr;
+	}
 
-&lt;pre&gt;
-FSBounds bounds = new FSBounds (-100, -200, 100, 200);
-&lt;/pre&gt;
+	/**
+	 * Sets the x and y coordinates of the lower and upper corner point.
+	 * 
+	 * @param xl
+	 *            the x-coordinate of the top left corner point.
+	 * @param yl
+	 *            the y-coordinate of the top left corner point.
+	 * @param xr
+	 *            the x-coordinate of the bottom right corner point.
+	 * @param yr
+	 *            the y-coordinate of the bottom right corner point.
+	 */
+	public void setPoints(int xl, int yl, int xr, int yr)
+	{
+		minX = xl;
+		minY = yl;
+		maxX = xr;
+		maxY = yr;
+	}
 
-&lt;p&gt;Creates a bounding rectangle for an object which is 200 twips wide and 400 twips high. The coordinate range for the object is from -100..100 along the x-axis and -200..200 along the y-axis. The origin (0,0) will be in the middle of the object as it is displayed on the screen.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @param anObject
+	 *            the reference object with which to compare.
+	 *            
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSBounds typedObject = (FSBounds) anObject;
 
-&lt;p&gt;The FSBounds class corresponds to the RECT data type, in the Macromedia Flash 
-(SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSBounds extends FSTransformObject
-{
-    private int minX = 0;
-    private int minY = 0;
-    private int maxX = 0;
-    private int maxY = 0;
-    
-    /**
-     * Construct an FSBounds object an initialize it with values decoded from 
-     * a binary encoded FSBounds object.
-     * 
-     * @param coder an FSCoder object containing an FSBounds encoded as binary
-     * data.
-     */
-    public FSBounds(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSBounds object representing a rectangle with the top left corner at (xl,yl) and bottom right corner at (xr,yr).
+			result = minX == typedObject.minX;
+			result = result &amp;&amp; minY == typedObject.minY;
+			result = result &amp;&amp; maxX == typedObject.maxX;
+			result = result &amp;&amp; maxY == typedObject.maxY;
+		}
+		return result;
+	}
 
-        @param xl x-coordinate of the top left corner.
-        @param yl y-coordinate of the top left corner.
-        @param xr x-coordinate of bottom right corner.
-        @param yr y-coordinate of bottom right corner.
-        */
-    public FSBounds(int xl, int yl, int xr, int yr)
-    {
-        setMinX(xl);
-        setMinY(yl);
-        setMaxX(xr);
-        setMaxY(yr);
-    }
-    /**
-     * Construct an FSBounds object and initialize it with value from another 
-     * FSBounds object.
-     * 
-     * @param obj an FSBounds object.
-     */
-    public FSBounds(FSBounds obj)
-    {
-        minX = obj.minX;
-        maxX = obj.maxX;
-        minY = obj.minY;
-        maxY = obj.maxY;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the x-coordinate of the top left corner of the bounding rectangle.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;minX&quot;, minX);
+			Transform.append(buffer, &quot;minY&quot;, minY);
+			Transform.append(buffer, &quot;maxX&quot;, maxX);
+			Transform.append(buffer, &quot;maxY&quot;, maxY);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the x-coordinate of the lower left corner of the bounding rectangle.
-        */
-    public int getMinX() 
-    {
-        return minX;
-    }
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 0;
+		int fieldSize = FSCoder.size(new int[]
+		{
+			minX, maxX, minY, maxY }, true);
 
-    /** Gets the x-coordinate of the bottom right corner of the bounding rectangle. 
-    
-        @return the x-coordinate of the bottom right corner of the bounding rectangle.
-        */
-    public int getMaxX() 
-    {
-        return maxX;
-    }
+		numberOfBits = 5 + fieldSize * 4;
+		numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
 
-    /** Gets the y-coordinate of the top left corner of the bounding rectangle. 
-    
-        @return the y-coordinate of the top left corner of the bounding rectangle.
-        */
-    public int getMinY() 
-    {
-        return minY;
-    }
+		return numberOfBits &gt;&gt; 3;
+	}
 
-    /** Gets the y-coordinate of the bottom right corner of the bounding rectangle. 
-    
-        @return the y-coordinate of the bottom right corner of the bounding rectangle.
-        */
-    public int getMaxY()
-    {
-        return maxY;
-    }
+	public void encode(FSCoder coder)
+	{
+		int numberOfBits = FSCoder.size(new int[]
+		{
+			minX, maxX, minY, maxY }, true);
 
-    /** Sets the x-coordinate of the top left corner of the bounding rectangle.
+		coder.alignToByte();
+		coder.writeBits(numberOfBits, 5);
+		coder.writeBits(minX, numberOfBits);
+		coder.writeBits(maxX, numberOfBits);
+		coder.writeBits(minY, numberOfBits);
+		coder.writeBits(maxY, numberOfBits);
+		coder.alignToByte();
+	}
 
-        @param aNumber x-coordinate of the lower left corner of the bounding rectangle.
-        */
-    public void setMinX(int aNumber) 
-    {
-        minX = aNumber;
-    }
+	public void decode(FSCoder coder)
+	{
+		coder.alignToByte();
 
-    /** Sets the x-coordinate of the bottom right corner of the bounding rectangle.
-        
-        @param aNumber x-coordinate of the bottom right corner of the bounding rectangle.
-        */
-    public void setMaxX(int aNumber)
-    {
-        maxX = aNumber;
-    }
+		int fieldSize = coder.readBits(5, false);
 
-    /** Sets the y-coordinate of the upper left corner of the bounding rectangle.
-        
-        @param aNumber y-coordinate of the lower left corner of the bounding rectangle.
-        */
-    public void setMinY(int aNumber)
-    {
-        minY = aNumber;
-    }
+		minX = coder.readBits(fieldSize, true);
+		maxX = coder.readBits(fieldSize, true);
+		minY = coder.readBits(fieldSize, true);
+		maxY = coder.readBits(fieldSize, true);
 
-    /** Sets the y-coordinate of the bottom right corner of the bounding rectangle.
-        
-        @param aNumber x-coordinate of the bottom right corner of the bounding rectangle.
-        */
-    public void setMaxY(int aNumber)
-    {
-        maxY = aNumber;
-    }
-
-    /** Gets the width of the rectangle.
-
-        @return the width of the rectangle.
-        */
-    public int getWidth()
-    {
-        return maxX - minX;
-    }
-
-    /** Gets the height of the rectangle. 
-    
-        @return the height of the rectangle.
-        */
-    public int getHeight()
-    {
-        return maxY - minY;
-    }
-
-    /** Sets the x and y coordinates of the lower corner.
-    
-        @param xl the x-coordinate of the top left corner point.
-        @param yl the y-coordinate of the top left corner point.
-        */
-    public void setMin(int xl, int yl)
-    {
-        minX = xl;
-        minY = yl;
-    }
-
-    /** Sets the x and y coordinates of the upper corner. 
-        
-        @param xr the x-coordinate of the bottom right corner point.
-        @param yr the y-coordinate of the bottom right corner point.
-        */
-    public void setMax(int xr, int yr)
-    {
-        maxX = xr;
-        maxY = yr;
-    }
-
-    /** Sets the x and y coordinates of the lower and upper corner point.
-            
-        @param xl the x-coordinate of the top left corner point.
-        @param yl the y-coordinate of the top left corner point.
-        @param xr the x-coordinate of the bottom right corner point.
-        @param yr the y-coordinate of the bottom right corner point.
-        */
-    public void setPoints(int xl, int yl, int xr, int yr)
-    {
-        minX = xl;
-        minY = yl;
-        maxX = xr;
-        maxY = yr;
-    }
-    
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSBounds typedObject = (FSBounds)anObject;
-            
-            result = minX == typedObject.minX;
-            result = result &amp;&amp; minY == typedObject.minY;
-            result = result &amp;&amp; maxX == typedObject.maxX;
-            result = result &amp;&amp; maxY == typedObject.maxY;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;minX&quot;, minX);
-            Transform.append(buffer, &quot;minY&quot;, minY);
-            Transform.append(buffer, &quot;maxX&quot;, maxX);
-            Transform.append(buffer, &quot;maxY&quot;, maxY);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 0;
-        int fieldSize = FSCoder.size(new int[]{minX, maxX, minY, maxY}, true);
-        
-        numberOfBits = 5 + fieldSize*4;
-        numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
-        
-        return numberOfBits&gt;&gt;3; 
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfBits = FSCoder.size(new int[]{minX, maxX, minY, maxY}, true);
-        
-        coder.alignToByte();    
-        coder.writeBits(numberOfBits, 5);
-        coder.writeBits(minX, numberOfBits);
-        coder.writeBits(maxX, numberOfBits);
-        coder.writeBits(minY, numberOfBits);
-        coder.writeBits(maxY, numberOfBits);    
-        coder.alignToByte();
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        coder.alignToByte();
-        
-        int fieldSize = coder.readBits(5, false);
-        
-        minX = coder.readBits(fieldSize, true);
-        maxX = coder.readBits(fieldSize, true);
-        minY = coder.readBits(fieldSize, true);
-        maxY = coder.readBits(fieldSize, true);
-        
-        coder.alignToByte();
-    }
+		coder.alignToByte();
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButton.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSButton.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,344 +31,497 @@
 package com.flagstone.transform;
 
 /**
-FSButton identifies the shape that is drawn when a button is in a particular state.
-
-&lt;p&gt;Shapes can be drawn for each of three button states, Over, Up and Down. Creating a button with more than one FSButton object each referencing a different shape allows the button to be animated as it is clicked.&lt;/p&gt;
-
-&lt;p&gt;A shape is also used to define active area of the button. When defining the active area the outline of the shape defines the boundary of the area. The shape is not drawn when the button is displayed. The button will only respond to mouse events when the cursor is placed inside the active area.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_0&quot;&gt;state&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;the state(s) the button is in when the shape will be drawn, either Up, Over or Down. Active is used to denote when a shape defined the active area of a button.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_1&quot;&gt;identifier&lt;a/&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the object that contains the definition of the shape that is drawn.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The layer number defines the order in which shapes are displayed. Shapes with a higher layer number are displayed in front of those on a lower layer. Complex buttons can be created by displaying more than one shape for a given button state. The layer number may be in the range 1..65535 - the range is determined by the size of the field when the value is encoded to a Flash file - however the vast majority of buttons will typically only use layer numbers less than 10.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an FSCoordTransform object that defines a coordinate transform that will be applied to the shape when it is displayed. The transform is most commonly used to offset shapes to create a 3-D appearance. The size may also be changed allowing a single shape definition to be used to display buttons in a range of sizes while still maintaining the same look and feel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButton_3&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an optional FSColorTransform object that can be used to change the shape's
-colour when it is drawn.&lt;/td&gt;
-&lt;/tr&gt;
-
-
-&lt;/table&gt;
-
-&lt;p&gt;An FSButton can define the appearance of the button for more than one state. Multiple states can be defined by bitwise Or-ing individual state codes together:&lt;/p&gt;
-
-&lt;pre&gt;
-int buttonState = FSButton.Up | FSButton.Over;
-&lt;/pre&gt;
-
-&lt;p&gt;The purpose of the layer attribute is to define the order in which shapes are displayed for a given button state. This is analogous to the layer number in the Flash Player's display list - specified using objects such as FSPlaceObject. When a button is displayed it is placed on a single layer in the display list and the layer numbers assigned to shapes in a FSButton object do not interfere with shapes assigned to the same layer in the display list.&lt;/p&gt;
-
-&lt;p&gt;The coordinate transform is used to change the appearance of the button without changing the original shape definitions. If it is omitted then a unity transform will be encoded which does not change the way the shape is drawn.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSButton class represents the ButtonRecord structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
-
+ * FSButton identifies the shape that is drawn when a button is in a particular
+ * state.
+ * 
+ * &lt;p&gt;
+ * Shapes can be drawn for each of three button states, Over, Up and Down.
+ * Creating a button with more than one FSButton object each referencing a
+ * different shape allows the button to be animated as it is clicked.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * A shape is also used to define active area of the button. When defining the
+ * active area the outline of the shape defines the boundary of the area. The
+ * shape is not drawn when the button is displayed. The button will only respond
+ * to mouse events when the cursor is placed inside the active area.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSButton_0&quot;&gt;state&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;the state(s) the button is in when the shape will be drawn, either Up,
+ * Over or Down. Active is used to denote when a shape defined the active area
+ * of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSButton_1&quot;&gt;identifier&lt;a/&gt;&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the object that contains the
+ * definition of the shape that is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSButton_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The layer number defines the order in which shapes are displayed. Shapes
+ * with a higher layer number are displayed in front of those on a lower layer.
+ * Complex buttons can be created by displaying more than one shape for a given
+ * button state. The layer number may be in the range 1..65535 - the range is
+ * determined by the size of the field when the value is encoded to a Flash file -
+ * however the vast majority of buttons will typically only use layer numbers
+ * less than 10.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSButton_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;an FSCoordTransform object that defines a coordinate transform that will
+ * be applied to the shape when it is displayed. The transform is most commonly
+ * used to offset shapes to create a 3-D appearance. The size may also be
+ * changed allowing a single shape definition to be used to display buttons in a
+ * range of sizes while still maintaining the same look and feel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSButton_3&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;an optional FSColorTransform object that can be used to change the
+ * shape's colour when it is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * An FSButton can define the appearance of the button for more than one state.
+ * Multiple states can be defined by bitwise Or-ing individual state codes
+ * together:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int buttonState = FSButton.Up | FSButton.Over;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The purpose of the layer attribute is to define the order in which shapes are
+ * displayed for a given button state. This is analogous to the layer number in
+ * the Flash Player's display list - specified using objects such as
+ * FSPlaceObject. When a button is displayed it is placed on a single layer in
+ * the display list and the layer numbers assigned to shapes in a FSButton
+ * object do not interfere with shapes assigned to the same layer in the display
+ * list.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The coordinate transform is used to change the appearance of the button
+ * without changing the original shape definitions. If it is omitted then a
+ * unity transform will be encoded which does not change the way the shape is
+ * drawn.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButton class represents the ButtonRecord structure from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ * 
  */
 public class FSButton extends FSTransformObject
 {
-    /** Code for the button in the up state. */
-    public static final int Up = 1;
-    /** Code for the state of the button when the mouse is over the active area. */
-    public static final int Over = 2;
-    /** Code for the state of the button when the mouse is clicked the active area. */
-    public static final int Down = 4;
-    /** Code for the active area of the button. */
-    public static final int Active = 8;
+	/** Code for the button in the up state. */
+	public static final int Up = 1;
 
-    private int state = 0;
-    private int identifier = 0;
-    private int layer = 0;
+	/** Code for the state of the button when the mouse is over the active area. */
+	public static final int Over = 2;
 
-    private FSCoordTransform transform = null;
-    private FSColorTransform colorTransform = null;
+	/**
+	 * Code for the state of the button when the mouse is clicked the active
+	 * area.
+	 */
+	public static final int Down = 4;
 
-    /**
-     * Construct an FSButton object, initalizing it with values decoded from
-     * an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButton(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**  Constructs an FSButton object without a coordinate or colour transform that will be applied to the shape drawn for the button states. The transforms default to unity transforms which do not change the location of colour of the shape for the button.
+	/** Code for the active area of the button. */
+	public static final int Active = 8;
 
-        @param aState the state of the button when the shape is drawn.
-        @param anIdentifier the identifier of an FSDefineShape, FSDefineShape2 or FSDefineShape3 object.
-        @param aLayer the layer in the display list on which the shape is drawn.
-        */
-    public FSButton(int aState, int anIdentifier, int aLayer)
-    {
-        setState(aState);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(0,0));
-        setColorTransform(new FSColorTransform());
-    }
+	private int state = 0;
 
-    /**  Constructs an FSButton object with a coordinate transform that will be applied to the shape drawn for the button states.
+	private int identifier = 0;
 
-        @param aState the state of the button when the shape is drawn.
-        @param anIdentifier the identifier of an FSDefineShape, FSDefineShape2 or FSDefineShape3 object.
-        @param aLayer the layer in the display list on which the shape is drawn.
-        @param aTransform an FSCoordTransform object that changes the appearance of the shape when it is drawn.
-        */
-    public FSButton(int aState, int anIdentifier, int aLayer, FSCoordTransform aTransform)
-    {
-        setState(aState);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(new FSColorTransform());
-    }
+	private int layer = 0;
 
-    /**  Constructs an FSButton object with a coordinate and colour transform that will be applied to the shape drawn for the button states.
+	private FSCoordTransform transform = null;
 
-        @param aState the state of the button when the shape is drawn.
-        @param anIdentifier the identifier of an FSDefineShape, FSDefineShape2 or FSDefineShape3 object.
-        @param aLayer the layer in the display list on which the shape is drawn.
-        @param aTransform an FSCoordTransform object that changes the appearance of the shape when it is drawn.
-        @param aColorTransform an FSColorTransform object that changes the colour of the shape when it is drawn.
-        */
-    public FSButton(int aState, int anIdentifier, int aLayer, FSCoordTransform aTransform, FSColorTransform aColorTransform)
-    {
-        setState(aState);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(aColorTransform);
-    }
-    /**
-     * Constructs an FSButton object by copying values from an existing object.
-     *
-     * @param obj an FSButton object.
-     */
-    public FSButton(FSButton obj)
-    {
-        state = obj.state;
-        identifier = obj.identifier;
-        layer = obj.layer;
-        transform = new FSCoordTransform(obj.transform);
+	private FSColorTransform colorTransform = null;
 
-        if (obj.colorTransform != null)
-            colorTransform = new FSColorTransform(obj.colorTransform);
-    }
+	/**
+	 * Construct an FSButton object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButton(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    /** Get the state(s) of the button when the shape is drawn.
+	/**
+	 * Constructs an FSButton object without a coordinate or colour transform
+	 * that will be applied to the shape drawn for the button states. The
+	 * transforms default to unity transforms which do not change the location
+	 * of colour of the shape for the button.
+	 * 
+	 * @param aState
+	 *            the state of the button when the shape is drawn.
+	 * @param anIdentifier
+	 *            the identifier of an FSDefineShape, FSDefineShape2 or
+	 *            FSDefineShape3 object.
+	 * @param aLayer
+	 *            the layer in the display list on which the shape is drawn.
+	 */
+	public FSButton(int aState, int anIdentifier, int aLayer)
+	{
+		setState(aState);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(0, 0));
+		setColorTransform(new FSColorTransform());
+	}
 
-        @return the state of the button when the shape is drawn.
-        */
-    public int getState() { return state; }
+	/**
+	 * Constructs an FSButton object with a coordinate transform that will be
+	 * applied to the shape drawn for the button states.
+	 * 
+	 * @param aState
+	 *            the state of the button when the shape is drawn.
+	 * @param anIdentifier
+	 *            the identifier of an FSDefineShape, FSDefineShape2 or
+	 *            FSDefineShape3 object.
+	 * @param aLayer
+	 *            the layer in the display list on which the shape is drawn.
+	 * @param aTransform
+	 *            an FSCoordTransform object that changes the appearance of the
+	 *            shape when it is drawn.
+	 */
+	public FSButton(int aState, int anIdentifier, int aLayer,
+					FSCoordTransform aTransform)
+	{
+		setState(aState);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(new FSColorTransform());
+	}
 
-    /** Does the Button Record defines a shape for the button's active area.
+	/**
+	 * Constructs an FSButton object with a coordinate and colour transform that
+	 * will be applied to the shape drawn for the button states.
+	 * 
+	 * @param aState
+	 *            the state of the button when the shape is drawn.
+	 * @param anIdentifier
+	 *            the identifier of an FSDefineShape, FSDefineShape2 or
+	 *            FSDefineShape3 object.
+	 * @param aLayer
+	 *            the layer in the display list on which the shape is drawn.
+	 * @param aTransform
+	 *            an FSCoordTransform object that changes the appearance of the
+	 *            shape when it is drawn.
+	 * @param aColorTransform
+	 *            an FSColorTransform object that changes the colour of the
+	 *            shape when it is drawn.
+	 */
+	public FSButton(int aState, int anIdentifier, int aLayer,
+					FSCoordTransform aTransform,
+					FSColorTransform aColorTransform)
+	{
+		setState(aState);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(aColorTransform);
+	}
 
-        @return a boolean flag indicating whether the button record defines the button's active area.
-        */
-    public boolean isActive() { return ((state &amp; Active) != 0) ? true : false; }
+	/**
+	 * Constructs an FSButton object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSButton object.
+	 */
+	public FSButton(FSButton obj)
+	{
+		state = obj.state;
+		identifier = obj.identifier;
+		layer = obj.layer;
+		transform = new FSCoordTransform(obj.transform);
 
-    /** Does the Button Record define a shape for the button's 'down' state.
+		if (obj.colorTransform != null)
+			colorTransform = new FSColorTransform(obj.colorTransform);
+	}
 
-        @return a boolean flag indicating whether the button record defines the shape for the button's 'down' state.
-        */
-    public boolean isDown() { return ((state &amp; Down) != 0) ? true : false; }
+	/**
+	 * Get the state(s) of the button when the shape is drawn.
+	 * 
+	 * @return the state of the button when the shape is drawn.
+	 */
+	public int getState()
+	{
+		return state;
+	}
 
-    /** Does the Button Record define a shape for the button's 'over' state.
+	/**
+	 * Does the Button Record defines a shape for the button's active area.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         button's active area.
+	 */
+	public boolean isActive()
+	{
+		return ((state &amp; Active) != 0) ? true : false;
+	}
 
-        @return a boolean flag indicating whether the button record defines the shape for the button's 'over' state.
-        */
-    public boolean isOver() { return ((state &amp; Over) != 0) ? true : false; }
+	/**
+	 * Does the Button Record define a shape for the button's 'down' state.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         shape for the button's 'down' state.
+	 */
+	public boolean isDown()
+	{
+		return ((state &amp; Down) != 0) ? true : false;
+	}
 
-    /** Does the Button Record define a shape for the button's 'up' state.
+	/**
+	 * Does the Button Record define a shape for the button's 'over' state.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         shape for the button's 'over' state.
+	 */
+	public boolean isOver()
+	{
+		return ((state &amp; Over) != 0) ? true : false;
+	}
 
-        @return a boolean flag indicating whether the button record defines the shape for the button's 'up' state.
-        */
-    public boolean isUp() { return ((state &amp; Up) != 0) ? true : false; }
+	/**
+	 * Does the Button Record define a shape for the button's 'up' state.
+	 * 
+	 * @return a boolean flag indicating whether the button record defines the
+	 *         shape for the button's 'up' state.
+	 */
+	public boolean isUp()
+	{
+		return ((state &amp; Up) != 0) ? true : false;
+	}
 
-    /** Gets the identifier of the shape that this FSButton applies to.
+	/**
+	 * Gets the identifier of the shape that this FSButton applies to.
+	 * 
+	 * @return the identifier of the shape.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-        @return the identifier of the shape.
-        */
-    public int getIdentifier() { return identifier; }
+	/**
+	 * Gets the layer that the button will be displayed on.
+	 * 
+	 * @return the layer on which the shape is displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-    /** Gets the layer that the button will be displayed on.
+	/**
+	 * Gets the coordinate transform that will be applied to the button.
+	 * 
+	 * @return the coordinate transform that is applied to the shape.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-        @return the layer on which the shape is displayed.
-        */
-    public int getLayer() { return layer; }
+	/**
+	 * Gets the colour transform that will be applied to the button.
+	 * 
+	 * @return the colour transform that is applied to the shape.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-    /** Gets the coordinate transform that will be applied to the button.
+	/**
+	 * Set the state(s) of the button when the shape is drawn. The shape may be
+	 * drawn for more than one state. Multiple states can be defined by
+	 * bitwise-OR'ing individual states together, e.g. Up | Over.
+	 * 
+	 * @param aNumber
+	 *            the state of the button when the shape is drawn.
+	 */
+	public void setState(int aNumber)
+	{
+		state = aNumber;
+	}
 
-        @return the coordinate transform that is applied to the shape.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+	/**
+	 * Sets the identifier of the FSDefineShape, FSDefineShape2 or
+	 * FSDefineShape3 object that defines the appearance of the button when it
+	 * is in the specified state(s).
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the shape object that defines the shape's
+	 *            appearance.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /** Gets the colour transform that will be applied to the button.
+	/**
+	 * Sets the layer in the display list that the shape will be displayed on.
+	 * 
+	 * @param aNumber
+	 *            the number of the layer in the display list where the shape is
+	 *            drawn.
+	 */
+	public void setLayer(int aNumber)
+	{
+		layer = aNumber;
+	}
 
-        @return the colour transform that is applied to the shape.
-        */
-    public FSColorTransform getColorTransform() { return colorTransform; }
+	/**
+	 * Sets the coordinate transform that will be applied to the shape to change
+	 * it's appearance.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the shape.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-    /** Set the state(s) of the button when the shape is drawn. The shape may be drawn for more than one state. Multiple states can be defined by bitwise-OR'ing individual states together, e.g.  Up | Over.
+	/**
+	 * Sets the colour transform that will be applied to the shape to change
+	 * it's colour.
+	 * 
+	 * @param aTransform
+	 *            an FSColorTransform object that will be applied to the shape.
+	 */
+	public void setColorTransform(FSColorTransform aTransform)
+	{
+		colorTransform = aTransform;
+	}
 
-        @param aNumber the state of the button when the shape is drawn.
-        */
-    public void setState(int aNumber) { state = aNumber; }
+	public Object clone()
+	{
+		FSButton anObject = (FSButton) super.clone();
 
-    /** Sets the identifier of the  FSDefineShape, FSDefineShape2 or FSDefineShape3 object that defines the appearance of the button when it is in the specified state(s).
+		anObject = (FSButton) super.clone();
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-        @param anIdentifier the identifier of the shape object that defines the shape's appearance.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		return anObject;
+	}
 
-    /** Sets the layer in the display list that the shape will be displayed on.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aNumber the number of the layer in the display list where the shape is drawn.
-        */
-    public void setLayer(int aNumber)
-    {
-        layer = aNumber;
-    }
+		if (super.equals(anObject))
+		{
+			FSButton typedObject = (FSButton) anObject;
 
-    /** Sets the coordinate transform that will be applied to the shape to change it's appearance.
+			result = state == typedObject.state;
+			result = result &amp;&amp; identifier == typedObject.identifier;
+			result = result &amp;&amp; layer == typedObject.layer;
 
-        @param aTransform an FSCoordTransform object that will be applied to the shape.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-    /** Sets the colour transform that will be applied to the shape to change it's colour.
+			if (colorTransform != null)
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
+			else
+				result = result &amp;&amp; colorTransform == typedObject.colorTransform;
+		}
+		return result;
+	}
 
-        @param aTransform an FSColorTransform object that will be applied to the shape.
-        */
-    public void setColorTransform(FSColorTransform aTransform)
-    {
-        colorTransform = aTransform;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    public Object clone()
-    {
-        FSButton anObject = (FSButton)super.clone();
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;state&quot;, state);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;layer&quot;, layer);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        anObject = (FSButton)super.clone();
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
+	public int length(FSCoder coder)
+	{
+		int length = 0;
 
-        return anObject;
-    }
+		length += 5;
+		length += transform.length(coder);
+		// Flash 3
+		if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
+			length += colorTransform.length(coder);
+		// End Flash 3
+		return length;
+	}
 
-    /**
-     * Returns true if anObject is equal to this one. Objects are considered
-     * equal if they would generate identical binary data when they are encoded
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+	public void encode(FSCoder coder)
+	{
+		coder.writeBits(0, 4);
+		coder.writeBits(state, 4);
+		coder.writeWord(identifier, 2);
+		coder.writeWord(layer, 2);
+		transform.encode(coder);
+		// Flash 3
+		if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
+			colorTransform.encode(coder);
+		// End Flash 3
+	}
 
-        if (super.equals(anObject))
-        {
-            FSButton typedObject = (FSButton)anObject;
+	public void decode(FSCoder coder)
+	{
+		coder.readBits(4, false);
 
-            result = state == typedObject.state;
-            result = result &amp;&amp; identifier == typedObject.identifier;
-            result = result &amp;&amp; layer == typedObject.layer;
+		state = coder.readBits(4, false);
+		identifier = coder.readWord(2, false);
+		layer = coder.readWord(2, false);
 
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
-
-            if (colorTransform != null)
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-            else
-                result = result &amp;&amp; colorTransform == typedObject.colorTransform;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;state&quot;, state);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 0;
-
-        length += 5;
-        length += transform.length(coder);
-// Flash 3
-         if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
-            length += colorTransform.length(coder);
-// End Flash 3
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        coder.writeBits(0, 4);
-        coder.writeBits(state, 4);
-        coder.writeWord(identifier, 2);
-        coder.writeWord(layer, 2);
-        transform.encode(coder);
-// Flash 3
-        if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
-            colorTransform.encode(coder);
-// End Flash 3
-    }
-
-    public void decode(FSCoder coder)
-    {
-        coder.readBits(4, false);
-
-        state = coder.readBits(4, false);
-        identifier = coder.readWord(2, false);
-        layer = coder.readWord(2, false);
-
-        transform = new FSCoordTransform(coder);
-// Flash 3
-        if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
-            colorTransform = new FSColorTransform(coder);
-// End Flash 3
-    }
+		transform = new FSCoordTransform(coder);
+		// Flash 3
+		if (coder.context[FSCoder.Type] == FSMovieObject.DefineButton2)
+			colorTransform = new FSColorTransform(coder);
+		// End Flash 3
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSButtonColorTransform.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonColorTransform.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSButtonColorTransform.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,173 +31,215 @@
 package com.flagstone.transform;
 
 /**
-FSButtonColorTransform defines the colour transform that is applied to each shape 
-that is used to draw a button.
- 
-&lt;p&gt;This class is only used in conjunction with FSDefineButton. FSDefineButton2 allows colour transforms to be specified in the FSButtonRecord object that identifies each shape that is displayed for a given button state.&lt;/p&gt;
+ * FSButtonColorTransform defines the colour transform that is applied to each
+ * shape that is used to draw a button.
+ * 
+ * &lt;p&gt;
+ * This class is only used in conjunction with FSDefineButton. FSDefineButton2
+ * allows colour transforms to be specified in the FSButtonRecord object that
+ * identifies each shape that is displayed for a given button state.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;the identifier for the FSDefineButton or FSDefineButton2 object that
+ * defines the appearance and behaviour of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;An FSColorTransform object that describes how the colours are changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButtonColorTransform class represents the DefineButtonCXForm structure
+ * from the Macromedia Flash (SWF) File Format Specification. It was introduced
+ * in Flash 2.
+ * &lt;/p&gt;
+ */
+public class FSButtonColorTransform extends FSMovieObject
+{
+	private int identifier = 0;
+	private FSColorTransform colorTransform = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSButtonColorTransform object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButtonColorTransform(FSCoder coder)
+	{
+		super(ButtonColorTransform);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonColorTransform object with a colour transform for
+	 * the specified button.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a button that this FSButtonColorTransform
+	 *            applies to.
+	 * @param aColorTransform
+	 *            an FSColorTransform object that will be applied to the button.
+	 */
+	public FSButtonColorTransform(int anIdentifier,
+									FSColorTransform aColorTransform)
+	{
+		super(ButtonColorTransform);
+		setIdentifier(anIdentifier);
+		setColorTransform(aColorTransform);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonColorTransform_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonColorTransform object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSButtonColorTransform object.
+	 */
+	public FSButtonColorTransform(FSButtonColorTransform obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonColorTransform_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;the identifier for the FSDefineButton or FSDefineButton2 object that defines the appearance and behaviour of a button.&lt;/td&gt;
-&lt;/tr&gt;
+		identifier = obj.identifier;
+		colorTransform = new FSColorTransform(obj.colorTransform);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonColorTransform_2&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColorTransform object that describes how the colours are changed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the button that this FSButtonColorTransform object
+	 * applies to.
+	 * 
+	 * @return the identifier of the button that the transform will be applied
+	 *         to.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the colour transform that will be applied to the FSDefineButton
+	 * object.
+	 * 
+	 * @return the colour transform that will be applied to the button.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the identifier of the button that the transform applies to.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the FSDefineButton object that the transform
+	 *            will be applied to.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;p&gt;The FSButtonColorTransform class represents the DefineButtonCXForm structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSButtonColorTransform extends FSMovieObject
-{
-    private int identifier = 0;
-    private FSColorTransform colorTransform = null;
+	/**
+	 * Sets the colour transform.
+	 * 
+	 * @param aTransform
+	 *            the colour transform object that will be applied to the
+	 *            button.
+	 */
+	public void setColorTransform(FSColorTransform aTransform)
+	{
+		colorTransform = aTransform;
+	}
 
-    /**
-     * Construct an FSButtonColorTransform object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButtonColorTransform(FSCoder coder)
-    {
-        super(ButtonColorTransform);
-        decode(coder);
-    }
+	public Object clone()
+	{
+		FSButtonColorTransform anObject = (FSButtonColorTransform) super
+						.clone();
 
-    /** Constructs an FSButtonColorTransform object with a colour transform for the specified button.
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-        @param anIdentifier    the identifier of a button that this FSButtonColorTransform applies to.
-        @param aColorTransform an FSColorTransform object that will be applied to the button.
-        */
-    public FSButtonColorTransform(int anIdentifier, FSColorTransform aColorTransform)
-    {
-        super(ButtonColorTransform);
-        setIdentifier(anIdentifier);
-        setColorTransform(aColorTransform);
-    }
-    /**
-     * Constructs an FSButtonColorTransform object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSButtonColorTransform object.
-     */
-    public FSButtonColorTransform(FSButtonColorTransform obj)
-    {
-        super(obj);
-        
-        identifier = obj.identifier;
-        colorTransform = new FSColorTransform(obj.colorTransform);
-    }
+		return anObject;
+	}
 
-    /** Gets the identifier of the button that this FSButtonColorTransform object applies to. 
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the identifier of the button that the transform will be applied to.
-        */
-    public int getIdentifier() { return identifier; }
+		if (super.equals(anObject))
+		{
+			FSButtonColorTransform typedObject = (FSButtonColorTransform) anObject;
 
-    /** Gets the colour transform that will be applied to the FSDefineButton object.
+			result = identifier == typedObject.identifier;
 
-        @return the colour transform that will be applied to the button.
-        */ 
-    public FSColorTransform getColorTransform() { return colorTransform; }
+			if (colorTransform == null)
+				result = result &amp;&amp; (typedObject.colorTransform == null);
+			else
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
+		}
+		return result;
+	}
 
-    /** Sets the identifier of the button that the transform applies to.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param anIdentifier the identifier of the FSDefineButton object that the transform will be applied to.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
+			buffer.append(&quot;};&quot;);
+		}
+	}
 
-    /** Sets the colour transform.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param aTransform the colour transform object that will be applied to the button.
-        */ 
-    public void setColorTransform(FSColorTransform aTransform)
-    {
-        colorTransform = aTransform;
-    }
+		length += 2;
+		length += colorTransform.length(coder);
 
-    public Object clone()
-    {
-        FSButtonColorTransform anObject = (FSButtonColorTransform)super.clone();
-        
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
-        
-        return anObject;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSButtonColorTransform typedObject = (FSButtonColorTransform)anObject;
-            
-            result = identifier == typedObject.identifier;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-            if (colorTransform == null)
-                result = result &amp;&amp; (typedObject.colorTransform == null);
-            else
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-        }
-        return result;
-    }
+		coder.writeWord(identifier, 2);
+		colorTransform.encode(coder);
+		coder.endObject(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            buffer.append(&quot;};&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        length += colorTransform.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        colorTransform.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        colorTransform = new FSColorTransform(coder);
-        coder.endObject(name());
-    }
+		identifier = coder.readWord(2, false);
+		colorTransform = new FSColorTransform(coder);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSButtonEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonEvent.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSButtonEvent.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,455 +30,702 @@
 
 package com.flagstone.transform;
 
-import java.util.*;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
 
-/** 
-FSButtonEvent is used to define the actions that a button will execute in response 
-to a particular event.
- 
-&lt;p&gt;The events that a button responds to are:&lt;/p&gt;
+/**
+ * FSButtonEvent is used to define the actions that a button will execute in
+ * response to a particular event.
+ * 
+ * &lt;p&gt;
+ * The events that a button responds to are:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves over the active area of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves out of the active area of a button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Press&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is over
+ * the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Release&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and released while the mouse
+ * cursor is over the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * out of the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged
+ * into the active area of the button and the mouse button is released.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * When a button is configured as a menu item (FSDefineButton2 objects only)
+ * then three additional events can occur:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MenuDragOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * into the active area of the menu item.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MenuDragOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * out of the active area of the menu item.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;ReleaseOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * into the active area of the menu item.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In addition to responding to mouse events, buttons also respond to keys being
+ * pressed on the keyboard. Keyboard events are defined by the character key
+ * being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;, etc. For control keys a number of reserved
+ * names are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Left&gt;&lt;/td&gt;
+ * &lt;td&gt;Left arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Right&gt;&lt;/td&gt;
+ * &lt;td&gt;Right arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Home&gt;&lt;/td&gt;
+ * &lt;td&gt;Home key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;End&gt;&lt;/td&gt;
+ * &lt;td&gt;End key&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Insert&gt;&lt;/td&gt;
+ * &lt;td&gt;Insert key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Delete&gt;&lt;/td&gt;
+ * &lt;td&gt;Delete key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Backspace&gt;&lt;/td&gt;
+ * &lt;td&gt;Backspace key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Enter&gt;&lt;/td&gt;
+ * &lt;td&gt;Enter (return) key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Up&gt;&lt;/td&gt;
+ * &lt;td&gt;Up arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Down&gt;&lt;/td&gt;
+ * &lt;td&gt;Down arrow key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Pageup&gt;&lt;/td&gt;
+ * &lt;td&gt;Page up key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Pagedown&gt;&lt;/td&gt;
+ * &lt;td&gt;Page down key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Tab&gt;&lt;/td&gt;
+ * &lt;td&gt;Tab key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Escape&gt;&lt;/td&gt;
+ * &lt;td&gt;Escape key.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;Space&gt;&lt;/td&gt;
+ * &lt;td&gt;Space bar.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Since the event code allows multiple events, the code for compound events can
+ * be created by performing a bit-wise Or of the individual codes:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  int eventCode = FSButtonEvent.RollOver | FSButtonEvent.Press;&quot;;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The class method &lt;b&gt;codeForKey&lt;/b&gt; returns the event code that identifies
+ * when a specific key is pressed:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int eventCode = FSButtonEvent.codeForKey('J');
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Control keys are identified using one of the reserved ButtonEvent values:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int eventCode = FSButtonEvent.Enter | FSButtonEvent.PageUp;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * However while multiple mouse events can be defined for a button only one
+ * keyboard event can be defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;event&lt;/td&gt;
+ * &lt;td&gt;a code identifying the different types of button events that the actions
+ * defined in this object will be executed in response to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of action objects that are executed when the events defined in
+ * the event code occur.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButtonEvent class represents the ButtonCondAction data structure from
+ * the Macromedia Flash (SWF) File Format Specification. It was introduced in
+ * Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSButtonEvent extends FSTransformObject
+{
+	/**
+	 * Defines the button event that occurs when the mouse cursor moves over the
+	 * active area of a button.
+	 */
+	public static final int RollOver = 1;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;RollOver&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves over the active area of a button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;RollOut&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves out of the active area of a button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Press&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is over the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Release&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and released while the mouse cursor is over the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOut&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged out of the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOver&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged into the active area of the button and the mouse button is released.&lt;/td&gt;&lt;/tr&gt;
-&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the mouse cursor moves out of
+	 * the active area of a button.
+	 */
+	public static final int RollOut = 2;
 
-&lt;p&gt;When a button is configured as a menu item (FSDefineButton2 objects only) then three additional events can occur:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked
+	 * while the mouse cursor is over the active area of the button.
+	 */
+	public static final int Press = 4;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;MenuDragOver&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the menu item.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MenuDragOut&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse
-cursor is dragged out of the active area of the menu item.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;ReleaseOut&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the menu item.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * released while the mouse cursor is over the active area of the button.
+	 */
+	public static final int Release = 8;
 
-&lt;p&gt;In addition to responding to mouse events, buttons also respond to keys being pressed on the keyboard. Keyboard events are defined by the character key being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;, etc. For control keys a number of reserved names are supported:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged out of the active area of the button.
+	 */
+	public static final int DragOut = 16;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Left&gt;&lt;/td&gt;&lt;td&gt;Left arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Right&gt;&lt;/td&gt;&lt;td&gt;Right arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Home&gt;&lt;/td&gt;&lt;td&gt;Home key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;End&gt;&lt;/td&gt;&lt;td&gt;End key&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Insert&gt;&lt;/td&gt;&lt;td&gt;Insert key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Delete&gt;&lt;/td&gt;&lt;td&gt;Delete key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Backspace&gt;&lt;/td&gt;&lt;td&gt;Backspace key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Enter&gt;&lt;/td&gt;&lt;td&gt;Enter (return) key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Up&gt;&lt;/td&gt;&lt;td&gt;Up arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Down&gt;&lt;/td&gt;&lt;td&gt;Down arrow key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Pageup&gt;&lt;/td&gt;&lt;td&gt;Page up key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Pagedown&gt;&lt;/td&gt;&lt;td&gt;Page down key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Tab&gt;&lt;/td&gt;&lt;td&gt;Tab key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Escape&gt;&lt;/td&gt;&lt;td&gt;Escape key.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;Space&gt;&lt;/td&gt;&lt;td&gt;Space bar.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged into the active area of the button.
+	 */
+	public static final int DragOver = 32;
 
-&lt;p&gt;Since the event code allows multiple events, the code for compound events can be created by performing a bit-wise Or of the individual codes:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked,
+	 * the mouse cursor is dragged into the active area of the button and the
+	 * mouse button is released.
+	 */
+	public static final int ReleaseOut = 64;
 
-&lt;pre&gt;
-int eventCode = FSButtonEvent.RollOver | FSButtonEvent.Press;&quot;;
-&lt;/pre&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged into the active area of the menu item.
+	 */
+	public static final int MenuDragOver = 128;
 
-&lt;p&gt;The class method &lt;b&gt;codeForKey&lt;/b&gt; returns the event code that identifies when a specific key is pressed:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the mouse button is clicked and
+	 * the mouse cursor is dragged out of the active area of the menu item.
+	 */
+	public static final int MenuDragOut = 256;
 
-&lt;pre&gt;
-int eventCode = FSButtonEvent.codeForKey('J');
-&lt;/pre&gt;
+	/**
+	 * Defines the button event that occurs when the left arrow key is pressed
+	 * on the keyboard.
+	 */
+	public static final int Left = 512;
 
-&lt;p&gt;Control keys are identified using one of the reserved ButtonEvent values:&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the right arrow key is pressed
+	 * on the keyboard.
+	 */
+	public static final int Right = 1024;
 
-&lt;pre&gt;
-int eventCode = FSButtonEvent.Enter | FSButtonEvent.PageUp;
-&lt;/pre&gt;
+	/**
+	 * Defines the button event that occurs when the home key is pressed on the
+	 * keyboard.
+	 */
+	public static final int Home = 1536;
 
-&lt;p&gt;However while multiple mouse events can be defined for a button only one keyboard event can be defined.&lt;/p&gt;
+	/**
+	 * Defines the button event that occurs when the end key is pressed on the
+	 * keyboard.
+	 */
+	public static final int End = 2048;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Defines the button event that occurs when the insert key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Insert = 2560;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Defines the button event that occurs when the delete key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Delete = 3072;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonEvent_0&quot;&gt;event&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;a code identifying the different types of button events that the actions defined in this object will be executed in response to.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Defines the button event that occurs when the backspace key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Backspace = 4096;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSButtonEvent_1&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of action objects that are executed when the events defined in the event code occur.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Defines the button event that occurs when the enter key is pressed on the
+	 * keyboard.
+	 */
+	public static final int Enter = 6656;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSButtonEvent_2&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded actions are typically generated by the parser in the Translate framework. The actions array and encodedActions cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/table&gt;
+	/**
+	 * Defines the button event that occurs when the up arrow key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Up = 7168;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Defines the button event that occurs when the down arrow key is pressed
+	 * on the keyboard.
+	 */
+	public static final int Down = 7680;
 
-&lt;p&gt;The FSButtonEvent class represents the ButtonCondAction data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt; */  
-public class FSButtonEvent extends FSTransformObject
-{
-    /** Defines the button event that occurs when the mouse cursor moves over the active area of a button. */
-    public static final int RollOver = 1;
-    /** Defines the button event that occurs when the mouse cursor moves out of the active area of a button. */
-    public static final int RollOut = 2;
-    /** Defines the button event that occurs when the mouse button is clicked while the mouse cursor is over the active area of the button. */
-    public static final int Press = 4;
-    /** Defines the button event that occurs when the mouse button is clicked and released while the mouse cursor is over the active area of the button. */
-    public static final int Release = 8;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged out of the active area of the button. */
-    public static final int DragOut = 16;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the button. */
-    public static final int DragOver = 32;
-    /** Defines the button event that occurs when the mouse button is clicked, the mouse cursor is dragged into the active area of the button and the mouse button is released. */
-    public static final int ReleaseOut = 64;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged into the active area of the menu item. */
-    public static final int MenuDragOver = 128;
-    /** Defines the button event that occurs when the mouse button is clicked and the mouse cursor is dragged out of the active area of the menu item. */
-    public static final int MenuDragOut = 256;
+	/**
+	 * Defines the button event that occurs when the page up key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Pageup = 8192;
 
-    /** Defines the button event that occurs when the left arrow key is pressed on the keyboard. */
-    public static final int Left = 512;
-    /** Defines the button event that occurs when the right arrow key is pressed on the keyboard. */
-    public static final int Right = 1024;
-    /** Defines the button event that occurs when the home key is pressed on the keyboard. */
-    public static final int Home = 1536;
-    /** Defines the button event that occurs when the end key is pressed on the keyboard. */
-    public static final int End = 2048;
-    /** Defines the button event that occurs when the insert key is pressed on the keyboard. */
-    public static final int Insert = 2560;
-    /** Defines the button event that occurs when the delete key is pressed on the keyboard. */
-    public static final int Delete = 3072;
-    /** Defines the button event that occurs when the backspace key is pressed on the keyboard. */
-    public static final int Backspace = 4096;
-    /** Defines the button event that occurs when the enter key is pressed on the keyboard. */
-    public static final int Enter = 6656;
-    /** Defines the button event that occurs when the up arrow key is pressed on the keyboard. */
-    public static final int Up = 7168;
-    /** Defines the button event that occurs when the down arrow key is pressed on the keyboard. */
-    public static final int Down = 7680;
-    /** Defines the button event that occurs when the page up key is pressed on the keyboard. */
-    public static final int Pageup = 8192;
-    /** Defines the button event that occurs when the page down key is pressed on the keyboard. */
-    public static final int Pagedown = 8704;
-    /** Defines the button event that occurs when the tab key is pressed on the keyboard. */
-    public static final int Tab = 9216;
-    /** Defines the button event that occurs when the escape key is pressed on the keyboard. */
-    public static final int Escape = 9728;
-    /** Defines the button event that occurs when the space bar is pressed on the keyboard. */
-    public static final int Space = 16384;
+	/**
+	 * Defines the button event that occurs when the page down key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Pagedown = 8704;
 
-    /** Generates the code identifying a particular event using the name of the event.
+	/**
+	 * Defines the button event that occurs when the tab key is pressed on the
+	 * keyboard.
+	 */
+	public static final int Tab = 9216;
 
-        @param c a keyboard character.
-        @return the event code corresponding to the specified event.
-        */
-    public static int codeForKey(char c)
-    {
-        return c &lt;&lt; 9;
-    }
+	/**
+	 * Defines the button event that occurs when the escape key is pressed on
+	 * the keyboard.
+	 */
+	public static final int Escape = 9728;
 
-    private int event = 0;
-    private int length = 0;
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-   
-    /**
-     * Construct an FSButtonEvent object, initializing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButtonEvent(FSCoder coder, int len)
-    {
-        length = len-2;
-        decode(coder);
-    }
-    /** Constructs an FSButtonEvent object that defines the array of actions that will be executed when a particular event occurs.
+	/**
+	 * Defines the button event that occurs when the space bar is pressed on the
+	 * keyboard.
+	 */
+	public static final int Space = 16384;
 
-        @param aNumber the event code.
-        @param anArray the array of action objects that will be executed when the specified event(s) occur.
-        */
-    public FSButtonEvent(int aNumber, ArrayList anArray)
-    {
-        setEvent(aNumber);
-        setActions(anArray);
-    }
-    /** 
-     * Constructs an FSButtonEvent object that defines the array of actions that 
-     * will be executed when a particular event occurs.
-     * 
-     * @param aNumber the event code.
-     * @param bytes an array of encoded action objects.
-     */
-    public FSButtonEvent(int aNumber, byte[] bytes)
-    {
-        setEvent(aNumber);
-        setEncodedActions(bytes);
-    }
-    /**
-     * Constructs an FSButtonEvent object by copying values from an existing object.
-     *
-     * @param obj an FSButtonEvent object.
-     */
-    public FSButtonEvent(FSButtonEvent obj)
-    {
-        event = obj.event;
-        
-        if (obj.actions != null)
-        {
-            actions = new ArrayList();
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }
+	/**
+	 * Generates the code identifying a particular event using the name of the
+	 * event.
+	 * 
+	 * @param c
+	 *            a keyboard character.
+	 * @return the event code corresponding to the specified event.
+	 */
+	public static int codeForKey(char c)
+	{
+		return c &lt;&lt; 9;
+	}
 
+	private int event = 0;
+	private byte[] encodedActions = null;
 
-    /** Add an action to the end of the actions array.
-        
-        @param anAction an object derived from the base class FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+	private int length = 0;
+	private ArrayList actions = null;
 
-    /** Gets the event code that this FSButtonEvent defines actions for.
+	/**
+	 * Construct an FSButtonEvent object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButtonEvent(FSCoder coder, int len)
+	{
+		length = len - 2;
+		decode(coder);
+	}
 
-        @return the compound event code.
-        */
-    public int getEvent()
-    {
-        return event;
-    }
+	/**
+	 * Constructs an FSButtonEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param aNumber
+	 *            the event code.
+	 * @param anArray
+	 *            the array of action objects that will be executed when the
+	 *            specified event(s) occur.
+	 */
+	public FSButtonEvent(int aNumber, ArrayList anArray)
+	{
+		setEvent(aNumber);
+		setActions(anArray);
+	}
 
-    /** Gets the array of actions that are executed by the button in response to specified event(s).
+	/**
+	 * Constructs an FSButtonEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param aNumber
+	 *            the event code.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSButtonEvent(int aNumber, byte[] bytes)
+	{
+		setEvent(aNumber);
+		setEncodedActions(bytes);
+	}
 
-        @return the array of action objects that will be executed when the specified event(s) occur.
-        */   
-    public ArrayList getActions()
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+	/**
+	 * Constructs an FSButtonEvent object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSButtonEvent object.
+	 */
+	public FSButtonEvent(FSButtonEvent obj)
+	{
+		event = obj.event;
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** Sets the event code that this FSButtonEvent defines actions for.
+		if (obj.actions != null)
+		{
+			actions = new ArrayList();
 
-        @param aNumber the event code.
-        */
-    public void setEvent(int aNumber)
-    {
-        event = aNumber;
-    }
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-    /** Sets the array of actions that are executed by the button in response to specified event(s).
+	/**
+	 * Add an action to the end of the actions array.
+	 * 
+	 * @param anAction
+	 *            an object derived from the base class FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-        @param anArray the array of action objects that will be executed when the specified event(s) occur.
-        */  
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+	/**
+	 * Gets the event code that this FSButtonEvent defines actions for.
+	 * 
+	 * @return the compound event code.
+	 */
+	public int getEvent()
+	{
+		return event;
+	}
 
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-   }
+	/**
+	 * Gets the array of actions that are executed by the button in response to
+	 * specified event(s).
+	 * 
+	 * @return the array of action objects that will be executed when the
+	 *         specified event(s) occur.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-    public Object clone()
-    {
-        FSButtonEvent anObject = (FSButtonEvent)super.clone();
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+	/**
+	 * Sets the event code that this FSButtonEvent defines actions for.
+	 * 
+	 * @param aNumber
+	 *            the event code.
+	 */
+	public void setEvent(int aNumber)
+	{
+		event = aNumber;
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSButtonEvent typedObject = (FSButtonEvent)anObject;
-            
-            result = event == typedObject.event;                
+	/**
+	 * Sets the array of actions that are executed by the button in response to
+	 * specified event(s).
+	 * 
+	 * @param anArray
+	 *            the array of action objects that will be executed when the
+	 *            specified event(s) occur.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-            if (actions != null)
-                result = actions.equals(typedObject.actions);
-            else
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public Object clone()
+	{
+		FSButtonEvent anObject = (FSButtonEvent) super.clone();
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;event&quot;, event);
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
+		return anObject;
+	}
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    {
-        length = 2;
-    
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(event, 2);
+		if (super.equals(anObject))
+		{
+			FSButtonEvent typedObject = (FSButtonEvent) anObject;
 
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int length = action.getLength();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (length &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+			result = event == typedObject.event;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        event = coder.readWord(2, false);
-        
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
+			if (actions != null)
+				result = actions.equals(typedObject.actions);
+			else
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+		}
+		return result;
+	}
 
-            int start;
-            
-            while (length &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length];
-            coder.readBytes(encodedActions);
-        }
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;event&quot;, event);
+
+			if (actions != null)
+				Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			else
+				buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+
+			buffer.append(&quot;}&quot;);
+		}
+	}
+
+	public int length(FSCoder coder)
+	{
+		length = 2;
+
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
+
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
+
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(event, 2);
+
+		if (actions != null)
+		{
+			FSActionObject action = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int length = action.getLength();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (length &lt;&lt; 3);
+
+				action.encode(coder);
+				coder.setPointer(next);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		event = coder.readWord(2, false);
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
+
+			int start;
+
+			while (length &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSMovie.decodeAction(coder));
+				length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[length];
+			coder.readBytes(encodedActions);
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSButtonSound.java
===================================================================
--- trunk/src/com/flagstone/transform/FSButtonSound.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSButtonSound.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,281 +31,346 @@
 package com.flagstone.transform;
 
 /**
-FSButtonSound defines the sounds that are played when an event occurs in a button. 
- 
-&lt;p&gt;A sound is played for only a subset of the events that a button responds to:&lt;/p&gt;
+ * FSButtonSound defines the sounds that are played when an event occurs in a
+ * button.
+ * 
+ * &lt;p&gt;
+ * A sound is played for only a subset of the events that a button responds to:
+ * &lt;/p&gt;
+ * 
+ * &lt;table&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;rollOut&lt;/td&gt;
+ * &lt;td&gt;The cursor exits the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;rollOver&lt;/td&gt;
+ * &lt;td&gt;The cursor enters the active area of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;press&lt;/td&gt;
+ * &lt;td&gt;The mouse button is clicked and the cursor is inside the active area of
+ * the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;release&lt;/td&gt;
+ * &lt;td&gt;The mouse button is released while the cursor is inside the active area
+ * of the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;table&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;the identifier of an FSDefineButton or FSDefineButton2 object that
+ * define the button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[rollOut]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * rollOver event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[rollOver]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * rollOver event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[press]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * press event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound[release]&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that describes how the sound will be played for a
+ * release event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Important:&lt;/b&gt; If the identifier in the FSSound object for an event is
+ * set to zero then the corresponding FSSound object will not be encoded when
+ * the object is encoded to a Flash file. This compresses the object when the
+ * sounds for only a sub-set of the events are defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSButtonSound class represents the DefineButtonSound structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
+ */
+public class FSButtonSound extends FSMovieObject
+{
+	private int identifier = 0;
+	private FSSound[] sound = new FSSound[] {null, null, null, null };
 
-&lt;table&gt;
-&lt;tr&gt;&lt;td&gt;rollOut&lt;/td&gt;&lt;td&gt;The cursor exits the active area of the button.&lt;/td&gt;&lt;/tr&gt; 
-&lt;tr&gt;&lt;td&gt;rollOver&lt;/td&gt;&lt;td&gt;The cursor enters the active area of the button.&lt;/td&gt;&lt;/tr&gt; 
-&lt;tr&gt;&lt;td&gt;press&lt;/td&gt;&lt;td&gt;The mouse button is clicked and the cursor is inside the active area of the button.&lt;/td&gt;&lt;/tr&gt; 
-&lt;tr&gt;&lt;td&gt;release&lt;/td&gt;&lt;td&gt;The mouse button is released while the cursor is inside the active area of the button.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Construct an FSButtonSound object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSButtonSound(FSCoder coder)
+	{
+		super(ButtonSound);
+		decode(coder);
+	}
 
-&lt;table&gt;
+	/**
+	 * Constructs an FSButtonSound object that defines the sound played for a
+	 * single button event.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the FSDefineButton or FSDefineButton2 object
+	 *            that defines the button.
+	 * @param eventCode
+	 *            the event that identifies when the sound id played, must be
+	 *            either FSButtonEvent.rollOver, FSButtonEvent.rollOut,
+	 *            FSButtonEvent.press or FSButtonEvent.release.
+	 * @param aSound
+	 *            an FSSound object that identifies a sound and controls how it
+	 *            is played.
+	 */
+	public FSButtonSound(int anIdentifier, int eventCode, FSSound aSound)
+	{
+		super(ButtonSound);
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		setIdentifier(anIdentifier);
+		setSoundForEvent(eventCode, aSound);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSButtonSound object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSButtonSound object.
+	 */
+	public FSButtonSound(FSButtonSound obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;the identifier of an FSDefineButton or FSDefineButton2 object that define the button.&lt;/td&gt;
-&lt;/tr&gt;
+		identifier = obj.identifier;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_3&quot;&gt;sound[rollOut]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a rollOver event.&lt;/td&gt;
-&lt;/tr&gt;
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (obj.sound[i] != null)
+				sound[i] = new FSSound(obj.sound[i]);
+		}
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_2&quot;&gt;sound[rollOver]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a rollOver event.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the button that this object applies to.
+	 * 
+	 * @return the identifier of the button.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_4&quot;&gt;sound[press]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a press event.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the FSSound object for the specified event.
+	 * 
+	 * @param eventCode
+	 *            the code representing the button event, must be either
+	 *            FSButtonEvent.RollOver, FSButtonEvent.RollOut,
+	 *            FSButtonEvent.Press or FSButtonEvent.Release.
+	 * @return the FSSound that identifies and controls the sound that will be
+	 *         played for the event.
+	 */
+	public FSSound getSoundForEvent(int eventCode)
+	{
+		FSSound aSound = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSButtonSound_5&quot;&gt;sound[release]&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that describes how the sound will be played for a release event.&lt;/td&gt;
-&lt;/tr&gt;
+		if (eventCode == FSButtonEvent.RollOut)
+			aSound = sound[0];
+		else if (eventCode == FSButtonEvent.RollOver)
+			aSound = sound[1];
+		else if (eventCode == FSButtonEvent.Press)
+			aSound = sound[2];
+		else
+			aSound = sound[3];
 
-&lt;/table&gt;
+		return aSound;
+	}
 
-&lt;p&gt;&lt;b&gt;Important:&lt;/b&gt; If the identifier in the FSSound object for an event is set to zero then the corresponding FSSound object will not be encoded when the object is encoded to a Flash file. This compresses the object when the sounds for only a sub-set of the events are defined.&lt;/p&gt;
+	/**
+	 * Sets the identifier of the button that this object applies to.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the button which this object applies to.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
- &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the FSSound object for the specified button event.
+	 * 
+	 * @param eventCode
+	 *            the code representing the button event, must be either
+	 *            FSButtonEvent.RollOver, FSButtonEvent.RollOut,
+	 *            FSButtonEvent.Press or FSButtonEvent.Release.
+	 * @param aSound
+	 *            an FSSound object that identifies and controls how the sound
+	 *            is played.
+	 */
+	public void setSoundForEvent(int eventCode, FSSound aSound)
+	{
+		if (eventCode == FSButtonEvent.RollOut)
+			sound[0] = aSound;
+		else if (eventCode == FSButtonEvent.RollOver)
+			sound[1] = aSound;
+		else if (eventCode == FSButtonEvent.Press)
+			sound[2] = aSound;
+		else
+			sound[3] = aSound;
+	}
 
-&lt;p&gt;The FSButtonSound class represents the DefineButtonSound structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSButtonSound extends FSMovieObject
-{
-    private int identifier = 0;
-    private FSSound[] sound = new FSSound[] {null, null, null, null};
-    
-    /**
-     * Construct an FSButtonSound object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSButtonSound(FSCoder coder)
-    {
-        super(ButtonSound);
-        decode(coder);
-    }
-    /**  Constructs an FSButtonSound object that defines the sound played for a single button event.
+	public Object clone()
+	{
+		FSButtonSound anObject = (FSButtonSound) super.clone();
 
-        @param anIdentifier the identifier of the FSDefineButton or FSDefineButton2 object that defines the button.
-        @param eventCode the event that identifies when the sound id played, must be either FSButtonEvent.rollOver, FSButtonEvent.rollOut, FSButtonEvent.press or FSButtonEvent.release.
-        @param aSound an FSSound object that identifies a sound and controls how it is played.
-        */
-    public FSButtonSound(int anIdentifier, int eventCode, FSSound aSound)
-    {
-        super(ButtonSound);
-        
-        setIdentifier(anIdentifier);
-        setSoundForEvent(eventCode, aSound);
-    }
-    /**
-     * Constructs an FSButtonSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSButtonSound object.
-     */
-    public FSButtonSound(FSButtonSound obj)
-    {
-        super(obj);
-        
-        identifier = obj.identifier;
-        
-        for (int i=0; i&lt;4; i++)
-        {
-            if (obj.sound[i] != null)
-                sound[i] = new FSSound(obj.sound[i]);
-        }
-    }
+		for (int i = 0; i &lt; 4; i++)
+		{
+			anObject.sound[i] = (sound[i] != null) ? (FSSound) sound[i].clone()
+							: null;
+		}
 
-    /** Gets the identifier of the button that this object applies to.
+		return anObject;
+	}
 
-        @return the identifier of the button.
-        */
-    public int getIdentifier() { return identifier; }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the FSSound object for the specified event.
+		if (super.equals(anObject))
+		{
+			FSButtonSound typedObject = (FSButtonSound) anObject;
 
-        @param eventCode the code representing the button event, must be either FSButtonEvent.rollOver, FSButtonEvent.rollOut, FSButtonEvent.press or FSButtonEvent.release.
-        @return the FSSound that identifies and controls the sound that will be played for the event.
-        */
-    public FSSound getSoundForEvent(int eventCode)
-    {
-        FSSound aSound = null;
-        
-        if (eventCode == FSButtonEvent.RollOut)
-            aSound = sound[0];
-        else if (eventCode == FSButtonEvent.RollOver)
-            aSound = sound[1];
-        else if (eventCode == FSButtonEvent.Press)
-            aSound = sound[2];
-        else
-            aSound = sound[3];
-            
-        return aSound;
-    }
+			result = identifier == typedObject.identifier;
 
-    /** Sets the identifier of the button that this object applies to.
+			for (int i = 0; i &lt; 4; i++)
+			{
+				if (sound[i] != null)
+					result = result &amp;&amp; sound[i].equals(typedObject.sound[i]);
+				else
+					result = result &amp;&amp; sound[i] == typedObject.sound[i];
+			}
+		}
+		return result;
+	}
 
-        @param anIdentifier the identifier of the button which this object applies to.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the FSSound object for the specified button event. 
+		if (depth &gt; 0)
+		{
+			buffer.append(name() + &quot;: {&quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
 
-        @param eventCode the code representing the button event, must be either FSButtonEvent.rollOver, FSButtonEvent.rollOut, FSButtonEvent.press or FSButtonEvent.release.
-        @param aSound an FSSound object that identifies and controls how the sound is played.
-        */
-    public void setSoundForEvent(int eventCode, FSSound aSound)
-    {
-        if (eventCode == FSButtonEvent.RollOut)
-            sound[0] = aSound;
-        else if (eventCode == FSButtonEvent.RollOver)
-            sound[1] = aSound;
-        else if (eventCode == FSButtonEvent.Press)
-            sound[2] = aSound;
-        else
-            sound[3] = aSound;
-    }
+			if (depth - 1 &gt; 0)
+			{
+				for (int i = 0; i &lt; 4; i++)
+				{
+					buffer.append(&quot;sound[&quot; + i + &quot;] = &quot;);
 
-    public Object clone()
-    {
-        FSButtonSound anObject = (FSButtonSound)super.clone();
-                
-        for (int i=0; i&lt;4; i++)
-        {
-            anObject.sound[i] = (sound[i] != null) ? (FSSound)sound[i].clone() : null;
-        }
+					if (sound[i] != null)
+						sound[i].appendDescription(buffer, depth);
+					else
+						buffer.append(&quot;null; &quot;);
+				}
+			} else
+			{
+				for (int i = 0; i &lt; 4; i++)
+				{
+					buffer.append(&quot;sound[&quot; + i + &quot;] =&quot;);
 
-        return anObject;
-    }
+					if (sound[i] != null)
+						Transform.append(buffer, sound[i].name(), depth);
+					else
+						buffer.append(&quot;null&quot;);
+				}
+			}
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSButtonSound typedObject = (FSButtonSound)anObject;
-            
-            result = identifier == typedObject.identifier;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-            for (int i=0; i&lt;4; i++)
-            {
-                if (sound[i] != null)
-                    result = result &amp;&amp; sound[i].equals(typedObject.sound[i]);
-                else
-                    result = result &amp;&amp; sound[i] == typedObject.sound[i];
-            }
-        }
-        return result;
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		length += 2;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(name() + &quot;: {&quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
+				length += sound[i].length(coder);
+			else
+				length += 2;
+		}
 
-            if (depth-1 &gt; 0)
-            {
-                for (int i=0; i&lt;4; i++)
-                {
-                    buffer.append(&quot;sound[&quot; + i + &quot;] = &quot;);
-                
-                    if (sound[i] != null)
-                        sound[i].appendDescription(buffer, depth);
-                    else
-                        buffer.append(&quot;null; &quot;);
-                }
-            }
-            else
-            {    
-                for (int i=0; i&lt;4; i++)
-                {
-                    buffer.append(&quot;sound[&quot; + i + &quot;] =&quot;);
-                
-                    if (sound[i] != null)
-                        Transform.append(buffer, sound[i].name(), depth);
-                    else
-                        buffer.append(&quot;null&quot;);
-                }
-            }
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		return length;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 2;
-        
-        for (int i=0; i&lt;4; i++)
-        {
-            if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
-                length += sound[i].length(coder);
-            else
-                length += 2;
-        }
-        
-        return length;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
+		coder.writeWord(identifier, 2);
 
-        for (int i=0; i&lt;4; i++)
-        {
-            if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
-                sound[i].encode(coder);
-            else
-                coder.writeWord(0, 2);
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        int start = coder.getPointer();
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (sound[i] != null &amp;&amp; sound[i].getIdentifier() != 0)
+				sound[i].encode(coder);
+			else
+				coder.writeWord(0, 2);
+		}
+		coder.endObject(name());
+	}
 
-        identifier = coder.readWord(2, false);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        for (int i=0; i&lt;4; i++)
-        {
-            if (coder.scanWord(2, false) &gt; 0)
-                sound[i] = new FSSound(coder);
-            else
-                coder.readWord(2, false);
-            
-            if (((coder.getPointer() - start) &gt;&gt;&gt; 3) == length)
-                break;
-        }
-        coder.endObject(name());
-    }
+		int start = coder.getPointer();
+
+		identifier = coder.readWord(2, false);
+
+		for (int i = 0; i &lt; 4; i++)
+		{
+			if (coder.scanWord(2, false) &gt; 0)
+				sound[i] = new FSSound(coder);
+			else
+				coder.readWord(2, false);
+
+			if (((coder.getPointer() - start) &gt;&gt;&gt; 3) == length)
+				break;
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSCall.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCall.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSCall.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,101 +31,123 @@
 package com.flagstone.transform;
 
 /**
-FSCall is used to execute the actions previously assigned to a given frame with an FSDoAction object.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSCall is used to execute the actions previously assigned to a given frame
+ * with an FSDoAction object.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;type&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSCall is a stack-based action, the value for the &lt;i&gt;frame name&lt;/i&gt; or
+ * &lt;i&gt;frame number&lt;/i&gt; is retrieved from the top of the stack when it is
+ * executed.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The following code fragment show how to execute the actions associated with a
+ * given frame number from a Flash movie:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(12));
+ * actions.add(new FSCall());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Alternatively if the frame has been assigned a name using an FSFrameLabel
+ * object then the associated actions may be executed by using the name as a
+ * reference:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+ *  ...
+ *  actions.add(new FSPush(&quot;FirstFrame&quot;));
+ *  actions.add(new FSCall());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCall class represents the ActionCall action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSCall extends FSActionObject
+{
+	private static final FSCall instance = new FSCall();
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Returns a canonical FSCall object.
+	 * 
+	 * @return an object that can safely be shared among objects.
+	 */
+	public static FSCall getInstance()
+	{
+		return instance;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCall_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSCall object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSCall(FSCoder coder)
+	{
+		super(Call);
+		decode(coder);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSCall object.
+	 */
+	public FSCall()
+	{
+		super(Call);
+	}
 
-&lt;p&gt;FSCall is a stack-based action, the value for the &lt;i&gt;frame name&lt;/i&gt; or &lt;i&gt;frame number&lt;/i&gt; is retrieved from the top of the stack when it is executed.&lt;/p&gt;
+	/**
+	 * Constructs an FSCall object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSCall object.
+	 */
+	public FSCall(FSCall obj)
+	{
+		super(obj);
+	}
 
-&lt;p&gt;The following code fragment show how to execute the actions associated with a given frame number from a Flash movie:&lt;/p&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(12));
-actions.add(new FSCall());
-&lt;/pre&gt;
+	public int length(FSCoder coder)
+	{
+		return super.length(coder);
+	}
 
-&lt;p&gt;Alternatively if the frame has been assigned a name using an FSFrameLabel object then the associated actions may be executed by using the name as a reference:&lt;/p&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.endObject(name());
+	}
 
-&lt;pre&gt;
-movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
-...
-actions.add(new FSPush(&quot;FirstFrame&quot;));
-actions.add(new FSCall());
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSCall class represents the ActionCall action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSCall extends FSActionObject
-{
-    private static final FSCall instance = new FSCall();
-    
-    /**
-     * Returns a canonical FSCall object.
-     * 
-     * @return an object that can safely be shared among objects.
-     */
-    public static FSCall getInstance()
-    {
-        return instance;
-    }
-    /**
-     * Construct an FSCall object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSCall(FSCoder coder)
-    {
-        super(Call);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSCall object. 
-     */
-    public FSCall()
-    {
-        super(Call);
-    }
-    /**
-     * Constructs an FSCall object by copying values from an existing object.
-     *
-     * @param obj an FSCall object.
-     */
-    public FSCall(FSCall obj)
-    {
-        super(obj);
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
-    
-    public int length(FSCoder coder)
-    {
-        return super.length(coder);
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSCharacter.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCharacter.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSCharacter.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,210 +31,268 @@
 package com.flagstone.transform;
 
 /**
-The FSCharacter class is used to identify the glyph that is displayed for a given 
-character in a line of text. 
+ * The FSCharacter class is used to identify the glyph that is displayed for a
+ * given character in a line of text.
+ * 
+ * &lt;p&gt;
+ * The spacing to the next character is also defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;glyphIndex&lt;/td&gt;
+ * &lt;td&gt;An index into the array of FSShape objects that define the glyphs for a
+ * given font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;advance&lt;/td&gt;
+ * &lt;td&gt;The distance, in twips, from the origin of the glyph representing the
+ * current character to the next glyph to be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * A single lines of text is displayed using an FSText object which contains an
+ * array of FSCharacter objects. Blocks of text can be created by combining one
+ * or more FSText objects. The size, colour and relative position of each line
+ * within the block is defined by the FSText object. The FSText objects are
+ * added to an FSDefineText object or an FSDefineText2 object (which supports
+ * transparent colours) which is then used to define the final size and
+ * orientation of the text when it is placed on the Display List.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This greatly simplified example illustrates how text strings are created.
+ * First the array of glyphs for each character is defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList alphabet = new ArrayList();
+ * 
+ *  FSShape space = new Shape(...);  // Glyph for ' '
+ *  FSShape a = new Shape(...);      // Glyph for 'a'
+ *  FSShape b = new Shape(...);      // Glyph for 'b'
+ *  ...
+ *  FSShape z = new Shape(...);      // Glyph for 'z'
+ * 
+ *  alphabet.add(space);
+ *  alphabet.add(a);
+ *  alphabet.add(b);
+ *  ...
+ *  alphabet.add(z);
+ * 
+ *  // Create the font containing the glyphs for each character
+ *  movie.add(new FSDefineFont(movie.newIdentifier(), alphabet));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Now created the array of FSCharacter objects representing 'a string' Assume
+ * the font is a fixed width such as Courier and the spacing between characters
+ * is 160 twips - 8 pixels.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * ArrayList characters = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * FSText string = new FSText(characters);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * It should be immediately clear that creating strings and font definitions
+ * from scratch is a huge task requiring knowledge of drawing glyphs and how to
+ * layout glyphs to generate aesthetically pleasing text. Transform is a
+ * low-level library and such complicated code should be avoided at all costs.
+ * Fortunately it is 'relatively' easy to use convert existing font definitions
+ * such as those encoded in True Type Font files to into the font and text
+ * definition objects that can be used to create Flash files. Another useful
+ * approach is to use an existing font definition from a Flash file to obtain
+ * the glyph definitions, character codes and advance information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Creating such font and text definitions is outside the scope of the
+ * documentation for this library. However refer to the Transform Utilities
+ * framework for Transform available on Flagstone Software's web site for ways
+ * to perform these tasks.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCharacter class represents the GlyphEntry structure from Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSCharacter extends FSTransformObject
+{
+	private int glyphIndex = 0;
+	private int advance = 0;
 
-&lt;p&gt;The spacing to the next character is also defined.&lt;/p&gt;
+	/**
+	 * Construct an FSCharacter object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSCharacter(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSCharacter specifying the index of the glyph to be
+	 * displayed and the spacing to the next glyph.
+	 * 
+	 * @param anIndex
+	 *            the index into the array of FSShapes in a font definition
+	 *            object that defines the glyph that represents the character to
+	 *            be displayed.
+	 * 
+	 * @param anAdvance
+	 *            the relative position in twips, from the origin of the glyph
+	 *            representing this character to the next glyph to be displayed.
+	 */
+	public FSCharacter(int anIndex, int anAdvance)
+	{
+		setGlyphIndex(anIndex);
+		setAdvance(anAdvance);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSCharacter object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSCharacter object.
+	 */
+	public FSCharacter(FSCharacter obj)
+	{
+		glyphIndex = obj.glyphIndex;
+		advance = obj.advance;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCharacter_0&quot;&gt;glyphIndex&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An index into the array of FSShape objects that define the glyphs for a given font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the index of the glyph, in a font definition object, that will
+	 * displayed to represent this character.
+	 * 
+	 * @return the index of the glyph that represents the character to be
+	 *         displayed.
+	 */
+	public int getGlyphIndex()
+	{
+		return glyphIndex;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCharacter_1&quot;&gt;advance&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The distance, in twips, from the origin of the glyph representing the current character to the next glyph to be displayed.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the spacing in twips between the glyph representing this character
+	 * and the next.
+	 * 
+	 * @return the distance in twips to the next glyph.
+	 */
+	public int getAdvance()
+	{
+		return advance;
+	}
 
-&lt;p&gt;A single lines of text is displayed using an FSText object which contains an array of FSCharacter objects. Blocks of text can be created by combining one or more FSText objects. The size, colour and relative position of each line within the block is defined by the FSText object. The FSText objects are added to an FSDefineText object or an FSDefineText2 object (which supports transparent colours) which is then used to define the final size and orientation of the text when it is placed on the Display List.&lt;/p&gt;
+	/**
+	 * Sets the index of the glyph, contained in the array of FSShape object
+	 * contained in a font definition object, that represents the character to
+	 * be displayed.
+	 * 
+	 * @param anIndex
+	 *            the index of the glyph that represents the character to be
+	 *            displayed.
+	 */
+	public void setGlyphIndex(int anIndex)
+	{
+		glyphIndex = anIndex;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	/**
+	 * Sets the spacing in twips between the glyph representing this character
+	 * and the next glyph to be displayed.
+	 * 
+	 * @param aNumber
+	 *            the relative position in twips from the origin of the glyph
+	 *            representing this character to the next glyph.
+	 */
+	public void setAdvance(int aNumber)
+	{
+		advance = aNumber;
+	}
 
-&lt;p&gt;This greatly simplified example illustrates how text strings are created. First the array of glyphs for each character is defined.&lt;/p&gt;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-ArrayList alphabet = new ArrayList();
+		if (super.equals(anObject))
+		{
+			FSCharacter typedObject = (FSCharacter) anObject;
 
-FSShape space = new Shape(...);  // Glyph for ' '
-FSShape a = new Shape(...);      // Glyph for 'a'
-FSShape b = new Shape(...);      // Glyph for 'b'
-...
-FSShape z = new Shape(...);      // Glyph for 'z'
+			result = glyphIndex == typedObject.glyphIndex;
+			result = result &amp;&amp; advance == typedObject.advance;
+		}
+		return result;
+	}
 
-alphabet.add(space);
-alphabet.add(a);
-alphabet.add(b);
-...
-alphabet.add(z);
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-// Create the font containing the glyphs for each character
-movie.add(new FSDefineFont(movie.newIdentifier(), alphabet));
-&lt;/pre&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;glyphIndex&quot;, glyphIndex);
+			Transform.append(buffer, &quot;advance&quot;, advance);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;Now created the array of FSCharacter objects representing 'a string' Assume the font is a fixed width such as Courier and the spacing between characters is 160 twips - 8 pixels.&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
+		int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
 
-&lt;pre&gt;
-ArrayList characters = new ArrayList();
+		return numberOfGlyphBits + numberOfAdvanceBits;
+	}
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+	public void encode(FSCoder coder)
+	{
+		coder.writeBits(glyphIndex, coder.context[FSCoder.NumberOfGlyphBits]);
+		coder.writeBits(advance, coder.context[FSCoder.NumberOfAdvanceBits]);
+	}
 
-FSText string = new FSText(characters);
-&lt;/pre&gt;
+	public void decode(FSCoder coder)
+	{
+		int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
+		int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
 
-&lt;p&gt;It should be immediately clear that creating strings and font definitions from scratch is a huge task requiring knowledge of drawing glyphs and how to layout glyphs to generate aesthetically pleasing text. Transform is a low-level library and such complicated code should be avoided at all costs. Fortunately it is 'relatively' easy to use convert existing font definitions such as those encoded in True Type Font files to into the font and text definition objects that can be used to create Flash files. Another useful approach is to use an existing font definition from a Flash file to obtain the glyph definitions, character codes and advance information.&lt;/p&gt;
-
-&lt;p&gt;Creating such font and text definitions is outside the scope of the documentation for this library. However refer to the Transform Utilities framework for Transform available on Flagstone Software's web site for ways to perform these tasks.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSCharacter class represents the GlyphEntry structure from Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSCharacter extends FSTransformObject
-{
-    private int glyphIndex = 0;
-    private int advance = 0;
-
-    /**
-     * Construct an FSCharacter object, initalizing it with values decoded from 
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSCharacter(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSCharacter specifying the index of the glyph to be displayed 
-     * and the spacing to the next glyph.
-
-        @param anIndex the index into the array of FSShapes in a font definition
-        object that defines the glyph that represents the character to be displayed.
-        
-        @param anAdvance the relative position in twips, from the origin of the 
-        glyph representing this character to the next glyph to be displayed.
-        */
-    public FSCharacter(int anIndex, int anAdvance)
-    {
-        setGlyphIndex(anIndex);
-        setAdvance(anAdvance);
-    }
-    /**
-     * Constructs an FSCharacter object by copying values from an existing object.
-     *
-     * @param obj an FSCharacter object.
-     */
-    public FSCharacter(FSCharacter obj)
-    {
-        glyphIndex = obj.glyphIndex;
-        advance = obj.advance;
-    }
-
-    /** 
-     * Gets the index of the glyph, in a font definition object, that will 
-     * displayed to represent this character.
-
-        @return the index of the glyph that represents the character to be displayed.
-        */
-    public int getGlyphIndex() { return glyphIndex; }
-
-    /** Gets the spacing in twips between the glyph representing this character and the next.
-
-        @return the distance in twips to the next glyph.
-        */
-    public int getAdvance() { return advance; }
-
-    /** 
-     * Sets the index of the glyph, contained in the array of FSShape object 
-     * contained in a font definition object, that represents the character to 
-     * be displayed.
-
-        @param anIndex the index of the glyph that represents the character to 
-        be displayed.
-     */
-    public void setGlyphIndex(int anIndex)
-    {
-        glyphIndex = anIndex;
-    }
-
-    /** 
-     * Sets the spacing in twips between the glyph representing this character 
-     * and the next glyph to be displayed.
-
-        @param aNumber the relative position in twips from the origin of the 
-        glyph representing this character to the next glyph.
-     */
-    public void setAdvance(int aNumber)
-    {
-        advance = aNumber;
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSCharacter typedObject = (FSCharacter)anObject;
-            
-            result = glyphIndex == typedObject.glyphIndex;
-            result = result &amp;&amp; advance == typedObject.advance;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;glyphIndex&quot;, glyphIndex);
-            Transform.append(buffer, &quot;advance&quot;, advance);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
-        int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
-        
-        return numberOfGlyphBits + numberOfAdvanceBits;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeBits(glyphIndex, coder.context[FSCoder.NumberOfGlyphBits]);
-        coder.writeBits(advance, coder.context[FSCoder.NumberOfAdvanceBits]);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
-        int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
-        
-        glyphIndex = coder.readBits(numberOfGlyphBits, false);
-        advance = coder.readBits(numberOfAdvanceBits, true);
-    }
+		glyphIndex = coder.readBits(numberOfGlyphBits, false);
+		advance = coder.readBits(numberOfAdvanceBits, true);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSClipEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSClipEvent.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSClipEvent.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,609 +33,817 @@
 import java.util.*;
 
 /**
-FSClipEvent is used to define the actions that a movie clip will execute in response 
-to a particular event.
+ * FSClipEvent is used to define the actions that a movie clip will execute in
+ * response to a particular event.
+ * 
+ * &lt;p&gt;
+ * FSClipEvent objects are added to an FSPlaceObject2 object and the actions are
+ * registered with the Flash Player when the movie clip is added to the display
+ * list.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;event&lt;/td&gt;
+ * &lt;td&gt;A code representing one or more events that the movie clip will respond
+ * to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of actions that will be executed when one or more of the
+ * specified events occur.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The events that a movie clip responds to are:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr bgcolor=&quot;#CCCCFF&quot; valign=&quot;top&quot;&gt;
+ * &lt;th align=&quot;left&quot;&gt;Event&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Load&lt;/td&gt;
+ * &lt;td&gt;occurs when the movie clip is finished loading.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Unload&lt;/td&gt;
+ * &lt;td&gt;occurs when the movie clip is unloaded from the parent movie.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;EnterFrame&lt;/td&gt;
+ * &lt;td&gt;occurs when each frame in the movie clip is played.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MouseMove&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse pointer is moved.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MouseDown&lt;/td&gt;
+ * &lt;td&gt;occurs when the left mouse button is pressed while the cursor is outside
+ * of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MouseUp&lt;/td&gt;
+ * &lt;td&gt;occurs when the left mouse button is pressed and released while the
+ * cursor is outside of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;KeyDown&lt;/td&gt;
+ * &lt;td&gt;occurs when any key is pressed on the keyboard. From Flash 6 a key code
+ * can be specified to identify a specific key rather than testing for the value
+ * inside the actions that are executed in response to the event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;KeyUp&lt;/td&gt;
+ * &lt;td&gt;occurs when any key being pressed on the keyboard is released.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Data&lt;/td&gt;
+ * &lt;td&gt;occurs when an FSGetUrl2 action is executed with the movie clip
+ * specified as a target.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Starting with Flash 6 movie clips also respond to the same set of events that
+ * buttons do:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves over the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;RollOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse cursor moves out of the bounding rectangle of the
+ * movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Press&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is inside
+ * bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Release&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and released while the mouse
+ * cursor is inside bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;ReleaseOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is released
+ * outside of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOut&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged
+ * out of the bounding rectangle of the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;DragOver&lt;/td&gt;
+ * &lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged
+ * into the bounding rectangle of the movie clip and the mouse button is
+ * released.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Initialize&lt;/td&gt;
+ * &lt;td&gt;occurs when a movie clip is initialized using the FSInitialize class.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Movie clips now also respond to keys being pressed on the keyboard. Keyboard
+ * events are defined by the character key being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;,
+ * etc. The ASCII code for the key is used to identify which key was pressed.
+ * Note that while multiple mouse events can be defined for a button only one
+ * keyboard event can be defined.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * In Flash 7 a new construct event was added.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;Construct&lt;/td&gt;
+ * &lt;td&gt;The function of this event is undocumented.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * IMPORTANT: The FSClipEvent object supports both the Flash 5, Flash 6 and
+ * Flash 7 event models. The events that are encoded to a file are determined by
+ * the version of the FSMovie in which the object is contained. The codes
+ * assigned to the different types of event ensure that the same value can be
+ * used to encode the object for each version of Flash.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For the KeyDown and KeyUp events, Flash ActionScript provides the Key object
+ * which contains the getCode() and isDown() functions that allow code to be
+ * written to test which key was pressed. Note that ActionScript is a high-level
+ * interpreted language similar to JavaScript. Transform supports actions that
+ * represent the compiled version of the ActionScript code. To create and
+ * compile ActionScript code then use Transform's sister product, Translate.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Each type of event is defined by a constant, for example, Load, EnterFrame,
+ * etc. An FSClipEvent object can define the actions that will be executed in
+ * response to multiple events. There are two ways to respond to multiple
+ * events. If the same set of actions should be executed then the event code
+ * that flags which events should be responded to can be generated by bitwise
+ * OR-ing together the individual constants:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int loadAndMouseMove = FSClipEvent.Load | FSClipEvent.MouseMove;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * If different actions should be executed then an FSClipEvent object is created
+ * for each different set of events. The FSPlaceObject2 object that is used to
+ * register the actions for a movie clip with the Flash Player supports an array
+ * of FSClipEvent objects.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The array of actions may be empty. Although this situation does not perform
+ * any useful operation it is valid and may be encountered when parsing Flash
+ * files generated by a third party.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following simplified code fragments illustrate how the FSClipEvent class
+ * can be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Defining the actions for a single event.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  FSClipEvent clipEvent(FSClipEvent.MouseDown);
+ * 
+ *  clipEvent.add(anAction);
+ *  ...
+ * 
+ *  FSPlaceObject2 placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400);
+ * 
+ *  placeClip.add(clipEvent);
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(placeClip);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Defining the actions for a compound event.&lt;br/&gt; If a movie clip should
+ * execute the same set of actions for different types of event then the code
+ * for the compound event can be created by bitwise-OR'ing individual event
+ * codes.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  FSClipEvent clipEvent(FSClipEvent.MouseDown | FSClipEvent.KeyDown, actions);
+ *  ...
+ *  FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+ * 
+ *  placeClip.add(clipEvent);
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(placeClip);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Defining different sets of actions for events.&lt;br/&gt; An FSClipEvent object
+ * is created for each set of events that a movie clip must respond to.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineMovieClip* movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ *  FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+ * 
+ *  FSClipEvent mouseEvent(FSClipEvent.MouseDown, mouseActions);
+ *  ...
+ *  placeClip.add(clipEvent);
+ * 
+ *  FSClipEvent keyEvent(FSClipEvent.KeyDown, keyActions);
+ *  ...
+ *  placeClip.add(keyEvent);
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(placeClip);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSClipEvent class represents the ClipEvent data structure tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5. The event model was extended in Flash 6 to support the set of events that
+ * Buttons respond to. In Flash 7 the Construct event was added.
+ * &lt;/p&gt;
+ */
+public class FSClipEvent extends FSTransformObject
+{
+	/** Code for a load event. */
+	public static final int Load = 1;
 
-&lt;p&gt;FSClipEvent objects are added to an FSPlaceObject2 object and the actions are registered with the Flash Player when the movie clip is added to the display list.&lt;/p&gt;
+	/** Code for an enter frame event. */
+	public static final int EnterFrame = 2;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Code for an unload event. */
+	public static final int Unload = 4;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Code for a mouse move event. */
+	public static final int MouseMove = 8;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSClipEvent_0&quot;&gt;event&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A code representing one or more events that the movie clip will respond to.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSClipEvent_0&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An array of actions that will be executed when one or more of the specified events occur.&lt;/td&gt;&lt;/tr&gt;
+	/** Code for a mouse down event. */
+	public static final int MouseDown = 16;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSClipEvent_2&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded actions are typically generated by the parser in the Translate framework. The actions array and encodedActions cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Code for a mouse up event. */
+	public static final int MouseUp = 32;
 
-&lt;/table&gt;
+	/** Code for a key down event. */
+	public static final int KeyDown = 64;
 
-&lt;p&gt;The events that a movie clip responds to are:&lt;/p&gt;
+	/** Code for a key up event. */
+	public static final int KeyUp = 128;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr bgcolor=&quot;#CCCCFF&quot; valign=&quot;top&quot;&gt;&lt;th align=&quot;left&quot;&gt;Event&lt;/th&gt;
-&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Load&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the movie clip is finished loading.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Unload&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the movie clip is unloaded from the parent movie.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;EnterFrame&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when each frame in the movie clip is played.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MouseMove&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse pointer is moved.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MouseDown&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the left mouse button is pressed while the cursor is outside of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MouseUp&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the left mouse button is pressed  and released while the cursor is outside of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;KeyDown&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when any key is pressed on the keyboard. From Flash 6  a key code can be specified to identify a specific key rather than testing for the value inside the actions that are executed in response to the event.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;KeyUp&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when any key being pressed on the keyboard is released.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Data&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when an FSGetUrl2 action is executed with the movie clip specified as a target.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Code for a data event. */
+	public static final int Data = 256;
 
-&lt;p&gt;Starting with Flash 6 movie clips also respond to the same set of events that buttons do:&lt;/p&gt;
+	/** Code for an initialise event. */
+	public static final int Initialize = 512;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;RollOver&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves over the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;RollOut&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse cursor moves out of the bounding rectangle  of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Press&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked while the mouse cursor is inside bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Release&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and released while the mouse cursor is inside bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;ReleaseOut&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is released outside of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOut&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked and the mouse cursor is dragged out of the bounding rectangle of the movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;DragOver&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when the mouse button is clicked, the mouse cursor is dragged into the bounding rectangle of the movie clip and the mouse button is released.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;Initialize&lt;/a&gt;&lt;/td&gt;&lt;td&gt;occurs when a movie clip is initialized using the FSInitialize class.&lt;/td&gt;&lt;/tr&gt;
-&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Code for a press event. */
+	public static final int Press = 1024;
 
-&lt;p&gt;Movie clips now also respond to keys being pressed on the keyboard. Keyboard events are defined by the character key being pressed, e.g. &quot;t&quot;, &quot;T&quot;, &quot;$&quot;, etc. The ASCII code for the key is used to identify which key was pressed. Note that while multiple mouse events can be defined for a button only one keyboard event can be defined.&lt;/p&gt;
+	/** Code for a release event. */
+	public static final int Release = 2048;
 
-&lt;p&gt;In Flash 7 a new construct event was added.&lt;/p&gt;
-    
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;td&gt;Construct&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The function of this event is undocumented.&lt;/td&gt;&lt;/tr&gt;
-&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Code for a release outside event. */
+	public static final int ReleaseOut = 4096;
 
-&lt;p&gt;IMPORTANT: The FSClipEvent object supports both the Flash 5, Flash 6 and Flash 7 event models. The events that are encoded to a file are determined by the version of the FSMovie in which the object is contained. The codes assigned to the different types of event ensure that the same value can be used to encode the object for each version of Flash.&lt;/p&gt;
+	/** Code for a roll over event. */
+	public static final int RollOver = 8192;
 
-&lt;p&gt;For the KeyDown and KeyUp events, Flash ActionScript provides the Key object which contains the getCode() and isDown() functions that allow code to be written to test which key was pressed. Note that ActionScript is a high-level interpreted language similar to JavaScript. Transform supports actions that represent the compiled version of the ActionScript code. To create and compile ActionScript code then use Transform's sister product, Translate.&lt;/p&gt;
+	/** Code for a roll out event. */
+	public static final int RollOut = 16384;
 
-&lt;p&gt;Each type of event is defined by a constant, for example, Load, EnterFrame, etc. An FSClipEvent object can define the actions that will be executed in response to multiple events. There are two ways to respond to multiple events. If the same set of actions should be executed then the event code that flags which events should be responded to can be generated by bitwise OR-ing together the individual constants:&lt;/p&gt;
+	/** Code for a drag over event. */
+	public static final int DragOver = 32768;
 
-&lt;pre&gt;
-int loadAndMouseMove = FSClipEvent.Load | FSClipEvent.MouseMove;
-&lt;/pre&gt;
+	/** Code for a drag out event. */
+	public static final int DragOut = 65536;
 
-&lt;p&gt;If different actions should be executed then an FSClipEvent object is created for each different set of events. The FSPlaceObject2 object that is used to register the actions for a movie clip with the Flash Player supports an array of FSClipEvent objects.&lt;/p&gt;
+	/** Code for a key press event, where the code for the key is specified. */
+	public static final int KeyPress = 131072;
 
-&lt;p&gt;The array of actions may be empty. Although this situation does not perform any useful operation it is valid and may be encountered when parsing Flash files generated by a third party.&lt;/p&gt;
+	/** Code for a construct event. */
+	public static final int Construct = 262144;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	private int event = 0;
+	private int keyCode = 0; // Flash 6+
+	private ArrayList actions = null;
+	private byte[] encodedActions = null;
 
-&lt;p&gt;The following simplified code fragments illustrate how the FSClipEvent class can be used.&lt;/p&gt;
+	/**
+	 * Construct an FSClipEvent object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSClipEvent(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;p&gt;1. Defining the actions for a single event.&lt;/p&gt;
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param eventCode
+	 *            the code representing one or more events.
+	 * @param anArray
+	 *            the array of actions that will be executed when the specified
+	 *            event occurs.
+	 */
+	public FSClipEvent(int eventCode, ArrayList anArray)
+	{
+		setEvent(eventCode);
+		setActions(anArray);
+	}
 
-&lt;pre&gt;
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs.
+	 * 
+	 * @param eventCode
+	 *            the event code.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSClipEvent(int eventCode, byte[] bytes)
+	{
+		setEvent(eventCode);
+		setEncodedActions(bytes);
+	}
 
-FSClipEvent clipEvent(FSClipEvent.MouseDown);
+	// Flash 6
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs or when the specified key
+	 * is pressed.
+	 * 
+	 * @param eventCode
+	 *            the code representing one or more events.
+	 * @param keyCode
+	 *            the ASCII code for the key pressed on the keyboard.
+	 * @param anArray
+	 *            the array of actions that will be executed when the specified
+	 *            event occurs.
+	 */
+	public FSClipEvent(int eventCode, int keyCode, ArrayList anArray)
+	{
+		setEvent(eventCode);
+		setKeyCode(keyCode);
+		setActions(anArray);
+	}
 
-clipEvent.add(anAction);
-...
+	/**
+	 * Constructs an FSClipEvent object that defines the array of actions that
+	 * will be executed when a particular event occurs or when the specified key
+	 * is pressed. The array of bytes contained the encoded actions and is
+	 * typically generated using the classes in the Translate framework.
+	 * 
+	 * @param eventCode
+	 *            the code representing one or more events.
+	 * @param keyCode
+	 *            the ASCII code for the key pressed on the keyboard.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSClipEvent(int eventCode, int keyCode, byte[] bytes)
+	{
+		setEvent(eventCode);
+		setKeyCode(keyCode);
+		setEncodedActions(bytes);
+	}
 
-FSPlaceObject2 placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400);
+	// End Flash 6
+	/**
+	 * Constructs an FSCall object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSCall object.
+	 */
+	public FSClipEvent(FSClipEvent obj)
+	{
+		event = obj.event;
+		keyCode = obj.keyCode;
 
-placeClip.add(clipEvent);
+		if (actions != null)
+		{
+			actions = new ArrayList();
 
-movie.add(movieClip);
-movie.add(placeClip);
-&lt;/pre&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-&lt;p&gt;2. Defining the actions for a compound event.&lt;br/&gt;
-If a movie clip should execute the same set of actions for different types of event then the code for the compound event can be created by bitwise-OR'ing individual event codes.&lt;/p&gt;
+	/**
+	 * Adds an action to the array of actions.
+	 * 
+	 * @param anAction
+	 *            a pointer to an action object.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-&lt;pre&gt;
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+	/**
+	 * Sets the event code that this FSClipEvent defines actions for.
+	 * 
+	 * @param aNumber
+	 *            the code representing one or more events.
+	 */
+	public void setEvent(int aNumber)
+	{
+		event = aNumber;
+	}
 
-FSClipEvent clipEvent(FSClipEvent.MouseDown | FSClipEvent.KeyDown, actions);
-...
-FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+	/**
+	 * Gets the event code that this FSClipEvent defines actions for.
+	 * 
+	 * @return the eventCode representing the events that the FSClipEvent object
+	 *         will respond to.
+	 */
+	public int getEvent()
+	{
+		return event;
+	}
 
-placeClip.add(clipEvent);
+	// Flash 6
+	/**
+	 * Gets the code for the key that triggers the event when pressed. The code
+	 * is typically the ASCII code for standard western keyboards.
+	 * 
+	 * @return the code for the key that triggers the event.
+	 */
+	public int getKeyCode()
+	{
+		return keyCode;
+	}
 
-movie.add(movieClip);
-movie.add(placeClip);
-&lt;/pre&gt;
+	/**
+	 * Sets the code for the key that triggers the event when pressed. The code
+	 * is typically the ASCII code for standard western keyboards.
+	 * 
+	 * @param code
+	 *            the ASCII code for the key that triggers the event.
+	 */
+	public void setKeyCode(int code)
+	{
+		keyCode = code;
+	}
 
-&lt;p&gt;3. Defining different sets of actions for events.&lt;br/&gt;
-An FSClipEvent object is created for each set of events that a movie clip must respond to.&lt;/p&gt;
+	// End Flash 6
 
-&lt;pre&gt;
-FSDefineMovieClip* movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
-FSPlaceObject2* placeClip = new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400)
+	/**
+	 * Sets the array of actions that are executed by the movie clip in response
+	 * to specified event(s).
+	 * 
+	 * @param anArray
+	 *            the array of actions that will be executed when the specified
+	 *            event occurs.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-FSClipEvent mouseEvent(FSClipEvent.MouseDown, mouseActions);
-...
-placeClip.add(clipEvent);
+	/**
+	 * Gets the array of actions that are executed by the movie clip in response
+	 * to specified event(s).
+	 * 
+	 * @return the array of actions that will be executed when the specified
+	 *         event occurs.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-FSClipEvent keyEvent(FSClipEvent.KeyDown, keyActions);
-...
-placeClip.add(keyEvent);
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-movie.add(movieClip);
-movie.add(placeClip);
-&lt;/pre&gt;
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public Object clone()
+	{
+		FSClipEvent anObject = (FSClipEvent) super.clone();
 
-&lt;p&gt;The FSClipEvent class represents the ClipEvent data structure tag from the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5. 
-The event model was extended in Flash 6 to support the set of events that Buttons 
-respond to. In Flash 7 the Construct event was added.&lt;/p&gt;
- */  
-public class FSClipEvent extends FSTransformObject
-{
-/** Code for a load event.*/
-    public static final int Load = 1;
-/** Code for an enter frame event.*/
-    public static final int EnterFrame = 2;
-/** Code for an unload event.*/
-    public static final int Unload = 4;
-/** Code for a mouse move event.*/
-    public static final int MouseMove = 8;
-/** Code for a mouse down event.*/
-    public static final int MouseDown = 16;
-/** Code for a mouse up event.*/
-    public static final int MouseUp = 32;
-/** Code for a key down event.*/
-    public static final int KeyDown = 64;
-/** Code for a key up event.*/
-    public static final int KeyUp = 128;
-/** Code for a data event.*/
-    public static final int Data = 256;
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-// Flash 6
-    /// Code for an initialize event.
-    public static final int Initialize = 512;
-    /// Code for a press event.
-    public static final int Press = 1024;
-    /// Code for a release event.
-    public static final int Release = 2048;
-    /// Code for a release outside event.
-    public static final int ReleaseOut = 4096;
-    /// Code for a roll over event.
-    public static final int RollOver = 8192;
-    /// Code for a roll out event.
-    public static final int RollOut = 16384;
-    /// Code for a drag over event.
-    public static final int DragOver = 32768;
-    /// Code for a drag out event.
-    public static final int DragOut = 65536;
-    /// Code for a key press event, where the code for the key is specified.
-    public static final int KeyPress = 131072;
-// Flash 7
-    /// Code for a construct event.
-    public static final int Construct = 262144;
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
+		return anObject;
+	}
 
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    private int event = 0;
-    private int keyCode = 0; // Flash 6+
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-    
-    /**
-     * Construct an FSClipEvent object, initalizing it with values decoded from 
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSClipEvent(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSClipEvent object that defines the array of actions that will be executed when a particular event occurs.
+		if (super.equals(anObject))
+		{
+			FSClipEvent typedObject = (FSClipEvent) anObject;
 
-        @param eventCode the code representing one or more events.
-        @param anArray the array of actions that will be executed when the specified event occurs.
-        */
-    public FSClipEvent(int eventCode, ArrayList anArray)
-    {
-        setEvent(eventCode);
-        setActions(anArray);
-    }
+			result = event == typedObject.event;
+			// Flash 6
+			result = result &amp;&amp; keyCode == typedObject.keyCode;
+			// End Flash 6
+			if (actions != null)
+				result = actions.equals(typedObject.actions);
+			else
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+		}
+		return result;
+	}
 
-    /** 
-     * Constructs an FSClipEvent object that defines the array of actions that 
-     * will be executed when a particular event occurs.
-     * 
-     * @param eventCode the event code.
-     * @param bytes an array of encoded action objects.
-     */
-    public FSClipEvent(int eventCode, byte[] bytes)
-    {
-        setEvent(eventCode);
-        setEncodedActions(bytes);
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-// Flash 6
-    /** Constructs an FSClipEvent object that defines the array of actions that will be 
-     *  executed when a particular event occurs or when the specified key is pressed. 
-     * 
-     *  @param eventCode the code representing one or more events.
-     *  @param keyCode the ASCII code for the key pressed on the keyboard.
-     *  @param anArray the array of actions that will be executed when the specified event occurs.
-     */ 
-    public FSClipEvent(int eventCode, int keyCode, ArrayList anArray)
-    {
-        setEvent(eventCode);
-        setKeyCode(keyCode);
-        setActions(anArray);
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;event&quot;, event);
+			// Flash 6
+			Transform.append(buffer, &quot;keyCode&quot;, keyCode);
+			// End Flash 6
+			if (actions != null)
+				Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			else
+				buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    /** Constructs an FSClipEvent object that defines the array of actions that will be 
-     *  executed when a particular event occurs or when the specified key is pressed.
-     *  The array of bytes contained the encoded actions and is typically generated
-     *  using the classes in the Translate framework.
-     * 
-     *  @param eventCode the code representing one or more events.
-     *  @param keyCode the ASCII code for the key pressed on the keyboard.
-     *  @param bytes an array of encoded action objects.
-     */
-    public FSClipEvent(int eventCode, int keyCode, byte[] bytes)
-    {
-        setEvent(eventCode);
-        setKeyCode(keyCode);
-        setEncodedActions(bytes);
-    }
-// End Flash 6
-    /**
-     * Constructs an FSCall object by copying values from an existing object.
-     *
-     * @param obj an FSCall object.
-     */
-    public FSClipEvent(FSClipEvent obj)
-    {
-        event = obj.event;
-        keyCode = obj.keyCode;
-        
-        if (actions != null)
-        {
-            actions = new ArrayList();
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Adds an action to the array of actions.
-        
-        @param anAction a pointer to an action object.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+	public int length(FSCoder coder)
+	{
+		int length = 4 + ((coder.context[FSCoder.Version] &gt; 5) ? 4 : 2);
 
-    /** Sets the event code that this FSClipEvent defines actions for.
+		// Flash 6
+		length += ((event &amp; KeyPress) != 0) ? 1 : 0;
+		// End Flash 6
 
-        @param aNumber the code representing one or more events.
-        */
-    public void setEvent(int aNumber)
-    {
-        event = aNumber;
-    }
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-    /** Gets the event code that this FSClipEvent defines actions for.
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-        @return the eventCode representing the events that the FSClipEvent object will respond to.
-        */
-    public int getEvent()
-    {
-        return event;
-    }
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-// Flash 6
-    /** Gets the code for the key that triggers the event when pressed. The code 
-     *  is typically the ASCII code for standard western keyboards.
-     * 
-     *  @return the code for the key that triggers the event.
-     */
-    public int getKeyCode()
-    {
-        return keyCode;
-    }
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-    /** Sets the code for the key that triggers the event when pressed. The code 
-     *  is typically the ASCII code for standard western keyboards.
-     * 
-     *  @param code the ASCII code for the key that triggers the event.
-     */
-    public void setKeyCode(int code)
-    {
-        keyCode = code;
-    }
-// End Flash 6
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
 
-    /** Sets the array of actions that are executed by the movie clip in response to specified event(s).
+	public void encode(FSCoder coder)
+	{
+		int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
 
-        @param anArray the array of actions that will be executed when the specified event occurs.
-        */  
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+		int offset = 0;
 
-    /** Gets the array of actions that are executed by the movie clip in response to specified event(s).
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-        @return the array of actions that will be executed when the specified event occurs.
-        */   
-    public ArrayList getActions()
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-   }
+				offset += currentAction.getLength();
+				offset += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-    public Object clone()
-    {
-        FSClipEvent anObject = (FSClipEvent)super.clone();
-        
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				offset += 1;
+			}
+		} else
+		{
+			offset += encodedActions.length;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSClipEvent typedObject = (FSClipEvent)anObject;
-            
-            result = event == typedObject.event;              
-// Flash 6
-            result = result &amp;&amp; keyCode == typedObject.keyCode;              
-// End Flash 6
-            if (actions != null)
-                result = actions.equals(typedObject.actions);
-            else
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				offset += 1;
+			}
+		}
 
-     public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		// Flash 6
+		offset += ((event &amp; KeyPress) != 0) ? 1 : 0;
+		// End Flash 6
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;event&quot;, event);
-// Flash 6
-            Transform.append(buffer, &quot;keyCode&quot;, keyCode);
-// End Flash 6
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
-                
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.writeWord(event, eventSize);
+		coder.writeWord(offset, 4);
 
-    public int length(FSCoder coder)
-    {
-        int length = 4 + ((coder.context[FSCoder.Version] &gt; 5) ? 4 : 2);
-    
-// Flash 6
-        length += ((event &amp; KeyPress) != 0) ? 1 : 0;
-// End Flash 6
-    
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+		// Flash 6
+		if ((event &amp; KeyPress) != 0)
+			coder.writeWord(keyCode, 1);
+		// End Flash 6
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
-        
-        int offset = 0;
-        
-        if (actions != null)
-        {       
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-            	currentAction = (FSActionObject)i.next();
-            
-                offset += currentAction.getLength();
-                offset += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	offset += 1;
-            }
-        }
-        else
-        {
-            offset += encodedActions.length;
+		if (actions != null)
+		{
+			FSActionObject action = null;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	offset += 1;
-            }
-        }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
 
-// Flash 6
-        offset += ((event &amp; KeyPress) != 0) ? 1 : 0;
-// End Flash 6
-            
-        coder.writeWord(event, eventSize);
-        coder.writeWord(offset, 4);
-            
-// Flash 6
-        if ((event &amp; KeyPress) != 0)
-            coder.writeWord(keyCode, 1);
-// End Flash 6
-        
-        if (actions != null)
-        { 
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int length = action.getLength();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (length &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-           coder.writeBytes(encodedActions);
+				int objStart = coder.getPointer();
+				int length = action.getLength();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (length &lt;&lt; 3);
 
-           if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-               coder.writeWord(0, 1);
-           }
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
+				action.encode(coder);
+				coder.setPointer(next);
 
-        event = coder.readWord(eventSize, false);
-        int length = coder.readWord(4, false);
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-// Flash 6
-        if ((event &amp; KeyPress) != 0) {
-            keyCode = coder.readWord(1, false);
-            length -= 1;
-        }
-// End Flash 6
-    
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            FSActionObject action;
-            int start;
-            
-            actions = new ArrayList();
-            
-            while (length &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                action = FSMovie.decodeAction(coder);                
-                actions.add(action);
-                length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-                
-                /*
-                 * The following code is to fix an apparent bug in Flash CS3
-                 * where the offset to the next clip event is 1 byte larger 
-                 * than it should be.
-                 */
-                
-                if (action.getType() == FSAction.End &amp;&amp; length == 1) {
-                	break;
-                }
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length];
-            coder.readBytes(encodedActions);
-        }
-    }
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		int eventSize = (coder.context[FSCoder.Version] &gt; 5) ? 4 : 2;
+
+		event = coder.readWord(eventSize, false);
+		int length = coder.readWord(4, false);
+
+		// Flash 6
+		if ((event &amp; KeyPress) != 0)
+		{
+			keyCode = coder.readWord(1, false);
+			length -= 1;
+		}
+		// End Flash 6
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			FSActionObject action;
+			int start;
+
+			actions = new ArrayList();
+
+			while (length &gt; 0)
+			{
+				start = coder.getPointer();
+
+				action = FSMovie.decodeAction(coder);
+				actions.add(action);
+				length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+
+				/*
+				 * The following code is to fix an apparent bug in Flash CS3
+				 * where the offset to the next clip event is 1 byte larger than
+				 * it should be.
+				 */
+
+				if (action.getType() == FSAction.End &amp;&amp; length == 1)
+				{
+					break;
+				}
+			}
+		} else
+		{
+			encodedActions = new byte[length];
+			coder.readBytes(encodedActions);
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSCoder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoder.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSCoder.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,1081 +33,1202 @@
 import java.io.*;
 
 /**
- * FSCoder is a similar to Java stream classes, allowing words and bit fields 
- * to be read and written from an internal array of bytes. FSCoder supports both 
+ * FSCoder is a similar to Java stream classes, allowing words and bit fields to
+ * be read and written from an internal array of bytes. FSCoder supports both
  * little-endian and big-endian byte ordering.
  * 
- * The FSCoder class maintains an internal pointer which points to the next bit 
- * in the internal array where data will be read or written. When calculating an 
- * offset in bytes to jump to simply multiply the offset by 8 for the correct 
- * bit position. The class provides accessor methods, getPointer() and 
+ * The FSCoder class maintains an internal pointer which points to the next bit
+ * in the internal array where data will be read or written. When calculating an
+ * offset in bytes to jump to simply multiply the offset by 8 for the correct
+ * bit position. The class provides accessor methods, getPointer() and
  * setPointer() to change the location of the internal pointer.
  * 
- * When writing to an array the size of the array is changed dynamically should 
- * a write operation cause a buffer overflow. For reads if an overflow results 
- * then the bits/bytes that overflowed will be set to zero, rather than throwing 
- * an exception. The eof() method can be used to determine whether the end of 
+ * When writing to an array the size of the array is changed dynamically should
+ * a write operation cause a buffer overflow. For reads if an overflow results
+ * then the bits/bytes that overflowed will be set to zero, rather than throwing
+ * an exception. The eof() method can be used to determine whether the end of
  * the buffer has been reached.
  */
-public class FSCoder 
+public class FSCoder
 {
-    /** 
-     * Identifies that multibyte words are stored in little-endian format with 
-     * the least significant byte in a word stored first.
-     */
-    public static final int LITTLE_ENDIAN = 0;
-    /** 
-     * Identifies that multibyte words are stored in big-endian format with the 
-     * most significant byte in a word stored first.
-     */
-    public static final int BIG_ENDIAN = 1;
+	/**
+	 * Identifies that multibyte words are stored in little-endian format with
+	 * the least significant byte in a word stored first.
+	 */
+	public static final int LITTLE_ENDIAN = 0;
 
-    /*
-     * Methods used to calculate the size of fields when encoded.
-     */
-    
-    /**
-     * Calculates the minimum number of bits required to encoded an integer
-     * in a bit field.
-     * 
-     * @param value the value to be encoded.
-     * 
-     * @param signed where the value will be encoded as a signed or unsigned
-     * integer.
-     * 
-     * @return the number of bits required to encode the value.
-     */
-    static int size(int value, boolean signed)
-    {
-        int size = 0, i = 0;
-        int mask = 0x80000000;
-        
-        if (signed)
-        {            
-            value = (value &lt; 0) ? -value : value;
-            for (i=32; (value &amp; mask) == 0 &amp;&amp; i&gt;0; i--)
-                mask &gt;&gt;&gt;= 1;
-            size = (i &lt; 32) ? i+1 : i;
-        }
-        else
-        {
-            for (i=32; (value &amp; mask) == 0 &amp;&amp; i&gt;0; i--)
-                mask &gt;&gt;&gt;= 1;
-            size = i;
-        }
-        return size;
-    }
-    /**
-     * Calculates the minimum number of bits required to encoded an array of
-     * integer values in a series of bit fields.
-     * 
-     * @param values the values to be encoded.
-     * 
-     * @param signed where the values will be encoded as a signed or unsigned
-     * integers.
-     * 
-     * @return the minimum number of bits required to encode all the values.
-     */
-    static int size(int[] values, boolean signed)
-    {
-        int size = 0;
-        
-        for (int i=0; i&lt;values.length; i++)
-            size = Math.max(size, size(values[i], signed));
+	/**
+	 * Identifies that multibyte words are stored in big-endian format with the
+	 * most significant byte in a word stored first.
+	 */
+	public static final int BIG_ENDIAN = 1;
 
-        return size;
-    }
-    /**
-     * Calculates the minimum number of bits required to encoded a floating
-     * point number as a fixed point number in 8.8 format. 
-     * 
-     * @param value the value to be encoded.
-     * 
-     * @return the number of bits required to encode the value.
-     */
-    static int fixedShortSize(float aNumber)
-    {
-        float floatValue = aNumber * 256.0f;
-        
-        return size((int)floatValue, true);
-    }
-    /**
-     * Calculates the minimum number of bits required to encoded a series of
-     * floating point numbers in a fixed point number in 8.8 format. 
-     * 
-     * @param value the values to be encoded.
-     * 
-     * @return the minimum number of bits required to encode all the values.
-     */
-    static int fixedShortSize(float[] values)
-    {
-        int size = 0;
-        
-        for (int i=0; i&lt;values.length; i++)
-            size = Math.max(size, fixedShortSize(values[i]));
+	/*
+	 * Methods used to calculate the size of fields when encoded.
+	 */
 
-        return size;
-    }
-    /**
-     * Calculates the minimum number of bits required to encoded a floating
-     * point number as a fixed point number in 16.16 format. 
-     * 
-     * @param value the value to be encoded.
-     * 
-     * @return the number of bits required to encode the value.
-    */
-    static int fixedSize(float aNumber)
-    {
-        float floatValue = aNumber * 65536.0f;
-        
-        return size((int)floatValue, true);
-    }
-    /**
-     * Calculates the minimum number of bits required to encoded a series of
-     * floating point numbers in a fixed point number in 16.16 format. 
-     * 
-     * @param value the values to be encoded.
-     * 
-     * @return the number of bits required to encode the value.
-     */
-    static int fixedSize(float[] values)
-    {
-        int size = 0;
-        
-        for (int i=0; i&lt;values.length; i++)
-            size = Math.max(size, fixedSize(values[i]));
+	/**
+	 * Calculates the minimum number of bits required to encoded an integer in a
+	 * bit field.
+	 * 
+	 * @param value
+	 *            the value to be encoded.
+	 * 
+	 * @param signed
+	 *            where the value will be encoded as a signed or unsigned
+	 *            integer.
+	 * 
+	 * @return the number of bits required to encode the value.
+	 */
+	static int size(int value, boolean signed)
+	{
+		int size = 0, i = 0;
+		int mask = 0x80000000;
 
-        return size;
-    }
-    /**
-     * Calculates the length of a string when encoded.
-     * 
-     * @param string the string to be encoded.
-     * 
-     * @param encoding the format used to encode the string characters.
-     * 
-     * @param appendNull whether the string should be terminated with a null
-     * byte.
-     * 
-     * @return the number of bytes required to encode the string.
-     */
-    static int strlen(String string, String encoding, boolean appendNull)
-    {    
-        int length = 0;
-        
-        if (string != null)
-        {
-            try 
-            {
-                length += string.getBytes(encoding).length;
-                length += appendNull ? 1 : 0;
-            }
-            catch (UnsupportedEncodingException e) 
-            {
-            }
-        }
-        return length;
-    }
-    /**
-     * Calculates the length of a string when encoded.
-     * 
-     * @param string the string to be encoded.
-     * 
-     * @param appendNull whether the string should be terminated with a null
-     * byte.
-     * 
-     * @return the number of bytes required to encode the string.
-     */
-    static int strlen(String string, boolean appendNull)
-    {    
-        int length = 0;
-        
-        if (string != null)
-        {
-            try 
-            {
-                length += string.getBytes(&quot;UTF8&quot;).length;
-                length += appendNull ? 1 : 0;
-            }
-            catch (UnsupportedEncodingException e) 
-            {
-            }
-        }
-        return length;
-    }
-    
-    private FSMovieListener listener = null;
-    
-    String encoding = &quot;UTF8&quot;;
-    
-    private int byteOrder = LITTLE_ENDIAN;
-    private byte[] data = null;
-    private int ptr = 0;
-    private int end = 0;
-    
-    /**
-     * Constructs an FSCoder object containing an array of bytes with the 
-     * specified byte ordering.
-     * 
-     * @param order the byte-order for words, eitherLITTLE_ENDIAN or BIG_ENDIAN.
-     * @param size the size of the internal buffer to be created.
-     */
-    public FSCoder(int order, int size)
-    {
-        clearContext();
-            
-        byteOrder = order;
-        data = new byte[size];
-        
-        for (int i=0; i&lt;size; i++)
-           data[i] = 0;
-       
-        ptr = 0;
-        end = data.length &lt;&lt; 3;
-    }
-    /**
-     * Constructs an FSCoder object containing an array of bytes with the
-     * specified byte order.
-     * 
-     * @param order the byte-order for words, either LITTLE_ENDIAN or BIG_ENDIAN.
-     * @param bytes an array of bytes where the data will be read or written.
-     */
-    public FSCoder(int order, byte[] bytes)
-    {
-        clearContext();
-            
-        byteOrder = order;
-        data = bytes;
-        ptr = 0;
-        end = data.length &lt;&lt; 3;
-    }
+		if (signed)
+		{
+			value = (value &lt; 0) ? -value : value;
+			for (i = 32; (value &amp; mask) == 0 &amp;&amp; i &gt; 0; i--)
+				mask &gt;&gt;&gt;= 1;
+			size = (i &lt; 32) ? i + 1 : i;
+		} else
+		{
+			for (i = 32; (value &amp; mask) == 0 &amp;&amp; i &gt; 0; i--)
+				mask &gt;&gt;&gt;= 1;
+			size = i;
+		}
+		return size;
+	}
 
-    public boolean equals(FSCoder coder)
-    {
-        boolean result = true;
+	/**
+	 * Calculates the minimum number of bits required to encoded an array of
+	 * integer values in a series of bit fields.
+	 * 
+	 * @param values
+	 *            the values to be encoded.
+	 * 
+	 * @param signed
+	 *            where the values will be encoded as a signed or unsigned
+	 *            integers.
+	 * 
+	 * @return the minimum number of bits required to encode all the values.
+	 */
+	static int size(int[] values, boolean signed)
+	{
+		int size = 0;
 
-        result = result &amp;&amp; byteOrder == coder.byteOrder;
-        result = result &amp;&amp; ptr == coder.ptr;
+		for (int i = 0; i &lt; values.length; i++)
+			size = Math.max(size, size(values[i], signed));
 
-        for (int i=0; i&lt;data.length; i++) {
-            result = result &amp;&amp; data[i] == coder.data[i];
-        }
+		return size;
+	}
 
-        return result;
-    }
-        
-    /**
-     * @deprecated The FSMovieListener interface does not enable recovery from
-     * coding errors or corrupt Flash files and therefore will no longer be 
-     * used. Instead errors will be reported through exceptions.
-     */ 
-    void setListener(FSMovieListener aListener) 
-    {
-        listener = aListener;
-    }
-    /**
-     * @deprecated The FSMovieListener interface does not enable recovery from
-     * coding errors or corrupt Flash files and therefore will no longer be 
-     * used. Instead errors will be reported through exceptions.
-     */ 
-    FSMovieListener getListener()
-    { 
-       return listener; 
-    }
-    /**
-     * @deprecated
-     * 
-     * @param name
-     */
-    void beginObject(String name)
-    {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Begin, ptr, 0, name));
-    }
-    /**
-     * @deprecated
-     * 
-     * @param name
-     */
-    void endObject(String name)
-    {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.End, ptr, 0, name));
-    }
-    /**
-     * @deprecated
-     * 
-     */
-    void logValue(Object anObject, int location, int numberOfBits)
-    {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Value, location, numberOfBits, anObject));
-    }
-    /**
-     * @deprecated
-     * 
-     */
-    void logError(String errorKey, int location, int length)
-    {
-        if (listener != null)
-            listener.logEvent(new FSMovieEvent(context[FSCoder.Action], FSMovieEvent.Error, location, length, errorKey));
-    }
-    
-    /**
-     * Return the string representation of the character encoding scheme used
-     * when encoding or decoding strings as a sequence of bytes.
-     * 
-     * @return the string the name of the encoding scheme for characters.
-     */
-    public String getEncoding()
-    {
-        return encoding;
-    }
-    /**
-     * Sets the string representation of the character encoding scheme used
-     * when encoding or decoding strings as a sequence of bytes.
-     * 
-     * @param enc the string the name of the encoding scheme for characters.
-     */
-    public void setEncoding(String enc)
-    {
-        encoding = enc;
-    }
+	/**
+	 * Calculates the minimum number of bits required to encoded a floating
+	 * point number as a fixed point number in 8.8 format.
+	 * 
+	 * @param value
+	 *            the value to be encoded.
+	 * 
+	 * @return the number of bits required to encode the value.
+	 */
+	static int fixedShortSize(float aNumber)
+	{
+		float floatValue = aNumber * 256.0f;
 
-    /*
-     * Methods for accessing the encoded data
-     */
+		return size((int) floatValue, true);
+	}
 
-    /**
-     * Returns a copy of the array of bytes.
-     * 
-     * @return a copy of the internal buffer.
-     */
-    public byte[] getData()
-    {
-        int length = (ptr + 7) &gt;&gt; 3;
-        
-        byte[] bytes = new byte[length];
-        System.arraycopy(data, 0, bytes, 0, length);
-        
-        return bytes;
-    }    
-    /**
-     * Sets the array of bytes used to read or write data to.
-     * 
-     * @param order the byte-order for words, either FSCoder.LITTLE_ENDIAN or 
-     * FSCoder.BIG_ENDIAN.
-     * 
-     * @param bytes a byte array that will be used as the internal buffer.
-     */
-    public void setData(int order, byte[] bytes)
-    {
-        byteOrder = order;
-        data = new byte[bytes.length];
-        System.arraycopy(bytes, 0, data, 0, bytes.length);
+	/**
+	 * Calculates the minimum number of bits required to encoded a series of
+	 * floating point numbers in a fixed point number in 8.8 format.
+	 * 
+	 * @param value
+	 *            the values to be encoded.
+	 * 
+	 * @return the minimum number of bits required to encode all the values.
+	 */
+	static int fixedShortSize(float[] values)
+	{
+		int size = 0;
 
-        ptr = 0;
-        end = data.length &lt;&lt; 3;
-    }
-    /**
-     * Increases the size of the internal buffer. This method is used when 
-     * encoding data to automatically adjust the buffer size to avoid overflows.
-     *  
-     * @param size the number of bytes to add to the buffer.
-     */
-    public void addCapacity(int size)
-    {
-        int length = (end &gt;&gt;&gt; 3) + size;
-        byte[] bytes = new byte[length];
-        
-        System.arraycopy(data, 0, bytes, 0, data.length);
-        data = bytes;
-        
-        end = data.length &lt;&lt; 3;
-    }
-    
-   /**
-    * Return the size of the internal buffer in bytes.
-    * 
-    * @return the size of the buffer.
-    */
-    public int getCapacity()
-    {
-        return end &gt;&gt;&gt; 3;
-    }
-    
-    /*
-     * Methods for adjusting the location from where data is read or written
-     */
-    /**
-     * Returns the offset, in bits, from the start of the buffer where the next 
-     * value will be read or written.
-     * 
-     * @return the offset in bits where the next value will be read or written. 
-     */
-    public int getPointer()
-    {
-        return ptr;
-    }
-    /**
-     * Sets the offset, in bits, from the start of the buffer where the next 
-     * value will be read or written. If the offset falls outside of the bits 
-     * range supported by the buffer then an IllegalArgumentException will
-     * be thrown.
-     *  
-     * @param location the offset in bits from the start of the array of bytes.
-     */
-    public void setPointer(int location)
-    {
-        if (location &lt; 0) {
-        	location = 0;
-        }
-        else if (location &gt; end) {
-        	location = end;
-        }
+		for (int i = 0; i &lt; values.length; i++)
+			size = Math.max(size, fixedShortSize(values[i]));
 
-        ptr = location;
-    }
-    /**
-     * Adds offset, in bits, to the internal pointer to change the location 
-     * where the next value will be read or written. If the adjust causes the 
-     * point to fall outside the bounds of the internal data then the value 
-     * is clamped to either the start of end of the array.
-     *  
-     * @param offset the offset in bits from the start of the array of bytes.
-     */
-    public void adjustPointer(int offset)
-    {
-        ptr += offset;
+		return size;
+	}
 
-        if (ptr &lt; 0)
-            ptr = 0;
-        else if (ptr &gt;= end)
-            ptr = end;
-    }
-    /**
-     * Moves the internal pointer forward so it is aligned on a byte boundary. 
-     * All word values read and written to the internal buffer must be 
-     * byte-aligned.
-     */
-    public void alignToByte()
-    {
-        ptr = (ptr+7) &amp; ~7;
-    }
-    /**
-     * Returns true of the internal pointer is at the end of the buffer.
-     * 
-     * @return true if the pointer is at the end of the buffer, false otherwise.
-     */
-    public boolean eof()
-    {
-        return ptr &gt;= end;
-    }
-    
-    /*
-     * Core methods for reading and writing bits and multibyte words
-     */
-    
-    /**
-     * Read a bit field from the internal buffer.
-     * 
-     * If a buffer overflow would occur then the bits which would cause the 
-     * error when read will be set to zero.
-     * 
-     * @param numberOfBits the number of bits to read.
-     * 
-     * @param signed a boolean flag indicating whether the value read should 
-     * be sign extended.
-     * 
-     * @return the value read.
-     */    
-    public int readBits(int numberOfBits, boolean signed)
-    {
-        int value = 0;
-        
-        if (numberOfBits &lt; 0 || numberOfBits &gt; 32)
-            throw new IllegalArgumentException(&quot;Number of bits must be in the range 1..32.&quot;);
-        
-        if (numberOfBits == 0)
-            return 0;
-        
-        int index = ptr &gt;&gt; 3;
-        int base = (data.length - index &gt; 4) ? 0 : (4 - (data.length - index))*8;
-        
-        for (int i=32; i&gt;base; i-=8, index++)
-            value |= (data[index] &amp; 0x000000FF) &lt;&lt; (i-8);
+	/**
+	 * Calculates the minimum number of bits required to encoded a floating
+	 * point number as a fixed point number in 16.16 format.
+	 * 
+	 * @param value
+	 *            the value to be encoded.
+	 * 
+	 * @return the number of bits required to encode the value.
+	 */
+	static int fixedSize(float aNumber)
+	{
+		float floatValue = aNumber * 65536.0f;
 
-        value &lt;&lt;= ptr % 8;
+		return size((int) floatValue, true);
+	}
 
-        if (signed)
-            value &gt;&gt;= 32 - numberOfBits;
-        else 
-            value &gt;&gt;&gt;= 32 - numberOfBits;
+	/**
+	 * Calculates the minimum number of bits required to encoded a series of
+	 * floating point numbers in a fixed point number in 16.16 format.
+	 * 
+	 * @param value
+	 *            the values to be encoded.
+	 * 
+	 * @return the number of bits required to encode the value.
+	 */
+	static int fixedSize(float[] values)
+	{
+		int size = 0;
 
-        ptr += numberOfBits;
+		for (int i = 0; i &lt; values.length; i++)
+			size = Math.max(size, fixedSize(values[i]));
 
-        if (ptr &gt; (data.length &lt;&lt; 3))
-            ptr = data.length &lt;&lt; 3;
+		return size;
+	}
 
-        return value;
-    }
-    /**
-     * Write a bit value to the internal buffer. The buffer will resize 
-     * automatically if required.
-     * 
-     * @param value an integer containing the value to be written.
-     * @param numberOfBits the least significant n bits from the value that 
-     * will be written to the buffer.
-     */
-    public void writeBits(int value, int numberOfBits)
-    {
-        if (numberOfBits &lt; 0 || numberOfBits &gt; 32)
-            throw new IllegalArgumentException(&quot;Number of bits must be in the range 1..32.&quot;);
-        
-        if (ptr+32 &gt; end)
-            addCapacity(data.length/2+4);
-        
-        int index = ptr &gt;&gt; 3;
+	/**
+	 * Calculates the length of a string when encoded.
+	 * 
+	 * @param string
+	 *            the string to be encoded.
+	 * 
+	 * @param encoding
+	 *            the format used to encode the string characters.
+	 * 
+	 * @param appendNull
+	 *            whether the string should be terminated with a null byte.
+	 * 
+	 * @return the number of bytes required to encode the string.
+	 */
+	static int strlen(String string, String encoding, boolean appendNull)
+	{
+		int length = 0;
 
-        value &lt;&lt;= (32 - numberOfBits);    
-        value = value &gt;&gt;&gt; (ptr % 8);
-        value = value | (data[index] &lt;&lt; 24);
+		if (string != null)
+		{
+			try
+			{
+				length += string.getBytes(encoding).length;
+				length += appendNull ? 1 : 0;
+			} catch (UnsupportedEncodingException e)
+			{
+			}
+		}
+		return length;
+	}
 
-        for (int i=24; i&gt;=0; i-=8, index++)
-            data[index] = (byte)(value &gt;&gt;&gt; i);
-        
-        ptr += numberOfBits;
+	/**
+	 * Calculates the length of a string when encoded.
+	 * 
+	 * @param string
+	 *            the string to be encoded.
+	 * 
+	 * @param appendNull
+	 *            whether the string should be terminated with a null byte.
+	 * 
+	 * @return the number of bytes required to encode the string.
+	 */
+	static int strlen(String string, boolean appendNull)
+	{
+		int length = 0;
 
-        if (ptr &gt; (data.length &lt;&lt; 3))
-            ptr = data.length &lt;&lt; 3;
-    }
-    /**
-     * Read a word from the internal buffer.
-     * 
-     * If a buffer overflow would occur then the bytes which would cause the 
-     * error when read will be set to zero.
-     * 
-     * @param numberOfBytes the number of bytes read in the range 1..4.
-     * 
-     * @param signed a boolean flag indicating whether the value read should be 
-     * sign extended.
-     * 
-     * @return the value read.
-     */
-    public int readWord(int numberOfBytes, boolean signed)
-    {
-        int value = 0;
-        
-        if (numberOfBytes &lt; 0 || numberOfBytes &gt; 4)
-            throw new IllegalArgumentException(&quot;Number of bytes must be in the range 1..4.&quot;);
-        
-        int index = ptr &gt;&gt; 3;
-        
-        if (index + numberOfBytes &gt; data.length)
-            numberOfBytes = data.length - index;
-        
-        int numberOfBits = numberOfBytes*8;
+		if (string != null)
+		{
+			try
+			{
+				length += string.getBytes(&quot;UTF8&quot;).length;
+				length += appendNull ? 1 : 0;
+			} catch (UnsupportedEncodingException e)
+			{
+			}
+		}
+		return length;
+	}
 
-        if (byteOrder == LITTLE_ENDIAN)
-        {
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, index++)
-                value += (data[index] &amp; 0x000000FF) &lt;&lt; i;
-        }
-        else
-        {
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, index++)
-            {
-                value = value &lt;&lt; 8;
-                value += data[index] &amp; 0x000000FF;
-            }
-        }
-        
-        if (signed)
-        {
-            value &lt;&lt;= 32 - numberOfBits;
-            value &gt;&gt;= 32 - numberOfBits;
-        }
+	private FSMovieListener listener = null;
 
-        return value;
-    }
-    /**
-     * Write a word to the internal buffer. The buffer will resize automatically
-     * if required.
-     * 
-     * @param value an integer containing the value to be written.
-     * @param numberOfBytes the least significant n bytes from the value that 
-     * will be written to the buffer.
-     */
-    public void writeWord(int value, int numberOfBytes)
-    {
-        if (numberOfBytes &lt; 0 || numberOfBytes &gt; 4)
-            throw new IllegalArgumentException(&quot;Number of bytes must be in the range 1..4.&quot;);
-            
-        int numberOfBits = numberOfBytes*8;
-        
-        if (ptr+numberOfBits &gt; end)
-            addCapacity(data.length/2+numberOfBytes);
-        
-        if (byteOrder == LITTLE_ENDIAN)
-        {
-            int index = ptr &gt;&gt;&gt; 3;
-            
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, value &gt;&gt;&gt;= 8, index++)
-                data[index] = (byte)value;
-        }
-        else
-        {
-            int index = (ptr + numberOfBits - 8) &gt;&gt;&gt; 3;
-            
-            for (int i=0; i&lt;numberOfBits; i+=8, ptr+=8, value &gt;&gt;&gt;= 8, index--)
-                data[index] = (byte)value;
-        }
-    }
-    /**
-     * Reads an array of bytes from the internal buffer. If a read overflow 
-     * would occur while reading the internal buffer then the remaining bytes 
-     * in the array will not be filled. The method returns the number of bytes 
-     * read.
-     * 
-     * @param bytes the array that will contain the bytes read.
-     * @return the number of bytes read from the buffer.
-     */
-    public int readBytes(byte[] bytes)
-    {
-        int bytesRead = 0;
-        
-        if (bytes == null || bytes.length == 0)
-            return bytesRead;
+	String encoding = &quot;UTF8&quot;;
+	private int byteOrder = LITTLE_ENDIAN;
+	private byte[] data = null;
+	private int ptr = 0;
+	private int end = 0;
 
-        int index = ptr &gt;&gt;&gt; 3;
-        int numberOfBytes = bytes.length;
-        
-        if (index + numberOfBytes &gt; data.length)
-            numberOfBytes = data.length - index;
+	/**
+	 * Constructs an FSCoder object containing an array of bytes with the
+	 * specified byte ordering.
+	 * 
+	 * @param order
+	 *            the byte-order for words, eitherLITTLE_ENDIAN or BIG_ENDIAN.
+	 * @param size
+	 *            the size of the internal buffer to be created.
+	 */
+	public FSCoder(int order, int size)
+	{
+		clearContext();
 
-        for (int i=0; i&lt;numberOfBytes; i++, ptr+=8, index++, bytesRead++)
-            bytes[i] = data[index];
+		byteOrder = order;
+		data = new byte[size];
 
-        return bytesRead;
-    }
-    /**
-     * Writes an array of bytes from the internal buffer. The internal buffer 
-     * will be resized automatically if required.
-     * 
-     * @param bytes the array containing the data to be written.
-     * @return the number of bytes written to the buffer.
-     */
-    public int writeBytes(byte[] bytes)
-    {
-        int bytesWritten = 0;
-        
-        if (ptr+(bytes.length &lt;&lt; 3) &gt; end)
-            addCapacity(data.length/2+bytes.length);
-        
-        if (bytes == null || bytes.length == 0)
-            return bytesWritten;
+		for (int i = 0; i &lt; size; i++)
+			data[i] = 0;
 
-        int index = ptr &gt;&gt;&gt; 3;
-        int numberOfBytes = bytes.length;
+		ptr = 0;
+		end = data.length &lt;&lt; 3;
+	}
 
-        for (int i=0; i&lt;numberOfBytes; i++, ptr+=8, index++, bytesWritten++)
-            data[index] = bytes[i];
-        
-        return bytesWritten;
-    }
-    
-    /*
-     * Methods to lookahead at the data without reading.
-     */
-    /**
-     * Read a bit field without adjusting the internal pointer.
-     * 
-     * @param numberOfBits the number of bits to read.
-     * 
-     * @param signed a boolean flag indicating whether the value read should 
-     * be sign extended.
-     * 
-     * @return the value read.
-     */
-    public int scanBits(int numberOfBits, boolean signed)
-    {
-        int start = ptr;
-        int value = readBits(numberOfBits, signed);
-        ptr = start;
-        
-        return value;
-    }
-    /**
-     * Read a word without adjusting the internal pointer.
-     * 
-     * @param numberOfBytes the number of bytes to read.
-     * 
-     * @param signed a boolean flag indicating whether the value read should 
-     * be sign extended.
-     * 
-     * @return the value read.
-     */
-    public int scanWord(int numberOfBytes, boolean signed)
-    {
-        int start = ptr;
-        int value = readWord(numberOfBytes, signed);
-        ptr = start;
-        
-        return value;
-    }
-    
-    /*
-     * Methods for accessing fixed point (8.8) and (16.16) values.
-     */
-    /**
-     * Read a fixed point number, in either (8.8) or (16.16) format from a bit 
-     * field.
-     * 
-     * @param numberOfBits the number of bits the number is encoded in.
-     * @param fractionSize the number of bits occupied by the fractional
-     * part of the number. The integer part will be signed extended.
-     * 
-     * @return the value read as a floating-point number.
-     */    
-    public float readFixedBits(int numberOfBits, int fractionSize)
-    {
-        float divisor = (float)(1 &lt;&lt; fractionSize);    
-        float value = ((float)readBits(numberOfBits, true)) / divisor;
-    
-        return value;
-    }
-    /**
-     * Write a fixed point number, in either (8.8) or (16.16) format to a bit 
-     * field.
-     * 
-     * @param value the value to be ecoded.
-     * @param numberOfBits the number of bits the number is encoded in.
-     * @param fractionSize the number of bits occupied by the fractional
-     * part of the number. The integer part will be signed extended.
-     */    
-    public void writeFixedBits(float value, int numberOfBits, int fractionSize)
-    {
-        float multiplier = (float)(1 &lt;&lt; fractionSize);   
-        writeBits((int)(value*multiplier), numberOfBits);
-    }
-    /**
-     * Read a fixed point number, in either (8.8) or (16.16) format from a 
-     * word field, accounting for the byte-ordering used.
-     * 
-     * @param mantissaSize the number of bits occupied by the integer
-     * part of the number. This will be signed extended.
-     * @param fractionSize the number of bits occupied by the fractional
-     * part of the number.
-     * 
-     * @return the value read as a floating-point number.
-     */    
-    public float readFixedWord(int mantissaSize, int fractionSize)
-    {
-        float divisor = (float)(1 &lt;&lt; (fractionSize*8));    
-        int fraction = readWord(fractionSize, false);
-        int mantissa = readWord(mantissaSize, true) &lt;&lt; (fractionSize*8);
-        
-        return (mantissa + fraction) / divisor;
-    }
-    /**
-     * Write a fixed point number, in either (8.8) or (16.16) format to a 
-     * word field, accounting for the byte-ordering used.
-     * 
-     * @param value the value to be written.
-     * @param mantissaSize the number of bits occupied by the integer
-     * part of the number.
-     * @param fractionSize the number of bits occupied by the fractional
-     * part of the number.
-     */    
-    public void writeFixedWord(float value, int mantissaSize, int fractionSize)
-    {
-        float multiplier = (float)(1 &lt;&lt; (fractionSize*8));   
-        int fraction = (int)(value*multiplier);
-        int mantissa = (int)value;
+	/**
+	 * Constructs an FSCoder object containing an array of bytes with the
+	 * specified byte order.
+	 * 
+	 * @param order
+	 *            the byte-order for words, either LITTLE_ENDIAN or BIG_ENDIAN.
+	 * @param bytes
+	 *            an array of bytes where the data will be read or written.
+	 */
+	public FSCoder(int order, byte[] bytes)
+	{
+		clearContext();
 
-        writeWord(fraction, fractionSize);
-        writeWord(mantissa, mantissaSize);
-    }
-    
-    /*
-     * Methods for reading specific data types
-     */
-    
-    /**
-     * Read a double-precision floating point number from a sequence of bytes
-     * using the byte-ordering of the buffer.
-     * 
-     * @return the value.
-     */
-    public double readDouble()
-    {
-        int upperInt = readWord(4, false);
-        int lowerInt = readWord(4, false);
-    
-        long longValue = (long)upperInt &lt;&lt; 32;
-        longValue |= (long)lowerInt &amp; 0x00000000FFFFFFFFL;
-    
-        return Double.longBitsToDouble(longValue);
-    }
-    /**
-     * Write a double-precision floating point number as a sequence of bytes
-     * using the byte-ordering of the buffer.
-     * 
-     * @param value the value to be written.
-     */
-    public void writeDouble(double value)
-    {
-        long longValue = Double.doubleToLongBits(value);
-    
-        int lowerInt = (int)longValue;
-        int upperInt = (int)(longValue &gt;&gt;&gt; 32);
-    
-        writeWord(upperInt, 4);
-        writeWord(lowerInt, 4);
-    }
-    /**
-     * Read a string containing the specified number of characters using the 
-     * default character encoding scheme.
-     * 
-     * @param length the number of characters to read.
-     * 
-     * @return the string containing the specified number of characters.
-     */
-    public String readString(int length)
-    {
-        return readString(length, encoding);
-    }
-    /**
-     * Read a string containing the specified number of characters with the  
-     * given character encoding scheme.
-     * 
-     * @param length the number of characters to read.
-     * @return enc, the string the name of the encoding schemd for characters.
-     * 
-     * @return the string containing the specified number of characters.
-     */
-    public String readString(int length, String enc)
-    {
-        if (length == 0)
-            return &quot;&quot;;
-            
-        String value = null;
-        byte[] str = new byte[length];
-    
-        int len = readBytes(str);
-        
-        try { 
-            value = new String(str, 0, len, enc); 
-        }
-        catch (java.io.UnsupportedEncodingException e) 
-        {
-            value = &quot;&quot;;
-        }
-        return value;
-    }
-    /**
-     * Read a null-terminated string using the default character encoding scheme.
-     * 
-     * @return the string read from the internal buffer.
-     */
-    public String readString()
-    {
-        return readString(encoding);
-    }
-    /**
-     * Read a null-terminated string using the specified character encoding scheme.
-     * 
-     * @return the string read from the internal buffer.
-     */
-    public String readString(String enc)
-    {
-        String value = null;
-    
-        int start = ptr&gt;&gt;3;
-        int length = 0;
-    
-        while (start &lt; data.length &amp;&amp; data[start++] != 0) length++;
-    
-        byte[] str = new byte[length];
-        int len = readBytes(str);
+		byteOrder = order;
+		data = bytes;
+		ptr = 0;
+		end = data.length &lt;&lt; 3;
+	}
 
-        try { 
-            value = new String(str, 0, len, enc); 
-        }
-        catch (java.io.UnsupportedEncodingException e) 
-        {
-            value = &quot;&quot;;
-        }
+	public boolean equals(FSCoder coder)
+	{
+		boolean result = true;
 
-        readWord(1, false);
-        len++;
-    
-        return value;
-    }
-    /**
-     * Write a string to the internal buffer using the default character 
-     * encoding scheme.
-     * 
-     * @param str the string.
-     * 
-     * @return the number of bytes written.
-     */
-    public int writeString(String str)
-    {            
-        return writeString(str, encoding);
-    }
-    /**
-     * Write a string to the internal buffer using the specified character 
-     * encoding scheme.
-     * 
-     * @param str the string.
-     * 
-     * @return the number of bytes written.
-     */
-    public int writeString(String str, String enc)
-    {            
-        int bytesWritten = 0;
+		result = result &amp;&amp; byteOrder == coder.byteOrder;
+		result = result &amp;&amp; ptr == coder.ptr;
 
-        try 
-        {
-            bytesWritten = writeBytes(str.getBytes(enc)); 
-        }
-        catch (java.io.UnsupportedEncodingException e) 
-        {
-        }
-        return bytesWritten;
-    }
+		for (int i = 0; i &lt; data.length; i++)
+		{
+			result = result &amp;&amp; data[i] == coder.data[i];
+		}
 
-    /*
-     * Methods for searching the data
-     */
-    
-    /**
-     * Searches the internal buffer for a bit pattern and advances the pointer 
-     * to the start of the bit field, returning true to signal a successful 
-     * search. If the bit pattern cannot be found then the method returns false 
-     * and the position of the internal pointer is not changed.
-     * 
-     * The step, in bits, added to the pointer can be specified, allowing the
-     * number of bits being searched to be independent of the location in the 
-     * internal buffer. This is useful for example when searching for a bit 
-     * field that begins on a byte or word boundary.
-     *  
-     * @param value an integer containing the bit patter to search for.
-     * @param numberOfBits least significant n bits in the value to search for.
-     * @param step the increment in bits to add to the internal pointer as the 
-     * buffer is searched.
-     * 
-     * @return true if the pattern was found, false otherwise.
-     */
-    public boolean findBits(int value, int numberOfBits, int step)
-    {
-        boolean found = false;
-        int start = ptr;
-        
-        for (; ptr &lt; end; ptr += step)
-        {
-            if (scanBits(numberOfBits, false) == value)
-            {
-                found = true;
-                break;
-            }
-        }
-        if (found == false)
-            ptr = start;
-            
-        return found;
-    }
-    /**
-     * Searches the internal buffer for a word and advances the pointer to the 
-     * location where the word was found, returning true to signal a successful 
-     * search. The search will begin on the next byte boundary. If word cannot 
-     * be found then the method returns false and the position of the internal 
-     * pointer is not changed.
-     * 
-     * Specifying the number of bytes in the search value allows word of either 
-     * 8, 16, 24 or 32 bits to be searched for. Searches for words are performed 
-     * faster than using the findBits() method.
-     * 
-     * @param value an integer containing the word to search for.
-     * 
-     * @param numberOfBytes least significant n bytes in the value to search 
-     * for.
-     * 
-     * @param step the increment in bits to add to the internal pointer as the 
-     * buffer is searched.
-     * 
-     * @return true if the pattern was found, false otherwise.
-     */
-    public boolean findWord(int value, int numberOfBytes, int step)
-    {
-        boolean found = false;
-        
-        for (; ptr &lt; end; ptr += step)
-        {
-            if (scanWord(numberOfBytes, false) == value)
-            {
-                found = true;
-                break;
-            }
-        }
-        return found;
-    }
+		return result;
+	}
 
-    /*
-     * Context variables are used to pass information between objects when
-     * they are being encoded or decoded. Context variables are primarily 
-     * used within the Transform classes however they are also used when 
-     * performing unit tests on classes.
-     */
-    
-    /**
-     * TransparentColors is used to pass information to FSCOlor objects when
-     * they are being encoded or decoded so that the alpha channel will be 
-     * included.
-     */
-    public static final int TransparentColors = 0;
+	/**
+	 * @deprecated The FSMovieListener interface does not enable recovery from
+	 *             coding errors or corrupt Flash files and therefore will no
+	 *             longer be used. Instead errors will be reported through
+	 *             exceptions.
+	 */
+	void setListener(FSMovieListener aListener)
+	{
+		listener = aListener;
+	}
 
-    static final int Action = 1;
-    /**
-     * Version is used to pass the current version of Flash that an object is 
-     * being encoded or decoded for.
-     */
-    public static final int Version = 2;
-    static final int Type = 3;
-    static final int Empty = 4;
-    static final int Identifier = 5;
-    static final int NumberOfFillBits = 6;
-    static final int NumberOfLineBits = 7;
-    static final int NumberOfAdvanceBits = 8;
-    static final int NumberOfGlyphBits = 9;
-    static final int NumberOfShapeBits = 10;
-    static final int ArrayCountExtended = 11;
-    static final int WideCodes = 12;
-    static final int Delta = 13;
-    static final int CodingError = 14;
-    static final int TypeInError = 15;
-    static final int StartOfError = 16;
-    static final int ExpectedLength = 17;
-    static final int DecodeActions = 18;
-    static final int DecodeShapes = 19;
-    static final int DecodeGlyphs = 20;
+	/**
+	 * @deprecated The FSMovieListener interface does not enable recovery from
+	 *             coding errors or corrupt Flash files and therefore will no
+	 *             longer be used. Instead errors will be reported through
+	 *             exceptions.
+	 */
+	FSMovieListener getListener()
+	{
+		return listener;
+	}
 
-    int[] context = new int[21];
-    
-    private void clearContext()
-    {
-        for (int i=0; i&lt;context.length; i++)
-            context[i] = 0;
-    }
-    
-    public int getContext(int key)
-    {
-        return context[key];
-    }
-    
-    public void setContext(int key, int value)
-    {
-        context[key] = value;
-    }
+	/**
+	 * @deprecated
+	 * 
+	 * @param name
+	 */
+	void beginObject(String name)
+	{
+		if (listener != null)
+			listener.logEvent(new FSMovieEvent(context[FSCoder.Action],
+							FSMovieEvent.Begin, ptr, 0, name));
+	}
+
+	/**
+	 * @deprecated
+	 * 
+	 * @param name
+	 */
+	void endObject(String name)
+	{
+		if (listener != null)
+			listener.logEvent(new FSMovieEvent(context[FSCoder.Action],
+							FSMovieEvent.End, ptr, 0, name));
+	}
+
+	/**
+	 * @deprecated
+	 * 
+	 */
+	void logValue(Object anObject, int location, int numberOfBits)
+	{
+		if (listener != null)
+			listener.logEvent(new FSMovieEvent(context[FSCoder.Action],
+							FSMovieEvent.Value, location, numberOfBits,
+							anObject));
+	}
+
+	/**
+	 * @deprecated
+	 * 
+	 */
+	void logError(String errorKey, int location, int length)
+	{
+		if (listener != null)
+			listener.logEvent(new FSMovieEvent(context[FSCoder.Action],
+							FSMovieEvent.Error, location, length, errorKey));
+	}
+
+	/**
+	 * Return the string representation of the character encoding scheme used
+	 * when encoding or decoding strings as a sequence of bytes.
+	 * 
+	 * @return the string the name of the encoding scheme for characters.
+	 */
+	public String getEncoding()
+	{
+		return encoding;
+	}
+
+	/**
+	 * Sets the string representation of the character encoding scheme used when
+	 * encoding or decoding strings as a sequence of bytes.
+	 * 
+	 * @param enc
+	 *            the string the name of the encoding scheme for characters.
+	 */
+	public void setEncoding(String enc)
+	{
+		encoding = enc;
+	}
+
+	/*
+	 * Methods for accessing the encoded data
+	 */
+
+	/**
+	 * Returns a copy of the array of bytes.
+	 * 
+	 * @return a copy of the internal buffer.
+	 */
+	public byte[] getData()
+	{
+		int length = (ptr + 7) &gt;&gt; 3;
+
+		byte[] bytes = new byte[length];
+		System.arraycopy(data, 0, bytes, 0, length);
+
+		return bytes;
+	}
+
+	/**
+	 * Sets the array of bytes used to read or write data to.
+	 * 
+	 * @param order
+	 *            the byte-order for words, either FSCoder.LITTLE_ENDIAN or
+	 *            FSCoder.BIG_ENDIAN.
+	 * 
+	 * @param bytes
+	 *            a byte array that will be used as the internal buffer.
+	 */
+	public void setData(int order, byte[] bytes)
+	{
+		byteOrder = order;
+		data = new byte[bytes.length];
+		System.arraycopy(bytes, 0, data, 0, bytes.length);
+
+		ptr = 0;
+		end = data.length &lt;&lt; 3;
+	}
+
+	/**
+	 * Increases the size of the internal buffer. This method is used when
+	 * encoding data to automatically adjust the buffer size to avoid overflows.
+	 * 
+	 * @param size
+	 *            the number of bytes to add to the buffer.
+	 */
+	public void addCapacity(int size)
+	{
+		int length = (end &gt;&gt;&gt; 3) + size;
+		byte[] bytes = new byte[length];
+
+		System.arraycopy(data, 0, bytes, 0, data.length);
+		data = bytes;
+
+		end = data.length &lt;&lt; 3;
+	}
+
+	/**
+	 * Return the size of the internal buffer in bytes.
+	 * 
+	 * @return the size of the buffer.
+	 */
+	public int getCapacity()
+	{
+		return end &gt;&gt;&gt; 3;
+	}
+
+	/*
+	 * Methods for adjusting the location from where data is read or written
+	 */
+	/**
+	 * Returns the offset, in bits, from the start of the buffer where the next
+	 * value will be read or written.
+	 * 
+	 * @return the offset in bits where the next value will be read or written.
+	 */
+	public int getPointer()
+	{
+		return ptr;
+	}
+
+	/**
+	 * Sets the offset, in bits, from the start of the buffer where the next
+	 * value will be read or written. If the offset falls outside of the bits
+	 * range supported by the buffer then an IllegalArgumentException will be
+	 * thrown.
+	 * 
+	 * @param location
+	 *            the offset in bits from the start of the array of bytes.
+	 */
+	public void setPointer(int location)
+	{
+		if (location &lt; 0)
+		{
+			location = 0;
+		} else if (location &gt; end)
+		{
+			location = end;
+		}
+
+		ptr = location;
+	}
+
+	/**
+	 * Adds offset, in bits, to the internal pointer to change the location
+	 * where the next value will be read or written. If the adjust causes the
+	 * point to fall outside the bounds of the internal data then the value is
+	 * clamped to either the start of end of the array.
+	 * 
+	 * @param offset
+	 *            the offset in bits from the start of the array of bytes.
+	 */
+	public void adjustPointer(int offset)
+	{
+		ptr += offset;
+
+		if (ptr &lt; 0)
+			ptr = 0;
+		else if (ptr &gt;= end)
+			ptr = end;
+	}
+
+	/**
+	 * Moves the internal pointer forward so it is aligned on a byte boundary.
+	 * All word values read and written to the internal buffer must be
+	 * byte-aligned.
+	 */
+	public void alignToByte()
+	{
+		ptr = (ptr + 7) &amp; ~7;
+	}
+
+	/**
+	 * Returns true of the internal pointer is at the end of the buffer.
+	 * 
+	 * @return true if the pointer is at the end of the buffer, false otherwise.
+	 */
+	public boolean eof()
+	{
+		return ptr &gt;= end;
+	}
+
+	/*
+	 * Core methods for reading and writing bits and multibyte words
+	 */
+
+	/**
+	 * Read a bit field from the internal buffer.
+	 * 
+	 * If a buffer overflow would occur then the bits which would cause the
+	 * error when read will be set to zero.
+	 * 
+	 * @param numberOfBits
+	 *            the number of bits to read.
+	 * 
+	 * @param signed
+	 *            a boolean flag indicating whether the value read should be
+	 *            sign extended.
+	 * 
+	 * @return the value read.
+	 */
+	public int readBits(int numberOfBits, boolean signed)
+	{
+		int value = 0;
+
+		if (numberOfBits &lt; 0 || numberOfBits &gt; 32)
+			throw new IllegalArgumentException(
+							&quot;Number of bits must be in the range 1..32.&quot;);
+
+		if (numberOfBits == 0)
+			return 0;
+
+		int index = ptr &gt;&gt; 3;
+		int base = (data.length - index &gt; 4) ? 0
+						: (4 - (data.length - index)) * 8;
+
+		for (int i = 32; i &gt; base; i -= 8, index++)
+			value |= (data[index] &amp; 0x000000FF) &lt;&lt; (i - 8);
+
+		value &lt;&lt;= ptr % 8;
+
+		if (signed)
+			value &gt;&gt;= 32 - numberOfBits;
+		else
+			value &gt;&gt;&gt;= 32 - numberOfBits;
+
+		ptr += numberOfBits;
+
+		if (ptr &gt; (data.length &lt;&lt; 3))
+			ptr = data.length &lt;&lt; 3;
+
+		return value;
+	}
+
+	/**
+	 * Write a bit value to the internal buffer. The buffer will resize
+	 * automatically if required.
+	 * 
+	 * @param value
+	 *            an integer containing the value to be written.
+	 * @param numberOfBits
+	 *            the least significant n bits from the value that will be
+	 *            written to the buffer.
+	 */
+	public void writeBits(int value, int numberOfBits)
+	{
+		if (numberOfBits &lt; 0 || numberOfBits &gt; 32)
+			throw new IllegalArgumentException(
+							&quot;Number of bits must be in the range 1..32.&quot;);
+
+		if (ptr + 32 &gt; end)
+			addCapacity(data.length / 2 + 4);
+
+		int index = ptr &gt;&gt; 3;
+
+		value &lt;&lt;= (32 - numberOfBits);
+		value = value &gt;&gt;&gt; (ptr % 8);
+		value = value | (data[index] &lt;&lt; 24);
+
+		for (int i = 24; i &gt;= 0; i -= 8, index++)
+			data[index] = (byte) (value &gt;&gt;&gt; i);
+
+		ptr += numberOfBits;
+
+		if (ptr &gt; (data.length &lt;&lt; 3))
+			ptr = data.length &lt;&lt; 3;
+	}
+
+	/**
+	 * Read a word from the internal buffer.
+	 * 
+	 * If a buffer overflow would occur then the bytes which would cause the
+	 * error when read will be set to zero.
+	 * 
+	 * @param numberOfBytes
+	 *            the number of bytes read in the range 1..4.
+	 * 
+	 * @param signed
+	 *            a boolean flag indicating whether the value read should be
+	 *            sign extended.
+	 * 
+	 * @return the value read.
+	 */
+	public int readWord(int numberOfBytes, boolean signed)
+	{
+		int value = 0;
+
+		if (numberOfBytes &lt; 0 || numberOfBytes &gt; 4)
+			throw new IllegalArgumentException(
+							&quot;Number of bytes must be in the range 1..4.&quot;);
+
+		int index = ptr &gt;&gt; 3;
+
+		if (index + numberOfBytes &gt; data.length)
+			numberOfBytes = data.length - index;
+
+		int numberOfBits = numberOfBytes * 8;
+
+		if (byteOrder == LITTLE_ENDIAN)
+		{
+			for (int i = 0; i &lt; numberOfBits; i += 8, ptr += 8, index++)
+				value += (data[index] &amp; 0x000000FF) &lt;&lt; i;
+		} else
+		{
+			for (int i = 0; i &lt; numberOfBits; i += 8, ptr += 8, index++)
+			{
+				value = value &lt;&lt; 8;
+				value += data[index] &amp; 0x000000FF;
+			}
+		}
+
+		if (signed)
+		{
+			value &lt;&lt;= 32 - numberOfBits;
+			value &gt;&gt;= 32 - numberOfBits;
+		}
+
+		return value;
+	}
+
+	/**
+	 * Write a word to the internal buffer. The buffer will resize automatically
+	 * if required.
+	 * 
+	 * @param value
+	 *            an integer containing the value to be written.
+	 * @param numberOfBytes
+	 *            the least significant n bytes from the value that will be
+	 *            written to the buffer.
+	 */
+	public void writeWord(int value, int numberOfBytes)
+	{
+		if (numberOfBytes &lt; 0 || numberOfBytes &gt; 4)
+			throw new IllegalArgumentException(
+							&quot;Number of bytes must be in the range 1..4.&quot;);
+
+		int numberOfBits = numberOfBytes * 8;
+
+		if (ptr + numberOfBits &gt; end)
+			addCapacity(data.length / 2 + numberOfBytes);
+
+		if (byteOrder == LITTLE_ENDIAN)
+		{
+			int index = ptr &gt;&gt;&gt; 3;
+
+			for (int i = 0; i &lt; numberOfBits; i += 8, ptr += 8, value &gt;&gt;&gt;= 8, index++)
+				data[index] = (byte) value;
+		} else
+		{
+			int index = (ptr + numberOfBits - 8) &gt;&gt;&gt; 3;
+
+			for (int i = 0; i &lt; numberOfBits; i += 8, ptr += 8, value &gt;&gt;&gt;= 8, index--)
+				data[index] = (byte) value;
+		}
+	}
+
+	/**
+	 * Reads an array of bytes from the internal buffer. If a read overflow
+	 * would occur while reading the internal buffer then the remaining bytes in
+	 * the array will not be filled. The method returns the number of bytes
+	 * read.
+	 * 
+	 * @param bytes
+	 *            the array that will contain the bytes read.
+	 * @return the number of bytes read from the buffer.
+	 */
+	public int readBytes(byte[] bytes)
+	{
+		int bytesRead = 0;
+
+		if (bytes == null || bytes.length == 0)
+			return bytesRead;
+
+		int index = ptr &gt;&gt;&gt; 3;
+		int numberOfBytes = bytes.length;
+
+		if (index + numberOfBytes &gt; data.length)
+			numberOfBytes = data.length - index;
+
+		for (int i = 0; i &lt; numberOfBytes; i++, ptr += 8, index++, bytesRead++)
+			bytes[i] = data[index];
+
+		return bytesRead;
+	}
+
+	/**
+	 * Writes an array of bytes from the internal buffer. The internal buffer
+	 * will be resized automatically if required.
+	 * 
+	 * @param bytes
+	 *            the array containing the data to be written.
+	 * @return the number of bytes written to the buffer.
+	 */
+	public int writeBytes(byte[] bytes)
+	{
+		int bytesWritten = 0;
+
+		if (ptr + (bytes.length &lt;&lt; 3) &gt; end)
+			addCapacity(data.length / 2 + bytes.length);
+
+		if (bytes == null || bytes.length == 0)
+			return bytesWritten;
+
+		int index = ptr &gt;&gt;&gt; 3;
+		int numberOfBytes = bytes.length;
+
+		for (int i = 0; i &lt; numberOfBytes; i++, ptr += 8, index++, bytesWritten++)
+			data[index] = bytes[i];
+
+		return bytesWritten;
+	}
+
+	/*
+	 * Methods to lookahead at the data without reading.
+	 */
+	/**
+	 * Read a bit field without adjusting the internal pointer.
+	 * 
+	 * @param numberOfBits
+	 *            the number of bits to read.
+	 * 
+	 * @param signed
+	 *            a boolean flag indicating whether the value read should be
+	 *            sign extended.
+	 * 
+	 * @return the value read.
+	 */
+	public int scanBits(int numberOfBits, boolean signed)
+	{
+		int start = ptr;
+		int value = readBits(numberOfBits, signed);
+		ptr = start;
+
+		return value;
+	}
+
+	/**
+	 * Read a word without adjusting the internal pointer.
+	 * 
+	 * @param numberOfBytes
+	 *            the number of bytes to read.
+	 * 
+	 * @param signed
+	 *            a boolean flag indicating whether the value read should be
+	 *            sign extended.
+	 * 
+	 * @return the value read.
+	 */
+	public int scanWord(int numberOfBytes, boolean signed)
+	{
+		int start = ptr;
+		int value = readWord(numberOfBytes, signed);
+		ptr = start;
+
+		return value;
+	}
+
+	/*
+	 * Methods for accessing fixed point (8.8) and (16.16) values.
+	 */
+	/**
+	 * Read a fixed point number, in either (8.8) or (16.16) format from a bit
+	 * field.
+	 * 
+	 * @param numberOfBits
+	 *            the number of bits the number is encoded in.
+	 * @param fractionSize
+	 *            the number of bits occupied by the fractional part of the
+	 *            number. The integer part will be signed extended.
+	 * 
+	 * @return the value read as a floating-point number.
+	 */
+	public float readFixedBits(int numberOfBits, int fractionSize)
+	{
+		float divisor = (float) (1 &lt;&lt; fractionSize);
+		float value = ((float) readBits(numberOfBits, true)) / divisor;
+
+		return value;
+	}
+
+	/**
+	 * Write a fixed point number, in either (8.8) or (16.16) format to a bit
+	 * field.
+	 * 
+	 * @param value
+	 *            the value to be ecoded.
+	 * @param numberOfBits
+	 *            the number of bits the number is encoded in.
+	 * @param fractionSize
+	 *            the number of bits occupied by the fractional part of the
+	 *            number. The integer part will be signed extended.
+	 */
+	public void writeFixedBits(float value, int numberOfBits, int fractionSize)
+	{
+		float multiplier = (float) (1 &lt;&lt; fractionSize);
+		writeBits((int) (value * multiplier), numberOfBits);
+	}
+
+	/**
+	 * Read a fixed point number, in either (8.8) or (16.16) format from a word
+	 * field, accounting for the byte-ordering used.
+	 * 
+	 * @param mantissaSize
+	 *            the number of bits occupied by the integer part of the number.
+	 *            This will be signed extended.
+	 * @param fractionSize
+	 *            the number of bits occupied by the fractional part of the
+	 *            number.
+	 * 
+	 * @return the value read as a floating-point number.
+	 */
+	public float readFixedWord(int mantissaSize, int fractionSize)
+	{
+		float divisor = (float) (1 &lt;&lt; (fractionSize * 8));
+		int fraction = readWord(fractionSize, false);
+		int mantissa = readWord(mantissaSize, true) &lt;&lt; (fractionSize * 8);
+
+		return (mantissa + fraction) / divisor;
+	}
+
+	/**
+	 * Write a fixed point number, in either (8.8) or (16.16) format to a word
+	 * field, accounting for the byte-ordering used.
+	 * 
+	 * @param value
+	 *            the value to be written.
+	 * @param mantissaSize
+	 *            the number of bits occupied by the integer part of the number.
+	 * @param fractionSize
+	 *            the number of bits occupied by the fractional part of the
+	 *            number.
+	 */
+	public void writeFixedWord(float value, int mantissaSize, int fractionSize)
+	{
+		float multiplier = (float) (1 &lt;&lt; (fractionSize * 8));
+		int fraction = (int) (value * multiplier);
+		int mantissa = (int) value;
+
+		writeWord(fraction, fractionSize);
+		writeWord(mantissa, mantissaSize);
+	}
+
+	/*
+	 * Methods for reading specific data types
+	 */
+
+	/**
+	 * Read a double-precision floating point number from a sequence of bytes
+	 * using the byte-ordering of the buffer.
+	 * 
+	 * @return the value.
+	 */
+	public double readDouble()
+	{
+		int upperInt = readWord(4, false);
+		int lowerInt = readWord(4, false);
+
+		long longValue = (long) upperInt &lt;&lt; 32;
+		longValue |= (long) lowerInt &amp; 0x00000000FFFFFFFFL;
+
+		return Double.longBitsToDouble(longValue);
+	}
+
+	/**
+	 * Write a double-precision floating point number as a sequence of bytes
+	 * using the byte-ordering of the buffer.
+	 * 
+	 * @param value
+	 *            the value to be written.
+	 */
+	public void writeDouble(double value)
+	{
+		long longValue = Double.doubleToLongBits(value);
+
+		int lowerInt = (int) longValue;
+		int upperInt = (int) (longValue &gt;&gt;&gt; 32);
+
+		writeWord(upperInt, 4);
+		writeWord(lowerInt, 4);
+	}
+
+	/**
+	 * Read a string containing the specified number of characters using the
+	 * default character encoding scheme.
+	 * 
+	 * @param length
+	 *            the number of characters to read.
+	 * 
+	 * @return the string containing the specified number of characters.
+	 */
+	public String readString(int length)
+	{
+		return readString(length, encoding);
+	}
+
+	/**
+	 * Read a string containing the specified number of characters with the
+	 * given character encoding scheme.
+	 * 
+	 * @param length
+	 *            the number of characters to read.
+	 * @return enc, the string the name of the encoding schemd for characters.
+	 * 
+	 * @return the string containing the specified number of characters.
+	 */
+	public String readString(int length, String enc)
+	{
+		if (length == 0)
+			return &quot;&quot;;
+
+		String value = null;
+		byte[] str = new byte[length];
+
+		int len = readBytes(str);
+
+		try
+		{
+			value = new String(str, 0, len, enc);
+		} catch (java.io.UnsupportedEncodingException e)
+		{
+			value = &quot;&quot;;
+		}
+		return value;
+	}
+
+	/**
+	 * Read a null-terminated string using the default character encoding
+	 * scheme.
+	 * 
+	 * @return the string read from the internal buffer.
+	 */
+	public String readString()
+	{
+		return readString(encoding);
+	}
+
+	/**
+	 * Read a null-terminated string using the specified character encoding
+	 * scheme.
+	 * 
+	 * @return the string read from the internal buffer.
+	 */
+	public String readString(String enc)
+	{
+		String value = null;
+
+		int start = ptr &gt;&gt; 3;
+		int length = 0;
+
+		while (start &lt; data.length &amp;&amp; data[start++] != 0)
+			length++;
+
+		byte[] str = new byte[length];
+		int len = readBytes(str);
+
+		try
+		{
+			value = new String(str, 0, len, enc);
+		} catch (java.io.UnsupportedEncodingException e)
+		{
+			value = &quot;&quot;;
+		}
+
+		readWord(1, false);
+		len++;
+
+		return value;
+	}
+
+	/**
+	 * Write a string to the internal buffer using the default character
+	 * encoding scheme.
+	 * 
+	 * @param str
+	 *            the string.
+	 * 
+	 * @return the number of bytes written.
+	 */
+	public int writeString(String str)
+	{
+		return writeString(str, encoding);
+	}
+
+	/**
+	 * Write a string to the internal buffer using the specified character
+	 * encoding scheme.
+	 * 
+	 * @param str
+	 *            the string.
+	 * 
+	 * @return the number of bytes written.
+	 */
+	public int writeString(String str, String enc)
+	{
+		int bytesWritten = 0;
+
+		try
+		{
+			bytesWritten = writeBytes(str.getBytes(enc));
+		} catch (java.io.UnsupportedEncodingException e)
+		{
+		}
+		return bytesWritten;
+	}
+
+	/*
+	 * Methods for searching the data
+	 */
+
+	/**
+	 * Searches the internal buffer for a bit pattern and advances the pointer
+	 * to the start of the bit field, returning true to signal a successful
+	 * search. If the bit pattern cannot be found then the method returns false
+	 * and the position of the internal pointer is not changed.
+	 * 
+	 * The step, in bits, added to the pointer can be specified, allowing the
+	 * number of bits being searched to be independent of the location in the
+	 * internal buffer. This is useful for example when searching for a bit
+	 * field that begins on a byte or word boundary.
+	 * 
+	 * @param value
+	 *            an integer containing the bit patter to search for.
+	 * @param numberOfBits
+	 *            least significant n bits in the value to search for.
+	 * @param step
+	 *            the increment in bits to add to the internal pointer as the
+	 *            buffer is searched.
+	 * 
+	 * @return true if the pattern was found, false otherwise.
+	 */
+	public boolean findBits(int value, int numberOfBits, int step)
+	{
+		boolean found = false;
+		int start = ptr;
+
+		for (; ptr &lt; end; ptr += step)
+		{
+			if (scanBits(numberOfBits, false) == value)
+			{
+				found = true;
+				break;
+			}
+		}
+		if (found == false)
+			ptr = start;
+
+		return found;
+	}
+
+	/**
+	 * Searches the internal buffer for a word and advances the pointer to the
+	 * location where the word was found, returning true to signal a successful
+	 * search. The search will begin on the next byte boundary. If word cannot
+	 * be found then the method returns false and the position of the internal
+	 * pointer is not changed.
+	 * 
+	 * Specifying the number of bytes in the search value allows word of either
+	 * 8, 16, 24 or 32 bits to be searched for. Searches for words are performed
+	 * faster than using the findBits() method.
+	 * 
+	 * @param value
+	 *            an integer containing the word to search for.
+	 * 
+	 * @param numberOfBytes
+	 *            least significant n bytes in the value to search for.
+	 * 
+	 * @param step
+	 *            the increment in bits to add to the internal pointer as the
+	 *            buffer is searched.
+	 * 
+	 * @return true if the pattern was found, false otherwise.
+	 */
+	public boolean findWord(int value, int numberOfBytes, int step)
+	{
+		boolean found = false;
+
+		for (; ptr &lt; end; ptr += step)
+		{
+			if (scanWord(numberOfBytes, false) == value)
+			{
+				found = true;
+				break;
+			}
+		}
+		return found;
+	}
+
+	/*
+	 * Context variables are used to pass information between objects when they
+	 * are being encoded or decoded. Context variables are primarily used within
+	 * the Transform classes however they are also used when performing unit
+	 * tests on classes.
+	 */
+
+	/**
+	 * TransparentColors is used to pass information to FSCOlor objects when
+	 * they are being encoded or decoded so that the alpha channel will be
+	 * included.
+	 */
+	public static final int TransparentColors = 0;
+
+	static final int Action = 1;
+
+	/**
+	 * Version is used to pass the current version of Flash that an object is
+	 * being encoded or decoded for.
+	 */
+	public static final int Version = 2;
+
+	static final int Type = 3;
+
+	static final int Empty = 4;
+
+	static final int Identifier = 5;
+
+	static final int NumberOfFillBits = 6;
+
+	static final int NumberOfLineBits = 7;
+
+	static final int NumberOfAdvanceBits = 8;
+
+	static final int NumberOfGlyphBits = 9;
+
+	static final int NumberOfShapeBits = 10;
+
+	static final int ArrayCountExtended = 11;
+
+	static final int WideCodes = 12;
+
+	static final int Delta = 13;
+
+	static final int CodingError = 14;
+
+	static final int TypeInError = 15;
+
+	static final int StartOfError = 16;
+
+	static final int ExpectedLength = 17;
+
+	static final int DecodeActions = 18;
+
+	static final int DecodeShapes = 19;
+
+	static final int DecodeGlyphs = 20;
+
+	int[] context = new int[21];
+
+	private void clearContext()
+	{
+		for (int i = 0; i &lt; context.length; i++)
+			context[i] = 0;
+	}
+
+	public int getContext(int key)
+	{
+		return context[key];
+	}
+
+	public void setContext(int key, int value)
+	{
+		context[key] = value;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSCoderException.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoderException.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSCoderException.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -1,107 +1,120 @@
 package com.flagstone.transform;
 
 import java.io.IOException;
+
 /**
- * This exception is thrown when parse errors are encountered. 
- * ParseExceptions contain information about the error that prevented 
- * a file from being read and decoded. 
+ * This exception is thrown when parse errors are encountered. ParseExceptions
+ * contain information about the error that prevented a file from being read and
+ * decoded.
  */
 public class FSCoderException extends IOException
 {
-    private int type = 0;
-    private int start = 0;
-    private int length = 0;
-    private int delta = 0;
+	private int type = 0;
+	private int start = 0;
+	private int length = 0;
+	private int delta = 0;
 
-    /**
-     * Constructs an FSCoderException to report where a problem occured when 
-     * encoding or decoding a Flash (.swf) file.
-     * 
-     * @param type the type of object or action that was being encoded/decoded
-     * when the problem occurred.
-     * 
-     * @param start the address in the file where the data structure being 
-     * encoded/decoded is located. This is only valid for files being decoded
-     * since the encoded file will not be written if an exception occurs.
-     * 
-     * @param length the size in bytes that the data structure should take 
-     * when encoded.
-     * 
-     * @param delta the difference between the actual number of byes and the 
-     * expected length. This is negative for underflow errors and postive when
-     * the takes more bytes to encode/decode that the expected length.
-     * 
-     * @param message a message indicating the type of error - overflow or 
-     * underflow.
-     */
-    public FSCoderException(int type, int start, int length, int delta, String message)
-    {
-        super(message);
-        this.type = type;
-        this.start = start;
-        this.length = length;
-        this.delta = delta;
-    }
-    /**
-     * Returns the type identifying the FSMovieObject or FSActionObject that 
-     * caused the error.
-     * 
-     * @return the object type.
-     */
-    public int getType()
-    {
-        return type;
-    }
-    /**
-     * The byte address of the start of the object in the file being decoded.
-     * This address is not valid when encoding a Flash file since the file will
-     * probably not be encoded - though this is under the control of the software
-     * using Transform.
-     * 
-     * @return the address (offset) in bytes where the object is encoded.
-     */
-    public int getStart()
-    {
-        return start;
-    }
-    /**
-     * The calculated number of bytes the object will occupy when encoded.
-     * 
-     * @return the length in bytes that the object is expected to occupy when 
-     * encoded.
-     * 
-     */
-    public int getLength()
-    {
-        return length;
-    }
-    /**
-     * The difference between the calculated number of bytes and the actual 
-     * number of bytes when the object was encoded or decoded.
-     * 
-     * @return the difference between the actual and expected number of bytes
-     * encoded/decoded.
-     */
-    public int getDelta()
-    {
-        return delta;
-    }
-    /**
-     * Return a description of the error.
-     * 
-     * @return a string desscribing the error that caused the exception.
-     */
-    public String toString()
-    {
-        StringBuffer buffer = new StringBuffer();
-        
-        buffer.append(&quot;FSCoderException: { &quot;);
-        buffer.append(&quot;type = &quot;).append(type).append(&quot;, &quot;);
-        buffer.append(&quot;location = &quot;).append(start).append(&quot;, &quot;);
-        buffer.append(&quot;length = &quot;).append(length).append(&quot;, &quot;);
-        buffer.append(&quot;delta = &quot;).append(delta).append(&quot;, &quot;);
-        buffer.append(&quot;message = \&quot;&quot;).append(getMessage()).append(&quot;\&quot; }&quot;);
-        
-        return buffer.toString();
-    }
+	/**
+	 * Constructs an FSCoderException to report where a problem occurred when
+	 * encoding or decoding a Flash (.swf) file.
+	 * 
+	 * @param type
+	 *            the type of object or action that was being encoded/decoded
+	 *            when the problem occurred.
+	 * 
+	 * @param start
+	 *            the address in the file where the data structure being
+	 *            encoded/decoded is located. This is only valid for files being
+	 *            decoded since the encoded file will not be written if an
+	 *            exception occurs.
+	 * 
+	 * @param length
+	 *            the size in bytes that the data structure should take when
+	 *            encoded.
+	 * 
+	 * @param delta
+	 *            the difference between the actual number of byes and the
+	 *            expected length. This is negative for underflow errors and
+	 *            positive when the takes more bytes to encode/decode that the
+	 *            expected length.
+	 * 
+	 * @param message
+	 *            a message indicating the type of error - overflow or
+	 *            underflow.
+	 */
+	public FSCoderException(int type, int start, int length, int delta, String message)
+	{
+		super(message);
+		this.type = type;
+		this.start = start;
+		this.length = length;
+		this.delta = delta;
+	}
+
+	/**
+	 * Returns the type identifying the FSMovieObject or FSActionObject that
+	 * caused the error.
+	 * 
+	 * @return the object type.
+	 */
+	public int getType()
+	{
+		return type;
+	}
+
+	/**
+	 * The byte address of the start of the object in the file being decoded.
+	 * This address is not valid when encoding a Flash file since the file will
+	 * probably not be encoded - though this is under the control of the
+	 * software using Transform.
+	 * 
+	 * @return the address (offset) in bytes where the object is encoded.
+	 */
+	public int getStart()
+	{
+		return start;
+	}
+
+	/**
+	 * The calculated number of bytes the object will occupy when encoded.
+	 * 
+	 * @return the length in bytes that the object is expected to occupy when
+	 *         encoded.
+	 * 
+	 */
+	public int getLength()
+	{
+		return length;
+	}
+
+	/**
+	 * The difference between the calculated number of bytes and the actual
+	 * number of bytes when the object was encoded or decoded.
+	 * 
+	 * @return the difference between the actual and expected number of bytes
+	 *         encoded/decoded.
+	 */
+	public int getDelta()
+	{
+		return delta;
+	}
+
+	/**
+	 * Return a description of the error.
+	 * 
+	 * @return a string describing the error that caused the exception.
+	 */
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
+
+		buffer.append(&quot;FSCoderException: { &quot;);
+		buffer.append(&quot;type = &quot;).append(type).append(&quot;, &quot;);
+		buffer.append(&quot;location = &quot;).append(start).append(&quot;, &quot;);
+		buffer.append(&quot;length = &quot;).append(length).append(&quot;, &quot;);
+		buffer.append(&quot;delta = &quot;).append(delta).append(&quot;, &quot;);
+		buffer.append(&quot;message = \&quot;&quot;).append(getMessage()).append(&quot;\&quot; }&quot;);
+
+		return buffer.toString();
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSColor.java
===================================================================
--- trunk/src/com/flagstone/transform/FSColor.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSColor.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,270 +31,361 @@
 package com.flagstone.transform;
 
 /**
-FSColor is used to represent colours. 
- 
-&lt;p&gt;The FSColor class supports the RGB colour space with an optional alpha channel which is used to specify the transparency of an object. An FSColor object supports 32-bit colours with 8 bits per colour channel.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColor_0&quot;&gt;red&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The red channel of the colour, with values in the range 0..255.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColor_1&quot;&gt;green&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The green channel of the colour, with values in the range 0..255.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColor_2&quot;&gt;blue&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The blue channel of the colour, with values in the range 0..255.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColor_3&quot;&gt;alpha&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The alpha channel of the colour, with values in the range 0..255.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;Whether a colour contains transparency information is determined by the context created by the object that contains the colour. For example colours within the FSDefineShape and FSDefineShape2 objects do not contain alpha channel information while those in an FSDefineShape3 object do. To simplify the use of the colours only a single class is provided. The alpha channel can be ignored if not required within the object the colour is defined for. When a FSColor object is encoded or decoded the object notifies the colour objects it contains whether the alpha channel information should also be encoded or decoded. As of Version 5 of the Macromedia Flash (SWF) File Format Specification only the FSPlaceObject2, FSDefineText2 and FSDefineShape3 classes use colours containing an alpha channel.&lt;/p&gt;
-
-&lt;p&gt;The class provides a range of constructors to instantiate objects using colour information presented in a variety of formats. To create a colour, specifying values for colour channels in the following order: red, green, blue and optionally alpha:&lt;/p&gt;
-
-&lt;pre&gt;
-FSColor red = new FSColor(255, 0, 0);
-FSColor green = new FSColor(0, 255, 0);
-FSColor blue = new FSColor(0, 0, 255);
-&lt;/pre&gt;
-
-&lt;p&gt;When the alpha channel is not specified it defaults to a value of 255 which defines the colour to be completely opaque. For transparent colours the alpha channel determines how opaque the colour is. 0 represents a fully transparent colour and 255 is fully opaque.&lt;/p&gt;
-
-&lt;pre&gt;
-FSColor transparentRed = new FSColor(255, 0, 0, 128);
-FSColor transparentGreen = new FSColor(0, 255, 0, 128);
-FSColor transparentBlue = new FSColor(0, 0, 255, 128);
-&lt;/pre&gt;
-
-&lt;p&gt;When the alpha channel is not specified it defaults to a value of 255 which defines the colour to be completely opaque. The classes that contain colour objects control whether the value for the alpha channel is encoded. For example FSDefineShape and FSDefineShape2 support opaque colours while FSDefineShape3 supports transparent colours. If only opaque colours are supported then the alpha channel can be ignored when creating and manipulating FSColor objects.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;FSColor class represents the colour data types, RGB and RGBA in the Macromedia Flash (SWF) File Format Specification. The colour data structure was available was introduced in Flash 1 and transparent colours were introduced in Flash 3.&lt;/p&gt;
+ * FSColor is used to represent colours.
+ * 
+ * &lt;p&gt;
+ * The FSColor class supports the RGB colour space with an optional alpha
+ * channel which is used to specify the transparency of an object. An FSColor
+ * object supports 32-bit colours with 8 bits per colour channel.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;red&lt;/td&gt;
+ * &lt;td&gt;The red channel of the colour, with values in the range 0..255.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;green&lt;/td&gt;
+ * &lt;td&gt;The green channel of the colour, with values in the range 0..255.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;blue&lt;/td&gt;
+ * &lt;td&gt;The blue channel of the colour, with values in the range 0..255.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;alpha&lt;/td&gt;
+ * &lt;td&gt;The alpha channel of the colour, with values in the range 0..255.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Whether a colour contains transparency information is determined by the
+ * context created by the object that contains the colour. For example colours
+ * within the FSDefineShape and FSDefineShape2 objects do not contain alpha
+ * channel information while those in an FSDefineShape3 object do. To simplify
+ * the use of the colours only a single class is provided. The alpha channel can
+ * be ignored if not required within the object the colour is defined for. When
+ * a FSColor object is encoded or decoded the object notifies the colour objects
+ * it contains whether the alpha channel information should also be encoded or
+ * decoded. As of Version 5 of the Macromedia Flash (SWF) File Format
+ * Specification only the FSPlaceObject2, FSDefineText2 and FSDefineShape3
+ * classes use colours containing an alpha channel.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The class provides a range of constructors to instantiate objects using
+ * colour information presented in a variety of formats. To create a colour,
+ * specifying values for colour channels in the following order: red, green,
+ * blue and optionally alpha:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSColor red = new FSColor(255, 0, 0);
+ * 
+ * FSColor green = new FSColor(0, 255, 0);
+ * 
+ * FSColor blue = new FSColor(0, 0, 255);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * When the alpha channel is not specified it defaults to a value of 255 which
+ * defines the colour to be completely opaque. For transparent colours the alpha
+ * channel determines how opaque the colour is. 0 represents a fully transparent
+ * colour and 255 is fully opaque.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSColor transparentRed = new FSColor(255, 0, 0, 128);
+ * 
+ * FSColor transparentGreen = new FSColor(0, 255, 0, 128);
+ * 
+ * FSColor transparentBlue = new FSColor(0, 0, 255, 128);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * When the alpha channel is not specified it defaults to a value of 255 which
+ * defines the colour to be completely opaque. The classes that contain colour
+ * objects control whether the value for the alpha channel is encoded. For
+ * example FSDefineShape and FSDefineShape2 support opaque colours while
+ * FSDefineShape3 supports transparent colours. If only opaque colours are
+ * supported then the alpha channel can be ignored when creating and
+ * manipulating FSColor objects.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSColor class represents the colour data types, RGB and RGBA in the
+ * Macromedia Flash (SWF) File Format Specification. The colour data structure
+ * was available was introduced in Flash 1 and transparent colours were
+ * introduced in Flash 3.
+ * &lt;/p&gt;
  */
 public class FSColor extends FSTransformObject
 {
-    private int red = 0;
-    private int green = 0;
-    private int blue = 0;
-    private int alpha = 255;
+	private int red = 0;
+	private int green = 0;
+	private int blue = 0;
+	private int alpha = 255;
 
-    /**
-     * Construct an FSColor object and initialize it with values decoded from 
-     * a binary encoded FSColor object.
-     * 
-     * @param coder an FSCoder object containing an FSColor encoded as binary
-     * data.
-     */
-    public FSColor(FSCoder coder)
-    {
-        decode(coder);
-    }    
-    /** 
-     * Constructs an FSColor object containing red, green and blue channels. The
-     * alpha channel defaults to the value 255 - defining an opaque colour.
-     * 
-     * @param r value for the red channel, in the range 0..255.
-       @param g value for the green channel, in the range 0..255.
-       @param b value for the blue channel, in the range 0..255.
-        */     
-    public FSColor(int r, int g, int b)
-    {
-        setRed(r);
-        setGreen(g);
-        setBlue(b);
-    }
+	/**
+	 * Construct an FSColor object and initialise it with values decoded from a
+	 * binary encoded FSColor object.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSColor encoded as binary
+	 *            data.
+	 */
+	public FSColor(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    /** Constructs an FSColor object containing red, green, blue and alpha channels.
-     
-        @param r value for the red channel, in the range 0..255.
-        @param g value for the green channel, in the range 0..255.
-        @param b value for the blue channel, in the range 0..255.
-        @param a value for the alpha channel, in the range 0..255.
-     */
-    public FSColor(int r, int g, int b, int a)
-    {
-        setRed(r);
-        setGreen(g);
-        setBlue(b);
-        setAlpha(a);
-    }
-    /**
-     * Construct an FSColor object and initialize it with value from another 
-     * FSColor object.
-     * 
-     * @param obj an FSColor object.
-     */
-    public FSColor(FSColor obj)
-    {
-        red = obj.red;
-        green = obj.green;
-        blue = obj.blue;
-        alpha = obj.alpha;
-    }
+	/**
+	 * Constructs an FSColor object containing red, green and blue channels. The
+	 * alpha channel defaults to the value 255 - defining an opaque colour.
+	 * 
+	 * @param r
+	 *            value for the red channel, in the range 0..255.
+	 * @param g
+	 *            value for the green channel, in the range 0..255.
+	 * @param b
+	 *            value for the blue channel, in the range 0..255.
+	 */
+	public FSColor(int r, int g, int b)
+	{
+		setRed(r);
+		setGreen(g);
+		setBlue(b);
+	}
 
-    /** Gets the value for the red colour channel. 
+	/**
+	 * Constructs an FSColor object containing red, green, blue and alpha
+	 * channels.
+	 * 
+	 * @param r
+	 *            value for the red channel, in the range 0..255.
+	 * @param g
+	 *            value for the green channel, in the range 0..255.
+	 * @param b
+	 *            value for the blue channel, in the range 0..255.
+	 * @param a
+	 *            value for the alpha channel, in the range 0..255.
+	 */
+	public FSColor(int r, int g, int b, int a)
+	{
+		setRed(r);
+		setGreen(g);
+		setBlue(b);
+		setAlpha(a);
+	}
 
-        @return the value for the red channel in the range 0..255.
-        */    
-    public int getRed() { return red; }
+	/**
+	 * Construct an FSColor object and initialise it with value from another
+	 * FSColor object.
+	 * 
+	 * @param obj
+	 *            an FSColor object.
+	 */
+	public FSColor(FSColor obj)
+	{
+		red = obj.red;
+		green = obj.green;
+		blue = obj.blue;
+		alpha = obj.alpha;
+	}
 
-    /** Gets the value for the green colour channel. 
+	/**
+	 * Gets the value for the red colour channel.
+	 * 
+	 * @return the value for the red channel in the range 0..255.
+	 */
+	public int getRed()
+	{
+		return red;
+	}
 
-        @return the value for the green channel in the range 0..255.
-        */    
-    public int getGreen() { return green; }
+	/**
+	 * Gets the value for the green colour channel.
+	 * 
+	 * @return the value for the green channel in the range 0..255.
+	 */
+	public int getGreen()
+	{
+		return green;
+	}
 
-    /** Gets the value for the blue colour channel. 
+	/**
+	 * Gets the value for the blue colour channel.
+	 * 
+	 * @return the value for the blue channel in the range 0..255.
+	 */
+	public int getBlue()
+	{
+		return blue;
+	}
 
-        @return the value for the blue channel in the range 0..255.
-        */
-    public int getBlue() { return blue; }
+	/**
+	 * Gets the value for the alpha colour channel.
+	 * 
+	 * @return the value for the alpha channel in the range 0..255.
+	 */
+	public int getAlpha()
+	{
+		return alpha;
+	}
 
-    /** Gets the value for the alpha colour channel. 
+	/**
+	 * Set the value for the red colour channel.
+	 * 
+	 * @param r
+	 *            value for the red channel.
+	 */
+	public void setRed(int r)
+	{
+		red = r;
+	}
 
-        @return the value for the alpha channel in the range 0..255.
-        */
-    public int getAlpha() { return alpha; }
+	/**
+	 * Set the value for the green colour channel.
+	 * 
+	 * @param g
+	 *            value for the green channel.
+	 */
+	public void setGreen(int g)
+	{
+		green = g;
+	}
 
-    /** Set the value for the red colour channel. 
+	/**
+	 * Set the value for the blue colour channel.
+	 * 
+	 * @param b
+	 *            value for the blue channel, in the range 0..255.
+	 */
+	public void setBlue(int b)
+	{
+		blue = b;
+	}
 
-        @param r value for the red channel.
-        */    
-    public void setRed(int r)
-    {
-        red = r;
-    }
+	/**
+	 * Set the value for the alpha channel.
+	 * 
+	 * @param a
+	 *            value for the alpha channel, in the range 0..255.
+	 */
+	public void setAlpha(int a)
+	{
+		alpha = a;
+	}
 
-    /** Set the value for the green colour channel.
+	/**
+	 * Set the values for the red, green and blue colour channels. The alpha
+	 * channel is not changed.
+	 * 
+	 * @param r
+	 *            value for the red channel, in the range 0..255.
+	 * @param g
+	 *            value for the green channel, in the range 0..255.
+	 * @param b
+	 *            value for the blue channel, in the range 0..255.
+	 */
+	public void setChannels(int r, int g, int b)
+	{
+		setRed(r);
+		setGreen(g);
+		setBlue(b);
+	}
 
-        @param g value for the green channel.
-        */
-    public void setGreen(int g)
-    {
-        green = g;
-    }
+	/**
+	 * Set the values for each of the four colour channels.
+	 * 
+	 * @param r
+	 *            value for the red channel, in the range 0..255.
+	 * @param g
+	 *            value for the green channel, in the range 0..255.
+	 * @param b
+	 *            value for the blue channel, in the range 0..255.
+	 * @param a
+	 *            value for the alpha channel, in the range 0..255.
+	 */
+	public void setChannels(int r, int g, int b, int a)
+	{
+		setRed(r);
+		setGreen(g);
+		setBlue(b);
+		setAlpha(a);
+	}
 
-    /** Set the value for the blue colour channel.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-       @param b value for the blue channel, in the range 0..255.
-     */
-    public void setBlue(int b) 
-    {
-        blue = b;
-    }
+		if (super.equals(anObject))
+		{
+			FSColor typedObject = (FSColor) anObject;
 
-    /** Set the value for the alpha channel.
+			result = red == typedObject.red;
+			result = result &amp;&amp; green == typedObject.green;
+			result = result &amp;&amp; blue == typedObject.blue;
+			result = result &amp;&amp; alpha == typedObject.alpha;
+		}
+		return result;
+	}
 
-        @param a value for the alpha channel, in the range 0..255.
-    */
-    public void setAlpha(int a)
-    {
-        alpha = a;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Set the values for the red, green and blue colour channels. The alpha 
-     * channel is not changed.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;red&quot;, red);
+			Transform.append(buffer, &quot;green&quot;, green);
+			Transform.append(buffer, &quot;blue&quot;, blue);
+			Transform.append(buffer, &quot;alpha&quot;, alpha);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param r value for the red channel, in the range 0..255.
-        @param g value for the green channel, in the range 0..255.
-        @param b value for the blue channel, in the range 0..255.
-        */
-    public void setChannels(int r, int g, int b)
-    {
-        setRed(r);
-        setGreen(g);
-        setBlue(b);
-    }
-    
-    /** Set the values for each of the four colour channels.
-    
-        @param r value for the red channel, in the range 0..255.
-        @param g value for the green channel, in the range 0..255.
-        @param b value for the blue channel, in the range 0..255.
-        @param a value for the alpha channel, in the range 0..255.
-        */
-    public void setChannels(int r, int g, int b, int a)
-    {
-        setRed(r);
-        setGreen(g);
-        setBlue(b);
-        setAlpha(a);
-    }
+	public int length(FSCoder coder)
+	{
+		return (coder.context[FSCoder.TransparentColors] != 0) ? 4 : 3;
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSColor typedObject = (FSColor)anObject;
-            
-            result = red == typedObject.red;
-            result = result &amp;&amp; green == typedObject.green;
-            result = result &amp;&amp; blue == typedObject.blue;
-            result = result &amp;&amp; alpha == typedObject.alpha;
-        }
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(red, 1);
+		coder.writeWord(green, 1);
+		coder.writeWord(blue, 1);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		if (coder.context[FSCoder.TransparentColors] != 0)
+			coder.writeWord(alpha, 1);
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;red&quot;, red);
-            Transform.append(buffer, &quot;green&quot;, green);
-            Transform.append(buffer, &quot;blue&quot;, blue);
-            Transform.append(buffer, &quot;alpha&quot;, alpha);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void decode(FSCoder coder)
+	{
+		red = coder.readWord(1, false);
+		green = coder.readWord(1, false);
+		blue = coder.readWord(1, false);
 
-    public int length(FSCoder coder)
-    {
-        return (coder.context[FSCoder.TransparentColors] != 0) ? 4 : 3;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(red, 1);
-        coder.writeWord(green, 1);
-        coder.writeWord(blue, 1);
-    
-        if (coder.context[FSCoder.TransparentColors] != 0)
-            coder.writeWord(alpha, 1);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        red = coder.readWord(1, false);
-        green = coder.readWord(1, false);
-        blue = coder.readWord(1, false);
-        
-        if (coder.context[FSCoder.TransparentColors] != 0)
-            alpha = coder.readWord(1, false);
-    }
+		if (coder.context[FSCoder.TransparentColors] != 0)
+			alpha = coder.readWord(1, false);
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSColorTable.java
===================================================================
--- trunk/src/com/flagstone/transform/FSColorTable.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSColorTable.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,825 +30,2425 @@
 
 package com.flagstone.transform;
 
-/** 
- * The FSColorTable class contains a set of factory methods to generate FSColor objects 
- * for each of the colours defined in the Netscape Colour Table. 
- *
- * &lt;div class=&quot;code&quot;&gt;
- *        FSColor aColor = FSColorTable.%aliceblue();
- * &lt;/div&gt;
+/**
+ * The FSColorTable class contains a set of factory methods to generate FSColor
+ * objects for each of the colours defined in the Netscape Colour Table.
  * 
- * &lt;p&gt;Each entry in the colour table returns and array of integers that define the values 
- * for the red, green and blue colour channels. To define a transparent colour for use 
- * with an object that support transparent colours such as the FSDefineShape3 class use 
- * the following code fragment:&lt;/p&gt;
+ * &lt;div class=&quot;code&quot;&gt; FSColor aColor = FSColorTable.%aliceblue(); &lt;/div&gt;
  * 
- * &lt;div class=&quot;code&quot;&gt;
- *        FSColor aColor = FSColorTable.%aliceblue(128);
- * &lt;/div&gt;
+ * &lt;p&gt;
+ * Each entry in the colour table returns and array of integers that define the
+ * values for the red, green and blue colour channels. To define a transparent
+ * colour for use with an object that support transparent colours such as the
+ * FSDefineShape3 class use the following code fragment:
+ * &lt;/p&gt;
  * 
- * &lt;p&gt;Transparent colours are created by specifying the level of transparency, in the range 
- * 0..255, where 0 is completely transparent and 255 is completely opaque.&lt;/P&gt;
-
-\htmlonly
-&lt;center&gt;
-&lt;table BORDER=&quot;1&quot; BGCOLOR=&quot;#FFFFFF&quot; CELLPADDING=&quot;5&quot; CELLSPACING=&quot;4&quot; width=&quot;90%&quot;&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;aliceblue&quot; WIDTH=&quot;15%&quot;&gt;aliceblue&lt;BR&gt;F0F8FF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;antiquewhite&quot; WIDTH=&quot;15%&quot;&gt;antiquewhite&lt;BR&gt;FAEBD7&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;aqua&quot; WIDTH=&quot;15%&quot;&gt;aqua&lt;BR&gt;00FFFF&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;aquamarine&quot; WIDTH=&quot;15%&quot;&gt;aquamarine&lt;BR&gt;7FFFD4&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;azure&quot; WIDTH=&quot;15%&quot;&gt;azure&lt;BR&gt;F0FFFF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;beige&quot; WIDTH=&quot;15%&quot;&gt;beige&lt;BR&gt;F5F5DC&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;bisque&quot; WIDTH=&quot;15%&quot;&gt;bisque&lt;BR&gt;FFE4C4&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;burlywood&quot; WIDTH=&quot;15%&quot;&gt;burlywood&lt;BR&gt;DEB887&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;blanchedalmond&quot; WIDTH=&quot;15%&quot;&gt;blanchedalmond&lt;BR&gt;FFEBCD&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;blue&quot; WIDTH=&quot;15%&quot;&gt;blue&lt;BR&gt;0000FF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;bluevoilet&quot; WIDTH=&quot;15%&quot;&gt;blueviolet&lt;BR&gt;8A2BE2&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;brown&quot; WIDTH=&quot;15%&quot;&gt;brown&lt;BR&gt;A52A2A&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;black&quot; WIDTH=&quot;15%&quot;&gt;&lt;FONT COLOR=&quot;FFFFFF&quot;&gt;black&lt;BR&gt;000000&lt;/FONT&gt;&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cadetblue&quot; WIDTH=&quot;15%&quot;&gt;cadetblue&lt;BR&gt;5F9EA0&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;chartreuse&quot; WIDTH=&quot;15%&quot;&gt;chartreuse&lt;BR&gt;7FFF00&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;chocolate&quot; WIDTH=&quot;15%&quot;&gt;chocolate&lt;BR&gt;D2691E&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;coral&quot; WIDTH=&quot;15%&quot;&gt;coral&lt;BR&gt;FF7F50&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cornflowerblue&quot; WIDTH=&quot;15%&quot;&gt;cornflowerblue&lt;BR&gt;6495ED&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cornsilk&quot; WIDTH=&quot;15%&quot;&gt;cornsilk&lt;BR&gt;FFF8DC&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;crimson&quot; WIDTH=&quot;15%&quot;&gt;crimson&lt;BR&gt;DC143C&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cyan&quot; WIDTH=&quot;15%&quot;&gt;cyan&lt;BR&gt;00FFFF&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkblue&quot; WIDTH=&quot;15%&quot;&gt;darkblue&lt;BR&gt;00008B&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkcyan&quot; WIDTH=&quot;15%&quot;&gt;darkcyan&lt;BR&gt;008B8B&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkgoldenrod&quot; WIDTH=&quot;15%&quot;&gt;darkgoldenrod&lt;BR&gt;B8860B&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkgray&quot; WIDTH=&quot;15%&quot;&gt;darkgray&lt;BR&gt;A9A9A9&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkgreen&quot; WIDTH=&quot;15%&quot;&gt;darkgreen&lt;BR&gt;006400&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkkhaki&quot; WIDTH=&quot;15%&quot;&gt;darkkhaki&lt;BR&gt;BDB76B&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkmagenta&quot; WIDTH=&quot;15%&quot;&gt;darkmagenta&lt;BR&gt;8B008B&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkolivegreen&quot; WIDTH=&quot;15%&quot;&gt;darkolivegreen&lt;BR&gt;556B2F&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkorange&quot; WIDTH=&quot;15%&quot;&gt;darkorange&lt;BR&gt;FF8C00&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkorchid&quot; WIDTH=&quot;15%&quot;&gt;darkorchid&lt;BR&gt;9932CC&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkred&quot; WIDTH=&quot;15%&quot;&gt;darkred&lt;BR&gt;8B0000&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darksalmon&quot; WIDTH=&quot;15%&quot;&gt;darksalmon&lt;BR&gt;E9967A&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkseagreen&quot; WIDTH=&quot;15%&quot;&gt;darkseagreen&lt;BR&gt;8FBC8F&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkslateblue&quot; WIDTH=&quot;15%&quot;&gt;darkslateblue&lt;BR&gt;483D8B&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkslategray&quot; WIDTH=&quot;15%&quot;&gt;darkslategray&lt;BR&gt;2F4F4F&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkturquoise&quot; WIDTH=&quot;15%&quot;&gt;darkturquoise&lt;BR&gt;00CED1&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkviolet&quot; WIDTH=&quot;15%&quot;&gt;darkviolet&lt;BR&gt;9400D3&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;deeppink&quot; WIDTH=&quot;15%&quot;&gt;deeppink&lt;BR&gt;FF1493&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;deepskyblue&quot; WIDTH=&quot;15%&quot;&gt;deepskyblue&lt;BR&gt;00BFFF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;dimgray&quot; WIDTH=&quot;15%&quot;&gt;dimgray&lt;BR&gt;696969&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;dodgerblue&quot; WIDTH=&quot;15%&quot;&gt;dodgerblue&lt;BR&gt;1E90FF&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;firebrick&quot; WIDTH=&quot;15%&quot;&gt;firebrick&lt;BR&gt;B22222&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;floralwhite&quot; WIDTH=&quot;15%&quot;&gt;floralwhite&lt;BR&gt;FFFAF0&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;forestgreen&quot; WIDTH=&quot;15%&quot;&gt;forestgreen&lt;BR&gt;228B22&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;fuchsia&quot; WIDTH=&quot;15%&quot;&gt;fuchsia&lt;BR&gt;FF00FF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;gainsboro&quot; WIDTH=&quot;15%&quot;&gt;gainsboro&lt;BR&gt;DCDCDC&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;ghostwhite&quot; WIDTH=&quot;15%&quot;&gt;ghostwhite&lt;BR&gt;F8F8FF&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;gold&quot; WIDTH=&quot;15%&quot;&gt;gold&lt;BR&gt;FFD700&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;goldenrod&quot; WIDTH=&quot;15%&quot;&gt;goldenrod&lt;BR&gt;DAA520&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;gray&quot; WIDTH=&quot;15%&quot;&gt;gray&lt;BR&gt;808080&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;green&quot; WIDTH=&quot;15%&quot;&gt;green&lt;BR&gt;008000&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;greenyellow&quot; WIDTH=&quot;15%&quot;&gt;greenyellow&lt;BR&gt;ADFF2F&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;honeydew&quot; WIDTH=&quot;15%&quot;&gt;honeydew&lt;BR&gt;F0FFF0&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;hotpink&quot; WIDTH=&quot;15%&quot;&gt;hotpink&lt;BR&gt;FF69B4&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;indianred&quot; WIDTH=&quot;15%&quot;&gt;indianred&lt;BR&gt;CD5C5C&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;indigo&quot; WIDTH=&quot;15%&quot;&gt;Indigo&lt;BR&gt;4B0082&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;ivory&quot; WIDTH=&quot;15%&quot;&gt;ivory&lt;BR&gt;FFFFF0&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;khaki&quot; WIDTH=&quot;15%&quot;&gt;khaki&lt;BR&gt;F0E68C&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lavender&quot; WIDTH=&quot;15%&quot;&gt;lavender&lt;BR&gt;E6E6FA&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lavenderblush&quot; WIDTH=&quot;15%&quot;&gt;lavenderblush&lt;BR&gt;FFF0F5&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lawngreen&quot; WIDTH=&quot;15%&quot;&gt;lawngreen&lt;BR&gt;7CFC00&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lemonchiffon&quot; WIDTH=&quot;15%&quot;&gt;lemonchiffon&lt;BR&gt;FFFACD&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightblue&quot; WIDTH=&quot;15%&quot;&gt;lightblue&lt;BR&gt;ADD8E6&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightcoral&quot; WIDTH=&quot;15%&quot;&gt;lightcoral&lt;BR&gt;F08080&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightcyan&quot; WIDTH=&quot;15%&quot;&gt;lightcyan&lt;BR&gt;E0FFFF&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightgoldenrodyellow&quot; WIDTH=&quot;15%&quot;&gt;lightgoldenrodyellow&lt;BR&gt;FAFAD2&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightgreen&quot; WIDTH=&quot;15%&quot;&gt;lightgreen&lt;BR&gt;90EE90&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightgrey&quot; WIDTH=&quot;15%&quot;&gt;lightgrey&lt;BR&gt;D3D3D3&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightpink&quot; WIDTH=&quot;15%&quot;&gt;lightpink&lt;BR&gt;FFB6C1&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightsalmon&quot; WIDTH=&quot;15%&quot;&gt;lightsalmon&lt;BR&gt;FFA07A&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightseagreen&quot; WIDTH=&quot;15%&quot;&gt;lightseagreen&lt;BR&gt;20B2AA&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightskyblue&quot; WIDTH=&quot;15%&quot;&gt;lightskyblue&lt;BR&gt;87CEFA&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightslategray&quot; WIDTH=&quot;15%&quot;&gt;lightslategray&lt;BR&gt;778899&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightsteelblue&quot; WIDTH=&quot;15%&quot;&gt;lightsteelblue&lt;BR&gt;B0C4DE&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightyellow&quot; WIDTH=&quot;15%&quot;&gt;lightyellow&lt;BR&gt;FFFFE0&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lime&quot; WIDTH=&quot;15%&quot;&gt;lime&lt;BR&gt;00FF00&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;limegreen&quot; WIDTH=&quot;15%&quot;&gt;limegreen&lt;BR&gt;32CD32&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;linen&quot; WIDTH=&quot;15%&quot;&gt;&lt;font COLOR=&quot;#000000&quot;&gt;linen&lt;BR&gt;FAF0E6&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;magenta&quot; WIDTH=&quot;15%&quot;&gt;magenta&lt;BR&gt;FF00FF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;maroon&quot; WIDTH=&quot;15%&quot;&gt;maroon&lt;BR&gt;800000&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumaquamarine&quot; WIDTH=&quot;15%&quot;&gt;mediumauqamarine&lt;BR&gt;66CDAA&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumblue&quot; WIDTH=&quot;15%&quot;&gt;mediumblue&lt;BR&gt;0000CD&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumorchid&quot; WIDTH=&quot;15%&quot;&gt;mediumorchid&lt;BR&gt;BA55D3&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumpurple&quot; WIDTH=&quot;15%&quot;&gt;mediumpurple&lt;BR&gt;9370D8&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumseagreen&quot; WIDTH=&quot;15%&quot;&gt;mediumseagreen&lt;BR&gt;3CB371&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumslateblue&quot; WIDTH=&quot;15%&quot;&gt;mediumslateblue&lt;BR&gt;7B68EE&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumspringgreen&quot; WIDTH=&quot;15%&quot;&gt;mediumspringgreen&lt;BR&gt;00FA9A&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumturquoise&quot; WIDTH=&quot;15%&quot;&gt;mediumturquoise&lt;BR&gt;48D1CC&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumvioletred&quot; WIDTH=&quot;15%&quot;&gt;mediumvioletred&lt;BR&gt;C71585&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;midnightblue&quot; WIDTH=&quot;15%&quot;&gt;midnightblue&lt;BR&gt;191970&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mintcream&quot; WIDTH=&quot;15%&quot;&gt;mintcream&lt;BR&gt;F5FFFA&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mistyrose&quot; WIDTH=&quot;15%&quot;&gt;mistyrose&lt;BR&gt;FFE4E1&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;moccasin&quot; WIDTH=&quot;15%&quot;&gt;moccasin&lt;BR&gt;FFE4B5&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;navajowhite&quot; WIDTH=&quot;15%&quot;&gt;navajowhite&lt;BR&gt;FFDEAD&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;navy&quot; WIDTH=&quot;15%&quot;&gt;navy&lt;BR&gt;000080&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;oldlace&quot; WIDTH=&quot;15%&quot;&gt;oldlace&lt;BR&gt;FDF5E6&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;olive&quot; WIDTH=&quot;15%&quot;&gt;olive&lt;BR&gt;808000&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;olivedrab&quot; WIDTH=&quot;15%&quot;&gt;olivedrab&lt;BR&gt;688E23&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;orange&quot; WIDTH=&quot;15%&quot;&gt;orange&lt;BR&gt;FFA500&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;orangered&quot; WIDTH=&quot;15%&quot;&gt;orangered&lt;BR&gt;FF4500&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;orchid&quot; WIDTH=&quot;15%&quot;&gt;orchid&lt;BR&gt;DA70D6&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;palegoldenrod&quot; WIDTH=&quot;15%&quot;&gt;palegoldenrod&lt;BR&gt;EEE8AA&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;palegreen&quot; WIDTH=&quot;15%&quot;&gt;palegreen&lt;BR&gt;98FB98&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;paleturquoise&quot; WIDTH=&quot;15%&quot;&gt;paleturquoise&lt;BR&gt;AFEEEE&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;palevioletred&quot; WIDTH=&quot;15%&quot;&gt;palevioletred&lt;BR&gt;D87093&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;papayawhip&quot; WIDTH=&quot;15%&quot;&gt;papayawhip&lt;BR&gt;FFEFD5&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;peachpuff&quot; WIDTH=&quot;15%&quot;&gt;peachpuff&lt;BR&gt;FFDAB9&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;peru&quot; WIDTH=&quot;15%&quot;&gt;peru&lt;BR&gt;CD853F&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;pink&quot; WIDTH=&quot;15%&quot;&gt;pink&lt;BR&gt;FFC0CB&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;plum&quot; WIDTH=&quot;15%&quot;&gt;plum&lt;BR&gt;DDA0DD&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;powderblue&quot; WIDTH=&quot;15%&quot;&gt;powderblue&lt;BR&gt;B0E0E6&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;purple&quot; WIDTH=&quot;15%&quot;&gt;purple&lt;BR&gt;800080&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;red&quot; WIDTH=&quot;15%&quot;&gt;red&lt;BR&gt;FF0000&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;rosybrown&quot; WIDTH=&quot;15%&quot;&gt;rosybrown&lt;BR&gt;BC8F8F&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;royalblue&quot; WIDTH=&quot;15%&quot;&gt;royalblue&lt;BR&gt;4169E1&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;saddlebrown&quot; WIDTH=&quot;15%&quot;&gt;saddlebrown&lt;BR&gt;8B4513&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;salmon&quot; WIDTH=&quot;15%&quot;&gt;salmon&lt;BR&gt;FA8072&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;sandybrown&quot; WIDTH=&quot;15%&quot;&gt;sandybrown&lt;BR&gt;F4A460&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;seagreen&quot; WIDTH=&quot;15%&quot;&gt;seagreen&lt;BR&gt;2E8B57&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;seashell&quot; WIDTH=&quot;15%&quot;&gt;seashell&lt;BR&gt;FFF5EE&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;sienna&quot; WIDTH=&quot;15%&quot;&gt;sienna&lt;BR&gt;A0522D&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;silver&quot; WIDTH=&quot;15%&quot;&gt;silver&lt;BR&gt;C0C0C0&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;skyblue&quot; WIDTH=&quot;15%&quot;&gt;skyblue&lt;BR&gt;87CEEB&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;slateblue&quot; WIDTH=&quot;15%&quot;&gt;slateblue&lt;BR&gt;6A5ACD&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;slategray&quot; WIDTH=&quot;15%&quot;&gt;slategray&lt;BR&gt;708090&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;snow&quot; WIDTH=&quot;15%&quot;&gt;snow&lt;BR&gt;FFFAFA&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;springgreen&quot; WIDTH=&quot;15%&quot;&gt;springgreen&lt;BR&gt;00FF7F&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;steelblue&quot; WIDTH=&quot;15%&quot;&gt;steelblue&lt;BR&gt;4682B4&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;tan&quot; WIDTH=&quot;15%&quot;&gt;tan&lt;BR&gt;D2B48C&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;teal&quot; WIDTH=&quot;15%&quot;&gt;teal&lt;BR&gt;008080&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;thistle&quot; WIDTH=&quot;15%&quot;&gt;thistle&lt;BR&gt;D8BFD8&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;tomato&quot; WIDTH=&quot;15%&quot;&gt;tomato&lt;BR&gt;FF6347&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;turquoise&quot; WIDTH=&quot;15%&quot;&gt;turquoise&lt;BR&gt;40E0D0&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;violet&quot; WIDTH=&quot;15%&quot;&gt;violet&lt;BR&gt;EE82EE&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;TR&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;wheat&quot; WIDTH=&quot;15%&quot;&gt;wheat&lt;BR&gt;F5DEB3&lt;BR&gt;&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;white&quot; WIDTH=&quot;15%&quot;&gt;white&lt;BR&gt;FFFFFF&lt;/TD&gt;
-&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;whitesmoke&quot; WIDTH=&quot;15%&quot;&gt;whitesmoke&lt;BR&gt;F5F5F5&lt;/TD&gt;
-&lt;/TR&gt;
-&lt;/table&gt;
-&lt;/center&gt;
-\endhtmlonly
-
-*/
+ * &lt;div class=&quot;code&quot;&gt; FSColor aColor = FSColorTable.%aliceblue(128); &lt;/div&gt;
+ * 
+ * &lt;p&gt;
+ * Transparent colours are created by specifying the level of transparency, in
+ * the range 0..255, where 0 is completely transparent and 255 is completely
+ * opaque.
+ * &lt;/P&gt;
+ * 
+ * \htmlonly &lt;center&gt; &lt;table BORDER=&quot;1&quot; BGCOLOR=&quot;#FFFFFF&quot; CELLPADDING=&quot;5&quot;
+ * CELLSPACING=&quot;4&quot; width=&quot;90%&quot;&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;aliceblue&quot; WIDTH=&quot;15%&quot;&gt;aliceblue&lt;BR&gt;
+ * F0F8FF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;antiquewhite&quot; WIDTH=&quot;15%&quot;&gt;antiquewhite&lt;BR&gt;
+ * FAEBD7&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;aqua&quot; WIDTH=&quot;15%&quot;&gt;aqua&lt;BR&gt;
+ * 00FFFF&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;aquamarine&quot; WIDTH=&quot;15%&quot;&gt;aquamarine&lt;BR&gt;
+ * 7FFFD4&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;azure&quot; WIDTH=&quot;15%&quot;&gt;azure&lt;BR&gt;
+ * F0FFFF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;beige&quot; WIDTH=&quot;15%&quot;&gt;beige&lt;BR&gt;
+ * F5F5DC&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;bisque&quot; WIDTH=&quot;15%&quot;&gt;bisque&lt;BR&gt;
+ * FFE4C4&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;burlywood&quot; WIDTH=&quot;15%&quot;&gt;burlywood&lt;BR&gt;
+ * DEB887&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;blanchedalmond&quot; WIDTH=&quot;15%&quot;&gt;blanchedalmond&lt;BR&gt;
+ * FFEBCD&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;blue&quot; WIDTH=&quot;15%&quot;&gt;blue&lt;BR&gt;
+ * 0000FF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;bluevoilet&quot; WIDTH=&quot;15%&quot;&gt;blueviolet&lt;BR&gt;
+ * 8A2BE2&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;brown&quot; WIDTH=&quot;15%&quot;&gt;brown&lt;BR&gt;
+ * A52A2A&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;black&quot; WIDTH=&quot;15%&quot;&gt;&lt;FONT COLOR=&quot;FFFFFF&quot;&gt;black&lt;BR&gt;
+ * 000000&lt;/FONT&gt;&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cadetblue&quot; WIDTH=&quot;15%&quot;&gt;cadetblue&lt;BR&gt;
+ * 5F9EA0&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;chartreuse&quot; WIDTH=&quot;15%&quot;&gt;chartreuse&lt;BR&gt;
+ * 7FFF00&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;chocolate&quot; WIDTH=&quot;15%&quot;&gt;chocolate&lt;BR&gt;
+ * D2691E&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;coral&quot; WIDTH=&quot;15%&quot;&gt;coral&lt;BR&gt;
+ * FF7F50&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cornflowerblue&quot; WIDTH=&quot;15%&quot;&gt;cornflowerblue&lt;BR&gt;
+ * 6495ED&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cornsilk&quot; WIDTH=&quot;15%&quot;&gt;cornsilk&lt;BR&gt;
+ * FFF8DC&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;crimson&quot; WIDTH=&quot;15%&quot;&gt;crimson&lt;BR&gt;
+ * DC143C&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;cyan&quot; WIDTH=&quot;15%&quot;&gt;cyan&lt;BR&gt;
+ * 00FFFF&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkblue&quot; WIDTH=&quot;15%&quot;&gt;darkblue&lt;BR&gt;
+ * 00008B&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkcyan&quot; WIDTH=&quot;15%&quot;&gt;darkcyan&lt;BR&gt;
+ * 008B8B&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkgoldenrod&quot; WIDTH=&quot;15%&quot;&gt;darkgoldenrod&lt;BR&gt;
+ * B8860B&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkgray&quot; WIDTH=&quot;15%&quot;&gt;darkgray&lt;BR&gt;
+ * A9A9A9&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkgreen&quot; WIDTH=&quot;15%&quot;&gt;darkgreen&lt;BR&gt;
+ * 006400&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkkhaki&quot; WIDTH=&quot;15%&quot;&gt;darkkhaki&lt;BR&gt;
+ * BDB76B&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkmagenta&quot; WIDTH=&quot;15%&quot;&gt;darkmagenta&lt;BR&gt;
+ * 8B008B&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkolivegreen&quot; WIDTH=&quot;15%&quot;&gt;darkolivegreen&lt;BR&gt;
+ * 556B2F&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkorange&quot; WIDTH=&quot;15%&quot;&gt;darkorange&lt;BR&gt;
+ * FF8C00&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkorchid&quot; WIDTH=&quot;15%&quot;&gt;darkorchid&lt;BR&gt;
+ * 9932CC&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkred&quot; WIDTH=&quot;15%&quot;&gt;darkred&lt;BR&gt;
+ * 8B0000&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darksalmon&quot; WIDTH=&quot;15%&quot;&gt;darksalmon&lt;BR&gt;
+ * E9967A&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkseagreen&quot; WIDTH=&quot;15%&quot;&gt;darkseagreen&lt;BR&gt;
+ * 8FBC8F&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkslateblue&quot; WIDTH=&quot;15%&quot;&gt;darkslateblue&lt;BR&gt;
+ * 483D8B&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkslategray&quot; WIDTH=&quot;15%&quot;&gt;darkslategray&lt;BR&gt;
+ * 2F4F4F&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkturquoise&quot; WIDTH=&quot;15%&quot;&gt;darkturquoise&lt;BR&gt;
+ * 00CED1&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;darkviolet&quot; WIDTH=&quot;15%&quot;&gt;darkviolet&lt;BR&gt;
+ * 9400D3&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;deeppink&quot; WIDTH=&quot;15%&quot;&gt;deeppink&lt;BR&gt;
+ * FF1493&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;deepskyblue&quot; WIDTH=&quot;15%&quot;&gt;deepskyblue&lt;BR&gt;
+ * 00BFFF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;dimgray&quot; WIDTH=&quot;15%&quot;&gt;dimgray&lt;BR&gt;
+ * 696969&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;dodgerblue&quot; WIDTH=&quot;15%&quot;&gt;dodgerblue&lt;BR&gt;
+ * 1E90FF&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;firebrick&quot; WIDTH=&quot;15%&quot;&gt;firebrick&lt;BR&gt;
+ * B22222&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;floralwhite&quot; WIDTH=&quot;15%&quot;&gt;floralwhite&lt;BR&gt;
+ * FFFAF0&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;forestgreen&quot; WIDTH=&quot;15%&quot;&gt;forestgreen&lt;BR&gt;
+ * 228B22&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;fuchsia&quot; WIDTH=&quot;15%&quot;&gt;fuchsia&lt;BR&gt;
+ * FF00FF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;gainsboro&quot; WIDTH=&quot;15%&quot;&gt;gainsboro&lt;BR&gt;
+ * DCDCDC&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;ghostwhite&quot; WIDTH=&quot;15%&quot;&gt;ghostwhite&lt;BR&gt;
+ * F8F8FF&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;gold&quot; WIDTH=&quot;15%&quot;&gt;gold&lt;BR&gt;
+ * FFD700&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;goldenrod&quot; WIDTH=&quot;15%&quot;&gt;goldenrod&lt;BR&gt;
+ * DAA520&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;gray&quot; WIDTH=&quot;15%&quot;&gt;gray&lt;BR&gt;
+ * 808080&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;green&quot; WIDTH=&quot;15%&quot;&gt;green&lt;BR&gt;
+ * 008000&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;greenyellow&quot; WIDTH=&quot;15%&quot;&gt;greenyellow&lt;BR&gt;
+ * ADFF2F&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;honeydew&quot; WIDTH=&quot;15%&quot;&gt;honeydew&lt;BR&gt;
+ * F0FFF0&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;hotpink&quot; WIDTH=&quot;15%&quot;&gt;hotpink&lt;BR&gt;
+ * FF69B4&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;indianred&quot; WIDTH=&quot;15%&quot;&gt;indianred&lt;BR&gt;
+ * CD5C5C&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;indigo&quot; WIDTH=&quot;15%&quot;&gt;Indigo&lt;BR&gt;
+ * 4B0082&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;ivory&quot; WIDTH=&quot;15%&quot;&gt;ivory&lt;BR&gt;
+ * FFFFF0&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;khaki&quot; WIDTH=&quot;15%&quot;&gt;khaki&lt;BR&gt;
+ * F0E68C&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lavender&quot; WIDTH=&quot;15%&quot;&gt;lavender&lt;BR&gt;
+ * E6E6FA&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lavenderblush&quot; WIDTH=&quot;15%&quot;&gt;lavenderblush&lt;BR&gt;
+ * FFF0F5&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lawngreen&quot; WIDTH=&quot;15%&quot;&gt;lawngreen&lt;BR&gt;
+ * 7CFC00&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lemonchiffon&quot; WIDTH=&quot;15%&quot;&gt;lemonchiffon&lt;BR&gt;
+ * FFFACD&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightblue&quot; WIDTH=&quot;15%&quot;&gt;lightblue&lt;BR&gt;
+ * ADD8E6&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightcoral&quot; WIDTH=&quot;15%&quot;&gt;lightcoral&lt;BR&gt;
+ * F08080&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightcyan&quot; WIDTH=&quot;15%&quot;&gt;lightcyan&lt;BR&gt;
+ * E0FFFF&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightgoldenrodyellow&quot; WIDTH=&quot;15%&quot;&gt;lightgoldenrodyellow&lt;BR&gt;
+ * FAFAD2&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightgreen&quot; WIDTH=&quot;15%&quot;&gt;lightgreen&lt;BR&gt;
+ * 90EE90&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightgrey&quot; WIDTH=&quot;15%&quot;&gt;lightgrey&lt;BR&gt;
+ * D3D3D3&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightpink&quot; WIDTH=&quot;15%&quot;&gt;lightpink&lt;BR&gt;
+ * FFB6C1&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightsalmon&quot; WIDTH=&quot;15%&quot;&gt;lightsalmon&lt;BR&gt;
+ * FFA07A&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightseagreen&quot; WIDTH=&quot;15%&quot;&gt;lightseagreen&lt;BR&gt;
+ * 20B2AA&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightskyblue&quot; WIDTH=&quot;15%&quot;&gt;lightskyblue&lt;BR&gt;
+ * 87CEFA&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightslategray&quot; WIDTH=&quot;15%&quot;&gt;lightslategray&lt;BR&gt;
+ * 778899&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightsteelblue&quot; WIDTH=&quot;15%&quot;&gt;lightsteelblue&lt;BR&gt;
+ * B0C4DE&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lightyellow&quot; WIDTH=&quot;15%&quot;&gt;lightyellow&lt;BR&gt;
+ * FFFFE0&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;lime&quot; WIDTH=&quot;15%&quot;&gt;lime&lt;BR&gt;
+ * 00FF00&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;limegreen&quot; WIDTH=&quot;15%&quot;&gt;limegreen&lt;BR&gt;
+ * 32CD32&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;linen&quot; WIDTH=&quot;15%&quot;&gt;&lt;font COLOR=&quot;#000000&quot;&gt;linen&lt;BR&gt;
+ * FAF0E6&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;magenta&quot; WIDTH=&quot;15%&quot;&gt;magenta&lt;BR&gt;
+ * FF00FF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;maroon&quot; WIDTH=&quot;15%&quot;&gt;maroon&lt;BR&gt;
+ * 800000&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumaquamarine&quot; WIDTH=&quot;15%&quot;&gt;mediumauqamarine&lt;BR&gt;
+ * 66CDAA&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumblue&quot; WIDTH=&quot;15%&quot;&gt;mediumblue&lt;BR&gt;
+ * 0000CD&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumorchid&quot; WIDTH=&quot;15%&quot;&gt;mediumorchid&lt;BR&gt;
+ * BA55D3&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumpurple&quot; WIDTH=&quot;15%&quot;&gt;mediumpurple&lt;BR&gt;
+ * 9370D8&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumseagreen&quot; WIDTH=&quot;15%&quot;&gt;mediumseagreen&lt;BR&gt;
+ * 3CB371&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumslateblue&quot; WIDTH=&quot;15%&quot;&gt;mediumslateblue&lt;BR&gt;
+ * 7B68EE&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumspringgreen&quot; WIDTH=&quot;15%&quot;&gt;mediumspringgreen&lt;BR&gt;
+ * 00FA9A&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumturquoise&quot; WIDTH=&quot;15%&quot;&gt;mediumturquoise&lt;BR&gt;
+ * 48D1CC&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mediumvioletred&quot; WIDTH=&quot;15%&quot;&gt;mediumvioletred&lt;BR&gt;
+ * C71585&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;midnightblue&quot; WIDTH=&quot;15%&quot;&gt;midnightblue&lt;BR&gt;
+ * 191970&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mintcream&quot; WIDTH=&quot;15%&quot;&gt;mintcream&lt;BR&gt;
+ * F5FFFA&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;mistyrose&quot; WIDTH=&quot;15%&quot;&gt;mistyrose&lt;BR&gt;
+ * FFE4E1&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;moccasin&quot; WIDTH=&quot;15%&quot;&gt;moccasin&lt;BR&gt;
+ * FFE4B5&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;navajowhite&quot; WIDTH=&quot;15%&quot;&gt;navajowhite&lt;BR&gt;
+ * FFDEAD&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;navy&quot; WIDTH=&quot;15%&quot;&gt;navy&lt;BR&gt;
+ * 000080&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;oldlace&quot; WIDTH=&quot;15%&quot;&gt;oldlace&lt;BR&gt;
+ * FDF5E6&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;olive&quot; WIDTH=&quot;15%&quot;&gt;olive&lt;BR&gt;
+ * 808000&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;olivedrab&quot; WIDTH=&quot;15%&quot;&gt;olivedrab&lt;BR&gt;
+ * 688E23&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;orange&quot; WIDTH=&quot;15%&quot;&gt;orange&lt;BR&gt;
+ * FFA500&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;orangered&quot; WIDTH=&quot;15%&quot;&gt;orangered&lt;BR&gt;
+ * FF4500&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;orchid&quot; WIDTH=&quot;15%&quot;&gt;orchid&lt;BR&gt;
+ * DA70D6&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;palegoldenrod&quot; WIDTH=&quot;15%&quot;&gt;palegoldenrod&lt;BR&gt;
+ * EEE8AA&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;palegreen&quot; WIDTH=&quot;15%&quot;&gt;palegreen&lt;BR&gt;
+ * 98FB98&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;paleturquoise&quot; WIDTH=&quot;15%&quot;&gt;paleturquoise&lt;BR&gt;
+ * AFEEEE&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;palevioletred&quot; WIDTH=&quot;15%&quot;&gt;palevioletred&lt;BR&gt;
+ * D87093&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;papayawhip&quot; WIDTH=&quot;15%&quot;&gt;papayawhip&lt;BR&gt;
+ * FFEFD5&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;peachpuff&quot; WIDTH=&quot;15%&quot;&gt;peachpuff&lt;BR&gt;
+ * FFDAB9&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;peru&quot; WIDTH=&quot;15%&quot;&gt;peru&lt;BR&gt;
+ * CD853F&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;pink&quot; WIDTH=&quot;15%&quot;&gt;pink&lt;BR&gt;
+ * FFC0CB&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;plum&quot; WIDTH=&quot;15%&quot;&gt;plum&lt;BR&gt;
+ * DDA0DD&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;powderblue&quot; WIDTH=&quot;15%&quot;&gt;powderblue&lt;BR&gt;
+ * B0E0E6&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;purple&quot; WIDTH=&quot;15%&quot;&gt;purple&lt;BR&gt;
+ * 800080&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;red&quot; WIDTH=&quot;15%&quot;&gt;red&lt;BR&gt;
+ * FF0000&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;rosybrown&quot; WIDTH=&quot;15%&quot;&gt;rosybrown&lt;BR&gt;
+ * BC8F8F&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;royalblue&quot; WIDTH=&quot;15%&quot;&gt;royalblue&lt;BR&gt;
+ * 4169E1&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;saddlebrown&quot; WIDTH=&quot;15%&quot;&gt;saddlebrown&lt;BR&gt;
+ * 8B4513&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;salmon&quot; WIDTH=&quot;15%&quot;&gt;salmon&lt;BR&gt;
+ * FA8072&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;sandybrown&quot; WIDTH=&quot;15%&quot;&gt;sandybrown&lt;BR&gt;
+ * F4A460&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;seagreen&quot; WIDTH=&quot;15%&quot;&gt;seagreen&lt;BR&gt;
+ * 2E8B57&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;seashell&quot; WIDTH=&quot;15%&quot;&gt;seashell&lt;BR&gt;
+ * FFF5EE&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;sienna&quot; WIDTH=&quot;15%&quot;&gt;sienna&lt;BR&gt;
+ * A0522D&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;silver&quot; WIDTH=&quot;15%&quot;&gt;silver&lt;BR&gt;
+ * C0C0C0&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;skyblue&quot; WIDTH=&quot;15%&quot;&gt;skyblue&lt;BR&gt;
+ * 87CEEB&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;slateblue&quot; WIDTH=&quot;15%&quot;&gt;slateblue&lt;BR&gt;
+ * 6A5ACD&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;slategray&quot; WIDTH=&quot;15%&quot;&gt;slategray&lt;BR&gt;
+ * 708090&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;snow&quot; WIDTH=&quot;15%&quot;&gt;snow&lt;BR&gt;
+ * FFFAFA&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;springgreen&quot; WIDTH=&quot;15%&quot;&gt;springgreen&lt;BR&gt;
+ * 00FF7F&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;steelblue&quot; WIDTH=&quot;15%&quot;&gt;steelblue&lt;BR&gt;
+ * 4682B4&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;tan&quot; WIDTH=&quot;15%&quot;&gt;tan&lt;BR&gt;
+ * D2B48C&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;teal&quot; WIDTH=&quot;15%&quot;&gt;teal&lt;BR&gt;
+ * 008080&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;thistle&quot; WIDTH=&quot;15%&quot;&gt;thistle&lt;BR&gt;
+ * D8BFD8&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;tomato&quot; WIDTH=&quot;15%&quot;&gt;tomato&lt;BR&gt;
+ * FF6347&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;turquoise&quot; WIDTH=&quot;15%&quot;&gt;turquoise&lt;BR&gt;
+ * 40E0D0&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;violet&quot; WIDTH=&quot;15%&quot;&gt;violet&lt;BR&gt;
+ * EE82EE&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;TR&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;wheat&quot; WIDTH=&quot;15%&quot;&gt;wheat&lt;BR&gt;
+ * F5DEB3&lt;BR&gt;
+ * &lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;white&quot; WIDTH=&quot;15%&quot;&gt;white&lt;BR&gt;
+ * FFFFFF&lt;/TD&gt;
+ * &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;whitesmoke&quot; WIDTH=&quot;15%&quot;&gt;whitesmoke&lt;BR&gt;
+ * F5F5F5&lt;/TD&gt;
+ * &lt;/TR&gt;
+ * &lt;/table&gt; &lt;/center&gt; \endhtmlonly
+ * 
+ */
 public class FSColorTable
 {
-    /** Definition of the color, aliceblue from the Netscape color table. */
-    public static FSColor aliceblue() { return new FSColor(0xF0, 0xF8, 0xFF, 0xFF); }
-    /** Definition of the color, antiquewhite from the Netscape color table. */
-    public static FSColor antiquewhite() { return new FSColor(0xFA, 0xEB, 0xD7, 0xFF); }
-    /** Definition of the color, aqua from the Netscape color table. */
-    public static FSColor aqua() { return new FSColor(0x00, 0xFF, 0xFF, 0xFF); }
-    /** Definition of the color, aquamarine from the Netscape color table. */
-    public static FSColor aquamarine() { return new FSColor(0x7F, 0xFF, 0xD4, 0xFF); }
-    /** Definition of the color, azure from the Netscape color table. */
-    public static FSColor azure() { return new FSColor(0xF0, 0xFF, 0xFF, 0xFF); }
-    /** Definition of the color, beige from the Netscape color table. */
-    public static FSColor beige() { return new FSColor(0xF5, 0xF5, 0xDC, 0xFF); }
-    /** Definition of the color, bisque from the Netscape color table. */
-    public static FSColor bisque() { return new FSColor(0xFF, 0xE4, 0xC4, 0xFF); }
-    /** Definition of the color, black from the Netscape color table. */
-    public static FSColor black() { return new FSColor(0x00, 0x00, 0x00, 0xFF); }
-    /** Definition of the color, blanchedalmond from the Netscape color table. */
-    public static FSColor blanchedalmond() { return new FSColor(0xFF, 0xEB, 0xCD, 0xFF); }
-    /** Definition of the color, blue from the Netscape color table. */
-    public static FSColor blue() { return new FSColor(0x00, 0x00, 0xFF, 0xFF); }
-    /** Definition of the color, blueviolet from the Netscape color table. */
-    public static FSColor blueviolet() { return new FSColor(0x8A, 0x2B, 0xE2, 0xFF); }
-    /** Definition of the color, brown from the Netscape color table. */
-    public static FSColor brown() { return new FSColor(0xA5, 0x2A, 0x2A, 0xFF); }
-    /** Definition of the color, burlywood from the Netscape color table. */
-    public static FSColor burlywood() { return new FSColor(0xDE, 0xB8, 0x87, 0xFF); }
-    /** Definition of the color, cadetblue from the Netscape color table. */
-    public static FSColor cadetblue() { return new FSColor(0x5F, 0x9E, 0xA0, 0xFF); }
-    /** Definition of the color, chartreuse from the Netscape color table. */
-    public static FSColor chartreuse() { return new FSColor(0x7F, 0xFF, 0x00, 0xFF); }
-    /** Definition of the color, chocolate from the Netscape color table. */
-    public static FSColor chocolate() { return new FSColor(0xD2, 0x69, 0x1E, 0xFF); }
-    /** Definition of the color, coral from the Netscape color table. */
-    public static FSColor coral() { return new FSColor(0xFF, 0x7F, 0x50, 0xFF); }
-    /** Definition of the color, cornflowerblue from the Netscape color table. */
-    public static FSColor cornflowerblue() { return new FSColor(0x64, 0x95, 0xED, 0xFF); }
-    /** Definition of the color, cornsilk from the Netscape color table. */
-    public static FSColor cornsilk() { return new FSColor(0xFF, 0xF8, 0xDC, 0xFF); }
-    /** Definition of the color, crimson from the Netscape color table. */
-    public static FSColor crimson() { return new FSColor(0xDC, 0x14, 0x3C, 0xFF); }
-    /** Definition of the color, cyan from the Netscape color table. */
-    public static FSColor cyan() { return new FSColor(0x00, 0xFF, 0xFF, 0xFF); }
-    /** Definition of the color, darkblue from the Netscape color table. */
-    public static FSColor darkblue() { return new FSColor(0x00, 0x00, 0x8B, 0xFF); }
-    /** Definition of the color, darkcyan from the Netscape color table. */
-    public static FSColor darkcyan() { return new FSColor(0x00, 0x8B, 0x8B, 0xFF); }
-    /** Definition of the color, darkgoldenrod from the Netscape color table. */
-    public static FSColor darkgoldenrod() { return new FSColor(0xB8, 0x86, 0x0B, 0xFF); }
-    /** Definition of the color, darkgray from the Netscape color table. */
-    public static FSColor darkgray() { return new FSColor(0xA9, 0xA9, 0xA9, 0xFF); }
-    /** Definition of the color, darkgreen from the Netscape color table. */
-    public static FSColor darkgreen() { return new FSColor(0x00, 0x64, 0x00, 0xFF); }
-    /** Definition of the color, darkkhaki from the Netscape color table. */
-    public static FSColor darkkhaki() { return new FSColor(0xBD, 0xB7, 0x6B, 0xFF); }
-    /** Definition of the color, darkmagenta from the Netscape color table. */
-    public static FSColor darkmagenta() { return new FSColor(0x8B, 0x00, 0x8B, 0xFF); }
-    /** Definition of the color, darkolivegreen from the Netscape color table. */
-    public static FSColor darkolivegreen() { return new FSColor(0x55, 0x6B, 0x2F, 0xFF); }
-    /** Definition of the color, darkorange from the Netscape color table. */
-    public static FSColor darkorange() { return new FSColor(0xFF, 0x8C, 0x00, 0xFF); }
-    /** Definition of the color, darkorchid from the Netscape color table. */
-    public static FSColor darkorchid() { return new FSColor(0x99, 0x32, 0xCC, 0xFF); }
-    /** Definition of the color, darkred from the Netscape color table. */
-    public static FSColor darkred() { return new FSColor(0x8B, 0x00, 0x00, 0xFF); }
-    /** Definition of the color, darksalmon from the Netscape color table. */
-    public static FSColor darksalmon() { return new FSColor(0xE9, 0x96, 0x7A, 0xFF); }
-    /** Definition of the color, darkseagreen from the Netscape color table. */
-    public static FSColor darkseagreen() { return new FSColor(0x8F, 0xBC, 0x8F, 0xFF); }
-    /** Definition of the color, darkslateblue from the Netscape color table. */
-    public static FSColor darkslateblue() { return new FSColor(0x48, 0x3D, 0x8B, 0xFF); }
-    /** Definition of the color, darkslategray from the Netscape color table. */
-    public static FSColor darkslategray() { return new FSColor(0x2F, 0x4F, 0x4F, 0xFF); }
-    /** Definition of the color, darkturquoise from the Netscape color table. */
-    public static FSColor darkturquoise() { return new FSColor(0x00, 0xCE, 0xD1, 0xFF); }
-    /** Definition of the color, darkviolet from the Netscape color table. */
-    public static FSColor darkviolet() { return new FSColor(0x94, 0x00, 0xD3, 0xFF); }
-    /** Definition of the color, deeppink from the Netscape color table. */
-    public static FSColor deeppink() { return new FSColor(0xFF, 0x14, 0x93, 0xFF); }
-    /** Definition of the color, deepskyblue from the Netscape color table. */
-    public static FSColor deepskyblue() { return new FSColor(0x00, 0xBF, 0xFF, 0xFF); }
-    /** Definition of the color, dimgray from the Netscape color table. */
-    public static FSColor dimgray() { return new FSColor(0x69, 0x69, 0x69, 0xFF); }
-    /** Definition of the color, dodgerblue from the Netscape color table. */
-    public static FSColor dodgerblue() { return new FSColor(0x1E, 0x90, 0xFF, 0xFF); }
-    /** Definition of the color, firebrick from the Netscape color table. */
-    public static FSColor firebrick() { return new FSColor(0xB2, 0x22, 0x22, 0xFF); }
-    /** Definition of the color, floralwhite from the Netscape color table. */
-    public static FSColor floralwhite() { return new FSColor(0xFF, 0xFA, 0xF0, 0xFF); }
-    /** Definition of the color, forestgreen from the Netscape color table. */
-    public static FSColor forestgreen() { return new FSColor(0x22, 0x8B, 0x22, 0xFF); }
-    /** Definition of the color, fuchsia from the Netscape color table. */
-    public static FSColor fuchsia() { return new FSColor(0xFF, 0x00, 0xFF, 0xFF); }
-    /** Definition of the color, gainsboro from the Netscape color table. */
-    public static FSColor gainsboro() { return new FSColor(0xDC, 0xDC, 0xDC, 0xFF); }
-    /** Definition of the color, ghostwhite from the Netscape color table. */
-    public static FSColor ghostwhite() { return new FSColor(0xF8, 0xF8, 0xFB, 0xFF); }
-    /** Definition of the color, gold from the Netscape color table. */
-    public static FSColor gold() { return new FSColor(0xFF, 0xD7, 0x00, 0xFF); }
-    /** Definition of the color, goldenrod from the Netscape color table. */
-    public static FSColor goldenrod() { return new FSColor(0xDA, 0xA5, 0x20, 0xFF); }
-    /** Definition of the color, gray from the Netscape color table. */
-    public static FSColor gray() { return new FSColor(0x80, 0x80, 0x80, 0xFF); }
-    /** Definition of the color, green from the Netscape color table. */
-    public static FSColor green() { return new FSColor(0x00, 0x80, 0x00, 0xFF); }
-    /** Definition of the color, greenyellow from the Netscape color table. */
-    public static FSColor greenyellow() { return new FSColor(0xAD, 0xFF, 0x2F, 0xFF); }
-    /** Definition of the color, honeydew from the Netscape color table. */
-    public static FSColor honeydew() { return new FSColor(0xF0, 0xFF, 0xF0, 0xFF); }
-    /** Definition of the color, hotpink from the Netscape color table. */
-    public static FSColor hotpink() { return new FSColor(0xFF, 0x69, 0xB4, 0xFF); }
-    /** Definition of the color, indianred from the Netscape color table. */
-    public static FSColor indianred() { return new FSColor(0xCD, 0x5C, 0x5C, 0xFF); }
-    /** Definition of the color, indigo from the Netscape color table. */
-    public static FSColor indigo() { return new FSColor(0x4B, 0x00, 0x82, 0xFF); }
-    /** Definition of the color, ivory from the Netscape color table. */
-    public static FSColor ivory() { return new FSColor(0xFF, 0xFF, 0xF0, 0xFF); }
-    /** Definition of the color, khaki from the Netscape color table. */
-    public static FSColor khaki() { return new FSColor(0xF0, 0xE6, 0x8C, 0xFF); }
-    /** Definition of the color, lavender from the Netscape color table. */
-    public static FSColor lavender() { return new FSColor(0xE6, 0xE6, 0xFA, 0xFF); }
-    /** Definition of the color, lavenderblush from the Netscape color table. */
-    public static FSColor lavenderblush() { return new FSColor(0xFF, 0xF0, 0xF5, 0xFF); }
-    /** Definition of the color, lawngreen from the Netscape color table. */
-    public static FSColor lawngreen() { return new FSColor(0x7C, 0xFC, 0x00, 0xFF); }
-    /** Definition of the color, lemonchiffon from the Netscape color table. */
-    public static FSColor lemonchiffon() { return new FSColor(0xFF, 0xFA, 0xCD, 0xFF); }
-    /** Definition of the color, lightblue from the Netscape color table. */
-    public static FSColor lightblue() { return new FSColor(0xAD, 0xD8, 0xE6, 0xFF); }
-    /** Definition of the color, lightcoral from the Netscape color table. */
-    public static FSColor lightcoral() { return new FSColor(0xF0, 0x80, 0x80, 0xFF); }
-    /** Definition of the color, lightcyan from the Netscape color table. */
-    public static FSColor lightcyan() { return new FSColor(0xE0, 0xFF, 0xFF, 0xFF); }
-    /** Definition of the color, lightgoldenrodyellow from the Netscape color table. */
-    public static FSColor lightgoldenrodyellow() { return new FSColor(0xFA, 0xFA, 0xD2, 0xFF); }
-    /** Definition of the color, lightgreen from the Netscape color table. */
-    public static FSColor lightgreen() { return new FSColor(0x90, 0xEE, 0x90, 0xFF); }
-    /** Definition of the color, lightgrey from the Netscape color table. */
-    public static FSColor lightgrey() { return new FSColor(0xD3, 0xD3, 0xD3, 0xFF); }
-    /** Definition of the color, lightpink from the Netscape color table. */
-    public static FSColor lightpink() { return new FSColor(0xFF, 0xB6, 0xC1, 0xFF); }
-    /** Definition of the color, lightsalmon from the Netscape color table. */
-    public static FSColor lightsalmon() { return new FSColor(0xFF, 0xA0, 0x7A, 0xFF); }
-    /** Definition of the color, lightseagreen from the Netscape color table. */
-    public static FSColor lightseagreen() { return new FSColor(0x20, 0xB2, 0xAA, 0xFF); }
-    /** Definition of the color, lightskyblue from the Netscape color table. */
-    public static FSColor lightskyblue() { return new FSColor(0x87, 0xCE, 0xFA, 0xFF); }
-    /** Definition of the color, lightslategray from the Netscape color table. */
-    public static FSColor lightslategray() { return new FSColor(0x77, 0x88, 0x99, 0xFF); }
-    /** Definition of the color, lightsteelblue from the Netscape color table. */
-    public static FSColor lightsteelblue() { return new FSColor(0xB0, 0xC4, 0xDE, 0xFF); }
-    /** Definition of the color, lightyellow from the Netscape color table. */
-    public static FSColor lightyellow() { return new FSColor(0xFF, 0xFF, 0xE0, 0xFF); }
-    /** Definition of the color, lime from the Netscape color table. */
-    public static FSColor lime() { return new FSColor(0x00, 0xFF, 0x00, 0xFF); }
-    /** Definition of the color, limegreen from the Netscape color table. */
-    public static FSColor limegreen() { return new FSColor(0x32, 0xCD, 0x32, 0xFF); }
-    /** Definition of the color, linen from the Netscape color table. */
-    public static FSColor linen() { return new FSColor(0xFA, 0xF0, 0xE6, 0xFF); }
-    /** Definition of the color, magenta from the Netscape color table. */
-    public static FSColor magenta() { return new FSColor(0xFF, 0x00, 0xFF, 0xFF); }
-    /** Definition of the color, maroon from the Netscape color table. */
-    public static FSColor maroon() { return new FSColor(0x80, 0x00, 0x00, 0xFF); }
-    /** Definition of the color, mediumaquamarine from the Netscape color table. */
-    public static FSColor mediumaquamarine() { return new FSColor(0x66, 0xCD, 0xAA, 0xFF); }
-    /** Definition of the color, mediumblue from the Netscape color table. */
-    public static FSColor mediumblue() { return new FSColor(0x00, 0x00, 0xCD, 0xFF); }
-    /** Definition of the color, mediumorchid from the Netscape color table. */
-    public static FSColor mediumorchid() { return new FSColor(0xBA, 0x55, 0xD3, 0xFF); }
-    /** Definition of the color, mediumpurple from the Netscape color table. */
-    public static FSColor mediumpurple() { return new FSColor(0x93, 0x70, 0xDB, 0xFF); }
-    /** Definition of the color, mediumseagreen from the Netscape color table. */
-    public static FSColor mediumseagreen() { return new FSColor(0x3C, 0xB3, 0x71, 0xFF); }
-    /** Definition of the color, mediumslateblue from the Netscape color table. */
-    public static FSColor mediumslateblue() { return new FSColor(0x7B, 0x68, 0xEE, 0xFF); }
-    /** Definition of the color, mediumspringgreen from the Netscape color table. */
-    public static FSColor mediumspringgreen() { return new FSColor(0x00, 0xFA, 0x9A, 0xFF); }
-    /** Definition of the color, mediumturquoise from the Netscape color table. */
-    public static FSColor mediumturquoise() { return new FSColor(0x48, 0xD1, 0xCC, 0xFF); }
-    /** Definition of the color, mediumvioletred from the Netscape color table. */
-    public static FSColor mediumvioletred() { return new FSColor(0xC7, 0x15, 0x85, 0xFF); }
-    /** Definition of the color, midnightblue from the Netscape color table. */
-    public static FSColor midnightblue() { return new FSColor(0x19, 0x19, 0x70, 0xFF); }
-    /** Definition of the color, mintcream from the Netscape color table. */
-    public static FSColor mintcream() { return new FSColor(0xF5, 0xFF, 0xFA, 0xFF); }
-    /** Definition of the color, mistyrose from the Netscape color table. */
-    public static FSColor mistyrose() { return new FSColor(0xFF, 0xE4, 0xE1, 0xFF); }
-    /** Definition of the color, moccasin from the Netscape color table. */
-    public static FSColor moccasin() { return new FSColor(0xFF, 0xE4, 0xB5, 0xFF); }
-    /** Definition of the color, navajowhite from the Netscape color table. */
-    public static FSColor navajowhite() { return new FSColor(0xFF, 0xDE, 0xAD, 0xFF); }
-    /** Definition of the color, navy from the Netscape color table. */
-    public static FSColor navy() { return new FSColor(0x00, 0x00, 0x80, 0xFF); }
-    /** Definition of the color, oldlace from the Netscape color table. */
-    public static FSColor oldlace() { return new FSColor(0xFD, 0xF5, 0xE6, 0xFF); }
-    /** Definition of the color, olive from the Netscape color table. */
-    public static FSColor olive() { return new FSColor(0x80, 0x80, 0x00, 0xFF); }
-    /** Definition of the color, olivedrab from the Netscape color table. */
-    public static FSColor olivedrab() { return new FSColor(0x6B, 0x8E, 0x23, 0xFF); }
-    /** Definition of the color, orange from the Netscape color table. */
-    public static FSColor orange() { return new FSColor(0xFF, 0xA5, 0x00, 0xFF); }
-    /** Definition of the color, orangered from the Netscape color table. */
-    public static FSColor orangered() { return new FSColor(0xFF, 0x45, 0x00, 0xFF); }
-    /** Definition of the color, orchid from the Netscape color table. */
-    public static FSColor orchid() { return new FSColor(0xDA, 0x70, 0xD6, 0xFF); }
-    /** Definition of the color, palegoldenrod from the Netscape color table. */
-    public static FSColor palegoldenrod() { return new FSColor(0xEE, 0xE8, 0xAA, 0xFF); }
-    /** Definition of the color, palegreen from the Netscape color table. */
-    public static FSColor palegreen() { return new FSColor(0x98, 0xFB, 0x98, 0xFF); }
-    /** Definition of the color, paleturquoise from the Netscape color table. */
-    public static FSColor paleturquoise() { return new FSColor(0xAF, 0xEE, 0xEE, 0xFF); }
-    /** Definition of the color, palevioletred from the Netscape color table. */
-    public static FSColor palevioletred() { return new FSColor(0xDB, 0x70, 0x93, 0xFF); }
-    /** Definition of the color, papayawhip from the Netscape color table. */
-    public static FSColor papayawhip() { return new FSColor(0xFF, 0xEF, 0xD5, 0xFF); }
-    /** Definition of the color, peachpuff from the Netscape color table. */
-    public static FSColor peachpuff() { return new FSColor(0xFF, 0xDA, 0xB9, 0xFF); }
-    /** Definition of the color, peru from the Netscape color table. */
-    public static FSColor peru() { return new FSColor(0xCD, 0x85, 0x3F, 0xFF); }
-    /** Definition of the color, pink from the Netscape color table. */
-    public static FSColor pink() { return new FSColor(0xFF, 0xC0, 0xCB, 0xFF); }
-    /** Definition of the color, plum from the Netscape color table. */
-    public static FSColor plum() { return new FSColor(0xDD, 0xA0, 0xDD, 0xFF); }
-    /** Definition of the color, powderblue from the Netscape color table. */
-    public static FSColor powderblue() { return new FSColor(0xB0, 0xE0, 0xE6, 0xFF); }
-    /** Definition of the color, purple from the Netscape color table. */
-    public static FSColor purple() { return new FSColor(0x80, 0x00, 0x80, 0xFF); }
-    /** Definition of the color, red from the Netscape color table. */
-    public static FSColor red() { return new FSColor(0xFF, 0x00, 0x00, 0xFF); }
-    /** Definition of the color, rosybrown from the Netscape color table. */
-    public static FSColor rosybrown() { return new FSColor(0xBC, 0x8F, 0x8F, 0xFF); }
-    /** Definition of the color, royalblue from the Netscape color table. */
-    public static FSColor royalblue() { return new FSColor(0x41, 0x69, 0xE1, 0xFF); }
-    /** Definition of the color, saddlebrown from the Netscape color table. */
-    public static FSColor saddlebrown() { return new FSColor(0x8B, 0x45, 0x13, 0xFF); }
-    /** Definition of the color, salmon from the Netscape color table. */
-    public static FSColor salmon() { return new FSColor(0xFA, 0x80, 0x72, 0xFF); }
-    /** Definition of the color, sandybrown from the Netscape color table. */
-    public static FSColor sandybrown() { return new FSColor(0xF4, 0xA4, 0x60, 0xFF); }
-    /** Definition of the color, seagreen from the Netscape color table. */
-    public static FSColor seagreen() { return new FSColor(0x2E, 0x8B, 0x57, 0xFF); }
-    /** Definition of the color, seashell from the Netscape color table. */
-    public static FSColor seashell() { return new FSColor(0xFF, 0xF5, 0xEE, 0xFF); }
-    /** Definition of the color, sienna from the Netscape color table. */
-    public static FSColor sienna() { return new FSColor(0xA0, 0x52, 0x2d, 0xFF); }
-    /** Definition of the color, silver from the Netscape color table. */
-    public static FSColor silver() { return new FSColor(0xC0, 0xC0, 0xC0, 0xFF); }
-    /** Definition of the color, skyblue from the Netscape color table. */
-    public static FSColor skyblue() { return new FSColor(0x87, 0xCE, 0xEB, 0xFF); }
-    /** Definition of the color, slateblue from the Netscape color table. */
-    public static FSColor slateblue() { return new FSColor(0x6A, 0x5A, 0xCD, 0xFF); }
-    /** Definition of the color, slategray from the Netscape color table. */
-    public static FSColor slategray() { return new FSColor(0x70, 0x80, 0x90, 0xFF); }
-    /** Definition of the color, snow from the Netscape color table. */
-    public static FSColor snow() { return new FSColor(0xFF, 0xFA, 0xFA, 0xFF); }
-    /** Definition of the color, springgreen from the Netscape color table. */
-    public static FSColor springgreen() { return new FSColor(0x00, 0xFF, 0x7F, 0xFF); }
-    /** Definition of the color, steelblue from the Netscape color table. */
-    public static FSColor steelblue() { return new FSColor(0x46, 0x82, 0xB4, 0xFF); }
-    /** Definition of the color, tan from the Netscape color table. */
-    public static FSColor tan() { return new FSColor(0xD2, 0xB4, 0x8C, 0xFF); }
-    /** Definition of the color, teal from the Netscape color table. */
-    public static FSColor teal() { return new FSColor(0x00, 0x80, 0x80, 0xFF); }
-    /** Definition of the color, thistle from the Netscape color table. */
-    public static FSColor thistle() { return new FSColor(0xD8, 0xBF, 0xD8, 0xFF); }
-    /** Definition of the color, tomato from the Netscape color table. */
-    public static FSColor tomato() { return new FSColor(0xFF, 0x63, 0x47, 0xFF); }
-    /** Definition of the color, turquoise from the Netscape color table. */
-    public static FSColor turquoise() { return new FSColor(0x40, 0xE0, 0xD0, 0xFF); }
-    /** Definition of the color, violet from the Netscape color table. */
-    public static FSColor violet() { return new FSColor(0xEE, 0x82, 0xEE, 0xFF); }
-    /** Definition of the color, wheat from the Netscape color table. */
-    public static FSColor wheat() { return new FSColor(0xF5, 0xDE, 0xB3, 0xFF); }
-    /** Definition of the color, white from the Netscape color table. */
-    public static FSColor white() { return new FSColor(0xFF, 0xFF, 0xFF, 0xFF); }
-    /** Definition of the color, whitesmoke from the Netscape color table. */
-    public static FSColor whitesmoke() { return new FSColor(0xF5, 0xF5, 0xF5, 0xFF); }
-    /** Definition of the color, yellow from the Netscape color table. */
-    public static FSColor yellow() { return new FSColor(0xFF, 0xFF, 0x00, 0xFF); }
-    /** Definition of the color, yellowgreen from the Netscape color table. */
-    public static FSColor yellowgreen() { return new FSColor(0x9A, 0xCD, 0x32, 0xFF); } 
+	/** Definition of the color, aliceblue from the Netscape color table. */
+	public static FSColor aliceblue()
+	{
+		return new FSColor(0xF0, 0xF8, 0xFF, 0xFF);
+	}
 
-    /** Definition of the transparent color, aliceblue from the Netscape color table. */
-    public static FSColor aliceblue(int alpha) { return new FSColor(0xF0, 0xF8, 0xFF, alpha); }
-    /** Definition of the transparent color, antiquewhite from the Netscape color table. */
-    public static FSColor antiquewhite(int alpha) { return new FSColor(0xFA, 0xEB, 0xD7, alpha); }
-    /** Definition of the transparent color, aqua from the Netscape color table. */
-    public static FSColor aqua(int alpha) { return new FSColor(0x00, 0xFF, 0xFF, alpha); }
-    /** Definition of the transparent color, aquamarine from the Netscape color table. */
-    public static FSColor aquamarine(int alpha) { return new FSColor(0x7F, 0xFF, 0xD4, alpha); }
-    /** Definition of the transparent color, azure from the Netscape color table. */
-    public static FSColor azure(int alpha) { return new FSColor(0xF0, 0xFF, 0xFF, alpha); }
-    /** Definition of the transparent color, beige from the Netscape color table. */
-    public static FSColor beige(int alpha) { return new FSColor(0xF5, 0xF5, 0xDC, alpha); }
-    /** Definition of the transparent color, bisque from the Netscape color table. */
-    public static FSColor bisque(int alpha) { return new FSColor(0xFF, 0xE4, 0xC4, alpha); }
-    /** Definition of the transparent color, black from the Netscape color table. */
-    public static FSColor black(int alpha) { return new FSColor(0x00, 0x00, 0x00, alpha); }
-    /** Definition of the transparent color, blanchedalmond from the Netscape color table. */
-    public static FSColor blanchedalmond(int alpha) { return new FSColor(0xFF, 0xEB, 0xCD, alpha); }
-    /** Definition of the transparent color, blue from the Netscape color table. */
-    public static FSColor blue(int alpha) { return new FSColor(0x00, 0x00, 0xFF, alpha); }
-    /** Definition of the transparent color, blueviolet from the Netscape color table. */
-    public static FSColor blueviolet(int alpha) { return new FSColor(0x8A, 0x2B, 0xE2, alpha); }
-    /** Definition of the transparent color, brown from the Netscape color table. */
-    public static FSColor brown(int alpha) { return new FSColor(0xA5, 0x2A, 0x2A, alpha); }
-    /** Definition of the transparent color, burlywood from the Netscape color table. */
-    public static FSColor burlywood(int alpha) { return new FSColor(0xDE, 0xB8, 0x87, alpha); }
-    /** Definition of the transparent color, cadetblue from the Netscape color table. */
-    public static FSColor cadetblue(int alpha) { return new FSColor(0x5F, 0x9E, 0xA0, alpha); }
-    /** Definition of the transparent color, chartreuse from the Netscape color table. */
-    public static FSColor chartreuse(int alpha) { return new FSColor(0x7F, 0xFF, 0x00, alpha); }
-    /** Definition of the transparent color, chocolate from the Netscape color table. */
-    public static FSColor chocolate(int alpha) { return new FSColor(0xD2, 0x69, 0x1E, alpha); }
-    /** Definition of the transparent color, coral from the Netscape color table. */
-    public static FSColor coral(int alpha) { return new FSColor(0xFF, 0x7F, 0x50, alpha); }
-    /** Definition of the transparent color, cornflowerblue from the Netscape color table. */
-    public static FSColor cornflowerblue(int alpha) { return new FSColor(0x64, 0x95, 0xED, alpha); }
-    /** Definition of the transparent color, cornsilk from the Netscape color table. */
-    public static FSColor cornsilk(int alpha) { return new FSColor(0xFF, 0xF8, 0xDC, alpha); }
-    /** Definition of the transparent color, crimson from the Netscape color table. */
-    public static FSColor crimson(int alpha) { return new FSColor(0xDC, 0x14, 0x3C, alpha); }
-    /** Definition of the transparent color, cyan from the Netscape color table. */
-    public static FSColor cyan(int alpha) { return new FSColor(0x00, 0xFF, 0xFF, alpha); }
-    /** Definition of the transparent color, darkblue from the Netscape color table. */
-    public static FSColor darkblue(int alpha) { return new FSColor(0x00, 0x00, 0x8B, alpha); }
-    /** Definition of the transparent color, darkcyan from the Netscape color table. */
-    public static FSColor darkcyan(int alpha) { return new FSColor(0x00, 0x8B, 0x8B, alpha); }
-    /** Definition of the transparent color, darkgoldenrod from the Netscape color table. */
-    public static FSColor darkgoldenrod(int alpha) { return new FSColor(0xB8, 0x86, 0x0B, alpha); }
-    /** Definition of the transparent color, darkgray from the Netscape color table. */
-    public static FSColor darkgray(int alpha) { return new FSColor(0xA9, 0xA9, 0xA9, alpha); }
-    /** Definition of the transparent color, darkgreen from the Netscape color table. */
-    public static FSColor darkgreen(int alpha) { return new FSColor(0x00, 0x64, 0x00, alpha); }
-    /** Definition of the transparent color, darkkhaki from the Netscape color table. */
-    public static FSColor darkkhaki(int alpha) { return new FSColor(0xBD, 0xB7, 0x6B, alpha); }
-    /** Definition of the transparent color, darkmagenta from the Netscape color table. */
-    public static FSColor darkmagenta(int alpha) { return new FSColor(0x8B, 0x00, 0x8B, alpha); }
-    /** Definition of the transparent color, darkolivegreen from the Netscape color table. */
-    public static FSColor darkolivegreen(int alpha) { return new FSColor(0x55, 0x6B, 0x2F, alpha); }
-    /** Definition of the transparent color, darkorange from the Netscape color table. */
-    public static FSColor darkorange(int alpha) { return new FSColor(0xFF, 0x8C, 0x00, alpha); }
-    /** Definition of the transparent color, darkorchid from the Netscape color table. */
-    public static FSColor darkorchid(int alpha) { return new FSColor(0x99, 0x32, 0xCC, alpha); }
-    /** Definition of the transparent color, darkred from the Netscape color table. */
-    public static FSColor darkred(int alpha) { return new FSColor(0x8B, 0x00, 0x00, alpha); }
-    /** Definition of the transparent color, darksalmon from the Netscape color table. */
-    public static FSColor darksalmon(int alpha) { return new FSColor(0xE9, 0x96, 0x7A, alpha); }
-    /** Definition of the transparent color, darkseagreen from the Netscape color table. */
-    public static FSColor darkseagreen(int alpha) { return new FSColor(0x8F, 0xBC, 0x8F, alpha); }
-    /** Definition of the transparent color, darkslateblue from the Netscape color table. */
-    public static FSColor darkslateblue(int alpha) { return new FSColor(0x48, 0x3D, 0x8B, alpha); }
-    /** Definition of the transparent color, darkslategray from the Netscape color table. */
-    public static FSColor darkslategray(int alpha) { return new FSColor(0x2F, 0x4F, 0x4F, alpha); }
-    /** Definition of the transparent color, darkturquoise from the Netscape color table. */
-    public static FSColor darkturquoise(int alpha) { return new FSColor(0x00, 0xCE, 0xD1, alpha); }
-    /** Definition of the transparent color, darkviolet from the Netscape color table. */
-    public static FSColor darkviolet(int alpha) { return new FSColor(0x94, 0x00, 0xD3, alpha); }
-    /** Definition of the transparent color, deeppink from the Netscape color table. */
-    public static FSColor deeppink(int alpha) { return new FSColor(0xFF, 0x14, 0x93, alpha); }
-    /** Definition of the transparent color, deepskyblue from the Netscape color table. */
-    public static FSColor deepskyblue(int alpha) { return new FSColor(0x00, 0xBF, 0xFF, alpha); }
-    /** Definition of the transparent color, dimgray from the Netscape color table. */
-    public static FSColor dimgray(int alpha) { return new FSColor(0x69, 0x69, 0x69, alpha); }
-    /** Definition of the transparent color, dodgerblue from the Netscape color table. */
-    public static FSColor dodgerblue(int alpha) { return new FSColor(0x1E, 0x90, 0xFF, alpha); }
-    /** Definition of the transparent color, firebrick from the Netscape color table. */
-    public static FSColor firebrick(int alpha) { return new FSColor(0xB2, 0x22, 0x22, alpha); }
-    /** Definition of the transparent color, floralwhite from the Netscape color table. */
-    public static FSColor floralwhite(int alpha) { return new FSColor(0xFF, 0xFA, 0xF0, alpha); }
-    /** Definition of the transparent color, forestgreen from the Netscape color table. */
-    public static FSColor forestgreen(int alpha) { return new FSColor(0x22, 0x8B, 0x22, alpha); }
-    /** Definition of the transparent color, fuchsia from the Netscape color table. */
-    public static FSColor fuchsia(int alpha) { return new FSColor(0xFF, 0x00, 0xFF, alpha); }
-    /** Definition of the transparent color, gainsboro from the Netscape color table. */
-    public static FSColor gainsboro(int alpha) { return new FSColor(0xDC, 0xDC, 0xDC, alpha); }
-    /** Definition of the transparent color, ghostwhite from the Netscape color table. */
-    public static FSColor ghostwhite(int alpha) { return new FSColor(0xF8, 0xF8, 0xFB, alpha); }
-    /** Definition of the transparent color, gold from the Netscape color table. */
-    public static FSColor gold(int alpha) { return new FSColor(0xFF, 0xD7, 0x00, alpha); }
-    /** Definition of the transparent color, goldenrod from the Netscape color table. */
-    public static FSColor goldenrod(int alpha) { return new FSColor(0xDA, 0xA5, 0x20, alpha); }
-    /** Definition of the transparent color, gray from the Netscape color table. */
-    public static FSColor gray(int alpha) { return new FSColor(0x80, 0x80, 0x80, alpha); }
-    /** Definition of the transparent color, green from the Netscape color table. */
-    public static FSColor green(int alpha) { return new FSColor(0x00, 0x80, 0x00, alpha); }
-    /** Definition of the transparent color, greenyellow from the Netscape color table. */
-    public static FSColor greenyellow(int alpha) { return new FSColor(0xAD, 0xFF, 0x2F, alpha); }
-    /** Definition of the transparent color, honeydew from the Netscape color table. */
-    public static FSColor honeydew(int alpha) { return new FSColor(0xF0, 0xFF, 0xF0, alpha); }
-    /** Definition of the transparent color, hotpink from the Netscape color table. */
-    public static FSColor hotpink(int alpha) { return new FSColor(0xFF, 0x69, 0xB4, alpha); }
-    /** Definition of the transparent color, indianred from the Netscape color table. */
-    public static FSColor indianred(int alpha) { return new FSColor(0xCD, 0x5C, 0x5C, alpha); }
-    /** Definition of the transparent color, indigo from the Netscape color table. */
-    public static FSColor indigo(int alpha) { return new FSColor(0x4B, 0x00, 0x82, alpha); }
-    /** Definition of the transparent color, ivory from the Netscape color table. */
-    public static FSColor ivory(int alpha) { return new FSColor(0xFF, 0xFF, 0xF0, alpha); }
-    /** Definition of the transparent color, khaki from the Netscape color table. */
-    public static FSColor khaki(int alpha) { return new FSColor(0xF0, 0xE6, 0x8C, alpha); }
-    /** Definition of the transparent color, lavender from the Netscape color table. */
-    public static FSColor lavender(int alpha) { return new FSColor(0xE6, 0xE6, 0xFA, alpha); }
-    /** Definition of the transparent color, lavenderblush from the Netscape color table. */
-    public static FSColor lavenderblush(int alpha) { return new FSColor(0xFF, 0xF0, 0xF5, alpha); }
-    /** Definition of the transparent color, lawngreen from the Netscape color table. */
-    public static FSColor lawngreen(int alpha) { return new FSColor(0x7C, 0xFC, 0x00, alpha); }
-    /** Definition of the transparent color, lemonchiffon from the Netscape color table. */
-    public static FSColor lemonchiffon(int alpha) { return new FSColor(0xFF, 0xFA, 0xCD, alpha); }
-    /** Definition of the transparent color, lightblue from the Netscape color table. */
-    public static FSColor lightblue(int alpha) { return new FSColor(0xAD, 0xD8, 0xE6, alpha); }
-    /** Definition of the transparent color, lightcoral from the Netscape color table. */
-    public static FSColor lightcoral(int alpha) { return new FSColor(0xF0, 0x80, 0x80, alpha); }
-    /** Definition of the transparent color, lightcyan from the Netscape color table. */
-    public static FSColor lightcyan(int alpha) { return new FSColor(0xE0, 0xFF, 0xFF, alpha); }
-    /** Definition of the transparent color, lightgoldenrodyellow from the Netscape color table. */
-    public static FSColor lightgoldenrodyellow(int alpha) { return new FSColor(0xFA, 0xFA, 0xD2, alpha); }
-    /** Definition of the transparent color, lightgreen from the Netscape color table. */
-    public static FSColor lightgreen(int alpha) { return new FSColor(0x90, 0xEE, 0x90, alpha); }
-    /** Definition of the transparent color, lightgrey from the Netscape color table. */
-    public static FSColor lightgrey(int alpha) { return new FSColor(0xD3, 0xD3, 0xD3, alpha); }
-    /** Definition of the transparent color, lightpink from the Netscape color table. */
-    public static FSColor lightpink(int alpha) { return new FSColor(0xFF, 0xB6, 0xC1, alpha); }
-    /** Definition of the transparent color, lightsalmon from the Netscape color table. */
-    public static FSColor lightsalmon(int alpha) { return new FSColor(0xFF, 0xA0, 0x7A, alpha); }
-    /** Definition of the transparent color, lightseagreen from the Netscape color table. */
-    public static FSColor lightseagreen(int alpha) { return new FSColor(0x20, 0xB2, 0xAA, alpha); }
-    /** Definition of the transparent color, lightskyblue from the Netscape color table. */
-    public static FSColor lightskyblue(int alpha) { return new FSColor(0x87, 0xCE, 0xFA, alpha); }
-    /** Definition of the transparent color, lightslategray from the Netscape color table. */
-    public static FSColor lightslategray(int alpha) { return new FSColor(0x77, 0x88, 0x99, alpha); }
-    /** Definition of the transparent color, lightsteelblue from the Netscape color table. */
-    public static FSColor lightsteelblue(int alpha) { return new FSColor(0xB0, 0xC4, 0xDE, alpha); }
-    /** Definition of the transparent color, lightyellow from the Netscape color table. */
-    public static FSColor lightyellow(int alpha) { return new FSColor(0xFF, 0xFF, 0xE0, alpha); }
-    /** Definition of the transparent color, lime from the Netscape color table. */
-    public static FSColor lime(int alpha) { return new FSColor(0x00, 0xFF, 0x00, alpha); }
-    /** Definition of the transparent color, limegreen from the Netscape color table. */
-    public static FSColor limegreen(int alpha) { return new FSColor(0x32, 0xCD, 0x32, alpha); }
-    /** Definition of the transparent color, linen from the Netscape color table. */
-    public static FSColor linen(int alpha) { return new FSColor(0xFA, 0xF0, 0xE6, alpha); }
-    /** Definition of the transparent color, magenta from the Netscape color table. */
-    public static FSColor magenta(int alpha) { return new FSColor(0xFF, 0x00, 0xFF, alpha); }
-    /** Definition of the transparent color, maroon from the Netscape color table. */
-    public static FSColor maroon(int alpha) { return new FSColor(0x80, 0x00, 0x00, alpha); }
-    /** Definition of the transparent color, mediumaquamarine from the Netscape color table. */
-    public static FSColor mediumaquamarine(int alpha) { return new FSColor(0x66, 0xCD, 0xAA, alpha); }
-    /** Definition of the transparent color, mediumblue from the Netscape color table. */
-    public static FSColor mediumblue(int alpha) { return new FSColor(0x00, 0x00, 0xCD, alpha); }
-    /** Definition of the transparent color, mediumorchid from the Netscape color table. */
-    public static FSColor mediumorchid(int alpha) { return new FSColor(0xBA, 0x55, 0xD3, alpha); }
-    /** Definition of the transparent color, mediumpurple from the Netscape color table. */
-    public static FSColor mediumpurple(int alpha) { return new FSColor(0x93, 0x70, 0xDB, alpha); }
-    /** Definition of the transparent color, mediumseagreen from the Netscape color table. */
-    public static FSColor mediumseagreen(int alpha) { return new FSColor(0x3C, 0xB3, 0x71, alpha); }
-    /** Definition of the transparent color, mediumslateblue from the Netscape color table. */
-    public static FSColor mediumslateblue(int alpha) { return new FSColor(0x7B, 0x68, 0xEE, alpha); }
-    /** Definition of the transparent color, mediumspringgreen from the Netscape color table. */
-    public static FSColor mediumspringgreen(int alpha) { return new FSColor(0x00, 0xFA, 0x9A, alpha); }
-    /** Definition of the transparent color, mediumturquoise from the Netscape color table. */
-    public static FSColor mediumturquoise(int alpha) { return new FSColor(0x48, 0xD1, 0xCC, alpha); }
-    /** Definition of the transparent color, mediumvioletred from the Netscape color table. */
-    public static FSColor mediumvioletred(int alpha) { return new FSColor(0xC7, 0x15, 0x85, alpha); }
-    /** Definition of the transparent color, midnightblue from the Netscape color table. */
-    public static FSColor midnightblue(int alpha) { return new FSColor(0x19, 0x19, 0x70, alpha); }
-    /** Definition of the transparent color, mintcream from the Netscape color table. */
-    public static FSColor mintcream(int alpha) { return new FSColor(0xF5, 0xFF, 0xFA, alpha); }
-    /** Definition of the transparent color, mistyrose from the Netscape color table. */
-    public static FSColor mistyrose(int alpha) { return new FSColor(0xFF, 0xE4, 0xE1, alpha); }
-    /** Definition of the transparent color, moccasin from the Netscape color table. */
-    public static FSColor moccasin(int alpha) { return new FSColor(0xFF, 0xE4, 0xB5, alpha); }
-    /** Definition of the transparent color, navajowhite from the Netscape color table. */
-    public static FSColor navajowhite(int alpha) { return new FSColor(0xFF, 0xDE, 0xAD, alpha); }
-    /** Definition of the transparent color, navy from the Netscape color table. */
-    public static FSColor navy(int alpha) { return new FSColor(0x00, 0x00, 0x80, alpha); }
-    /** Definition of the transparent color, oldlace from the Netscape color table. */
-    public static FSColor oldlace(int alpha) { return new FSColor(0xFD, 0xF5, 0xE6, alpha); }
-    /** Definition of the transparent color, olive from the Netscape color table. */
-    public static FSColor olive(int alpha) { return new FSColor(0x80, 0x80, 0x00, alpha); }
-    /** Definition of the transparent color, olivedrab from the Netscape color table. */
-    public static FSColor olivedrab(int alpha) { return new FSColor(0x6B, 0x8E, 0x23, alpha); }
-    /** Definition of the transparent color, orange from the Netscape color table. */
-    public static FSColor orange(int alpha) { return new FSColor(0xFF, 0xA5, 0x00, alpha); }
-    /** Definition of the transparent color, orangered from the Netscape color table. */
-    public static FSColor orangered(int alpha) { return new FSColor(0xFF, 0x45, 0x00, alpha); }
-    /** Definition of the transparent color, orchid from the Netscape color table. */
-    public static FSColor orchid(int alpha) { return new FSColor(0xDA, 0x70, 0xD6, alpha); }
-    /** Definition of the transparent color, palegoldenrod from the Netscape color table. */
-    public static FSColor palegoldenrod(int alpha) { return new FSColor(0xEE, 0xE8, 0xAA, alpha); }
-    /** Definition of the transparent color, palegreen from the Netscape color table. */
-    public static FSColor palegreen(int alpha) { return new FSColor(0x98, 0xFB, 0x98, alpha); }
-    /** Definition of the transparent color, paleturquoise from the Netscape color table. */
-    public static FSColor paleturquoise(int alpha) { return new FSColor(0xAF, 0xEE, 0xEE, alpha); }
-    /** Definition of the transparent color, palevioletred from the Netscape color table. */
-    public static FSColor palevioletred(int alpha) { return new FSColor(0xDB, 0x70, 0x93, alpha); }
-    /** Definition of the transparent color, papayawhip from the Netscape color table. */
-    public static FSColor papayawhip(int alpha) { return new FSColor(0xFF, 0xEF, 0xD5, alpha); }
-    /** Definition of the transparent color, peachpuff from the Netscape color table. */
-    public static FSColor peachpuff(int alpha) { return new FSColor(0xFF, 0xDA, 0xB9, alpha); }
-    /** Definition of the transparent color, peru from the Netscape color table. */
-    public static FSColor peru(int alpha) { return new FSColor(0xCD, 0x85, 0x3F, alpha); }
-    /** Definition of the transparent color, pink from the Netscape color table. */
-    public static FSColor pink(int alpha) { return new FSColor(0xFF, 0xC0, 0xCB, alpha); }
-    /** Definition of the transparent color, plum from the Netscape color table. */
-    public static FSColor plum(int alpha) { return new FSColor(0xDD, 0xA0, 0xDD, alpha); }
-    /** Definition of the transparent color, powderblue from the Netscape color table. */
-    public static FSColor powderblue(int alpha) { return new FSColor(0xB0, 0xE0, 0xE6, alpha); }
-    /** Definition of the transparent color, purple from the Netscape color table. */
-    public static FSColor purple(int alpha) { return new FSColor(0x80, 0x00, 0x80, alpha); }
-    /** Definition of the transparent color, red from the Netscape color table. */
-    public static FSColor red(int alpha) { return new FSColor(0xFF, 0x00, 0x00, alpha); }
-    /** Definition of the transparent color, rosybrown from the Netscape color table. */
-    public static FSColor rosybrown(int alpha) { return new FSColor(0xBC, 0x8F, 0x8F, alpha); }
-    /** Definition of the transparent color, royalblue from the Netscape color table. */
-    public static FSColor royalblue(int alpha) { return new FSColor(0x41, 0x69, 0xE1, alpha); }
-    /** Definition of the transparent color, saddlebrown from the Netscape color table. */
-    public static FSColor saddlebrown(int alpha) { return new FSColor(0x8B, 0x45, 0x13, alpha); }
-    /** Definition of the transparent color, salmon from the Netscape color table. */
-    public static FSColor salmon(int alpha) { return new FSColor(0xFA, 0x80, 0x72, alpha); }
-    /** Definition of the transparent color, sandybrown from the Netscape color table. */
-    public static FSColor sandybrown(int alpha) { return new FSColor(0xF4, 0xA4, 0x60, alpha); }
-    /** Definition of the transparent color, seagreen from the Netscape color table. */
-    public static FSColor seagreen(int alpha) { return new FSColor(0x2E, 0x8B, 0x57, alpha); }
-    /** Definition of the transparent color, seashell from the Netscape color table. */
-    public static FSColor seashell(int alpha) { return new FSColor(0xFF, 0xF5, 0xEE, alpha); }
-    /** Definition of the transparent color, sienna from the Netscape color table. */
-    public static FSColor sienna(int alpha) { return new FSColor(0xA0, 0x52, 0x2d, alpha); }
-    /** Definition of the transparent color, silver from the Netscape color table. */
-    public static FSColor silver(int alpha) { return new FSColor(0xC0, 0xC0, 0xC0, alpha); }
-    /** Definition of the transparent color, skyblue from the Netscape color table. */
-    public static FSColor skyblue(int alpha) { return new FSColor(0x87, 0xCE, 0xEB, alpha); }
-    /** Definition of the transparent color, slateblue from the Netscape color table. */
-    public static FSColor slateblue(int alpha) { return new FSColor(0x6A, 0x5A, 0xCD, alpha); }
-    /** Definition of the transparent color, slategray from the Netscape color table. */
-    public static FSColor slategray(int alpha) { return new FSColor(0x70, 0x80, 0x90, alpha); }
-    /** Definition of the transparent color, snow from the Netscape color table. */
-    public static FSColor snow(int alpha) { return new FSColor(0xFF, 0xFA, 0xFA, alpha); }
-    /** Definition of the transparent color, springgreen from the Netscape color table. */
-    public static FSColor springgreen(int alpha) { return new FSColor(0x00, 0xFF, 0x7F, alpha); }
-    /** Definition of the transparent color, steelblue from the Netscape color table. */
-    public static FSColor steelblue(int alpha) { return new FSColor(0x46, 0x82, 0xB4, alpha); }
-    /** Definition of the transparent color, tan from the Netscape color table. */
-    public static FSColor tan(int alpha) { return new FSColor(0xD2, 0xB4, 0x8C, alpha); }
-    /** Definition of the transparent color, teal from the Netscape color table. */
-    public static FSColor teal(int alpha) { return new FSColor(0x00, 0x80, 0x80, alpha); }
-    /** Definition of the transparent color, thistle from the Netscape color table. */
-    public static FSColor thistle(int alpha) { return new FSColor(0xD8, 0xBF, 0xD8, alpha); }
-    /** Definition of the transparent color, tomato from the Netscape color table. */
-    public static FSColor tomato(int alpha) { return new FSColor(0xFF, 0x63, 0x47, alpha); }
-    /** Definition of the transparent color, turquoise from the Netscape color table. */
-    public static FSColor turquoise(int alpha) { return new FSColor(0x40, 0xE0, 0xD0, alpha); }
-    /** Definition of the transparent color, violet from the Netscape color table. */
-    public static FSColor violet(int alpha) { return new FSColor(0xEE, 0x82, 0xEE, alpha); }
-    /** Definition of the transparent color, wheat from the Netscape color table. */
-    public static FSColor wheat(int alpha) { return new FSColor(0xF5, 0xDE, 0xB3, alpha); }
-    /** Definition of the transparent color, white from the Netscape color table. */
-    public static FSColor white(int alpha) { return new FSColor(0xFF, 0xFF, 0xFF, alpha); }
-    /** Definition of the transparent color, whitesmoke from the Netscape color table. */
-    public static FSColor whitesmoke(int alpha) { return new FSColor(0xF5, 0xF5, 0xF5, alpha); }
-    /** Definition of the transparent color, yellow from the Netscape color table. */
-    public static FSColor yellow(int alpha) { return new FSColor(0xFF, 0xFF, 0x00, alpha); }
-    /** Definition of the transparent color, yellowgreen from the Netscape color table. */
-    public static FSColor yellowgreen(int alpha) { return new FSColor(0x9A, 0xCD, 0x32, alpha); } 
+	/** Definition of the color, antiquewhite from the Netscape color table. */
+	public static FSColor antiquewhite()
+	{
+		return new FSColor(0xFA, 0xEB, 0xD7, 0xFF);
+	}
+
+	/** Definition of the color, aqua from the Netscape color table. */
+	public static FSColor aqua()
+	{
+		return new FSColor(0x00, 0xFF, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, aquamarine from the Netscape color table. */
+	public static FSColor aquamarine()
+	{
+		return new FSColor(0x7F, 0xFF, 0xD4, 0xFF);
+	}
+
+	/** Definition of the color, azure from the Netscape color table. */
+	public static FSColor azure()
+	{
+		return new FSColor(0xF0, 0xFF, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, beige from the Netscape color table. */
+	public static FSColor beige()
+	{
+		return new FSColor(0xF5, 0xF5, 0xDC, 0xFF);
+	}
+
+	/** Definition of the color, bisque from the Netscape color table. */
+	public static FSColor bisque()
+	{
+		return new FSColor(0xFF, 0xE4, 0xC4, 0xFF);
+	}
+
+	/** Definition of the color, black from the Netscape color table. */
+	public static FSColor black()
+	{
+		return new FSColor(0x00, 0x00, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, blanchedalmond from the Netscape color table. */
+	public static FSColor blanchedalmond()
+	{
+		return new FSColor(0xFF, 0xEB, 0xCD, 0xFF);
+	}
+
+	/** Definition of the color, blue from the Netscape color table. */
+	public static FSColor blue()
+	{
+		return new FSColor(0x00, 0x00, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, blueviolet from the Netscape color table. */
+	public static FSColor blueviolet()
+	{
+		return new FSColor(0x8A, 0x2B, 0xE2, 0xFF);
+	}
+
+	/** Definition of the color, brown from the Netscape color table. */
+	public static FSColor brown()
+	{
+		return new FSColor(0xA5, 0x2A, 0x2A, 0xFF);
+	}
+
+	/** Definition of the color, burlywood from the Netscape color table. */
+	public static FSColor burlywood()
+	{
+		return new FSColor(0xDE, 0xB8, 0x87, 0xFF);
+	}
+
+	/** Definition of the color, cadetblue from the Netscape color table. */
+	public static FSColor cadetblue()
+	{
+		return new FSColor(0x5F, 0x9E, 0xA0, 0xFF);
+	}
+
+	/** Definition of the color, chartreuse from the Netscape color table. */
+	public static FSColor chartreuse()
+	{
+		return new FSColor(0x7F, 0xFF, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, chocolate from the Netscape color table. */
+	public static FSColor chocolate()
+	{
+		return new FSColor(0xD2, 0x69, 0x1E, 0xFF);
+	}
+
+	/** Definition of the color, coral from the Netscape color table. */
+	public static FSColor coral()
+	{
+		return new FSColor(0xFF, 0x7F, 0x50, 0xFF);
+	}
+
+	/** Definition of the color, cornflowerblue from the Netscape color table. */
+	public static FSColor cornflowerblue()
+	{
+		return new FSColor(0x64, 0x95, 0xED, 0xFF);
+	}
+
+	/** Definition of the color, cornsilk from the Netscape color table. */
+	public static FSColor cornsilk()
+	{
+		return new FSColor(0xFF, 0xF8, 0xDC, 0xFF);
+	}
+
+	/** Definition of the color, crimson from the Netscape color table. */
+	public static FSColor crimson()
+	{
+		return new FSColor(0xDC, 0x14, 0x3C, 0xFF);
+	}
+
+	/** Definition of the color, cyan from the Netscape color table. */
+	public static FSColor cyan()
+	{
+		return new FSColor(0x00, 0xFF, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, darkblue from the Netscape color table. */
+	public static FSColor darkblue()
+	{
+		return new FSColor(0x00, 0x00, 0x8B, 0xFF);
+	}
+
+	/** Definition of the color, darkcyan from the Netscape color table. */
+	public static FSColor darkcyan()
+	{
+		return new FSColor(0x00, 0x8B, 0x8B, 0xFF);
+	}
+
+	/** Definition of the color, darkgoldenrod from the Netscape color table. */
+	public static FSColor darkgoldenrod()
+	{
+		return new FSColor(0xB8, 0x86, 0x0B, 0xFF);
+	}
+
+	/** Definition of the color, darkgray from the Netscape color table. */
+	public static FSColor darkgray()
+	{
+		return new FSColor(0xA9, 0xA9, 0xA9, 0xFF);
+	}
+
+	/** Definition of the color, darkgreen from the Netscape color table. */
+	public static FSColor darkgreen()
+	{
+		return new FSColor(0x00, 0x64, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, darkkhaki from the Netscape color table. */
+	public static FSColor darkkhaki()
+	{
+		return new FSColor(0xBD, 0xB7, 0x6B, 0xFF);
+	}
+
+	/** Definition of the color, darkmagenta from the Netscape color table. */
+	public static FSColor darkmagenta()
+	{
+		return new FSColor(0x8B, 0x00, 0x8B, 0xFF);
+	}
+
+	/** Definition of the color, darkolivegreen from the Netscape color table. */
+	public static FSColor darkolivegreen()
+	{
+		return new FSColor(0x55, 0x6B, 0x2F, 0xFF);
+	}
+
+	/** Definition of the color, darkorange from the Netscape color table. */
+	public static FSColor darkorange()
+	{
+		return new FSColor(0xFF, 0x8C, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, darkorchid from the Netscape color table. */
+	public static FSColor darkorchid()
+	{
+		return new FSColor(0x99, 0x32, 0xCC, 0xFF);
+	}
+
+	/** Definition of the color, darkred from the Netscape color table. */
+	public static FSColor darkred()
+	{
+		return new FSColor(0x8B, 0x00, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, darksalmon from the Netscape color table. */
+	public static FSColor darksalmon()
+	{
+		return new FSColor(0xE9, 0x96, 0x7A, 0xFF);
+	}
+
+	/** Definition of the color, darkseagreen from the Netscape color table. */
+	public static FSColor darkseagreen()
+	{
+		return new FSColor(0x8F, 0xBC, 0x8F, 0xFF);
+	}
+
+	/** Definition of the color, darkslateblue from the Netscape color table. */
+	public static FSColor darkslateblue()
+	{
+		return new FSColor(0x48, 0x3D, 0x8B, 0xFF);
+	}
+
+	/** Definition of the color, darkslategray from the Netscape color table. */
+	public static FSColor darkslategray()
+	{
+		return new FSColor(0x2F, 0x4F, 0x4F, 0xFF);
+	}
+
+	/** Definition of the color, darkturquoise from the Netscape color table. */
+	public static FSColor darkturquoise()
+	{
+		return new FSColor(0x00, 0xCE, 0xD1, 0xFF);
+	}
+
+	/** Definition of the color, darkviolet from the Netscape color table. */
+	public static FSColor darkviolet()
+	{
+		return new FSColor(0x94, 0x00, 0xD3, 0xFF);
+	}
+
+	/** Definition of the color, deeppink from the Netscape color table. */
+	public static FSColor deeppink()
+	{
+		return new FSColor(0xFF, 0x14, 0x93, 0xFF);
+	}
+
+	/** Definition of the color, deepskyblue from the Netscape color table. */
+	public static FSColor deepskyblue()
+	{
+		return new FSColor(0x00, 0xBF, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, dimgray from the Netscape color table. */
+	public static FSColor dimgray()
+	{
+		return new FSColor(0x69, 0x69, 0x69, 0xFF);
+	}
+
+	/** Definition of the color, dodgerblue from the Netscape color table. */
+	public static FSColor dodgerblue()
+	{
+		return new FSColor(0x1E, 0x90, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, firebrick from the Netscape color table. */
+	public static FSColor firebrick()
+	{
+		return new FSColor(0xB2, 0x22, 0x22, 0xFF);
+	}
+
+	/** Definition of the color, floralwhite from the Netscape color table. */
+	public static FSColor floralwhite()
+	{
+		return new FSColor(0xFF, 0xFA, 0xF0, 0xFF);
+	}
+
+	/** Definition of the color, forestgreen from the Netscape color table. */
+	public static FSColor forestgreen()
+	{
+		return new FSColor(0x22, 0x8B, 0x22, 0xFF);
+	}
+
+	/** Definition of the color, fuchsia from the Netscape color table. */
+	public static FSColor fuchsia()
+	{
+		return new FSColor(0xFF, 0x00, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, gainsboro from the Netscape color table. */
+	public static FSColor gainsboro()
+	{
+		return new FSColor(0xDC, 0xDC, 0xDC, 0xFF);
+	}
+
+	/** Definition of the color, ghostwhite from the Netscape color table. */
+	public static FSColor ghostwhite()
+	{
+		return new FSColor(0xF8, 0xF8, 0xFB, 0xFF);
+	}
+
+	/** Definition of the color, gold from the Netscape color table. */
+	public static FSColor gold()
+	{
+		return new FSColor(0xFF, 0xD7, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, goldenrod from the Netscape color table. */
+	public static FSColor goldenrod()
+	{
+		return new FSColor(0xDA, 0xA5, 0x20, 0xFF);
+	}
+
+	/** Definition of the color, gray from the Netscape color table. */
+	public static FSColor gray()
+	{
+		return new FSColor(0x80, 0x80, 0x80, 0xFF);
+	}
+
+	/** Definition of the color, green from the Netscape color table. */
+	public static FSColor green()
+	{
+		return new FSColor(0x00, 0x80, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, greenyellow from the Netscape color table. */
+	public static FSColor greenyellow()
+	{
+		return new FSColor(0xAD, 0xFF, 0x2F, 0xFF);
+	}
+
+	/** Definition of the color, honeydew from the Netscape color table. */
+	public static FSColor honeydew()
+	{
+		return new FSColor(0xF0, 0xFF, 0xF0, 0xFF);
+	}
+
+	/** Definition of the color, hotpink from the Netscape color table. */
+	public static FSColor hotpink()
+	{
+		return new FSColor(0xFF, 0x69, 0xB4, 0xFF);
+	}
+
+	/** Definition of the color, indianred from the Netscape color table. */
+	public static FSColor indianred()
+	{
+		return new FSColor(0xCD, 0x5C, 0x5C, 0xFF);
+	}
+
+	/** Definition of the color, indigo from the Netscape color table. */
+	public static FSColor indigo()
+	{
+		return new FSColor(0x4B, 0x00, 0x82, 0xFF);
+	}
+
+	/** Definition of the color, ivory from the Netscape color table. */
+	public static FSColor ivory()
+	{
+		return new FSColor(0xFF, 0xFF, 0xF0, 0xFF);
+	}
+
+	/** Definition of the color, khaki from the Netscape color table. */
+	public static FSColor khaki()
+	{
+		return new FSColor(0xF0, 0xE6, 0x8C, 0xFF);
+	}
+
+	/** Definition of the color, lavender from the Netscape color table. */
+	public static FSColor lavender()
+	{
+		return new FSColor(0xE6, 0xE6, 0xFA, 0xFF);
+	}
+
+	/** Definition of the color, lavenderblush from the Netscape color table. */
+	public static FSColor lavenderblush()
+	{
+		return new FSColor(0xFF, 0xF0, 0xF5, 0xFF);
+	}
+
+	/** Definition of the color, lawngreen from the Netscape color table. */
+	public static FSColor lawngreen()
+	{
+		return new FSColor(0x7C, 0xFC, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, lemonchiffon from the Netscape color table. */
+	public static FSColor lemonchiffon()
+	{
+		return new FSColor(0xFF, 0xFA, 0xCD, 0xFF);
+	}
+
+	/** Definition of the color, lightblue from the Netscape color table. */
+	public static FSColor lightblue()
+	{
+		return new FSColor(0xAD, 0xD8, 0xE6, 0xFF);
+	}
+
+	/** Definition of the color, lightcoral from the Netscape color table. */
+	public static FSColor lightcoral()
+	{
+		return new FSColor(0xF0, 0x80, 0x80, 0xFF);
+	}
+
+	/** Definition of the color, lightcyan from the Netscape color table. */
+	public static FSColor lightcyan()
+	{
+		return new FSColor(0xE0, 0xFF, 0xFF, 0xFF);
+	}
+
+	/**
+	 * Definition of the color, lightgoldenrodyellow from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightgoldenrodyellow()
+	{
+		return new FSColor(0xFA, 0xFA, 0xD2, 0xFF);
+	}
+
+	/** Definition of the color, lightgreen from the Netscape color table. */
+	public static FSColor lightgreen()
+	{
+		return new FSColor(0x90, 0xEE, 0x90, 0xFF);
+	}
+
+	/** Definition of the color, lightgrey from the Netscape color table. */
+	public static FSColor lightgrey()
+	{
+		return new FSColor(0xD3, 0xD3, 0xD3, 0xFF);
+	}
+
+	/** Definition of the color, lightpink from the Netscape color table. */
+	public static FSColor lightpink()
+	{
+		return new FSColor(0xFF, 0xB6, 0xC1, 0xFF);
+	}
+
+	/** Definition of the color, lightsalmon from the Netscape color table. */
+	public static FSColor lightsalmon()
+	{
+		return new FSColor(0xFF, 0xA0, 0x7A, 0xFF);
+	}
+
+	/** Definition of the color, lightseagreen from the Netscape color table. */
+	public static FSColor lightseagreen()
+	{
+		return new FSColor(0x20, 0xB2, 0xAA, 0xFF);
+	}
+
+	/** Definition of the color, lightskyblue from the Netscape color table. */
+	public static FSColor lightskyblue()
+	{
+		return new FSColor(0x87, 0xCE, 0xFA, 0xFF);
+	}
+
+	/** Definition of the color, lightslategray from the Netscape color table. */
+	public static FSColor lightslategray()
+	{
+		return new FSColor(0x77, 0x88, 0x99, 0xFF);
+	}
+
+	/** Definition of the color, lightsteelblue from the Netscape color table. */
+	public static FSColor lightsteelblue()
+	{
+		return new FSColor(0xB0, 0xC4, 0xDE, 0xFF);
+	}
+
+	/** Definition of the color, lightyellow from the Netscape color table. */
+	public static FSColor lightyellow()
+	{
+		return new FSColor(0xFF, 0xFF, 0xE0, 0xFF);
+	}
+
+	/** Definition of the color, lime from the Netscape color table. */
+	public static FSColor lime()
+	{
+		return new FSColor(0x00, 0xFF, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, limegreen from the Netscape color table. */
+	public static FSColor limegreen()
+	{
+		return new FSColor(0x32, 0xCD, 0x32, 0xFF);
+	}
+
+	/** Definition of the color, linen from the Netscape color table. */
+	public static FSColor linen()
+	{
+		return new FSColor(0xFA, 0xF0, 0xE6, 0xFF);
+	}
+
+	/** Definition of the color, magenta from the Netscape color table. */
+	public static FSColor magenta()
+	{
+		return new FSColor(0xFF, 0x00, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, maroon from the Netscape color table. */
+	public static FSColor maroon()
+	{
+		return new FSColor(0x80, 0x00, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, mediumaquamarine from the Netscape color table. */
+	public static FSColor mediumaquamarine()
+	{
+		return new FSColor(0x66, 0xCD, 0xAA, 0xFF);
+	}
+
+	/** Definition of the color, mediumblue from the Netscape color table. */
+	public static FSColor mediumblue()
+	{
+		return new FSColor(0x00, 0x00, 0xCD, 0xFF);
+	}
+
+	/** Definition of the color, mediumorchid from the Netscape color table. */
+	public static FSColor mediumorchid()
+	{
+		return new FSColor(0xBA, 0x55, 0xD3, 0xFF);
+	}
+
+	/** Definition of the color, mediumpurple from the Netscape color table. */
+	public static FSColor mediumpurple()
+	{
+		return new FSColor(0x93, 0x70, 0xDB, 0xFF);
+	}
+
+	/** Definition of the color, mediumseagreen from the Netscape color table. */
+	public static FSColor mediumseagreen()
+	{
+		return new FSColor(0x3C, 0xB3, 0x71, 0xFF);
+	}
+
+	/** Definition of the color, mediumslateblue from the Netscape color table. */
+	public static FSColor mediumslateblue()
+	{
+		return new FSColor(0x7B, 0x68, 0xEE, 0xFF);
+	}
+
+	/** Definition of the color, mediumspringgreen from the Netscape color table. */
+	public static FSColor mediumspringgreen()
+	{
+		return new FSColor(0x00, 0xFA, 0x9A, 0xFF);
+	}
+
+	/** Definition of the color, mediumturquoise from the Netscape color table. */
+	public static FSColor mediumturquoise()
+	{
+		return new FSColor(0x48, 0xD1, 0xCC, 0xFF);
+	}
+
+	/** Definition of the color, mediumvioletred from the Netscape color table. */
+	public static FSColor mediumvioletred()
+	{
+		return new FSColor(0xC7, 0x15, 0x85, 0xFF);
+	}
+
+	/** Definition of the color, midnightblue from the Netscape color table. */
+	public static FSColor midnightblue()
+	{
+		return new FSColor(0x19, 0x19, 0x70, 0xFF);
+	}
+
+	/** Definition of the color, mintcream from the Netscape color table. */
+	public static FSColor mintcream()
+	{
+		return new FSColor(0xF5, 0xFF, 0xFA, 0xFF);
+	}
+
+	/** Definition of the color, mistyrose from the Netscape color table. */
+	public static FSColor mistyrose()
+	{
+		return new FSColor(0xFF, 0xE4, 0xE1, 0xFF);
+	}
+
+	/** Definition of the color, moccasin from the Netscape color table. */
+	public static FSColor moccasin()
+	{
+		return new FSColor(0xFF, 0xE4, 0xB5, 0xFF);
+	}
+
+	/** Definition of the color, navajowhite from the Netscape color table. */
+	public static FSColor navajowhite()
+	{
+		return new FSColor(0xFF, 0xDE, 0xAD, 0xFF);
+	}
+
+	/** Definition of the color, navy from the Netscape color table. */
+	public static FSColor navy()
+	{
+		return new FSColor(0x00, 0x00, 0x80, 0xFF);
+	}
+
+	/** Definition of the color, oldlace from the Netscape color table. */
+	public static FSColor oldlace()
+	{
+		return new FSColor(0xFD, 0xF5, 0xE6, 0xFF);
+	}
+
+	/** Definition of the color, olive from the Netscape color table. */
+	public static FSColor olive()
+	{
+		return new FSColor(0x80, 0x80, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, olivedrab from the Netscape color table. */
+	public static FSColor olivedrab()
+	{
+		return new FSColor(0x6B, 0x8E, 0x23, 0xFF);
+	}
+
+	/** Definition of the color, orange from the Netscape color table. */
+	public static FSColor orange()
+	{
+		return new FSColor(0xFF, 0xA5, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, orangered from the Netscape color table. */
+	public static FSColor orangered()
+	{
+		return new FSColor(0xFF, 0x45, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, orchid from the Netscape color table. */
+	public static FSColor orchid()
+	{
+		return new FSColor(0xDA, 0x70, 0xD6, 0xFF);
+	}
+
+	/** Definition of the color, palegoldenrod from the Netscape color table. */
+	public static FSColor palegoldenrod()
+	{
+		return new FSColor(0xEE, 0xE8, 0xAA, 0xFF);
+	}
+
+	/** Definition of the color, palegreen from the Netscape color table. */
+	public static FSColor palegreen()
+	{
+		return new FSColor(0x98, 0xFB, 0x98, 0xFF);
+	}
+
+	/** Definition of the color, paleturquoise from the Netscape color table. */
+	public static FSColor paleturquoise()
+	{
+		return new FSColor(0xAF, 0xEE, 0xEE, 0xFF);
+	}
+
+	/** Definition of the color, palevioletred from the Netscape color table. */
+	public static FSColor palevioletred()
+	{
+		return new FSColor(0xDB, 0x70, 0x93, 0xFF);
+	}
+
+	/** Definition of the color, papayawhip from the Netscape color table. */
+	public static FSColor papayawhip()
+	{
+		return new FSColor(0xFF, 0xEF, 0xD5, 0xFF);
+	}
+
+	/** Definition of the color, peachpuff from the Netscape color table. */
+	public static FSColor peachpuff()
+	{
+		return new FSColor(0xFF, 0xDA, 0xB9, 0xFF);
+	}
+
+	/** Definition of the color, peru from the Netscape color table. */
+	public static FSColor peru()
+	{
+		return new FSColor(0xCD, 0x85, 0x3F, 0xFF);
+	}
+
+	/** Definition of the color, pink from the Netscape color table. */
+	public static FSColor pink()
+	{
+		return new FSColor(0xFF, 0xC0, 0xCB, 0xFF);
+	}
+
+	/** Definition of the color, plum from the Netscape color table. */
+	public static FSColor plum()
+	{
+		return new FSColor(0xDD, 0xA0, 0xDD, 0xFF);
+	}
+
+	/** Definition of the color, powderblue from the Netscape color table. */
+	public static FSColor powderblue()
+	{
+		return new FSColor(0xB0, 0xE0, 0xE6, 0xFF);
+	}
+
+	/** Definition of the color, purple from the Netscape color table. */
+	public static FSColor purple()
+	{
+		return new FSColor(0x80, 0x00, 0x80, 0xFF);
+	}
+
+	/** Definition of the color, red from the Netscape color table. */
+	public static FSColor red()
+	{
+		return new FSColor(0xFF, 0x00, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, rosybrown from the Netscape color table. */
+	public static FSColor rosybrown()
+	{
+		return new FSColor(0xBC, 0x8F, 0x8F, 0xFF);
+	}
+
+	/** Definition of the color, royalblue from the Netscape color table. */
+	public static FSColor royalblue()
+	{
+		return new FSColor(0x41, 0x69, 0xE1, 0xFF);
+	}
+
+	/** Definition of the color, saddlebrown from the Netscape color table. */
+	public static FSColor saddlebrown()
+	{
+		return new FSColor(0x8B, 0x45, 0x13, 0xFF);
+	}
+
+	/** Definition of the color, salmon from the Netscape color table. */
+	public static FSColor salmon()
+	{
+		return new FSColor(0xFA, 0x80, 0x72, 0xFF);
+	}
+
+	/** Definition of the color, sandybrown from the Netscape color table. */
+	public static FSColor sandybrown()
+	{
+		return new FSColor(0xF4, 0xA4, 0x60, 0xFF);
+	}
+
+	/** Definition of the color, seagreen from the Netscape color table. */
+	public static FSColor seagreen()
+	{
+		return new FSColor(0x2E, 0x8B, 0x57, 0xFF);
+	}
+
+	/** Definition of the color, seashell from the Netscape color table. */
+	public static FSColor seashell()
+	{
+		return new FSColor(0xFF, 0xF5, 0xEE, 0xFF);
+	}
+
+	/** Definition of the color, sienna from the Netscape color table. */
+	public static FSColor sienna()
+	{
+		return new FSColor(0xA0, 0x52, 0x2d, 0xFF);
+	}
+
+	/** Definition of the color, silver from the Netscape color table. */
+	public static FSColor silver()
+	{
+		return new FSColor(0xC0, 0xC0, 0xC0, 0xFF);
+	}
+
+	/** Definition of the color, skyblue from the Netscape color table. */
+	public static FSColor skyblue()
+	{
+		return new FSColor(0x87, 0xCE, 0xEB, 0xFF);
+	}
+
+	/** Definition of the color, slateblue from the Netscape color table. */
+	public static FSColor slateblue()
+	{
+		return new FSColor(0x6A, 0x5A, 0xCD, 0xFF);
+	}
+
+	/** Definition of the color, slategray from the Netscape color table. */
+	public static FSColor slategray()
+	{
+		return new FSColor(0x70, 0x80, 0x90, 0xFF);
+	}
+
+	/** Definition of the color, snow from the Netscape color table. */
+	public static FSColor snow()
+	{
+		return new FSColor(0xFF, 0xFA, 0xFA, 0xFF);
+	}
+
+	/** Definition of the color, springgreen from the Netscape color table. */
+	public static FSColor springgreen()
+	{
+		return new FSColor(0x00, 0xFF, 0x7F, 0xFF);
+	}
+
+	/** Definition of the color, steelblue from the Netscape color table. */
+	public static FSColor steelblue()
+	{
+		return new FSColor(0x46, 0x82, 0xB4, 0xFF);
+	}
+
+	/** Definition of the color, tan from the Netscape color table. */
+	public static FSColor tan()
+	{
+		return new FSColor(0xD2, 0xB4, 0x8C, 0xFF);
+	}
+
+	/** Definition of the color, teal from the Netscape color table. */
+	public static FSColor teal()
+	{
+		return new FSColor(0x00, 0x80, 0x80, 0xFF);
+	}
+
+	/** Definition of the color, thistle from the Netscape color table. */
+	public static FSColor thistle()
+	{
+		return new FSColor(0xD8, 0xBF, 0xD8, 0xFF);
+	}
+
+	/** Definition of the color, tomato from the Netscape color table. */
+	public static FSColor tomato()
+	{
+		return new FSColor(0xFF, 0x63, 0x47, 0xFF);
+	}
+
+	/** Definition of the color, turquoise from the Netscape color table. */
+	public static FSColor turquoise()
+	{
+		return new FSColor(0x40, 0xE0, 0xD0, 0xFF);
+	}
+
+	/** Definition of the color, violet from the Netscape color table. */
+	public static FSColor violet()
+	{
+		return new FSColor(0xEE, 0x82, 0xEE, 0xFF);
+	}
+
+	/** Definition of the color, wheat from the Netscape color table. */
+	public static FSColor wheat()
+	{
+		return new FSColor(0xF5, 0xDE, 0xB3, 0xFF);
+	}
+
+	/** Definition of the color, white from the Netscape color table. */
+	public static FSColor white()
+	{
+		return new FSColor(0xFF, 0xFF, 0xFF, 0xFF);
+	}
+
+	/** Definition of the color, whitesmoke from the Netscape color table. */
+	public static FSColor whitesmoke()
+	{
+		return new FSColor(0xF5, 0xF5, 0xF5, 0xFF);
+	}
+
+	/** Definition of the color, yellow from the Netscape color table. */
+	public static FSColor yellow()
+	{
+		return new FSColor(0xFF, 0xFF, 0x00, 0xFF);
+	}
+
+	/** Definition of the color, yellowgreen from the Netscape color table. */
+	public static FSColor yellowgreen()
+	{
+		return new FSColor(0x9A, 0xCD, 0x32, 0xFF);
+	}
+
+	/**
+	 * Definition of the transparent color, aliceblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor aliceblue(int alpha)
+	{
+		return new FSColor(0xF0, 0xF8, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, antiquewhite from the Netscape color
+	 * table.
+	 */
+	public static FSColor antiquewhite(int alpha)
+	{
+		return new FSColor(0xFA, 0xEB, 0xD7, alpha);
+	}
+
+	/** Definition of the transparent color, aqua from the Netscape color table. */
+	public static FSColor aqua(int alpha)
+	{
+		return new FSColor(0x00, 0xFF, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, aquamarine from the Netscape color
+	 * table.
+	 */
+	public static FSColor aquamarine(int alpha)
+	{
+		return new FSColor(0x7F, 0xFF, 0xD4, alpha);
+	}
+
+	/** Definition of the transparent color, azure from the Netscape color table. */
+	public static FSColor azure(int alpha)
+	{
+		return new FSColor(0xF0, 0xFF, 0xFF, alpha);
+	}
+
+	/** Definition of the transparent color, beige from the Netscape color table. */
+	public static FSColor beige(int alpha)
+	{
+		return new FSColor(0xF5, 0xF5, 0xDC, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, bisque from the Netscape color
+	 * table.
+	 */
+	public static FSColor bisque(int alpha)
+	{
+		return new FSColor(0xFF, 0xE4, 0xC4, alpha);
+	}
+
+	/** Definition of the transparent color, black from the Netscape color table. */
+	public static FSColor black(int alpha)
+	{
+		return new FSColor(0x00, 0x00, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, blanchedalmond from the Netscape
+	 * color table.
+	 */
+	public static FSColor blanchedalmond(int alpha)
+	{
+		return new FSColor(0xFF, 0xEB, 0xCD, alpha);
+	}
+
+	/** Definition of the transparent color, blue from the Netscape color table. */
+	public static FSColor blue(int alpha)
+	{
+		return new FSColor(0x00, 0x00, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, blueviolet from the Netscape color
+	 * table.
+	 */
+	public static FSColor blueviolet(int alpha)
+	{
+		return new FSColor(0x8A, 0x2B, 0xE2, alpha);
+	}
+
+	/** Definition of the transparent color, brown from the Netscape color table. */
+	public static FSColor brown(int alpha)
+	{
+		return new FSColor(0xA5, 0x2A, 0x2A, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, burlywood from the Netscape color
+	 * table.
+	 */
+	public static FSColor burlywood(int alpha)
+	{
+		return new FSColor(0xDE, 0xB8, 0x87, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, cadetblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor cadetblue(int alpha)
+	{
+		return new FSColor(0x5F, 0x9E, 0xA0, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, chartreuse from the Netscape color
+	 * table.
+	 */
+	public static FSColor chartreuse(int alpha)
+	{
+		return new FSColor(0x7F, 0xFF, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, chocolate from the Netscape color
+	 * table.
+	 */
+	public static FSColor chocolate(int alpha)
+	{
+		return new FSColor(0xD2, 0x69, 0x1E, alpha);
+	}
+
+	/** Definition of the transparent color, coral from the Netscape color table. */
+	public static FSColor coral(int alpha)
+	{
+		return new FSColor(0xFF, 0x7F, 0x50, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, cornflowerblue from the Netscape
+	 * color table.
+	 */
+	public static FSColor cornflowerblue(int alpha)
+	{
+		return new FSColor(0x64, 0x95, 0xED, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, cornsilk from the Netscape color
+	 * table.
+	 */
+	public static FSColor cornsilk(int alpha)
+	{
+		return new FSColor(0xFF, 0xF8, 0xDC, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, crimson from the Netscape color
+	 * table.
+	 */
+	public static FSColor crimson(int alpha)
+	{
+		return new FSColor(0xDC, 0x14, 0x3C, alpha);
+	}
+
+	/** Definition of the transparent color, cyan from the Netscape color table. */
+	public static FSColor cyan(int alpha)
+	{
+		return new FSColor(0x00, 0xFF, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkblue(int alpha)
+	{
+		return new FSColor(0x00, 0x00, 0x8B, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkcyan from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkcyan(int alpha)
+	{
+		return new FSColor(0x00, 0x8B, 0x8B, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkgoldenrod from the Netscape
+	 * color table.
+	 */
+	public static FSColor darkgoldenrod(int alpha)
+	{
+		return new FSColor(0xB8, 0x86, 0x0B, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkgray from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkgray(int alpha)
+	{
+		return new FSColor(0xA9, 0xA9, 0xA9, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkgreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkgreen(int alpha)
+	{
+		return new FSColor(0x00, 0x64, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkkhaki from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkkhaki(int alpha)
+	{
+		return new FSColor(0xBD, 0xB7, 0x6B, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkmagenta from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkmagenta(int alpha)
+	{
+		return new FSColor(0x8B, 0x00, 0x8B, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkolivegreen from the Netscape
+	 * color table.
+	 */
+	public static FSColor darkolivegreen(int alpha)
+	{
+		return new FSColor(0x55, 0x6B, 0x2F, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkorange from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkorange(int alpha)
+	{
+		return new FSColor(0xFF, 0x8C, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkorchid from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkorchid(int alpha)
+	{
+		return new FSColor(0x99, 0x32, 0xCC, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkred from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkred(int alpha)
+	{
+		return new FSColor(0x8B, 0x00, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darksalmon from the Netscape color
+	 * table.
+	 */
+	public static FSColor darksalmon(int alpha)
+	{
+		return new FSColor(0xE9, 0x96, 0x7A, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkseagreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkseagreen(int alpha)
+	{
+		return new FSColor(0x8F, 0xBC, 0x8F, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkslateblue from the Netscape
+	 * color table.
+	 */
+	public static FSColor darkslateblue(int alpha)
+	{
+		return new FSColor(0x48, 0x3D, 0x8B, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkslategray from the Netscape
+	 * color table.
+	 */
+	public static FSColor darkslategray(int alpha)
+	{
+		return new FSColor(0x2F, 0x4F, 0x4F, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkturquoise from the Netscape
+	 * color table.
+	 */
+	public static FSColor darkturquoise(int alpha)
+	{
+		return new FSColor(0x00, 0xCE, 0xD1, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, darkviolet from the Netscape color
+	 * table.
+	 */
+	public static FSColor darkviolet(int alpha)
+	{
+		return new FSColor(0x94, 0x00, 0xD3, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, deeppink from the Netscape color
+	 * table.
+	 */
+	public static FSColor deeppink(int alpha)
+	{
+		return new FSColor(0xFF, 0x14, 0x93, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, deepskyblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor deepskyblue(int alpha)
+	{
+		return new FSColor(0x00, 0xBF, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, dimgray from the Netscape color
+	 * table.
+	 */
+	public static FSColor dimgray(int alpha)
+	{
+		return new FSColor(0x69, 0x69, 0x69, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, dodgerblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor dodgerblue(int alpha)
+	{
+		return new FSColor(0x1E, 0x90, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, firebrick from the Netscape color
+	 * table.
+	 */
+	public static FSColor firebrick(int alpha)
+	{
+		return new FSColor(0xB2, 0x22, 0x22, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, floralwhite from the Netscape color
+	 * table.
+	 */
+	public static FSColor floralwhite(int alpha)
+	{
+		return new FSColor(0xFF, 0xFA, 0xF0, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, forestgreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor forestgreen(int alpha)
+	{
+		return new FSColor(0x22, 0x8B, 0x22, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, fuchsia from the Netscape color
+	 * table.
+	 */
+	public static FSColor fuchsia(int alpha)
+	{
+		return new FSColor(0xFF, 0x00, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, gainsboro from the Netscape color
+	 * table.
+	 */
+	public static FSColor gainsboro(int alpha)
+	{
+		return new FSColor(0xDC, 0xDC, 0xDC, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, ghostwhite from the Netscape color
+	 * table.
+	 */
+	public static FSColor ghostwhite(int alpha)
+	{
+		return new FSColor(0xF8, 0xF8, 0xFB, alpha);
+	}
+
+	/** Definition of the transparent color, gold from the Netscape color table. */
+	public static FSColor gold(int alpha)
+	{
+		return new FSColor(0xFF, 0xD7, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, goldenrod from the Netscape color
+	 * table.
+	 */
+	public static FSColor goldenrod(int alpha)
+	{
+		return new FSColor(0xDA, 0xA5, 0x20, alpha);
+	}
+
+	/** Definition of the transparent color, gray from the Netscape color table. */
+	public static FSColor gray(int alpha)
+	{
+		return new FSColor(0x80, 0x80, 0x80, alpha);
+	}
+
+	/** Definition of the transparent color, green from the Netscape color table. */
+	public static FSColor green(int alpha)
+	{
+		return new FSColor(0x00, 0x80, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, greenyellow from the Netscape color
+	 * table.
+	 */
+	public static FSColor greenyellow(int alpha)
+	{
+		return new FSColor(0xAD, 0xFF, 0x2F, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, honeydew from the Netscape color
+	 * table.
+	 */
+	public static FSColor honeydew(int alpha)
+	{
+		return new FSColor(0xF0, 0xFF, 0xF0, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, hotpink from the Netscape color
+	 * table.
+	 */
+	public static FSColor hotpink(int alpha)
+	{
+		return new FSColor(0xFF, 0x69, 0xB4, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, indianred from the Netscape color
+	 * table.
+	 */
+	public static FSColor indianred(int alpha)
+	{
+		return new FSColor(0xCD, 0x5C, 0x5C, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, indigo from the Netscape color
+	 * table.
+	 */
+	public static FSColor indigo(int alpha)
+	{
+		return new FSColor(0x4B, 0x00, 0x82, alpha);
+	}
+
+	/** Definition of the transparent color, ivory from the Netscape color table. */
+	public static FSColor ivory(int alpha)
+	{
+		return new FSColor(0xFF, 0xFF, 0xF0, alpha);
+	}
+
+	/** Definition of the transparent color, khaki from the Netscape color table. */
+	public static FSColor khaki(int alpha)
+	{
+		return new FSColor(0xF0, 0xE6, 0x8C, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lavender from the Netscape color
+	 * table.
+	 */
+	public static FSColor lavender(int alpha)
+	{
+		return new FSColor(0xE6, 0xE6, 0xFA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lavenderblush from the Netscape
+	 * color table.
+	 */
+	public static FSColor lavenderblush(int alpha)
+	{
+		return new FSColor(0xFF, 0xF0, 0xF5, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lawngreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor lawngreen(int alpha)
+	{
+		return new FSColor(0x7C, 0xFC, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lemonchiffon from the Netscape color
+	 * table.
+	 */
+	public static FSColor lemonchiffon(int alpha)
+	{
+		return new FSColor(0xFF, 0xFA, 0xCD, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightblue(int alpha)
+	{
+		return new FSColor(0xAD, 0xD8, 0xE6, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightcoral from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightcoral(int alpha)
+	{
+		return new FSColor(0xF0, 0x80, 0x80, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightcyan from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightcyan(int alpha)
+	{
+		return new FSColor(0xE0, 0xFF, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightgoldenrodyellow from the
+	 * Netscape color table.
+	 */
+	public static FSColor lightgoldenrodyellow(int alpha)
+	{
+		return new FSColor(0xFA, 0xFA, 0xD2, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightgreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightgreen(int alpha)
+	{
+		return new FSColor(0x90, 0xEE, 0x90, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightgrey from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightgrey(int alpha)
+	{
+		return new FSColor(0xD3, 0xD3, 0xD3, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightpink from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightpink(int alpha)
+	{
+		return new FSColor(0xFF, 0xB6, 0xC1, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightsalmon from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightsalmon(int alpha)
+	{
+		return new FSColor(0xFF, 0xA0, 0x7A, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightseagreen from the Netscape
+	 * color table.
+	 */
+	public static FSColor lightseagreen(int alpha)
+	{
+		return new FSColor(0x20, 0xB2, 0xAA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightskyblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightskyblue(int alpha)
+	{
+		return new FSColor(0x87, 0xCE, 0xFA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightslategray from the Netscape
+	 * color table.
+	 */
+	public static FSColor lightslategray(int alpha)
+	{
+		return new FSColor(0x77, 0x88, 0x99, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightsteelblue from the Netscape
+	 * color table.
+	 */
+	public static FSColor lightsteelblue(int alpha)
+	{
+		return new FSColor(0xB0, 0xC4, 0xDE, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, lightyellow from the Netscape color
+	 * table.
+	 */
+	public static FSColor lightyellow(int alpha)
+	{
+		return new FSColor(0xFF, 0xFF, 0xE0, alpha);
+	}
+
+	/** Definition of the transparent color, lime from the Netscape color table. */
+	public static FSColor lime(int alpha)
+	{
+		return new FSColor(0x00, 0xFF, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, limegreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor limegreen(int alpha)
+	{
+		return new FSColor(0x32, 0xCD, 0x32, alpha);
+	}
+
+	/** Definition of the transparent color, linen from the Netscape color table. */
+	public static FSColor linen(int alpha)
+	{
+		return new FSColor(0xFA, 0xF0, 0xE6, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, magenta from the Netscape color
+	 * table.
+	 */
+	public static FSColor magenta(int alpha)
+	{
+		return new FSColor(0xFF, 0x00, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, maroon from the Netscape color
+	 * table.
+	 */
+	public static FSColor maroon(int alpha)
+	{
+		return new FSColor(0x80, 0x00, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumaquamarine from the Netscape
+	 * color table.
+	 */
+	public static FSColor mediumaquamarine(int alpha)
+	{
+		return new FSColor(0x66, 0xCD, 0xAA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor mediumblue(int alpha)
+	{
+		return new FSColor(0x00, 0x00, 0xCD, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumorchid from the Netscape color
+	 * table.
+	 */
+	public static FSColor mediumorchid(int alpha)
+	{
+		return new FSColor(0xBA, 0x55, 0xD3, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumpurple from the Netscape color
+	 * table.
+	 */
+	public static FSColor mediumpurple(int alpha)
+	{
+		return new FSColor(0x93, 0x70, 0xDB, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumseagreen from the Netscape
+	 * color table.
+	 */
+	public static FSColor mediumseagreen(int alpha)
+	{
+		return new FSColor(0x3C, 0xB3, 0x71, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumslateblue from the Netscape
+	 * color table.
+	 */
+	public static FSColor mediumslateblue(int alpha)
+	{
+		return new FSColor(0x7B, 0x68, 0xEE, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumspringgreen from the Netscape
+	 * color table.
+	 */
+	public static FSColor mediumspringgreen(int alpha)
+	{
+		return new FSColor(0x00, 0xFA, 0x9A, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumturquoise from the Netscape
+	 * color table.
+	 */
+	public static FSColor mediumturquoise(int alpha)
+	{
+		return new FSColor(0x48, 0xD1, 0xCC, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mediumvioletred from the Netscape
+	 * color table.
+	 */
+	public static FSColor mediumvioletred(int alpha)
+	{
+		return new FSColor(0xC7, 0x15, 0x85, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, midnightblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor midnightblue(int alpha)
+	{
+		return new FSColor(0x19, 0x19, 0x70, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mintcream from the Netscape color
+	 * table.
+	 */
+	public static FSColor mintcream(int alpha)
+	{
+		return new FSColor(0xF5, 0xFF, 0xFA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, mistyrose from the Netscape color
+	 * table.
+	 */
+	public static FSColor mistyrose(int alpha)
+	{
+		return new FSColor(0xFF, 0xE4, 0xE1, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, moccasin from the Netscape color
+	 * table.
+	 */
+	public static FSColor moccasin(int alpha)
+	{
+		return new FSColor(0xFF, 0xE4, 0xB5, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, navajowhite from the Netscape color
+	 * table.
+	 */
+	public static FSColor navajowhite(int alpha)
+	{
+		return new FSColor(0xFF, 0xDE, 0xAD, alpha);
+	}
+
+	/** Definition of the transparent color, navy from the Netscape color table. */
+	public static FSColor navy(int alpha)
+	{
+		return new FSColor(0x00, 0x00, 0x80, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, oldlace from the Netscape color
+	 * table.
+	 */
+	public static FSColor oldlace(int alpha)
+	{
+		return new FSColor(0xFD, 0xF5, 0xE6, alpha);
+	}
+
+	/** Definition of the transparent color, olive from the Netscape color table. */
+	public static FSColor olive(int alpha)
+	{
+		return new FSColor(0x80, 0x80, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, olivedrab from the Netscape color
+	 * table.
+	 */
+	public static FSColor olivedrab(int alpha)
+	{
+		return new FSColor(0x6B, 0x8E, 0x23, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, orange from the Netscape color
+	 * table.
+	 */
+	public static FSColor orange(int alpha)
+	{
+		return new FSColor(0xFF, 0xA5, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, orangered from the Netscape color
+	 * table.
+	 */
+	public static FSColor orangered(int alpha)
+	{
+		return new FSColor(0xFF, 0x45, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, orchid from the Netscape color
+	 * table.
+	 */
+	public static FSColor orchid(int alpha)
+	{
+		return new FSColor(0xDA, 0x70, 0xD6, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, palegoldenrod from the Netscape
+	 * color table.
+	 */
+	public static FSColor palegoldenrod(int alpha)
+	{
+		return new FSColor(0xEE, 0xE8, 0xAA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, palegreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor palegreen(int alpha)
+	{
+		return new FSColor(0x98, 0xFB, 0x98, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, paleturquoise from the Netscape
+	 * color table.
+	 */
+	public static FSColor paleturquoise(int alpha)
+	{
+		return new FSColor(0xAF, 0xEE, 0xEE, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, palevioletred from the Netscape
+	 * color table.
+	 */
+	public static FSColor palevioletred(int alpha)
+	{
+		return new FSColor(0xDB, 0x70, 0x93, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, papayawhip from the Netscape color
+	 * table.
+	 */
+	public static FSColor papayawhip(int alpha)
+	{
+		return new FSColor(0xFF, 0xEF, 0xD5, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, peachpuff from the Netscape color
+	 * table.
+	 */
+	public static FSColor peachpuff(int alpha)
+	{
+		return new FSColor(0xFF, 0xDA, 0xB9, alpha);
+	}
+
+	/** Definition of the transparent color, peru from the Netscape color table. */
+	public static FSColor peru(int alpha)
+	{
+		return new FSColor(0xCD, 0x85, 0x3F, alpha);
+	}
+
+	/** Definition of the transparent color, pink from the Netscape color table. */
+	public static FSColor pink(int alpha)
+	{
+		return new FSColor(0xFF, 0xC0, 0xCB, alpha);
+	}
+
+	/** Definition of the transparent color, plum from the Netscape color table. */
+	public static FSColor plum(int alpha)
+	{
+		return new FSColor(0xDD, 0xA0, 0xDD, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, powderblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor powderblue(int alpha)
+	{
+		return new FSColor(0xB0, 0xE0, 0xE6, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, purple from the Netscape color
+	 * table.
+	 */
+	public static FSColor purple(int alpha)
+	{
+		return new FSColor(0x80, 0x00, 0x80, alpha);
+	}
+
+	/** Definition of the transparent color, red from the Netscape color table. */
+	public static FSColor red(int alpha)
+	{
+		return new FSColor(0xFF, 0x00, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, rosybrown from the Netscape color
+	 * table.
+	 */
+	public static FSColor rosybrown(int alpha)
+	{
+		return new FSColor(0xBC, 0x8F, 0x8F, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, royalblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor royalblue(int alpha)
+	{
+		return new FSColor(0x41, 0x69, 0xE1, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, saddlebrown from the Netscape color
+	 * table.
+	 */
+	public static FSColor saddlebrown(int alpha)
+	{
+		return new FSColor(0x8B, 0x45, 0x13, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, salmon from the Netscape color
+	 * table.
+	 */
+	public static FSColor salmon(int alpha)
+	{
+		return new FSColor(0xFA, 0x80, 0x72, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, sandybrown from the Netscape color
+	 * table.
+	 */
+	public static FSColor sandybrown(int alpha)
+	{
+		return new FSColor(0xF4, 0xA4, 0x60, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, seagreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor seagreen(int alpha)
+	{
+		return new FSColor(0x2E, 0x8B, 0x57, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, seashell from the Netscape color
+	 * table.
+	 */
+	public static FSColor seashell(int alpha)
+	{
+		return new FSColor(0xFF, 0xF5, 0xEE, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, sienna from the Netscape color
+	 * table.
+	 */
+	public static FSColor sienna(int alpha)
+	{
+		return new FSColor(0xA0, 0x52, 0x2d, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, silver from the Netscape color
+	 * table.
+	 */
+	public static FSColor silver(int alpha)
+	{
+		return new FSColor(0xC0, 0xC0, 0xC0, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, skyblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor skyblue(int alpha)
+	{
+		return new FSColor(0x87, 0xCE, 0xEB, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, slateblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor slateblue(int alpha)
+	{
+		return new FSColor(0x6A, 0x5A, 0xCD, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, slategray from the Netscape color
+	 * table.
+	 */
+	public static FSColor slategray(int alpha)
+	{
+		return new FSColor(0x70, 0x80, 0x90, alpha);
+	}
+
+	/** Definition of the transparent color, snow from the Netscape color table. */
+	public static FSColor snow(int alpha)
+	{
+		return new FSColor(0xFF, 0xFA, 0xFA, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, springgreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor springgreen(int alpha)
+	{
+		return new FSColor(0x00, 0xFF, 0x7F, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, steelblue from the Netscape color
+	 * table.
+	 */
+	public static FSColor steelblue(int alpha)
+	{
+		return new FSColor(0x46, 0x82, 0xB4, alpha);
+	}
+
+	/** Definition of the transparent color, tan from the Netscape color table. */
+	public static FSColor tan(int alpha)
+	{
+		return new FSColor(0xD2, 0xB4, 0x8C, alpha);
+	}
+
+	/** Definition of the transparent color, teal from the Netscape color table. */
+	public static FSColor teal(int alpha)
+	{
+		return new FSColor(0x00, 0x80, 0x80, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, thistle from the Netscape color
+	 * table.
+	 */
+	public static FSColor thistle(int alpha)
+	{
+		return new FSColor(0xD8, 0xBF, 0xD8, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, tomato from the Netscape color
+	 * table.
+	 */
+	public static FSColor tomato(int alpha)
+	{
+		return new FSColor(0xFF, 0x63, 0x47, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, turquoise from the Netscape color
+	 * table.
+	 */
+	public static FSColor turquoise(int alpha)
+	{
+		return new FSColor(0x40, 0xE0, 0xD0, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, violet from the Netscape color
+	 * table.
+	 */
+	public static FSColor violet(int alpha)
+	{
+		return new FSColor(0xEE, 0x82, 0xEE, alpha);
+	}
+
+	/** Definition of the transparent color, wheat from the Netscape color table. */
+	public static FSColor wheat(int alpha)
+	{
+		return new FSColor(0xF5, 0xDE, 0xB3, alpha);
+	}
+
+	/** Definition of the transparent color, white from the Netscape color table. */
+	public static FSColor white(int alpha)
+	{
+		return new FSColor(0xFF, 0xFF, 0xFF, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, whitesmoke from the Netscape color
+	 * table.
+	 */
+	public static FSColor whitesmoke(int alpha)
+	{
+		return new FSColor(0xF5, 0xF5, 0xF5, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, yellow from the Netscape color
+	 * table.
+	 */
+	public static FSColor yellow(int alpha)
+	{
+		return new FSColor(0xFF, 0xFF, 0x00, alpha);
+	}
+
+	/**
+	 * Definition of the transparent color, yellowgreen from the Netscape color
+	 * table.
+	 */
+	public static FSColor yellowgreen(int alpha)
+	{
+		return new FSColor(0x9A, 0xCD, 0x32, alpha);
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSColorTransform.java
===================================================================
--- trunk/src/com/flagstone/transform/FSColorTransform.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSColorTransform.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,727 +31,952 @@
 package com.flagstone.transform;
 
 /**
-The FSColorTransform is used to change the colour of a shape or button without changing 
-the values in the original definition of the object.
- 
-&lt;p&gt;Two types of transformation are supported: &lt;b&gt;Add&lt;/b&gt; and &lt;b&gt;Multiply&lt;/b&gt;&lt;/p&gt;
-
-&lt;p&gt;In Add transformations a value is added to each colour channel:&lt;/p&gt;
-
-&lt;pre&gt;
-newRed = red + addRedTerm
-newGreen = green + addGreenTerm
-newBlue = blue + addBlueTerm
-newAlpha = alpha + addAlphaTerm
-&lt;/pre&gt;
-
-&lt;p&gt;In Multiply transformations each colour channel is multiplied by a given value:&lt;/p&gt;
-
-&lt;pre&gt;
-newRed = red * multiplyRedTerm
-newGreen = green * multiplyGreenTerm
-newBlue = blue * multiplyBlueTerm
-newAlpha = alpha * multiplyAlphaTerm
-&lt;/pre&gt;
-
-&lt;p&gt;Add and Multiply transforms may be combined in which case the multiply terms are
-applied to the colour channel before the add terms.&lt;/p&gt;
-
-&lt;pre&gt;
-newRed = (red * multiplyRedTerm) + addRedTerm
-newGreen = (green * multiplyGreenTerm) + addGreenTerm
-newBlue = (blue * multiplyBlueTerm) + addBlueTerm
-newAlpha = (alpha * multiplyAlphaTerm) + addAlphaTerm
-&lt;/pre&gt;
-
-&lt;p&gt;For each type of transform the result of the calculation is limited to the range 0..255. If the result is less than 0 or greater than 255 then it is clamped at 0 and 255 respectively.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_0&quot;&gt;multiplyRed&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The multiply term for the red colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_1&quot;&gt;multiplyGreen&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The multiply term for the green colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_2&quot;&gt;multiplyBlue&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The multiply term for the blue colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_3&quot;&gt;multiplyAlpha&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The optional multiply term for the alpha colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_4&quot;&gt;addRed&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The add term for the red colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_5&quot;&gt;addGreen&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The add term for the green colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_6&quot;&gt;addBlue&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The add term for the blue colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSColorTransform_7&quot;&gt;addAlpha&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The optional add term for the alpha colour channel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;Not all objects containing a colour transform use the add or multiply terms defined for the alpha channel. The colour objects defined in an FSDefineButton, FSButtonColorTransform or FSPlaceObject object do not use the alpha channel. Transparent colours was introduced in Flash 3. The &quot;parent&quot; object that contains the colour transform controls whether the alpha channel information is encoded or not. Simplifying the alpha channel is not sufficient.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-
-&lt;p&gt;The class provides a range of constructors to support the different colour transformations. To create a colour transform object specify the values for colour channels in the following order: red, green, blue and optionally alpha:&lt;/p&gt;
-
-&lt;pre&gt;
-float multRed = 1.5f;
-float multGreen = 1.5f;
-float multBlue = 1.5f;
-float multAlpha = 1.5f;
-
-FSColorTransform multiply = new FSColorTransform(multRed, multGreen, multBlue);
-
-FSColorTransform multiplyWithAlpha = new FSColorTransform(multRed, multGreen, multBlue, multAlpha);
-&lt;/pre&gt;
-
-&lt;pre&gt;
-int addRed = 128;
-int addGreen = 128;
-int addBlue = 128;
-int addAlpha = 128;
-
-FSColorTransform add = new FSColorTransform(addRed, addGreen, addBlue);
-
-FSColorTransform addWithAlpha = new FSColorTransform(addRed, addGreen, addBlue, addAlpha);
-&lt;/pre&gt;
-
-&lt;p&gt;For transforms combining both multiply and add terms:&lt;/p&gt;
-
-&lt;pre&gt;
-int addRed = 128;
-int addGreen = 128;
-int addBlue = 128;
-int addAlpha = 128;
-
-float multRed = 1.5f;
-float multGreen = 1.5f;
-float multBlue = 1.5f;
-float multAlpha = 1.5f;
-
-FSColorTransform combined = new FSColorTransform(multRed, multGreen, multBlue,
-    addRed, addGreen, addBlue);
-
-FSColorTransform combinedWithAlpha = new FSColorTransform(multRed, multGreen, multBlue, multAlpha, 
-    addRed, addGreen, addBlue, addAlpha); 
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSCoordTransform class represents the CXForm and CXFormWithAlpha data structures from the Macromedia Flash (SWF) File Format Specification. They were introduced in Flash 1 and Flash 3 respectively.&lt;/P&gt;
+ * The FSColorTransform is used to change the colour of a shape or button
+ * without changing the values in the original definition of the object.
+ * 
+ * &lt;p&gt;
+ * Two types of transformation are supported: &lt;b&gt;Add&lt;/b&gt; and &lt;b&gt;Multiply&lt;/b&gt;
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * In Add transformations a value is added to each colour channel:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  newRed = red + addRedTerm
+ *  newGreen = green + addGreenTerm
+ *  newBlue = blue + addBlueTerm
+ *  newAlpha = alpha + addAlphaTerm
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * In Multiply transformations each colour channel is multiplied by a given
+ * value:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  newRed = red * multiplyRedTerm
+ *  newGreen = green * multiplyGreenTerm
+ *  newBlue = blue * multiplyBlueTerm
+ *  newAlpha = alpha * multiplyAlphaTerm
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Add and Multiply transforms may be combined in which case the multiply terms
+ * are applied to the colour channel before the add terms.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  newRed = (red * multiplyRedTerm) + addRedTerm
+ *  newGreen = (green * multiplyGreenTerm) + addGreenTerm
+ *  newBlue = (blue * multiplyBlueTerm) + addBlueTerm
+ *  newAlpha = (alpha * multiplyAlphaTerm) + addAlphaTerm
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * For each type of transform the result of the calculation is limited to the
+ * range 0..255. If the result is less than 0 or greater than 255 then it is
+ * clamped at 0 and 255 respectively.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;multiplyRed&lt;/td&gt;
+ * &lt;td&gt;The multiply term for the red colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;multiplyGreen&lt;/td&gt;
+ * &lt;td&gt;The multiply term for the green colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;multiplyBlue&lt;/td&gt;
+ * &lt;td&gt;The multiply term for the blue colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;multiplyAlpha&lt;/td&gt;
+ * &lt;td&gt;The optional multiply term for the alpha colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;addRed&lt;/td&gt;
+ * &lt;td&gt;The add term for the red colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;addGreen&lt;/td&gt;
+ * &lt;td&gt;The add term for the green colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;addBlue&lt;/td&gt;
+ * &lt;td&gt;The add term for the blue colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;addAlpha&lt;/td&gt;
+ * &lt;td&gt;The optional add term for the alpha colour channel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Not all objects containing a colour transform use the add or multiply terms
+ * defined for the alpha channel. The colour objects defined in an
+ * FSDefineButton, FSButtonColorTransform or FSPlaceObject object do not use the
+ * alpha channel. Transparent colours was introduced in Flash 3. The &quot;parent&quot;
+ * object that contains the colour transform controls whether the alpha channel
+ * information is encoded or not. Simplifying the alpha channel is not
+ * sufficient.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The class provides a range of constructors to support the different colour
+ * transformations. To create a colour transform object specify the values for
+ * colour channels in the following order: red, green, blue and optionally
+ * alpha:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * float multRed = 1.5f;
+ * 
+ * float multGreen = 1.5f;
+ * 
+ * float multBlue = 1.5f;
+ * 
+ * float multAlpha = 1.5f;
+ * 
+ * FSColorTransform multiply = new FSColorTransform(multRed, multGreen, multBlue);
+ * 
+ * FSColorTransform multiplyWithAlpha = new FSColorTransform(multRed, multGreen,
+ * 				multBlue, multAlpha);
+ * &lt;/pre&gt;
+ * 
+ * &lt;pre&gt;
+ * int addRed = 128;
+ * 
+ * int addGreen = 128;
+ * 
+ * int addBlue = 128;
+ * 
+ * int addAlpha = 128;
+ * 
+ * FSColorTransform add = new FSColorTransform(addRed, addGreen, addBlue);
+ * 
+ * FSColorTransform addWithAlpha = new FSColorTransform(addRed, addGreen, addBlue,
+ * 				addAlpha);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * For transforms combining both multiply and add terms:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int addRed = 128;
+ * 
+ * int addGreen = 128;
+ * 
+ * int addBlue = 128;
+ * 
+ * int addAlpha = 128;
+ * 
+ * float multRed = 1.5f;
+ * 
+ * float multGreen = 1.5f;
+ * 
+ * float multBlue = 1.5f;
+ * 
+ * float multAlpha = 1.5f;
+ * 
+ * FSColorTransform combined = new FSColorTransform(multRed, multGreen, multBlue,
+ * 				addRed, addGreen, addBlue);
+ * 
+ * FSColorTransform combinedWithAlpha = new FSColorTransform(multRed, multGreen,
+ * 				multBlue, multAlpha, addRed, addGreen, addBlue, addAlpha);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform class represents the CXForm and CXFormWithAlpha data
+ * structures from the Macromedia Flash (SWF) File Format Specification. They
+ * were introduced in Flash 1 and Flash 3 respectively.
+ * &lt;/P&gt;
  */
 public class FSColorTransform extends FSTransformObject
 {
-    private float multiplyRed = 1.0f;
-    private float multiplyGreen = 1.0f;
-    private float multiplyBlue = 1.0f;
-    private float multiplyAlpha = 1.0f;
-    private int addRed = 0;
-    private int addGreen = 0;
-    private int addBlue = 0;
-    private int addAlpha = 0;
+	private float multiplyRed = 1.0f;
+	private float multiplyGreen = 1.0f;
+	private float multiplyBlue = 1.0f;
+	private float multiplyAlpha = 1.0f;
+	private int addRed = 0;
+	private int addGreen = 0;
+	private int addBlue = 0;
+	private int addAlpha = 0;
 
-    /**
-     * Construct an FSColorTransform object an initialize with the values 
-     * decoded from an encoded colour transform
-     * 
-     * @param coder an FSCoder object containing the encoded colour transform.
-     */
-    public FSColorTransform(FSCoder coder)
-    {
-        decode(coder);
-    }    
-    /** 
-     * Constructs an FSColorTransform object defining a unity transform. If the 
-     * transform is applied to a shape its colour will not change.
-     */
-    public FSColorTransform()
-    {
-    }    
-    /** Constructs an FSColorTransform object with the specified add terms.
+	/**
+	 * Construct an FSColorTransform object an initialise with the values
+	 * decoded from an encoded colour transform
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing the encoded colour transform.
+	 */
+	public FSColorTransform(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-        Each colour channel is transformed by the following calculation:
+	/**
+	 * Constructs an FSColorTransform object defining a unity transform. If the
+	 * transform is applied to a shape its colour will not change.
+	 */
+	public FSColorTransform()
+	{
+	}
 
-        &lt;pre&gt;
-        newRed = red + addRedTerm
-        newGreen = green + addGreenTerm
-        newBlue = blue + addBlueTerm
-        &lt;/pre&gt;
+	/**
+	 * Constructs an FSColorTransform object with the specified add terms.
+	 * 
+	 * Each colour channel is transformed by the following calculation:
+	 * 
+	 * &lt;pre&gt;
+	 * 	    newRed = red + addRedTerm
+	 * 	    newGreen = green + addGreenTerm
+	 * 	    newBlue = blue + addBlueTerm
+	 * 	
+	 * &lt;/pre&gt;
+	 * 
+	 * The add term value for the alpha channel defaults to 0 so if the
+	 * transform is added to an object that uses alpha channel information then
+	 * the alpha channel will remain unchanged.
+	 * 
+	 * In the Flash Player the value assigned to the respective colour channel
+	 * is clamped to the range 0..255.
+	 * 
+	 * @param redTerm
+	 *            value to add to the red colour channel.
+	 * @param greenTerm
+	 *            value to add to the green colour channel.
+	 * @param blueTerm
+	 *            value to add to the blue colour channel.
+	 */
+	public FSColorTransform(int redTerm, int greenTerm, int blueTerm)
+	{
+		setAddRed(redTerm);
+		setAddGreen(greenTerm);
+		setAddBlue(blueTerm);
+	}
 
-        The add term value for the alpha channel defaults to 0 so if the transform is added to an object that uses alpha channel information then the alpha channel will remain unchanged.
+	/**
+	 * Constructs an FSColorTransform object with the specified add terms,
+	 * including the alpha channel.
+	 * 
+	 * Each colour channel is transformed by the following calculation:
+	 * 
+	 * &lt;pre&gt;
+	 * 	    newRed = red + addRedTerm
+	 * 	    newGreen = green + addGreenTerm
+	 * 	    newBlue = blue + addBlueTerm
+	 * 	    newAlpha = alpha + addAlphaTerm
+	 * 	
+	 * &lt;/pre&gt;
+	 * 
+	 * In the Flash Player the value assigned to the respective colour channel
+	 * is clamped to the range 0..255.
+	 * 
+	 * @param redTerm
+	 *            value to add to the red colour channel.
+	 * @param greenTerm
+	 *            value to add to the green colour channel.
+	 * @param blueTerm
+	 *            value to add to the blue colour channel.
+	 * @param alphaTerm
+	 *            value to add to the alpha colour channel.
+	 */
+	public FSColorTransform(int redTerm, int greenTerm, int blueTerm,
+							int alphaTerm)
+	{
+		setAddRed(redTerm);
+		setAddGreen(greenTerm);
+		setAddBlue(blueTerm);
+		setAddAlpha(alphaTerm);
+	}
 
-        In the Flash Player the value assigned to the respective colour channel is clamped to the range 0..255.
+	/**
+	 * Constructs a FSColorTransform object initialised with the specified
+	 * multiply terms.
+	 * 
+	 * Each colour channel is transformed by the following calculation:
+	 * 
+	 * &lt;pre&gt;
+	 * 	    newRed = red * multiplyRedTerm
+	 * 	    newGreen = green * multiplyGreenTerm
+	 * 	    newBlue = blue * multiplyBlueTerm
+	 * 	
+	 * &lt;/pre&gt;
+	 * 
+	 * The multiply term value for the alpha channel defaults to 1.0 so if the
+	 * transform is added to an object that uses alpha channel information then
+	 * the alpha channel will remain unchanged.
+	 * 
+	 * In the Flash Player the value assigned to the respective colour channel
+	 * is clamped to the range 0..255.
+	 * 
+	 * @param redTerm
+	 *            value to multiply the red colour channel by.
+	 * @param greenTerm
+	 *            value to multiply the green colour channel by.
+	 * @param blueTerm
+	 *            value to multiply the blue colour channel by.
+	 */
+	public FSColorTransform(float redTerm, float greenTerm, float blueTerm)
+	{
+		setMultiplyRed(redTerm);
+		setMultiplyGreen(greenTerm);
+		setMultiplyBlue(blueTerm);
+	}
 
-        @param redTerm value to add to the red colour channel.
-        @param greenTerm value to add to the green colour channel.
-        @param blueTerm value to add to the blue colour channel.
-        */
-    public FSColorTransform(int redTerm, int greenTerm, int blueTerm)
-    {
-        setAddRed(redTerm);
-        setAddGreen(greenTerm);
-        setAddBlue(blueTerm);
-    }
+	/**
+	 * Constructs a FSColorTransform object initialised with the specified
+	 * multiply terms, including the alpha channel.
+	 * 
+	 * Each colour channel is transformed by the following calculation:
+	 * 
+	 * &lt;pre&gt;
+	 * 	    newRed = red * multiplyRedTerm
+	 * 	    newGreen = green * multiplyGreenTerm
+	 * 	    newBlue = blue * multiplyBlueTerm
+	 * 	    newAlpha = alpha * multiplyAlphaTerm
+	 * 	
+	 * &lt;/pre&gt;
+	 * 
+	 * In the Flash Player the value assigned to the respective colour channel
+	 * is clamped to the range 0..255.
+	 * 
+	 * @param redTerm
+	 *            value to multiply the red colour channel by.
+	 * @param greenTerm
+	 *            value to multiply the green colour channel by.
+	 * @param blueTerm
+	 *            value to multiply the blue colour channel by.
+	 * @param alphaTerm
+	 *            value to multiply the alpha colour channel by.
+	 */
+	public FSColorTransform(float redTerm, float greenTerm, float blueTerm,
+							float alphaTerm)
+	{
+		setMultiplyRed(redTerm);
+		setMultiplyGreen(greenTerm);
+		setMultiplyBlue(blueTerm);
+		setMultiplyAlpha(alphaTerm);
+	}
 
-    /** Constructs an FSColorTransform object with the specified add terms, including the alpha channel.
+	/**
+	 * Constructs a FSColorTransform object initialised with the specified
+	 * addition and multiplication terms.
+	 * 
+	 * Each colour channel is transformed by the following calculation:
+	 * 
+	 * &lt;pre&gt;
+	 * 	    newRed = (red * multiplyRedTerm) + addRedTerm
+	 * 	    newGreen = (green * multiplyGreenTerm) + addGreenTerm
+	 * 	    newBlue = (blue * multiplyBlueTerm) + addBlueTerm
+	 * 	
+	 * &lt;/pre&gt;
+	 * 
+	 * The multiply and add terms for the alpha channel default to 1.0 and 0
+	 * respectively so for objects that use the alpha channel information then
+	 * the alpha channel will remain unchanged.
+	 * 
+	 * In the Flash Player the value assigned to the respective colour channel
+	 * is clamped to the range 0..255.
+	 * 
+	 * @param multRedTerm
+	 *            value to multiply the red colour channel by.
+	 * @param multGreenTerm
+	 *            value to multiply the green colour channel by.
+	 * @param multBlueTerm
+	 *            value to multiply the blue colour channel by.
+	 * @param addRedTerm
+	 *            value to add to the red colour channel.
+	 * @param addGreenTerm
+	 *            value to add to the green colour channel.
+	 * @param addBlueTerm
+	 *            value to add to the blue colour channel.
+	 */
+	public FSColorTransform(float multRedTerm, float multGreenTerm,
+							float multBlueTerm, int addRedTerm,
+							int addGreenTerm, int addBlueTerm)
+	{
+		setMultiplyRed(multRedTerm);
+		setMultiplyGreen(multGreenTerm);
+		setMultiplyBlue(multBlueTerm);
+		setAddRed(addRedTerm);
+		setAddGreen(addGreenTerm);
+		setAddBlue(addBlueTerm);
+	}
 
-        Each colour channel is transformed by the following calculation:
+	/**
+	 * Constructs a FSColorTransform object initialised with the specified
+	 * addition and multiplication terms, including alpha channel values.
+	 * 
+	 * Each colour channel is transformed by the following calculation:
+	 * 
+	 * &lt;pre&gt;
+	 * 	    newRed = (red * multiplyRedTerm) + addRedTerm
+	 * 	    newGreen = (green * multiplyGreenTerm) + addGreenTerm
+	 * 	    newBlue = (blue * multiplyBlueTerm) + addBlueTerm
+	 * 	    newAlpha = (alpha * multiplyAlphaTerm) + addAlphaTerm
+	 * 	
+	 * &lt;/pre&gt;
+	 * 
+	 * In the Flash Player the value assigned to the respective colour channel
+	 * is clamped to the range 0..255.
+	 * 
+	 * @param multRedTerm
+	 *            value to multiply the red colour channel by.
+	 * @param multGreenTerm
+	 *            value to multiply the green colour channel by.
+	 * @param multBlueTerm
+	 *            value to multiply the blue colour channel by.
+	 * @param multAlphaTerm
+	 *            value to multiply the alpha colour channel by.
+	 * @param addRedTerm
+	 *            value to add to the red colour channel.
+	 * @param addGreenTerm
+	 *            value to add to the green colour channel.
+	 * @param addBlueTerm
+	 *            value to add to the blue colour channel.
+	 * @param addAlphaTerm
+	 *            value to add to the alpha colour channel.
+	 */
+	public FSColorTransform(float multRedTerm, float multGreenTerm,
+							float multBlueTerm, float multAlphaTerm,
+							int addRedTerm, int addGreenTerm, int addBlueTerm,
+							int addAlphaTerm)
+	{
+		setMultiplyRed(multRedTerm);
+		setMultiplyGreen(multGreenTerm);
+		setMultiplyBlue(multBlueTerm);
+		setMultiplyAlpha(multAlphaTerm);
+		setAddRed(addRedTerm);
+		setAddGreen(addGreenTerm);
+		setAddBlue(addBlueTerm);
+		setAddAlpha(addAlphaTerm);
+	}
 
-        &lt;pre&gt;
-        newRed = red + addRedTerm
-        newGreen = green + addGreenTerm
-        newBlue = blue + addBlueTerm
-        newAlpha = alpha + addAlphaTerm
-        &lt;/pre&gt;
+	/**
+	 * Construct an FSColorTansform object and initialize it using a copy of the
+	 * values from another colour transform.
+	 * 
+	 * @param obj
+	 *            a colour transform.
+	 */
+	public FSColorTransform(FSColorTransform obj)
+	{
+		multiplyRed = obj.multiplyRed;
+		multiplyGreen = obj.multiplyGreen;
+		multiplyBlue = obj.multiplyBlue;
+		multiplyAlpha = obj.multiplyAlpha;
+		addRed = obj.addRed;
+		addGreen = obj.addGreen;
+		addBlue = obj.addBlue;
+		addAlpha = obj.addAlpha;
+	}
 
-        In the Flash Player the value assigned to the respective colour channel is clamped to the range 0..255.
+	/**
+	 * Gets the value of the multiply term for the red channel.
+	 * 
+	 * @return the value that will be multiplied with the red colour channel's
+	 *         value.
+	 */
+	public float getMultiplyRed()
+	{
+		return multiplyRed;
+	}
 
-        @param redTerm value to add to the red colour channel.
-        @param greenTerm value to add to the green colour channel.
-        @param blueTerm value to add to the blue colour channel.
-        @param alphaTerm value to add to the alpha colour channel.
-        */
-    public FSColorTransform(int redTerm, int greenTerm, int blueTerm, int alphaTerm)
-    {
-        setAddRed(redTerm);
-        setAddGreen(greenTerm);
-        setAddBlue(blueTerm);
-        setAddAlpha(alphaTerm);
-    }
+	/**
+	 * Gets the value of the multiply term for the green channel.
+	 * 
+	 * @return the value that will be multiplied with the green colour channel's
+	 *         value.
+	 */
+	public float getMultiplyGreen()
+	{
+		return multiplyGreen;
+	}
 
-    /** Constructs a FSColorTransform object initialised with the specified multiply terms.
+	/**
+	 * Gets the value of the multiply term for the blue channel.
+	 * 
+	 * @return the value that will be multiplied with the blue colour channel's
+	 *         value.
+	 */
+	public float getMultiplyBlue()
+	{
+		return multiplyBlue;
+	}
 
-        Each colour channel is transformed by the following calculation:
+	/**
+	 * Gets the value of the multiply term for the alpha channel.
+	 * 
+	 * @return the value that will be multiplied with the alpha colour channel's
+	 *         value.
+	 */
+	public float getMultiplyAlpha()
+	{
+		return multiplyAlpha;
+	}
 
-        &lt;pre&gt;
-        newRed = red * multiplyRedTerm
-        newGreen = green * multiplyGreenTerm
-        newBlue = blue * multiplyBlueTerm
-        &lt;/pre&gt;
+	/**
+	 * Gets the value of the add term for the red channel.
+	 * 
+	 * @return the value that will be added to the red colour channel's value.
+	 */
+	public int getAddRed()
+	{
+		return addRed;
+	}
 
-        The multiply term value for the alpha channel defaults to 1.0 so if the transform is added to an object that uses alpha channel information then the alpha channel will remain unchanged.
+	/**
+	 * Gets the value of the add term for the green channel.
+	 * 
+	 * @return the value that will be added to the green colour channel's value.
+	 */
+	public int getAddGreen()
+	{
+		return addGreen;
+	}
 
-        In the Flash Player the value assigned to the respective colour channel is clamped to the range 0..255.
+	/**
+	 * Gets the value of the add term for the blue channel.
+	 * 
+	 * @return the value that will be added to the blue colour channel's value.
+	 */
+	public int getAddBlue()
+	{
+		return addBlue;
+	}
 
-        @param redTerm value to multiply the red colour channel by.
-        @param greenTerm value to multiply the green colour channel by.
-        @param blueTerm value to multiply the blue colour channel by.
-        */
-    public FSColorTransform(float redTerm, float greenTerm, float blueTerm)
-    {
-        setMultiplyRed(redTerm);
-        setMultiplyGreen(greenTerm);
-        setMultiplyBlue(blueTerm);
-    }
+	/**
+	 * Gets the value of the add term for the alpha channel.
+	 * 
+	 * @return the value that will be added to the alpha colour channel's value.
+	 */
+	public int getAddAlpha()
+	{
+		return addAlpha;
+	}
 
-    /** Constructs a FSColorTransform object initialised with the specified multiply terms, including the alpha channel.
+	/**
+	 * Sets the value for the multiplyTerm which will be applied to the red
+	 * colour channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be multiplied with the red colour channel's
+	 *            value.
+	 */
+	public void setMultiplyRed(float aNumber)
+	{
+		multiplyRed = aNumber;
+	}
 
-        Each colour channel is transformed by the following calculation:
+	/**
+	 * Sets the value for the multiplyTerm which will be applied to the green
+	 * colour channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be multiplied with the green colour channel's
+	 *            value.
+	 */
+	public void setMultiplyGreen(float aNumber)
+	{
+		multiplyGreen = aNumber;
+	}
 
-        &lt;pre&gt;
-        newRed = red * multiplyRedTerm
-        newGreen = green * multiplyGreenTerm
-        newBlue = blue * multiplyBlueTerm
-        newAlpha = alpha * multiplyAlphaTerm
-        &lt;/pre&gt;
+	/**
+	 * Sets the value for the multiplyTerm which will be applied to the blue
+	 * colour channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be multiplied with the blue colour channel's
+	 *            value.
+	 */
+	public void setMultiplyBlue(float aNumber)
+	{
+		multiplyBlue = aNumber;
+	}
 
-        In the Flash Player the value assigned to the respective colour channel is clamped to the range 0..255.
+	/**
+	 * Sets the value for the multiplyTerm which will be applied to the alpha
+	 * colour channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be multiplied with the alpha colour channel's
+	 *            value.
+	 */
+	public void setMultiplyAlpha(float aNumber)
+	{
+		multiplyAlpha = aNumber;
+	}
 
-        @param redTerm value to multiply the red colour channel by.
-        @param greenTerm value to multiply the green colour channel by.
-        @param blueTerm value to multiply the blue colour channel by.
-        @param alphaTerm value to multiply the alpha colour channel by.
-        */
-    public FSColorTransform(float redTerm, float greenTerm, float blueTerm, float alphaTerm)
-    {
-        setMultiplyRed(redTerm);
-        setMultiplyGreen(greenTerm);
-        setMultiplyBlue(blueTerm);
-        setMultiplyAlpha(alphaTerm);
-    }
+	/**
+	 * Sets the values for the multiply terms for the red, green and blue colour
+	 * channels
+	 * 
+	 * @param redTerm
+	 *            value to multiply the red colour channel by.
+	 * @param greenTerm
+	 *            value to multiply the green colour channel by.
+	 * @param blueTerm
+	 *            value to multiply the blue colour channel by.
+	 */
+	public void setMultiplyTerms(float redTerm, float greenTerm, float blueTerm)
+	{
+		setMultiplyRed(redTerm);
+		setMultiplyGreen(greenTerm);
+		setMultiplyBlue(blueTerm);
+	}
 
-    /** Constructs a FSColorTransform object initialised with the specified addition and multiplication terms. 
+	/**
+	 * Sets the values for the multiply terms for each of the colour channels
+	 * 
+	 * @param redTerm
+	 *            value to multiply the red colour channel by.
+	 * @param greenTerm
+	 *            value to multiply the green colour channel by.
+	 * @param blueTerm
+	 *            value to multiply the blue colour channel by.
+	 * @param alphaTerm
+	 *            value to multiply the alpha colour channel by.
+	 */
+	public void setMultiplyTerms(float redTerm, float greenTerm,
+									float blueTerm, float alphaTerm)
+	{
+		setMultiplyRed(redTerm);
+		setMultiplyGreen(greenTerm);
+		setMultiplyBlue(blueTerm);
+		setMultiplyAlpha(alphaTerm);
+	}
 
-        Each colour channel is transformed by the following calculation:
+	/**
+	 * Sets the value for the addTerm which will be applied to the red colour
+	 * channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be added to the red colour channel's value.
+	 */
+	public void setAddRed(int aNumber)
+	{
+		addRed = aNumber;
+	}
 
-        &lt;pre&gt;
-        newRed = (red * multiplyRedTerm) + addRedTerm
-        newGreen = (green * multiplyGreenTerm) + addGreenTerm
-        newBlue = (blue * multiplyBlueTerm) + addBlueTerm
-        &lt;/pre&gt;
+	/**
+	 * Sets the value for the addTerm which will be applied to the green colour
+	 * channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be added to the green colour channel's value.
+	 */
+	public void setAddGreen(int aNumber)
+	{
+		addGreen = aNumber;
+	}
 
-        The multiply and add terms for the alpha channel default to 1.0 and 0 respectively so for objects that use the alpha channel information then the alpha channel will remain unchanged.
+	/**
+	 * Sets the value for the addTerm which will be applied to the blue colour
+	 * channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be added to the blue colour channel's value.
+	 */
+	public void setAddBlue(int aNumber)
+	{
+		addBlue = aNumber;
+	}
 
-        In the Flash Player the value assigned to the respective colour channel is clamped to the range 0..255.
+	/**
+	 * Sets the value for the addTerm which will be applied to the alpha colour
+	 * channel.
+	 * 
+	 * @param aNumber
+	 *            the value to be added to the alpha colour channel's value.
+	 */
+	public void setAddAlpha(int aNumber)
+	{
+		addAlpha = aNumber;
+	}
 
-        @param multRedTerm value to multiply the red colour channel by.
-        @param multGreenTerm value to multiply the green colour channel by.
-        @param multBlueTerm value to multiply the blue colour channel by.
-        @param addRedTerm value to add to the red colour channel.
-        @param addGreenTerm value to add to the green colour channel.
-        @param addBlueTerm value to add to the blue colour channel.
-        */
-    public FSColorTransform(float multRedTerm, float multGreenTerm, float multBlueTerm, int addRedTerm, int addGreenTerm, int addBlueTerm)
-    {
-        setMultiplyRed(multRedTerm);
-        setMultiplyGreen(multGreenTerm);
-        setMultiplyBlue(multBlueTerm);
-        setAddRed(addRedTerm);
-        setAddGreen(addGreenTerm);
-        setAddBlue(addBlueTerm);
-    }
+	/**
+	 * Sets the values for the add terms for each of the colour channels.
+	 * 
+	 * @param redTerm
+	 *            value to add to the red colour channel.
+	 * @param greenTerm
+	 *            value to add to the green colour channel.
+	 * @param blueTerm
+	 *            value to add to the blue colour channel.
+	 * @param alphaTerm
+	 *            value to add to the alpha colour channel.
+	 */
+	public void setAddTerms(int redTerm, int greenTerm, int blueTerm,
+							int alphaTerm)
+	{
+		setAddRed(redTerm);
+		setAddGreen(greenTerm);
+		setAddBlue(blueTerm);
+		setAddAlpha(alphaTerm);
+	}
 
-    /** Constructs a FSColorTransform object initialised with the specified addition and multiplication terms, including alpha channel values. 
+	/**
+	 * Sets the values for the add terms for the red, green and blue colour
+	 * channels.
+	 * 
+	 * @param redTerm
+	 *            value to add to the red colour channel.
+	 * @param greenTerm
+	 *            value to add to the green colour channel.
+	 * @param blueTerm
+	 *            value to add to the blue colour channel.
+	 */
+	public void setAddTerms(int redTerm, int greenTerm, int blueTerm)
+	{
+		setAddRed(redTerm);
+		setAddGreen(greenTerm);
+		setAddBlue(blueTerm);
+	}
 
-        Each colour channel is transformed by the following calculation:
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        &lt;pre&gt;
-        newRed = (red * multiplyRedTerm) + addRedTerm
-        newGreen = (green * multiplyGreenTerm) + addGreenTerm
-        newBlue = (blue * multiplyBlueTerm) + addBlueTerm
-        newAlpha = (alpha * multiplyAlphaTerm) + addAlphaTerm
-        &lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSColorTransform typedObject = (FSColorTransform) anObject;
 
-        In the Flash Player the value assigned to the respective colour channel is clamped to the range 0..255.
+			result = multiplyRed == typedObject.multiplyRed;
+			result = result &amp;&amp; multiplyGreen == typedObject.multiplyGreen;
+			result = result &amp;&amp; multiplyBlue == typedObject.multiplyBlue;
+			result = result &amp;&amp; multiplyAlpha == typedObject.multiplyAlpha;
+			result = result &amp;&amp; addRed == typedObject.addRed;
+			result = result &amp;&amp; addGreen == typedObject.addGreen;
+			result = result &amp;&amp; addBlue == typedObject.addBlue;
+			result = result &amp;&amp; addAlpha == typedObject.addAlpha;
+		}
+		return result;
+	}
 
-        @param multRedTerm value to multiply the red colour channel by.
-        @param multGreenTerm value to multiply the green colour channel by.
-        @param multBlueTerm value to multiply the blue colour channel by.
-        @param multAlphaTerm value to multiply the alpha colour channel by.
-        @param addRedTerm value to add to the red colour channel.
-        @param addGreenTerm value to add to the green colour channel.
-        @param addBlueTerm value to add to the blue colour channel.
-        @param addAlphaTerm value to add to the alpha colour channel.
-        */
-    public FSColorTransform(float multRedTerm, float multGreenTerm, float multBlueTerm, float multAlphaTerm, int addRedTerm, int addGreenTerm, int addBlueTerm, int addAlphaTerm)
-    {
-        setMultiplyRed(multRedTerm);
-        setMultiplyGreen(multGreenTerm);
-        setMultiplyBlue(multBlueTerm);
-        setMultiplyAlpha(multAlphaTerm);
-        setAddRed(addRedTerm);
-        setAddGreen(addGreenTerm);
-        setAddBlue(addBlueTerm);
-        setAddAlpha(addAlphaTerm);
-    }
-    /**
-     * Construct an FSColorTansform object and initialize it using a copy of 
-     * the values from another colour transform.
-     * 
-     * @param obj a colour transform.
-     */
-    public FSColorTransform(FSColorTransform obj)
-    {
-        multiplyRed = obj.multiplyRed;
-        multiplyGreen = obj.multiplyGreen;
-        multiplyBlue = obj.multiplyBlue;
-        multiplyAlpha = obj.multiplyAlpha;
-        addRed = obj.addRed;
-        addGreen = obj.addGreen;
-        addBlue = obj.addBlue;
-        addAlpha = obj.addAlpha;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the value of the multiply term for the red channel. 
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			buffer.append(&quot;multiply = [&quot; + multiplyRed + &quot;, &quot; + multiplyGreen
+							+ &quot;, &quot; + multiplyBlue + &quot;, &quot; + multiplyAlpha
+							+ &quot;]; &quot;);
+			buffer.append(&quot;add = [&quot; + addRed + &quot;, &quot; + addGreen + &quot;, &quot; + addBlue
+							+ &quot;, &quot; + addAlpha + &quot;]; &quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the value that will be multiplied with the red colour channel's value.
-        */
-    public float getMultiplyRed() { return multiplyRed; }    
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 6;
+		int fieldSize = fieldSize(coder);
+		boolean containsMultiplyTerms = containsMultiplyTerms(coder);
+		boolean containsAddTerms = containsAddTerms(coder);
 
-    /** Gets the value of the multiply term for the green channel. 
+		if (containsMultiplyTerms)
+			numberOfBits += fieldSize
+							* ((coder.context[FSCoder.TransparentColors] != 0) ? 4
+											: 3);
 
-        @return the value that will be multiplied with the green colour channel's value.
-        */
-    public float getMultiplyGreen() { return multiplyGreen; }
+		if (containsAddTerms)
+			numberOfBits += fieldSize
+							* ((coder.context[FSCoder.TransparentColors] != 0) ? 4
+											: 3);
 
-    /** Gets the value of the multiply term for the blue channel. 
+		numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
 
-        @return the value that will be multiplied with the blue colour channel's value.
-        */
-    public float getMultiplyBlue() { return multiplyBlue; }
+		return numberOfBits &gt;&gt; 3;
+	}
 
-    /** Gets the value of the multiply term for the alpha channel. 
+	public void encode(FSCoder coder)
+	{
+		int numberOfBits = fieldSize(coder);
+		boolean containsMultiplyTerms = containsMultiplyTerms(coder);
+		boolean containsAddTerms = containsAddTerms(coder);
 
-        @return the value that will be multiplied with the alpha colour channel's value.
-        */
-    public float getMultiplyAlpha() { return multiplyAlpha; }
+		coder.alignToByte();
 
-    /** Gets the value of the add term for the red channel. 
+		coder.writeBits(containsAddTerms ? 1 : 0, 1);
+		coder.writeBits(containsMultiplyTerms ? 1 : 0, 1);
+		coder.writeBits(numberOfBits, 4);
 
-        @return the value that will be added to the red colour channel's value.
-        */
-    public int getAddRed() { return addRed; }
+		if (containsMultiplyTerms)
+		{
+			coder.writeFixedBits(multiplyRed, numberOfBits, 8);
+			coder.writeFixedBits(multiplyGreen, numberOfBits, 8);
+			coder.writeFixedBits(multiplyBlue, numberOfBits, 8);
 
-    /** Gets the value of the add term for the green channel. 
+			if (coder.context[FSCoder.TransparentColors] != 0)
+				coder.writeFixedBits(multiplyAlpha, numberOfBits, 8);
+		}
+		if (containsAddTerms)
+		{
+			coder.writeBits(addRed, numberOfBits);
+			coder.writeBits(addGreen, numberOfBits);
+			coder.writeBits(addBlue, numberOfBits);
 
-        @return the value that will be added to the green colour channel's value.
-        */
-    public int getAddGreen() { return addGreen; }
+			if (coder.context[FSCoder.TransparentColors] != 0)
+				coder.writeBits(addAlpha, numberOfBits);
+		}
+		coder.alignToByte();
+	}
 
-    /** Gets the value of the add term for the blue channel. 
+	public void decode(FSCoder coder)
+	{
+		boolean containsAddTerms = false;
+		boolean containsMultiplyTerms = false;
+		int fieldSize = 0;
 
-        @return the value that will be added to the blue colour channel's value.
-        */
-    public int getAddBlue() { return addBlue; }
+		coder.alignToByte();
 
-    /** Gets the value of the add term for the alpha channel. 
+		containsAddTerms = coder.readBits(1, false) != 0 ? true : false;
+		containsMultiplyTerms = coder.readBits(1, false) != 0 ? true : false;
+		fieldSize = coder.readBits(4, false);
 
-        @return the value that will be added to the alpha colour channel's value.
-        */
-    public int getAddAlpha() { return addAlpha; }
+		if (containsMultiplyTerms)
+		{
+			multiplyRed = coder.readFixedBits(fieldSize, 8);
+			multiplyGreen = coder.readFixedBits(fieldSize, 8);
+			multiplyBlue = coder.readFixedBits(fieldSize, 8);
 
-    /** Sets the value for the multiplyTerm which will be applied to the red colour channel.
+			if (coder.context[FSCoder.TransparentColors] != 0)
+				multiplyAlpha = coder.readFixedBits(fieldSize, 8);
+		}
 
-        @param aNumber the value to be multiplied with the red colour channel's value.
-        */
-    public void setMultiplyRed(float aNumber) 
-    {
-        multiplyRed = aNumber;
-    }
+		if (containsAddTerms)
+		{
+			addRed = coder.readBits(fieldSize, true);
+			addGreen = coder.readBits(fieldSize, true);
+			addBlue = coder.readBits(fieldSize, true);
 
-    /** Sets the value for the multiplyTerm which will be applied to the green colour channel.
+			if (coder.context[FSCoder.TransparentColors] != 0)
+				addAlpha = coder.readBits(fieldSize, true);
+		}
+		coder.alignToByte();
+	}
 
-        @param aNumber the value to be multiplied with the green colour channel's value.
-        */
-    public void setMultiplyGreen(float aNumber) 
-    {
-        multiplyGreen = aNumber;
-    }
+	/**
+	 * Returns true if the values for the add and multiply terms represent a
+	 * unity transform - one which will not change the colour of a shape.
+	 * Whether the alpha channel is included is determined by the context
+	 * associated with the FSCoder object.
+	 * 
+	 * @param coder
+	 *            the FSCoder used to encoded the transform.
+	 * @return true if the object represents a unity transform, false otherwise.
+	 */
+	public boolean isUnityTransform(FSCoder coder)
+	{
+		return !(containsAddTerms(coder) || containsMultiplyTerms(coder));
+	}
 
-    /** Sets the value for the multiplyTerm which will be applied to the blue colour channel.
+	private boolean containsAddTerms(FSCoder coder)
+	{
+		boolean containsTerms = addRed != 0 || addGreen != 0 || addBlue != 0;
 
-        @param aNumber the value to be multiplied with the blue colour channel's value.
-        */
-    public void setMultiplyBlue(float aNumber) 
-    {
-        multiplyBlue = aNumber;
-    }
+		if (coder.context[FSCoder.TransparentColors] != 0)
+			containsTerms = containsTerms || addAlpha != 0;
 
-    /** Sets the value for the multiplyTerm which will be applied to the alpha colour channel.
+		return containsTerms;
+	}
 
-        @param aNumber the value to be multiplied with the alpha colour channel's value.
-        */     
-    public void setMultiplyAlpha(float aNumber) 
-    {
-        multiplyAlpha = aNumber;
-    }
+	private boolean containsMultiplyTerms(FSCoder coder)
+	{
+		boolean containsTerms = multiplyRed != 1.0 || multiplyGreen != 1.0
+						|| multiplyBlue != 1.0;
 
-    /** Sets the values for the multiply terms for the red, green and blue colour channels
+		if (coder.context[FSCoder.TransparentColors] != 0)
+			containsTerms = containsTerms || multiplyAlpha != 1.0;
 
-        @param redTerm value to multiply the red colour channel by.
-        @param greenTerm value to multiply the green colour channel by.
-        @param blueTerm value to multiply the blue colour channel by.
-        */
-    public void setMultiplyTerms(float redTerm, float greenTerm, float blueTerm)
-    {
-        setMultiplyRed(redTerm);
-        setMultiplyGreen(greenTerm);
-        setMultiplyBlue(blueTerm);
-    }
+		return containsTerms;
+	}
 
-    /** Sets the values for the multiply terms for each of the colour channels
+	private int addFieldSize(FSCoder coder)
+	{
+		int[] values;
+		int size = 0;
 
-        @param redTerm value to multiply the red colour channel by.
-        @param greenTerm value to multiply the green colour channel by.
-        @param blueTerm value to multiply the blue colour channel by.
-        @param alphaTerm value to multiply the alpha colour channel by.
-        */
-    public void setMultiplyTerms(float redTerm, float greenTerm, float blueTerm, float alphaTerm)
-    {
-        setMultiplyRed(redTerm);
-        setMultiplyGreen(greenTerm);
-        setMultiplyBlue(blueTerm);
-        setMultiplyAlpha(alphaTerm);
-    }
+		if (coder.context[FSCoder.TransparentColors] != 0)
+			values = new int[]
+			{
+				addRed, addGreen, addBlue, addAlpha };
+		else
+			values = new int[]
+			{
+				addRed, addGreen, addBlue };
 
-    /** Sets the value for the addTerm which will be applied to the red colour channel.
+		size = FSCoder.size(values, true);
 
-        @param aNumber the value to be added to the red colour channel's value.
-        */
-    public void setAddRed(int aNumber) 
-    {
-        addRed = aNumber;
-    }
+		return size;
+	}
 
-    /** Sets the value for the addTerm which will be applied to the green colour channel.
+	private int multiplyFieldSize(FSCoder coder)
+	{
+		float[] values;
+		int size = 0;
 
-        @param aNumber the value to be added to the green colour channel's value.
-        */
-    public void setAddGreen(int aNumber) 
-    {
-        addGreen = aNumber;
-    }
+		if (coder.context[FSCoder.TransparentColors] != 0)
+			values = new float[]
+			{
+				multiplyRed, multiplyGreen, multiplyBlue, multiplyAlpha };
+		else
+			values = new float[]
+			{
+				multiplyRed, multiplyGreen, multiplyBlue };
 
-    /** Sets the value for the addTerm which will be applied to the blue colour channel.
+		size = FSCoder.fixedShortSize(values);
 
-        @param aNumber the value to be added to the blue colour channel's value.
-        */
-    public void setAddBlue(int aNumber) 
-    {
-        addBlue = aNumber;
-    }
+		return size;
+	}
 
-    /** Sets the value for the addTerm which will be applied to the alpha colour channel.
+	private int fieldSize(FSCoder coder)
+	{
+		boolean containsMultiplyTerms = containsMultiplyTerms(coder);
+		boolean containsAddTerms = containsAddTerms(coder);
+		int numberOfBits = 0;
 
-        @param aNumber the value to be added to the alpha colour channel's value.
-        */
-    public void setAddAlpha(int aNumber) 
-    {
-        addAlpha = aNumber;
-    }
+		if (containsAddTerms &amp;&amp; !containsMultiplyTerms)
+			numberOfBits = addFieldSize(coder);
+		else if (!containsAddTerms &amp;&amp; containsMultiplyTerms)
+			numberOfBits = multiplyFieldSize(coder);
+		else if (containsAddTerms &amp;&amp; containsMultiplyTerms)
+			numberOfBits = Math.max(addFieldSize(coder),
+							multiplyFieldSize(coder));
+		else
+			numberOfBits = 1;
 
-    /** Sets the values for the add terms for each of the colour channels.
-
-        @param redTerm value to add to the red colour channel.
-        @param greenTerm value to add to the green colour channel.
-        @param blueTerm value to add to the blue colour channel.
-        @param alphaTerm value to add to the alpha colour channel.
-        */
-    public void setAddTerms(int redTerm, int greenTerm, int blueTerm, int alphaTerm)
-    {
-        setAddRed(redTerm);
-        setAddGreen(greenTerm);
-        setAddBlue(blueTerm);
-        setAddAlpha(alphaTerm);
-    }
-
-    /** Sets the values for the add terms for the red, green and blue colour channels.
-
-        @param redTerm value to add to the red colour channel.
-        @param greenTerm value to add to the green colour channel.
-        @param blueTerm value to add to the blue colour channel.
-        */
-    public void setAddTerms(int redTerm, int greenTerm, int blueTerm)
-    {
-        setAddRed(redTerm);
-        setAddGreen(greenTerm);
-        setAddBlue(blueTerm);
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSColorTransform typedObject = (FSColorTransform)anObject;
-            
-            result = multiplyRed == typedObject.multiplyRed;
-            result = result &amp;&amp; multiplyGreen == typedObject.multiplyGreen;
-            result = result &amp;&amp; multiplyBlue == typedObject.multiplyBlue;
-            result = result &amp;&amp; multiplyAlpha == typedObject.multiplyAlpha;
-            result = result &amp;&amp; addRed == typedObject.addRed;
-            result = result &amp;&amp; addGreen == typedObject.addGreen;
-            result = result &amp;&amp; addBlue == typedObject.addBlue;
-            result = result &amp;&amp; addAlpha == typedObject.addAlpha;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            buffer.append(&quot;multiply = [&quot; + multiplyRed + &quot;, &quot; + multiplyGreen + &quot;, &quot; + multiplyBlue + &quot;, &quot; + multiplyAlpha + &quot;]; &quot;);
-            buffer.append(&quot;add = [&quot; + addRed + &quot;, &quot; + addGreen + &quot;, &quot; + addBlue + &quot;, &quot; + addAlpha + &quot;]; &quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 6;
-        int fieldSize = fieldSize(coder);
-        boolean containsMultiplyTerms = containsMultiplyTerms(coder);
-        boolean containsAddTerms = containsAddTerms(coder);
-    
-        if (containsMultiplyTerms)
-            numberOfBits += fieldSize * ((coder.context[FSCoder.TransparentColors] != 0) ? 4 : 3);
-            
-        if (containsAddTerms)
-            numberOfBits += fieldSize * ((coder.context[FSCoder.TransparentColors] != 0) ? 4 : 3);
-
-        numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
-    
-        return numberOfBits&gt;&gt;3;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfBits = fieldSize(coder);
-        boolean containsMultiplyTerms = containsMultiplyTerms(coder);
-        boolean containsAddTerms = containsAddTerms(coder);
-        
-        coder.alignToByte();
-        
-        coder.writeBits(containsAddTerms ? 1 : 0, 1);
-        coder.writeBits(containsMultiplyTerms ? 1 : 0, 1);
-        coder.writeBits(numberOfBits, 4);
-    
-        if (containsMultiplyTerms)
-        {
-            coder.writeFixedBits(multiplyRed, numberOfBits, 8);
-            coder.writeFixedBits(multiplyGreen, numberOfBits, 8);
-            coder.writeFixedBits(multiplyBlue, numberOfBits, 8);
-    
-            if (coder.context[FSCoder.TransparentColors] != 0)
-                coder.writeFixedBits(multiplyAlpha, numberOfBits, 8);
-        }
-        if (containsAddTerms)
-        {
-            coder.writeBits(addRed, numberOfBits);
-            coder.writeBits(addGreen, numberOfBits);
-            coder.writeBits(addBlue, numberOfBits);
-    
-            if (coder.context[FSCoder.TransparentColors] != 0)
-                coder.writeBits(addAlpha, numberOfBits);
-        }
-        coder.alignToByte();
-    }
-     
-    public void decode(FSCoder coder)
-    {
-        boolean containsAddTerms = false;
-        boolean containsMultiplyTerms = false;
-        int fieldSize = 0;
-                
-        coder.alignToByte();
-
-        containsAddTerms = coder.readBits(1, false) != 0 ? true : false;
-        containsMultiplyTerms = coder.readBits(1, false) != 0 ? true : false;
-        fieldSize = coder.readBits(4, false);
-        
-        if (containsMultiplyTerms)
-        {
-            multiplyRed = coder.readFixedBits(fieldSize, 8);
-            multiplyGreen = coder.readFixedBits(fieldSize, 8);
-            multiplyBlue = coder.readFixedBits(fieldSize, 8);
-            
-            if (coder.context[FSCoder.TransparentColors] != 0)
-                multiplyAlpha = coder.readFixedBits(fieldSize, 8);
-        }
-        
-        if (containsAddTerms)
-        {
-            addRed = coder.readBits(fieldSize, true);
-            addGreen = coder.readBits(fieldSize, true);
-            addBlue = coder.readBits(fieldSize, true);
-            
-            if (coder.context[FSCoder.TransparentColors] != 0)
-                addAlpha = coder.readBits(fieldSize, true);
-        }
-        coder.alignToByte();
-    }
-
-    /** Returns true if the values for the add and multiply terms represent a unity transform - one which will not change the colour of a shape. Whether the alpha channel is included is determined by the context associated with the FSCoder object.
-    
-        @param coder the FSCoder used to encoded the transform.
-        @return true if the object represents a unity transform, false otherwise.
-        */
-    public boolean isUnityTransform(FSCoder coder)
-    {
-        return ! (containsAddTerms(coder) || containsMultiplyTerms(coder));
-    }
-
-    private boolean containsAddTerms(FSCoder coder) 
-    {
-        boolean containsTerms = addRed != 0 || addGreen != 0 || addBlue != 0;
-        
-        if (coder.context[FSCoder.TransparentColors] != 0)
-            containsTerms = containsTerms || addAlpha != 0;
-            
-        return containsTerms;
-    }
-
-    private boolean containsMultiplyTerms(FSCoder coder) 
-    {
-        boolean containsTerms = multiplyRed != 1.0 || multiplyGreen != 1.0 || multiplyBlue != 1.0;
-        
-        if (coder.context[FSCoder.TransparentColors] != 0)
-            containsTerms = containsTerms || multiplyAlpha != 1.0;
-        
-        return containsTerms;
-    }
-
-    private int addFieldSize(FSCoder coder)
-    {
-        int[] values;
-        int size = 0;
-
-        if (coder.context[FSCoder.TransparentColors] != 0)
-            values = new int[] { addRed, addGreen, addBlue, addAlpha };
-        else
-            values = new int[] { addRed, addGreen, addBlue };
-
-        size = FSCoder.size(values, true);
-        
-        return size;
-    }
-
-    private int multiplyFieldSize(FSCoder coder)
-    {
-        float[] values;
-        int size = 0;
-
-        if (coder.context[FSCoder.TransparentColors] != 0)
-            values = new float[] { multiplyRed, multiplyGreen, multiplyBlue, multiplyAlpha };
-        else
-            values = new float[] { multiplyRed, multiplyGreen, multiplyBlue };
-
-        size = FSCoder.fixedShortSize(values);
-        
-        return size;
-    }
-
-    private int fieldSize(FSCoder coder)
-    {
-        boolean containsMultiplyTerms = containsMultiplyTerms(coder);
-        boolean containsAddTerms = containsAddTerms(coder);
-        int numberOfBits = 0;
-
-        if (containsAddTerms &amp;&amp; !containsMultiplyTerms)
-            numberOfBits = addFieldSize(coder);
-        else if (!containsAddTerms &amp;&amp; containsMultiplyTerms)
-            numberOfBits = multiplyFieldSize(coder);
-        else if (containsAddTerms &amp;&amp; containsMultiplyTerms)
-            numberOfBits = Math.max(addFieldSize(coder), multiplyFieldSize(coder));
-        else
-            numberOfBits = 1;
-
-        return numberOfBits;
-    }    
+		return numberOfBits;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSCoordTransform.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCoordTransform.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSCoordTransform.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,518 +31,634 @@
 package com.flagstone.transform;
 
 /**
-FSCoordTransform is used to specify two-dimensional coordinate transforms, allowing an 
-object to be scaled, rotated or moved without changing the original definition of how 
-the object is drawn.
- 
-&lt;p&gt;A two-dimensional transform is defined using a 3x3 matrix and the new values for a pair of coordinates (x,y) are calculated using the following matrix multiplication:&lt;/p&gt;
+ * FSCoordTransform is used to specify two-dimensional coordinate transforms,
+ * allowing an object to be scaled, rotated or moved without changing the
+ * original definition of how the object is drawn.
+ * 
+ * &lt;p&gt;
+ * A two-dimensional transform is defined using a 3x3 matrix and the new values
+ * for a pair of coordinates (x,y) are calculated using the following matrix
+ * multiplication:
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/transform.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * Different transformations such as scaling, rotation, shearing and translation
+ * can be performed using the above matrix multiplication. More complex
+ * transformations can be defined by performing successive matrix
+ * multiplications in a process known as compositing. This allows a complex
+ * transformations to performed on an object.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform contains a 3x3 array for defining the transformations.
+ * However when it is encoded the matrix is reduced to the following set
+ * attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;scaleX&lt;/td&gt;
+ * &lt;td&gt;The value to scale the shape in the x direction combined with the cosine
+ * component of any rotation.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;scaleY&lt;/td&gt;
+ * &lt;td&gt;The value to scale the shape in the x direction combined with the cosine
+ * component of any rotation.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;rotate0&lt;/td&gt;
+ * &lt;td&gt;The sine component of any rotation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;rotate1&lt;/td&gt;
+ * &lt;td&gt;The negative sine component of any rotation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;translateX&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of any translation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;translateY&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of any translation applied to the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h2 class=&quot;datasheet&quot;&gt;Examples&lt;/h2&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform provides a set of methods for generating the matrices
+ * that will perform specific transformations. Methods are provided that
+ * represent matrices for performing translation, scaling, rotation and shearing
+ * transformations.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform = new FSCoordTransform();
+ * 
+ * transform.scale(2.0, 2.0); // scale(x,y)
+ * transform.rotate(30.0); // rotate(degrees)
+ * transform.shear(1.2, 0.9); // shear(x, y)
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The composite method can be used to multiply two matrices together to create
+ * complex transformations though successive compositing steps. For example to
+ * place a new object on the screen first rotating it by 30 degrees and scaling
+ * it to twice its original size the required transform can be constructed using
+ * the following steps:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSCoordTransform transform = new FSCoordTranform();
+ * 
+ *  transform.scale(2.0, 2.0);
+ *  transform.rotate(30.0);
+ * 
+ *  int layer = 1;
+ *  int identifier = movie.newIdentifier();
+ * 
+ *  FSDefineShape shape = new FSDefineShape(identifier, ...);
+ * 
+ *  FSPlaceObject2 placeShape = new FSPlaceObject2(identifier, layer, transform);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Compositing transforms are not commutative, the order in which
+ * transformations are applied will affect the final result. For example
+ * consider the following pair if transforms:
+ * &lt;/p&gt;
+ * 
+ * FSCoordTransform transform = new FSCoordTransform();
+ * 
+ * transform.translate(100, 100); transform.scale(2.0, 2.0);
+ * 
+ * &lt;p&gt;
+ * The composite transform places an object at the coordinates (100,100) then
+ * scales it to twice its original size. If the transform was composited in the
+ * opposite order:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform transform = new FSCoordTransform();
+ * 
+ * transform.scale(2.0, 2.0);
+ * transform.translate(100, 100);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Then the coordinates for the object's location would also be scaled, placing
+ * the object at (200,200).
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Arbitrary coordinate transforms are created by specifying the 3 by 3 array of
+ * floating-point values in the constructor:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * float[][] matrix = new float[][] {
+ * 	{0.923f, 0.321f, 1000.0f },
+ * 	{0.868f, 0.235f, 1000.0f },
+ * 	{0.000f, 0.000f, 1.0000f } 
+ * };
+ * 
+ * FSCoordTransform transform = new FSCoordTransform(matrix);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * A constructor is also provided to handle the most common composite transform -
+ * scaling and translating an object at the same time:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform composite = new FSCoordTransform(100, 150, 2.0, 2.0);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Will place the object at the twip coordinates (100, 150) and scale the object
+ * to twice its original size.
+ * &lt;/P&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform class represents the Matrix data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSCoordTransform extends FSTransformObject
+{
+	private float[][] matrix = new float[][] {
+		{1.0f, 0.0f, 0.0f },
+		{0.0f, 1.0f, 0.0f },
+		{0.0f, 0.0f, 1.0f } 
+	};
 
-&lt;img src=&quot;doc-files/transform.gif&quot;&gt;
+	/**
+	 * Construct an FSCoordTransform object and initialise it with values
+	 * decoded from a binary encoded FSCoordTransform object.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSColor encoded as binary
+	 *            data.
+	 */
+	public FSCoordTransform(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;p&gt;Different transformations such as scaling, rotation, shearing and translation can be performed using the above matrix multiplication. More complex transformations can be defined by performing successive matrix multiplications in a process known as compositing. This allows a complex transformations to performed on an object.&lt;/p&gt;
+	/**
+	 * Constructs an FSCoordTransform object defining a unity transform. If the
+	 * transform is applied to a shape its location or appearance will not
+	 * change.
+	 */
+	public FSCoordTransform()
+	{
+	}
 
-&lt;p&gt;The FSCoordTransform contains a 3x3 array for defining the transformations. However when it is encoded the matrix is reduced to the following set attributes:&lt;/p&gt;
+	/**
+	 * Constructs an FSCoordTransform object defining a translation transform
+	 * that will change an objects location to the specified coordinates.
+	 * 
+	 * @param x
+	 *            the x-coordinate where the object will be displayed.
+	 * @param y
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSCoordTransform(int x, int y)
+	{
+		float xValue = (float) x;
+		float yValue = (float) y;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+		matrix[0][2] = xValue;
+		matrix[1][2] = yValue;
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSCoordTransform object defining translation and scaling
+	 * transforms that will change an object's location and size.
+	 * 
+	 * @param x
+	 *            the x-coordinate where the object will be displayed.
+	 * @param y
+	 *            the y-coordinate where the object will be displayed.
+	 * @param scaleX
+	 *            value to scale the object in the x direction.
+	 * @param scaleY
+	 *            value to scale the object in the y direction.
+	 */
+	public FSCoordTransform(int x, int y, double scaleX, double scaleY)
+	{
+		matrix[0][0] = (float) scaleX;
+		matrix[1][1] = (float) scaleY;
+		matrix[0][2] = (float) x;
+		matrix[1][2] = (float) y;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_0&quot;&gt;scaleX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The value to scale the shape in the x direction combined with the cosine 
-component of any rotation.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSCoordTransform object with the specified transformation
+	 * matrix.
+	 * 
+	 * @param aMatrix
+	 *            a 3x3 array of floats containing the values defining the
+	 *            transform.
+	 */
+	public FSCoordTransform(float[][] aMatrix)
+	{
+		setMatrix(aMatrix);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_1&quot;&gt;scaleY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The value to scale the shape in the x direction combined with the cosine 
-component of any rotation.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSCoordTransform object by copying an existing object.
+	 */
+	public FSCoordTransform(FSCoordTransform obj)
+	{
+		for (int i = 0; i &lt; 3; i++)
+			for (int j = 0; j &lt; 3; j++)
+				matrix[i][j] = obj.matrix[i][j];
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_2&quot;&gt;rotate0&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sine component of any rotation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the translation points of the transform.
+	 * 
+	 * @param x
+	 *            the x-coordinate where the object will be displayed.
+	 * @param y
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public void translate(int x, int y)
+	{
+		float[][] m = new float[][] {
+			{1.0f, 0.0f, (float) x },
+			{0.0f, 1.0f, (float) y },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_3&quot;&gt;rotate1&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The negative sine component of any rotation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		composite(m);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_4&quot;&gt;translateX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of any translation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the scaling factor for the transform.
+	 * 
+	 * @param x
+	 *            value to scale the object in the x direction.
+	 * @param y
+	 *            value to scale the object in the y direction.
+	 */
+	public void scale(double x, double y)
+	{
+		float[][] m = new float[][] {
+			{(float) x, 0.0f, 0.0f },
+			{0.0f, (float) y, 0.0f },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCoordTransform_5&quot;&gt;translateY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of any translation applied to the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		composite(m);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the angle which the transform will rotate an object.
+	 * 
+	 * @param angle
+	 *            value, in degrees, to rotate the object clockwise.
+	 */
+	public void rotate(double angle)
+	{
+		float[][] m = new float[][] {
+			{1.0f, 0.0f, 0.0f },
+			{0.0f, 1.0f, 0.0f },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-&lt;h2 class=&quot;datasheet&quot;&gt;Examples&lt;/h2&gt;
+		m[0][0] = (float) Math.cos(Math.toRadians(angle));
+		m[0][1] = -(float) Math.sin(Math.toRadians(angle));
+		m[1][0] = (float) Math.sin(Math.toRadians(angle));
+		m[1][1] = (float) Math.cos(Math.toRadians(angle));
 
-&lt;p&gt;The FSCoordTransform provides a set of methods for generating the matrices that will perform specific transformations. Methods are provided that represent matrices for performing translation, scaling, rotation and shearing transformations.&lt;/p&gt;
+		composite(m);
+	}
 
-&lt;pre&gt;
-FSCoordTransform = new FSCoordTransform();
+	/**
+	 * Sets the shearing factor for the transform.
+	 * 
+	 * @param x
+	 *            value to shear the object in the x direction.
+	 * @param y
+	 *            value to shear the object in the y direction.
+	 */
+	public void shear(double x, double y)
+	{
+		float[][] m = new float[][] {
+			{1.0f, (float) y, 0.0f },
+			{(float) x, 1.0f, 0.0f },
+			{0.0f, 0.0f, 1.0f } 
+		};
 
-transform.scale(2.0, 2.0); // scale(x,y)
-transform.rotate(30.0);  // rotate(degrees)
-transform.shear(1.2, 0.9);  // shear(x, y)
-&lt;/pre&gt;
+		composite(m);
+	}
 
-&lt;p&gt;The composite method can be used to multiply two matrices together to create complex transformations though successive compositing steps. For example to place a new object on the screen first rotating it by 30 degrees and scaling it to twice its original size the required transform can be constructed using the following steps:&lt;/p&gt;
+	/**
+	 * Applies the transformation to the coordinates of a point.
+	 * 
+	 * @param x
+	 *            x-coordinate of a point.
+	 * @param y
+	 *            x-coordinate of a point.
+	 * @return an array containing the transformed point.
+	 */
+	public int[] transformPoint(int x, int y)
+	{
+		float[] point = new float[] { (float) x, (float) y, 1.0f };
+		int[] result = new int[2];
 
-&lt;pre&gt;
-FSCoordTransform transform = new FSCoordTranform();
+		result[0] = (int) (matrix[0][0] * point[0] + matrix[0][1] * point[1] + matrix[0][2]
+						* point[2]);
+		result[1] = (int) (matrix[1][0] * point[0] + matrix[1][1] * point[1] + matrix[1][2]
+						* point[2]);
 
-transform.scale(2.0, 2.0);
-transform.rotate(30.0);
+		return result;
+	}
 
-int layer = 1;
-int identifier = movie.newIdentifier();
+	/**
+	 * Gets the 3 X 3 array that is used to store the transformation values.
+	 * 
+	 * @return an array, float[3][3], containing the values for the
+	 *         transformation matrix.
+	 */
+	public float[][] getMatrix()
+	{
+		return matrix;
+	}
 
-FSDefineShape shape = new FSDefineShape(identifier, ...);
+	/**
+	 * Sets the values in the 3 X 3 array that is used to store the
+	 * transformation values.
+	 * 
+	 * @param aMatrix
+	 *            a 3x3 array of floats containing the values defining the
+	 *            transform.
+	 */
+	public void setMatrix(float[][] aMatrix)
+	{
+		for (int i = 0; i &lt; 3; i++)
+			for (int j = 0; j &lt; 3; j++)
+				matrix[i][j] = aMatrix[i][j];
+	}
 
-FSPlaceObject2 placeShape = new FSPlaceObject2(identifier, layer, transform);
-&lt;/pre&gt;
+	/**
+	 * Composite the 3 X 3 matrix with the FSCoordTransform argument. This
+	 * method is used to create multiple transformation effects that can be
+	 * applied to an object in a single step. Using the instance method fixes
+	 * the order in which the transforms are composited. Since matrix
+	 * multiplication is not commutative this limits the number of complex
+	 * transforms that can be generated when compared to the class method.
+	 * 
+	 * @param transform
+	 *            an FSCoordTransform object to composite with this instance.
+	 */
+	public void composite(FSCoordTransform transform)
+	{
+		composite(transform.getMatrix());
+	}
 
-&lt;p&gt;Compositing transforms are not commutative, the order in which transformations are applied will affect the final result. For example consider the following pair if transforms:&lt;/p&gt;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-FSCoordTransform transform = new FSCoordTransform();
+		if (super.equals(anObject))
+		{
+			FSCoordTransform typedObject = (FSCoordTransform) anObject;
+			float m[][] = typedObject.matrix;
 
-transform.translate(100, 100);
-transform.scale(2.0, 2.0);
+			result = true;
 
-&lt;p&gt;The composite transform places an object at the coordinates (100,100) then scales it to twice its original size. If the transform was composited in the opposite order:&lt;/p&gt;
+			for (int i = 0; i &lt; 3; i++)
+				for (int j = 0; j &lt; 3; j++)
+					if (matrix[i][j] != m[i][j])
+						result = false;
+		}
+		return result;
+	}
 
-&lt;pre&gt;
-FSCoordTransform transform = new FSCoordTransform();
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-transform.scale(2.0, 2.0);
-transform.translate(100, 100);
-&lt;/pre&gt;     
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			buffer.append(&quot;[ &quot;);
+			buffer.append(&quot;[&quot; + matrix[0][0] + &quot;, &quot; + matrix[0][1] + &quot;, &quot;
+							+ matrix[0][2] + &quot;], &quot;);
+			buffer.append(&quot;[&quot; + matrix[1][0] + &quot;, &quot; + matrix[1][1] + &quot;, &quot;
+							+ matrix[1][2] + &quot;], &quot;);
+			buffer.append(&quot;[&quot; + matrix[2][0] + &quot;, &quot; + matrix[2][1] + &quot;, &quot;
+							+ matrix[2][2] + &quot;] &quot;);
+			buffer.append(&quot;]; &quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;Then the coordinates for the object's location would also be scaled, placing the object at (200,200).&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 7 + translateFieldSize() * 2;
 
-&lt;p&gt;Arbitrary coordinate transforms are created by specifying the 3 by 3 array of floating-point values in the constructor:&lt;/p&gt;
+		if (containsScaling())
+			numberOfBits += 5 + scaleFieldSize() * 2;
 
-&lt;pre&gt;
-float[][] matrix = new float[][] {
-    {0.923f, 0.321f, 1000.0f}, 
-    {0.868f, 0.235f, 1000.0f}, 
-    {0.000f, 0.000f, 1.0000f}
-};
+		if (containsRotation())
+			numberOfBits += 5 + rotateFieldSize() * 2;
 
-FSCoordTransform transform = new FSCoordTransform(matrix);
-&lt;/pre&gt;
+		numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
 
-&lt;p&gt;A constructor is also provided to handle the most common composite transform - scaling and translating an object at the same time:&lt;/p&gt;
+		return numberOfBits &gt;&gt; 3;
+	}
 
-&lt;pre&gt;
-FSCoordTransform composite = new FSCoordTransform(100, 150, 2.0, 2.0);
-&lt;/pre&gt;
+	public void encode(FSCoder coder)
+	{
+		int translateBits = translateFieldSize();
 
-&lt;p&gt;Will place the object at the twip coordinates (100, 150) and scale the object to twice its original size.&lt;/P&gt;
+		coder.alignToByte();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		coder.writeBits(containsScaling() ? 1 : 0, 1);
 
-&lt;p&gt;The FSCoordTransform class represents the Matrix data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSCoordTransform extends FSTransformObject
-{
-    private float[][] matrix = new float[][] { 
-        {1.0f, 0.0f, 0.0f}, 
-        {0.0f, 1.0f, 0.0f}, 
-        {0.0f, 0.0f, 1.0f} 
-    };
+		if (containsScaling())
+		{
+			int scaleBits = scaleFieldSize();
 
-    /**
-     * Construct an FSCoordTransform object and initialize it with values decoded 
-     * from a binary encoded FSCoordTransform object.
-     * 
-     * @param coder an FSCoder object containing an FSColor encoded as binary
-     * data.
-     */
-    public FSCoordTransform(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSCoordTransform object defining a unity transform. If the 
-     * transform is applied to a shape its location or appearance will not change.
-     */
-    public FSCoordTransform()
-    {
-    }  
-    /** 
-     * Constructs an FSCoordTransform object defining a translation transform 
-     * that will change an objects location to the specified coordinates. 
-     * 
-     * @param x the x-coordinate where the object will be displayed.
-     * @param y the y-coordinate where the object will be displayed.
-     */
-    public FSCoordTransform(int x, int y)
-    {
-        float xValue = (float)x;
-        float yValue = (float)y;
+			coder.writeBits(scaleBits, 5);
+			coder.writeFixedBits(matrix[0][0], scaleBits, 16);
+			coder.writeFixedBits(matrix[1][1], scaleBits, 16);
+		}
 
-        matrix[0][2] = xValue;
-        matrix[1][2] = yValue;
-    }
-    /** 
-     * Constructs an FSCoordTransform object defining translation and scaling transforms
-     * that will change an object's location and size.
-    
-        @param x the x-coordinate where the object will be displayed.
-        @param y the y-coordinate where the object will be displayed.
-        @param scaleX value to scale the object in the x direction.
-        @param scaleY value to scale the object in the y direction.
-        */
-    public FSCoordTransform(int x, int y, double scaleX, double scaleY)
-    {
-        matrix[0][0] = (float)scaleX;
-        matrix[1][1] = (float)scaleY;
-        matrix[0][2] = (float)x;
-        matrix[1][2] = (float)y;
-    }
+		coder.writeBits(containsRotation() ? 1 : 0, 1);
 
-    /** Constructs an FSCoordTransform object with the specified transformation matrix.
-    
-        @param aMatrix a 3x3 array of floats containing the values defining the transform.
-        */
-    public FSCoordTransform(float[][] aMatrix)
-    {
-        setMatrix(aMatrix);
-    }
-    /**
-     * Construct an FSCoordTransform object by copying an existing object.
-     */
-    public FSCoordTransform(FSCoordTransform obj)
-    {
-        for(int i=0; i&lt;3; i++)
-            for (int j = 0; j&lt;3; j++)
-                matrix[i][j] = obj.matrix[i][j];
-    }
-    
-    /** Sets the translation points of the transform.
-     * 
-     * @param x the x-coordinate where the object will be displayed.
-     * @param y the y-coordinate where the object will be displayed.
-     */
-    public void translate(int x, int y)
-    {
-        float[][] m = new float[][] { 
-            {1.0f, 0.0f, (float)x}, 
-            {0.0f, 1.0f, (float)y}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        composite(m);
-    }
+		if (containsRotation())
+		{
+			int rotateBits = rotateFieldSize();
 
-    /** Sets the scaling factor for the transform.
-     * 
-     * @param x value to scale the object in the x direction.
-     * @param y value to scale the object in the y direction.
-     */
-    public void scale(double x, double y)
-    {
-        float[][] m = new float[][] { 
-            {(float)x, 0.0f, 0.0f}, 
-            {0.0f, (float)y, 0.0f}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        composite(m);
-    }
+			coder.writeBits(rotateBits, 5);
+			coder.writeFixedBits(matrix[1][0], rotateBits, 16);
+			coder.writeFixedBits(matrix[0][1], rotateBits, 16);
+		}
+		coder.writeBits(translateBits, 5);
+		coder.writeBits((int) matrix[0][2], translateBits);
+		coder.writeBits((int) matrix[1][2], translateBits);
 
-    /** Sets the angle which the transform will rotate an object.
-     * 
-     * @param angle value, in degrees, to rotate the object clockwise.
-     */
-    public void rotate(double angle)
-    {
-        float[][] m = new float[][] { 
-            {1.0f, 0.0f, 0.0f}, 
-            {0.0f, 1.0f, 0.0f}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        m[0][0] = (float)Math.cos(Math.toRadians(angle));
-        m[0][1] = -(float)Math.sin(Math.toRadians(angle));
-        m[1][0] = (float)Math.sin(Math.toRadians(angle));
-        m[1][1] = (float)Math.cos(Math.toRadians(angle));
+		coder.alignToByte();
+	}
 
-        composite(m);
-    }
+	public void decode(FSCoder coder)
+	{
+		int scaleFieldSize = 0;
+		int rotateFieldSize = 0;
+		int translateFieldSize = 0;
 
-    /** Sets the shearing factor for the transform.
-     * 
-     * @param x value to shear the object in the x direction.
-     * @param y value to shear the object in the y direction.
-     */
-    public void shear(double x, double y)
-    {
-        float[][] m = new float[][] { 
-            {1.0f, (float)y, 0.0f}, 
-            {(float)x, 1.0f, 0.0f}, 
-            {0.0f, 0.0f, 1.0f}
-        };
-        
-        composite(m);
-    }
+		coder.alignToByte();
 
-    /**
-     * Applies the transformation to the coordinates of a point.
-     * 
-     * @param x x-coordinate of a point.
-     * @param y x-coordinate of a point.
-     * @return an array containing the transformed point.
-     */
-    public int[] transformPoint(int x, int y)
-    {
-        float[] point = new float[] { (float)x, (float)y, 1.0f };
-        int[] result = new int[2];
-        
-        result[0] = (int)(matrix[0][0] * point[0] +  matrix[0][1] * point[1] +  matrix[0][2] * point[2]);
-        result[1] = (int)(matrix[1][0] * point[0] +  matrix[1][1] * point[1] +  matrix[1][2] * point[2]);
-        
-        return result;
-    }
+		boolean _containsScaling = coder.readBits(1, false) != 0 ? true : false;
 
-    /** Gets the 3 X 3 array that is used to store the transformation values.
-    
-        @return an array, float[3][3], containing the values for the transformation matrix.
-        */
-    public float[][] getMatrix()
-    {
-        return matrix;
-    }
+		if (_containsScaling)
+		{
+			scaleFieldSize = coder.readBits(5, false);
+			matrix[0][0] = coder.readFixedBits(scaleFieldSize, 16);
+			matrix[1][1] = coder.readFixedBits(scaleFieldSize, 16);
+		}
 
-    /** Sets the values in the 3 X 3 array that is used to store the transformation values. 
-    
-        @param aMatrix a 3x3 array of floats containing the values defining the transform.
-        */
-    public void setMatrix(float[][] aMatrix)
-    {
-        for(int i=0; i&lt;3; i++)
-            for (int j = 0; j&lt;3; j++)
-                matrix[i][j] = aMatrix[i][j];
-    }
+		boolean _containsRotation = coder.readBits(1, false) != 0 ? true
+						: false;
 
-    /** Composite the 3 X 3 matrix with the FSCoordTransform argument. This method is used to create multiple transformation effects that can be applied to an object in a single step. Using the instance method fixes the order in which the transforms are composited. Since matrix multiplication is not commutative this limits the number of complex transforms that can be generated when compared to the class method.
+		if (_containsRotation)
+		{
+			rotateFieldSize = coder.readBits(5, false);
+			matrix[1][0] = coder.readFixedBits(rotateFieldSize, 16);
+			matrix[0][1] = coder.readFixedBits(rotateFieldSize, 16);
+		}
 
-        @param transform an FSCoordTransform object to composite with this instance.
-        */
-    public void composite(FSCoordTransform transform)
-    {
-        composite(transform.getMatrix());
-    }
+		translateFieldSize = coder.readBits(5, false);
+		matrix[0][2] = (float) coder.readBits(translateFieldSize, true);
+		matrix[1][2] = (float) coder.readBits(translateFieldSize, true);
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSCoordTransform typedObject = (FSCoordTransform)anObject;
-            float m[][] = typedObject.matrix;
-            
-            result = true;
-            
-            for(int i=0; i&lt;3; i++)
-                for (int j=0; j&lt;3; j++)
-                    if (matrix[i][j] != m[i][j])
-                        result = false;
-        }
-        return result;
-    }
+		coder.alignToByte();
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	/**
+	 * Returns true if the values in the transformation matrix represent a unity
+	 * transform - one which will not change the physical appearance or location
+	 * of a shape.
+	 * 
+	 * @return true if the object represents a unity transform, false otherwise.
+	 */
+	public boolean isUnityTransform()
+	{
+		return !(containsScaling() || containsRotation() || containsTranslation());
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            buffer.append(&quot;[ &quot;);
-            buffer.append(&quot;[&quot; + matrix[0][0] + &quot;, &quot; + matrix[0][1] + &quot;, &quot; + matrix[0][2] + &quot;], &quot;);
-            buffer.append(&quot;[&quot; + matrix[1][0] + &quot;, &quot; + matrix[1][1] + &quot;, &quot; + matrix[1][2] + &quot;], &quot;);
-            buffer.append(&quot;[&quot; + matrix[2][0] + &quot;, &quot; + matrix[2][1] + &quot;, &quot; + matrix[2][2] + &quot;] &quot;);
-            buffer.append(&quot;]; &quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	private boolean containsScaling()
+	{
+		return matrix[0][0] != 1.0f || matrix[1][1] != 1.0f;
+	}
 
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 7 + translateFieldSize()*2;
-    
-        if (containsScaling())
-            numberOfBits += 5 + scaleFieldSize()*2;
-    
-        if (containsRotation())
-            numberOfBits += 5 + rotateFieldSize()*2;
-    
-        numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
-    
-        return numberOfBits&gt;&gt;3;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int translateBits = translateFieldSize();
-        
-        coder.alignToByte();
-    
-        coder.writeBits(containsScaling() ? 1 : 0, 1);
-    
-        if (containsScaling())
-        {
-            int scaleBits = scaleFieldSize();
-            
-            coder.writeBits(scaleBits, 5);
-            coder.writeFixedBits(matrix[0][0], scaleBits, 16);
-            coder.writeFixedBits(matrix[1][1], scaleBits, 16);
-        }
-    
-        coder.writeBits(containsRotation() ? 1 : 0, 1);
-    
-        if (containsRotation())
-        {
-            int rotateBits = rotateFieldSize();
-            
-            coder.writeBits(rotateBits, 5);
-            coder.writeFixedBits(matrix[1][0], rotateBits, 16);
-            coder.writeFixedBits(matrix[0][1], rotateBits, 16);
-        }
-        coder.writeBits(translateBits, 5);
-        coder.writeBits((int)matrix[0][2], translateBits);
-        coder.writeBits((int)matrix[1][2], translateBits);
-    
-        coder.alignToByte();
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int scaleFieldSize = 0;
-        int rotateFieldSize = 0;
-        int translateFieldSize = 0;
-    
-        coder.alignToByte();
+	private boolean containsRotation()
+	{
+		return matrix[1][0] != 0.0f || matrix[0][1] != 0.0f;
+	}
 
-        boolean _containsScaling = coder.readBits(1, false) != 0 ? true : false;
-            
-        if (_containsScaling)
-        {
-            scaleFieldSize = coder.readBits(5, false);
-            matrix[0][0] = coder.readFixedBits(scaleFieldSize, 16);
-            matrix[1][1] = coder.readFixedBits(scaleFieldSize, 16);
-        }
-    
-        boolean _containsRotation = coder.readBits(1, false) != 0 ? true : false;
-        
-        if (_containsRotation)
-        {
-            rotateFieldSize = coder.readBits(5, false);
-            matrix[1][0] = coder.readFixedBits(rotateFieldSize, 16);
-            matrix[0][1] = coder.readFixedBits(rotateFieldSize, 16);
-        }
-    
-        translateFieldSize = coder.readBits(5, false);
-        matrix[0][2] = (float)coder.readBits(translateFieldSize, true);
-        matrix[1][2] = (float)coder.readBits(translateFieldSize, true);
-        
-        coder.alignToByte();
-    }
+	private boolean containsTranslation()
+	{
+		return matrix[0][2] != 0.0f || matrix[1][2] != 0.0f;
+	}
 
-    /** Returns true if the values in the transformation matrix represent a unity transform - one which will not change the physical appearance or location of a shape.
+	private int scaleFieldSize()
+	{
+		int size = 0;
 
-        @return true if the object represents a unity transform, false otherwise.
-        */
-    public boolean isUnityTransform()
-    {
-        return ! (containsScaling() || containsRotation() || containsTranslation());
-    }
-    
-    private boolean containsScaling() 
-    { 
-        return matrix[0][0] != 1.0f || matrix[1][1] != 1.0f;
-    }
-     
-    private boolean containsRotation() 
-    {
-        return matrix[1][0] != 0.0f || matrix[0][1] != 0.0f;
-    } 
+		if (isUnityTransform() == false)
+			size = FSCoder.fixedSize(new float[]
+			{
+				matrix[0][0], matrix[1][1] });
 
-    private boolean containsTranslation()
-    {
-        return matrix[0][2] != 0.0f || matrix[1][2] != 0.0f;
-    }
+		return size;
+	}
 
-    private int scaleFieldSize() 
-    {
-        int size = 0;
-        
-        if (isUnityTransform() == false)
-            size = FSCoder.fixedSize(new float[] {matrix[0][0], matrix[1][1]});
-        
-        return size;
-    }
+	private int rotateFieldSize()
+	{
+		int size = FSCoder.fixedSize(new float[]
+		{
+			matrix[1][0], matrix[0][1] });
 
-    private int rotateFieldSize()
-    {
-        int size = FSCoder.fixedSize(new float[] {matrix[1][0], matrix[0][1]});
-        
-        return size;
-    }
+		return size;
+	}
 
-    private int translateFieldSize()
-    {
-        int size = 0;
-        
-        if (containsTranslation())
-            size = FSCoder.size(new int[] {(int)matrix[0][2], (int)matrix[1][2]}, true);
+	private int translateFieldSize()
+	{
+		int size = 0;
 
-        return size;
-    }
-    
-    private void composite(float[][] m)
-    {
-        float result[][] = new float[3][3];
-                   
-        result[0][0] = matrix[0][0] * m[0][0] + matrix[0][1] * m[1][0] + matrix[0][2] * m[2][0];
-        result[0][1] = matrix[0][0] * m[0][1] + matrix[0][1] * m[1][1] + matrix[0][2] * m[2][1];
-        result[0][2] = matrix[0][0] * m[0][2] + matrix[0][1] * m[1][2] + matrix[0][2] * m[2][2];
+		if (containsTranslation())
+			size = FSCoder.size(new int[]
+			{
+				(int) matrix[0][2], (int) matrix[1][2] }, true);
 
-        result[1][0] = matrix[1][0] * m[0][0] + matrix[1][1] * m[1][0] + matrix[1][2] * m[2][0];
-        result[1][1] = matrix[1][0] * m[0][1] + matrix[1][1] * m[1][1] + matrix[1][2] * m[2][1];
-        result[1][2] = matrix[1][0] * m[0][2] + matrix[1][1] * m[1][2] + matrix[1][2] * m[2][2];
+		return size;
+	}
 
-        result[2][0] = matrix[2][0] * m[0][0] + matrix[2][1] * m[1][0] + matrix[2][2] * m[2][0];
-        result[2][1] = matrix[2][0] * m[0][1] + matrix[2][1] * m[1][1] + matrix[2][2] * m[2][1];
-        result[2][2] = matrix[2][0] * m[0][2] + matrix[2][1] * m[1][2] + matrix[2][2] * m[2][2];
-       
-        matrix[0][0] = result[0][0];
-        matrix[0][1] = result[0][1];
-        matrix[0][2] = result[0][2];
+	private void composite(float[][] m)
+	{
+		float result[][] = new float[3][3];
 
-        matrix[1][0] = result[1][0];
-        matrix[1][1] = result[1][1];
-        matrix[1][2] = result[1][2];
+		result[0][0] = matrix[0][0] * m[0][0] + matrix[0][1] * m[1][0]
+						+ matrix[0][2] * m[2][0];
+		result[0][1] = matrix[0][0] * m[0][1] + matrix[0][1] * m[1][1]
+						+ matrix[0][2] * m[2][1];
+		result[0][2] = matrix[0][0] * m[0][2] + matrix[0][1] * m[1][2]
+						+ matrix[0][2] * m[2][2];
 
-        matrix[2][0] = result[2][0];
-        matrix[2][1] = result[2][1];
-        matrix[2][2] = result[2][2];
-    }
+		result[1][0] = matrix[1][0] * m[0][0] + matrix[1][1] * m[1][0]
+						+ matrix[1][2] * m[2][0];
+		result[1][1] = matrix[1][0] * m[0][1] + matrix[1][1] * m[1][1]
+						+ matrix[1][2] * m[2][1];
+		result[1][2] = matrix[1][0] * m[0][2] + matrix[1][1] * m[1][2]
+						+ matrix[1][2] * m[2][2];
+
+		result[2][0] = matrix[2][0] * m[0][0] + matrix[2][1] * m[1][0]
+						+ matrix[2][2] * m[2][0];
+		result[2][1] = matrix[2][0] * m[0][1] + matrix[2][1] * m[1][1]
+						+ matrix[2][2] * m[2][1];
+		result[2][2] = matrix[2][0] * m[0][2] + matrix[2][1] * m[1][2]
+						+ matrix[2][2] * m[2][2];
+
+		matrix[0][0] = result[0][0];
+		matrix[0][1] = result[0][1];
+		matrix[0][2] = result[0][2];
+
+		matrix[1][0] = result[1][0];
+		matrix[1][1] = result[1][1];
+		matrix[1][2] = result[1][2];
+
+		matrix[2][0] = result[2][0];
+		matrix[2][1] = result[2][1];
+		matrix[2][2] = result[2][2];
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSCurve.java
===================================================================
--- trunk/src/com/flagstone/transform/FSCurve.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSCurve.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,289 +31,348 @@
 package com.flagstone.transform;
 
 /**
-FSCurve is used to define a curve. Curved lines are constructed using a Quadratic Bezier curve.
+ * FSCurve is used to define a curve. Curved lines are constructed using a
+ * Quadratic Bezier curve.
+ * 
+ * &lt;p&gt;
+ * The curve is specified using two points relative to the current drawing
+ * position, an off-curve control point and an on-curve anchor point which
+ * defines the end-point of the curve.
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/quadratic.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * To define a curve the points are defined as pairs of relative coordinates.
+ * The control point is specified relative to the current drawing point and the
+ * anchor point is specified relative to the control point. Once the line is
+ * drawn, the anchor point becomes the current drawing point.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;controlX&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of the control point relative to the current drawing
+ * point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;controlY&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of the control point relative to the current drawing
+ * point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;anchorX&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of the anchor point relative to the control point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;anchorY&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of the anchor point relative to the control point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The relative coordinates are specified in twips (where 20 twips = 1 pixel)
+ * and must be in the range -65536..65535.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Flash does not directly support Cubic Bezier curves. Converting a Cubic
+ * Bezier curve to a Quadratic curve is a non trivial process, however the
+ * FSShapeConstructor class in the Transform Utilities framework contains an
+ * algorithm to perform the conversion simplifying the create of Shape outlines
+ * in Flash from other graphics formats.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCurve class represents the CurvedEdge record from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSCurve extends FSTransformObject
+{
+	private int controlX = 0;
+	private int controlY = 0;
+	private int anchorX = 0;
+	private int anchorY = 0;
 
-&lt;p&gt;The curve is specified using two points relative to the current drawing position, an off-curve control point and an on-curve anchor point which defines the end-point of the curve.&lt;/p&gt;
+	/**
+	 * Construct an FSCurve object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSCurve(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;img src=&quot;doc-files/quadratic.gif&quot;&gt;
+	/**
+	 * Constructs an FSCurve object specifying the anchor and control point
+	 * coordinates - specified in twips.
+	 * 
+	 * @param cx
+	 *            the x-coordinate of the control point, specified relative to
+	 *            the current drawing point.
+	 * @param cy
+	 *            the y-coordinate of the control point, specified relative to
+	 *            the current drawing point.
+	 * @param ax
+	 *            the x-coordinate of the anchor point, specified relative to
+	 *            the control point.
+	 * @param ay
+	 *            the y-coordinate of the anchor point, specified relative to
+	 *            the control point.
+	 */
+	public FSCurve(int cx, int cy, int ax, int ay)
+	{
+		setControlX(cx);
+		setControlY(cy);
+		setAnchorX(ax);
+		setAnchorY(ay);
+	}
 
-&lt;p&gt;To define a curve the points are defined as pairs of relative coordinates. The control point is specified relative to the current drawing point and the anchor point is specified relative to the control point. Once the line is drawn, the anchor point becomes the current drawing point.&lt;/p&gt;
+	/**
+	 * Constructs an FSCurve object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSCurve object.
+	 */
+	public FSCurve(FSCurve obj)
+	{
+		controlX = obj.controlX;
+		controlY = obj.controlY;
+		anchorX = obj.anchorX;
+		anchorY = obj.anchorY;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Gets the x-coordinate of the control point relative to the current
+	 * drawing point.
+	 * 
+	 * @return the x-coordinate of the control point.
+	 */
+	public int getControlX()
+	{
+		return controlX;
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Gets the y-coordinate of the control point relative to the current
+	 * drawing point.
+	 * 
+	 * @return the y-coordinate of the control point.
+	 */
+	public int getControlY()
+	{
+		return controlY;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCurve_0&quot;&gt;controlX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of the control point relative to the current drawing point.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the x-coordinate of the anchor point relative to the control point.
+	 * 
+	 * @return the x-coordinate of the anchor point.
+	 */
+	public int getAnchorX()
+	{
+		return anchorX;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCurve_1&quot;&gt;controlY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of the control point relative to the current drawing point.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the y-coordinate of the anchor point relative to the control point.
+	 * 
+	 * @return the y-coordinate of the anchor point.
+	 */
+	public int getAnchorY()
+	{
+		return anchorY;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCurve_2&quot;&gt;anchorX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of the anchor point relative to the control point.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the x-coordinate of the control point relative to the current
+	 * drawing point.
+	 * 
+	 * @param cx
+	 *            the x-coordinate of the control point.
+	 */
+	public void setControlX(int cx)
+	{
+		controlX = cx;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSCurve_3&quot;&gt;anchorY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of the anchor point relative to the control point.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the y-coordinate of the control point relative to the current
+	 * drawing point.
+	 * 
+	 * @param cy
+	 *            the y-coordinate of the control point.
+	 */
+	public void setControlY(int cy)
+	{
+		controlY = cy;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the x-coordinate of the anchor point relative to the control point.
+	 * 
+	 * @param ax
+	 *            the x-coordinate of the anchor point.
+	 */
+	public void setAnchorX(int ax)
+	{
+		anchorX = ax;
+	}
 
-&lt;p&gt;The relative coordinates are specified in twips (where 20 twips = 1 pixel) and must be in the range -65536..65535.&lt;/p&gt;
+	/**
+	 * Sets the y-coordinate of the anchor point relative to the control point.
+	 * 
+	 * @param ay
+	 *            the y-coordinate of the anchor point.
+	 */
+	public void setAnchorY(int ay)
+	{
+		anchorY = ay;
+	}
 
-&lt;p&gt;Flash does not directly support Cubic Bezier curves. Converting a Cubic Bezier curve to a Quadratic curve is a non trivial process, however the FSShapeConstructor class in the Transform Utilities framework contains an algorithm to perform the conversion simplifying the create of Shape outlines in Flash from other graphics formats.&lt;/p&gt;
+	/**
+	 * Sets the x and y coordinates of control point, relative to the current
+	 * drawing point.
+	 * 
+	 * @param cx
+	 *            the x-coordinate of the control point.
+	 * @param cy
+	 *            the y-coordinate of the control point.
+	 */
+	public void setControl(int cx, int cy)
+	{
+		setControlX(cx);
+		setControlY(cy);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the x and y coordinates of anchor point relative to the control
+	 * point.
+	 * 
+	 * @param ax
+	 *            the x-coordinate of the anchor point.
+	 * @param ay
+	 *            the y-coordinate of the anchor point.
+	 */
+	public void setAnchor(int ax, int ay)
+	{
+		setAnchorX(ax);
+		setAnchorY(ay);
+	}
 
-&lt;p&gt;The FSCurve class represents the CurvedEdge record from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
+	/**
+	 * Sets the x and y coordinates of the control and anchor points.
+	 * 
+	 * @param cx
+	 *            the x-coordinate of the control point.
+	 * @param cy
+	 *            the y-coordinate of the control point.
+	 * @param ax
+	 *            the x-coordinate of the anchor point.
+	 * @param ay
+	 *            the y-coordinate of the anchor point.
+	 */
+	public void setPoints(int cx, int cy, int ax, int ay)
+	{
+		setControlX(cx);
+		setControlY(cy);
+		setAnchorX(ax);
+		setAnchorY(ay);
+	}
 
- */
-public class FSCurve extends FSTransformObject
-{
-    private int controlX = 0;
-    private int controlY = 0;
-    private int anchorX = 0;
-    private int anchorY = 0;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Construct an FSCurve object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSCurve(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSCurve object specifying the anchor and control point 
-     * coordinates - specified in twips. 
-    
-        @param cx the x-coordinate of the control point, specified relative to the current drawing point.
-        @param cy the y-coordinate of the control point, specified relative to the current drawing point.
-        @param ax the x-coordinate of the anchor point, specified relative to the control point.
-        @param ay the y-coordinate of the anchor point, specified relative to the control point.
-        */
-    public FSCurve(int cx, int cy, int ax, int ay)
-    {
-        setControlX(cx);
-        setControlY(cy);
-        setAnchorX(ax);
-        setAnchorY(ay);
-    }
-    /**
-     * Constructs an FSCurve object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSCurve object.
-     */
-    public FSCurve(FSCurve obj)
-    {
-        controlX = obj.controlX;
-        controlY = obj.controlY;
-        anchorX = obj.anchorX;
-        anchorY = obj.anchorY;
-    }    
+		if (super.equals(anObject))
+		{
+			FSCurve typedObject = (FSCurve) anObject;
 
-    /** Gets the x-coordinate of the control point relative to the current 
-     * drawing point.  
+			result = controlX == typedObject.controlX;
+			result = result &amp;&amp; controlY == typedObject.controlY;
+			result = result &amp;&amp; anchorX == typedObject.anchorX;
+			result = result &amp;&amp; anchorY == typedObject.anchorY;
+		}
+		return result;
+	}
 
-        @return the x-coordinate of the control point.
-        */
-    public int getControlX() 
-    { 
-        return controlX;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the y-coordinate of the control point relative to the current 
-     * drawing point. 
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;controlX&quot;, controlX);
+			Transform.append(buffer, &quot;controlY&quot;, controlY);
+			Transform.append(buffer, &quot;anchorX&quot;, anchorX);
+			Transform.append(buffer, &quot;anchorY&quot;, anchorY);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the y-coordinate of the control point.
-        */
-    public int getControlY()
-    {
-        return controlY;
-    }
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 6;
 
-    /** Gets the x-coordinate of the anchor point relative to the control 
-     * point.
+		int _fieldSize = FSCoder.size(new int[]
+		{
+			controlX, controlY, anchorX, anchorY, 1 }, true);
 
-        @return the x-coordinate of the anchor point.
-        */
-    public int getAnchorX() 
-    {
-        return anchorX;
-    }
+		numberOfBits += _fieldSize * 4;
 
-    /** Gets the y-coordinate of the anchor point relative to the control 
-     * point.
+		coder.context[FSCoder.NumberOfShapeBits] += numberOfBits;
 
-        @return the y-coordinate of the anchor point.
-        */
-    public int getAnchorY()
-    {
-        return anchorY;
-    }
+		return numberOfBits;
+	}
 
-    /** Sets the x-coordinate of the control point relative to the current 
-     * drawing point.
-    
-        @param cx the x-coordinate of the control point.
-      */
-    public void setControlX(int cx)
-    {
-        controlX = cx;
-    }
+	public void encode(FSCoder coder)
+	{
+		int _fieldSize = FSCoder.size(new int[]
+		{
+			controlX, controlY, anchorX, anchorY, 1 }, true);
 
-    /** Sets the y-coordinate of the control point relative to the current 
-     * drawing point.
-    
-        @param cy the y-coordinate of the control point.
-        */
-    public void setControlY(int cy)
-    {
-        controlY = cy;
-    }
+		coder.writeBits(1, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(_fieldSize - 2, 4);
+		coder.writeBits(controlX, _fieldSize);
+		coder.writeBits(controlY, _fieldSize);
+		coder.writeBits(anchorX, _fieldSize);
+		coder.writeBits(anchorY, _fieldSize);
+	}
 
-    /** Sets the x-coordinate of the anchor point relative to the control 
-     * point.
-    
-        @param ax the x-coordinate of the anchor point.
-       */
-    public void setAnchorX(int ax)
-    {
-        anchorX = ax;
-    }
+	public void decode(FSCoder coder)
+	{
+		int fieldSize = 0;
 
-    /** Sets the y-coordinate of the anchor point relative to the control 
-     * point.
-    
-        @param ay the y-coordinate of the anchor point.
-        */
-    public void setAnchorY(int ay)
-    {
-        anchorY = ay;
-    }
-
-    /** Sets the x and y coordinates of control point, relative to the current
-     * drawing point.
-    
-        @param cx the x-coordinate of the control point.
-        @param cy the y-coordinate of the control point.
-        */
-    public void setControl(int cx, int cy)
-    {
-        setControlX(cx);
-        setControlY(cy);
-    }
-
-    /** Sets the x and y coordinates of anchor point relative to the control
-     * point.
- 
-        @param ax the x-coordinate of the anchor point.
-        @param ay the y-coordinate of the anchor point.
-       */
-    public void setAnchor(int ax, int ay)
-    {
-        setAnchorX(ax);
-        setAnchorY(ay);
-    }
-
-    /** Sets the x and y coordinates of the control and anchor points.
-        
-        @param cx the x-coordinate of the control point.
-        @param cy the y-coordinate of the control point.
-        @param ax the x-coordinate of the anchor point.
-        @param ay the y-coordinate of the anchor point.
-        */
-    public void setPoints(int cx, int cy, int ax, int ay)
-    {
-        setControlX(cx);
-        setControlY(cy);
-        setAnchorX(ax);
-        setAnchorY(ay);
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSCurve typedObject = (FSCurve)anObject;
-            
-            result = controlX == typedObject.controlX;
-            result = result &amp;&amp; controlY == typedObject.controlY;
-            result = result &amp;&amp; anchorX == typedObject.anchorX;
-            result = result &amp;&amp; anchorY == typedObject.anchorY;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;controlX&quot;, controlX);
-            Transform.append(buffer, &quot;controlY&quot;, controlY);
-            Transform.append(buffer, &quot;anchorX&quot;, anchorX);
-            Transform.append(buffer, &quot;anchorY&quot;, anchorY);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 6;
-
-        int _fieldSize = FSCoder.size(new int[]{controlX, controlY, anchorX, anchorY, 1}, true);
-        
-        numberOfBits += _fieldSize*4;
-    
-        coder.context[FSCoder.NumberOfShapeBits] += numberOfBits;
-
-        return numberOfBits;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int _fieldSize = FSCoder.size(new int[]{controlX, controlY, anchorX, anchorY, 1}, true);
-        
-        coder.writeBits(1, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(_fieldSize-2, 4);
-        coder.writeBits(controlX, _fieldSize);
-        coder.writeBits(controlY, _fieldSize);
-        coder.writeBits(anchorX, _fieldSize);
-        coder.writeBits(anchorY, _fieldSize);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fieldSize = 0;
-        
-        /* shapeType */ coder.readBits(1, false);
-        /* edgeType */ coder.readBits(1, false);
-        fieldSize = coder.readBits(4, false) + 2;
-        controlX = coder.readBits(fieldSize, true);
-        controlY = coder.readBits(fieldSize, true);
-        anchorX = coder.readBits(fieldSize, true);
-        anchorY = coder.readBits(fieldSize, true);
-    }
+		/* shapeType */coder.readBits(1, false);
+		/* edgeType */coder.readBits(1, false);
+		fieldSize = coder.readBits(4, false) + 2;
+		controlX = coder.readBits(fieldSize, true);
+		controlY = coder.readBits(fieldSize, true);
+		anchorX = coder.readBits(fieldSize, true);
+		anchorY = coder.readBits(fieldSize, true);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineButton.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineButton.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineButton.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,455 +33,532 @@
 import java.util.*;
 
 /**
-FSDefineButton defines the appearance of a button and the actions performed when the 
-button is clicked.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSDefineButton defines the appearance of a button and the actions performed
+ * when the button is clicked.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonRecords&lt;/td&gt;
+ * &lt;td&gt;an array of FSButton objects that define the appearance of the button in
+ * each of its states. The array must contain at least one FSButton object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;an array of action objects that are executed when the button is clicked.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * A FSDefineButton object must contain at least one FSButton object. If more
+ * than one button record is defined for a given button state then each shape
+ * will be displayed by the button. The order in which the shapes are displayed
+ * is determined by the layer assigned to each FSButton object.
+ * &lt;/P&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Define a simple button that highlights itself when the mouse is move over
+ * it. No actions are performed when the button is clicked.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape normal = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape);
+ * FSDefineShape highlight = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, highlightShape);
+ * 
+ * ArrayList records = new ArrayList();
+ * ArrayList actions = new ArrayList();
+ * 
+ * records.add(new FSButton(FSButton.Up, normal.getIdentifier(), 1));
+ * records.add(new FSButton(FSButton.Over, highlight.getIdentifier(), 2));
+ * 
+ * FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records,
+ * 				actions);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Define a &quot;complex&quot; button that highlights itself when the mouse is move
+ * over it and actions are executed when the button is clicked.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape1);
+ * FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape2);
+ * FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape3);
+ * 
+ * ArrayList records = new ArrayList();
+ * records.add(new FSButton(FSButton.Up, upShape.getIdentifier(), 1));
+ * records.add(new FSButton(FSButton.Over, overShape.getIdentifier(), 2));
+ * records.add(new FSButton(FSButton.Down, downShape.getIdentifier(), 3));
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(action);
+ * actions.add(action);
+ * actions.add(action);
+ * 
+ * FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records,
+ * 				actions);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. If more than one button record is defined for a state then the layer
+ * number defines the order the shapes are displayed. This allows buttons to be
+ * &quot;reused&quot; with only the label on the button being changed.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape1);
+ * FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape2);
+ * FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape3);
+ * 
+ * // The label shape contains the &quot;text&quot; for the button. Note the text must be 
+ * // drawn as a shape.
+ * 
+ * FSDefineShape label = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				lineStyles, fillStyles, shape4);
+ * 
+ * ArrayList records = new ArrayList();
+ * 
+ * // Note that the label defined for all of the button's states. This ensures the 
+ * // label is visible at all times when the mouse is moved over the button.
+ * 
+ * records.add(FSButton(FSButton.Up, upShape.getIdentifier(), 1));
+ * records.add(FSButton(FSButton.Up, label.getIdentifier(), 2));
+ * records.add(FSButton(FSButton.Over, overShape.getIdentifier(), 3));
+ * records.add(FSButton(FSButton.Over, label.getIdentifier(), 4));
+ * records.add(FSButton(FSButton.Down, downShape.getIdentifier(), 5));
+ * records.add(FSButton(FSButton.Down, label.getIdentifier(), 6));
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(action);
+ * actions.add(action);
+ * actions.add(action);
+ * 
+ * FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records,
+ * 				actions);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineButton class represents the DefineButton structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineButton extends FSDefineObject
+{
+	private ArrayList buttonRecords = null;
+	private ArrayList actions = null;
+	private byte[] encodedActions = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineButton object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineButton(FSCoder coder)
+	{
+		super(DefineButton, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSAction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object with the identifier, button records
+	 * and actions.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param actionArray
+	 *            and array of action objects.
+	 */
+	public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray, ArrayList actionArray)
+	{
+		super(DefineButton, anIdentifier);
+		setButtonRecords(buttonRecordArray);
+		setActions(actionArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton_2&quot;&gt;buttonRecords&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an array of FSButton objects that define the appearance of the button in each of its states. The array must contain at least one FSButton object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineButton object.
+	 */
+	public FSDefineButton(FSDefineButton obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton_3&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;an array of action objects that are executed when the button is clicked.&lt;/td&gt;
-&lt;/tr&gt;
+		buttonRecords = new ArrayList();
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineButton_4&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded actions are typically generated by the parser in the Translate framework. The actions array and encodedActions cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
+			buttonRecords.add(((FSButton) i.next()).clone());
 
-&lt;/table&gt;
+		if (actions != null)
+		{
+			actions = new ArrayList();
 
-&lt;p&gt;A FSDefineButton object must contain at least one FSButton object. If more than one button record is defined for a given button state then each shape will be displayed by the button. The order in which the shapes are displayed is determined by the layer assigned to each FSButton object.&lt;/P&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Constructs an FSDefineButton object with the identifier, button records
+	 * and encoded actions.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray,
+							byte[] bytes)
+	{
+		super(DefineButton, anIdentifier);
+		setButtonRecords(buttonRecordArray);
+		setEncodedActions(bytes);
+	}
 
-&lt;p&gt;1. Define a simple button that highlights itself when the mouse is move over it. No actions are performed when the button is clicked.&lt;/p&gt;
+	/**
+	 * Adds the button record object to the array of button records.
+	 * 
+	 * @param aButtonRecord
+	 *            an FSButton object.
+	 */
+	public void add(FSButton aButtonRecord)
+	{
+		buttonRecords.add(aButtonRecord);
+	}
 
-&lt;pre&gt;
-FSDefineShape normal = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape);
-FSDefineShape highlight = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, highlightShape);
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-ArrayList records = new ArrayList();
-ArrayList actions = new ArrayList();
+	/**
+	 * Gets the array of button records defined for this button.
+	 * 
+	 * @return the array of FSButton objects defined for this button.
+	 */
+	public ArrayList getButtonRecords()
+	{
+		return buttonRecords;
+	}
 
-records.add(new FSButton(FSButton.Up, normal.getIdentifier(), 1));
-records.add(new FSButton(FSButton.Over, highlight.getIdentifier(), 2));
+	/**
+	 * Gets the array of actions that will be executed when the button is
+	 * clicked and released.
+	 * 
+	 * @return the array of action objects defined for this button.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records, actions);
-&lt;/pre&gt;
+	/**
+	 * Sets the array of button records defined for this button.
+	 * 
+	 * @param anArray
+	 *            an array of FSButton objects.
+	 */
+	public void setButtonRecords(ArrayList anArray)
+	{
+		buttonRecords = anArray;
+	}
 
-&lt;p&gt;2. Define a &quot;complex&quot; button that highlights itself when the mouse is move over it and actions are executed when the button is clicked.&lt;/p&gt;
+	/**
+	 * Sets the array of actions that will be executed when the button is
+	 * clicked and released.
+	 * 
+	 * @param anArray
+	 *            and array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-&lt;pre&gt;
-FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape1);
-FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape2);
-FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape3);
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-ArrayList records = new ArrayList();
-records.add(new FSButton(FSButton.Up, upShape.getIdentifier(), 1));
-records.add(new FSButton(FSButton.Over, overShape.getIdentifier(), 2));
-records.add(new FSButton(FSButton.Down, downShape.getIdentifier(), 3));
+	/**
+	 * Set the array of encoded actions that will be executed when the button is
+	 * clicked and released. The encoded actions are typically generated by the
+	 * classes in the Translate framework. If the object already contains an
+	 * array of actions then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-ArrayList actions = new ArrayList();
+	public Object clone()
+	{
+		FSDefineButton anObject = (FSDefineButton) super.clone();
 
-actions.add(action);
-actions.add(action);
-actions.add(action);
+		anObject.buttonRecords = new ArrayList();
 
-FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records, actions);
-&lt;/pre&gt;
+		for (Iterator i = buttonRecords.iterator(); i.hasNext();)
+			anObject.buttonRecords.add(((FSButton) i.next()).clone());
 
-&lt;p&gt;3. If more than one button record is defined for a state then the layer number defines the order the shapes are displayed. This allows buttons to be &quot;reused&quot; with only the label on the button being changed.&lt;/p&gt;
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-&lt;pre&gt;
-FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape1);
-FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape2);
-FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape3);
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
 
-// The label shape contains the &quot;text&quot; for the button. Note the text must be 
-// drawn as a shape.
+		return anObject;
+	}
 
-FSDefineShape label = new FSDefineShape(movie.newIdentifier(), bounds, lineStyles, fillStyles, shape4);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-ArrayList records = new ArrayList();
+		if (super.equals(anObject))
+		{
+			FSDefineButton typedObject = (FSDefineButton) anObject;
 
-// Note that the label defined for all of the button's states. This ensures the 
-// label is visible at all times when the mouse is moved over the button.
+			if (buttonRecords != null)
+				result = buttonRecords.equals(typedObject.buttonRecords);
+			else
+				result = buttonRecords == typedObject.buttonRecords;
 
-records.add(FSButton(FSButton.Up, upShape.getIdentifier(), 1));
-records.add(FSButton(FSButton.Up, label.getIdentifier(), 2));
-records.add(FSButton(FSButton.Over, overShape.getIdentifier(), 3));
-records.add(FSButton(FSButton.Over, label.getIdentifier(), 4));
-records.add(FSButton(FSButton.Down, downShape.getIdentifier(), 5));
-records.add(FSButton(FSButton.Down, label.getIdentifier(), 6));
+			if (actions != null)
+				result = actions.equals(typedObject.actions);
+			else
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+		}
+		return result;
+	}
 
-ArrayList actions = new ArrayList();
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-actions.add(action);
-actions.add(action);
-actions.add(action);
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;buttonRecords&quot;, buttonRecords, depth);
 
-FSDefineButton button = new FSDefineButton(movie.newIdentifier(), records, actions);
-&lt;/pre&gt;
+			if (actions != null)
+				Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			else
+				buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSDefineButton class represents the DefineButton structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineButton extends FSDefineObject
-{
-    private ArrayList buttonRecords = null;
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /**
-     * Construct an FSDefineButton object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineButton(FSCoder coder)
-    {
-        super(DefineButton, 0);
-        decode(coder);
-    }
-    /**  Constructs an FSDefineButton object with the identifier, button records and actions.
+		for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator
+						.hasNext();)
+			length += ((FSTransformObject) buttonIterator.next()).length(coder);
 
-        @param anIdentifier a unique identifier for this button.
-        @param buttonRecordArray an array of FSButton objects.
-        @param actionArray and array of action objects.
-        */
-    public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray, ArrayList actionArray)
-    {
-        super(DefineButton, anIdentifier);
-        setButtonRecords(buttonRecordArray);
-        setActions(actionArray);
-    }
-    /**
-     * Constructs an FSDefineButton object by copying values from an existing object.
-     *
-     * @param obj an FSDefineButton object.
-     */
-    public FSDefineButton(FSDefineButton obj)
-    {
-        super(obj);
-        
-        buttonRecords = new ArrayList();
-        
-        for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
-            buttonRecords.add(((FSButton)i.next()).clone());
+		length += 1;
 
-        if (actions != null)
-        {
-            actions = new ArrayList();
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-    /**  
-     * Constructs an FSDefineButton object with the identifier, button records and 
-     * encoded actions.
-     * 
-     * @param anIdentifier a unique identifier for this button.
-     * @param buttonRecordArray an array of FSButton objects.
-     * @param bytes an array of encoded action objects.
-     */
-    public FSDefineButton(int anIdentifier, ArrayList buttonRecordArray, byte[] bytes)
-    {
-        super(DefineButton, anIdentifier);
-        setButtonRecords(buttonRecordArray);
-        setEncodedActions(bytes);
-    }
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-    /** Adds the button record object to the array of button records.
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-        @param aButtonRecord an FSButton object.
-        */
-    public void add(FSButton aButtonRecord)
-    {
-        buttonRecords.add(aButtonRecord);
-    }
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-    /** Adds the action object to the array of actions.
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+		return length;
+	}
 
-    /** Gets the array of button records defined for this button.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @return the array of FSButton objects defined for this button.
-        */
-    public ArrayList getButtonRecords() { return buttonRecords; }
+		for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator
+						.hasNext();)
+			((FSTransformObject) buttonIterator.next()).encode(coder);
 
-    /** Gets the array of actions that will be executed when the button is clicked and released.
+		coder.writeWord(0, 1);
 
-        @return the array of action objects defined for this button.
-        */
-    public ArrayList getActions() 
-    { 
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+		if (actions != null)
+		{
+			FSActionObject action = null;
 
-    /** Sets the array of button records defined for this button.
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
 
-        @param anArray an array of FSButton objects.
-        */
-    public void setButtonRecords(ArrayList anArray)
-    {
-        buttonRecords = anArray;
-    }
+				int objStart = coder.getPointer();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (action.getLength() &lt;&lt; 3);
 
-    /** Sets the array of actions that will be executed when the button is clicked and released.
+				action.encode(coder);
+				coder.setPointer(next);
 
-        @param anArray and array of action objects.
-        */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions that will be executed when the button is 
-     * clicked and released. The encoded actions are typically generated by the 
-     * classes in the Translate framework. If the object already contains an 
-     * array of actions then they will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-   }
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
 
-    public Object clone()
-    {
-        FSDefineButton anObject = (FSDefineButton)super.clone();
-        
-        anObject.buttonRecords = new ArrayList();
-            
-        for (Iterator i = buttonRecords.iterator(); i.hasNext();)
-            anObject.buttonRecords.add(((FSButton)i.next()).clone());
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
 
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        
-        return anObject;
-    }
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+		coder.endObject(name());
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineButton typedObject = (FSDefineButton)anObject;
-            
-            if (buttonRecords != null)
-                result = buttonRecords.equals(typedObject.buttonRecords);
-            else
-                result = buttonRecords == typedObject.buttonRecords;
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-            if (actions != null)
-                result = actions.equals(typedObject.actions);
-            else
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+		int start = coder.getPointer() - 16;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;buttonRecords&quot;, buttonRecords, depth);
+		buttonRecords = new ArrayList();
 
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+		while (coder.scanWord(1, false) != 0)
+			buttonRecords.add(new FSButton(coder));
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.readWord(1, false); // character end
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();) 
-            length += ((FSTransformObject)buttonIterator.next()).length(coder);
+		int actionsLength = length - ((coder.getPointer() - start) &gt;&gt;&gt; 3);
 
-        length += 1;
-    
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
+			while (actionsLength &gt; 0)
+			{
+				start = coder.getPointer();
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();) 
-            ((FSTransformObject)buttonIterator.next()).encode(coder);
-
-        coder.writeWord(0, 1);
-    
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                    
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-                
-                action.encode(coder);
-                coder.setPointer(next);
-                
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-                
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
-
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        int start = coder.getPointer() - 16;
-        
-        buttonRecords = new ArrayList();
-        
-        while (coder.scanWord(1, false) != 0)
-            buttonRecords.add(new FSButton(coder));
-            
-        coder.readWord(1, false); // character end
-        
-        int actionsLength = length - ((coder.getPointer()-start) &gt;&gt;&gt; 3);
-        
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
-            
-            while (actionsLength &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                actionsLength -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[actionsLength];
-            coder.readBytes(encodedActions);
-        }
-        coder.endObject(name());
-    }
+				actions.add(FSMovie.decodeAction(coder));
+				actionsLength -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[actionsLength];
+			coder.readBytes(encodedActions);
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineButton2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineButton2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineButton2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,446 +33,541 @@
 import java.util.*;
 
 /**
-FSDefineButton2 defines the appearance and actions of push and menu buttons. 
- 
-&lt;p&gt;It provides a more sophisticated model for creating buttons:&lt;/p&gt;
+ * FSDefineButton2 defines the appearance and actions of push and menu buttons.
+ * 
+ * &lt;p&gt;
+ * It provides a more sophisticated model for creating buttons:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;Two types of button are supported, &lt;B&gt;Push&lt;/B&gt; and &lt;B&gt;Menu&lt;/B&gt;.&lt;/li&gt;
+ * &lt;li&gt;The number of events that a button can respond to is increased.&lt;/li&gt;
+ * &lt;li&gt;Actions can be executed for any button event.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * Push and Menu buttons behave slightly differently in tracking mouse movements
+ * when the button is clicked. A Push button 'captures' the mouse so if the
+ * cursor is dragged outside of the active area of the button and the mouse
+ * click is released then the Release Outside event is still sent to the button.
+ * A Menu button does not 'capture' the mouse so if the cursor is dragged out of
+ * the active area the button returns to its 'inactive' state.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonType&lt;/td&gt;
+ * &lt;td&gt;Whether the button is a Push button or a Menu button.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonRecords&lt;/td&gt;
+ * &lt;td&gt;An array of FSButton objects that describe the appearance of the button
+ * in each of its states.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;buttonEvents&lt;/td&gt;
+ * &lt;td&gt;An array of FSButtonEvent objects that define the actions that are
+ * executed for each type of button event.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSDefineButton2_5&quot;&gt;encodedEvents&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded button events can also be set. The
+ * encoded objects are typically generated by the parser in the Translate
+ * framework. The buttonEvents array and encodedEvents cannot both be valid at
+ * the same time. Accessor methods used to set either of the attributes will set
+ * the other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * An FSDefineButton2 object must contain at least one FSButton object. If more
+ * than one button record is defined for a given button state then each shape
+ * will be displayed by the button. The order in which the shapes are displayed
+ * is determined by the layer assigned to each button record.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Each FSButton object can contain an FSColorTransform object which can be used
+ * to change the colour of the shape being displayed without changing the
+ * original definition.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Actions do not need to be specified for every button event. Indeed actions do
+ * not need to be specified at all.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * 1. Define a button that highlights itself when the mouse is move over it and
+ * actions are executed when the button is clicked.
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape1);
+ * FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape2);
+ * FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape3);
+ * 
+ * ArrayList records = new ArrayList();
+ * ArrayList events = new ArrayList();
+ * 
+ * records.add(FSButtonRecord(FSButton.Up, upShape.getIdentifier(), 1));
+ * records.add(FSButtonRecord(FSButton.Over, overShape.getIdentifier(), 2));
+ * records.add(FSButtonRecord(FSButton.Down, downShape.getIdentifier(), 3));
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(action);
+ * actions.add(action);
+ * actions.add(action);
+ * 
+ * events.add(FSButtonEvent(FSButtonEvent.Press, actions));
+ * 
+ * FSDefineButton2 button = new FSDefineButton2(movie.newIdentifier(),
+ * 				FSDefineButton2.Push, records, events);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineButton2 class represents the DefineButton2 structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineButton2 extends FSDefineObject
+{
+	/**
+	 * Defines whether a FSDefineButton2 object is configured as a momentary,
+	 * push button.
+	 */
+	public static final int Push = 0;
 
-&lt;ul&gt;
-&lt;li&gt;Two types of button are supported, &lt;B&gt;Push&lt;/B&gt; and &lt;B&gt;Menu&lt;/B&gt;.&lt;/li&gt;
-&lt;li&gt;The number of events that a button can respond to is increased.&lt;/li&gt;
-&lt;li&gt;Actions can be executed for any button event.&lt;/li&gt;
-&lt;/ul&gt;
+	/** 
+	 * Defines whether a FSDefineButton2 object is configured as a menu button. 
+	 * */
+	public static final int Menu = 1;
 
-&lt;p&gt;Push and Menu buttons behave slightly differently in tracking mouse movements when the button is clicked. A Push button 'captures' the mouse so if the cursor is dragged outside of the active area of the button and the mouse click is released then the Release Outside event is still sent to the button. A Menu button does not 'capture' the mouse so if the cursor is dragged out of the active area the button returns to its 'inactive' state.&lt;/p&gt;
+	private int buttonType = Push;
+	private ArrayList buttonRecords = null;
+	private ArrayList buttonEvents = null;
+	private byte[] encodedEvents = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineButton2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineButton2(FSCoder coder)
+	{
+		super(DefineButton2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object, specifying the unique identifier,
+	 * the type of button to be created, the button records that describe the
+	 * button's appearance and the actions that are performed in response to
+	 * each button event.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonType
+	 *            the type of button - push or menu.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param buttonEventArray
+	 *            an array of FSButtonEvent objects.
+	 */
+	public FSDefineButton2(int anIdentifier, int buttonType,
+							ArrayList buttonRecordArray,
+							ArrayList buttonEventArray)
+	{
+		super(DefineButton2, anIdentifier);
+		setButtonType(buttonType);
+		setButtonRecords(buttonRecordArray);
+		setButtonEvents(buttonEventArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton object, specifying the unique identifier,
+	 * the type of button to be created, the button records that describe the
+	 * button's appearance and the encoded actions that are performed in
+	 * response to each button event.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for this button.
+	 * @param buttonType
+	 *            the type of button - push or menu.
+	 * @param buttonRecordArray
+	 *            an array of FSButton objects.
+	 * @param bytes
+	 *            an array containing the encoded FSButtonEvent objects.
+	 */
+	public FSDefineButton2(int anIdentifier, int buttonType,
+							ArrayList buttonRecordArray, byte[] bytes)
+	{
+		super(DefineButton2, anIdentifier);
+		setButtonType(buttonType);
+		setButtonRecords(buttonRecordArray);
+		setEncodedEvents(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineButton2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineButton2 object.
+	 */
+	public FSDefineButton2(FSDefineButton2 obj)
+	{
+		super(obj);
+		buttonType = obj.buttonType;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_2&quot;&gt;buttonType&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether the button is a Push button or a Menu button.&lt;/td&gt;
-&lt;/tr&gt;
+		buttonRecords = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_3&quot;&gt;buttonRecords&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSButton objects that describe the appearance of the button in each of its states.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
+			buttonRecords.add(((FSButton) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineButton2_4&quot;&gt;buttonEvents&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSButtonEvent objects that define the actions that are executed for each type of button event.&lt;/td&gt;
-&lt;/tr&gt;
+		if (buttonEvents != null)
+		{
+			buttonEvents = new ArrayList();
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineButton2_5&quot;&gt;encodedEvents&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded button events can also be set. The encoded objects are typically generated by the parser in the Translate framework. The buttonEvents array and encodedEvents cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator i = obj.buttonEvents.iterator(); i.hasNext();)
+				buttonEvents.add(((FSButtonEvent) i.next()).clone());
+		} else
+		{
+			encodedEvents = Transform.clone(obj.encodedEvents);
+		}
+	}
 
-&lt;/table&gt;
+	/**
+	 * Adds an FSButton to the array of button records.
+	 * 
+	 * @param aButton
+	 *            a button record.
+	 */
+	public void add(FSButton aButton)
+	{
+		buttonRecords.add(aButton);
+	}
 
-&lt;p&gt;An FSDefineButton2 object must contain at least one FSButton object. If more than one button record is defined for a given button state then each shape will be displayed by the button. The order in which the shapes are displayed is determined by the layer assigned to each button record.&lt;/p&gt;
+	/**
+	 * Adds a button event object to the array of button events.
+	 * 
+	 * @param aButtonEvent
+	 *            a button event.
+	 */
+	public void add(FSButtonEvent aButtonEvent)
+	{
+		if (buttonEvents == null)
+			buttonEvents = new ArrayList();
 
-&lt;p&gt;Each FSButton object can contain an FSColorTransform object which can be used to change the colour of the shape being displayed without changing the original definition.&lt;/p&gt;
+		buttonEvents.add(aButtonEvent);
+		encodedEvents = null;
+	}
 
-&lt;p&gt;Actions do not need to be specified for every button event. Indeed actions do not need to be specified at all.&lt;/p&gt;
+	/**
+	 * Gets the button type - push or menu.
+	 * 
+	 * @return the type of button.
+	 */
+	public int getButtonType()
+	{
+		return buttonType;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the array of button records defined for this button.
+	 * 
+	 * @return the array of button records.
+	 */
+	public ArrayList getButtonRecords()
+	{
+		return buttonRecords;
+	}
 
-1. Define a button that highlights itself when the mouse is move over it and actions are executed when the button is clicked.
+	/**
+	 * Gets the array of button records defined for this button.
+	 * 
+	 * @return the array of button events.
+	 */
+	public ArrayList getButtonEvents()
+	{
+		return buttonEvents;
+	}
 
-&lt;pre&gt;
-FSDefineShape upShape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape1);
-FSDefineShape overShape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape2);
-FSDefineShape downShape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape3);
+	/**
+	 * Sets the button type.
+	 * 
+	 * @param aType
+	 *            the type of button - push or menu.
+	 */
+	public void setButtonType(int aType)
+	{
+		buttonType = aType;
+	}
 
-ArrayList records = new ArrayList();
-ArrayList events = new ArrayList();
+	/**
+	 * Sets the array of button records defined for this button.
+	 * 
+	 * @param anArray
+	 *            an array of FSButtonRecord objects.
+	 */
+	public void setButtonRecords(ArrayList anArray)
+	{
+		buttonRecords = anArray;
+	}
 
-records.add(FSButtonRecord(FSButton.Up, upShape.getIdentifier(), 1));
-records.add(FSButtonRecord(FSButton.Over, overShape.getIdentifier(), 2));
-records.add(FSButtonRecord(FSButton.Down, downShape.getIdentifier(), 3));
+	/**
+	 * Sets the array of button events defined for this button. If the object
+	 * contains encodedEvents then they will be deleted.
+	 * 
+	 * @param anArray
+	 *            and array of FSButtonEvent objects.
+	 */
+	public void setButtonEvents(ArrayList anArray)
+	{
+		buttonEvents = anArray;
 
-ArrayList actions = new ArrayList();
+		if (encodedEvents != null)
+			encodedEvents = null;
+	}
 
-actions.add(action);
-actions.add(action);
-actions.add(action);
+	/**
+	 * Set the encoded button event objects generated by the classes in the
+	 * Translate framework. If the object already contains an array of button
+	 * events objects then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded button events.
+	 */
+	public void setEncodedEvents(byte[] bytes)
+	{
+		encodedEvents = bytes;
+		buttonEvents = null;
+	}
 
-events.add(FSButtonEvent(FSButtonEvent.Press, actions));
+	public Object clone()
+	{
+		FSDefineButton2 anObject = (FSDefineButton2) super.clone();
 
-FSDefineButton2 button = new FSDefineButton2(movie.newIdentifier(), FSDefineButton2.Push, records, events);
-&lt;/pre&gt;
+		anObject.buttonRecords = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		for (Iterator i = buttonRecords.iterator(); i.hasNext();)
+			anObject.buttonRecords.add(((FSButton) i.next()).clone());
 
-&lt;p&gt;The FSDefineButton2 class represents the DefineButton2 structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineButton2 extends FSDefineObject
-{
-/** Defines whether a FSDefineButton2 object is configured as a momentary, push button. */
-    public static final int Push = 0;
-    
-/** Defines whether a FSDefineButton2 object is configured as a menu button. */
-    public static final int Menu = 1;
-    
-    private int buttonType = Push;
-    private ArrayList buttonRecords = null;
-    private ArrayList buttonEvents = null;
-    private byte[] encodedEvents = null;
-    
-    /**
-     * Construct an FSDefineButton2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineButton2(FSCoder coder)
-    {
-        super(DefineButton2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineButton object, specifying the unique identifier, the type of button to be created, the button records that describe the button's appearance and the actions that are performed in response to each button event.
+		if (buttonEvents != null)
+		{
+			anObject.buttonEvents = new ArrayList();
 
-        @param anIdentifier a unique identifier for this button.
-        @param buttonType the type of button - push or menu.
-        @param buttonRecordArray an array of FSButton objects.
-        @param buttonEventArray an array of FSButtonEvent objects.
-        */
-    public FSDefineButton2(int anIdentifier, int buttonType, ArrayList buttonRecordArray, ArrayList buttonEventArray)
-    {
-        super(DefineButton2, anIdentifier);
-        setButtonType(buttonType);
-        setButtonRecords(buttonRecordArray);
-        setButtonEvents(buttonEventArray);
-    }
+			for (Iterator i = buttonEvents.iterator(); i.hasNext();)
+				anObject.buttonEvents.add(((FSButtonEvent) i.next()).clone());
+		} else
+		{
+			anObject.encodedEvents = Transform.clone(encodedEvents);
+		}
+		return anObject;
+	}
 
-    /** 
-     * Constructs an FSDefineButton object, specifying the unique identifier, the 
-     * type of button to be created, the button records that describe the button's 
-     * appearance and the encoded actions that are performed in response to each 
-     * button event.
-     * 
-     * @param anIdentifier a unique identifier for this button.
-     * @param buttonType the type of button - push or menu.
-     * @param buttonRecordArray an array of FSButton objects.
-     * @param bytes an array containing the encoded FSButtonEvent objects.
-     */
-    public FSDefineButton2(int anIdentifier, int buttonType, ArrayList buttonRecordArray, byte[] bytes)
-    {
-        super(DefineButton2, anIdentifier);
-        setButtonType(buttonType);
-        setButtonRecords(buttonRecordArray);
-        setEncodedEvents(bytes);
-    }
-    /**
-     * Constructs an FSDefineButton2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineButton2 object.
-     */
-    public FSDefineButton2(FSDefineButton2 obj)
-    {
-        super(obj);
-        buttonType = obj.buttonType;
-        
-        buttonRecords = new ArrayList();
-            
-        for (Iterator i = obj.buttonRecords.iterator(); i.hasNext();)
-            buttonRecords.add(((FSButton)i.next()).clone());
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        if (buttonEvents != null)
-        {
-            buttonEvents = new ArrayList();
-            
-            for (Iterator i = obj.buttonEvents.iterator(); i.hasNext();)
-                buttonEvents.add(((FSButtonEvent)i.next()).clone());
-        }
-        else
-        {
-            encodedEvents = Transform.clone(obj.encodedEvents);
-        }
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineButton2 typedObject = (FSDefineButton2) anObject;
 
-    /** Adds an FSButton to the array of button records.
+			result = buttonType == typedObject.buttonType;
 
-        @param aButton a button record.
-        */
-    public void add(FSButton aButton) { buttonRecords.add(aButton); }
+			if (buttonRecords != null)
+				result = result
+								&amp;&amp; buttonRecords
+												.equals(typedObject.buttonRecords);
+			else
+				result = result &amp;&amp; buttonRecords == typedObject.buttonRecords;
 
-    /** Adds a button event object to the array of button events.
+			if (buttonEvents != null)
+				result = buttonEvents.equals(typedObject.buttonEvents);
+			else
+				result = Transform.equals(encodedEvents,
+								typedObject.encodedEvents);
+		}
+		return result;
+	}
 
-        @param aButtonEvent a button event.
-        */
-    public void add(FSButtonEvent aButtonEvent) 
-    { 
-        if (buttonEvents == null)
-            buttonEvents = new ArrayList();
-            
-        buttonEvents.add(aButtonEvent); 
-        encodedEvents = null;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the button type - push or menu.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;buttonRecords&quot;, buttonRecords, depth);
 
-        @return the type of button.
-        */
-    public int getButtonType() { return buttonType; }
+			if (buttonEvents != null)
+				Transform.append(buffer, &quot;buttonEvents&quot;, buttonEvents, depth);
+			else
+				buffer.append(&quot;buttonEvents = &lt;data&gt;; &quot;);
 
-    /** Gets the array of button records defined for this button.
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the array of button records.
-        */
-    public ArrayList getButtonRecords() { return buttonRecords; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the array of button records defined for this button.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @return the array of button events.
-        */
-    public ArrayList getButtonEvents() { return buttonEvents; }
+		length += 3;
 
-    /** Sets the button type.
+		for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator
+						.hasNext();)
+			length += ((FSTransformObject) buttonIterator.next()).length(coder);
 
-        @param aType the type of button - push or menu.
-        */
-    public void setButtonType(int aType)
-    {
-        buttonType = aType;
-    }
+		length += 1;
 
-    /** Sets the array of button records defined for this button.
+		if (buttonEvents != null)
+		{
+			for (Iterator eventIterator = buttonEvents.iterator(); eventIterator
+							.hasNext();)
+			{
+				length += 2;
+				length += ((FSTransformObject) eventIterator.next())
+								.length(coder);
+			}
+		} else
+		{
+			length += encodedEvents.length;
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
 
-        @param anArray an array of FSButtonRecord objects.
-        */
-    public void setButtonRecords(ArrayList anArray)
-    {
-        buttonRecords = anArray;
-    }
+		return length;
+	}
 
-    /** 
-     * Sets the array of button events defined for this button. If the object
-     * contains encodedEvents then they will be deleted.
-     * 
-     * @param anArray and array of FSButtonEvent objects.
-     */
-    public void setButtonEvents(ArrayList anArray)
-    {
-        buttonEvents = anArray;
-        
-        if (encodedEvents != null)
-            encodedEvents = null;
-    }
+	public void encode(FSCoder coder)
+	{
+		int offsetStart = 0;
+		int offsetEnd = 0;
+		int currentCursor = 0;
 
-    /** 
-     * Set the encoded button event objects generated by the classes in the Translate 
-     * framework. If the object already contains an array of button events objects
-     * then they will be deleted.
-     * 
-     * @param bytes the array of encoded button events.
-     */
-    public void setEncodedEvents(byte[] bytes)
-    {
-        encodedEvents = bytes;
-        buttonEvents = null;
-    }
+		super.encode(coder);
 
-    public Object clone()
-    {
-        FSDefineButton2 anObject = (FSDefineButton2)super.clone();
-        
-        anObject.buttonRecords = new ArrayList();
-            
-        for (Iterator i = buttonRecords.iterator(); i.hasNext();)
-            anObject.buttonRecords.add(((FSButton)i.next()).clone());
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        if (buttonEvents != null)
-        {
-            anObject.buttonEvents = new ArrayList();
-            
-            for (Iterator i = buttonEvents.iterator(); i.hasNext();)
-                anObject.buttonEvents.add(((FSButtonEvent)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedEvents = Transform.clone(encodedEvents);
-        }
-        return anObject;
-    }
+		coder.writeWord(buttonType, 1);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineButton2 typedObject = (FSDefineButton2)anObject;
-            
-            result = buttonType == typedObject.buttonType;
+		offsetStart = coder.getPointer();
+		coder.writeWord(0, 2);
 
-            if (buttonRecords != null)
-                result = result &amp;&amp; buttonRecords.equals(typedObject.buttonRecords);
-            else
-                result = result &amp;&amp; buttonRecords == typedObject.buttonRecords;
+		for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator
+						.hasNext();)
+			((FSTransformObject) buttonIterator.next()).encode(coder);
 
-            if (buttonEvents != null)
-                result = buttonEvents.equals(typedObject.buttonEvents);
-            else
-                result = Transform.equals(encodedEvents, typedObject.encodedEvents);
-        }
-        return result;
-    }
+		coder.writeWord(0, 1);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;buttonRecords&quot;, buttonRecords, depth);
+		// Write actions offset
 
-            if (buttonEvents != null)
-                Transform.append(buffer, &quot;buttonEvents&quot;, buttonEvents, depth);
-            else
-                buffer.append(&quot;buttonEvents = &lt;data&gt;; &quot;);
+		currentCursor = coder.getPointer();
+		offsetEnd = (currentCursor - offsetStart) &gt;&gt; 3;
+		coder.setPointer(offsetStart);
+		coder.writeWord(offsetEnd, 2);
+		coder.setPointer(currentCursor);
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (buttonEvents != null)
+		{
+			for (Iterator eventIterator = buttonEvents.iterator(); eventIterator
+							.hasNext();)
+			{
+				FSButtonEvent anEvent = (FSButtonEvent) eventIterator.next();
 
-    public int length(FSCoder coder)
-    {    
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+				offsetStart = coder.getPointer();
+				coder.writeWord(anEvent.length(coder) + 2, 2);
+				anEvent.encode(coder);
+			}
+			// Write offset of zero for last Action Condition
 
-        length += 3;
-    
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();)
-            length += ((FSTransformObject)buttonIterator.next()).length(coder);
+			currentCursor = coder.getPointer();
+			coder.setPointer(offsetStart);
+			coder.writeWord(0, 2);
+			coder.setPointer(currentCursor);
+		} else
+		{
+			coder.writeBytes(encodedEvents);
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.endObject(name());
+	}
 
-        length += 1;
-    
-        if (buttonEvents != null)
-        {
-            for (Iterator eventIterator = buttonEvents.iterator(); eventIterator.hasNext();)
-            {
-                length += 2;
-                length += ((FSTransformObject)eventIterator.next()).length(coder);
-            }        
-        }
-        else
-        {
-            length += encodedEvents.length;
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int offsetStart = 0;
-        int offsetEnd = 0;
-        int currentCursor = 0;
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+	public void decode(FSCoder coder)
+	{
+		int offsetToNext = 0;
 
-        coder.writeWord(buttonType, 1);
-        
-        offsetStart = coder.getPointer();
-        coder.writeWord(0, 2);
-    
-        for (Iterator buttonIterator = buttonRecords.iterator(); buttonIterator.hasNext();) 
-            ((FSTransformObject)buttonIterator.next()).encode(coder);
-    
-        coder.writeWord(0, 1);
+		buttonEvents = new ArrayList();
 
-        // Write actions offset
-        
-        currentCursor = coder.getPointer();
-        offsetEnd = (currentCursor - offsetStart) &gt;&gt; 3;
-        coder.setPointer(offsetStart);
-        coder.writeWord(offsetEnd, 2);
-        coder.setPointer(currentCursor);
-    
-        if (buttonEvents != null)
-        {
-            for (Iterator eventIterator = buttonEvents.iterator(); eventIterator.hasNext();)
-            {
-                FSButtonEvent anEvent = (FSButtonEvent)eventIterator.next();
+		super.decode(coder);
 
-                offsetStart = coder.getPointer();
-                coder.writeWord(anEvent.length(coder) + 2, 2);
-                anEvent.encode(coder);
-            }
-            // Write offset of zero for last Action Condition
-        
-            currentCursor = coder.getPointer();
-            coder.setPointer(offsetStart);
-            coder.writeWord(0, 2);
-            coder.setPointer(currentCursor);
-        }
-        else
-        {
-            coder.writeBytes(encodedEvents);
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int offsetToNext = 0;
-        
-        buttonEvents = new ArrayList();
+		int start = coder.getPointer() - 16;
 
-        super.decode(coder);
-        
-        int start = coder.getPointer()-16;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		buttonType = coder.readWord(1, false);
+		offsetToNext = coder.readWord(2, false);
 
-        buttonType = coder.readWord(1, false);
-        offsetToNext = coder.readWord(2, false);
+		buttonRecords = new ArrayList();
 
-        buttonRecords = new ArrayList();
-        
-        while (coder.scanWord(1, false) != 0)
-            buttonRecords.add(new FSButton(coder));
-            
-        coder.readWord(1, false);
+		while (coder.scanWord(1, false) != 0)
+			buttonRecords.add(new FSButton(coder));
 
-        if (offsetToNext != 0)
-        {
-            buttonEvents = new ArrayList();
-                
-            do {
-                offsetToNext = coder.readWord(2, false);
-                
-                if (offsetToNext != 0)
-                {
-                    buttonEvents.add(new FSButtonEvent(coder, offsetToNext-2));
-                }
-                else
-                {
-                    buttonEvents.add(new FSButtonEvent(coder, length - ((coder.getPointer()-start) &gt;&gt;&gt; 3)));
-                }
-            } while (offsetToNext != 0);
+		coder.readWord(1, false);
 
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
+		if (offsetToNext != 0)
+		{
+			buttonEvents = new ArrayList();
+
+			do
+			{
+				offsetToNext = coder.readWord(2, false);
+
+				if (offsetToNext != 0)
+				{
+					buttonEvents
+									.add(new FSButtonEvent(coder,
+													offsetToNext - 2));
+				} else
+				{
+					buttonEvents.add(new FSButtonEvent(coder, length
+									- ((coder.getPointer() - start) &gt;&gt;&gt; 3)));
+				}
+			} while (offsetToNext != 0);
+
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineFont.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineFont.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,220 +33,259 @@
 import java.util.*;
 
 /**
-FSDefineFont defines the glyphs that are drawn when text characters are rendered in a particular font.
+ * FSDefineFont defines the glyphs that are drawn when text characters are
+ * rendered in a particular font.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shapes&lt;/td&gt;
+ * &lt;td&gt;An array of FSShape objects contain the sequences of FSLine, FSCurve and
+ * FSShapeStyle objects used to trace the outlines for each glyph.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * A complete definition of a font is created using the FSDefineFont object for
+ * the glyphs along with an FSFontInfo object which contains the name of the
+ * font, whether the font face is bold or italics and a table that maps
+ * character codes to the glyphs that is drawn to represent the character.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When defining a font only the glyphs used from a particular font are
+ * included. Unused glyphs can be omitted greatly reducing the amount of
+ * information that is encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;h2 class=&quot;datasheet&quot;&gt;History&lt;/h2&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineFont class represents the DefineFont structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineFont extends FSDefineObject
+{
+	private ArrayList shapes = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSCall object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineFont(FSCoder coder)
+	{
+		super(FSMovieObject.DefineFont, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineFont object setting the unique identifier for the
+	 * object and the array of glyphs used to render the characters used from
+	 * the font.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param anArray
+	 *            an array of FSShape objects that define the outlines for each
+	 *            glyph in the font.
+	 */
+	public FSDefineFont(int anIdentifier, ArrayList anArray)
+	{
+		super(FSMovieObject.DefineFont, anIdentifier);
+		setShapes(anArray);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineFont_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineFont object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineFont object.
+	 */
+	public FSDefineFont(FSDefineFont obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		shapes = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont_2&quot;&gt;shapes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSShape objects contain the sequences of FSLine, FSCurve and FSShapeStyle objects used to trace the outlines for each glyph.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.shapes.iterator(); i.hasNext();)
+			shapes.add(((FSShape) i.next()).clone());
+	}
 
-&lt;/table&gt;
+	/**
+	 * Add a shape to the array of shapes.
+	 * 
+	 * @param anObject
+	 *            a shape.
+	 */
+	public void add(FSShape anObject)
+	{
+		shapes.add(anObject);
+	}
 
-&lt;p&gt;A complete definition of a font is created using the FSDefineFont object for the glyphs along with an FSFontInfo object which contains the name of the font, whether the font face is bold or italics and a table that maps character codes to the glyphs that is drawn to represent the character.&lt;/p&gt;
+	/**
+	 * Gets the array of shapes that define the outline for each glyph.
+	 * 
+	 * @return an array of FSShape objects.
+	 */
+	public ArrayList getShapes()
+	{
+		return shapes;
+	}
 
-&lt;p&gt;When defining a font only the glyphs used from a particular font are included. Unused glyphs can be omitted greatly reducing the amount of information that is encoded.&lt;/p&gt;
+	/**
+	 * Sets the array of shapes that describe each glyph.
+	 * 
+	 * @param anArray
+	 *            an array of FSShape objects that define the outlines for each
+	 *            glyph in the font.
+	 */
+	public void setShapes(ArrayList anArray)
+	{
+		shapes = anArray;
+	}
 
-&lt;h2 class=&quot;datasheet&quot;&gt;History&lt;/h2&gt;
+	public Object clone()
+	{
+		FSDefineFont anObject = (FSDefineFont) super.clone();
 
-&lt;p&gt;The FSDefineFont class represents the DefineFont structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineFont extends FSDefineObject
-{
-    private ArrayList shapes = null;
-    
-    /**
-     * Construct an FSCall object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineFont(FSCoder coder)
-    {
-        super(FSMovieObject.DefineFont, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineFont object setting the unique identifier for the object and the array of glyphs used to render the characters used from the font.
+		anObject.shapes = new ArrayList();
 
-        @param anIdentifier the unique identifier for this object.
-        @param anArray an array of FSShape objects that define the outlines for each glyph in the font.
-        */
-    public FSDefineFont(int anIdentifier, ArrayList anArray)
-    {
-        super(FSMovieObject.DefineFont, anIdentifier);
-        setShapes(anArray);
-    }
-    /**
-     * Constructs an FSDefineFont object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineFont object.
-     */
-    public FSDefineFont(FSDefineFont obj)
-    {
-        super(obj);
+		for (Iterator i = shapes.iterator(); i.hasNext();)
+			anObject.shapes.add(((FSShape) i.next()).clone());
 
-        shapes = new ArrayList();
-        
-        for (Iterator i = obj.shapes.iterator(); i.hasNext();)
-            shapes.add(((FSShape)i.next()).clone());
-    }
+		return anObject;
+	}
 
-    /** Add a shape to the array of shapes.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anObject a shape.
-        */
-    public void add(FSShape anObject)
-    {
-        shapes.add(anObject);
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineFont typedObject = (FSDefineFont) anObject;
 
-    /**    Gets the array of shapes that define the outline for each glyph.
+			if (shapes != null)
+				result = shapes.equals(typedObject.shapes);
+			else
+				result = shapes == typedObject.shapes;
+		}
+		return result;
+	}
 
-        @return an array of FSShape objects.
-        */
-    public ArrayList getShapes() { return shapes; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the array of shapes that describe each glyph.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;shapes&quot;, shapes, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anArray an array of FSShape objects that define the outlines for each glyph in the font.
-        */
-    public void setShapes(ArrayList anArray)
-    {
-        shapes = anArray;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public Object clone()
-    {
-        FSDefineFont anObject = (FSDefineFont)super.clone();
-        
-        anObject.shapes = new ArrayList();
-            
-        for (Iterator i = shapes.iterator(); i.hasNext();)
-            anObject.shapes.add(((FSShape)i.next()).clone());
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-        return anObject;
-    }
+		length += shapes.size() * 2;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineFont typedObject = (FSDefineFont)anObject;
-            
-            if (shapes != null)
-                result = shapes.equals(typedObject.shapes);
-            else
-                result = shapes == typedObject.shapes;
-        }
-        return result;
-    }
+		for (Iterator shapeIterator = shapes.iterator(); shapeIterator
+						.hasNext();)
+			length += ((FSTransformObject) shapeIterator.next()).length(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;shapes&quot;, shapes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		return length;
+	}
 
-        length += shapes.size()*2;
-        
-        for (Iterator shapeIterator = shapes.iterator(); shapeIterator.hasNext();) 
-            length += ((FSTransformObject)shapeIterator.next()).length(coder);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		int currentLocation;
+		int offset;
 
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		int tableStart = coder.getPointer();
+		int tableEntry = tableStart;
 
-        int currentLocation;
-        int offset;
-        
-        int tableStart = coder.getPointer();
-        int tableEntry = tableStart;
-   
-        for (int i=0; i&lt;shapes.size(); i++)
-            coder.writeWord(0, 2);
+		for (int i = 0; i &lt; shapes.size(); i++)
+			coder.writeWord(0, 2);
 
-        for (Iterator i=shapes.iterator(); i.hasNext(); tableEntry += 16) 
-        {
-            currentLocation = coder.getPointer();
-            offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
-            
-            coder.setPointer(tableEntry);
-            coder.writeWord(offset, 2);
-            coder.setPointer(currentLocation);
-            
-            ((FSTransformObject)i.next()).encode(coder);
-        }
+		for (Iterator i = shapes.iterator(); i.hasNext(); tableEntry += 16)
+		{
+			currentLocation = coder.getPointer();
+			offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+			coder.setPointer(tableEntry);
+			coder.writeWord(offset, 2);
+			coder.setPointer(currentLocation);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        shapes = new ArrayList();
-        
-        super.decode(coder);
-        
-        int offsetStart = coder.getPointer();
-        int shapeCount = coder.scanWord(2, false) / 2;        
-        
-        coder.setPointer(offsetStart);
+			((FSTransformObject) i.next()).encode(coder);
+		}
 
-        int[] offset = new int[shapeCount+1];
-        
-        for (int i=0; i&lt;shapeCount; i++)
-            offset[i] = coder.readWord(2, false);
-        
-        offset[shapeCount] = length-2;
-            
-        for (int i=0; i&lt;shapeCount; i++) {
-            coder.setPointer(offsetStart+(offset[i]&lt;&lt;3));
-            
-            if (coder.context[FSCoder.DecodeGlyphs] == 1)
-                shapes.add(new FSShape(coder));
-            else   
-                shapes.add(new FSShape(coder, offset[i+1]-offset[i]));
-        }
-        
-        coder.endObject(name());
-    }
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		shapes = new ArrayList();
+
+		super.decode(coder);
+
+		int offsetStart = coder.getPointer();
+		int shapeCount = coder.scanWord(2, false) / 2;
+
+		coder.setPointer(offsetStart);
+
+		int[] offset = new int[shapeCount + 1];
+
+		for (int i = 0; i &lt; shapeCount; i++)
+			offset[i] = coder.readWord(2, false);
+
+		offset[shapeCount] = length - 2;
+
+		for (int i = 0; i &lt; shapeCount; i++)
+		{
+			coder.setPointer(offsetStart + (offset[i] &lt;&lt; 3));
+
+			if (coder.context[FSCoder.DecodeGlyphs] == 1)
+				shapes.add(new FSShape(coder));
+			else
+				shapes.add(new FSShape(coder, offset[i + 1] - offset[i]));
+		}
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineFont2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineFont2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineFont2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,911 +33,1045 @@
 import java.util.*;
 
 /**
-FSDefineFont2 defines the shapes and layout of the glyphs used in a font. 
- 
-&lt;p&gt;It extends the functionality provided by the FSDefineFont class by:&lt;/p&gt;
+ * FSDefineFont2 defines the shapes and layout of the glyphs used in a font.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by the FSDefineFont class by:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;allowing more than 65535 glyphs in a particular font.&lt;/li&gt;
+ * &lt;li&gt;including the functionality provided by the FontInfo class.&lt;/li&gt;
+ * &lt;li&gt;specifying ascent, descent and leading layout information for the font.&lt;/li&gt;
+ * &lt;li&gt;specifying advances for each glyph.&lt;/li&gt;
+ * &lt;li&gt;specifying bounding rectangles for each glyph.&lt;/li&gt;
+ * &lt;li&gt;specifying kerning pairs defining the distance between pairs of glyphs.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineFont2 class combines the attributes of the FSFontInfo and
+ * FSDefineFont classes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier for this object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encoding&lt;/td&gt;
+ * &lt;td&gt;Specifies whether the font codes are ANSI, SJIS or Unicode.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;language&lt;/td&gt;
+ * &lt;td&gt;Identifies the spoken language for the font, either FSText.Japanese,
+ * FSText.Korean, FSText.Latin, FSText.SimplifiedChinese,
+ * FSText.TraditionalChinese. This attribute is used when displaying text fields
+ * and assists in determining language-appropriate line breaks.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;italic&lt;/td&gt;
+ * &lt;td&gt;Whether the font is italicised.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Whether the font is bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;small&lt;/td&gt;
+ * &lt;td&gt;Small point size fonts will be drawn aligned to pixel boundaries to
+ * improve rendering.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shapes&lt;/td&gt;
+ * &lt;td&gt;An array of FSShape objects that define the outline for each glyph.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;codes&lt;/td&gt;
+ * &lt;td&gt;An array mapping a glyph index to a particular character code in the
+ * font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Additional layout information for the glyphs in the font can also be
+ * specified through the following set of attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;ascent&lt;/td&gt;
+ * &lt;td&gt;The maximum ascent for the font in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;descent&lt;/td&gt;
+ * &lt;td&gt;The maximum descent for the font in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;leading&lt;/td&gt;
+ * &lt;td&gt;The leading for the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;advances&lt;/td&gt;
+ * &lt;td&gt;An array of integers that define the advance for each glyph in the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;An array of FSBounds object that define the bounding rectangle for each
+ * glyph in the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;kernings&lt;/td&gt;
+ * &lt;td&gt;An array of FSKerning objects that define adjustment to the advance for
+ * particular pairs of glyphs in the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The default values for the ascent, descent and leading attributes is zero and
+ * the arrays containing the advances, bounds and kernings are empty. If the
+ * attributes all set to their default values then the layout information will
+ * not be encoded. All the values must be set and the arrays must contain the
+ * same number of entries as there are glyphs before the layout information will
+ * be encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineFont2 class represents the DefineFont2 structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2. Support for spoken languages was added in Flash 6. Support for small point
+ * size fonts was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSDefineFont2 extends FSDefineObject
+{
+	private int encoding = FSText.Unicode;
+	private boolean small = false;
+	private boolean italic = false;
+	private boolean bold = false;
+	private int language = 0;
+	private String name = &quot;&quot;;
+	private ArrayList shapes = new ArrayList();
+	private ArrayList codes = new ArrayList();
+	private int ascent = 0;
+	private int descent = 0;
+	private int leading = 0;
+	private ArrayList advances = null;
+	private ArrayList bounds = null;
+	private ArrayList kernings = null;
 
-&lt;ul&gt;
-&lt;li&gt;allowing more than 65535 glyphs in a particular font.&lt;/li&gt;
-&lt;li&gt;including the functionality provided by the FontInfo class.&lt;/li&gt;
-&lt;li&gt;specifying ascent, descent and leading layout information for the font.&lt;/li&gt;
-&lt;li&gt;specifying advances for each glyph.&lt;/li&gt;
-&lt;li&gt;specifying bounding rectangles for each glyph.&lt;/li&gt;
-&lt;li&gt;specifying kerning pairs defining the distance between pairs of glyphs.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Construct an FSDefineFont2 object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineFont2(FSCoder coder)
+	{
+		super(DefineFont2, 0);
+		decode(coder);
+	}
 
-&lt;p&gt;The FSDefineFont2 class combines the attributes of the FSFontInfo and FSDefineFont classes:&lt;/p&gt;
+	/**
+ 	 * Constructs an FSDefineFont2 object specifying only the name of the font.
+	 * 
+	 * If none of the remaining attributes are set the Flash Player will load
+	 * the font from the system on which it is running or substitute a suitable
+	 * font if the specified font cannot be found. This is particularly useful
+	 * when defining fonts that will be used to display text in
+	 * FSDefineTextField objects.
+	 * 
+	 * The font will be defined to use Unicode encoding. The flags which define
+	 * the font's face will be set to false. The arrays of glyphs which define
+	 * the shapes and the code which map the character codes to a particular
+	 * glyph will remain empty since the font is loaded from the system on which
+	 * it is displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param name
+	 *            the name of the font.
+	 */
+	public FSDefineFont2(int anIdentifier, String name)
+	{
+		super(DefineFont2, anIdentifier);
+		setName(name);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSDefineFont2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineFont2 object.
+	 */
+	public FSDefineFont2(FSDefineFont2 obj)
+	{
+		super(obj);
+		encoding = obj.encoding;
+		small = obj.small;
+		italic = obj.italic;
+		bold = obj.bold;
+		language = obj.language;
+		name = new String(obj.name);
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		shapes = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.shapes.iterator(); i.hasNext();)
+			shapes.add(((FSShape) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier for this object.&lt;/td&gt;
-&lt;/tr&gt;
+		codes = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_2&quot;&gt;encoding&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Specifies whether the font codes are ANSI, SJIS or Unicode.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.codes.iterator(); i.hasNext();)
+			codes.add(new Integer(((Integer) i.next()).intValue()));
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_3&quot;&gt;language&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the spoken language for the font, either FSText.Japanese, FSText.Korean, 
-FSText.Latin, FSText.SimplifiedChinese, FSText.TraditionalChinese. This attribute 
-is used when displaying text fields and assists in determining language-appropriate
-line breaks.&lt;/td&gt;
-&lt;/tr&gt;
+		ascent = obj.ascent;
+		descent = obj.descent;
+		leading = obj.leading;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_4&quot;&gt;italic&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether the font is italicised.&lt;/td&gt;
-&lt;/tr&gt;
+		if (advances != null)
+		{
+			advances = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_5&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether the font is bold.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator i = obj.advances.iterator(); i.hasNext();)
+				advances.add(new Integer(((Integer) i.next()).intValue()));
+		}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_6&quot;&gt;small&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Small point size fonts will be drawn aligned to pixel boundaries to improve rendering.&lt;/td&gt;
-&lt;/tr&gt;
+		if (bounds != null)
+		{
+			bounds = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_7&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of the font.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator i = obj.bounds.iterator(); i.hasNext();)
+				bounds.add(((FSBounds) i.next()).clone());
+		}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_8&quot;&gt;shapes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSShape objects that define the outline for each glyph.&lt;/td&gt;
-&lt;/tr&gt;
+		if (kernings != null)
+		{
+			kernings = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_9&quot;&gt;codes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array mapping a glyph index to a particular character code in the font.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator i = obj.kernings.iterator(); i.hasNext();)
+				kernings.add(((FSKerning) i.next()).clone());
+		}
+	}
 
-&lt;/table&gt;
+	/**
+	 * Add a shape to the array of shapes.
+	 * 
+	 * @param anObject
+	 *            a shape.
+	 */
+	public void add(FSShape anObject)
+	{
+		shapes.add(anObject);
+	}
 
-&lt;p&gt;Additional layout information for the glyphs in the font can also be specified through the following set of attributes:&lt;/p&gt;
+	/**
+	 * Add a code to the array of codes.
+	 * 
+	 * @param aCode
+	 *            a code for a glyph.
+	 */
+	public void addCode(int aCode)
+	{
+		codes.add(new Integer(aCode));
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Add an advance to the array of advances.
+	 * 
+	 * @param anAdvance
+	 *            an advance for a glyph.
+	 */
+	public void addAdvance(int anAdvance)
+	{
+		advances.add(new Integer(anAdvance));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_10&quot;&gt;ascent&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum ascent for the font in twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a bounds object to the array of bounds for each glyph.
+	 * 
+	 * @param anObject
+	 *            an FSBounds.
+	 */
+	public void add(FSBounds anObject)
+	{
+		bounds.add(anObject);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_11&quot;&gt;descent&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum descent for the font in twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a kerning object to the array of kernings for pairs of glyphs.
+	 * 
+	 * @param anObject
+	 *            an FSKerning.
+	 */
+	public void add(FSKerning anObject)
+	{
+		kernings.add(anObject);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_12&quot;&gt;leading&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The leading for the font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the encoding used for the font codes, either FSText.ASCII,
+	 * FSText.SJIS or FSText.Unicode.
+	 * 
+	 * @return the encoding used to represent characters rendered in the font.
+	 */
+	public int getEncoding()
+	{
+		return encoding;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_13&quot;&gt;advances&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of integers that define the advance for each glyph in the font.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 7
+	/**
+	 * Does the font have a small point size. This is used only with a Unicode
+	 * font encoding.
+	 * 
+	 * @return a boolean indicating whether the font will be aligned on pixel
+	 *         boundaries.
+	 */
+	public boolean isSmall()
+	{
+		return small;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_14&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSBounds object that define the bounding rectangle for each glyph in the font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the font is small. Used only with Unicode fonts.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating the font will be aligned on pixel
+	 *            boundaries.
+	 */
+	public void setSmall(boolean aBool)
+	{
+		small = aBool;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineFont2_15&quot;&gt;kernings&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSKerning objects that define adjustment to the advance for particular pairs of glyphs in the font.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	// End Flash 7
 
-&lt;p&gt;The default values for the ascent, descent and leading attributes is zero and the arrays containing the advances, bounds and kernings are empty. If the attributes all set to their default values then the layout information will not be encoded. All the values must be set and the arrays must contain the same number of entries as there are glyphs before the layout information will be encoded.&lt;/p&gt;
+	/**
+	 * Is the font italicised.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in italics.
+	 */
+	public boolean isItalic()
+	{
+		return italic;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Is the font bold.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in a bold face.
+	 */
+	public boolean isBold()
+	{
+		return bold;
+	}
 
-&lt;p&gt;The FSDefineFont2 class represents the DefineFont2 structure from the Macromedia 
-Flash (SWF) File Format Specification. It was introduced in Flash 2. Support for
-spoken languages was added in Flash 6. Support for small point size fonts was 
-added in Flash 7.&lt;/p&gt;
- */
-public class FSDefineFont2 extends FSDefineObject
-{
-    private int encoding = FSText.Unicode;
-    private boolean small = false;
-    private boolean italic = false;
-    private boolean bold = false;
-    private int language = 0;
-    private String name = &quot;&quot;;
-    private ArrayList  shapes = new ArrayList();
-    private ArrayList  codes = new ArrayList();
-    private int ascent = 0;
-    private int descent = 0;
-    private int leading = 0;
-    private ArrayList advances = null;
-    private ArrayList bounds = null;
-    private ArrayList kernings = null;
-    
-    /**
-     * Construct an FSDefineFont2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineFont2(FSCoder coder)
-    {
-        super(DefineFont2, 0);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSDefineFont2 object specifying only the name of the font. 
-     *
-     * If none of the remaining attributes are set the Flash Player will load the font from the system
-     * on which it is running or substitute a suitable font if the specified font cannot be found. This 
-     * is particularly useful when defining fonts that will be used to display text in FSDefineTextField 
-     * objects.
-     *
-     * The font will be defined to use Unicode encoding. The flags which define the font's face will be 
-     * set to false. The arrays  of glyphs which define the shapes and the code which map the character 
-     * codes to a particular glyph will remain empty since the font is loaded from the system on which 
-     * it is displayed.
-     *
-     * @param anIdentifier the unique identifier for this object.
-     * @param name the name of the font.
-     */
-    public FSDefineFont2(int anIdentifier, String name)
-    {
-        super(DefineFont2, anIdentifier);
-        setName(name);
-    }
-    /**
-     * Constructs an FSDefineFont2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineFont2 object.
-     */
-    public FSDefineFont2(FSDefineFont2 obj)
-    {
-        super(obj);
-        encoding = obj.encoding;
-        small = obj.small;
-        italic = obj.italic;
-        bold = obj.bold;
-        language = obj.language;
-        name = new String(obj.name);
-        
-        shapes = new ArrayList();
-        
-        for (Iterator i = obj.shapes.iterator(); i.hasNext();)
-            shapes.add(((FSShape)i.next()).clone());
+	// Flash 6
+	/**
+	 * Gets the language code identifying the type of spoken language for the
+	 * font either FSText.Japanese, FSText.Korean, FSText.Latin,
+	 * FSText.SimplifiedChinese or FSText.TraditionalChinese.
+	 * 
+	 * @return the language code used to determine how line-breaks are inserted
+	 *         into text rendered using the font. Returns 0 if the object was
+	 *         decoded from a movie contains Flash 5 or less.
+	 */
+	public int getLanguage()
+	{
+		return language;
+	}
 
-        codes = new ArrayList();
-            
-        for (Iterator i = obj.codes.iterator(); i.hasNext();)
-            codes.add(new Integer(((Integer)i.next()).intValue()));
+	/**
+	 * Sets the language code used to determine the position of line-breaks in
+	 * text rendered using the font.
+	 * 
+	 * NOTE: The language attribute is ignored if the object is encoded in a
+	 * Flash 5 movie.
+	 * 
+	 * @param code
+	 *            the code identifying the spoken language either
+	 *            FSText.Japanese, FSText.Korean, FSText.Latin,
+	 *            FSText.SimplifiedChinese or FSText.TraditionalChinese.
+	 */
+	public void setLanguage(int code)
+	{
+		language = code;
+	}
 
-        ascent = obj.ascent;
-        descent = obj.descent;
-        leading = obj.leading;
-        
-        if (advances != null)
-        {
-            advances = new ArrayList();
-            
-            for (Iterator i = obj.advances.iterator(); i.hasNext();)
-                advances.add(new Integer(((Integer)i.next()).intValue()));
-        }
+	// End Flash 6
 
-        if (bounds != null)
-        {
-            bounds = new ArrayList();
-            
-            for (Iterator i = obj.bounds.iterator(); i.hasNext();)
-                bounds.add(((FSBounds)i.next()).clone());
-        }
+	/**
+	 * Gets the name of the font family.
+	 * 
+	 * @return the name of the font.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-        if (kernings != null)
-        {
-            kernings = new ArrayList();
-            
-            for (Iterator i = obj.kernings.iterator(); i.hasNext();)
-                kernings.add(((FSKerning)i.next()).clone());
-        }
-    }
+	/**
+	 * Gets the array of shapes used to define the outlines of each font glyph.
+	 * 
+	 * @return an array of FSShape objects
+	 */
+	public ArrayList getShapes()
+	{
+		return shapes;
+	}
 
-    /** Add a shape to the array of shapes.
+	/**
+	 * Gets the array of codes used to identify each glyph in the font. The
+	 * ordinal position of each Integer representing a code identifies a
+	 * particular glyph in the shapes array.
+	 * 
+	 * @return an array of Integer objects that contain the character codes for
+	 *         each glyph in the font.
+	 */
+	public ArrayList getCodes()
+	{
+		return codes;
+	}
 
-        @param anObject a shape.
-        */
-    public void add(FSShape anObject) { shapes.add(anObject); }
+	/**
+	 * Gets the ascent for the font in twips.
+	 * 
+	 * @return the ascent for the font.
+	 */
+	public int getAscent()
+	{
+		return ascent;
+	}
 
-    /** Add a code to the array of codes.
+	/**
+	 * Gets the descent for the font in twips.
+	 * 
+	 * @return the descent for the font.
+	 */
+	public int getDescent()
+	{
+		return descent;
+	}
 
-        @param aCode a code for a glyph.
-        */
-    public void addCode(int aCode) { codes.add(new Integer(aCode)); }
+	/**
+	 * Gets the leading for the font in twips.
+	 * 
+	 * @return the leading for the font.
+	 */
+	public int getLeading()
+	{
+		return leading;
+	}
 
-    /** Add an advance to the array of advances.
+	/**
+	 * Gets the array of advances defined for each glyph in the font.
+	 * 
+	 * @return an array of Integer objects that contain the advance for each
+	 *         glyph in the font.
+	 */
+	public ArrayList getAdvances()
+	{
+		return advances;
+	}
 
-        @param anAdvance an advance for a glyph.
-        */
-    public void addAdvance(int anAdvance) { advances.add(new Integer(anAdvance)); }
+	/**
+	 * Gets the array of bounding rectangles defined for each glyph in the font.
+	 * 
+	 * @return an array of FSBounds objects.
+	 */
+	public ArrayList getBounds()
+	{
+		return bounds;
+	}
 
-    /** Add a bounds object to the array of bounds for each glyph.
+	/**
+	 * Gets the array of kerning records that define the spacing between glyph
+	 * pairs.
+	 * 
+	 * @return an array of FSKerning objects that define the spacing adjustment
+	 *         between pairs of glyphs.
+	 */
+	public ArrayList getKernings()
+	{
+		return kernings;
+	}
 
-        @param anObject an FSBounds.
-        */
-    public void add(FSBounds anObject) { bounds.add(anObject); }
+	/**
+	 * Sets the encoding for the font character codes.
+	 * 
+	 * @param aType
+	 *            the encoding scheme used to denote characters, either
+	 *            FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	 */
+	public void setEncoding(int aType)
+	{
+		encoding = aType;
+	}
 
-    /** Add a kerning object to the array of kernings for pairs of glyphs.
+	/**
+	 * Set the font is italicised.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            italics
+	 */
+	public void setItalic(boolean aBool)
+	{
+		italic = aBool;
+	}
 
-        @param anObject an FSKerning.
-        */
-    public void add(FSKerning anObject) { kernings.add(anObject); }
+	/**
+	 * Set the font is bold.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            bold face.
+	 */
+	public void setBold(boolean aBool)
+	{
+		bold = aBool;
+	}
 
-    /** Gets the encoding used for the font codes, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	/**
+	 * Set the name of the font.
+	 * 
+	 * @param aString
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-        @return the encoding used to represent characters rendered in the font.
-        */
-    public int getEncoding()
-    {
-        return encoding;
-    }
+	/**
+	 * Set the array of shape records that define the outlines of the characters
+	 * used from the font.
+	 * 
+	 * @param anArray
+	 *            an array of FSShape objects that define the glyphs for the
+	 *            font.
+	 */
+	public void setShapes(ArrayList anArray)
+	{
+		shapes = anArray;
+	}
 
-// Flash 7
-    /** Does the font have a small point size. This is used only with a Unicode font encoding.
-     * 
-     *  @return a boolean indicating whether the font will be aligned on pixel boundaries.
-     */
-    public boolean isSmall() 
-    {
-        return small;
-    }
+	/**
+	 * Sets the codes used to identify each glyph in the font.
+	 * 
+	 * @param anArray
+	 *            sets the code table that maps a particular glyph to a
+	 *            character code.
+	 */
+	public void setCodes(ArrayList anArray)
+	{
+		codes = anArray;
+	}
 
-    /** Sets the font is small. Used only with Unicode fonts.
-     *
-     * @param aBool a boolean flag indicating the font will be aligned on pixel boundaries.
-     */
-    public void setSmall(boolean aBool)
-    {
-        small = aBool;
-    }
-// End Flash 7
+	/**
+	 * Sets the ascent for the font in twips.
+	 * 
+	 * @param aNumber
+	 *            the ascent for the font.
+	 */
+	public void setAscent(int aNumber)
+	{
+		ascent = aNumber;
+	}
 
-    /** Is the font italicised.
+	/**
+	 * Sets the descent for the font in twips.
+	 * 
+	 * @param aNumber
+	 *            the descent for the font.
+	 */
+	public void setDescent(int aNumber)
+	{
+		descent = aNumber;
+	}
 
-        @return a boolean indicating whether the font is rendered in italics.
-        */
-    public boolean isItalic() 
-    {
-        return italic;
-    }
+	/**
+	 * Sets the leading for the font in twips.
+	 * 
+	 * @param aNumber
+	 *            the descent for the font.
+	 */
+	public void setLeading(int aNumber)
+	{
+		leading = aNumber;
+	}
 
-    /** Is the font bold.
+	/**
+	 * Sets the array of advances for each glyph in the font.
+	 * 
+	 * @param anArray
+	 *            of Integer objects that define the spacing between glyphs.
+	 */
+	public void setAdvances(ArrayList anArray)
+	{
+		advances = anArray;
+	}
 
-        @return a boolean indicating whether the font is rendered in a bold face.
-        */
-    public boolean isBold() 
-    {
-        return bold;
-    }
+	/**
+	 * Sets the array of bounding rectangles for each glyph in the font.
+	 * 
+	 * @param anArray
+	 *            an array of FSBounds objects that define the bounding
+	 *            rectangles that enclose each glyph in the font.
+	 */
+	public void setBounds(ArrayList anArray)
+	{
+		bounds = anArray;
+	}
 
-// Flash 6
-    /** Gets the language code identifying the type of spoken language for the font
-     *  either FSText.Japanese, FSText.Korean, FSText.Latin, FSText.SimplifiedChinese 
-     *  or FSText.TraditionalChinese.
-     * 
-     *  @return the language code used to determine how line-breaks are inserted 
-     *  into text rendered using the font. Returns 0 if the object was decoded 
-     *  from a movie contains Flash 5 or less.
-     */
-    public int getLanguage()
-    {
-        return language;
-    }
+	/**
+	 * Sets the array of kerning records for pairs of glyphs in the font.
+	 * 
+	 * @param anArray
+	 *            an array of FSKerning objects that define an adjustment
+	 *            applied to the spacing between pairs of glyphs.
+	 */
+	public void setKernings(ArrayList anArray)
+	{
+		kernings = anArray;
+	}
 
-    /** Sets the language code used to determine the position of line-breaks in 
-     *  text rendered using the font.
-     * 
-     *  NOTE: The language attribute is ignored if the object is encoded in a Flash 5 movie.
-     * 
-     *  @param code the code identifying the spoken language either FSText.Japanese, 
-     * FSText.Korean, FSText.Latin, FSText.SimplifiedChinese or FSText.TraditionalChinese.
-     */
-    public void setLanguage(int code)
-    {
-        language = code;
-    }
-// End Flash 6
+	public Object clone()
+	{
+		FSDefineFont2 anObject = (FSDefineFont2) super.clone();
 
-    /** Gets the name of the font family.
+		anObject.shapes = new ArrayList();
 
-        @return the name of the font.
-        */
-    public String getName()
-    {
-        return name; 
-    }
+		for (Iterator i = shapes.iterator(); i.hasNext();)
+			anObject.shapes.add(((FSShape) i.next()).clone());
 
-    /** Gets the array of shapes used to define the outlines of each font glyph.
+		anObject.codes = new ArrayList();
 
-        @return an array of FSShape objects
-        */
-    public ArrayList getShapes()
-    {
-        return shapes;
-    }
+		for (Iterator i = codes.iterator(); i.hasNext();)
+			anObject.codes.add(new Integer(((Integer) i.next()).intValue()));
 
-    /** Gets the array of codes used to identify each glyph in the font. The ordinal position of each Integer representing a code identifies a particular glyph in the shapes array.
+		if (advances != null)
+		{
+			anObject.advances = new ArrayList();
 
-        @return an array of Integer objects that contain the character codes for each glyph in the font.
-        */
-    public ArrayList getCodes()
-    {
-        return codes;
-    }
+			for (Iterator i = advances.iterator(); i.hasNext();)
+				anObject.advances.add(new Integer(((Integer) i.next())
+								.intValue()));
+		}
 
-    /** Gets the ascent for the font in twips.
+		if (bounds != null)
+		{
+			anObject.bounds = new ArrayList();
 
-        @return the ascent for the font.
-        */
-    public int getAscent()
-    {
-        return ascent;
-    }
+			for (Iterator i = bounds.iterator(); i.hasNext();)
+				anObject.bounds.add(((FSBounds) i.next()).clone());
+		}
 
-    /** Gets the descent for the font in twips.
+		if (kernings != null)
+		{
+			anObject.kernings = new ArrayList();
 
-        @return the descent for the font.
-        */
-    public int getDescent()
-    {
-        return descent;
-    }
+			for (Iterator i = kernings.iterator(); i.hasNext();)
+				anObject.kernings.add(((FSKerning) i.next()).clone());
+		}
 
-    /** Gets the leading for the font in twips.
+		return anObject;
+	}
 
-        @return the leading for the font.
-        */
-    public int getLeading()
-    {
-        return leading;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the array of advances defined for each glyph in the font.
+		if (super.equals(anObject))
+		{
+			FSDefineFont2 typedObject = (FSDefineFont2) anObject;
 
-        @return an array of Integer objects that contain the advance for each glyph in the font.
-        */
-    public ArrayList getAdvances()
-    {
-        return advances;
-    }
+			result = encoding == typedObject.encoding;
+			// Flash 7
+			result = result &amp;&amp; small == typedObject.small;
+			// End Flash 7
+			result = result &amp;&amp; italic == typedObject.italic;
+			result = result &amp;&amp; bold == typedObject.bold;
+			// Flash 6
+			result = result &amp;&amp; language == typedObject.language;
+			// End Flash 6
 
-    /** Gets the array of bounding rectangles defined for each glyph in the font.
+			if (name != null)
+				result = result &amp;&amp; name.equals(typedObject.name);
+			else
+				result = result &amp;&amp; name == typedObject.name;
 
-        @return an array of FSBounds objects.
-        */
-    public ArrayList getBounds()
-    {
-        return bounds;
-    }
+			if (shapes != null)
+				result = result &amp;&amp; shapes.equals(typedObject.shapes);
+			else
+				result = result &amp;&amp; shapes == typedObject.shapes;
 
-    /** Gets the array of kerning records that define the spacing between glyph pairs.
+			if (codes != null)
+				result = result &amp;&amp; codes.equals(typedObject.codes);
+			else
+				result = result &amp;&amp; codes == typedObject.codes;
 
-        @return an array of FSKerning objects that define the spacing adjustment between pairs of glyphs.
-        */
-    public ArrayList getKernings()
-    {
-        return kernings;
-    }
+			if (containsLayoutInfo())
+			{
+				result = result &amp;&amp; ascent == typedObject.ascent;
+				result = result &amp;&amp; descent == typedObject.descent;
+				result = result &amp;&amp; leading == typedObject.leading;
 
-    /** Sets the encoding for the font character codes.
+				if (advances != null)
+					result = result &amp;&amp; advances.equals(typedObject.advances);
+				else
+					result = result &amp;&amp; advances == typedObject.advances;
 
-        @param aType the encoding scheme used to denote characters, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
-        */
-    public void setEncoding(int aType)
-    {
-        encoding = aType;
-    }
+				if (bounds != null)
+					result = result &amp;&amp; bounds.equals(typedObject.bounds);
+				else
+					result = result &amp;&amp; bounds == typedObject.bounds;
 
-    /** Set the font is italicised.
+				if (kernings != null)
+					result = result &amp;&amp; kernings.equals(typedObject.kernings);
+				else
+					result = result &amp;&amp; kernings == typedObject.kernings;
+			}
+		}
+		return result;
+	}
 
-        @param aBool a boolean flag indicating whether the font will be rendered in italics */
-    public void setItalic(boolean aBool)
-    {
-        italic = aBool;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Set the font is bold.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;encoding&quot;, encoding);
+			// Flash 7
+			Transform.append(buffer, &quot;small&quot;, small);
+			// End Flash 7
+			Transform.append(buffer, &quot;italic&quot;, italic);
+			Transform.append(buffer, &quot;bold&quot;, bold);
+			// Flash 6
+			Transform.append(buffer, &quot;language&quot;, language);
+			// End Flash 6
+			Transform.append(buffer, &quot;name&quot;, name);
+			Transform.append(buffer, &quot;shapes&quot;, shapes, depth);
+			Transform.append(buffer, &quot;codes&quot;, codes, depth);
+			Transform.append(buffer, &quot;ascent&quot;, ascent);
+			Transform.append(buffer, &quot;descent&quot;, descent);
+			Transform.append(buffer, &quot;leading&quot;, leading);
+			Transform.append(buffer, &quot;advances&quot;, advances, depth);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;kernings&quot;, kernings, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aBool a boolean flag indicating whether the font will be rendered in bold face.
-        */
-    public void setBold(boolean aBool)
-    {
-        bold = aBool;
-    }
+	public int length(FSCoder coder)
+	{
+		boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
+		int wideCodes = 0;
 
-    /** Set the name of the font.
+		if (coder.context[FSCoder.Version] &gt; 5)
+			wideCodes = 1;
+		else
+			wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
 
-        @param aString the name assigned to the font, identifying the font family.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+		super.length(coder);
 
-    /** Set the array of shape records that define the outlines of the characters used from the font.
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = wideCodes;
+		length += 3;
+		length += coder.strlen(name, false);
+		length += 2;
+		length += shapes.size() * (wideOffsets ? 4 : 2);
+		length += wideOffsets ? 4 : 2;
 
-        @param anArray an array of FSShape objects that define the glyphs for the font.
-        */
-    public void setShapes(ArrayList anArray)
-    {
-        shapes = anArray;
-    }
+		for (Iterator shapeIterator = shapes.iterator(); shapeIterator
+						.hasNext();)
+			length += ((FSTransformObject) shapeIterator.next()).length(coder);
 
-    /** Sets the codes used to identify each glyph in the font.
+		length += shapes.size() * ((wideCodes == 1) ? 2 : 1);
 
-        @param anArray sets the code table that maps a particular glyph to a character code.
-        */
-    public void setCodes(ArrayList anArray)
-    {
-        codes = anArray;
-    }
+		if (containsLayoutInfo())
+		{
+			length += 6;
+			length += shapes.size() * 2;
 
-    /** Sets the ascent for the font in twips.
+			for (Iterator boundsIterator = bounds.iterator(); boundsIterator
+							.hasNext();)
+				length += ((FSTransformObject) boundsIterator.next())
+								.length(coder);
 
-        @param aNumber the ascent for the font.
-        */
-    public void setAscent(int aNumber)
-    {
-        ascent = aNumber;
-    }
+			length += 2;
+			length += kernings.size() * ((wideCodes == 1) ? 6 : 4);
+		}
 
-    /** Sets the descent for the font in twips.
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = 0;
 
-        @param aNumber the descent for the font.
-        */
-    public void setDescent(int aNumber)
-    {
-        descent = aNumber;
-    }
+		return length;
+	}
 
-    /** Sets the leading for the font in twips.
+	public void encode(FSCoder coder)
+	{
+		boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
+		int wideCodes = 0;
+		int format = 0;
 
-        @param aNumber the descent for the font.
-        */
-    public void setLeading(int aNumber)
-    {
-        leading = aNumber;
-    }
+		if (coder.context[FSCoder.Version] &gt; 5)
+			wideCodes = 1;
+		else
+			wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
 
-    /** Sets the array of advances for each glyph in the font.
+		if (encoding == FSText.ANSI)
+			format = 1;
+		// Flash 7
+		else if (small)
+			format = 2;
+		// End Flash 7
+		else if (encoding == FSText.SJIS)
+			format = 4;
 
-        @param anArray of Integer objects that define the spacing between glyphs.
-        */
-    public void setAdvances(ArrayList anArray)
-    {
-        advances = anArray;
-    }
+		super.encode(coder);
 
-    /** Sets the array of bounding rectangles for each glyph in the font.
+		coder.context[FSCoder.NumberOfFillBits] = 1;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = wideCodes;
 
-        @param anArray an array of FSBounds objects that define the bounding rectangles that enclose each glyph in the font.
-        */
-    public void setBounds(ArrayList anArray)
-    {
-        bounds = anArray;
-    }
+		coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
+		coder.writeBits(format, 3);
+		coder.writeBits(wideOffsets ? 1 : 0, 1);
+		coder.writeBits(wideCodes, 1);
+		coder.writeBits(italic ? 1 : 0, 1);
+		coder.writeBits(bold ? 1 : 0, 1);
+		coder.writeWord(coder.context[FSCoder.Version] &gt; 5 ? language : 0, 1);
+		coder.writeWord(coder.strlen(name, false), 1);
 
-    /** Sets the array of kerning records for pairs of glyphs in the font.
+		coder.writeString(name);
+		coder.writeWord(shapes.size(), 2);
 
-        @param anArray an array of FSKerning objects that define an adjustment applied to the spacing between pairs of glyphs.
-        */
-    public void setKernings(ArrayList anArray)
-    {
-        kernings = anArray;
-    }
+		int currentLocation;
+		int offset;
 
-    public Object clone()
-    {    
-        FSDefineFont2 anObject = (FSDefineFont2)super.clone();
-        
-        anObject.shapes = new ArrayList();
-            
-        for (Iterator i = shapes.iterator(); i.hasNext();)
-            anObject.shapes.add(((FSShape)i.next()).clone());
+		int tableStart = coder.getPointer();
+		int tableEntry = tableStart;
+		int entrySize = wideOffsets ? 4 : 2;
 
-        anObject.codes = new ArrayList();
-            
-        for (Iterator i = codes.iterator(); i.hasNext();)
-            anObject.codes.add(new Integer(((Integer)i.next()).intValue()));
+		for (int i = 0; i &lt;= shapes.size(); i++)
+			coder.writeWord(0, entrySize);
 
-        if (advances != null)
-        {
-            anObject.advances = new ArrayList();
-            
-            for (Iterator i = advances.iterator(); i.hasNext();)
-                anObject.advances.add(new Integer(((Integer)i.next()).intValue()));
-        }
+		for (Iterator i = shapes.iterator(); i.hasNext(); tableEntry += entrySize &lt;&lt; 3)
+		{
+			currentLocation = coder.getPointer();
+			offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
 
-        if (bounds != null)
-        {
-            anObject.bounds = new ArrayList();
-            
-            for (Iterator i = bounds.iterator(); i.hasNext();)
-                anObject.bounds.add(((FSBounds)i.next()).clone());
-        }
+			coder.setPointer(tableEntry);
+			coder.writeWord(offset, entrySize);
+			coder.setPointer(currentLocation);
 
-        if (kernings != null)
-        {
-            anObject.kernings = new ArrayList();
-            
-            for (Iterator i = kernings.iterator(); i.hasNext();)
-                anObject.kernings.add(((FSKerning)i.next()).clone());
-        }
-                
-        return anObject;
-    }
+			((FSTransformObject) i.next()).encode(coder);
+		}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineFont2 typedObject = (FSDefineFont2)anObject;
-            
-            result = encoding == typedObject.encoding;
-// Flash 7
-            result = result &amp;&amp; small == typedObject.small;
-// End Flash 7
-            result = result &amp;&amp; italic == typedObject.italic;
-            result = result &amp;&amp; bold == typedObject.bold;
-// Flash 6
-            result = result &amp;&amp; language == typedObject.language;
-// End Flash 6
+		currentLocation = coder.getPointer();
+		offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
 
-            if (name != null)
-                result = result &amp;&amp; name.equals(typedObject.name);
-            else
-                result = result &amp;&amp; name == typedObject.name;
+		coder.setPointer(tableEntry);
+		coder.writeWord(offset, entrySize);
+		coder.setPointer(currentLocation);
 
-            if (shapes != null)
-                result = result &amp;&amp; shapes.equals(typedObject.shapes);
-            else
-                result = result &amp;&amp; shapes == typedObject.shapes;
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+			coder.writeWord(((Integer) codesIterator.next()).intValue(),
+							(wideCodes == 1) ? 2 : 1);
 
-            if (codes != null)
-                result = result &amp;&amp; codes.equals(typedObject.codes);
-            else
-                result = result &amp;&amp; codes == typedObject.codes;
-            
-            if (containsLayoutInfo())
-            {
-                result = result &amp;&amp; ascent == typedObject.ascent;
-                result = result &amp;&amp; descent == typedObject.descent;
-                result = result &amp;&amp; leading == typedObject.leading;
-                
-                if (advances != null)
-                    result = result &amp;&amp; advances.equals(typedObject.advances);
-                else
-                    result = result &amp;&amp; advances == typedObject.advances;
-    
-                if (bounds != null)
-                    result = result &amp;&amp; bounds.equals(typedObject.bounds);
-                else
-                    result = result &amp;&amp; bounds == typedObject.bounds;
-    
-                if (kernings != null)
-                    result = result &amp;&amp; kernings.equals(typedObject.kernings);
-                else
-                    result = result &amp;&amp; kernings == typedObject.kernings;
-            }
-        }
-        return result;
-    }
+		if (containsLayoutInfo())
+		{
+			coder.writeWord(ascent, 2);
+			coder.writeWord(descent, 2);
+			coder.writeWord(leading, 2);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encoding&quot;, encoding);
-// Flash 7
-            Transform.append(buffer, &quot;small&quot;, small);
-// End Flash 7
-            Transform.append(buffer, &quot;italic&quot;, italic);
-            Transform.append(buffer, &quot;bold&quot;, bold);
-// Flash 6
-            Transform.append(buffer, &quot;language&quot;, language);
-// End Flash 6
-            Transform.append(buffer, &quot;name&quot;, name);
-            Transform.append(buffer, &quot;shapes&quot;, shapes, depth);
-            Transform.append(buffer, &quot;codes&quot;, codes, depth);
-            Transform.append(buffer, &quot;ascent&quot;, ascent);
-            Transform.append(buffer, &quot;descent&quot;, descent);
-            Transform.append(buffer, &quot;leading&quot;, leading);
-            Transform.append(buffer, &quot;advances&quot;, advances, depth);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;kernings&quot;, kernings, depth);        
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			for (Iterator advancesIterator = advances.iterator(); advancesIterator
+							.hasNext();)
+				coder.writeWord(((Integer) advancesIterator.next()).intValue(),
+								2);
 
-    public int length(FSCoder coder)
-    {
-        boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
-        int wideCodes = 0;
-        
-        if (coder.context[FSCoder.Version] &gt; 5)
-            wideCodes = 1;
-        else
-            wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
+			for (Iterator boundsIterator = bounds.iterator(); boundsIterator
+							.hasNext();)
+				((FSTransformObject) boundsIterator.next()).encode(coder);
 
-        super.length(coder);
-        
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = wideCodes;
-        length += 3;
-        length += coder.strlen(name, false);
-        length += 2;
-        length += shapes.size()*(wideOffsets ? 4 : 2);
-        length += wideOffsets ? 4 : 2;
-    
-        for (Iterator shapeIterator = shapes.iterator(); shapeIterator.hasNext();) 
-            length += ((FSTransformObject)shapeIterator.next()).length(coder);
-    
-        length += shapes.size()*((wideCodes == 1) ? 2 : 1);
-    
-        if (containsLayoutInfo())
-        {
-            length += 6;
-            length += shapes.size()*2;
-        
-            for (Iterator boundsIterator = bounds.iterator(); boundsIterator.hasNext();) 
-                length += ((FSTransformObject)boundsIterator.next()).length(coder);
-        
-            length += 2;
-            length += kernings.size()*((wideCodes == 1) ? 6 : 4);
-        }
+			coder.writeWord(kernings.size(), 2);
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = 0;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean wideOffsets = wideOffsetsForIndexedArray(shapes, coder);
-        int wideCodes = 0;
-        int format = 0;
-        
-        if (coder.context[FSCoder.Version] &gt; 5)
-            wideCodes = 1;
-        else
-            wideCodes = (encoding != FSText.ANSI) ? 1 : 0;
-            
-        if (encoding == FSText.ANSI)
-            format = 1;
-// Flash 7
-        else if (small)
-           format = 2;
-// End Flash 7
-        else if (encoding == FSText.SJIS)
-            format = 4;
-        
-        super.encode(coder);
+			for (Iterator kerningIterator = kernings.iterator(); kerningIterator
+							.hasNext();)
+				((FSTransformObject) kerningIterator.next()).encode(coder);
+		}
 
-        coder.context[FSCoder.NumberOfFillBits] = 1;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = wideCodes;
-        
-        coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
-        coder.writeBits(format, 3);
-        coder.writeBits(wideOffsets ? 1 : 0, 1);
-        coder.writeBits(wideCodes, 1);
-        coder.writeBits(italic ? 1 : 0, 1);
-        coder.writeBits(bold ? 1 : 0, 1);
-        coder.writeWord(coder.context[FSCoder.Version] &gt; 5 ? language : 0, 1);
-        coder.writeWord(coder.strlen(name, false), 1);
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.WideCodes] = 0;
 
-        coder.writeString(name);
-        coder.writeWord(shapes.size(), 2);
+		coder.endObject(name());
+	}
 
+	public void decode(FSCoder coder)
+	{
+		boolean containsWideOffsets = false;
+		boolean containsWideCodes = false;
+		boolean containsLayout = false;
 
-        int currentLocation;
-        int offset;
-        
-        int tableStart = coder.getPointer();
-        int tableEntry = tableStart;
-        int entrySize = wideOffsets ? 4 : 2;
-   
-        for (int i=0; i&lt;=shapes.size(); i++)
-            coder.writeWord(0, entrySize);
+		int glyphCount = 0;
+		int kerningCount = 0;
+		int nameLength = 0;
 
-        for (Iterator i=shapes.iterator(); i.hasNext(); tableEntry += entrySize &lt;&lt; 3) 
-        {
-            currentLocation = coder.getPointer();
-            offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
-            
-            coder.setPointer(tableEntry);
-            coder.writeWord(offset, entrySize);
-            coder.setPointer(currentLocation);
+		super.decode(coder);
 
-            ((FSTransformObject)i.next()).encode(coder);
-        }
+		containsLayout = coder.readBits(1, false) != 0 ? true : false;
+		int format = coder.readBits(3, false);
 
-        currentLocation = coder.getPointer();
-        offset = (coder.getPointer() - tableStart) &gt;&gt; 3;
-        
-        coder.setPointer(tableEntry);
-        coder.writeWord(offset, entrySize);
-        coder.setPointer(currentLocation);
+		encoding = FSText.Unicode;
 
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-            coder.writeWord(((Integer)codesIterator.next()).intValue(), (wideCodes == 1) ? 2 : 1);
-    
-        if (containsLayoutInfo())
-        {
-            coder.writeWord(ascent, 2);
-            coder.writeWord(descent, 2);
-            coder.writeWord(leading, 2);
-    
-            for (Iterator advancesIterator = advances.iterator(); advancesIterator.hasNext();)
-                coder.writeWord(((Integer)advancesIterator.next()).intValue(), 2);
+		if (format == 1)
+			encoding = FSText.ANSI;
+		// Flash 7
+		else if (format == 2)
+			small = true;
+		// End Flash 7
+		else if (format == 4)
+			encoding = FSText.SJIS;
 
-            for (Iterator boundsIterator = bounds.iterator(); boundsIterator.hasNext();)
-                ((FSTransformObject)boundsIterator.next()).encode(coder);
+		containsWideOffsets = coder.readBits(1, false) != 0 ? true : false;
+		containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
 
-            coder.writeWord(kernings.size(), 2);
-    
-            for (Iterator kerningIterator = kernings.iterator(); kerningIterator.hasNext();)
-                ((FSTransformObject)kerningIterator.next()).encode(coder);
-        }
+		coder.context[FSCoder.WideCodes] = containsWideCodes ? 1 : 0;
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.WideCodes] = 0;
+		italic = coder.readBits(1, false) != 0 ? true : false;
+		bold = coder.readBits(1, false) != 0 ? true : false;
+		language = coder.readBits(8, false);
+		nameLength = coder.readWord(1, false);
+		name = coder.readString(nameLength);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsWideOffsets = false;
-        boolean containsWideCodes = false;
-        boolean containsLayout = false;
-        
-        int glyphCount = 0;
-        int kerningCount = 0;
-        int nameLength = 0;
-        
-        super.decode(coder);
-        
-        containsLayout = coder.readBits(1, false) != 0 ? true : false;
-        int format = coder.readBits(3, false);
-        
-        encoding = FSText.Unicode;
+		if (name.length() &gt; 0)
+		{
+			while (name.charAt(name.length() - 1) == 0)
+			{
+				name = name.substring(0, name.length() - 1);
+			}
+		}
 
-        if (format == 1)
-            encoding = FSText.ANSI;
-// Flash 7
-        else if (format == 2)
-            small = true;
-// End Flash 7
-        else if (format == 4)
-            encoding = FSText.SJIS;
-        
-        containsWideOffsets = coder.readBits(1, false) != 0 ? true : false;
-        containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
+		glyphCount = coder.readWord(2, false);
 
-        coder.context[FSCoder.WideCodes] = containsWideCodes ? 1 : 0;
+		int offsetStart = coder.getPointer();
+		int[] offset = new int[glyphCount + 1];
 
-        italic = coder.readBits(1, false) != 0 ? true : false;
-        bold = coder.readBits(1, false) != 0 ? true : false;
-        language = coder.readBits(8, false);
-        nameLength = coder.readWord(1, false);
-        name = coder.readString(nameLength);
-        
-        if (name.length() &gt; 0)
-        {
-            while (name.charAt(name.length()-1) == 0) {
-            	name = name.substring(0, name.length()-1);
-            }
-        }
-        
-        glyphCount = coder.readWord(2, false);
+		for (int i = 0; i &lt; glyphCount; i++)
+			offset[i] = coder.readWord((containsWideOffsets) ? 4 : 2, false);
 
-        int offsetStart = coder.getPointer();
-        int[] offset = new int[glyphCount+1];
-        
-        for (int i=0; i&lt;glyphCount; i++)
-            offset[i] = coder.readWord((containsWideOffsets) ? 4 : 2, false);
+		offset[glyphCount] = coder.readWord((containsWideOffsets) ? 4 : 2,
+						false);
 
-        offset[glyphCount] = coder.readWord((containsWideOffsets) ? 4 : 2, false);
+		for (int i = 0; i &lt; glyphCount; i++)
+		{
+			coder.setPointer(offsetStart + (offset[i] &lt;&lt; 3));
 
-        for (int i=0; i&lt;glyphCount; i++)
-        {
-            coder.setPointer(offsetStart+(offset[i]&lt;&lt;3));
-            
-            if (coder.context[FSCoder.DecodeGlyphs] == 1)
-                shapes.add(new FSShape(coder));
-            else   
-                shapes.add(new FSShape(coder, offset[i+1]-offset[i]));
-                
-        }
+			if (coder.context[FSCoder.DecodeGlyphs] == 1)
+				shapes.add(new FSShape(coder));
+			else
+				shapes.add(new FSShape(coder, offset[i + 1] - offset[i]));
 
-        for (int i=0; i&lt;glyphCount; i++)
-            codes.add(new Integer(coder.readWord((containsWideCodes) ? 2 : 1, false)));
+		}
 
-        if (containsLayout)
-        {
-            ascent = coder.readWord(2, true);
-            descent = coder.readWord(2, true);
-            leading = coder.readWord(2, true);
-            
-            advances = new ArrayList();
-            bounds = new ArrayList();
-            kernings = new ArrayList();
+		for (int i = 0; i &lt; glyphCount; i++)
+			codes.add(new Integer(coder.readWord((containsWideCodes) ? 2 : 1,
+							false)));
 
-            for (int i=0; i&lt;glyphCount; i++)
-                advances.add(new Integer(coder.readWord(2, true)));
+		if (containsLayout)
+		{
+			ascent = coder.readWord(2, true);
+			descent = coder.readWord(2, true);
+			leading = coder.readWord(2, true);
 
-            for (int i=0; i&lt;glyphCount; i++)
-                bounds.add(new FSBounds(coder));
+			advances = new ArrayList();
+			bounds = new ArrayList();
+			kernings = new ArrayList();
 
-            kerningCount = coder.readWord(2, false);
+			for (int i = 0; i &lt; glyphCount; i++)
+				advances.add(new Integer(coder.readWord(2, true)));
 
-            for (int i=0; i&lt;kerningCount; i++)
-                kernings.add(new FSKerning(coder));
-        }
+			for (int i = 0; i &lt; glyphCount; i++)
+				bounds.add(new FSBounds(coder));
 
-        coder.context[FSCoder.WideCodes] = 0;
+			kerningCount = coder.readWord(2, false);
 
-        coder.endObject(name());
-    }
+			for (int i = 0; i &lt; kerningCount; i++)
+				kernings.add(new FSKerning(coder));
+		}
 
-    private boolean containsLayoutInfo()
-    {
-        boolean layout = false;
-        
-        layout = layout || ascent != 0;
-        layout = layout || descent != 0;
-        layout = layout || leading != 0;
-        layout = layout || ((advances != null) &amp;&amp; advances.size() &gt; 0);
-        layout = layout || ((bounds != null) &amp;&amp; bounds.size() &gt; 0);
-        layout = layout || ((kernings != null) &amp;&amp; kernings.size() &gt; 0);
-        
-        return layout;
-    }
-    
-    private boolean wideOffsetsForIndexedArray(ArrayList anArray, FSCoder coder)
-    {
-        boolean wideOffsets = false;
-        
-        int glyphLength = 0;
+		coder.context[FSCoder.WideCodes] = 0;
 
-        for (Iterator i=anArray.iterator(); i.hasNext();)
-            glyphLength += ((FSTransformObject)i.next()).length(coder);
-        
-        if ((anArray.size()*2 + glyphLength) &gt; 65535)
-            wideOffsets = true;
+		coder.endObject(name());
+	}
 
-        return wideOffsets;
-    }
+	private boolean containsLayoutInfo()
+	{
+		boolean layout = false;
+
+		layout = layout || ascent != 0;
+		layout = layout || descent != 0;
+		layout = layout || leading != 0;
+		layout = layout || ((advances != null) &amp;&amp; advances.size() &gt; 0);
+		layout = layout || ((bounds != null) &amp;&amp; bounds.size() &gt; 0);
+		layout = layout || ((kernings != null) &amp;&amp; kernings.size() &gt; 0);
+
+		return layout;
+	}
+
+	private boolean wideOffsetsForIndexedArray(ArrayList anArray, FSCoder coder)
+	{
+		boolean wideOffsets = false;
+
+		int glyphLength = 0;
+
+		for (Iterator i = anArray.iterator(); i.hasNext();)
+			glyphLength += ((FSTransformObject) i.next()).length(coder);
+
+		if ((anArray.size() * 2 + glyphLength) &gt; 65535)
+			wideOffsets = true;
+
+		return wideOffsets;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineImage.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineImage.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineImage.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,373 +34,459 @@
 import java.util.zip.Inflater;
 
 /**
-FSDefineImage is used to define an image compressed using the lossless zlib compression algorithm.
-
-&lt;p&gt;The class supports colour-mapped images where the image data contains an index into a colour table or images where the image data specifies the colour directly.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineImage_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_2&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_3&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Height of the image in pixels, NOT twips.  1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_4&quot;&gt;pixelSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bits per pixel, either 16 or 24.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_4&quot;&gt;tableSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of entries in the colour table - which is compressed as part of the image. Each entry in the colour table contains one byte each for the red, green and blue colour channels. The colour table is only used for indexed colour images. The table is not used when the colour is specified directly in each pixel.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage_5&quot;&gt;compressedData&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;For colour-mapped images the colour table contains up to 256, 24-bit colours. The image contains one byte for each pixel which is an index into the table to specify the colour for that pixel. The colour table and the image data are compressed as a single block, with the colour table placed before the image.&lt;/p&gt;
-
-&lt;p&gt;For images where the colour is specified directly, the image data contains either 16 or 24 bit colour values. For 16-bit colour values the most significant bit is zero followed by three, 5-bit fields for the red, green and blue channels:&lt;/p&gt;
-
-&lt;pre&gt;
-            +-+--------+--------+--------+
-            |0|   Red  |  Green |  Blue  |
-            +-+--------+--------+--------+
-           15                            0
-&lt;/pre&gt;
-
-&lt;p&gt;Four bytes are used to represent 24-bit colours. The first byte is always set to zero and the following bytes contain the colour values for the red, green and blue colour channels.&lt;/p&gt;
-
-&lt;p&gt;The number of bytes in each row of an image must be aligned to a 32-bit word boundary. For example if an image if an icon is 25 pixels wide, then for an 8-bit colour mapped image an additional three bytes (0x00) must be used to pad each row; for a 16-bit direct mapped colour image an additional two bytes must be used as padding.&lt;/p&gt;
-
-&lt;p&gt;The image data is stored in zlib compressed form within the object. For colour-mapped images the compressed data contains the colour table followed by the image data. The colour table is omitted for direct-mapped images.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSDefineImage class represents the DefineBitsLossless tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
+ * FSDefineImage is used to define an image compressed using the lossless zlib
+ * compression algorithm.
+ * 
+ * &lt;p&gt;
+ * The class supports colour-mapped images where the image data contains an
+ * index into a colour table or images where the image data specifies the colour
+ * directly.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;width&lt;/td&gt;
+ * &lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;Height of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;pixelSize&lt;/td&gt;
+ * &lt;td&gt;The number of bits per pixel, either 16 or 24.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;tableSize&lt;/td&gt;
+ * &lt;td&gt;The number of entries in the colour table - which is compressed as part
+ * of the image. Each entry in the colour table contains one byte each for the
+ * red, green and blue colour channels. The colour table is only used for
+ * indexed colour images. The table is not used when the colour is specified
+ * directly in each pixel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;compressedData&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * For colour-mapped images the colour table contains up to 256, 24-bit colours.
+ * The image contains one byte for each pixel which is an index into the table
+ * to specify the colour for that pixel. The colour table and the image data are
+ * compressed as a single block, with the colour table placed before the image.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For images where the colour is specified directly, the image data contains
+ * either 16 or 24 bit colour values. For 16-bit colour values the most
+ * significant bit is zero followed by three, 5-bit fields for the red, green
+ * and blue channels:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  +-+--------+--------+--------+
+ *  |0|   Red  |  Green |  Blue  |
+ *  +-+--------+--------+--------+
+ *  15                            0
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Four bytes are used to represent 24-bit colours. The first byte is always set
+ * to zero and the following bytes contain the colour values for the red, green
+ * and blue colour channels.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The number of bytes in each row of an image must be aligned to a 32-bit word
+ * boundary. For example if an image if an icon is 25 pixels wide, then for an
+ * 8-bit colour mapped image an additional three bytes (0x00) must be used to
+ * pad each row; for a 16-bit direct mapped colour image an additional two bytes
+ * must be used as padding.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The image data is stored in zlib compressed form within the object. For
+ * colour-mapped images the compressed data contains the colour table followed
+ * by the image data. The colour table is omitted for direct-mapped images.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineImage class represents the DefineBitsLossless tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
  */
 public class FSDefineImage extends FSDefineObject
 {
-    private int width = 0;
-    private int height = 0;
+	private int width = 0;
+	private int height = 0;
+	private int pixelSize = 8;
+	private int tableSize = 0;
+	private byte[] compressedData = null;
 
-    private int pixelSize = 8;
-    private int tableSize = 0;
+	/**
+	 * Construct an FSDefineImage object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineImage(FSCoder coder)
+	{
+		super(DefineImage, 0);
+		extendLength = true;
+		decode(coder);
+	}
 
-    private byte[] compressedData = null;
+	/**
+	 * Constructs an FSDefineImage object defining a colour-mapped image.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param tableSize
+	 *            the number of entries in the colour table in the compressed
+	 *            data. Each entry is 24 bits.
+	 * @param compressedBytes
+	 *            the zlib compressed colour table and image data.
+	 */
+	public FSDefineImage(int anIdentifier, int width, int height,
+							int tableSize, byte[] compressedBytes)
+	{
+		super(DefineImage, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(8);
+		setTableSize(tableSize);
+		setCompressedData(compressedBytes);
+	}
 
-    /**
-     * Construct an FSDefineImage object, initalizing it with values decoded
-     * from an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineImage(FSCoder coder)
-    {
-        super(DefineImage, 0);
-        extendLength = true;
-        decode(coder);
-    }
-    /** Constructs an FSDefineImage object defining a colour-mapped image.
+	/**
+	 * Constructs an FSDefineImage object defining an image that specifies the
+	 * colour directly.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param compressedBytes
+	 *            the zlib compressed image data.
+	 * @param aPixelSize
+	 *            the size of each pixel, either 16 or 24 bits.
+	 */
+	public FSDefineImage(int anIdentifier, int width, int height,
+							byte[] compressedBytes, int aPixelSize)
+	{
+		super(DefineImage, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(aPixelSize);
+		setTableSize(0);
+		setCompressedData(compressedBytes);
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param width the width of the image.
-        @param height the height of the image.
-        @param tableSize the number of entries in the colour table in the compressed data. Each entry is 24 bits.
-        @param compressedBytes the zlib compressed colour table and image data.
-        */
-    public FSDefineImage(int anIdentifier, int width, int height, int tableSize, byte[] compressedBytes)
-    {
-        super(DefineImage, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(8);
-        setTableSize(tableSize);
-        setCompressedData(compressedBytes);
-    }
+	/**
+	 * Constructs an FSDefineImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineImage object.
+	 */
+	public FSDefineImage(FSDefineImage obj)
+	{
+		super(obj);
+		width = obj.width;
+		height = obj.height;
+		pixelSize = obj.pixelSize;
+		tableSize = obj.tableSize;
+		compressedData = Transform.clone(obj.compressedData);
+	}
 
-    /** Constructs an FSDefineImage object defining an image that specifies the colour directly.
+	/**
+	 * Gets the width of the image.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param width the width of the image.
-        @param height the height of the image.
-        @param compressedBytes the zlib compressed image data.
-        @param aPixelSize the size of each pixel, either 16 or 24 bits.
-        */
-    public FSDefineImage(int anIdentifier, int width, int height, byte[] compressedBytes, int aPixelSize)
-    {
-        super(DefineImage, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(aPixelSize);
-        setTableSize(0);
-        setCompressedData(compressedBytes);
-    }
-    /**
-     * Constructs an FSDefineImage object by copying values from an existing
-     * object.
-     *
-     * @param obj an FSDefineImage object.
-     */
-    public FSDefineImage(FSDefineImage obj)
-    {
-        super(obj);
-        width = obj.width;
-        height = obj.height;
-        pixelSize = obj.pixelSize;
-        tableSize = obj.tableSize;
-        compressedData = Transform.clone(obj.compressedData);
-    }
+	/**
+	 * Gets the height of the image.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-    /** Gets the width of the image.
+	/**
+	 * Gets the number of bits used to represent each pixel. Either 8, 16 or 24
+	 * bits. The pixel size is 8-bits for colour-mapped images and 16 or 24 bits
+	 * for images where the colour is specified directly.
+	 * 
+	 * @return the number of bits per pixel: 8, 16 or 24.
+	 */
+	public int getPixelSize()
+	{
+		return pixelSize;
+	}
 
-        @return the width of the image.
-        */
-    public int getWidth()
-    {
-        return width;
-    }
+	/**
+	 * Gets the number of entries in the colour table encoded the compressed
+	 * image. For images where the colour is specified directly in the image
+	 * then the table size is zero.
+	 * 
+	 * @return the number of entries in the colour table.
+	 */
+	public int getTableSize()
+	{
+		return tableSize;
+	}
 
-    /** Gets the height of the image.
+	/**
+	 * Gets the compressed colour table and image.
+	 * 
+	 * @return an array of bytes containing the compressed colour table and
+	 *         image.
+	 */
+	public byte[] getCompressedData()
+	{
+		return compressedData;
+	}
 
-        @return the height of the image in pixels.
-        */
-    public int getHeight()
-    {
-        return height;
-    }
+	/**
+	 * Sets the width of the image
+	 * 
+	 * @param aNumber
+	 *            the width of the image.
+	 */
+	public void setWidth(int aNumber)
+	{
+		width = aNumber;
+	}
 
-    /** Gets the number of bits used to represent each pixel. Either 8, 16 or 24 bits. The pixel size is 8-bits for colour-mapped images and 16 or 24 bits for images where the colour is specified directly.
+	/**
+	 * Sets the height of the image.
+	 * 
+	 * @param aNumber
+	 *            the height of the image in pixels.
+	 */
+	public void setHeight(int aNumber)
+	{
+		height = aNumber;
+	}
 
-        @return the number of bits per pixel: 8, 16 or 24.
-        */
-    public int getPixelSize()
-    {
-        return pixelSize;
-    }
+	/**
+	 * Sets the size of the pixel in bits: 8, 16 or 32. The pixel size is 8-bits
+	 * for colour-mapped images and 16 or 24 bits for images where the colour is
+	 * specified directly.
+	 * 
+	 * @param aNumber
+	 *            the size of each pixel in bits: 8, 16 or 24.
+	 */
+	public void setPixelSize(int aNumber)
+	{
+		pixelSize = aNumber;
+	}
 
-    /** Gets the number of entries in the colour table encoded the compressed image. For images where the colour is specified directly in the image then the table size is zero.
+	/**
+	 * Sets the number of entries in the colour table in the compressed image.
+	 * For images where the colour is specified directly in the image then the
+	 * table size should be zero.
+	 * 
+	 * @param aNumber
+	 *            the number of entries in the colour table in the compressed
+	 *            image.
+	 */
+	public void setTableSize(int aNumber)
+	{
+		tableSize = aNumber;
+	}
 
-        @return the number of entries in the colour table.
-        */
-    public int getTableSize()
-    {
-        return tableSize;
-    }
+	/**
+	 * Sets the compressed image data using compressed data.
+	 * 
+	 * @param bytes
+	 *            byte array containing zlib compressed colour table and image.
+	 */
+	public void setCompressedData(byte[] bytes)
+	{
+		compressedData = bytes;
+	}
 
-    /** Gets the compressed colour table and image.
+	public Object clone()
+	{
+		FSDefineImage anObject = (FSDefineImage) super.clone();
 
-        @return an array of bytes containing the compressed colour table and image.
-        */
-    public byte[] getCompressedData()
-    {
-        return compressedData;
-    }
+		anObject.compressedData = Transform.clone(compressedData);
 
-    /** Sets the width of the image
+		return anObject;
+	}
 
-        @param aNumber the width of the image.
-        */
-    public void setWidth(int aNumber)
-    {
-        width = aNumber;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the height of the image.
+		if (super.equals(anObject))
+		{
+			FSDefineImage typedObject = (FSDefineImage) anObject;
 
-        @param aNumber the height of the image in pixels.
-        */
-    public void setHeight(int aNumber)
-    {
-        height = aNumber;
-    }
+			result = pixelSize == typedObject.pixelSize;
+			result = result &amp;&amp; width == typedObject.width;
+			result = result &amp;&amp; height == typedObject.height;
+			result = result &amp;&amp; tableSize == typedObject.tableSize;
 
-    /** Sets the size of the pixel in bits: 8, 16 or 32. The pixel size is 8-bits for colour-mapped images and 16 or 24 bits for images where the colour is specified directly.
+			try
+			{
+				result = result
+								&amp;&amp; Transform
+												.equals(
+																unzip(compressedData),
+																unzip(typedObject.compressedData));
+			} catch (DataFormatException e)
+			{
+				result = false;
+			}
+		}
+		return result;
+	}
 
-        @param aNumber the size of each pixel in bits: 8, 16 or 24.
-        */
-    public void setPixelSize(int aNumber)
-    {
-        pixelSize = aNumber;
-    }
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		byte[] data = new byte[width * height * 8];
+		int count = 0;
 
-    /** Sets the number of entries in the colour table in the compressed image. For images where the colour is specified directly in the image then the table size should be zero.
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes);
+		count = inflater.inflate(data);
 
-        @param aNumber the number of entries in the colour table in the compressed image.
-        */
-    public void setTableSize(int aNumber)
-    {
-        tableSize = aNumber;
-    }
+		byte[] uncompressedData = new byte[count];
 
-    /** Sets the compressed image data using compressed data.
+		System.arraycopy(data, 0, uncompressedData, 0, count);
 
-        @param bytes byte array containing zlib compressed colour table and image.
-        */
-    public void setCompressedData(byte[] bytes)
-    {
-        compressedData = bytes;
-    }
+		return uncompressedData;
+	}
 
-    public Object clone()
-    {
-        FSDefineImage anObject = (FSDefineImage)super.clone();
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        anObject.compressedData = Transform.clone(compressedData);
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;pixelSize&quot;, pixelSize);
+			Transform.append(buffer, &quot;width&quot;, width);
+			Transform.append(buffer, &quot;height&quot;, height);
+			Transform.append(buffer, &quot;tableSize&quot;, tableSize);
+			Transform.append(buffer, &quot;compressedData&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        return anObject;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+		length += 5;
+		length += (pixelSize == 8) ? 1 : 0;
+		length += compressedData.length;
 
-        if (super.equals(anObject))
-        {
-            FSDefineImage typedObject = (FSDefineImage)anObject;
+		return length;
+	}
 
-            result = pixelSize == typedObject.pixelSize;
-            result = result &amp;&amp; width == typedObject.width;
-            result = result &amp;&amp; height == typedObject.height;
-            result = result &amp;&amp; tableSize == typedObject.tableSize;
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
 
-            try
-            {
-            	result = result &amp;&amp; Transform.equals(unzip(compressedData), unzip(typedObject.compressedData));
-            }
-            catch (DataFormatException e)
-            {
-            	result = false;
-            }
-        }
-        return result;
-    }
+		super.encode(coder);
 
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*8];
-        int count = 0;
+		switch (pixelSize)
+		{
+			case 8:
+				coder.writeWord(3, 1);
+				break;
+			case 16:
+				coder.writeWord(4, 1);
+				break;
+			case 24:
+				coder.writeWord(5, 1);
+				break;
+		}
 
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
+		coder.writeWord(width, 2);
+		coder.writeWord(height, 2);
 
-        byte[] uncompressedData = new byte[count];
+		if (pixelSize == 8)
+			coder.writeWord(tableSize - 1, 1);
 
-        System.arraycopy(data, 0, uncompressedData, 0, count);
+		coder.writeBytes(compressedData);
+		coder.endObject(name());
+	}
 
-        return uncompressedData;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		switch (coder.readWord(1, false))
+		{
+			case 3:
+				pixelSize = 8;
+				break;
+			case 4:
+				pixelSize = 16;
+				break;
+			case 5:
+				pixelSize = 24;
+				break;
+		}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;pixelSize&quot;, pixelSize);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;tableSize&quot;, tableSize);
-            Transform.append(buffer, &quot;compressedData&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		width = coder.readWord(2, false);
+		height = coder.readWord(2, false);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += 5;
-        length += (pixelSize == 8) ? 1 : 0;
-        length += compressedData.length;
-
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
-
-        super.encode(coder);
-
-        switch (pixelSize)
-        {
-            case 8:
-                coder.writeWord(3, 1);
-                break;
-            case 16:
-                coder.writeWord(4, 1);
-                break;
-            case 24:
-                coder.writeWord(5, 1);
-                break;
-        }
-
-        coder.writeWord(width, 2);
-        coder.writeWord(height, 2);
-
-        if (pixelSize == 8)
-            coder.writeWord(tableSize-1, 1);
-
-        coder.writeBytes(compressedData);
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        switch (coder.readWord(1, false))
-        {
-            case 3:
-                pixelSize = 8;
-                break;
-            case 4:
-                pixelSize = 16;
-                break;
-            case 5:
-                pixelSize = 24;
-                break;
-        }
-
-        width = coder.readWord(2, false);
-        height = coder.readWord(2, false);
-
-        if (pixelSize == 8)
-        {
-            tableSize = coder.readWord(1, false) + 1;
-            compressedData = new byte[length-8];
-            coder.readBytes(compressedData);
-        }
-        else
-        {
-            compressedData = new byte[length-7];
-            coder.readBytes(compressedData);
-        }
-        coder.endObject(name());
-    }
+		if (pixelSize == 8)
+		{
+			tableSize = coder.readWord(1, false) + 1;
+			compressedData = new byte[length - 8];
+			coder.readBytes(compressedData);
+		} else
+		{
+			compressedData = new byte[length - 7];
+			coder.readBytes(compressedData);
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineImage2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineImage2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineImage2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,356 +34,433 @@
 import java.util.zip.Inflater;
 
 /**
-FSDefineImage2 is used to define a transparent image compressed using the lossless 
-zlib compression algorithm. 
- 
-&lt;p&gt;The class supports colour-mapped images where the image data contains an index into a colour table or images where the image data specifies the colour directly. It extends FSDefineImage by including alpha channel information for the colour table and pixels in the image.&lt;/p&gt;
+ * FSDefineImage2 is used to define a transparent image compressed using the
+ * lossless zlib compression algorithm.
+ * 
+ * &lt;p&gt;
+ * The class supports colour-mapped images where the image data contains an
+ * index into a colour table or images where the image data specifies the colour
+ * directly. It extends FSDefineImage by including alpha channel information for
+ * the colour table and pixels in the image.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For colour-mapped images the colour table contains up to 256, 32-bit colours.
+ * The image contains one byte for each pixel which is an index into the table
+ * to specify the colour for that pixel. The colour table and the image data are
+ * compressed as a single block, with the colour table placed before the image.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For images where the colour is specified directly, the image data contains 32
+ * bit colour values.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;width&lt;/td&gt;
+ * &lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;Height of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;pixelSize&lt;/td&gt;
+ * &lt;td&gt;The number of bits per pixel, either 8 or 32. 8-bit pixels are used for
+ * indexed images where the colour table contains the colours for each pixel.
+ * 32-bit pixels are used to specify the colour and transparency directly.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;tableSize&lt;/td&gt;
+ * &lt;td&gt;The number of entries in the colour table - which is compressed as part
+ * of the image. Each entry in the colour table contains one byte each for the
+ * red, green and blue colour channels. The colour table is only used for
+ * indexed colour images. The table is not used when the colour is specified
+ * directly in each pixel.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;compressedData&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The image data is stored in zlib compressed form within the object. For
+ * colour-mapped images the compressed data contains the colour table followed
+ * by the image data.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineImage2 class represents the DefineBitsLossless2 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineImage2 extends FSDefineObject
+{
+	private int width = 0;
+	private int height = 0;
+	private int pixelSize = 8;
+	private int tableSize = 0;
+	private byte[] compressedData = null;
 
-&lt;p&gt;For colour-mapped images the colour table contains up to 256, 32-bit colours. The image contains one byte for each pixel which is an index into the table to specify the colour for that pixel. The colour table and the image data are compressed as a single block, with the colour table placed before the image.&lt;/p&gt;
+	/**
+	 * Construct an FSCall object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineImage2(FSCoder coder)
+	{
+		super(DefineImage2, 0);
+		extendLength = true;
+		decode(coder);
+	}
 
-&lt;p&gt;For images where the colour is specified directly, the image data contains 32 bit colour values.&lt;/p&gt;
+	/**
+	 * Constructs an FSDefineImage2 object defining a colour-mapped image.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param tableSize
+	 *            the number of entries in the colour table in the compressed
+	 *            data. Each entry is 32 bits.
+	 * @param compressedBytes
+	 *            the zlib compressed colour table and image data.
+	 */
+	public FSDefineImage2(int anIdentifier, int width, int height,
+							int tableSize, byte[] compressedBytes)
+	{
+		super(DefineImage2, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(8);
+		setTableSize(tableSize);
+		setCompressedData(compressedBytes);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSDefineImage object defining an image that specifies the
+	 * colour directly. Each pixel in the image is 32 bits - 8 bits for the red,
+	 * green, blue and alpha colour channels.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param width
+	 *            the width of the image.
+	 * @param height
+	 *            the height of the image.
+	 * @param compressedBytes
+	 *            the zlib compressed image data.
+	 */
+	public FSDefineImage2(int anIdentifier, int width, int height,
+							byte[] compressedBytes)
+	{
+		super(DefineImage2, anIdentifier);
+		extendLength = true;
+		setWidth(width);
+		setHeight(height);
+		setPixelSize(32);
+		setTableSize(0);
+		setCompressedData(compressedBytes);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineImage2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineImage2 object.
+	 */
+	public FSDefineImage2(FSDefineImage2 obj)
+	{
+		super(obj);
+		width = obj.width;
+		height = obj.height;
+		pixelSize = obj.pixelSize;
+		tableSize = obj.tableSize;
+		compressedData = Transform.clone(obj.compressedData);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineImage2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the width of the image.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the height of the image.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_2&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Width of the image in pixels, NOT twips. 1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the number of bits used to represent each pixel. Either 8 or 32
+	 * bits. The pixel size is 8-bits for colour-mapped images and 32 bits for
+	 * images where the colour is specified directly.
+	 * 
+	 * @return the number of bits per pixel: 8 or 32.
+	 */
+	public int getPixelSize()
+	{
+		return pixelSize;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_3&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Height of the image in pixels, NOT twips.  1 pixel = 20 twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the number of entries in the colour table encoded the compressed
+	 * image. For images where the colour is specified directly in the image
+	 * then the table size is zero.
+	 * 
+	 * @return the number of entries in the colour table.
+	 */
+	public int getTableSize()
+	{
+		return tableSize;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_4&quot;&gt;pixelSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bits per pixel, either 8 or 32. 8-bit pixels are used for indexed images where the colour table contains the colours for each pixel. 32-bit pixels are used to specify the colour and transparency directly.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the compressed colour table and image.
+	 * 
+	 * @return an array of bytes containing the compressed colour table and
+	 *         image.
+	 */
+	public byte[] getCompressedData()
+	{
+		return compressedData;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_5&quot;&gt;tableSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of entries in the colour table - which is compressed as part of the image. Each entry in the colour table contains one byte each for the red, green and blue colour channels. The colour table is only used for indexed colour images. The table is not used when the colour is specified directly in each pixel.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the width of the image
+	 * 
+	 * @param aNumber
+	 *            the width of the image.
+	 */
+	public void setWidth(int aNumber)
+	{
+		width = aNumber;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineImage2_5&quot;&gt;compressedData&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the zlib compressed colour table and image.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the height of the image.
+	 * 
+	 * @param aNumber
+	 *            the height of the image in pixels.
+	 */
+	public void setHeight(int aNumber)
+	{
+		height = aNumber;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the size of the pixel in bits: 8 for colour-mapped images, 32 for
+	 * direct images.
+	 * 
+	 * @param aNumber
+	 *            the size of each pixel in bits: 8 or 32.
+	 */
+	public void setPixelSize(int aNumber)
+	{
+		pixelSize = aNumber;
+	}
 
-&lt;p&gt;The image data is stored in zlib compressed form within the object. For colour-mapped images the compressed data contains the colour table followed by the image data.&lt;/p&gt;
+	/**
+	 * Sets the number of entries in the colour table in the compressed image.
+	 * For images where the colour is specified directly in the image then the
+	 * table size should be zero.
+	 * 
+	 * @param aNumber
+	 *            the number of entries in the colour table in the compressed
+	 *            image.
+	 */
+	public void setTableSize(int aNumber)
+	{
+		tableSize = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the compressed image data using compressed data.
+	 * 
+	 * @param bytes
+	 *            byte array containing zlib compressed colour table and image.
+	 */
+	public void setCompressedData(byte[] bytes)
+	{
+		compressedData = bytes;
+	}
 
-&lt;p&gt;The FSDefineImage2 class represents the DefineBitsLossless2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineImage2 extends FSDefineObject
-{
-    private int width = 0;
-    private int height = 0;
+	public Object clone()
+	{
+		FSDefineImage2 anObject = (FSDefineImage2) super.clone();
 
-    private int pixelSize = 8;
-    private int tableSize = 0;
-    
-    private byte[] compressedData = null;
+		anObject.compressedData = Transform.clone(compressedData);
 
-    /**
-     * Construct an FSCall object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineImage2(FSCoder coder)
-    {
-        super(DefineImage2, 0);
-        extendLength = true;
-        decode(coder);
-    }
-    /** Constructs an FSDefineImage2 object defining a colour-mapped image.
+		return anObject;
+	}
 
-    @param anIdentifier    the unique identifier for this object
-    @param width the width of the image.
-    @param height the height of the image.
-    @param tableSize the number of entries in the colour table in the compressed data. Each entry is 32 bits.
-    @param compressedBytes the zlib compressed colour table and image data.
-    */
-    public FSDefineImage2(int anIdentifier, int width, int height, int tableSize, byte[] compressedBytes)
-    {
-        super(DefineImage2, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(8);
-        setTableSize(tableSize);
-        setCompressedData(compressedBytes);
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Constructs an FSDefineImage object defining an image that specifies the colour directly. Each pixel in the image is 32 bits - 8 bits for the red, green, blue and alpha colour channels.
+		if (super.equals(anObject))
+		{
+			FSDefineImage2 typedObject = (FSDefineImage2) anObject;
 
-    @param anIdentifier    the unique identifier for this object
-    @param width the width of the image.
-    @param height the height of the image.
-    @param compressedBytes the zlib compressed image data.
-    */
-    public FSDefineImage2(int anIdentifier, int width, int height, byte[] compressedBytes)
-    { 
-        super(DefineImage2, anIdentifier);
-        extendLength = true;
-        setWidth(width);
-        setHeight(height);
-        setPixelSize(32);
-        setTableSize(0);
-        setCompressedData(compressedBytes);
-    }
-    /**
-     * Constructs an FSDefineImage2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineImage2 object.
-     */
-    public FSDefineImage2(FSDefineImage2 obj)
-    {
-        super(obj);
-        width = obj.width;
-        height = obj.height;
-        pixelSize = obj.pixelSize;
-        tableSize = obj.tableSize;
-        compressedData = Transform.clone(obj.compressedData);        
-    }
+			result = pixelSize == typedObject.pixelSize;
+			result = result &amp;&amp; width == typedObject.width;
+			result = result &amp;&amp; height == typedObject.height;
+			result = result &amp;&amp; tableSize == typedObject.tableSize;
 
-    /** Gets the width of the image. 
+			try
+			{
+				result = result
+								&amp;&amp; Transform
+												.equals(
+																unzip(compressedData),
+																unzip(typedObject.compressedData));
+			} catch (DataFormatException e)
+			{
+				result = false;
+			}
+		}
+		return result;
+	}
 
-        @return the width of the image.
-        */
-    public int getWidth()
-    {
-        return width; 
-    }    
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		byte[] data = new byte[width * height * 8];
+		int count = 0;
 
-    /** Gets the height of the image.
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes);
+		count = inflater.inflate(data);
 
-        @return the height of the image in pixels.
-        */
-    public int getHeight()
-    {
-        return height;
-    }
+		byte[] uncompressedData = new byte[count];
 
-    /** Gets the number of bits used to represent each pixel. Either 8 or 32 bits. The pixel size is 8-bits for colour-mapped images and 32 bits for images where the colour is specified directly.
+		System.arraycopy(data, 0, uncompressedData, 0, count);
 
-    @return the number of bits per pixel: 8 or 32.
-    */
-    public int getPixelSize()
-    {
-        return pixelSize;
-    }
+		return uncompressedData;
+	}
 
-    /** Gets the number of entries in the colour table encoded the compressed image. For images where the colour is specified directly in the image then the table size is zero.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the number of entries in the colour table.
-        */
-    public int getTableSize()
-    {
-        return tableSize;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;pixelSize&quot;, pixelSize);
+			Transform.append(buffer, &quot;width&quot;, width);
+			Transform.append(buffer, &quot;height&quot;, height);
+			Transform.append(buffer, &quot;tableSize&quot;, tableSize);
+			Transform.append(buffer, &quot;compressedData&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Gets the compressed colour table and image.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @return an array of bytes containing the compressed colour table and image.
-        */
-    public byte[] getCompressedData()
-    {
-        return compressedData;
-    }
+		length += 5;
+		length += (pixelSize == 8) ? 1 : 0;
+		length += compressedData.length;
 
-    /** Sets the width of the image
+		return length;
+	}
 
-        @param aNumber the width of the image.
-        */
-    public void setWidth(int aNumber)
-    {
-        width = aNumber;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
 
-    /** Sets the height of the image.
+		super.encode(coder);
 
-        @param aNumber the height of the image in pixels.
-        */
-    public void setHeight(int aNumber)
-    {
-        height = aNumber;
-    }
+		switch (pixelSize)
+		{
+			case 8:
+				coder.writeWord(3, 1);
+				break;
+			case 32:
+				coder.writeWord(5, 1);
+				break;
+		}
 
-    /** Sets the size of the pixel in bits: 8 for colour-mapped images, 32 for direct images.
+		coder.writeWord(width, 2);
+		coder.writeWord(height, 2);
 
-    @param aNumber the size of each pixel in bits: 8 or 32.
-    */
-    public void setPixelSize(int aNumber) 
-    { 
-        pixelSize = aNumber; 
-    }
-    
-    /** Sets the number of entries in the colour table in the compressed image. For images where the colour is specified directly in the image then the table size should be zero.
+		if (pixelSize == 8)
+			coder.writeWord(tableSize - 1, 1);
 
-        @param aNumber the number of entries in the colour table in the compressed image.
-        */
-    public void setTableSize(int aNumber)
-    {
-        tableSize = aNumber;
-    }
+		coder.writeBytes(compressedData);
+		coder.endObject(name());
+	}
 
-    /** Sets the compressed image data using compressed data.
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        @param bytes byte array containing zlib compressed colour table and image.
-        */
-    public void setCompressedData(byte[] bytes)
-    {
-        compressedData = bytes;
-    }
+		switch (coder.readWord(1, false))
+		{
+			case 3:
+				pixelSize = 8;
+				break;
+			case 5:
+				pixelSize = 32;
+				break;
+		}
 
-    public Object clone()
-    {
-        FSDefineImage2 anObject = (FSDefineImage2)super.clone();
-        
-        anObject.compressedData = Transform.clone(compressedData);
-        
-        return anObject;
-    }
+		width = coder.readWord(2, false);
+		height = coder.readWord(2, false);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineImage2 typedObject = (FSDefineImage2)anObject;
-            
-            result = pixelSize == typedObject.pixelSize;
-            result = result &amp;&amp; width == typedObject.width;
-            result = result &amp;&amp; height == typedObject.height;
-            result = result &amp;&amp; tableSize == typedObject.tableSize;
-
-            try
-            {
-            	result = result &amp;&amp; Transform.equals(unzip(compressedData), unzip(typedObject.compressedData));
-            }
-            catch (DataFormatException e)
-            {
-            	result = false;
-            }
-        }
-        return result;
-    }
-
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*8];
-        int count = 0;
-
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
-
-        byte[] uncompressedData = new byte[count];
-
-        System.arraycopy(data, 0, uncompressedData, 0, count);
-
-        return uncompressedData;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;pixelSize&quot;, pixelSize);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;tableSize&quot;, tableSize);
-            Transform.append(buffer, &quot;compressedData&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += 5;
-        length += (pixelSize == 8) ? 1 : 0;
-        length += compressedData.length;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
-
-        super.encode(coder);
-
-        switch (pixelSize)
-        {
-            case 8:
-                coder.writeWord(3, 1);
-                break;
-            case 32:
-                coder.writeWord(5, 1);
-                break;
-        }
-        
-        coder.writeWord(width, 2);
-        coder.writeWord(height, 2);
-
-        if (pixelSize == 8)
-            coder.writeWord(tableSize-1, 1);
-        
-        coder.writeBytes(compressedData);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        switch (coder.readWord(1, false))
-        {
-            case 3:
-                pixelSize = 8;
-                break;
-            case 5:
-                pixelSize = 32;
-                break;
-        }
-        
-        width = coder.readWord(2, false);
-        height = coder.readWord(2, false);
-
-        if (pixelSize == 8)
-        {
-            tableSize = coder.readWord(1, false) + 1;
-            compressedData = new byte[length-8];
-            coder.readBytes(compressedData);
-        }
-        else
-        {
-            compressedData = new byte[length-7];
-            coder.readBytes(compressedData);
-        }
-        coder.endObject(name());
-    }
+		if (pixelSize == 8)
+		{
+			tableSize = coder.readWord(1, false) + 1;
+			compressedData = new byte[length - 8];
+			coder.readBytes(compressedData);
+		} else
+		{
+			compressedData = new byte[length - 7];
+			coder.readBytes(compressedData);
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,228 +31,270 @@
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage is used to define a JPEG encoded image. 
- 
-&lt;p&gt;FSDefineJPEGImage objects only contain the image data, the encoding table for the image is defined in a FSJPEGEncodingTable object. All images using a shared FSJPEGEncodingTable object to represent the encoding table have the same compression ratio.&lt;/p&gt;
+ * FSDefineJPEGImage is used to define a JPEG encoded image.
+ * 
+ * &lt;p&gt;
+ * FSDefineJPEGImage objects only contain the image data, the encoding table for
+ * the image is defined in a FSJPEGEncodingTable object. All images using a
+ * shared FSJPEGEncodingTable object to represent the encoding table have the
+ * same compression ratio.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;image&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Images can only be displayed inside a shape using the FSBitmapFill class.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The image data may be taken directly from a JPEG image file. No further
+ * decoding is necessary.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Although the FSDefineJPEGImage class is supposed to be used with the
+ * FSJPEGEncodingTable class which defines the encoding table for the images it
+ * is not essential. If an FSJPEGEncodingTable object is created with an empty
+ * encoding table then the Flash Player will still display the JPEG image
+ * correctly.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSJPEGEncodingTable and FSDefineJPEGImage classes
+ * to define JPEG encoded images is to create an empty encoding table then
+ * construct the FSDefineJPEGImage object with the image data from a file:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSJPEGEncodingTable());
+ * movie.add(new FSDefineJPEGImage(movie.newIdentifier(), bytes));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineJPEGImage class represents the DefineBits data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineJPEGImage extends FSDefineObject
+{
+	private byte[] image = null;
+	private int width;
+	private int height;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineJPEGImage object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineJPEGImage(FSCoder coder)
+	{
+		super(FSMovieObject.DefineJPEGImage, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object with the identifier and JPEG data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param bytes
+	 *            the JPEG encoded image data.
+	 */
+	public FSDefineJPEGImage(int anIdentifier, byte[] bytes)
+	{
+		super(FSMovieObject.DefineJPEGImage, anIdentifier);
+		setImage(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage object.
+	 */
+	public FSDefineJPEGImage(FSDefineJPEGImage obj)
+	{
+		super(obj);
+		width = obj.width;
+		height = obj.height;
+		image = Transform.clone(obj.image);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the width of the image in pixels.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage_2&quot;&gt;image&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the height of the image in pixels.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;p&gt;Images can only be displayed inside a shape using the FSBitmapFill class.&lt;/p&gt;
+	/**
+	 * Gets the image data.
+	 * 
+	 * @return the array of bytes containing the image data.
+	 */
+	public byte[] getImage()
+	{
+		return image;
+	}
 
-&lt;p&gt;The image data may be taken directly from a JPEG image file. No further decoding is necessary.&lt;/p&gt;
+	/**
+	 * Sets the image data. The image data may be taken directly from a file
+	 * containing a JPEG encoded image.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the image data.
+	 */
+	public void setImage(byte[] bytes)
+	{
+		image = bytes;
+		decodeInfo();
+	}
 
-&lt;p&gt;Although the FSDefineJPEGImage class is supposed to be used with the FSJPEGEncodingTable class which defines the encoding table for the images it is not essential. If an FSJPEGEncodingTable object is created with an empty encoding table then the Flash Player will still display the JPEG image correctly.&lt;/p&gt;
+	public Object clone()
+	{
+		FSDefineJPEGImage anObject = (FSDefineJPEGImage) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+		anObject.image = Transform.clone(image);
+		anObject.width = width;
+		anObject.height = height;
 
-&lt;p&gt;The simplest way to use the FSJPEGEncodingTable and FSDefineJPEGImage classes to define JPEG encoded images is to create an empty encoding table then construct the FSDefineJPEGImage object with the image data from a file:&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);            
-    imageContents.read(bytes);
-    imageContents.close();
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
+		if (super.equals(anObject))
+		{
+			FSDefineJPEGImage typedObject = (FSDefineJPEGImage) anObject;
 
-movie.add(new FSJPEGEncodingTable());
-movie.add(new FSDefineJPEGImage(movie.newIdentifier(), bytes));
-&lt;/pre&gt;
+			result = Transform.equals(image, typedObject.image);
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;The FSDefineJPEGImage class represents the DefineBits data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineJPEGImage extends FSDefineObject
-{
-    private byte[] image = null;
-    private int width;
-    private int height;
-    
-    /**
-     * Construct an FSDefineJPEGImage object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineJPEGImage(FSCoder coder)
-    {
-        super(FSMovieObject.DefineJPEGImage, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineJPEGImage object with the identifier and JPEG data.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param bytes the JPEG encoded image data.
-        */
-    public FSDefineJPEGImage(int anIdentifier, byte[] bytes)
-    {
-        super(FSMovieObject.DefineJPEGImage, anIdentifier);
-        setImage(bytes);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineJPEGImage object.
-     */
-    public FSDefineJPEGImage(FSDefineJPEGImage obj)
-    {
-        super(obj);
-        width = obj.width;
-        height = obj.height;
-        image = Transform.clone(obj.image);
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** 
-     * Gets the width of the image in pixels. 
-     * 
-     * @return the width of the image.
-     */
-    public int getWidth()
-    {
-        return width; 
-    }    
-    /** 
-     * Gets the height of the image in pixels.
-     * 
-     * @return the height of the image in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }
+		length += image.length;
 
-    /** Gets the image data.
+		return length;
+	}
 
-        @return the array of bytes containing the image data.
-        */
-    public byte[] getImage() { return image; }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(image);
+		coder.endObject(name());
+	}
 
-    /** 
-     * Sets the image data. The image data may be taken directly from a file
-     * containing a JPEG encoded image.
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		byte[] data = new byte[length - 2];
+		coder.readBytes(data);
+		setImage(data);
+		coder.endObject(name());
+	}
 
-        @param bytes an array of bytes containing the image data.
-        */
-    public void setImage(byte[] bytes)
-    {
-        image = bytes;
-        decodeInfo();
-    }
+	private boolean decodeInfo()
+	{
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
 
-    public Object clone()
-    {
-        FSDefineJPEGImage anObject = (FSDefineJPEGImage)super.clone();
-        
-        anObject.image = Transform.clone(image);
-        anObject.width = width;
-        anObject.height = height;
-        
-        return anObject;
-    }
+		if (coder.readWord(2, false) != 0xffd8)
+			return false;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineJPEGImage typedObject = (FSDefineJPEGImage)anObject;
-            
-            result = Transform.equals(image, typedObject.image);
-        }
-        return result;
-    }
+		while (true)
+		{
+			int marker = coder.readWord(2, false);
+			int size = coder.readWord(2, false);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			if ((marker &amp; 0xff00) != 0xff00)
+				return false;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += image.length;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(image);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);    
-        byte[] data = new byte[length-2];    
-        coder.readBytes(data);
-        setImage(data);
-        coder.endObject(name());
-    }
-    private boolean decodeInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
-
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readWord(1, false);
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4
+							&amp;&amp; marker != 0xffc8)
+			{
+				coder.readWord(1, false);
+				height = coder.readWord(2, false);
+				width = coder.readWord(2, false);
+				return true;
+			} else
+			{
+				coder.adjustPointer((size - 2) &lt;&lt; 3);
+			}
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,307 +31,358 @@
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage2 is used to define a JPEG encoded image with an integrated
-encoding table.
+ * FSDefineJPEGImage2 is used to define a JPEG encoded image with an integrated
+ * encoding table.
+ * 
+ * &lt;p&gt;
+ * It extends the FSDefineJPEGImage class by including a separate encoding
+ * table, rather than using an FSJPEGEncodingTable object to store the encoding
+ * table. This allows multiple JPEG images with different amounts of compression
+ * to be included within a Flash file.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;image&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodingTable&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the encoding table. May be set to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although the encoding table defines how the image is compressed it is not
+ * essential. If an FSDefineJPEGImage3 object is created with an empty encoding
+ * table then the Flash Player will still display the JPEG image correctly. The
+ * empty encoding table is not a null object. It contains four bytes: 0xFF,
+ * 0xD8, 0xFF, 0xD9. For convenience passing a null reference to any of the
+ * constructors or to the setEncodingTable method will create an empty table.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSDefineJPEGImage2 class is to use the
+ * constructor that specifies the JPEG file to initialise the object:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSDefineJPEGImage2(movie.newIdentifier(), bytes));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This generates an object with an empty encoding table, however the image will
+ * still be displayed correctly.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineJPEGImage2 class represents the DefineBitsJPEG2 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
+ */
+public class FSDefineJPEGImage2 extends FSDefineObject
+{
+	private int width;
+	private int height;
+	private byte[] image = null;
+	private byte[] encodingTable = null;
 
-&lt;p&gt;It extends the FSDefineJPEGImage class by including a separate encoding table,
-rather than using an FSJPEGEncodingTable object to store the encoding table.
-This allows multiple JPEG images with different amounts of compression to be
-included within a Flash file.&lt;/p&gt;
+	/**
+	 * Construct an FSDefineJPEGImage2 object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineJPEGImage2(FSCoder coder)
+	{
+		super(DefineJPEGImage2, 0);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image
+	 * data and JPEG encoding table data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param imageBytes
+	 *            the JPEG encoded image data.
+	 * @param encodingBytes
+	 *            the JPEG encoded encoding table.
+	 */
+	public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes,
+								byte[] encodingBytes)
+	{
+		super(DefineJPEGImage2, anIdentifier);
+		setImage(imageBytes);
+		setEncodingTable(encodingBytes);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image
+	 * data and JPEG encoding table data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param imageBytes
+	 *            the JPEG encoded image data.
+	 */
+	public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes)
+	{
+		super(DefineJPEGImage2, anIdentifier);
+		setImage(imageBytes);
+		setEncodingTable(null);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage2 object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage2 object.
+	 */
+	public FSDefineJPEGImage2(FSDefineJPEGImage2 obj)
+	{
+		super(obj);
+		image = Transform.clone(obj.image);
+		width = obj.width;
+		height = obj.height;
+		encodingTable = Transform.clone(obj.encodingTable);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the
-image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the width of the image in pixels.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_2&quot;&gt;image&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the height of the image in pixels.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage2_3&quot;&gt;encodingTable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the encoding table. May be set to null.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the image data.
+	 * 
+	 * @return the array of bytes containing the image data.
+	 */
+	public byte[] getImage()
+	{
+		return image;
+	}
 
-&lt;p&gt;Although the encoding table defines how the image is compressed it is not
-essential. If an FSDefineJPEGImage3 object is created with an empty encoding
-table then the Flash Player will still display the JPEG image correctly. The
-empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8,
-0xFF, 0xD9. For convenience passing a null reference to any of the constructors
-or to the setEncodingTable method will create an empty table.&lt;/p&gt;
+	/**
+	 * Gets the encoding table.
+	 * 
+	 * @return the array of bytes containing the encoding table.
+	 */
+	public byte[] getEncodingTable()
+	{
+		return encodingTable;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the image data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the image data.
+	 */
+	public void setImage(byte[] bytes)
+	{
+		image = bytes;
+		decodeInfo();
+	}
 
-&lt;p&gt;The simplest way to use the FSDefineJPEGImage2 class is to use the constructor
-that specifies the JPEG file to initialise the object:&lt;/p&gt;
+	/**
+	 * Sets the encoding table.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the encoding table.
+	 */
+	public void setEncodingTable(byte[] bytes)
+	{
+		if (bytes == null)
+		{
+			bytes = new byte[]
+			{
+				(byte) 0xFF, (byte) 0xD9, (byte) 0xFF, (byte) 0xD8 };
+		}
+		encodingTable = bytes;
+	}
 
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
+	public Object clone()
+	{
+		FSDefineJPEGImage2 anObject = (FSDefineJPEGImage2) super.clone();
 
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);
-    imageContents.read(bytes);
-    imageContents.close();
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
+		anObject.image = Transform.clone(image);
+		anObject.width = width;
+		anObject.height = height;
+		anObject.encodingTable = Transform.clone(encodingTable);
 
-movie.add(new FSDefineJPEGImage2(movie.newIdentifier(), bytes));
-&lt;/pre&gt;
+		return anObject;
+	}
 
-&lt;p&gt;This generates an object with an empty encoding table, however the image will still be displayed correctly.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSDefineJPEGImage2 typedObject = (FSDefineJPEGImage2) anObject;
 
-&lt;p&gt;The FSDefineJPEGImage2 class represents the DefineBitsJPEG2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSDefineJPEGImage2 extends FSDefineObject
-{
-    private int width;
-    private int height;
-    private byte[] image = null;
-    private byte[] encodingTable = null;
+			result = Transform.equals(image, typedObject.image);
+			result = result
+							&amp;&amp; Transform.equals(encodingTable,
+											typedObject.encodingTable);
+		}
+		return result;
+	}
 
-    /**
-     * Construct an FSDefineJPEGImage2 object, initalizing it with values decoded
-     * from an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineJPEGImage2(FSCoder coder)
-    {
-        super(DefineJPEGImage2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image data and JPEG encoding table data.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param anIdentifier    the unique identifier for this object
-        @param imageBytes the JPEG encoded image data.
-        @param encodingBytes the JPEG encoded encoding table.
-        */
-    public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes, byte[] encodingBytes)
-    {
-        super(DefineJPEGImage2, anIdentifier);
-        setImage(imageBytes);
-        setEncodingTable(encodingBytes);
-    }
-    /** Constructs an FSDefineJPEGImage2 object with the identifier, JPEG image data and JPEG encoding table data.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
+			Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param imageBytes the JPEG encoded image data.
-        */
-    public FSDefineJPEGImage2(int anIdentifier, byte[] imageBytes)
-    {
-        super(DefineJPEGImage2, anIdentifier);
-        setImage(imageBytes);
-        setEncodingTable(null);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage2 object by copying values from an
-     * existing object.
-     *
-     * @param obj an FSDefineJPEGImage2 object.
-     */
-    public FSDefineJPEGImage2(FSDefineJPEGImage2 obj)
-    {
-        super(obj);
-        image = Transform.clone(obj.image);
-        width = obj.width;
-        height = obj.height;
-        encodingTable = Transform.clone(obj.encodingTable);
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** 
-     * Gets the width of the image in pixels. 
-     * 
-     * @return the width of the image.
-     */
-    public int getWidth()
-    {
-        return width; 
-    }    
-    /** 
-     * Gets the height of the image in pixels.
-     * 
-     * @return the height of the image in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }
-    /** Gets the image data.
+		length += encodingTable.length;
+		length += image.length;
 
-        @return the array of bytes containing the image data.
-        */
-    public byte[] getImage() { return image; }
+		return length;
+	}
 
-    /** Gets the encoding table.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(encodingTable);
+		coder.writeBytes(image);
+		coder.endObject(name());
+	}
 
-        @return the array of bytes containing the encoding table.
-        */
-    public byte[] getEncodingTable()  { return encodingTable; }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		setEncodingTable(readJPEGStream(coder));
+		byte[] data = new byte[length - encodingTable.length - 2];
+		coder.readBytes(data);
+		setImage(data);
+		coder.endObject(name());
+	}
 
-    /** Sets the image data.
+	private byte[] readJPEGStream(FSCoder coder)
+	{
+		byte bytes[] = null;
 
-        @param bytes an array of bytes containing the image data.
-        */
-    public void setImage(byte[] bytes)
-    {
-        image = bytes;
-        decodeInfo();
-    }
+		int start = coder.getPointer();
+		int end = start + ((length - 2) &lt;&lt; 3);
+		int word = coder.readBits(16, false);
+		int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
 
-    /** Sets the encoding table.
+		do
+		{
+			word = coder.scanBits(16, false);
 
-        @param bytes an array of bytes containing the encoding table.
-        */
-    public void setEncodingTable(byte[] bytes)
-    {
-        if (bytes == null) {
-            bytes = new byte[] { (byte)0xFF, (byte)0xD9, (byte)0xFF, (byte)0xD8 };
-        }
-        encodingTable = bytes;
-    }
+			if (word == eoi)
+			{
+				end = coder.getPointer() + 16;
+				break;
+			}
+			coder.adjustPointer(8);
+		} while (coder.getPointer() &lt; end);
 
-    public Object clone()
-    {
-        FSDefineJPEGImage2 anObject = (FSDefineJPEGImage2)super.clone();
+		int len = (end - start) &gt;&gt;&gt; 3;
 
-        anObject.image = Transform.clone(image);
-        anObject.width = width;
-        anObject.height = height;
-        anObject.encodingTable = Transform.clone(encodingTable);
+		coder.setPointer(start);
+		bytes = new byte[len];
+		coder.readBytes(bytes);
 
-        return anObject;
-    }
+		return bytes;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+	private boolean decodeInfo()
+	{
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
 
-        if (super.equals(anObject))
-        {
-            FSDefineJPEGImage2 typedObject = (FSDefineJPEGImage2)anObject;
+		if (coder.readWord(2, false) != 0xffd8)
+			return false;
 
-            result = Transform.equals(image, typedObject.image);
-            result = result &amp;&amp; Transform.equals(encodingTable, typedObject.encodingTable);
-        }
-        return result;
-    }
+		while (true)
+		{
+			int marker = coder.readWord(2, false);
+			int size = coder.readWord(2, false);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+			if ((marker &amp; 0xff00) != 0xff00)
+				return false;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
-            Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += encodingTable.length;
-        length += image.length;
-
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(encodingTable);
-        coder.writeBytes(image);
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        setEncodingTable(readJPEGStream(coder));
-        byte[] data = new byte[length-encodingTable.length-2];
-        coder.readBytes(data);
-        setImage(data);
-        coder.endObject(name());
-    }
-
-    private byte[] readJPEGStream(FSCoder coder)
-    {
-        byte bytes[] = null;
-        
-        int start = coder.getPointer();
-        int end = start + ((length-2) &lt;&lt; 3);
-        int word = coder.readBits(16, false);
-        int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
-
-        do {
-            word = coder.scanBits(16, false);
-
-            if (word == eoi)
-            {
-                end = coder.getPointer()+16;
-                break;
-            }
-            coder.adjustPointer(8);
-        }
-        while (coder.getPointer() &lt; end);
-
-        int len = (end-start) &gt;&gt;&gt; 3;
-
-        coder.setPointer(start);
-        bytes = new byte[len];
-        coder.readBytes(bytes);
-
-        return bytes;
-    }
-
-    private boolean decodeInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
-
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readWord(1, false);
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4
+							&amp;&amp; marker != 0xffc8)
+			{
+				coder.readWord(1, false);
+				height = coder.readWord(2, false);
+				width = coder.readWord(2, false);
+				return true;
+			} else
+			{
+				coder.adjustPointer((size - 2) &lt;&lt; 3);
+			}
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineJPEGImage3.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,356 +31,413 @@
 package com.flagstone.transform;
 
 /**
-FSDefineJPEGImage3 is used to define a transparent JPEG encoded image.
-
-&lt;p&gt;It extends the FSDefineJPEGImage3 class by including a separate zlib compressed table of alpha channel values. This allows the transparency of existing JPEG encoded images to be changed without re-encoding the original image.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the image from other objects.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_2&quot;&gt;image&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_3&quot;&gt;encodingTable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the encoding table.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineJPEGImage3_3&quot;&gt;alpha&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the zlib encoded alpha channel data for each
-pixel in the image.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
-
-&lt;p&gt;Although the encoding table defines how the image is compressed it is not
-essential. If an FSDefineJPEGImage3 object is created with an empty encoding
-table then the Flash Player will still display the JPEG image correctly. The
-empty encoding table is not a null object. It contains four bytes: 0xFF, 0xD8,
-0xFF, 0xD9. For convenience passing a null reference to any of the constructors
-or to the setEncodingTable method will create an empty table.&lt;/p&gt;
-
-&lt;p&gt;The simplest way to use the FSDefineJPEGImage3 class is to use the constructor
-that specifies the JPEG file to initialise the object:&lt;/p&gt;
-
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
-byte[] alpha = new byte[width*height];
-byte[] compressedAlpha = null;
-
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);
-    imageContents.read(bytes);
-    imageContents.close();
-
-    // Set the level of transparency;
-
-    for (int i=0; i&lt;bytes.length; i++)
-        alpha[i] = (byte)128;
-
-    Deflater deflater = new Deflater();
-
-    byte[] tmp = new byte[alpha.length];
-
-    deflater.setInput(alpha);
-    deflater.finish();
-
-    int bytesCompressed = deflater.deflate(tmp);
-
-    compressedAlpha = new byte[bytesCompressed];
-
-    for (int i=0; i&lt;bytesCompressed; i++)
-        compressedAlpha[i] = tmp[i];
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
-
-movie.add(new FSDefineJPEGImage3(movie.newIdentifier(), bytes, null, compressedAlpha));
-&lt;/pre&gt;
-
-&lt;p&gt;This generates an object with an empty encoding table, however the image will
-still be displayed correctly. The empty encoding table is not a null object. The
-alpha channel data is set so the image is completely opaque.&lt;/P&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSDefineJPEGImage3 class represents the DefineBitsJPEG3 tag from the
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
+ * FSDefineJPEGImage3 is used to define a transparent JPEG encoded image.
+ * 
+ * &lt;p&gt;
+ * It extends the FSDefineJPEGImage3 class by including a separate zlib
+ * compressed table of alpha channel values. This allows the transparency of
+ * existing JPEG encoded images to be changed without re-encoding the original
+ * image.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the image from other objects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;image&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the JPEG compressed image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodingTable&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the encoding table.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;alpha&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the zlib encoded alpha channel data for
+ * each pixel in the image.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although the encoding table defines how the image is compressed it is not
+ * essential. If an FSDefineJPEGImage3 object is created with an empty encoding
+ * table then the Flash Player will still display the JPEG image correctly. The
+ * empty encoding table is not a null object. It contains four bytes: 0xFF,
+ * 0xD8, 0xFF, 0xD9. For convenience passing a null reference to any of the
+ * constructors or to the setEncodingTable method will create an empty table.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSDefineJPEGImage3 class is to use the
+ * constructor that specifies the JPEG file to initialise the object:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * byte[] alpha = new byte[width * height];
+ * byte[] compressedAlpha = null;
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * 
+ * 	// Set the level of transparency;
+ * 
+ * 	for (int i = 0; i &lt; bytes.length; i++)
+ * 		alpha[i] = (byte) 128;
+ * 
+ * 	Deflater deflater = new Deflater();
+ * 
+ * 	byte[] tmp = new byte[alpha.length];
+ * 
+ * 	deflater.setInput(alpha);
+ * 	deflater.finish();
+ * 
+ * 	int bytesCompressed = deflater.deflate(tmp);
+ * 
+ * 	compressedAlpha = new byte[bytesCompressed];
+ * 
+ * 	for (int i = 0; i &lt; bytesCompressed; i++)
+ * 		compressedAlpha[i] = tmp[i];
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSDefineJPEGImage3(movie.newIdentifier(), bytes, null,
+ * 				compressedAlpha));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This generates an object with an empty encoding table, however the image will
+ * still be displayed correctly. The empty encoding table is not a null object.
+ * The alpha channel data is set so the image is completely opaque.
+ * &lt;/P&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineJPEGImage3 class represents the DefineBitsJPEG3 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
  */
 public class FSDefineJPEGImage3 extends FSDefineObject
 {
-    private int width;
-    private int height;
-    private byte[] image = null;
-    private byte[] encodingTable = null;
-    private byte[] alpha = null;
+	private int width;
+	private int height;
+	private byte[] image = null;
+	private byte[] encodingTable = null;
+	private byte[] alpha = null;
 
-    /**
-     * Construct an FSDefineJPEGImage3 object, initalizing it with values
-     * decoded from an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineJPEGImage3(FSCoder coder)
-    {
-        super(DefineJPEGImage3, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineJPEGImage3 object with the specified image data, encoding table and
-        alpha channel data.
+	/**
+	 * Construct an FSDefineJPEGImage3 object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineJPEGImage3(FSCoder coder)
+	{
+		super(DefineJPEGImage3, 0);
+		decode(coder);
+	}
 
-        @param anIdentifier    the unique identifier for this object
-        @param imageBytes byte array containing the image data
-        @param encodingBytes byte array containing the encoding table
-        @param alphaBytes byte array containing the zlib compressed alpha channel data
-        */
-    public FSDefineJPEGImage3(int anIdentifier, byte[] imageBytes, byte[] encodingBytes, byte[] alphaBytes)
-    {
-        super(DefineJPEGImage3, anIdentifier);
-        setImage(imageBytes);
-        setEncodingTable(encodingBytes);
-        setCompressedAlpha(alphaBytes);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing
-     * object.
-     *
-     * @param obj an FSDefineJPEGImage object.
-     */
-    public FSDefineJPEGImage3(FSDefineJPEGImage3 obj)
-    {
-        super(obj);
-        image = Transform.clone(obj.image);
-        width = obj.width;
-        height = obj.height;
-        encodingTable = Transform.clone(obj.encodingTable);
-        alpha = Transform.clone(obj.alpha);
-    }
+	/**
+	 * Constructs an FSDefineJPEGImage3 object with the specified image data,
+	 * encoding table and alpha channel data.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param imageBytes
+	 *            byte array containing the image data
+	 * @param encodingBytes
+	 *            byte array containing the encoding table
+	 * @param alphaBytes
+	 *            byte array containing the zlib compressed alpha channel data
+	 */
+	public FSDefineJPEGImage3(int anIdentifier, byte[] imageBytes,
+								byte[] encodingBytes, byte[] alphaBytes)
+	{
+		super(DefineJPEGImage3, anIdentifier);
+		setImage(imageBytes);
+		setEncodingTable(encodingBytes);
+		setCompressedAlpha(alphaBytes);
+	}
 
-    /** Gets the encoding table.
+	/**
+	 * Constructs an FSDefineJPEGImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage object.
+	 */
+	public FSDefineJPEGImage3(FSDefineJPEGImage3 obj)
+	{
+		super(obj);
+		image = Transform.clone(obj.image);
+		width = obj.width;
+		height = obj.height;
+		encodingTable = Transform.clone(obj.encodingTable);
+		alpha = Transform.clone(obj.alpha);
+	}
 
-        @return the array of bytes containing the encoding table.
-        */
-    public byte[] getEncodingTable()  { return encodingTable; }
+	/**
+	 * Gets the encoding table.
+	 * 
+	 * @return the array of bytes containing the encoding table.
+	 */
+	public byte[] getEncodingTable()
+	{
+		return encodingTable;
+	}
 
-    /** 
-     * Gets the width of the image in pixels. 
-     * 
-     * @return the width of the image.
-     */
-    public int getWidth()
-    {
-        return width; 
-    }    
-    /** 
-     * Gets the height of the image in pixels.
-     * 
-     * @return the height of the image in pixels.
-     */
-    public int getHeight()
-    {
-        return height;
-    }
+	/**
+	 * Gets the width of the image in pixels.
+	 * 
+	 * @return the width of the image.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-    /** Gets the image data.
+	/**
+	 * Gets the height of the image in pixels.
+	 * 
+	 * @return the height of the image in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-        @return the array of bytes containing the image data.
-        */
-    public byte[] getImage() { return image; }
+	/**
+	 * Gets the image data.
+	 * 
+	 * @return the array of bytes containing the image data.
+	 */
+	public byte[] getImage()
+	{
+		return image;
+	}
 
-    /** Gets the alpha channel data.
+	/**
+	 * Gets the alpha channel data.
+	 * 
+	 * @return the array of bytes containing the zlib compressed alpha data.
+	 */
+	public byte[] getCompressedAlpha()
+	{
+		return alpha;
+	}
 
-        @return the array of bytes containing the zlib compressed alpha data.
-        */
-    public byte[] getCompressedAlpha()  { return alpha; }
+	/**
+	 * Sets the encoding table.
+	 * 
+	 * @param bytes
+	 *            byte array containing the encoding table.
+	 */
+	public void setEncodingTable(byte[] bytes)
+	{
+		if (bytes == null)
+		{
+			bytes = new byte[]
+			{
+				(byte) 0xFF, (byte) 0xD9, (byte) 0xFF, (byte) 0xD8 };
+		}
+		encodingTable = bytes;
+	}
 
-    /** Sets the encoding table.
+	/**
+	 * Sets the image data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the image table.
+	 */
+	public void setImage(byte[] bytes)
+	{
+		image = bytes;
+		decodeInfo();
+	}
 
-        @param bytes byte array containing the encoding table.
-        */
-    public void setEncodingTable(byte[] bytes)
-    {
-        if (bytes == null) {
-            bytes = new byte[] { (byte)0xFF, (byte)0xD9, (byte)0xFF, (byte)0xD8 };
-        }
-        encodingTable = bytes;
-    }
+	/**
+	 * Sets the alpha channel data with the zlib compressed data.
+	 * 
+	 * @param bytes
+	 *            array of bytes containing zlib encoded alpha channel.
+	 */
+	public void setCompressedAlpha(byte[] bytes)
+	{
+		alpha = bytes;
+	}
 
-    /** Sets the image data.
+	public Object clone()
+	{
+		FSDefineJPEGImage3 anObject = (FSDefineJPEGImage3) super.clone();
 
-        @param bytes an array of bytes containing the image table.
-        */
-    public void setImage(byte[] bytes)
-    {
-        image = bytes;
-        decodeInfo();
-    }
+		anObject.image = Transform.clone(image);
+		anObject.encodingTable = Transform.clone(encodingTable);
+		anObject.alpha = Transform.clone(alpha);
 
-    /** Sets the alpha channel data with the zlib compressed data.
+		return anObject;
+	}
 
-        @param bytes array of bytes containing zlib encoded alpha channel.
-        */
-    public void setCompressedAlpha(byte[] bytes)
-    {
-        alpha = bytes;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public Object clone()
-    {
-        FSDefineJPEGImage3 anObject = (FSDefineJPEGImage3)super.clone();
+		if (super.equals(anObject))
+		{
+			FSDefineJPEGImage3 typedObject = (FSDefineJPEGImage3) anObject;
 
-        anObject.image = Transform.clone(image);
-        anObject.encodingTable = Transform.clone(encodingTable);
-        anObject.alpha = Transform.clone(alpha);
+			result = Transform.equals(image, typedObject.image);
+			result = result
+							&amp;&amp; Transform.equals(encodingTable,
+											typedObject.encodingTable);
+			result = result &amp;&amp; Transform.equals(alpha, typedObject.alpha);
+		}
+		return result;
+	}
 
-        return anObject;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
+			Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
+			Transform.append(buffer, &quot;alpha&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        if (super.equals(anObject))
-        {
-            FSDefineJPEGImage3 typedObject = (FSDefineJPEGImage3)anObject;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-            result = Transform.equals(image, typedObject.image);
-            result = result &amp;&amp; Transform.equals(encodingTable, typedObject.encodingTable);
-            result = result &amp;&amp; Transform.equals(alpha, typedObject.alpha);
-        }
-        return result;
-    }
+		length += 4;
+		length += encodingTable.length;
+		length += image.length;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		length += (alpha == null) ? 0 : alpha.length;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
-            Transform.append(buffer, &quot;image&quot;, &quot;&lt;data&gt;&quot;);
-            Transform.append(buffer, &quot;alpha&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		return length;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        length += 4;
-        length += encodingTable.length;
-        length += image.length;
+		coder.writeWord(encodingTable.length + image.length, 4);
+		coder.writeBytes(encodingTable);
+		coder.writeBytes(image);
 
-        length += (alpha == null) ? 0 : alpha.length;
+		if (alpha != null)
+			coder.writeBytes(alpha);
 
-        return length;
-    }
+		coder.endObject(name());
+	}
 
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        coder.writeWord(encodingTable.length+image.length, 4);
-        coder.writeBytes(encodingTable);
-        coder.writeBytes(image);
+		int offset = coder.readWord(4, false);
 
-        if (alpha != null)
-            coder.writeBytes(alpha);
+		setEncodingTable(readJPEGStream(coder));
+		byte[] imageIn = new byte[offset - encodingTable.length];
+		coder.readBytes(imageIn);
+		setImage(imageIn);
+		byte[] alphaIn = new byte[length - offset - 6];
+		coder.readBytes(alphaIn);
+		setCompressedAlpha(alphaIn);
 
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+	private byte[] readJPEGStream(FSCoder coder)
+	{
+		byte bytes[] = null;
 
-        int offset = coder.readWord(4, false);
+		int start = coder.getPointer();
+		int end = start + ((length - 2) &lt;&lt; 3);
+		int word = coder.readBits(16, false);
+		int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
 
-        setEncodingTable(readJPEGStream(coder));
-        byte[] imageIn = new byte[offset-encodingTable.length];
-        coder.readBytes(imageIn);
-        setImage(imageIn);
-        byte[] alphaIn = new byte[length-offset-6];
-        coder.readBytes(alphaIn);
-         setCompressedAlpha(alphaIn);
+		do
+		{
+			word = coder.scanBits(16, false);
 
-        coder.endObject(name());
-    }
+			if (word == eoi)
+			{
+				end = coder.getPointer() + 16;
+				break;
+			}
+			coder.adjustPointer(8);
+		} while (coder.getPointer() &lt; end);
 
-    private byte[] readJPEGStream(FSCoder coder)
-    {
-        byte bytes[] = null;
-        
-        int start = coder.getPointer();
-        int end = start + ((length-2) &lt;&lt; 3);
-        int word = coder.readBits(16, false);
-        int eoi = word == 0xFFD8 ? 0xFFD9 : 0xFFD8;
+		int len = (end - start) &gt;&gt;&gt; 3;
 
-        do {
-            word = coder.scanBits(16, false);
+		coder.setPointer(start);
+		bytes = new byte[len];
+		coder.readBytes(bytes);
 
-            if (word == eoi)
-            {
-                end = coder.getPointer()+16;
-                break;
-            }
-            coder.adjustPointer(8);
-        }
-        while (coder.getPointer() &lt; end);
+		return bytes;
+	}
 
-        int len = (end-start) &gt;&gt;&gt; 3;
+	private boolean decodeInfo()
+	{
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
 
-        coder.setPointer(start);
-        bytes = new byte[len];
-        coder.readBytes(bytes);
+		if (coder.readWord(2, false) != 0xffd8)
+			return false;
 
-        return bytes;
-    }
-    private boolean decodeInfo()
-    {
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, image);
-                 
-        if (coder.readWord(2, false) != 0xffd8)
-            return false;
+		while (true)
+		{
+			int marker = coder.readWord(2, false);
+			int size = coder.readWord(2, false);
 
-        while (true) 
-        {
-            int marker = coder.readWord(2, false);
-            int size = coder.readWord(2, false);
-            
-            if ((marker &amp; 0xff00) != 0xff00) 
-                return false;
-            
-            if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4 &amp;&amp; marker != 0xffc8) 
-            {
-                coder.readWord(1, false);
-                height = coder.readWord(2, false);
-                width = coder.readWord(2, false);
-                return true;
-            } 
-            else 
-            {
-                coder.adjustPointer((size - 2) &lt;&lt; 3);
-            }
-        }
-    }
+			if ((marker &amp; 0xff00) != 0xff00)
+				return false;
+
+			if (marker &gt;= 0xffc0 &amp;&amp; marker &lt;= 0xffcf &amp;&amp; marker != 0xffc4
+							&amp;&amp; marker != 0xffc8)
+			{
+				coder.readWord(1, false);
+				height = coder.readWord(2, false);
+				width = coder.readWord(2, false);
+				return true;
+			} else
+			{
+				coder.adjustPointer((size - 2) &lt;&lt; 3);
+			}
+		}
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSDefineMorphShape.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineMorphShape.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineMorphShape.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,567 +33,683 @@
 import java.util.*;
 
 /**
-FSDefineMorphShape defines a shape that will morph from one form into another. 
- 
-&lt;p&gt;Only the start and end shapes are defined the Flash Player will perform the interpolation that transforms the shape at each staging in the morphing process.&lt;/p&gt;
+ * FSDefineMorphShape defines a shape that will morph from one form into
+ * another.
+ * 
+ * &lt;p&gt;
+ * Only the start and end shapes are defined the Flash Player will perform the
+ * interpolation that transforms the shape at each staging in the morphing
+ * process.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Morphing can be applied to any shape, however there are a few restrictions:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The start and end shapes must have the same number of edges (FSLine and
+ * FSCurve objects).&lt;/li&gt;
+ * &lt;li&gt;The fill style (Solid, Bitmap or Gradient) must be the same in the start
+ * and end shape.&lt;/li&gt;
+ * &lt;li&gt;If a bitmap fill style is used then the same image must be used in the
+ * start and end shapes.&lt;/li&gt;
+ * &lt;li&gt;If a gradient fill style is used then the gradient must contain the same
+ * number of points in the start and end shape.&lt;/li&gt;
+ * &lt;li&gt;The start and end shape must contain the same set of FSShapeStyle
+ * objects.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * To perform the morphing of a shape the shape is placed in the display list
+ * using a FSPlaceObject2 object. The ratio attribute in the FSPlaceObject2
+ * object defines the progress of the morphing process. The ratio ranges between
+ * 0.0 and 1.0 where 0 represents the start of the morphing process and 1.0, the
+ * end.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through the objects in an FSMovie
+ * object to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startBounds&lt;/td&gt;
+ * &lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is
+ * drawn at the start of the morph process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;endBounds&lt;/td&gt;
+ * &lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is
+ * drawn at the end of the morph process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startShape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe the shape at the start of the morphing
+ * process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;endShape&lt;/td&gt;
+ * &lt;td&gt;The shape at the end of the morphing process containing the FSLine and
+ * FSCurve objects that define the edges of the shape.FSShapeStyle objects may
+ * only be included if they are used to move the current point and may &lt;b&gt;not&lt;/b&gt;
+ * change the style being used to draw the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The edges may change their type when a shape is morphed. Straight edges can
+ * become curves and vice versa.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This simple example morphs a rectangle into a square. While this example is
+ * trivial it illustrates how the FSDefineMorphShape class is used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * This rectangle is 200 twips wide and 100 twips high, drawing using a black
+ * outline 1 twip wide and filled with a transparent red colour. The square is
+ * 150 x 150 twips. The origin of the shape is at the bottom left corner of the
+ * rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Create the bounding rectangle for the start shape (rectangle).
+ *  FSBounds startBounds = new FSBounds(0, 0, 200, 100);
+ * 
+ *  // Create the bounding rectangle for the end shape (square).
+ *  FSBounds endBounds = new FSBounds(0, 0, 150, 150);
+ * 
+ *  // Define the styles for the shape.
+ * 
+ *  ArrayList fillStyles = new ArrayList();
+ *  ArrayList lineStyles = new ArrayList();
+ * 
+ *  fillStyles.push_back(new FSSolidFill(new FSColor((FSColorTable.red)));
+ * 
+ *  lineStyles.push_back(new FSSolidLine(1, FColor.black()));
+ * 
+ *  // Draw the rectangle.
+ * 
+ *  FSShape rectangle = new FSShape();
+ * 
+ *  rectangle.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ *  rectangle.add(new FSLine(200,0));
+ *  rectangle.add(new FSLine(0,100));
+ *  rectangle.add(new FSLine(-200,0));
+ *  rectangle.add(new FSLine(0,-100));
+ * 
+ *  // Draw the square.
+ * 
+ *  FSShape square = new FSShape();
+ * 
+ *  square.add(new FSLine(150,0));
+ *  square.add(new FSLine(0,150));
+ *  square.add(new FSLine(-150,0));
+ *  square.add(new FSLine(0,-150));
+ * 
+ *  FSDefineMorphShape shape = FSDefineMorphShape(movie.newIdentifier(), startBounds, endBounds, fillStyles, lineStyles, rectangle, square);
+ * 
+ *  // The morphing process is controlled by the FSPlaceObject2 class using the ratio attribute.
+ *  // Place the shape on layer 1 of the display list at coordinates (0,0).
+ * 
+ *  movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 0,0));
+ *  movie.add(new FSShowFrame());
+ * 
+ *  // Morph the shape over 5 steps without changing its location.
+ * 
+ *  for (float i=0.2; i&lt;1.0; i+= 0.2)
+ *  {
+ *  movie.add(new FSPlaceObject2(1, i, 0,0));
+ *  movie.add(new FSShowFrame());
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineMorphShape class represents the DefineMorphShape tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineMorphShape extends FSDefineObject
+{
+	private FSBounds startBounds = null;
+	private FSBounds endBounds = null;
+	private ArrayList fillStyles = null;
+	private ArrayList lineStyles = null;
+	private FSShape startShape = null;
+	private FSShape endShape = null;
 
-&lt;p&gt;Morphing can be applied to any shape, however there are a few restrictions:&lt;/p&gt;
+	/**
+	 * Construct an FSDefineJPEGImage object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineMorphShape(FSCoder coder)
+	{
+		super(DefineMorphShape, 0);
+		decode(coder);
+	}
 
-&lt;ul&gt;
-&lt;li&gt;The start and end shapes must have the same number of edges (FSLine and FSCurve objects).&lt;/li&gt;
-&lt;li&gt;The fill style (Solid, Bitmap or Gradient) must be the same in the start and end shape.&lt;/li&gt;
-&lt;li&gt;If a bitmap fill style is used then the same image must be used in the start and end shapes.&lt;/li&gt;
-&lt;li&gt;If a gradient fill style is used then the gradient must contain the same number of points in the start and end shape.&lt;/li&gt;
-&lt;li&gt;The start and end shape must contain the same set of FSShapeStyle objects.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Constructs an FSDefineMorphShape object.
+	 * 
+	 * @param anIdentifier
+	 *            an unique identifier for this object.
+	 * @param startBounds
+	 *            the bounding rectangle enclosing the start shape.
+	 * @param endBounds
+	 *            the bounding rectangle enclosing the end shape.
+	 * @param fillStyleArray
+	 *            an array of FSMorphSolidFill, FSMorphBitmapFill and
+	 *            FSMorphGradientFill objects.
+	 * @param lineStyleArray
+	 *            an array of FSMorphLineStyle objects.
+	 * @param startShape
+	 *            the shape at the start of the morphing process.
+	 * @param endShape
+	 *            the shape at the end of the morphing process.
+	 */
+	public FSDefineMorphShape(int anIdentifier, FSBounds startBounds,
+								FSBounds endBounds, ArrayList fillStyleArray,
+								ArrayList lineStyleArray, FSShape startShape,
+								FSShape endShape)
+	{
+		super(DefineMorphShape, anIdentifier);
+		setStartBounds(startBounds);
+		setEndBounds(endBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setStartShape(startShape);
+		setEndShape(endShape);
+	}
 
-&lt;p&gt;To perform the morphing of a shape the shape is placed in the display list using a FSPlaceObject2 object. The ratio attribute in the FSPlaceObject2 object defines the progress of the morphing process. The ratio ranges between 0.0 and 1.0 where 0 represents the start of the morphing process and 1.0, the end.&lt;/p&gt;
+	/**
+	 * Constructs an FSDefineJPEGImage object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineJPEGImage object.
+	 */
+	public FSDefineMorphShape(FSDefineMorphShape obj)
+	{
+		super(obj);
+		startBounds = new FSBounds(obj.startBounds);
+		endBounds = new FSBounds(obj.endBounds);
 
-&lt;table class=&quot;datasheet&quot;&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through the objects in an FSMovie object to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+		lineStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_2&quot;&gt;startBounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is drawn at the start of the morph process.&lt;/td&gt;
-&lt;/tr&gt;
+		startShape = new FSShape(obj.startShape);
+		endShape = new FSShape(obj.endShape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_3&quot;&gt;endBounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A rectangle (FSBounds) defining the bounding area in which the shape is drawn at the end of the morph process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a FSSolidLine object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSSolidLine object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_4&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            an FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_5&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the FSBounds object that defines the bounding rectangle enclosing
+	 * the start shape.
+	 * 
+	 * @return the bounds of the start shape.
+	 */
+	public FSBounds getStartBounds()
+	{
+		return startBounds;
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_6&quot;&gt;startShape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle objects) that describe the shape at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the FSBounds object that defines the bounding rectangle enclosing
+	 * the end shape.
+	 * 
+	 * @return the bounds of the end shape.
+	 */
+	public FSBounds getEndBounds()
+	{
+		return endBounds;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMorphShape_7&quot;&gt;endShape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The shape at the end of the morphing process containing the FSLine and FSCurve objects that define the edges of the shape.FSShapeStyle objects may only be included if they are used to move the current point and may &lt;b&gt;not&lt;/b&gt; change the style being used to draw the shape.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the array of FSMorphSolidFill, FSMorphBitmapFill and
+	 * FSMorphGradientFill objects that define the fill styles for the shapes.
+	 * 
+	 * @return the array morph fill styles.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-&lt;p&gt;The edges may change their type when a shape is morphed. Straight edges can become curves and vice versa.&lt;/p&gt;
+	/**
+	 * Gets the array of FSMorphLineStyle objects that define the line styles
+	 * for the shapes.
+	 * 
+	 * @return the array morph line styles.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the starting shape.
+	 * 
+	 * @return the start shape.
+	 */
+	public FSShape getStartShape()
+	{
+		return startShape;
+	}
 
-&lt;p&gt;This simple example morphs a rectangle into a square. While this example is trivial it illustrates how the FSDefineMorphShape class is used.&lt;/p&gt;
+	/**
+	 * Gets the ending shape.
+	 * 
+	 * @return the end shape.
+	 */
+	public FSShape getEndShape()
+	{
+		return endShape;
+	}
 
-&lt;p&gt;This rectangle is 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a transparent red colour. The square is 150 x 150 twips. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Sets the starting bounds of the shape.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the start shape.
+	 */
+	public void setStartBounds(FSBounds aBounds)
+	{
+		startBounds = aBounds;
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the start shape (rectangle).
-FSBounds startBounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Sets the ending bounds of the shape.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the end shape.
+	 */
+	public void setEndBounds(FSBounds aBounds)
+	{
+		endBounds = aBounds;
+	}
 
-// Create the bounding rectangle for the end shape (square).
-FSBounds endBounds = new FSBounds(0, 0, 150, 150);
+	/**
+	 * Sets the array of morph fill styles.
+	 * 
+	 * @param anArray
+	 *            an array of FSMorphSolidFill, FSMorphBitmapFill and
+	 *            FSMorphGradientFill objects.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Sets the array of morph line styles.
+	 * 
+	 * @param anArray
+	 *            an array of FSMorphLineStyle objects.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Sets the starting shape.
+	 * 
+	 * @param aShape
+	 *            the shape at the start of the morphing process.
+	 */
+	public void setStartShape(FSShape aShape)
+	{
+		startShape = aShape;
+	}
 
-fillStyles.push_back(new FSSolidFill(new FSColor((FSColorTable.red)));
+	/**
+	 * Sets the ending shape.
+	 * 
+	 * @param aShape
+	 *            the shape at the end of the morphing process.
+	 */
+	public void setEndShape(FSShape aShape)
+	{
+		endShape = aShape;
+	}
 
-lineStyles.push_back(new FSSolidLine(1, FColor.black()));
+	public Object clone()
+	{
+		FSDefineMorphShape anObject = (FSDefineMorphShape) super.clone();
 
-// Draw the rectangle.
+		anObject.startBounds = (startBounds != null) ? (FSBounds) startBounds
+						.clone() : null;
+		anObject.endBounds = (endBounds != null) ? (FSBounds) endBounds.clone()
+						: null;
 
-FSShape rectangle = new FSShape();
+		anObject.fillStyles = new ArrayList();
 
-rectangle.add(new FSShapeStyle(1, 1, 0, 0, 0));
-rectangle.add(new FSLine(200,0));
-rectangle.add(new FSLine(0,100));
-rectangle.add(new FSLine(-200,0));
-rectangle.add(new FSLine(0,-100));
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-// Draw the square.
+		anObject.lineStyles = new ArrayList();
 
-FSShape square = new FSShape();
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-square.add(new FSLine(150,0));
-square.add(new FSLine(0,150));
-square.add(new FSLine(-150,0));
-square.add(new FSLine(0,-150));
+		anObject.startShape = (startShape != null) ? (FSShape) startShape
+						.clone() : null;
+		anObject.endShape = (endShape != null) ? (FSShape) endShape.clone()
+						: null;
 
-FSDefineMorphShape shape = FSDefineMorphShape(movie.newIdentifier(), startBounds, endBounds, fillStyles, lineStyles, rectangle, square);
+		return anObject;
+	}
 
-// The morphing process is controlled by the FSPlaceObject2 class using the ratio attribute.
-// Place the shape on layer 1 of the display list at coordinates (0,0).
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 0,0));
-movie.add(new FSShowFrame());
+		if (super.equals(anObject))
+		{
+			FSDefineMorphShape typedObject = (FSDefineMorphShape) anObject;
 
-// Morph the shape over 5 steps without changing its location.
+			if (startBounds != null)
+				result = startBounds.equals(typedObject.startBounds);
+			else
+				result = startBounds == typedObject.startBounds;
 
-for (float i=0.2; i&lt;1.0; i+= 0.2)
-{
-    movie.add(new FSPlaceObject2(1, i, 0,0));
-    movie.add(new FSShowFrame());
-}
-&lt;/pre&gt;
+			if (endBounds != null)
+				result = result &amp;&amp; endBounds.equals(typedObject.endBounds);
+			else
+				result = result &amp;&amp; endBounds == typedObject.endBounds;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-&lt;p&gt;The FSDefineMorphShape class represents the DefineMorphShape tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineMorphShape extends FSDefineObject
-{
-    private FSBounds startBounds = null;
-    private FSBounds endBounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape startShape = null;
-    private FSShape endShape = null;
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-    /**
-     * Construct an FSDefineJPEGImage object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineMorphShape(FSCoder coder)
-    {
-        super(DefineMorphShape, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineMorphShape object.
+			if (startShape != null)
+				result = result &amp;&amp; startShape.equals(typedObject.startShape);
+			else
+				result = result &amp;&amp; startShape == typedObject.startShape;
 
-        @param anIdentifier an unique identifier for this object.
-        @param startBounds the bounding rectangle enclosing the start shape.
-        @param endBounds the bounding rectangle enclosing the end shape.
-        @param fillStyleArray an array of FSMorphSolidFill, FSMorphBitmapFill and FSMorphGradientFill objects.
-        @param lineStyleArray an array of FSMorphLineStyle objects.
-        @param startShape the shape at the start of the morphing process.
-        @param endShape the shape at the end of the morphing process.
-        */
-    public FSDefineMorphShape(int anIdentifier, FSBounds startBounds, FSBounds endBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape startShape, FSShape endShape)
-    {
-        super(DefineMorphShape, anIdentifier);
-        setStartBounds(startBounds);
-        setEndBounds(endBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setStartShape(startShape);
-        setEndShape(endShape);
-    }
-    /**
-     * Constructs an FSDefineJPEGImage object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineJPEGImage object.
-     */
-    public FSDefineMorphShape(FSDefineMorphShape obj)
-    {
-        super(obj);
-        startBounds = new FSBounds(obj.startBounds);
-        endBounds = new FSBounds(obj.endBounds);
+			if (endShape != null)
+				result = result &amp;&amp; endShape.equals(typedObject.endShape);
+			else
+				result = result &amp;&amp; endShape == typedObject.endShape;
+		}
+		return result;
+	}
 
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;startBounds&quot;, startBounds, depth);
+			Transform.append(buffer, &quot;endBounds&quot;, endBounds, depth);
+			Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
+			Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
+			Transform.append(buffer, &quot;startShape&quot;, startShape, depth);
+			Transform.append(buffer, &quot;endShape&quot;, endShape, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        startShape = new FSShape(obj.startShape);
-        endShape = new FSShape(obj.endShape);
-    }
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Add a FSSolidLine object to the array of line styles.
+		super.length(coder);
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Add the fill style object to the array of fill styles.
+		length += startBounds.length(coder);
+		length += endBounds.length(coder);
+		length += 4;
 
-        @param aFillStyle an FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+		length += (fillStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Gets the FSBounds object that defines the bounding rectangle enclosing the start shape.
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-        @return the bounds of the start shape.
-        */
-    public FSBounds getStartBounds() { return startBounds; }
+		length += (lineStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Gets the FSBounds object that defines the bounding rectangle enclosing the end shape.
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-        @return the bounds of the end shape.
-        */
-    public FSBounds getEndBounds() { return endBounds; }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    /** Gets the array of FSMorphSolidFill, FSMorphBitmapFill and FSMorphGradientFill objects that define the fill styles for the shapes.
+		length += startShape.length(coder);
 
-        @return the array morph fill styles.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+		// Number of Fill and Line bits is zero for end shape.
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    /** Gets the array of FSMorphLineStyle objects that define the line styles for the shapes.
+		length += endShape.length(coder);
 
-        @return the array morph line styles.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.TransparentColors] = 0;
 
-    /** Gets the starting shape.
+		return length;
+	}
 
-        @return the start shape.
-        */
-    public FSShape getStartShape() { return startShape; }
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Gets the ending shape.
+		super.encode(coder);
 
-        @return the end shape.
-        */
-    public FSShape getEndShape() { return endShape; }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Sets the starting bounds of the shape.
+		startBounds.encode(coder);
+		endBounds.encode(coder);
 
-        @param aBounds the bounding rectangle enclosing the start shape.
-        */
-    public void setStartBounds(FSBounds aBounds)
-    {
-        startBounds = aBounds;
-    }
+		int offsetStart = coder.getPointer();
+		coder.writeWord(0, 4);
 
-    /** Sets the ending bounds of the shape.
+		if (fillStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(fillStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(fillStyles.size(), 1);
+		}
 
-        @param aBounds the bounding rectangle enclosing the end shape.
-        */
-    public void setEndBounds(FSBounds aBounds)
-    {
-        endBounds = aBounds;
-    }
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-    /** Sets the array of morph fill styles.
+		if (lineStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(lineStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(lineStyles.size(), 1);
+		}
 
-        @param anArray an array of FSMorphSolidFill, FSMorphBitmapFill and FSMorphGradientFill objects.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-    /** Sets the array of morph line styles.
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-        @param anArray an array of FSMorphLineStyle objects.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		startShape.encode(coder);
 
-    /** Sets the starting shape.
+		int offsetEnd = (coder.getPointer() - offsetStart) &gt;&gt; 3;
+		int currentCursor = coder.getPointer();
 
-        @param aShape the shape at the start of the morphing process.
-        */
-    public void setStartShape(FSShape aShape)
-    {
-        startShape = aShape;
-    }
+		coder.setPointer(offsetStart);
+		coder.writeWord(offsetEnd - 4, 4);
+		coder.setPointer(currentCursor);
 
-    /** Sets the ending shape.
+		// Number of Fill and Line bits is zero for end shape.
 
-        @param aShape the shape at the end of the morphing process.
-        */
-    public void setEndShape(FSShape aShape)
-    {
-        endShape = aShape;
-    }
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    public Object clone()
-    {
-        FSDefineMorphShape anObject = (FSDefineMorphShape)super.clone();
-        
-        anObject.startBounds = (startBounds != null) ? (FSBounds)startBounds.clone() : null;
-        anObject.endBounds = (endBounds != null) ? (FSBounds)endBounds.clone() : null;
+		endShape.encode(coder);
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.TransparentColors] = 0;
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		coder.endObject(name());
+	}
 
-        anObject.startShape = (startShape != null) ? (FSShape)startShape.clone() : null;
-        anObject.endShape = (endShape != null) ? (FSShape)endShape.clone() : null;
-        
-        return anObject;
-    }
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineMorphShape typedObject = (FSDefineMorphShape)anObject;
-            
-            if (startBounds != null)
-                result = startBounds.equals(typedObject.startBounds);
-            else
-                result = startBounds == typedObject.startBounds;
+		super.decode(coder);
 
-            if (endBounds != null)
-                result = result &amp;&amp; endBounds.equals(typedObject.endBounds);
-            else
-                result = result &amp;&amp; endBounds == typedObject.endBounds;
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		int start = coder.getPointer() - 16;
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		startBounds = new FSBounds(coder);
+		endBounds = new FSBounds(coder);
 
-            if (startShape != null)
-                result = result &amp;&amp; startShape.equals(typedObject.startShape);
-            else
-                result = result &amp;&amp; startShape == typedObject.startShape;
+		int offset = coder.readWord(4, false);
+		int first = coder.getPointer();
 
-            if (endShape != null)
-                result = result &amp;&amp; endShape.equals(typedObject.endShape);
-            else
-                result = result &amp;&amp; endShape == typedObject.endShape;
-        }
-        return result;
-    }
+		fillStyleCount = coder.readWord(1, false);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startBounds&quot;, startBounds, depth);
-            Transform.append(buffer, &quot;endBounds&quot;, endBounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;startShape&quot;, startShape, depth);
-            Transform.append(buffer, &quot;endShape&quot;, endShape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (coder.context[FSCoder.ArrayCountExtended] != 0
+						&amp;&amp; fillStyleCount == 0xFF)
+			fillStyleCount = coder.readWord(2, false);
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+		fillStyles = new ArrayList(fillStyleCount);
 
-        length += startBounds.length(coder);
-        length += endBounds.length(coder);
-        length += 4;
-        
-        length += (fillStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        length += (lineStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += startShape.length(coder);
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSMorphSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSMorphGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSMorphGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSMorphBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSMorphBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        // Number of Fill and Line bits is zero for end shape.
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		lineStyleCount = coder.readWord(1, false);
 
-        length += endShape.length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+		if (coder.context[FSCoder.ArrayCountExtended] != 0
+						&amp;&amp; lineStyleCount == 0xFF)
+			lineStyleCount = coder.readWord(2, false);
 
-        startBounds.encode(coder);
-        endBounds.encode(coder);
-    
-        int offsetStart = coder.getPointer();
-        coder.writeWord(0, 4);
+		lineStyles = new ArrayList(lineStyleCount);
 
-        if (fillStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(fillStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(fillStyles.size(), 1);
-        }
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        if (lineStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(lineStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(lineStyles.size(), 1);
-        }
-                
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        startShape.encode(coder);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSMorphSolidLine(coder));
 
-        int offsetEnd = (coder.getPointer() - offsetStart) &gt;&gt; 3;
-        int currentCursor = coder.getPointer();
-        
-        coder.setPointer(offsetStart);
-        coder.writeWord(offsetEnd-4, 4);
-        coder.setPointer(currentCursor);
+		int bytesDecoded = (coder.getPointer() - first) &gt;&gt; 3;
 
-        // Number of Fill and Line bits is zero for end shape.
-        
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		startShape = new FSShape(coder, offset - bytesDecoded);
 
-        endShape.encode(coder);
+		bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-         coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.TransparentColors] = 0;
+		endShape = new FSShape(coder, length - bytesDecoded);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        
-        int start = coder.getPointer()-16;
-        
-        startBounds = new FSBounds(coder);
-        endBounds = new FSBounds(coder);
-        
-        int offset = coder.readWord(4, false);
-        int first = coder.getPointer();
-
-        fillStyleCount = coder.readWord(1, false);
-
-        if (coder.context[FSCoder.ArrayCountExtended] != 0 &amp;&amp; fillStyleCount == 0xFF)
-            fillStyleCount = coder.readWord(2, false);
-            
-        fillStyles = new ArrayList(fillStyleCount);
-
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSMorphSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSMorphGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSMorphGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSMorphBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSMorphBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
-
-        if (coder.context[FSCoder.ArrayCountExtended] != 0 &amp;&amp; lineStyleCount == 0xFF)
-            lineStyleCount = coder.readWord(2, false);
-
-        lineStyles = new ArrayList(lineStyleCount);
-
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSMorphSolidLine(coder));
-        
-        int bytesDecoded = (coder.getPointer()-first) &gt;&gt; 3;
-
-        startShape = new FSShape(coder, offset-bytesDecoded);
-
-        bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
-
-        endShape = new FSShape(coder, length-bytesDecoded);
-
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineMovieClip.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineMovieClip.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineMovieClip.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,219 +33,261 @@
 import java.util.*;
 
 /**
-FSDefineMovieClip defines a movie clip that animates shapes within a movie. 
- 
-&lt;p&gt;It contains an array of movie objects that define the placement of shapes, buttons, text and images and the order in which they are displayed through a time-line that is separate from the parent movie.&lt;/p&gt;
+ * FSDefineMovieClip defines a movie clip that animates shapes within a movie.
+ * 
+ * &lt;p&gt;
+ * It contains an array of movie objects that define the placement of shapes,
+ * buttons, text and images and the order in which they are displayed through a
+ * time-line that is separate from the parent movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, for the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSMovieObject objects that define the commands that are
+ * executed by the Flash Player to animate the movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although a movie clip contains the commands that instructs the Flash Player
+ * on how to animate the clip it cannot contain any new definitions of objects.
+ * All definitions must be in the main movie. All objects referred to by the
+ * movie clip must be also defined in the main movie before they can be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When using the FSDefineMovieClip object can only contain objects from the
+ * following classes: FSShowFrame, FSPlaceObject, FSPlaceObject2,
+ * FSRemoveObject, FSRemoveObject2, FSDoAction, FSStartSound, FSFrameLabel,
+ * FSSoundStreamHead, FSSoundStreamHead2 or FSSoundStreamBlock. Other objects
+ * are not allowed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineMovieClip class represents the DefineSprite tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineMovieClip extends FSDefineObject
+{
+	private ArrayList objects = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineMovieClip object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineMovieClip(FSCoder coder)
+	{
+		super(DefineMovieClip, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineMovieClip object with the unique identifier. The
+	 * Array of objects used to control the movie is empty.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for the movie clip.
+	 */
+	public FSDefineMovieClip(int anIdentifier)
+	{
+		super(DefineMovieClip, anIdentifier);
+		setObjects(new ArrayList());
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMovieClip_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineMovieClip object with the unique identifier and
+	 * array of movie objects.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for the movie clip.
+	 * @param anArray
+	 *            the array of movie objects.
+	 */
+	public FSDefineMovieClip(int anIdentifier, ArrayList anArray)
+	{
+		super(DefineMovieClip, anIdentifier);
+		setObjects(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMovieClip_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, for the movie clip.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineMovieClip(FSDefineMovieClip obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineMovieClip_2&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSMovieObject objects that define the commands that are executed by the Flash Player to animate the movie clip.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		objects = new ArrayList();
 
-&lt;p&gt;Although a movie clip contains the commands that instructs the Flash Player on how to animate the clip it cannot contain any new definitions of objects. All definitions must be in the main movie. All objects referred to by the movie clip must be also defined in the main movie before they can be used.&lt;/p&gt;
+		for (Iterator i = obj.objects.iterator(); i.hasNext();)
+			objects.add(((FSMovieObject) i.next()).clone());
+	}
 
-&lt;p&gt;When using the FSDefineMovieClip object can only contain objects from the following classes: FSShowFrame, FSPlaceObject, FSPlaceObject2, FSRemoveObject, FSRemoveObject2, FSDoAction, FSStartSound, FSFrameLabel, FSSoundStreamHead, FSSoundStreamHead2 or FSSoundStreamBlock. Other objects are not allowed.&lt;/p&gt;
+	/**
+	 * Adds the movie object to the array of actions.
+	 * 
+	 * @param anObject
+	 *            an object belonging to a class derived from FSMovieObject.
+	 */
+	public void add(FSMovieObject anObject)
+	{
+		objects.add(anObject);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the array of movie objects.
+	 * 
+	 * @return the array of movie objects.
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-&lt;p&gt;The FSDefineMovieClip class represents the DefineSprite tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineMovieClip extends FSDefineObject
-{
-    private ArrayList objects = null;
+	/**
+	 * Sets the array of movie objects.
+	 * 
+	 * @param anArray
+	 *            the array of movie objects.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-    /**
-     * Construct an FSDefineMovieClip object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineMovieClip(FSCoder coder)
-    {
-        super(DefineMovieClip, 0);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSDefineMovieClip object with the unique identifier. The 
-     * Array of objects used to control the movie is empty.
-     * 
-     * @param anIdentifier a unique identifier for the movie clip.
-     */
-    public FSDefineMovieClip(int anIdentifier)
-    {
-        super(DefineMovieClip, anIdentifier);
-        setObjects(new ArrayList());
-    }
-    /** Constructs an FSDefineMovieClip object with the unique identifier and array of movie objects.
+	/**
+	 * Gets the total number of frames in the movie clip.
+	 * 
+	 * @return the number of frames.
+	 */
+	public int getFrameCount()
+	{
+		return numberOfFrames();
+	}
 
-        @param anIdentifier a unique identifier for the movie clip.
-        @param anArray the array of movie objects.
-        */
-    public FSDefineMovieClip(int anIdentifier, ArrayList anArray)
-    {
-        super(DefineMovieClip, anIdentifier);
-        setObjects(anArray);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineMovieClip(FSDefineMovieClip obj)
-    {
-        super(obj);
+	public Object clone()
+	{
+		FSDefineMovieClip anObject = (FSDefineMovieClip) super.clone();
 
-        objects = new ArrayList();
-        
-        for (Iterator i = obj.objects.iterator(); i.hasNext();)
-            objects.add(((FSMovieObject)i.next()).clone());
-    }
+		anObject.objects = new ArrayList();
 
-    /** Adds the movie object to the array of actions.
+		for (Iterator i = objects.iterator(); i.hasNext();)
+			anObject.objects.add(((FSMovieObject) i.next()).clone());
 
-        @param anObject an object belonging to a class derived from FSMovieObject.
-        */
-    public void add(FSMovieObject anObject)
-    {
-        objects.add(anObject);
-    }
+		return anObject;
+	}
 
-    /** Gets the array of movie objects.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the array of movie objects.
-        */
-    public ArrayList getObjects()  { return objects; }
+		if (super.equals(anObject))
+		{
+			FSDefineMovieClip typedObject = (FSDefineMovieClip) anObject;
 
-    /** Sets the array of movie objects.
+			if (objects != null)
+				result = objects.equals(typedObject.objects);
+			else
+				result = objects == typedObject.objects;
+		}
+		return result;
+	}
 
-        @param anArray the array of movie objects.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the total number of frames in the movie clip.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;objects&quot;, objects, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the number of frames.
-        */
-    public int getFrameCount()
-    {
-        return numberOfFrames();
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public Object clone()
-    {
-        FSDefineMovieClip anObject = (FSDefineMovieClip)super.clone();
-        
-        anObject.objects = new ArrayList();
-            
-        for (Iterator i = objects.iterator(); i.hasNext();)
-            anObject.objects.add(((FSMovieObject)i.next()).clone());
+		length += 4;
 
-        return anObject;
-    }
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject object = (FSMovieObject) i.next();
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineMovieClip typedObject = (FSDefineMovieClip)anObject;
-            
-            if (objects != null)
-                result = objects.equals(typedObject.objects);
-            else
-                result = objects == typedObject.objects;
-        }
-        return result;
-    }
+			int objectLength = object.length(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			length += (object.getExtendLength() || objectLength &gt;= 63) ? objectLength + 6
+							: objectLength + 2;
+		}
+		return length;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-            
-        length += 4;
-    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
-            
-            int objectLength = object.length(coder);
-            
-            length += (object.getExtendLength() || objectLength &gt;= 63) ? objectLength+6 : objectLength+2;
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(numberOfFrames(), 2);        
-        FSMovie.encodeObjects(coder, objects);
-        coder.writeWord(0, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        /* frameCount */ coder.readWord(2, false);
-    
-        objects = new ArrayList();
+		coder.writeWord(numberOfFrames(), 2);
+		FSMovie.encodeObjects(coder, objects);
+		coder.writeWord(0, 2);
+		coder.endObject(name());
+	}
 
-        FSMovieObject object = null; 
-        
-        while ((object = FSMovie.decodeObject(coder)) != null)
-        {
-            objects.add(object);
-        }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        coder.endObject(name());
-    }
-    
-    private int numberOfFrames() 
-    {
-        int numberOfFrames = 0;
-        
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject currentObject = (FSMovieObject)i.next();
-            
-            if (currentObject.getType() == FSMovieObject.ShowFrame)
-                numberOfFrames += 1;
-        }
-        return numberOfFrames;
-    }
+		/* frameCount */coder.readWord(2, false);
+
+		objects = new ArrayList();
+
+		FSMovieObject object = null;
+
+		while ((object = FSMovie.decodeObject(coder)) != null)
+		{
+			objects.add(object);
+		}
+
+		coder.endObject(name());
+	}
+
+	private int numberOfFrames()
+	{
+		int numberOfFrames = 0;
+
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject currentObject = (FSMovieObject) i.next();
+
+			if (currentObject.getType() == FSMovieObject.ShowFrame)
+				numberOfFrames += 1;
+		}
+		return numberOfFrames;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,77 +31,82 @@
 package com.flagstone.transform;
 
 /**
-The FSDefineObject is a base class for the different types of object used to 
-create images, buttons, shapes and sounds. Each such object contains a unique 
-identifier that is used to reference the object when performing operations 
-such as placing it in the display list using the FSPlaceObject class, etc. 
-The FSDefineObject manages the encoding and decoding of this identifier.
-
-Identifiers are unique within a given movie. The FSMovie class is maintains an 
-internal counter which is used to generate the identifiers that are assigned 
-to classes derived from FSDefineObject.
-
-Two accessor methods, getIdentifier() and setIdentifier() are used to retrieve 
-and update the unique identifier assigned to an object.
-*/
+ * The FSDefineObject is a base class for the different types of object used to
+ * create images, buttons, shapes and sounds. Each such object contains a unique
+ * identifier that is used to reference the object when performing operations
+ * such as placing it in the display list using the FSPlaceObject class, etc.
+ * The FSDefineObject manages the encoding and decoding of this identifier.
+ * 
+ * Identifiers are unique within a given movie. The FSMovie class is maintains
+ * an internal counter which is used to generate the identifiers that are
+ * assigned to classes derived from FSDefineObject.
+ * 
+ * Two accessor methods, getIdentifier() and setIdentifier() are used to
+ * retrieve and update the unique identifier assigned to an object.
+ */
 public abstract class FSDefineObject extends FSMovieObject
 {
-    protected int identifier = 0; 
-    
-    FSDefineObject(int type, int anIdentifier)
-    {
-        super(type);
-        setIdentifier(anIdentifier);
-    }
-    protected FSDefineObject(FSDefineObject obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-    }
-    
-    /** Returns the unique identifier assigned to this Define tag. 
+	protected int identifier = 0;
 
-        @return the unique identifier for the object.
-        */     
-    public int getIdentifier() 
-    {
-        return identifier;
-    }
+	FSDefineObject(int type, int anIdentifier)
+	{
+		super(type);
+		setIdentifier(anIdentifier);
+	}
 
-    /** Sets the identifier used to uniquely identify the object within a given FSMovie.
+	protected FSDefineObject(FSDefineObject obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+	}
 
-        @param anIdentifier a unique identifier for the object. 
-        */     
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        Transform.append(buffer, &quot;identifier&quot;, identifier);
-    }
+	/**
+	 * Returns the unique identifier assigned to this Define tag.
+	 * 
+	 * @return the unique identifier for the object.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-    }
+	/**
+	 * Sets the identifier used to uniquely identify the object within a given
+	 * FSMovie.
+	 * 
+	 * @param anIdentifier
+	 *            a unique identifier for the object.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
+
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		Transform.append(buffer, &quot;identifier&quot;, identifier);
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 2;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(identifier, 2);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		identifier = coder.readWord(2, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineShape.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineShape.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineShape.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,411 +33,474 @@
 import java.util.*;
 
 /**
-FSDefineShape defines a shape to be displayed.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSDefineShape defines a shape to be displayed.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The shape defines a path containing a mix of straight and curved edges and
+ * pen move actions. A path need not be contiguous. When the shape is drawn the
+ * FSShapeStyle object selects the line and fill styles, from the respective
+ * array, to be used. FSShapeStyle objects can be defined in the shape at any
+ * time to change the styles being used. The fill style used can either be a
+ * solid colour, a bitmap image or a gradient. The line style specifies the
+ * colour and thickness of the line drawn around the shape outline.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For both line and fill styles the selected style may be undefined, allowing
+ * the shape to be drawn without an outline or left unfilled.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This example creates a simple rectangle, 200 twips wide and 100 twips high,
+ * drawing using a black outline 1 twip wide and filled with a solid red colour.
+ * The origin of the shape is at the bottom left corner of the rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. The values also specify
+ * // the coordinate range of the shape.
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, 200, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+ * 
+ * lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0)));
+ * 
+ * // Draw the shape.
+ * 
+ * FSShape shape = new FSShape();
+ * 
+ * // Define the line, fill styles and move to the shape's origin.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(200, 0));
+ * shape.add(new FSLine(0, 100));
+ * shape.add(new FSLine(-200, 0));
+ * shape.add(new FSLine(0, -100));
+ * 
+ * FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineShape class represents the DefineShape tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineShape extends FSDefineObject
+{
+	private FSBounds bounds = null;
+	private ArrayList fillStyles = null;
+	private ArrayList lineStyles = null;
+	private FSShape shape = null;
 
-&lt;tr&gt;
-&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineShape object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineShape(FSCoder coder)
+	{
+		super(FSMovieObject.DefineShape, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the shape in the range 1..65535.
+	 * @param aBounds
+	 *            the bounding rectangle for the shape.
+	 * @param fillStyleArray
+	 *            the array of fill styles used in the shape.
+	 * @param lineStyleArray
+	 *            the array of line styles used in the shape.
+	 * @param aShape
+	 *            the shape to be drawn.
+	 */
+	public FSDefineShape(int anIdentifier, FSBounds aBounds,
+							ArrayList fillStyleArray, ArrayList lineStyleArray,
+							FSShape aShape)
+	{
+		super(FSMovieObject.DefineShape, anIdentifier);
+		setBounds(aBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setShape(aShape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineShape(FSDefineShape obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_3&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_4&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		lineStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape_5&quot;&gt;shape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle 
-objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;/table&gt;
+		shape = new FSShape(obj.shape);
+	}
 
-&lt;p&gt;The shape defines a path containing a mix of straight and curved edges and pen move actions. A path need not be contiguous. When the shape is drawn the FSShapeStyle object selects the line and fill styles, from the respective array, to be used. FSShapeStyle objects can be defined in the shape at any time to change the styles being used. The fill style used can either be a solid colour, a bitmap image or a gradient. The line style specifies the colour and thickness of the line drawn around the shape outline.&lt;/p&gt;
+	/**
+	 * Add a FSSolidLine object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSSolidLine object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;p&gt;For both line and fill styles the selected style may be undefined, allowing the shape to be drawn without an outline or left unfilled.&lt;/p&gt;
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the bounding rectangle for the shape.
+	 * 
+	 * @return the bounding rectangle for the shape.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;p&gt;This example creates a simple rectangle, 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a solid red colour. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Gets the array fill styles.
+	 * 
+	 * @return the fill styles used in the shape.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. The values also specify
-// the coordinate range of the shape.
+	/**
+	 * Gets the array line styles.
+	 * 
+	 * @return the line styles used in the shape.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-FSBounds bounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Gets the shape.
+	 * 
+	 * @return the shape to be drawn.
+	 */
+	public FSShape getShape()
+	{
+		return shape;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Sets the bounding rectangle.
+	 * 
+	 * @param aBounds
+	 *            set the bounding rectangle for the shape.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Sets the fill styles.
+	 * 
+	 * @param anArray
+	 *            set the fill styles for the shape.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+	/**
+	 * Sets the line styles.
+	 * 
+	 * @param anArray
+	 *            set the line styles for the shape.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0)));
+	/**
+	 * Sets the shape.
+	 * 
+	 * @param aShape
+	 *            set the shape to be drawn.
+	 */
+	public void setShape(FSShape aShape)
+	{
+		shape = aShape;
+	}
 
-// Draw the shape.
+	public Object clone()
+	{
+		FSDefineShape anObject = (FSDefineShape) super.clone();
 
-FSShape shape = new FSShape();
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
 
-// Define the line, fill styles and move to the shape's origin.
+		anObject.fillStyles = new ArrayList();
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(200,0));
-shape.add(new FSLine(0,100));
-shape.add(new FSLine(-200,0));
-shape.add(new FSLine(0,-100));
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
-&lt;/pre&gt;
+		anObject.lineStyles = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;p&gt;The FSDefineShape class represents the DefineShape tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineShape extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape shape = null;
+		anObject.shape = (shape != null) ? (FSShape) shape.clone() : null;
 
-    /**
-     * Construct an FSDefineShape object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineShape(FSCoder coder)
-    {
-        super(FSMovieObject.DefineShape, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineShape object.
+		return anObject;
+	}
 
-        @param anIdentifier the unique identifier for the shape in the range 1..65535.
-        @param aBounds the bounding rectangle for the shape.
-        @param fillStyleArray the array of fill styles used in the shape.
-        @param lineStyleArray the array of line styles used in the shape.
-        @param aShape the shape to be drawn.
-        */
-    public FSDefineShape(int anIdentifier, FSBounds aBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape aShape)
-    {
-        super(FSMovieObject.DefineShape, anIdentifier);
-        setBounds(aBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setShape(aShape);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineShape(FSDefineShape obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+		if (super.equals(anObject))
+		{
+			FSDefineShape typedObject = (FSDefineShape) anObject;
 
-        shape = new FSShape(obj.shape);
-    }
-    
-    /** Add a FSSolidLine object to the array of line styles.
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-    /** Add the fill style object to the array of fill styles.
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+			if (shape != null)
+				result = result &amp;&amp; shape.equals(typedObject.shape);
+			else
+				result = result &amp;&amp; shape == typedObject.shape;
+		}
+		return result;
+	}
 
-    /** Gets the bounding rectangle for the shape.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the bounding rectangle for the shape.
-        */
-    public FSBounds getBounds() { return bounds; }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
+			Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
+			Transform.append(buffer, &quot;shape&quot;, shape, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Gets the array fill styles.
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+		super.length(coder);
 
-    /** Gets the array line styles.
+		length += bounds.length(coder);
+		length += 1;
 
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-    /** Gets the shape.
+		length += 1;
 
-        @return the shape to be drawn.
-        */
-    public FSShape getShape() { return shape; }
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-    /** Sets the bounding rectangle.
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-        @param aBounds set the bounding rectangle for the shape.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		length += shape.length(coder);
 
-    /** Sets the fill styles.
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		return length;
+	}
 
-    /** Sets the line styles.
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		super.encode(coder);
 
-    /** Sets the shape.
+		bounds.encode(coder);
 
-        @param aShape set the shape to be drawn.
-        */
-    public void setShape(FSShape aShape)
-    {
-        shape = aShape;
-    }
+		coder.writeWord(fillStyles.size(), 1);
 
-    public Object clone()
-    {
-        FSDefineShape anObject = (FSDefineShape)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		coder.writeWord(lineStyles.size(), 1);
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-         anObject.shape = (shape != null) ? (FSShape)shape.clone() : null;
-        
-        return anObject;
-    }
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineShape typedObject = (FSDefineShape)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		shape.encode(coder);
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		coder.endObject(name());
+	}
 
-            if (shape != null)
-                result = result &amp;&amp; shape.equals(typedObject.shape);
-            else
-                result = result &amp;&amp; shape == typedObject.shape;
-        }
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;shape&quot;, shape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		super.decode(coder);
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.length(coder);
-    
-        length += bounds.length(coder);
-        length += 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-        
-        length += 1;
-        
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += shape.length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		int start = coder.getPointer() - 16; // account for identifier
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
+		bounds = new FSBounds(coder);
+		fillStyleCount = coder.readWord(1, false);
 
-        bounds.encode(coder);
-        
-        coder.writeWord(fillStyles.size(), 1);
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.writeWord(lineStyles.size(), 1);
+		fillStyles = new ArrayList(fillStyleCount);
 
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		fillStyles = new ArrayList();
 
-        shape.encode(coder);
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		lineStyleCount = coder.readWord(1, false);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
-        
-        int start = coder.getPointer()-16; // account for identifier
+		lineStyles = new ArrayList(lineStyleCount);
 
-        bounds = new FSBounds(coder);
-        fillStyleCount = coder.readWord(1, false);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSSolidLine(coder));
 
-        fillStyles = new ArrayList(fillStyleCount);
+		int bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        fillStyles = new ArrayList();
+		if (coder.context[FSCoder.DecodeShapes] == 1)
+			shape = new FSShape(coder);
+		else
+			shape = new FSShape(coder, length - bytesDecoded);
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }        
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
-
-        lineStyles = new ArrayList(lineStyleCount);
-        
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSSolidLine(coder));
-        
-        int bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
-
-        if (coder.context[FSCoder.DecodeShapes] == 1)
-            shape = new FSShape(coder);
-        else
-            shape = new FSShape(coder, length-bytesDecoded);
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineShape2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineShape2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineShape2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,443 +33,505 @@
 import java.util.*;
 
 /**
-FSDefineShape2 defines a shape to be displayed. 
- 
-&lt;p&gt;It extends the functionality of the FSDefineShape class by allowing more than 255 fill or line styles to be specified.&lt;/p&gt;
+ * FSDefineShape2 defines a shape to be displayed.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality of the FSDefineShape class by allowing more than
+ * 255 fill or line styles to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSDefineShape2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The shape defines a path containing a mix of straight and curved edges and
+ * pen move actions. A path need not be contiguous. When the shape is drawn the
+ * FSShapeStyle object selects the line and fill styles, from the respective
+ * array, to be used. FSShapeStyle objects can be defined in the shape at any
+ * time to change the styles being used. The fill style used can either be a
+ * solid colour, a bitmap image or a gradient. The line style specifies the
+ * colour and thickness of the line drawn around the shape outline. For both
+ * line and fill styles the selected style may be undefined, allowing the shape
+ * to be drawn without an outline or left unfilled.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This example creates a simple rectangle, 200 twips wide and 100 twips high,
+ * drawing using a black outline 1 twip wide and filled with a solid red colour.
+ * The origin of the shape is at the bottom left corner of the rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. The values also specify
+ * // the coordinate range of the shape.
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, 200, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+ * 
+ * lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0)));
+ * 
+ * // Draw the shape.
+ * 
+ * FSShape shape = new FSShape();
+ * 
+ * // Define the line, fill styles and move to the shape's origin.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(200, 0));
+ * shape.add(new FSLine(0, 100));
+ * shape.add(new FSLine(-200, 0));
+ * shape.add(new FSLine(0, -100));
+ * 
+ * FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineShape2 class represents the DefineShape2 data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 2.
+ * &lt;/p&gt;
+ */
+public class FSDefineShape2 extends FSDefineObject
+{
+	private FSBounds bounds = null;
+	private ArrayList fillStyles = null;
+	private ArrayList lineStyles = null;
+	private FSShape shape = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineShape2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineShape2(FSCoder coder)
+	{
+		super(DefineShape2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape2 object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the shape.
+	 * @param aBounds
+	 *            the bounding rectangle for the shape.
+	 * @param fillStyleArray
+	 *            the array of fill styles used in the shape.
+	 * @param lineStyleArray
+	 *            the array of line styles used in the shape.
+	 * @param aShape
+	 *            the shape to be drawn.
+	 */
+	public FSDefineShape2(int anIdentifier, FSBounds aBounds,
+							ArrayList fillStyleArray, ArrayList lineStyleArray,
+							FSShape aShape)
+	{
+		super(DefineShape2, anIdentifier);
+		setBounds(aBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setShape(aShape);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineShape2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineShape2(FSDefineShape2 obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_3&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;&lt;/tr&gt;
+		lineStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape2_4&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineShape2_5&quot;&gt;shape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle 
-objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		shape = new FSShape(obj.shape);
+	}
 
-&lt;p&gt;The shape defines a path containing a mix of straight and curved edges and pen 
-move actions. A path need not be contiguous. When the shape is drawn the FSShapeStyle 
-object selects the line and fill styles, from the respective array, to be used. 
-FSShapeStyle objects can be defined in the shape at any time to change the styles 
-being used. The fill style used can either be a solid colour, a bitmap image or a 
-gradient. The line style specifies the colour and thickness of the line drawn around 
-the shape outline. For both line and fill styles the selected style may be undefined, 
-allowing the shape to be drawn without an outline or left unfilled.&lt;/p&gt;
+	/**
+	 * Add a FSSolidLine object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSSolidLine object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-&lt;p&gt;This example creates a simple rectangle, 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a solid red colour. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Gets the bounding rectangle for the shape.
+	 * 
+	 * @return the bounding rectangle for the shape.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. The values also specify
-// the coordinate range of the shape.
+	/**
+	 * Gets the array fill styles.
+	 * 
+	 * @return the fill styles used in the shape.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-FSBounds bounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Gets the array line styles.
+	 * 
+	 * @return the line styles used in the shape.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Gets the shape.
+	 * 
+	 * @return the shape to be drawn.
+	 */
+	public FSShape getShape()
+	{
+		return shape;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Sets the bounding rectangle.
+	 * 
+	 * @param aBounds
+	 *            set the bounding rectangle for the shape.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+	/**
+	 * Sets the fill styles.
+	 * 
+	 * @param anArray
+	 *            set the fill styles for the shape.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0)));
+	/**
+	 * Sets the line styles.
+	 * 
+	 * @param anArray
+	 *            set the line styles for the shape.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-// Draw the shape.
+	/**
+	 * Sets the shape.
+	 * 
+	 * @param aShape
+	 *            set the shape to be drawn.
+	 */
+	public void setShape(FSShape aShape)
+	{
+		shape = aShape;
+	}
 
-FSShape shape = new FSShape();
+	public Object clone()
+	{
+		FSDefineShape2 anObject = (FSDefineShape2) super.clone();
 
-// Define the line, fill styles and move to the shape's origin.
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(200,0));
-shape.add(new FSLine(0,100));
-shape.add(new FSLine(-200,0));
-shape.add(new FSLine(0,-100));
+		anObject.fillStyles = new ArrayList();
 
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
-&lt;/pre&gt;
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.lineStyles = new ArrayList();
 
-&lt;p&gt;The FSDefineShape2 class represents the DefineShape2 data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSDefineShape2 extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape shape = null;
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-    /**
-     * Construct an FSDefineShape2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineShape2(FSCoder coder)
-    {
-        super(DefineShape2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineShape2 object.
+		anObject.shape = (shape != null) ? (FSShape) shape.clone() : null;
 
-        @param anIdentifier the unique identifier for the shape.
-        @param aBounds the bounding rectangle for the shape.
-        @param fillStyleArray the array of fill styles used in the shape.
-        @param lineStyleArray the array of line styles used in the shape.
-        @param aShape the shape to be drawn.
-    */
-    public FSDefineShape2(int anIdentifier, FSBounds aBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape aShape)
-    {
-        super(DefineShape2, anIdentifier);
-        setBounds(aBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setShape(aShape);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineShape2(FSDefineShape2 obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+		return anObject;
+	}
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        shape = new FSShape(obj.shape);
-    }
-    
-    /** Add a FSSolidLine object to the array of line styles.
+		if (super.equals(anObject))
+		{
+			FSDefineShape2 typedObject = (FSDefineShape2) anObject;
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-    /** Add the fill style object to the array of fill styles.
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-    /** Gets the bounding rectangle for the shape.
+			if (shape != null)
+				result = result &amp;&amp; shape.equals(typedObject.shape);
+			else
+				result = result &amp;&amp; shape == typedObject.shape;
+		}
+		return result;
+	}
 
-        @return the bounding rectangle for the shape.
-        */
-    public FSBounds getBounds() { return bounds; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the array fill styles.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
+			Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
+			Transform.append(buffer, &quot;shape&quot;, shape, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Gets the array line styles.
+		super.length(coder);
 
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		length += bounds.length(coder);
+		length += (fillStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Gets the shape.
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-        @return the shape to be drawn.
-        */
-    public FSShape getShape() { return shape; }
+		length += (lineStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Sets the bounding rectangle.
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-        @param aBounds set the bounding rectangle for the shape.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    /** Sets the fill styles.
+		length += shape.length(coder);
 
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    /** Sets the line styles.
+		return length;
+	}
 
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Sets the shape.
+		super.encode(coder);
 
-        @param aShape set the shape to be drawn.
-        */
-    public void setShape(FSShape aShape)
-    {
-        shape = aShape;
-    }
+		bounds.encode(coder);
 
-    public Object clone()
-    {
-        FSDefineShape2 anObject = (FSDefineShape2)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
+		if (fillStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(fillStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(fillStyles.size(), 1);
+		}
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		if (lineStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(lineStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(lineStyles.size(), 1);
+		}
 
-         anObject.shape = (shape != null) ? (FSShape)shape.clone() : null;
-        
-        return anObject;
-    }
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineShape2 typedObject = (FSDefineShape2)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		shape.encode(coder);
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-            if (shape != null)
-                result = result &amp;&amp; shape.equals(typedObject.shape);
-            else
-                result = result &amp;&amp; shape == typedObject.shape;
-        }
-        return result;
-    }
+		coder.endObject(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;shape&quot;, shape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.length(coder);
-    
-        length += bounds.length(coder);
-        length += (fillStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-        
-        length += (lineStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += shape.length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		super.decode(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
+		int start = coder.getPointer() - 16; // account for identifier
 
-        bounds.encode(coder);
-        
-        if (fillStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(fillStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(fillStyles.size(), 1);
-        }
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        if (lineStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(lineStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(lineStyles.size(), 1);
-        }
-                    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		bounds = new FSBounds(coder);
+		fillStyleCount = coder.readWord(1, false);
 
-        shape.encode(coder);
+		if (fillStyleCount == 0xFF)
+			fillStyleCount = coder.readWord(2, false);
 
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		fillStyles = new ArrayList(fillStyleCount);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
+		fillStyles = new ArrayList();
 
-        int start = coder.getPointer()-16; // account for identifier
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        bounds = new FSBounds(coder);
-        fillStyleCount = coder.readWord(1, false);
+		lineStyleCount = coder.readWord(1, false);
 
-        if (fillStyleCount == 0xFF)
-            fillStyleCount = coder.readWord(2, false);
-            
-        fillStyles = new ArrayList(fillStyleCount);
+		if (lineStyleCount == 0xFF)
+			lineStyleCount = coder.readWord(2, false);
 
-        fillStyles = new ArrayList();
+		lineStyles = new ArrayList(lineStyleCount);
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }        
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSSolidLine(coder));
 
-        if (lineStyleCount == 0xFF)
-            lineStyleCount = coder.readWord(2, false);
+		coder.context[FSCoder.ArrayCountExtended] = 1;
 
-        lineStyles = new ArrayList(lineStyleCount);
-        
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSSolidLine(coder));
+		int bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        coder.context[FSCoder.ArrayCountExtended] = 1;
+		if (coder.context[FSCoder.DecodeShapes] == 1)
+			shape = new FSShape(coder);
+		else
+			shape = new FSShape(coder, length - bytesDecoded);
 
-        int bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
 
-        if (coder.context[FSCoder.DecodeShapes] == 1)
-            shape = new FSShape(coder);
-        else
-            shape = new FSShape(coder, length-bytesDecoded);
-
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineShape3.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineShape3.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineShape3.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,447 +33,516 @@
 import java.util.*;
 
 /**
-FSDefineShape3 defines a transparent shape to be displayed. 
+ * FSDefineShape3 defines a transparent shape to be displayed.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality of the FSDefineShape2 class by supporting
+ * transparent colours.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;shape&lt;/td&gt;
+ * &lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The shape defines a path containing a mix of straight and curved edges and
+ * pen move actions. A path need not be contiguous. When the shape is drawn the
+ * FSShapeStyle object selects the line and fill styles, from the respective
+ * array, to be used. FSShapeStyle objects can be defined in the shape at any
+ * time to change the styles being used. The fill style used can either be an
+ * area of pure colour, a bitmap image or a gradient. The line style specifies
+ * the colour and thickness of the line drawn around the shape outline. For both
+ * line and fill styles the selected style may be undefined, allowing the shape
+ * to be drawn without an outline or left unfilled.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * This example creates a simple rectangle, 200 twips wide and 100 twips high,
+ * drawing using a black outline 1 twip wide and filled with a transparent red
+ * colour. The origin of the shape is at the bottom left corner of the
+ * rectangle.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. The values also specify
+ * // the coordinate range of the shape.
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, 200, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0, 128)));
+ * 
+ * lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0, 128)));
+ * 
+ * // Draw the shape.
+ * 
+ * FSShape shape = new FSShape();
+ * 
+ * // Define the line, fill styles and move to the shape's origin.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(200, 0));
+ * shape.add(new FSLine(0, 100));
+ * shape.add(new FSLine(-200, 0));
+ * shape.add(new FSLine(0, -100));
+ * 
+ * FSDefineShape3 shape = new FSDefineShape3(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineShape3 class represents the DefineShape3 tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineShape3 extends FSDefineObject
+{
+	private FSBounds bounds = null;
+	private ArrayList fillStyles = null;
+	private ArrayList lineStyles = null;
+	private FSShape shape = null;
 
-&lt;p&gt;It extends the functionality of the FSDefineShape2 class by supporting transparent colours.&lt;/p&gt;
+	/**
+	 * Construct an FSDefineShape3 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineShape3(FSCoder coder)
+	{
+		super(DefineShape3, 0);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSDefineShape3 object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the shape.
+	 * @param aBounds
+	 *            the bounding rectangle for the shape.
+	 * @param fillStyleArray
+	 *            the array of fill styles used in the shape.
+	 * @param lineStyleArray
+	 *            the array of line styles used in the shape.
+	 * @param aShape
+	 *            the shape to be drawn.
+	 */
+	public FSDefineShape3(int anIdentifier, FSBounds aBounds,
+							ArrayList fillStyleArray, ArrayList lineStyleArray,
+							FSShape aShape)
+	{
+		super(DefineShape3, anIdentifier);
+		setBounds(aBounds);
+		setFillStyles(fillStyleArray);
+		setLineStyles(lineStyleArray);
+		setShape(aShape);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineShape object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineShape object.
+	 */
+	public FSDefineShape3(FSDefineShape3 obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineShape3_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+		fillStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object, in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+			fillStyles.add(((FSFillStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding area inside which the shape is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+		lineStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_3&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of fill styles used to fill the area enclosed by the shape.&lt;/td&gt;&lt;/tr&gt;
+		for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+			lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_4&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of line styles used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+		shape = new FSShape(obj.shape);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineShape3_5&quot;&gt;shape&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSShape object containing the shape records (FSLine, FSCurve and FSShapeStyle objects) that describe how the shape is drawn and filled shape.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Add a FSSolidLine object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSSolidLine object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;p&gt;The shape defines a path containing a mix of straight and curved edges and pen move actions. A path need not be contiguous. When the shape is drawn the FSShapeStyle object selects the line and fill styles, from the respective array, to be used. FSShapeStyle objects can be defined in the shape at any time to change the styles being used. The fill style used can either be an area of pure colour, a bitmap image or a gradient. The line style specifies the colour and thickness of the line drawn around the shape outline. For both line and fill styles the selected style may be undefined, allowing the shape to be drawn without an outline or left unfilled.&lt;/p&gt;
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the bounding rectangle for the shape.
+	 * 
+	 * @return the bounding rectangle for the shape.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;p&gt;This example creates a simple rectangle, 200 twips wide and 100 twips high, drawing using a black outline 1 twip wide and filled with a transparent red colour. The origin of the shape is at the bottom left corner of the rectangle.&lt;/p&gt;
+	/**
+	 * Gets the array fill styles.
+	 * 
+	 * @return the fill styles used in the shape.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. The values also specify
-// the coordinate range of the shape.
+	/**
+	 * Gets the array line styles.
+	 * 
+	 * @return the line styles used in the shape.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-FSBounds bounds = new FSBounds(0, 0, 200, 100);
+	/**
+	 * Gets the shape.
+	 * 
+	 * @return the shape to be drawn.
+	 */
+	public FSShape getShape()
+	{
+		return shape;
+	}
 
-// Define the styles for the shape.
+	/**
+	 * Sets the bounding rectangle.
+	 * 
+	 * @param aBounds
+	 *            set the bounding rectangle for the shape.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	/**
+	 * Sets the fill styles.
+	 * 
+	 * @param anArray
+	 *            set the fill styles for the shape.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0, 128)));
+	/**
+	 * Sets the line styles.
+	 * 
+	 * @param anArray
+	 *            set the line styles for the shape.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-lineStyles.add(new FSSolidLine(1, new FSColor(0, 0, 0, 128)));
+	/**
+	 * Sets the shape.
+	 * 
+	 * @param aShape
+	 *            set the shape to be drawn.
+	 */
+	public void setShape(FSShape aShape)
+	{
+		shape = aShape;
+	}
 
-// Draw the shape.
+	public Object clone()
+	{
+		FSDefineShape3 anObject = (FSDefineShape3) super.clone();
 
-FSShape shape = new FSShape();
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
 
-// Define the line, fill styles and move to the shape's origin.
+		anObject.fillStyles = new ArrayList();
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(200,0));
-shape.add(new FSLine(0,100));
-shape.add(new FSLine(-200,0));
-shape.add(new FSLine(0,-100));
+		for (Iterator i = fillStyles.iterator(); i.hasNext();)
+			anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
 
-FSDefineShape3 shape = new FSDefineShape3(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
-&lt;/pre&gt;
+		anObject.lineStyles = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		for (Iterator i = lineStyles.iterator(); i.hasNext();)
+			anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
 
-&lt;p&gt;The FSDefineShape3 class represents the DefineShape3 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineShape3 extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
-    private FSShape shape = null;
+		anObject.shape = (shape != null) ? (FSShape) shape.clone() : null;
 
-    /**
-     * Construct an FSDefineShape3 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineShape3(FSCoder coder)
-    {
-        super(DefineShape3, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineShape3 object.
+		return anObject;
+	}
 
-        @param anIdentifier the unique identifier for the shape.
-        @param aBounds the bounding rectangle for the shape.
-        @param fillStyleArray the array of fill styles used in the shape.
-        @param lineStyleArray the array of line styles used in the shape.
-        @param aShape the shape to be drawn.
-        */
-    public FSDefineShape3(int anIdentifier, FSBounds aBounds, ArrayList fillStyleArray, ArrayList lineStyleArray, FSShape aShape)
-    {
-        super(DefineShape3, anIdentifier);
-        setBounds(aBounds);
-        setFillStyles(fillStyleArray);
-        setLineStyles(lineStyleArray);
-        setShape(aShape);
-    }
-    /**
-     * Constructs an FSDefineShape object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineShape object.
-     */
-    public FSDefineShape3(FSDefineShape3 obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        
-        fillStyles = new ArrayList();
-        
-        for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-            fillStyles.add(((FSFillStyle)i.next()).clone());
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        lineStyles = new ArrayList();
-            
-        for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-            lineStyles.add(((FSLineStyle)i.next()).clone());
+		if (super.equals(anObject))
+		{
+			FSDefineShape3 typedObject = (FSDefineShape3) anObject;
 
-        shape = new FSShape(obj.shape);
-    }
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-    /** Add a FSSolidLine object to the array of line styles.
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
 
-    /** Add the fill style object to the array of fill styles.
+			if (shape != null)
+				result = result &amp;&amp; shape.equals(typedObject.shape);
+			else
+				result = result &amp;&amp; shape == typedObject.shape;
+		}
+		return result;
+	}
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the bounding rectangle for the shape.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
+			Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
+			Transform.append(buffer, &quot;shape&quot;, shape, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the bounding rectangle for the shape.
-        */
-    public FSBounds getBounds() { return bounds; }
+	public int length(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Gets the array fill styles.
+		super.length(coder);
 
-        @return the fill styles used in the shape.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Gets the array line styles.
+		length += bounds.length(coder);
 
-        @return the line styles used in the shape.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		length += (fillStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Gets the shape.
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-        @return the shape to be drawn.
-        */
-    public FSShape getShape() { return shape; }
+		length += (lineStyles.size() &gt;= 255) ? 3 : 1;
 
-    /** Sets the bounding rectangle.
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			length += ((FSTransformObject) styleIterator.next()).length(coder);
 
-        @param aBounds set the bounding rectangle for the shape.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-    /** Sets the fill styles.
+		length += shape.length(coder);
 
-        @param anArray set the fill styles for the shape.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
 
-    /** Sets the line styles.
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
 
-        @param anArray set the line styles for the shape.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+		return length;
+	}
 
-    /** Sets the shape.
+	public void encode(FSCoder coder)
+	{
+		int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+		int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-        @param aShape set the shape to be drawn.
-        */
-    public void setShape(FSShape aShape)
-    {
-        shape = aShape;
-    }
+		super.encode(coder);
 
-    public Object clone()
-    {
-        FSDefineShape3 anObject = (FSDefineShape3)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        anObject.fillStyles = new ArrayList();
-            
-        for (Iterator i = fillStyles.iterator(); i.hasNext();)
-            anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
+		bounds.encode(coder);
 
-        anObject.lineStyles = new ArrayList();
-            
-        for (Iterator i = lineStyles.iterator(); i.hasNext();)
-            anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
+		if (fillStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(fillStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(fillStyles.size(), 1);
+		}
 
-         anObject.shape = (shape != null) ? (FSShape)shape.clone() : null;
-        
-        return anObject;
-    }
+		for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineShape3 typedObject = (FSDefineShape3)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		if (lineStyles.size() &gt;= 255)
+		{
+			coder.writeWord(0xFF, 1);
+			coder.writeWord(lineStyles.size(), 2);
+		} else
+		{
+			coder.writeWord(lineStyles.size(), 1);
+		}
 
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
+		for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+						.hasNext();)
+			((FSTransformObject) styleIterator.next()).encode(coder);
 
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		coder.context[FSCoder.ArrayCountExtended] = 1;
+		coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+		coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
 
-            if (shape != null)
-                result = result &amp;&amp; shape.equals(typedObject.shape);
-            else
-                result = result &amp;&amp; shape == typedObject.shape;
-        }
-        return result;
-    }
+		shape.encode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            Transform.append(buffer, &quot;shape&quot;, shape, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.NumberOfFillBits] = 0;
+		coder.context[FSCoder.NumberOfLineBits] = 0;
+		coder.context[FSCoder.TransparentColors] = 0;
 
-    public int length(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
+		coder.endObject(name());
+	}
 
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+	public void decode(FSCoder coder)
+	{
+		int fillStyleCount = 0;
+		int lineStyleCount = 0;
 
-        length += bounds.length(coder);
+		super.decode(coder);
 
-        length += (fillStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-        
-        length += (lineStyles.size() &gt;= 255) ? 3 : 1;
-    
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            length += ((FSTransformObject)styleIterator.next()).length(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-    
-        length += shape.length(coder);
-    
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
+		int start = coder.getPointer() - 16; // account for identifier
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.ArrayCountExtended] = 0;
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-        int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-        super.encode(coder);
+		bounds = new FSBounds(coder);
+		fillStyleCount = coder.readWord(1, false);
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		if (fillStyleCount == 0xFF)
+			fillStyleCount = coder.readWord(2, false);
 
-        bounds.encode(coder);
-        
-        if (fillStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(fillStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(fillStyles.size(), 1);
-        }
-    
-        for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-       if (lineStyles.size() &gt;= 255)
-        {
-            coder.writeWord(0xFF, 1);
-            coder.writeWord(lineStyles.size(), 2);
-        }
-        else
-        {
-            coder.writeWord(lineStyles.size(), 1);
-        }
-                
-        for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-            ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-        coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-        coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		fillStyles = new ArrayList(fillStyleCount);
 
-        shape.encode(coder);
+		fillStyles = new ArrayList();
 
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-        coder.context[FSCoder.NumberOfFillBits] = 0;
-        coder.context[FSCoder.NumberOfLineBits] = 0;
-        coder.context[FSCoder.TransparentColors] = 0;
+		for (int i = 0; i &lt; fillStyleCount; i++)
+		{
+			switch (coder.scanWord(1, false))
+			{
+				case FSFillStyle.Solid:
+					fillStyles.add(new FSSolidFill(coder));
+					break;
+				case FSFillStyle.Linear:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Radial:
+					fillStyles.add(new FSGradientFill(coder));
+					break;
+				case FSFillStyle.Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Tiled:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				case FSFillStyle.Unsmoothed_Clipped:
+					fillStyles.add(new FSBitmapFill(coder));
+					break;
+				default:
+					break;
+			}
+		}
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int fillStyleCount = 0;
-        int lineStyleCount = 0;
-        
-        super.decode(coder);
+		lineStyleCount = coder.readWord(1, false);
 
-        int start = coder.getPointer()-16; // account for identifier
+		if (lineStyleCount == 0xFF)
+			lineStyleCount = coder.readWord(2, false);
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		lineStyles = new ArrayList(lineStyleCount);
 
-        bounds = new FSBounds(coder);
-        fillStyleCount = coder.readWord(1, false);
+		for (int i = 0; i &lt; lineStyleCount; i++)
+			lineStyles.add(new FSSolidLine(coder));
 
-        if (fillStyleCount == 0xFF)
-            fillStyleCount = coder.readWord(2, false);
-            
-        fillStyles = new ArrayList(fillStyleCount);
+		coder.context[FSCoder.ArrayCountExtended] = 1;
 
-        fillStyles = new ArrayList();
+		int bytesDecoded = (coder.getPointer() - start) &gt;&gt; 3;
 
-        for (int i=0; i&lt;fillStyleCount; i++)
-        {
-            switch (coder.scanWord(1, false))
-            {
-                case FSFillStyle.Solid:
-                    fillStyles.add(new FSSolidFill(coder));
-                    break;
-                case FSFillStyle.Linear:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Radial:
-                    fillStyles.add(new FSGradientFill(coder));
-                    break;
-                case FSFillStyle.Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Tiled:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                case FSFillStyle.Unsmoothed_Clipped:
-                    fillStyles.add(new FSBitmapFill(coder));
-                    break;
-                default:
-                    break;    
-            }        
-        }
-        
-        lineStyleCount = coder.readWord(1, false);
+		if (coder.context[FSCoder.DecodeShapes] == 1)
+			shape = new FSShape(coder);
+		else
+			shape = new FSShape(coder, length - bytesDecoded);
 
-        if (lineStyleCount == 0xFF)
-            lineStyleCount = coder.readWord(2, false);
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.ArrayCountExtended] = 0;
 
-        lineStyles = new ArrayList(lineStyleCount);
-        
-        for (int i=0; i&lt;lineStyleCount; i++)
-            lineStyles.add(new FSSolidLine(coder));
-
-        coder.context[FSCoder.ArrayCountExtended] = 1;
-
-        int bytesDecoded = (coder.getPointer()-start) &gt;&gt; 3;
-
-        if (coder.context[FSCoder.DecodeShapes] == 1)
-            shape = new FSShape(coder);
-        else
-            shape = new FSShape(coder, length-bytesDecoded);
-
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.ArrayCountExtended] = 0;
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineSound.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineSound.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineSound.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,365 +34,442 @@
 import java.util.Iterator;
 
 /**
-FSDefineSound is used to define a sound that will be played when a given event occurs. 
-
-&lt;p&gt;Three different types of object are used to play an event sound:&lt;/p&gt;
-
-&lt;ul&gt;
-&lt;li&gt;The FSDefineSound object that contains the sampled sound.&lt;/li&gt;
-&lt;li&gt;A FSSound object that defines how the sound fades in and out, whether it repeats and also defines an envelope for more sophisticated control over how the sound is played.&lt;/li&gt;
-&lt;li&gt;A FSStartSound object that signals the Flash Player to begin playing the sound.&lt;/li&gt;
-&lt;/ul&gt;
-
-&lt;p&gt;An FSDefineSound object contains the following attributes:&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineSound_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;
-&lt;a name=&quot;FSDefineSound_2&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The format of the sound data - FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER&lt;/td&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_3&quot;&gt;playbackRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_4&quot;&gt;playbackChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of channels in the sound, typically 1 (mono) or 2 (stereo).&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_5&quot;&gt;playbackSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in a sample: 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_6&quot;&gt;sampleCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of samples in the sound.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_7&quot;&gt;soundLength&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in the sound data.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineSound_8&quot;&gt;sound&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded sound data.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;Five encoded formats for the sound data are supported:&lt;/p&gt;
-
-&lt;ul&gt;
-&lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes. For two-byte samples the byte order is dependent on the platform on which the Flash Player is hosted. Sounds created on a platform which supports big-endian byte order will not be played correctly when listened to on a platform which supports little-endian byte order.&lt;/li&gt;
-&lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes with 
-the latter presented in Little-Endian byte order. This ensures that sounds can be played across different platforms.&lt;/li&gt;
-&lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded and compressed
-by comparing the difference between successive sound sample which dramatically reduces
-the size of the encoded sound when compared to the uncompressed PCM formats. Use this 
-format whenever possible.&lt;/li&gt;
-&lt;li&gt;MP3 - compressed MPEG Audio Layer-3.&lt;/li&gt;
-&lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate sound for improving synchronisation between the sound and frame rate of movies.&lt;/li&gt;
-&lt;/ul&gt;
-
-&lt;p&gt;Constants representing the different formats are defined in the FSSound class.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSDefineSound class represents the DefineSound structure from the Macromedia 
-Flash (SWF) File Format Specification. It was introduced in Flash 1. Flash 3 added 
-support for MP3 and the Nellymoser Asao format was added in Flash 6.&lt;/p&gt;
- */  
+ * FSDefineSound is used to define a sound that will be played when a given
+ * event occurs.
+ * 
+ * &lt;p&gt;
+ * Three different types of object are used to play an event sound:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The FSDefineSound object that contains the sampled sound.&lt;/li&gt;
+ * &lt;li&gt;A FSSound object that defines how the sound fades in and out, whether it
+ * repeats and also defines an envelope for more sophisticated control over how
+ * the sound is played.&lt;/li&gt;
+ * &lt;li&gt;A FSStartSound object that signals the Flash Player to begin playing the
+ * sound.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * An FSDefineSound object contains the following attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt; format&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The format of the sound data - FSDefineSound.NATIVE_PCM, FSDefineSound.ADPCM,
+ * FSDefineSound.MP3, FSDefineSound.PCM or FSDefineSound.NELLYMOSER&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackRate&lt;/td&gt;
+ * &lt;td&gt;The rate the sound will be played in Hertz: 5512, 11025, 22050 or 44100&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackChannels&lt;/td&gt;
+ * &lt;td&gt;The number of channels in the sound, typically 1 (mono) or 2 (stereo).&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackSampleSize&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in a sample: 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sampleCount&lt;/td&gt;
+ * &lt;td&gt;The number of samples in the sound.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;soundLength&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in the sound data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound&lt;/td&gt;
+ * &lt;td&gt;The encoded sound data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Five encoded formats for the sound data are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or
+ * 2 bytes. For two-byte samples the byte order is dependent on the platform on
+ * which the Flash Player is hosted. Sounds created on a platform which supports
+ * big-endian byte order will not be played correctly when listened to on a
+ * platform which supports little-endian byte order.&lt;/li&gt;
+ * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes
+ * with the latter presented in Little-Endian byte order. This ensures that
+ * sounds can be played across different platforms.&lt;/li&gt;
+ * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded
+ * and compressed by comparing the difference between successive sound sample
+ * which dramatically reduces the size of the encoded sound when compared to the
+ * uncompressed PCM formats. Use this format whenever possible.&lt;/li&gt;
+ * &lt;li&gt;MP3 - compressed MPEG Audio Layer-3.&lt;/li&gt;
+ * &lt;li&gt;NELLYMOSER - compressed Nellymoser Asao format supporting low bit-rate
+ * sound for improving synchronisation between the sound and frame rate of
+ * movies.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * Constants representing the different formats are defined in the FSSound
+ * class.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineSound class represents the DefineSound structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1. Flash 3 added support for MP3 and the Nellymoser Asao format was added in
+ * Flash 6.
+ * &lt;/p&gt;
+ */
 public class FSDefineSound extends FSDefineObject
 {
-    private int format = 0;
-    private int playbackRate = 5512;
-    private int playbackChannels = 1;
-    private int playbackSampleSize = 1;
-    private int sampleCount = 0;
-    private byte[] soundData = null;
+	private int format = 0;
+	private int playbackRate = 5512;
+	private int playbackChannels = 1;
+	private int playbackSampleSize = 1;
+	private int sampleCount = 0;
+	private byte[] soundData = null;
 
-    /**
-     * Construct an FSDefineSound object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineSound(FSCoder coder)
-    {
-        super(FSMovieObject.DefineSound, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineSound object specifying the unique identifier and all the parameters required to describe the sound.
+	/**
+	 * Construct an FSDefineSound object, initalising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineSound(FSCoder coder)
+	{
+		super(FSMovieObject.DefineSound, 0);
+		decode(coder);
+	}
 
-        @param anIdentifier the unique identifier for this sound.
-        @param aFormat the encoding format for the sound.  For Flash 1 the formats may be FSSound.NATIVE_PCM, FSSound.PCM or FSSound.ADPCM. For Flash 4 or later include FSSound.MP3 and Flash 6 or later include FSSound.NELLYMOSER.
-        @param rate the number of samples per second that the sound is played at , either 5512, 11025, 22050 or 44100.
-        @param channels the number of channels in the sound, either 1 (Mono) or 2 (Stereo).
-        @param sampleSize the size of an uncompressed sound sample in bits, either 8 or 16.
-        @param count the number of samples in the sound data.
-        @param bytes the sound data.
-        */
-    public FSDefineSound(int anIdentifier, int aFormat, int rate, int channels, int sampleSize, int count, byte[] bytes)
-    {
-        super(FSMovieObject.DefineSound, anIdentifier);
-        setFormat(aFormat);
-        setPlaybackRate(rate);
-        setPlaybackChannels(channels);
-        setPlaybackSampleSize(sampleSize);
-        setSampleCount(count);
-        setSoundData(bytes);
-    }
-    /**
-     * Constructs an FSDefineSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineSound object.
-     */
-    public FSDefineSound(FSDefineSound obj)
-    {
-        super(obj);
-        format = obj.format;
-        playbackRate = obj.playbackRate;
-        playbackChannels = obj.playbackChannels;
-        playbackSampleSize = obj.playbackSampleSize;
-        sampleCount = obj.sampleCount;
-        soundData = Transform.clone(obj.soundData);
-    }
+	/**
+	 * Constructs an FSDefineSound object specifying the unique identifier and
+	 * all the parameters required to describe the sound.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this sound.
+	 * @param aFormat
+	 *            the encoding format for the sound. For Flash 1 the formats may
+	 *            be FSSound.NATIVE_PCM, FSSound.PCM or FSSound.ADPCM. For Flash
+	 *            4 or later include FSSound.MP3 and Flash 6 or later include
+	 *            FSSound.NELLYMOSER.
+	 * @param rate
+	 *            the number of samples per second that the sound is played at ,
+	 *            either 5512, 11025, 22050 or 44100.
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 * @param sampleSize
+	 *            the size of an uncompressed sound sample in bits, either 8 or
+	 *            16.
+	 * @param count
+	 *            the number of samples in the sound data.
+	 * @param bytes
+	 *            the sound data.
+	 */
+	public FSDefineSound(int anIdentifier, int aFormat, int rate, int channels,
+							int sampleSize, int count, byte[] bytes)
+	{
+		super(FSMovieObject.DefineSound, anIdentifier);
+		setFormat(aFormat);
+		setPlaybackRate(rate);
+		setPlaybackChannels(channels);
+		setPlaybackSampleSize(sampleSize);
+		setSampleCount(count);
+		setSoundData(bytes);
+	}
 
-    /**    Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM or FSSound.ADPCM (all Flash 1), FSSound.MP3 (Flash 4+) or FSSound.NELLYMOSER (Flash 6+).
+	/**
+	 * Constructs an FSDefineSound object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineSound object.
+	 */
+	public FSDefineSound(FSDefineSound obj)
+	{
+		super(obj);
+		format = obj.format;
+		playbackRate = obj.playbackRate;
+		playbackChannels = obj.playbackChannels;
+		playbackSampleSize = obj.playbackSampleSize;
+		sampleCount = obj.sampleCount;
+		soundData = Transform.clone(obj.soundData);
+	}
 
-        @return a constant defining the type of compression.
-        */
-    public int getFormat() 
-    {
-        return format;
-    }
+	/**
+	 * Gets the compression format used, either FSSound.NATIVE_PCM, FSSound.PCM
+	 * or FSSound.ADPCM (all Flash 1), FSSound.MP3 (Flash 4+) or
+	 * FSSound.NELLYMOSER (Flash 6+).
+	 * 
+	 * @return a constant defining the type of compression.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-    /** Gets the rate at which the sound will be played, in Hz: 5512, 11025, 22050 or 44100.
+	/**
+	 * Gets the rate at which the sound will be played, in Hz: 5512, 11025,
+	 * 22050 or 44100.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-     @return the rate at which the sound was sampled.
-     */
-    public int getPlaybackRate()
-    {
-        return playbackRate;
-    }
+	/**
+	 * Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
+	 * 
+	 * @return the number of channels.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-    /** Gets the number of sound channels, 1 (Mono) or 2 (Stereo).
+	/**
+	 * Gets the size of an uncompressed sample in bytes.
+	 * 
+	 * @return the number of bytes per sample when the sound is uncompressed.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-     @return the number of channels.
-     */
-    public int getPlaybackChannels()
-    {
-        return playbackChannels;
-    }
+	/**
+	 * Gets the number of samples in the sound data.
+	 * 
+	 * @return the number of sound samples.
+	 */
+	public int getSampleCount()
+	{
+		return sampleCount;
+	}
 
-    /** Gets the size of an uncompressed sample in bytes.
+	/**
+	 * Gets the sound data.
+	 * 
+	 * @return an array of bytes containing the sampled sound.
+	 */
+	public byte[] getSoundData()
+	{
+		return soundData;
+	}
 
-        @return the number of bytes per sample when the sound is uncompressed.
-        */
-    public int getPlaybackSampleSize() 
-    {
-        return playbackSampleSize;
-    }
+	/**
+	 * Sets the compression format used, either FSSound.NATIVE_PCM,
+	 * FSSound.ADPCM or FSSound.PCM from Flash 1 onwards, FSSound.MP3 from Flash
+	 * 4 onwards, or FSSound.NELLYMOSER from Flash 6 onwards.
+	 * 
+	 * @param encoding
+	 *            the format for the sound.
+	 */
+	public void setFormat(int encoding)
+	{
+		format = encoding;
+	}
 
-    /** Gets the number of samples in the sound data.
+	/**
+	 * Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or
+	 * 44100.
+	 * 
+	 * @param rate
+	 *            the rate at which the sounds is played in Hz.
+	 */
+	public void setPlaybackRate(int rate)
+	{
+		playbackRate = rate;
+	}
 
-     @return the number of sound samples.
-     */
-    public int getSampleCount()
-    {
-        return sampleCount;
-    }
+	/**
+	 * Sets the number of channels defined in the sound.
+	 * 
+	 * @param channels
+	 *            the number of channels in the sound, either 1 (Mono) or 2
+	 *            (Stereo).
+	 */
+	public void setPlaybackChannels(int channels)
+	{
+		playbackChannels = channels;
+	}
 
-    /** Gets the sound data.
+	/**
+	 * Sets the sample size in bytes. Must be either 1 or 2.
+	 * 
+	 * @param sampleSize
+	 *            the size of sound samples in bytes.
+	 */
+	public void setPlaybackSampleSize(int sampleSize)
+	{
+		playbackSampleSize = sampleSize;
+	}
 
-     @return an array of bytes containing the sampled sound.
-     */
-    public byte[] getSoundData()
-    {
-        return soundData;
-    }
+	/**
+	 * Sets the number of samples in the sound data.
+	 * 
+	 * @param count
+	 *            the number of samples for the sound.
+	 */
+	public void setSampleCount(int count)
+	{
+		sampleCount = count;
+	}
 
-    /**    Sets the compression format used, either FSSound.NATIVE_PCM, FSSound.ADPCM or FSSound.PCM from Flash 1 onwards, FSSound.MP3 from Flash 4 onwards, or FSSound.NELLYMOSER from Flash 6 onwards.
+	/**
+	 * Sets the sound data.
+	 * 
+	 * @param bytes
+	 *            the sound data.
+	 */
+	public void setSoundData(byte[] bytes)
+	{
+		soundData = bytes;
+	}
 
-        @param encoding the format for the sound.
-        */
-    public void setFormat(int encoding)
-    {
-        format = encoding;
-    }
+	public Object clone()
+	{
+		FSDefineSound anObject = (FSDefineSound) super.clone();
 
-    /** Sets the sampling rate in Hertz. Must be one of: 5512, 11025, 22050 or 44100.
+		anObject.soundData = Transform.clone(soundData);
 
-        @param rate the rate at which the sounds is played in Hz.
-        */
-    public void setPlaybackRate(int rate)
-    {
-        playbackRate = rate;
-    }
+		return anObject;
+	}
 
-    /** Sets the number of channels defined in the sound.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param channels the number of channels in the sound, either 1 (Mono) or 2 (Stereo).
-        */
-    public void setPlaybackChannels(int channels)
-    {
-        playbackChannels = channels;
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineSound typedObject = (FSDefineSound) anObject;
 
-    /** Sets the sample size in bytes. Must be either 1 or 2.
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result &amp;&amp; sampleCount == typedObject.sampleCount;
+			result = result
+							&amp;&amp; Transform.equals(soundData,
+											typedObject.soundData);
+		}
+		return result;
+	}
 
-        @param sampleSize the size of sound samples in bytes.
-        */
-    public void setPlaybackSampleSize(int sampleSize)
-    {
-        playbackSampleSize = sampleSize;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the number of samples in the sound data.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;format&quot;, format);
+			Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
+			Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
+			Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
+			Transform.append(buffer, &quot;sampleCount&quot;, sampleCount);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-     @param count the number of samples for the sound.
-     */
-    public void setSampleCount(int count)
-    {
-        sampleCount = count;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the sound data.
+		length += 5;
+		length += soundData.length;
 
-        @param bytes the sound data.
-        */
-    public void setSoundData(byte[] bytes)
-    {
-        soundData = bytes;
-    }
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSDefineSound anObject = (FSDefineSound)super.clone();
-        
-        anObject.soundData = Transform.clone(soundData);
-        
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineSound typedObject = (FSDefineSound)anObject;
-            
-            result = format == typedObject.format;
-            result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-            result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-            result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-            result = result &amp;&amp; sampleCount == typedObject.sampleCount;
-            result = result &amp;&amp; Transform.equals(soundData, typedObject.soundData);
-        }
-        return result;
-    }
+		coder.writeBits(format, 4);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
+		coder.writeWord(sampleCount, 4);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;format&quot;, format);
-            Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-            Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-            Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-            Transform.append(buffer, &quot;sampleCount&quot;, sampleCount);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.writeBytes(soundData);
+		coder.endObject(name());
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 5;
-        length += soundData.length;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeBits(format, 4);
-        
-        switch (playbackRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(playbackSampleSize-1, 1);
-        coder.writeBits(playbackChannels-1, 1);
-        coder.writeWord(sampleCount, 4);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        coder.writeBytes(soundData);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        format = coder.readBits(4, false);
+		format = coder.readBits(4, false);
 
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                playbackRate = 5512;
-                break;
-            case 1:
-                playbackRate = 11025;
-                break;
-            case 2:
-                playbackRate = 22050;
-                break;
-            case 3:
-                playbackRate = 44100;
-                break;
-        }
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
 
-        playbackSampleSize = coder.readBits(1, false)+1;
-        playbackChannels = coder.readBits(1, false)+1;
-        sampleCount = coder.readWord(4, false);
-        
-        soundData = new byte[length-7];
-        coder.readBytes(soundData);
-        coder.endObject(name());
-    }
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
+		sampleCount = coder.readWord(4, false);
+
+		soundData = new byte[length - 7];
+		coder.readBytes(soundData);
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSDefineText.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineText.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineText.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,381 +33,456 @@
 import java.util.*;
 
 /**
-FSDefineText defines one or more lines of text.
- 
-&lt;p&gt;The characters, style and layout information is defined using FSText objects. The FSDefineText class acts as a container for the text, defining the bounding rectangle that encloses the text along with a coordinate transform that can be used to change the size and orientation of the text when it is displayed.&lt;/p&gt;
+ * FSDefineText defines one or more lines of text.
+ * 
+ * &lt;p&gt;
+ * The characters, style and layout information is defined using FSText objects.
+ * The FSDefineText class acts as a container for the text, defining the
+ * bounding rectangle that encloses the text along with a coordinate transform
+ * that can be used to change the size and orientation of the text when it is
+ * displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;A coordinate transform describing the placement, size and rotation of
+ * the text block.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSText objects describing the characters to be displayed and
+ * their attributes.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The bounding rectangle and transform controls how the text is laid out. Each
+ * FSText object in the textRecords array specifies an offset from the left and
+ * bottom edges of the bounding rectangle, allowing successive lines of text to
+ * be arranged as a block or paragraph. The coordinate transform can be used to
+ * control the size and orientation of the text when it is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Creating a simple string. The creation and layout of the glyphs to create the
+ * text is too onerous to perform from scratch. It is easier and more convenient
+ * to use existing font definitions either by parsing an existing Flash file or
+ * by converting a font definition from a specification such as TrueType in
+ * order to obtain the glyphs and layout information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * This examples assumes a font definition that contains glyphs for the
+ * following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font
+ * used fixed size for the spacing between glyphs .e.g. Courier.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int fontSize = 240;
+ * int leading = 80;
+ * 
+ * ArrayList characters = new ArrayList();
+ * ArrayList lines = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
+ * // the text is not indented or offset.
+ * 
+ * lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize,
+ * 				characters);
+ * 
+ * // Calculate the bounding rectangle that encloses the text.
+ * // The width of the text by summing all the advances.
+ * 
+ * int width = 0;
+ * int height = fontSize + leading;
+ * 
+ * for (Iterator i = characters.iterator(); i.hasNext();)
+ * 	width += ((FSCharacter) i.next()).getAdvance();
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, width, height);
+ * 
+ * // Define the text with no coordinate transformation (use the default unity transform which leaves
+ * // the text unchanged.
+ * 
+ * FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds,
+ * 				new FSCoordTransform(), lines);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineText class represents the DefineText tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSDefineText extends FSDefineObject
+{
+	private FSBounds bounds = null;
+	private FSCoordTransform transform = null;
+	private ArrayList objects = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineText object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineText(FSCoder coder)
+	{
+		super(FSMovieObject.DefineText, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText object with the specified bounding rectangle,
+	 * coordinate transform and text records.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object. Must be in the range
+	 *            1..65535
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text. Must not be null.
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text. Must not be null.
+	 * @param array
+	 *            an array of FSText objects that define the text to be
+	 *            displayed. Must not be null.
+	 */
+	public FSDefineText(int anIdentifier, FSBounds aBounds,
+						FSCoordTransform aTransform, ArrayList array)
+	{
+		super(FSMovieObject.DefineText, anIdentifier);
+		setBounds(aBounds);
+		setTransform(aTransform);
+		setObjects(array);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineText object.
+	 */
+	public FSDefineText(FSDefineText obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		objects = new ArrayList(obj.objects.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.objects.iterator(); i.hasNext();)
+			objects.add(((FSText) i.next()).clone());
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A coordinate transform describing the placement, size and rotation of the text block.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a FSText object to the array of text records.
+	 * 
+	 * @param anObject
+	 *            an FSText object.
+	 */
+	public void add(FSText anObject)
+	{
+		objects.add(anObject);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText_4&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSText objects describing the characters to be displayed and their attributes.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the bounding rectangle that completely encloses the text to be
+	 * displayed.
+	 * 
+	 * @return the bounding rectangle of the text.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;p&gt;The bounding rectangle and transform controls how the text is laid out. Each FSText object in the textRecords array specifies an offset from the left and bottom edges of the bounding rectangle, allowing successive lines of text to be arranged as a block or paragraph. The coordinate transform can be used to control the size and orientation of the text when it is displayed.&lt;/p&gt;
+	/**
+	 * Gets the coordinate transform that controls how the text is displayed.
+	 * 
+	 * @return the coordinate transform.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the array of text records that define the text to be displayed as
+	 * its attributes.
+	 * 
+	 * @return the array of text records (FSTextStyle and FSText objects).
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-&lt;p&gt;Creating a simple string. The creation and layout of the glyphs to create the text is too onerous to perform from scratch. It is easier and more convenient to use existing font definitions either by parsing an existing Flash file or by converting a font definition from a specification such as TrueType in order to obtain the glyphs and layout information.&lt;/p&gt;
+	/**
+	 * Sets the bounding rectangle that encloses the text being displayed.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-&lt;p&gt;This examples assumes a font definition that contains glyphs for the following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font used fixed size for the spacing between glyphs .e.g. Courier.&lt;/p&gt;
+	/**
+	 * Sets the coordinate transform that changes the orientation and size of
+	 * the text displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-&lt;pre&gt;
-int fontSize = 240;
-int leading = 80;
+	/**
+	 * Sets the array of text records that define the text to be displayed.
+	 * 
+	 * @param anArray
+	 *            an array of FSText objects that define the text to be
+	 *            displayed.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-ArrayList characters = new ArrayList();
-ArrayList lines = new ArrayList();
+	public Object clone()
+	{
+		FSDefineText anObject = (FSDefineText) super.clone();
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
 
-// Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
-// the text is not indented or offset.
+		anObject.objects = new ArrayList(objects.size());
 
-lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize, characters);
+		for (Iterator i = objects.iterator(); i.hasNext();)
+			anObject.objects.add(((FSText) i.next()).clone());
 
-// Calculate the bounding rectangle that encloses the text.
-// The width of the text by summing all the advances.
+		return anObject;
+	}
 
-int width = 0;
-int height = fontSize + leading;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-for (Iterator i = characters.iterator(); i.hasNext();)
-    width += ((FSCharacter)i.next()).getAdvance();
+		if (super.equals(anObject))
+		{
+			FSDefineText typedObject = (FSDefineText) anObject;
 
-FSBounds bounds = new FSBounds(0, 0, width, height);
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-// Define the text with no coordinate transformation (use the default unity transform which leaves
-// the text unchanged.
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds, new FSCoordTransform(), lines);
+			if (objects != null)
+				result = result &amp;&amp; objects.equals(typedObject.objects);
+			else
+				result = result &amp;&amp; objects == typedObject.objects;
+		}
+		return result;
+	}
 
-&lt;/pre&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			Transform.append(buffer, &quot;objects&quot;, objects, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSDefineText class represents the DefineText tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDefineText extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private FSCoordTransform transform = null;
-    private ArrayList objects = null;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /**
-     * Construct an FSDefineText object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineText(FSCoder coder)
-    {
-        super(FSMovieObject.DefineText, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineText object with the specified bounding rectangle, coordinate transform and text records.
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-        @param anIdentifier the unique identifier for this object. Must be in the range 1..65535
-        @param aBounds the bounding rectangle enclosing the text. Must not be null.
-        @param aTransform an FSCoordTransform to change the size and orientation of 
-        the text. Must not be null.
-        @param array an array of FSText objects that define the text to be displayed.
-        Must not be null.
-        */
-    public FSDefineText(int anIdentifier, FSBounds aBounds, FSCoordTransform aTransform, ArrayList array)
-    {
-        super(FSMovieObject.DefineText, anIdentifier);
-        setBounds(aBounds);
-        setTransform(aTransform);
-        setObjects(array);
-    }
-    /**
-     * Constructs an FSDefineText object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineText object.
-     */
-    public FSDefineText(FSDefineText obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        transform = new FSCoordTransform(obj.transform);
-        
-        objects = new ArrayList(obj.objects.size());
-        
-        for (Iterator i = obj.objects.iterator(); i.hasNext();)
-            objects.add(((FSText)i.next()).clone());
-    }    
+		length += bounds.length(coder);
+		length += transform.length(coder);
+		length += 2;
 
-    /** Add a FSText object to the array of text records.
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			length += ((FSTransformObject) recordIterator.next()).length(coder);
 
-        @param anObject an FSText object.
-        */
-    public void add(FSText anObject) { objects.add(anObject); }
+		length += 1;
 
-    /** Gets the bounding rectangle that completely encloses the text to be displayed.
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
 
-        @return the bounding rectangle of the text.
-        */
-    public FSBounds  getBounds() { return bounds; }
+		return length;
+	}
 
-    /** Gets the coordinate transform that controls how the text is displayed.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @return the coordinate transform.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-    /** Gets the array of text records that define the text to be displayed as its attributes.
+		bounds.encode(coder);
+		transform.encode(coder);
 
-        @return the array of text records (FSTextStyle and FSText objects).
-        */
-    public ArrayList getObjects() 
-    {
-        return objects;
-    }
+		coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
+		coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
 
-    /** Sets the bounding rectangle that encloses the text being displayed.
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			((FSTransformObject) recordIterator.next()).encode(coder);
 
-        @param aBounds the bounding rectangle enclosing the text.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		coder.writeWord(0, 1);
 
-    /** Sets the coordinate transform that changes the orientation and size of the text displayed.
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		coder.endObject(name());
+	}
 
-        @param aTransform an FSCoordTransform to change the size and orientation of the text.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+	public void decode(FSCoder coder)
+	{
+		int glyphBits = 0;
+		int advanceBits = 0;
 
-    /** Sets the array of text records that define the text to be displayed.
+		super.decode(coder);
 
-        @param anArray an array of FSText objects that define the text to be displayed.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		// Mark the start of the tag body
 
-    public Object clone()
-    {
-        FSDefineText anObject = (FSDefineText)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        
-        anObject.objects = new ArrayList(objects.size());
-                    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-            anObject.objects.add(((FSText)i.next()).clone());
+		/* location */coder.getPointer();
 
-         return anObject;
-    }
+		bounds = new FSBounds(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineText typedObject = (FSDefineText)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		// This code is used to get round a bug in Flash - sometimes 16,
+		// 8-bit zeroes are written out before the transform. The root
+		// cause in Flash is unknown but seems to be related to the
+		// bounds not being set - all values are zero.
 
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
+		boolean bytesAreZero = true;
+		int start = coder.getPointer();
 
-            if (objects != null)
-                result = result &amp;&amp; objects.equals(typedObject.objects);
-            else
-                result = result &amp;&amp; objects == typedObject.objects;
-        }
-        return result;
-    }
+		for (int i = 0; i &lt; 16; i++)
+		{
+			if (coder.scanWord(1, false) != 0)
+				bytesAreZero = false;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+			coder.adjustPointer(8);
+		}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.setPointer(start);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		if (bytesAreZero)
+		{
+			for (int i = 0; i &lt; 16; i++)
+			{
+				coder.scanWord(1, false);
+				coder.adjustPointer(8);
+			}
+		}
 
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		// Back to reading the rest of the tag
 
-        length += bounds.length(coder);
-        length += transform.length(coder);
-        length += 2;
-            
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            length += ((FSTransformObject)recordIterator.next()).length(coder);
-    
-        length += 1;
+		transform = new FSCoordTransform(coder);
 
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		glyphBits = coder.readWord(1, false);
+		advanceBits = coder.readWord(1, false);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
 
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		/*
+		 * Set the instance variable directly since Flash files can contain
+		 * FSDefineText objects with no text records - this appears to be a bug
+		 * in the Flash file.
+		 */
+		objects = new ArrayList();
 
-        bounds.encode(coder);
-        transform.encode(coder);
-    
-        coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
-        coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
-    
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            ((FSTransformObject)recordIterator.next()).encode(coder);
+		while (coder.scanBits(8, false) != 0)
+			objects.add(new FSText(coder));
 
-        coder.writeWord(0, 1);
+		coder.readBits(8, false);
 
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int glyphBits = 0;
-        int advanceBits = 0;
-        
-        super.decode(coder);
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		coder.endObject(name());
+	}
 
-        // Mark the start of the tag body
-        
-        /* location */ coder.getPointer();
+	private int glyphBits()
+	{
+		int numberOfBits = 0;
 
-        bounds = new FSBounds(coder);
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).glyphBits());
 
-        // This code is used to get round a bug in Flash - sometimes 16, 
-        // 8-bit zeroes are written out before the transform. The root 
-        // cause in Flash is unknown but seems to be related to the 
-        // bounds not being set - all values are zero.
+		return numberOfBits;
+	}
 
-        boolean bytesAreZero = true;
-        int start = coder.getPointer();
-        
-        for (int i=0; i&lt;16; i++)
-        {
-            if (coder.scanWord(1, false) != 0)
-                 bytesAreZero = false;
-                 
-             coder.adjustPointer(8);
-        }
-        
-        coder.setPointer(start);
-        
-        if (bytesAreZero)
-        {
-            for (int i=0; i&lt;16; i++)
-            {
-                coder.scanWord(1, false);
-                coder.adjustPointer(8);
-            }
-        }
- 
-        // Back to reading the rest of the tag
+	private int advanceBits()
+	{
+		int numberOfBits = 1;
 
-        transform = new FSCoordTransform(coder);
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).advanceBits());
 
-        glyphBits = coder.readWord(1, false);
-        advanceBits = coder.readWord(1, false);
-
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
-        
-        /*
-         * Set the instance variable directly since Flash files can contain
-         * FSDefineText objects with no text records - this appears to be a 
-         * bug in the Flash file.
-         */
-        objects = new ArrayList();
-        
-        while (coder.scanBits(8, false) != 0)
-            objects.add(new FSText(coder));
-
-        coder.readBits(8, false);
-        
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    private int glyphBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).glyphBits());
-            
-        return numberOfBits;
-    }
-    
-    private int advanceBits()
-    {
-        int numberOfBits = 1;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).advanceBits());
-
-        return numberOfBits;
-    }
+		return numberOfBits;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineText2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineText2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineText2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,384 +33,463 @@
 import java.util.*;
 
 /**
-FSDefineText2 defines one or more lines of transparent text. 
- 
-&lt;p&gt;It extends the functionality provided by the FSDefineText class by supporting transparent colours. The characters, style and layout information is defined using FSText objects. The FSDefineText2 class acts as a container for the text, defining the bounding rectangle that encloses the text along with a coordinate transform that can be used to change the size and orientation of the text when it is displayed.&lt;/p&gt;
+ * FSDefineText2 defines one or more lines of transparent text.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by the FSDefineText class by supporting
+ * transparent colours. The characters, style and layout information is defined
+ * using FSText objects. The FSDefineText2 class acts as a container for the
+ * text, defining the bounding rectangle that encloses the text along with a
+ * coordinate transform that can be used to change the size and orientation of
+ * the text when it is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;A coordinate transform describing the placement, size and rotation of
+ * the text block.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSText objects describing the characters to be displayed and
+ * their attributes.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The bounding rectangle and transform controls how the text is laid out. Each
+ * FSText object in the textRecords array specifies an offset from the left and
+ * bottom edges of the bounding rectangle, allowing successive lines of text to
+ * be arranged as a block or paragraph. The coordinate transform can be used to
+ * control the size and orientation of the text when it is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Creating a simple string. The creation and layout of the glyphs to create the
+ * text is too onerous to perform from scratch. It is easier and more convenient
+ * to use existing font definitions either by parsing an existing Flash file or
+ * by converting a font definition from a specification such as TrueType in
+ * order to obtain the glyphs and layout information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * This examples assumes a font definition that contains glyphs for the
+ * following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font
+ * used fixed size for the spacing between glyphs .e.g. Courier.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int fontSize = 240;
+ * int leading = 80;
+ * 
+ * ArrayList characters = new ArrayList();
+ * ArrayList lines = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
+ * // the text is not indented or offset.
+ * 
+ * lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize,
+ * 				characters);
+ * 
+ * // Calculate the bounding rectangle that encloses the text.
+ * // The width of the text by summing all the advances.
+ * 
+ * int width = 0;
+ * int height = fontSize + leading;
+ * 
+ * for (Iterator i = characters.iterator(); i.hasNext();)
+ * 	width += ((FSCharacter) i.next()).getAdvance();
+ * 
+ * FSBounds bounds = new FSBounds(0, 0, width, height);
+ * 
+ * // Define the text with no coordinate transformation (use the default unity transform which leaves
+ * // the text unchanged.
+ * 
+ * FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds,
+ * 				new FSCoordTransform(), lines);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineText2 class represents the DefineText2 tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSDefineText2 extends FSDefineObject
+{
+	private FSBounds bounds = null;
+	private FSCoordTransform transform = null;
+	private ArrayList objects = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSDefineText2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineText2(FSCoder coder)
+	{
+		super(DefineText2, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText2 object with the specified bounding rectangle,
+	 * coordinate transform and text records.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text.
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text.
+	 * @param textRecordArray
+	 *            an array of text record (FSTextStyle and FSText) object that
+	 *            define the text to be displayed.
+	 */
+	public FSDefineText2(int anIdentifier, FSBounds aBounds,
+							FSCoordTransform aTransform,
+							ArrayList textRecordArray)
+	{
+		super(DefineText2, anIdentifier);
+		setBounds(aBounds);
+		setTransform(aTransform);
+		setObjects(textRecordArray);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDefineText2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineText object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineText object.
+	 */
+	public FSDefineText2(FSDefineText2 obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
+		objects = new ArrayList(obj.objects.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A bounding rectangle for the entire block of text defined in the object.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.objects.iterator(); i.hasNext();)
+			objects.add(((FSText) i.next()).clone());
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_3&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A coordinate transform describing the placement, size and rotation of the text block.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Add a FSText object to the array of text records.
+	 * 
+	 * @param anObject
+	 *            an FSText object.
+	 */
+	public void add(FSText anObject)
+	{
+		objects.add(anObject);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineText2_4&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSText objects describing the characters to be displayed and their attributes.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the bounding rectangle that completely encloses the text to be
+	 * displayed.
+	 * 
+	 * @return the bounding rectangle of the text.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-&lt;p&gt;The bounding rectangle and transform controls how the text is laid out. Each FSText object in the textRecords array specifies an offset from the left and bottom edges of the bounding rectangle, allowing successive lines of text to be arranged as a block or paragraph. The coordinate transform can be used to control the size and orientation of the text when it is displayed.&lt;/p&gt;
+	/**
+	 * Gets the coordinate transform that controls how the text is displayed.
+	 * 
+	 * @return the coordinate transform.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the array of text records that define the text to be displayed as
+	 * its attributes.
+	 * 
+	 * @return the array of text records (FSTextStyle and FSText objects).
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-&lt;p&gt;Creating a simple string. The creation and layout of the glyphs to create the text is too onerous to perform from scratch. It is easier and more convenient to use existing font definitions either by parsing an existing Flash file or by converting a font definition from a specification such as TrueType in order to obtain the glyphs and layout information.&lt;/p&gt;
+	/**
+	 * Sets the bounding rectangle that encloses the text being displayed.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-&lt;p&gt;This examples assumes a font definition that contains glyphs for the following set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font used fixed size for the spacing between glyphs .e.g. Courier.&lt;/p&gt;
+	/**
+	 * Sets the coordinate transform that changes the orientation and size of
+	 * the text displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform to change the size and orientation of the
+	 *            text.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-&lt;pre&gt;
-int fontSize = 240;
-int leading = 80;
+	/**
+	 * Sets the array of text records that define the text to be displayed.
+	 * 
+	 * @param anArray
+	 *            an array of FSText objects that define the text to be
+	 *            displayed.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-ArrayList characters = new ArrayList();
-ArrayList lines = new ArrayList();
+	public Object clone()
+	{
+		FSDefineText2 anObject = (FSDefineText2) super.clone();
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
 
-// Create the string setting the height to be 12-point (240 twips) and displaying the characters in black.
-// the text is not indented or offset.
+		anObject.objects = new ArrayList(objects.size());
 
-lines.add(new FSText(font.getIdentifier, FSColor.black()), 0, 0, fontSize, characters);
+		for (Iterator i = objects.iterator(); i.hasNext();)
+			anObject.objects.add(((FSText) i.next()).clone());
 
-// Calculate the bounding rectangle that encloses the text.
-// The width of the text by summing all the advances.
+		return anObject;
+	}
 
-int width = 0;
-int height = fontSize + leading;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-for (Iterator i = characters.iterator(); i.hasNext();)
-    width += ((FSCharacter)i.next()).getAdvance();
+		if (super.equals(anObject))
+		{
+			FSDefineText2 typedObject = (FSDefineText2) anObject;
 
-FSBounds bounds = new FSBounds(0, 0, width, height);
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-// Define the text with no coordinate transformation (use the default unity transform which leaves
-// the text unchanged.
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-FSDefineText text = new FSDefineText(movie.newIdentifier(), bounds, new FSCoordTransform(), lines);
+			if (objects != null)
+				result = result &amp;&amp; objects.equals(typedObject.objects);
+			else
+				result = result &amp;&amp; objects == typedObject.objects;
+		}
+		return result;
+	}
 
-&lt;/pre&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			Transform.append(buffer, &quot;objects&quot;, objects, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSDefineText2 class represents the DefineText2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSDefineText2 extends FSDefineObject
-{
-    private FSBounds bounds = null;
-    private FSCoordTransform transform = null;
-    private ArrayList objects = null;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /**
-     * Construct an FSDefineText2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineText2(FSCoder coder)
-    {
-        super(DefineText2, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineText2 object with the specified bounding rectangle, coordinate transform and text records.
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-    @param anIdentifier the unique identifier for this object.
-    @param aBounds the bounding rectangle enclosing the text.
-    @param aTransform an FSCoordTransform to change the size and orientation of the text.
-    @param textRecordArray an array of text record (FSTextStyle and FSText) object that define the text to be displayed.
-    */
-    public FSDefineText2(int anIdentifier, FSBounds aBounds, FSCoordTransform aTransform, ArrayList textRecordArray)
-    {
-        super(DefineText2, anIdentifier);
-        setBounds(aBounds);
-        setTransform(aTransform);
-        setObjects(textRecordArray);
-    }
-    /**
-     * Constructs an FSDefineText object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineText object.
-     */
-    public FSDefineText2(FSDefineText2 obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        transform = new FSCoordTransform(obj.transform);
-        
-        objects = new ArrayList(obj.objects.size());
-        
-        for (Iterator i = obj.objects.iterator(); i.hasNext();)
-            objects.add(((FSText)i.next()).clone());
-    }    
-    
-    /** Add a FSText object to the array of text records.
+		length += bounds.length(coder);
+		length += transform.length(coder);
+		length += 2;
 
-        @param anObject an FSText object.
-        */
-    public void add(FSText anObject) { objects.add(anObject); }
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			length += ((FSTransformObject) recordIterator.next()).length(coder);
 
-    /** Gets the bounding rectangle that completely encloses the text to be displayed.
+		length += 1;
 
-        @return the bounding rectangle of the text.
-        */
-    public FSBounds  getBounds() { return bounds; }
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
 
-    /** Gets the coordinate transform that controls how the text is displayed.
+		return length;
+	}
 
-        @return the coordinate transform.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Gets the array of text records that define the text to be displayed as its attributes.
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
 
-        @return the array of text records (FSTextStyle and FSText objects).
-        */
-    public ArrayList getObjects() 
-    {
-        return objects;
-    }
+		bounds.encode(coder);
+		transform.encode(coder);
 
-    /** Sets the bounding rectangle that encloses the text being displayed.
+		coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
+		coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
 
-        @param aBounds the bounding rectangle enclosing the text.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			((FSTransformObject) recordIterator.next()).encode(coder);
 
-    /** Sets the coordinate transform that changes the orientation and size of the text displayed.
+		coder.writeWord(0, 1);
 
-        @param aTransform an FSCoordTransform to change the size and orientation of the text.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		coder.endObject(name());
+	}
 
-    /** Sets the array of text records that define the text to be displayed.
+	public void decode(FSCoder coder)
+	{
+		int glyphBits = 0;
+		int advanceBits = 0;
 
-        @param anArray an array of FSText objects that define the text to be displayed.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		super.decode(coder);
 
-    public Object clone()
-    {
-        FSDefineText2 anObject = (FSDefineText2)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        
-        anObject.objects = new ArrayList(objects.size());
-                    
-        for (Iterator i = objects.iterator(); i.hasNext();)
-            anObject.objects.add(((FSText)i.next()).clone());
+		// Mark the start of the tag body
 
-        return anObject;
-    }
+		/* location */coder.getPointer();
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineText2 typedObject = (FSDefineText2)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		bounds = new FSBounds(coder);
 
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
+		// This code is used to get round a bug in Flash - sometimes 16,
+		// 8-bit zeroes are written out before the transform. The root
+		// cause in Flash is unknown but seems to be related to the
+		// bounds not being set - all values are zero.
 
-            if (objects != null)
-                result = result &amp;&amp; objects.equals(typedObject.objects);
-            else
-                result = result &amp;&amp; objects == typedObject.objects;
-        }
-        return result;
-    }
+		boolean bytesAreZero = true;
+		int start = coder.getPointer();
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		for (int i = 0; i &lt; 16; i++)
+		{
+			if (coder.scanWord(1, false) != 0)
+				bytesAreZero = false;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			coder.adjustPointer(8);
+		}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		coder.setPointer(start);
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		if (bytesAreZero)
+		{
+			for (int i = 0; i &lt; 16; i++)
+			{
+				coder.scanWord(1, false);
+				coder.adjustPointer(8);
+			}
+		}
 
-        length += bounds.length(coder);
-        length += transform.length(coder);
-        length += 2;
-            
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            length += ((FSTransformObject)recordIterator.next()).length(coder);
-    
-        length += 1;
+		// Back to reading the rest of the tag
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		transform = new FSCoordTransform(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		glyphBits = coder.readWord(1, false);
+		advanceBits = coder.readWord(1, false);
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits();
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits();
+		coder.context[FSCoder.TransparentColors] = 1;
+		coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
+		coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
 
-        bounds.encode(coder);
-        transform.encode(coder);
-    
-        coder.writeWord(coder.context[FSCoder.NumberOfGlyphBits], 1);
-        coder.writeWord(coder.context[FSCoder.NumberOfAdvanceBits], 1);
-    
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();) 
-            ((FSTransformObject)recordIterator.next()).encode(coder);
+		/*
+		 * Set the instance variable directly since Flash files can contain
+		 * FSDefineText objects with no text records - this appears to be a bug
+		 * in the Flash file.
+		 */
+		objects = new ArrayList();
 
-        coder.writeWord(0, 1);
+		while (coder.scanBits(8, false) != 0)
+			objects.add(new FSText(coder));
 
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int glyphBits = 0;
-        int advanceBits = 0;
-        
-        super.decode(coder);
+		coder.readBits(8, false);
 
-        // Mark the start of the tag body
-        
-        /* location */ coder.getPointer();
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.context[FSCoder.NumberOfGlyphBits] = 0;
+		coder.context[FSCoder.NumberOfAdvanceBits] = 0;
+		coder.endObject(name());
+	}
 
-        bounds = new FSBounds(coder);
+	private int glyphBits()
+	{
+		int numberOfBits = 0;
 
-        // This code is used to get round a bug in Flash - sometimes 16, 
-        // 8-bit zeroes are written out before the transform. The root 
-        // cause in Flash is unknown but seems to be related to the 
-        // bounds not being set - all values are zero.
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).glyphBits());
 
-        boolean bytesAreZero = true;
-        int start = coder.getPointer();
-        
-        for (int i=0; i&lt;16; i++)
-        {
-            if (coder.scanWord(1, false) != 0)
-                bytesAreZero = false;
-                 
-            coder.adjustPointer(8);
-        }
-        
-        coder.setPointer(start);
-        
-        if (bytesAreZero)
-        {
-            for (int i=0; i&lt;16; i++)
-            {
-                coder.scanWord(1, false);
-                coder.adjustPointer(8);
-            }
-        }
- 
-        // Back to reading the rest of the tag
+		return numberOfBits;
+	}
 
-        transform = new FSCoordTransform(coder);
+	private int advanceBits()
+	{
+		int numberOfBits = 0;
 
-        glyphBits = coder.readWord(1, false);
-        advanceBits = coder.readWord(1, false);
+		for (Iterator recordIterator = objects.iterator(); recordIterator
+						.hasNext();)
+			numberOfBits = Math.max(numberOfBits, ((FSText) recordIterator
+							.next()).advanceBits());
 
-        coder.context[FSCoder.TransparentColors] = 1;
-        coder.context[FSCoder.NumberOfGlyphBits] = glyphBits;
-        coder.context[FSCoder.NumberOfAdvanceBits] = advanceBits;
-        
-        /*
-         * Set the instance variable directly since Flash files can contain
-         * FSDefineText objects with no text records - this appears to be a 
-         * bug in the Flash file.
-         */
-        objects = new ArrayList();
-        
-        while (coder.scanBits(8, false) != 0)
-            objects.add(new FSText(coder));
-
-        coder.readBits(8, false);
-        
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.context[FSCoder.NumberOfGlyphBits] = 0;
-        coder.context[FSCoder.NumberOfAdvanceBits] = 0;
-        coder.endObject(name());
-    }
-    
-    private int glyphBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).glyphBits());
-            
-        return numberOfBits;
-    }
-    
-    private int advanceBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator recordIterator = objects.iterator(); recordIterator.hasNext();)
-            numberOfBits = Math.max(numberOfBits, ((FSText)recordIterator.next()).advanceBits());
-
-        return numberOfBits;
-    }
+		return numberOfBits;
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSDefineTextField.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineTextField.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineTextField.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,1089 +33,1249 @@
 import java.util.*;
 
 /**
-FSDefineTextField defines an editable text field. 
- 
-&lt;p&gt;The value entered into the text field is assigned to a specified variable 
-allowing the creation of forms to accept values entered by a person viewing the 
-Flash file.&lt;/p&gt;
+ * FSDefineTextField defines an editable text field.
+ * 
+ * &lt;p&gt;
+ * The value entered into the text field is assigned to a specified variable
+ * allowing the creation of forms to accept values entered by a person viewing
+ * the Flash file.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The class contains a complex set of attributes which allows a high degree of
+ * control over how a text field is displayed:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;bounds&lt;/td&gt;
+ * &lt;td&gt;The bounding rectangle for the text field.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;wordWrap&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text should be wrapped.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;multiline&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field contains multiple lines.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;password&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field will be used to display a password.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;readOnly&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field is read only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;selectable&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field is selectable.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;bordered&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field is bordered.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;HTML&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field contains HTML.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;fontIdentifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the font displayed in the text field.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;The height of the characters in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;useFontGlyphs&lt;/td&gt;
+ * &lt;td&gt;Use either the glyphs defined in the movie to display the text or load
+ * the specified from the platform on which the Flash Player is hosted.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;autosize&lt;/td&gt;
+ * &lt;td&gt;Indicates whether the text field will resize automatically to fit the
+ * text entered.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;colour&lt;/td&gt;
+ * &lt;td&gt;The colour of the text. If set to null then the text colour defaults to
+ * black.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;maxLength&lt;/td&gt;
+ * &lt;td&gt;The maximum length of the text field. May be set to zero is not maximum
+ * length is defined.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;variableName&lt;/td&gt;
+ * &lt;td&gt;The name of the variable the text will be assigned to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;initialText&lt;/td&gt;
+ * &lt;td&gt;The default text displayed in the text field.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Additional layout information for the spacing of the text relative to the
+ * text field borders can also be specified through the following set of
+ * attributes:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;alignment&lt;/td&gt;
+ * &lt;td&gt;Whether the text in the field is left-aligned, right-aligned, centred.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;leftMargin&lt;/td&gt;
+ * &lt;td&gt;Left margin in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;rightMargin&lt;/td&gt;
+ * &lt;td&gt;Right margin in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;indent&lt;/td&gt;
+ * &lt;td&gt;Text indentation in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;leading&lt;/td&gt;
+ * &lt;td&gt;Leading in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The default values for the alignment is AlignLeft while the leftMargin,
+ * rightMargin indent and leading attributes are set to the constant
+ * Transform.VALUE_NOT_SET. If the attributes remain unchanged then the layout
+ * information will not be encoded. If any of the values in this group are set
+ * then they must all have values assigned for the field to be displayed
+ * correctly otherwise default values of 0 will be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;HTML Support&lt;/b&gt;&lt;br/&gt; Setting the HTML flag to true allows text marked
+ * up with a limited set of HTML tags to be displayed in the text field. The
+ * following tags are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits a paragraph. Only the align attribute is supported:&lt;br&gt;
+ * &lt;p [align = left | right | center ]&gt;
+ * &lt;/p&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;br&gt;&lt;/td&gt;
+ * &lt;td&gt;Inserts a line break.&gt;
+ * &lt;/p&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Define a hyperlink. Two attributes are supported:
+ * &lt;ul&gt;
+ * &lt;li&gt;href - the URL of the link.&lt;/li&gt;
+ * &lt;li&gt;target - name of a window or frame. (optional)&lt;/li&gt;
+ * &lt;/ul&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;font&gt;&lt;/font&gt;&lt;/td&gt;
+ * &lt;td&gt;Format enclosed text using the font. Three attributes are supported:
+ * &lt;ul&gt;
+ * &lt;li&gt;name - must match the name of a font defined using the FSDefineFont2
+ * class.&lt;/li&gt;
+ * &lt;li&gt;size - the height of the font in twips.&lt;/li&gt;
+ * &lt;li&gt;color - the colour of the text in the hexadecimal format #RRGGBB.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * &lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits text that should be displayed in bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits text that should be displayed in italics.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
+ * &lt;td&gt;Delimits text that should be displayed underlined.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;li&gt;&lt;/li&gt;&lt;/td&gt;
+ * &lt;td&gt;Display bulleted paragraph. Strictly speaking this is not an HTML list.
+ * The &lt;ul&gt; tag is not required and no other list format is supported.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSDefineTextField class represents the DefineTextField from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSDefineTextField extends FSDefineObject
+{
+	/** Key used to identify the wordWrapped attribute. */
+	public static final String WordWrapped = &quot;WordWrapped&quot;;
 
-&lt;p&gt;The class contains a complex set of attributes which allows a high degree of 
-control over how a text field is displayed:&lt;/p&gt;
+	/** Key used to identify the multiline attribute. */
+	public static final String Multiline = &quot;Multiline&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Key used to identify the password attribute. */
+	public static final String Password = &quot;Password&quot;;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Key used to identify the readOnly attribute. */
+	public static final String ReadOnly = &quot;ReadOnly&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the selectable attribute. */
+	public static final String Selectable = &quot;Selectable&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An unique identifier for this object in the range 1..65535.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_2&quot;&gt;bounds&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The bounding rectangle for the text field.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_3&quot;&gt;wordWrap&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text should be wrapped.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_4&quot;&gt;multiline&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field contains multiple lines.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_5&quot;&gt;password&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field will be used to display a password.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_6&quot;&gt;readOnly&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field is read only.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_7&quot;&gt;selectable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field is selectable.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_8&quot;&gt;bordered&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field is bordered.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_9&quot;&gt;HTML&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field contains HTML.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_10&quot;&gt;fontIdentifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the font displayed in the text field.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_11&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The height of the characters in twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_12&quot;&gt;useFontGlyphs&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Use either the glyphs defined in the movie to display the text or load the 
-specified from the platform on which the Flash Player is hosted.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_13&quot;&gt;autosize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether the text field will resize automatically to fit the text 
-entered.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_14&quot;&gt;colour&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour of the text. If set to null then the text colour defaults to 
-black.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_15&quot;&gt;maxLength&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum length of the text field. May be set to zero is not maximum 
-length is defined.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_16&quot;&gt;variableName&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of the variable the text will be assigned to.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_17&quot;&gt;initialText&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The default text displayed in the text field.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/** Key used to identify the bordered attribute. */
+	public static final String Bordered = &quot;Bordered&quot;;
 
-&lt;p&gt;Additional layout information for the spacing of the text relative to the 
-text field borders can also be specified through the following set of 
-attributes:&lt;/p&gt;
+	/** Key used to identify the bordered attribute. */
+	public static final String HTML = &quot;HTML&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Key used to identify the useFontGlyphs attribute. */
+	public static final String UseFontGlyphs = &quot;UseFontGlyphs&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_17&quot;&gt;alignment&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the text in the 
-field is left-aligned, right-aligned, centred.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_18&quot;&gt;leftMargin&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Left margin in 
-twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_19&quot;&gt;rightMargin&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Right margin in 
-twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_20&quot;&gt;indent&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Text indentation in 
-twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineTextField_21&quot;&gt;leading&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Leading in twips.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	// Flash 6
+	/** Key used to identify the autoSize attribute. */
+	public static final String AutoSize = &quot;AutoSize&quot;;
 
-&lt;p&gt;The default values for the alignment is AlignLeft while the leftMargin, 
-rightMargin indent and leading attributes are set to the constant
-Transform.VALUE_NOT_SET. If the attributes remain unchanged then the layout 
-information will not be encoded. If any of the values in this group are set then 
-they must all have values assigned for the field to be displayed correctly
-otherwise default values of 0 will be used.&lt;/p&gt;
+	// End Flash 6
+	/** Key used to identify the identifier attribute. */
+	public static final String FontIdentifier = &quot;FontIdentifier&quot;;
 
-&lt;p&gt;&lt;b&gt;HTML Support&lt;/b&gt;&lt;br/&gt;
-Setting the HTML flag to true allows text marked up with a limited set of HTML 
-tags to be displayed in the text field. The following tags are supported:&lt;/p&gt;
+	/** Key used to identify the fontHeight attribute. */
+	public static final String FontHeight = &quot;FontHeight&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;
-&lt;td&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;
-&lt;td&gt;Delimits a paragraph. Only the align attribute is supported:&lt;br&gt;
-&lt;p [align = left | right | center ]&gt;&lt;/p&gt;
-&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the color attribute. */
+	public static final String Color = &quot;Color&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;br&gt;&lt;/td&gt;
-&lt;td&gt;Inserts a line break.&gt;&lt;/p&gt;&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the maxLength attribute. */
+	public static final String MaxLength = &quot;MaxLength&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a&gt;&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Define a hyperlink. Two attributes are supported:
-&lt;ul&gt;
-&lt;li&gt;href - the URL of the link.&lt;/li&gt;
-&lt;li&gt;target - name of a window or frame. (optional)&lt;/li&gt;
-&lt;/ul&gt;
-&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the leftMargin attribute. */
+	public static final String LeftMargin = &quot;LeftMargin&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;font&gt;&lt;/font&gt;&lt;/td&gt;
-&lt;td&gt;Format enclosed text using the font. Three attributes are supported:
-&lt;ul&gt;
-&lt;li&gt;name - must match the name of a font defined using the FSDefineFont2 class.&lt;/li&gt;
-&lt;li&gt;size - the height of the font in twips.&lt;/li&gt;
-&lt;li&gt;color - the colour of the text in the hexadecimal format #RRGGBB.&lt;/li&gt;
-&lt;/ul&gt;
-&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the rightMargin attribute. */
+	public static final String RightMargin = &quot;RightMargin&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
-&lt;td&gt;Delimits text that should be displayed in bold.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the indent attribute. */
+	public static final String Indent = &quot;Indent&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
-&lt;td&gt;Delimits text that should be displayed in italics.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the leading attribute. */
+	public static final String Leading = &quot;Leading&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt;
-&lt;td&gt;Delimits text that should be displayed underlined.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the variableName attribute. */
+	public static final String VariableName = &quot;VariableName&quot;;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;li&gt;&lt;/li&gt;&lt;/td&gt;
-&lt;td&gt;Display bulleted paragraph. Strictly speaking this is not an HTML list. 
-The &lt;ul&gt; tag is not required and no other list format is supported.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Key used to identify the initialText attribute. */
+	public static final String InitialText = &quot;InitialText&quot;;
 
-&lt;/table&gt;
+	/** Defines that the text displayed in a text field is left aligned. */
+	public static final int AlignLeft = 0;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/** Defines that the text displayed in a text field is right aligned. */
+	public static final int AlignRight = 1;
 
-&lt;p&gt;FSDefineTextField class represents the DefineTextField from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSDefineTextField extends FSDefineObject
-{
-/** Key used to identify the wordWrapped attribute. */
-    public static final String WordWrapped = &quot;WordWrapped&quot;;
-/** Key used to identify the multiline attribute. */
-    public static final String Multiline = &quot;Multiline&quot;;
-/** Key used to identify the password attribute. */
-    public static final String Password = &quot;Password&quot;;
-/** Key used to identify the readOnly attribute. */
-    public static final String ReadOnly = &quot;ReadOnly&quot;;
-/** Key used to identify the selectable attribute. */
-    public static final String Selectable = &quot;Selectable&quot;;
-/** Key used to identify the bordered attribute. */
-    public static final String Bordered = &quot;Bordered&quot;;
-/** Key used to identify the bordered attribute. */
-    public static final String HTML = &quot;HTML&quot;;
-/** Key used to identify the useFontGlyphs attribute. */
-    public static final String UseFontGlyphs = &quot;UseFontGlyphs&quot;;
-// Flash 6
-/** Key used to identify the autoSize attribute. */
-    public static final String AutoSize = &quot;AutoSize&quot;;
-// End Flash 6
-/** Key used to identify the identifier attribute. */
-    public static final String FontIdentifier = &quot;FontIdentifier&quot;;
-/** Key used to identify the fontHeight attribute. */
-    public static final String FontHeight = &quot;FontHeight&quot;;
-/** Key used to identify the color attribute. */
-    public static final String Color = &quot;Color&quot;;
-/** Key used to identify the maxLength attribute. */
-    public static final String MaxLength = &quot;MaxLength&quot;;
-/** Key used to identify the leftMargin attribute. */
-    public static final String LeftMargin = &quot;LeftMargin&quot;;
-/** Key used to identify the rightMargin attribute. */
-    public static final String RightMargin = &quot;RightMargin&quot;;
-/** Key used to identify the indent attribute. */
-    public static final String Indent = &quot;Indent&quot;;
-/** Key used to identify the leading attribute. */
-    public static final String Leading = &quot;Leading&quot;;
-/** Key used to identify the variableName attribute. */
-    public static final String VariableName = &quot;VariableName&quot;;
-/** Key used to identify the initialText attribute. */
-    public static final String InitialText = &quot;InitialText&quot;;
+	/** Defines that the text displayed in a text field is centre aligned. */
+	public static final int AlignCenter = 2;
 
+	/** Defines that the text displayed in a text field is justified. */
+	public static final int AlignJustify = 3;
 
-/** Defines that the text displayed in a text field is left aligned. */
-    public static final int AlignLeft = 0;
-/** Defines that the text displayed in a text field is right aligned. */
-    public static final int AlignRight = 1;
-/** Defines that the text displayed in a text field is centre aligned. */
-    public static final int AlignCenter = 2;
-/** Defines that the text displayed in a text field is justified. */
-    public static final int AlignJustify = 3;
-    
-    private FSBounds bounds = null;
-    private boolean wordWrapped = false;
-    private boolean multiline = false;
-    private boolean password = false;
-    private boolean readOnly = false;
-    private int reserved1 = 0;
-    private boolean selectable = false;
-    private boolean bordered = false;
-    private boolean reserved2 = false;
-    private boolean html = false;
-    private boolean useFontGlyphs = false;
-    private boolean autoSize = false;
-    private int fontIdentifier = 0;
-    private int fontHeight = 0;
-    private FSColor color = null;
-    private int maxLength = 0;
-    private int alignment = Transform.VALUE_NOT_SET;
-    private int leftMargin = Transform.VALUE_NOT_SET;
-    private int rightMargin = Transform.VALUE_NOT_SET;
-    private int indent = Transform.VALUE_NOT_SET;
-    private int leading = Transform.VALUE_NOT_SET;
-    private String variableName = &quot;&quot;;
-    private String initialText = &quot;&quot;;
+	private FSBounds bounds = null;
+	private boolean wordWrapped = false;
+	private boolean multiline = false;
+	private boolean password = false;
+	private boolean readOnly = false;
+	private int reserved1 = 0;
+	private boolean selectable = false;
+	private boolean bordered = false;
+	private boolean reserved2 = false;
+	private boolean html = false;
+	private boolean useFontGlyphs = false;
+	private boolean autoSize = false;
+	private int fontIdentifier = 0;
+	private int fontHeight = 0;
+	private FSColor color = null;
+	private int maxLength = 0;
+	private int alignment = Transform.VALUE_NOT_SET;
+	private int leftMargin = Transform.VALUE_NOT_SET;
+	private int rightMargin = Transform.VALUE_NOT_SET;
+	private int indent = Transform.VALUE_NOT_SET;
+	private int leading = Transform.VALUE_NOT_SET;
+	private String variableName = &quot;&quot;;
+	private String initialText = &quot;&quot;;
 
-    /**
-     * Construct an FSDefineTextField object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineTextField(FSCoder coder)
-    {
-        super(DefineTextField, 0);
-        decode(coder);
-    }
-    /** Constructs an FSDefineTextField object with the specified identifier and with the size defined by the bounding rectangle. All other attributes are set to their default values which will result in a blank, single-line, editable text field. Any values entered will not be assigned to a variable. Since no font is specified the text will be displayed in a non-spaced font 20 twips in height.
+	/**
+	 * Construct an FSDefineTextField object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineTextField(FSCoder coder)
+	{
+		super(DefineTextField, 0);
+		decode(coder);
+	}
 
-        @param anIdentifier the unique identifier for this object.
-        @param aBounds the bounding rectangle for the field which defines its size.
-        */
-    public FSDefineTextField(int anIdentifier, FSBounds aBounds)
-    {
-        super(DefineTextField, anIdentifier);
-        setBounds(aBounds);
-    }
-    /** Constructs an FSDefineTextField object setting the attributes added to the Hashtable. Each entry consists of a key-value pair. The key is one of the pre-defined attribute names while the value is an instance of a wrapper class (Boolean, Integer or String) that will be assigned to the specified attribute.
+	/**
+	 * Constructs an FSDefineTextField object with the specified identifier and
+	 * with the size defined by the bounding rectangle. All other attributes are
+	 * set to their default values which will result in a blank, single-line,
+	 * editable text field. Any values entered will not be assigned to a
+	 * variable. Since no font is specified the text will be displayed in a
+	 * non-spaced font 20 twips in height.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param aBounds
+	 *            the bounding rectangle for the field which defines its size.
+	 */
+	public FSDefineTextField(int anIdentifier, FSBounds aBounds)
+	{
+		super(DefineTextField, anIdentifier);
+		setBounds(aBounds);
+	}
 
-        @param anIdentifier the unique identifier for this object.
-        @param aBounds the bounding rectangle for the field which defines its size.
-        @param attributes a collection of key-value pairs identifying the attributes to be set.
-        */
-    public FSDefineTextField(int anIdentifier, FSBounds aBounds, Hashtable attributes)
-    {
-        super(DefineTextField, anIdentifier);
-        setBounds(aBounds);
-        setAttributes(attributes);
-    }
-    /**
-     * Constructs an FSDefineText object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineText object.
-     */
-    public FSDefineTextField(FSDefineTextField obj)
-    {
-        super(obj);
-        bounds = new FSBounds(obj.bounds);
-        wordWrapped = obj.wordWrapped;
-        multiline = obj.multiline;
-        password = obj.password;
-        readOnly = obj.readOnly;
-        reserved1 = obj.reserved1;
-        selectable = obj.selectable;
-        bordered = obj.bordered;
-        reserved2 = obj.reserved2;
-        html = obj.html;
-        useFontGlyphs = obj.useFontGlyphs;
-        autoSize = obj.autoSize;
-        fontIdentifier = obj.fontIdentifier;
-        fontHeight = obj.fontHeight;
-        color = new FSColor(obj.color);
-        maxLength = obj.maxLength;
-        alignment = obj.alignment;
-        leftMargin = obj.leftMargin;
-        rightMargin = obj.rightMargin;
-        indent = obj.indent;
-        leading = obj.leading;
-        variableName = new String(obj.variableName);
-        initialText = new String(obj.initialText);
-    }    
+	/**
+	 * Constructs an FSDefineTextField object setting the attributes added to
+	 * the Hashtable. Each entry consists of a key-value pair. The key is one of
+	 * the pre-defined attribute names while the value is an instance of a
+	 * wrapper class (Boolean, Integer or String) that will be assigned to the
+	 * specified attribute.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object.
+	 * @param aBounds
+	 *            the bounding rectangle for the field which defines its size.
+	 * @param attributes
+	 *            a collection of key-value pairs identifying the attributes to
+	 *            be set.
+	 */
+	public FSDefineTextField(int anIdentifier, FSBounds aBounds,
+								Hashtable attributes)
+	{
+		super(DefineTextField, anIdentifier);
+		setBounds(aBounds);
+		setAttributes(attributes);
+	}
 
-    /** Gets the bounding rectangle that completely encloses the text field.
+	/**
+	 * Constructs an FSDefineText object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineText object.
+	 */
+	public FSDefineTextField(FSDefineTextField obj)
+	{
+		super(obj);
+		bounds = new FSBounds(obj.bounds);
+		wordWrapped = obj.wordWrapped;
+		multiline = obj.multiline;
+		password = obj.password;
+		readOnly = obj.readOnly;
+		reserved1 = obj.reserved1;
+		selectable = obj.selectable;
+		bordered = obj.bordered;
+		reserved2 = obj.reserved2;
+		html = obj.html;
+		useFontGlyphs = obj.useFontGlyphs;
+		autoSize = obj.autoSize;
+		fontIdentifier = obj.fontIdentifier;
+		fontHeight = obj.fontHeight;
+		color = new FSColor(obj.color);
+		maxLength = obj.maxLength;
+		alignment = obj.alignment;
+		leftMargin = obj.leftMargin;
+		rightMargin = obj.rightMargin;
+		indent = obj.indent;
+		leading = obj.leading;
+		variableName = new String(obj.variableName);
+		initialText = new String(obj.initialText);
+	}
 
-        @return the bounding rectangle for the text field.
-        */
-    public FSBounds getBounds()
-    {
-        return bounds;
-    }
+	/**
+	 * Gets the bounding rectangle that completely encloses the text field.
+	 * 
+	 * @return the bounding rectangle for the text field.
+	 */
+	public FSBounds getBounds()
+	{
+		return bounds;
+	}
 
-    /** Does the text field support word wrapping.
+	/**
+	 * Does the text field support word wrapping.
+	 * 
+	 * @return a flag indicating whether the text in the field will be wrapped.
+	 */
+	public boolean isWordWrapped()
+	{
+		return wordWrapped;
+	}
 
-        @return a flag indicating whether the text in the field will be wrapped.
-        */
-    public boolean isWordWrapped()
-    {
-        return wordWrapped;
-    }
+	/**
+	 * Does the text field support multiple lines of text.
+	 * 
+	 * @return a flag indicating whether the text in the field will contain
+	 *         multiple lines.
+	 */
+	public boolean isMultiline()
+	{
+		return multiline;
+	}
 
-    /** Does the text field support multiple lines of text.
+	/**
+	 * Does the text field protect passwords being entered.
+	 * 
+	 * @return a flag indicating whether the text in the field represents a
+	 *         password.
+	 */
+	public boolean isPassword()
+	{
+		return password;
+	}
 
-        @return a flag indicating whether the text in the field will contain multiple lines.
-        */
-    public boolean  isMultiline()
-    {
-        return multiline;
-    }
+	/**
+	 * Is the text field read-only.
+	 * 
+	 * @return a flag indicating whether the text in the field is read-only.
+	 */
+	public boolean isReadOnly()
+	{
+		return readOnly;
+	}
 
-    /** Does the text field protect passwords being entered.
+	/**
+	 * Is the text field selectable.
+	 * 
+	 * @return a flag indicating whether the text in the field is selectable.
+	 */
+	public boolean isSelectable()
+	{
+		return selectable;
+	}
 
-        @return a flag indicating whether the text in the field represents a password.
-        */
-    public boolean isPassword()
-    {
-        return password;
-    }
+	/**
+	 * Is the text field bordered.
+	 * 
+	 * @return a flag indicating whether the text in the field is bordered.
+	 */
+	public boolean isBordered()
+	{
+		return bordered;
+	}
 
-    /** Is the text field read-only.
+	/**
+	 * Does the text field contain HTML.
+	 * 
+	 * @return a flag indicating whether the text in the field contains HTML.
+	 */
+	public boolean isHTML()
+	{
+		return html;
+	}
 
-        @return a flag indicating whether the text in the field is read-only.
-        */
-    public boolean isReadOnly()
-    {
-        return readOnly;
-    }
+	// Flash 6
+	/**
+	 * Does the text field resize to fit the contents.
+	 * 
+	 * @return a flag indicating whether the text field will resize
+	 *         automatically.
+	 */
+	public boolean isAutoSize()
+	{
+		return autoSize;
+	}
 
-    /** Is the text field selectable.
+	// End Flash 6
+	/**
+	 * Sets whether the text field will resize to fit the contents.
+	 * 
+	 * @param aFlag
+	 *            indicate whether the text field will resize automatically.
+	 */
+	public void setAutoSize(boolean aFlag)
+	{
+		autoSize = aFlag;
+	}
 
-        @return a flag indicating whether the text in the field is selectable.
-        */
-    public boolean isSelectable()
-    {
-        return selectable;
-    }
+	/**
+	 * Indicates whether the test will be displayed using the font defined in
+	 * the movie or whether a font defined on the host platform will be used.
+	 * 
+	 * @return true if the text will be displayed using the glyphs from the font
+	 *         defined in the movie, false if the glyphs will be loaded from the
+	 *         platform on which the Flash Player is hosted.
+	 */
+	public boolean useFontGlyphs()
+	{
+		return useFontGlyphs;
+	}
 
-    /** Is the text field bordered.
+	/**
+	 * Gets the identifier of the font used to display the characters.
+	 * 
+	 * @return the font identifier.
+	 */
+	public int getFontIdentifier()
+	{
+		return fontIdentifier;
+	}
 
-        @return a flag indicating whether the text in the field is bordered.
-        */
-    public boolean isBordered()
-    {
-        return bordered;
-    }
+	/**
+	 * Gets the height of the characters.
+	 * 
+	 * @return the height of the font.
+	 */
+	public int getFontHeight()
+	{
+		return fontHeight;
+	}
 
-    /** Does the text field contain HTML.
+	/**
+	 * Gets the text color.
+	 * 
+	 * @return the color of the text.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-        @return a flag indicating whether the text in the field contains HTML.
-        */
-    public boolean isHTML()
-    {
-        return html;
-    }
+	/**
+	 * Gets the maximum length of the text displayed.
+	 * 
+	 * @return the maximum number of characters displayed.
+	 */
+	public int getMaxLength()
+	{
+		return maxLength;
+	}
 
-// Flash 6
-    /** Does the text field resize to fit the contents.
-    
-        @return a flag indicating whether the text field will resize automatically. 
-      */
-    public boolean isAutoSize()
-    {
-        return autoSize;
-    }
-// End Flash 6
-    /** Sets whether the text field will resize to fit the contents.
-     *
-     * @param aFlag indicate whether the text field will resize automatically.
-     */
-    public void setAutoSize(boolean aFlag)
-    {
-        autoSize = aFlag;
-    }
+	/**
+	 * Gets the alignment of the text, either AlignLeft, AlignRight, AlignCenter
+	 * or AlignJustify.
+	 * 
+	 * @return the alignment code.
+	 */
+	public int getAlignment()
+	{
+		return alignment;
+	}
 
-    /** 
-     * Indicates whether the test will be displayed using the font defined in the movie or 
-     * whether a font defined on the host platform will be used.
-     *
-     * @return true if the text will be displayed using the glyphs from the font defined 
-     * in the movie, false if the glyphs will be loaded from the platform on which the 
-     * Flash Player is hosted.
-     */
-    public boolean useFontGlyphs()
-    {
-        return useFontGlyphs;
-    }
+	/**
+	 * Gets the left margin in twips.
+	 * 
+	 * @return the left margin.
+	 */
+	public int getLeftMargin()
+	{
+		return leftMargin;
+	}
 
-    /** Gets the identifier of the font used to display the characters.
+	/**
+	 * Gets the right margin in twips.
+	 * 
+	 * @return the right margin.
+	 */
+	public int getRightMargin()
+	{
+		return rightMargin;
+	}
 
-        @return the font identifier.
-        */
-    public int getFontIdentifier()
-    {
-        return fontIdentifier;
-    }
+	/**
+	 * Gets the indentation of the first line of text in twips.
+	 * 
+	 * @return the indentation of the first line.
+	 */
+	public int getIndent()
+	{
+		return indent;
+	}
 
-    /** Gets the height of the characters.
+	/**
+	 * Gets the leading in twips.
+	 * 
+	 * @return the leading.
+	 */
+	public int getLeading()
+	{
+		return leading;
+	}
 
-        @return the height of the font.
-        */
-    public int getFontHeight()
-    {
-        return fontHeight;
-    }
+	/**
+	 * Gets the name of the variable the value in the text field will be
+	 * assigned to.
+	 * 
+	 * @return the name of the variable.
+	 */
+	public String getVariableName()
+	{
+		return variableName;
+	}
 
-    /** Gets the text color.
+	/**
+	 * Gets the default text displayed in the field.
+	 * 
+	 * @return the default value displayed in the field.
+	 */
+	public String getInitialText()
+	{
+		return initialText;
+	}
 
-        @return the color of the text.
-        */
-    public FSColor getColor()
-    {
-        return color;
-    }
+	/**
+	 * Gets the list of attributes for the object. The Hashtable contains a list
+	 * of key-value pairs. The key is one of the pre-defined attribute names
+	 * while the value is an instance of a wrapper class (Boolean, Integer or
+	 * String) that contains the corresponding object attribute.
+	 * 
+	 * @return the list of attributes for the object.
+	 */
+	public Hashtable getAttributes()
+	{
+		Hashtable attributes = new Hashtable();
 
-    /** Gets the maximum length of the text displayed.
+		attributes.put(WordWrapped, new Boolean(isWordWrapped()));
+		attributes.put(Multiline, new Boolean(isMultiline()));
+		attributes.put(Password, new Boolean(isPassword()));
+		attributes.put(ReadOnly, new Boolean(isReadOnly()));
+		// Flash 6
+		attributes.put(AutoSize, new Boolean(isAutoSize()));
+		// End Flash 6
+		attributes.put(Selectable, new Boolean(isSelectable()));
+		attributes.put(Bordered, new Boolean(isBordered()));
+		attributes.put(HTML, new Boolean(isHTML()));
+		attributes.put(UseFontGlyphs, new Boolean(useFontGlyphs()));
+		attributes.put(FontIdentifier, new Integer(getFontIdentifier()));
+		attributes.put(FontHeight, new Integer(getFontHeight()));
+		attributes.put(Color, getColor());
+		attributes.put(MaxLength, new Integer(getMaxLength()));
+		attributes.put(LeftMargin, new Integer(getLeftMargin()));
+		attributes.put(RightMargin, new Integer(getRightMargin()));
+		attributes.put(Indent, new Integer(getIndent()));
+		attributes.put(Leading, new Integer(getLeading()));
+		attributes.put(VariableName, getVariableName());
+		attributes.put(InitialText, getInitialText());
 
-        @return the maximum number of characters displayed.
-        */
-    public int getMaxLength()
-    {
-        return maxLength;
-    }
+		return attributes;
+	}
 
-    /** Gets the alignment of the text, either AlignLeft, AlignRight, AlignCenter or AlignJustify.
+	/**
+	 * Sets the bounding rectangle of the text field.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle enclosing the text field.
+	 */
+	public void setBounds(FSBounds aBounds)
+	{
+		bounds = aBounds;
+	}
 
-        @return the alignment code.
-        */
-    public int getAlignment()
-    {
-        return alignment;
-    }
+	/**
+	 * Set whether the text field supports word wrapping.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is word wrapped.
+	 */
+	public void setWordWrapped(boolean aFlag)
+	{
+		wordWrapped = aFlag;
+	}
 
-    /** Gets the left margin in twips.
+	/**
+	 * Set whether the text field contains multiple lines of text.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is multiline.
+	 */
+	public void setMultiline(boolean aFlag)
+	{
+		multiline = aFlag;
+	}
 
-        @return the left margin.
-        */
-    public int getLeftMargin() 
-    {    
-        return leftMargin;
-    }
+	/**
+	 * Set whether the text field should protect passwords entered.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is password protected.
+	 */
+	public void setPassword(boolean aFlag)
+	{
+		password = aFlag;
+	}
 
-    /** Gets the right margin in twips.
+	/**
+	 * Set whether the text field is read-only.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is read-only.
+	 */
+	public void setReadOnly(boolean aFlag)
+	{
+		readOnly = aFlag;
+	}
 
-        @return the right margin.
-        */
-    public int getRightMargin() 
-    {
-        return rightMargin;
-    }
+	/**
+	 * Set whether the text field is selectable.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is selectable.
+	 */
+	public void setSelectable(boolean aFlag)
+	{
+		selectable = !aFlag;
+	}
 
-    /** Gets the indentation of the first line of text in twips.
+	/**
+	 * Set whether the text field is bordered.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field is bordered.
+	 */
+	public void setBordered(boolean aFlag)
+	{
+		bordered = aFlag;
+	}
 
-        @return the indentation of the first line.
-        */
-    public int getIndent()
-    {
-        return indent;
-    }
+	/**
+	 * Set whether the text field contains HTML.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field contains HTML.
+	 */
+	public void setHTML(boolean aFlag)
+	{
+		html = aFlag;
+	}
 
-    /** Gets the leading in twips.
+	/**
+	 * Set whether the text field characters are displayed using the font
+	 * defined in the movie or whether the Flash Player uses a font definition
+	 * loaded from the platform on which it is hosted.
+	 * 
+	 * @param aFlag
+	 *            set whether the text field characters will be drawn using the
+	 *            font in the movie (true) or use a font loaded by the Flash
+	 *            Player (false).
+	 */
+	public void setUseFontGlyphs(boolean aFlag)
+	{
+		useFontGlyphs = aFlag;
+	}
 
-        @return the leading.
-        */
-    public int getLeading()
-    {
-        return leading;
-    }
+	/**
+	 * Sets the identifier of the font used to display the characters.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier for the font that the text will be rendered in.
+	 */
+	public void setFontIdentifier(int anIdentifier)
+	{
+		fontIdentifier = anIdentifier;
+	}
 
-    /** Gets the name of the variable the value in the text field will be assigned to.
+	/**
+	 * Sets the height of the characters.
+	 * 
+	 * @param aNumber
+	 *            the height of the font.
+	 */
+	public void setFontHeight(int aNumber)
+	{
+		fontHeight = aNumber;
+	}
 
-        @return the name of the variable.
-        */
-    public String getVariableName()
-    {
-        return variableName;
-    }
+	/**
+	 * Sets the text color. If set to null then the text color defaults to
+	 * black.
+	 * 
+	 * @param aColor
+	 *            the colour object that defines the text colour.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-    /** Gets the default text displayed in the field.
+	/**
+	 * Sets the maximum length of the text displayed. May be set to zero if no
+	 * maximum length is defined.
+	 * 
+	 * @param aNumber
+	 *            the maximum number of characters displayed in the field.
+	 */
+	public void setMaxLength(int aNumber)
+	{
+		maxLength = aNumber;
+	}
 
-        @return the default value displayed in the field.
-    */
-    public String getInitialText()
-    {
-        return initialText;
-    }
+	/**
+	 * Sets the alignment of the text, either AlignLeft, AlignRight, AlignCenter
+	 * or AlignJustify.
+	 * 
+	 * @param aType
+	 *            the type of alignment.
+	 */
+	public void setAlignment(int aType)
+	{
+		alignment = aType;
+	}
 
-    /** Gets the list of attributes for the object. The Hashtable contains a list of key-value pairs. The key is one of the pre-defined attribute names while the value is an instance of a wrapper class (Boolean, Integer or String) that contains the corresponding object attribute.
+	/**
+	 * Sets the left margin in twips.
+	 * 
+	 * @param aNumber
+	 *            the width of the left margin.
+	 */
+	public void setLeftMargin(int aNumber)
+	{
+		leftMargin = aNumber;
+	}
 
-        @return the list of attributes for the object.
-        */
-    public Hashtable getAttributes()
-    {
-        Hashtable attributes = new Hashtable();
-        
-        attributes.put(WordWrapped, new Boolean(isWordWrapped()));
-        attributes.put(Multiline, new Boolean(isMultiline()));
-        attributes.put(Password, new Boolean(isPassword()));
-        attributes.put(ReadOnly, new Boolean(isReadOnly()));
-// Flash 6
-        attributes.put(AutoSize, new Boolean(isAutoSize()));
-// End Flash 6
-        attributes.put(Selectable, new Boolean(isSelectable()));
-        attributes.put(Bordered, new Boolean(isBordered()));
-        attributes.put(HTML, new Boolean(isHTML()));
-        attributes.put(UseFontGlyphs, new Boolean(useFontGlyphs()));
-        attributes.put(FontIdentifier, new Integer(getFontIdentifier()));
-        attributes.put(FontHeight, new Integer(getFontHeight()));
-        attributes.put(Color, getColor());
-        attributes.put(MaxLength, new Integer(getMaxLength()));
-        attributes.put(LeftMargin, new Integer(getLeftMargin()));
-        attributes.put(RightMargin, new Integer(getRightMargin()));
-        attributes.put(Indent, new Integer(getIndent()));
-        attributes.put(Leading, new Integer(getLeading()));
-        attributes.put(VariableName, getVariableName());
-        attributes.put(InitialText, getInitialText());
-        
-        return attributes;
-    }
+	/**
+	 * Sets the right margin in twips.
+	 * 
+	 * @param aNumber
+	 *            the width of the right margin.
+	 */
+	public void setRightMargin(int aNumber)
+	{
+		rightMargin = aNumber;
+	}
 
-    /** Sets the bounding rectangle of the text field.
+	/**
+	 * Gets the indentation of the first line of text in twips.
+	 * 
+	 * @param aNumber
+	 *            the indentation for the first line.
+	 */
+	public void setIndent(int aNumber)
+	{
+		indent = aNumber;
+	}
 
-        @param aBounds the bounding rectangle enclosing the text field.
-        */
-    public void setBounds(FSBounds aBounds)
-    {
-        bounds = aBounds;
-    }
+	/**
+	 * Sets the leading in twips.
+	 * 
+	 * @param aNumber
+	 *            the value for the leading.
+	 */
+	public void setLeading(int aNumber)
+	{
+		leading = aNumber;
+	}
 
-    /** Set whether the text field supports word wrapping.
+	/**
+	 * Sets the name of the variable the value in the text field will be
+	 * assigned to.
+	 * 
+	 * @param aString
+	 *            the name of the variable.
+	 */
+	public void setVariableName(String aString)
+	{
+		variableName = aString;
+	}
 
-        @param aFlag set whether the text field is word wrapped.
-        */
-    public void setWordWrapped(boolean aFlag)
-    {
-        wordWrapped = aFlag;
-    }
+	/**
+	 * Sets the value that will initially be displayed in the text field.
+	 * 
+	 * @param aString
+	 *            the initial text displayed.
+	 */
+	public void setInitialText(String aString)
+	{
+		initialText = aString;
+	}
 
-    /** Set whether the text field contains multiple lines of text.
+	/**
+	 * Sets the attributes for the object. The Hashtable contains a list of
+	 * key-value pairs. The key is one of the pre-defined attribute names while
+	 * the value is an instance of a wrapper class (Boolean, Integer or String)
+	 * that will be assigned to the specified attribute.
+	 * 
+	 * @param attributes
+	 *            the list of attributes for the object.
+	 */
+	public void setAttributes(Hashtable attributes)
+	{
+		if (attributes.get(WordWrapped) != null)
+			setWordWrapped(((Boolean) attributes.get(WordWrapped))
+							.booleanValue());
+		if (attributes.get(Multiline) != null)
+			setMultiline(((Boolean) attributes.get(Multiline)).booleanValue());
+		if (attributes.get(Password) != null)
+			setPassword(((Boolean) attributes.get(Password)).booleanValue());
+		if (attributes.get(ReadOnly) != null)
+			setReadOnly(((Boolean) attributes.get(ReadOnly)).booleanValue());
+		if (attributes.get(Selectable) != null)
+			setSelectable(((Boolean) attributes.get(Selectable)).booleanValue());
+		if (attributes.get(Bordered) != null)
+			setBordered(((Boolean) attributes.get(Bordered)).booleanValue());
+		if (attributes.get(HTML) != null)
+			setHTML(((Boolean) attributes.get(HTML)).booleanValue());
+		// Flash 6
+		if (attributes.get(AutoSize) != null)
+			setAutoSize(((Boolean) attributes.get(AutoSize)).booleanValue());
+		// End Flash 6
+		if (attributes.get(UseFontGlyphs) != null)
+			setUseFontGlyphs(((Boolean) attributes.get(UseFontGlyphs))
+							.booleanValue());
+		if (attributes.get(FontIdentifier) != null)
+			setFontIdentifier(((Integer) attributes.get(FontIdentifier))
+							.intValue());
+		if (attributes.get(FontHeight) != null)
+			setFontHeight(((Integer) attributes.get(FontHeight)).intValue());
+		if (attributes.get(Color) != null)
+			setColor((FSColor) attributes.get(Color));
+		if (attributes.get(MaxLength) != null)
+			setMaxLength(((Integer) attributes.get(MaxLength)).intValue());
+		if (attributes.get(LeftMargin) != null)
+			setLeftMargin(((Integer) attributes.get(LeftMargin)).intValue());
+		if (attributes.get(RightMargin) != null)
+			setRightMargin(((Integer) attributes.get(RightMargin)).intValue());
+		if (attributes.get(Indent) != null)
+			setIndent(((Integer) attributes.get(Indent)).intValue());
+		if (attributes.get(Leading) != null)
+			setLeading(((Integer) attributes.get(Leading)).intValue());
+		if (attributes.get(VariableName) != null)
+			setVariableName((String) attributes.get(VariableName));
+		if (attributes.get(InitialText) != null)
+			setInitialText((String) attributes.get(InitialText));
+	}
 
-        @param aFlag set whether the text field is multiline.
-        */
-    public void setMultiline(boolean aFlag)
-    {
-        multiline = aFlag;
-    }
+	public Object clone()
+	{
+		FSDefineTextField anObject = (FSDefineTextField) super.clone();
 
-    /** Set whether the text field should protect passwords entered.
+		anObject.bounds = (bounds != null) ? (FSBounds) bounds.clone() : null;
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-        @param aFlag set whether the text field is password protected.
-        */
-    public void setPassword(boolean aFlag)
-    {
-        password = aFlag;
-    }
+		return anObject;
+	}
 
-    /** Set whether the text field is read-only.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param aFlag set whether the text field is read-only.
-        */
-    public void setReadOnly(boolean aFlag)
-    {
-        readOnly = aFlag;
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineTextField typedObject = (FSDefineTextField) anObject;
 
-    /** Set whether the text field is selectable.
+			if (bounds != null)
+				result = bounds.equals(typedObject.bounds);
+			else
+				result = bounds == typedObject.bounds;
 
-        @param aFlag set whether the text field is selectable.
-        */
-    public void setSelectable(boolean aFlag)
-    {
-        selectable = !aFlag;
-    }
+			result = result &amp;&amp; wordWrapped == typedObject.wordWrapped;
+			result = result &amp;&amp; multiline == typedObject.multiline;
+			result = result &amp;&amp; password == typedObject.password;
+			result = result &amp;&amp; readOnly == typedObject.readOnly;
+			result = result &amp;&amp; reserved1 == typedObject.reserved1;
+			// Flash 6
+			result = result &amp;&amp; autoSize == typedObject.autoSize;
+			// End Flash 6
+			result = result &amp;&amp; selectable == typedObject.selectable;
+			result = result &amp;&amp; bordered == typedObject.bordered;
+			result = result &amp;&amp; reserved2 == typedObject.reserved2;
+			result = result &amp;&amp; html == typedObject.html;
+			result = result &amp;&amp; useFontGlyphs == typedObject.useFontGlyphs;
+			result = result &amp;&amp; fontIdentifier == typedObject.fontIdentifier;
+			result = result &amp;&amp; fontHeight == typedObject.fontHeight;
 
-    /** Set whether the text field is bordered.
+			if (color != null)
+				result = result &amp;&amp; color.equals(typedObject.color);
+			else
+				result = result &amp;&amp; color == typedObject.color;
 
-        @param aFlag set whether the text field is bordered.
-        */
-    public void setBordered(boolean aFlag)
-    {
-        bordered = aFlag;
-    }
+			result = result &amp;&amp; maxLength == typedObject.maxLength;
 
-    /** Set whether the text field contains HTML.
+			if (containsLayoutInfo())
+			{
+				result = result &amp;&amp; alignment == typedObject.alignment;
+				result = result &amp;&amp; leftMargin == typedObject.leftMargin;
+				result = result &amp;&amp; rightMargin == typedObject.rightMargin;
+				result = result &amp;&amp; indent == typedObject.indent;
+				result = result &amp;&amp; leading == typedObject.leading;
+			}
 
-        @param aFlag set whether the text field contains HTML.
-        */
-    public void setHTML(boolean aFlag)
-    {
-        html = aFlag;
-    }
+			if (variableName != null)
+				result = result
+								&amp;&amp; variableName
+												.equals(typedObject.variableName);
+			else
+				result = result &amp;&amp; variableName == typedObject.variableName;
 
-    /** 
-     * Set whether the text field characters are displayed using the font defined in the movie 
-     * or whether the Flash Player uses a font definition loaded from the platform on which it 
-     * is hosted.
-     *
-     * @param aFlag set whether the text field characters will be drawn using the font in the 
-     * movie (true) or use a font loaded by the Flash Player (false).
-        */
-    public void setUseFontGlyphs(boolean aFlag)
-    {
-        useFontGlyphs = aFlag;
-    }
+			if (initialText != null)
+				result = result &amp;&amp; initialText.equals(typedObject.initialText);
+			else
+				result = result &amp;&amp; initialText == typedObject.initialText;
+		}
+		return result;
+	}
 
-    /** Sets the identifier of the font used to display the characters.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param anIdentifier the identifier for the font that the text will be rendered in.
-        */
-    public void setFontIdentifier(int anIdentifier)
-    {
-        fontIdentifier = anIdentifier;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
+			Transform.append(buffer, &quot;wordWrapped&quot;, wordWrapped);
+			Transform.append(buffer, &quot;multiline&quot;, multiline);
+			Transform.append(buffer, &quot;password&quot;, password);
+			Transform.append(buffer, &quot;readOnly&quot;, readOnly);
+			// Flash 6
+			Transform.append(buffer, &quot;autoSize&quot;, autoSize);
+			// End Flash 6
+			Transform.append(buffer, &quot;selectable&quot;, selectable);
+			Transform.append(buffer, &quot;bordered&quot;, bordered);
+			Transform.append(buffer, &quot;HTML&quot;, html);
+			Transform.append(buffer, &quot;useFontGlyphs&quot;, useFontGlyphs);
+			Transform.append(buffer, &quot;fontIdentifier&quot;, fontIdentifier);
+			Transform.append(buffer, &quot;fontHeight&quot;, fontHeight);
+			Transform.append(buffer, &quot;color&quot;, color, depth);
+			Transform.append(buffer, &quot;maxLength&quot;, maxLength);
+			Transform.append(buffer, &quot;alignment&quot;, alignment);
+			Transform.append(buffer, &quot;leftMargin&quot;, leftMargin);
+			Transform.append(buffer, &quot;rightMargin&quot;, rightMargin);
+			Transform.append(buffer, &quot;indent&quot;, indent);
+			Transform.append(buffer, &quot;leading&quot;, leading);
+			Transform.append(buffer, &quot;variableName&quot;, variableName);
+			Transform.append(buffer, &quot;initalText&quot;, initialText);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the height of the characters.
+	public int length(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsMaxLength = containsMaxLength();
+		boolean _containsText = containsText();
 
-        @param aNumber the height of the font.
-        */
-    public void setFontHeight(int aNumber)
-    {
-        fontHeight = aNumber;
-    }
+		super.length(coder);
 
-    /** Sets the text color. If set to null then the text color defaults to black.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @param aColor the colour object that defines the text colour.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+		length += bounds.length(coder);
+		length += 2;
+		length += (_containsFont) ? 4 : 0;
+		length += (_containsColor) ? color.length(coder) : 0;
+		length += (_containsMaxLength) ? 2 : 0;
+		length += (containsLayoutInfo()) ? 9 : 0;
+		length += coder.strlen(variableName, true);
+		length += (_containsText) ? coder.strlen(initialText, true) : 0;
 
-    /** Sets the maximum length of the text displayed. May be set to zero if no maximum length is defined.
+		coder.context[FSCoder.TransparentColors] = 0;
 
-        @param aNumber the maximum number of characters displayed in the field.
-        */
-    public void setMaxLength(int aNumber)
-    {
-        maxLength = aNumber;
-    }
+		return length;
+	}
 
-    /** Sets the alignment of the text, either AlignLeft, AlignRight, AlignCenter or AlignJustify.
+	public void encode(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsMaxLength = containsMaxLength();
+		boolean _containsText = containsText();
 
-        @param aType the type of alignment.
-        */
-    public void setAlignment(int aType)
-    {
-        alignment = aType;
-    }
+		super.encode(coder);
 
-    /** Sets the left margin in twips.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @param aNumber the width of the left margin.
-        */
-    public void setLeftMargin(int aNumber)
-    {
-        leftMargin = aNumber;
-    }
+		bounds.encode(coder);
+		coder.writeBits(_containsText ? 1 : 0, 1);
+		coder.writeBits(wordWrapped ? 1 : 0, 1);
+		coder.writeBits(multiline ? 1 : 0, 1);
+		coder.writeBits(password ? 1 : 0, 1);
+		coder.writeBits(readOnly ? 1 : 0, 1);
+		coder.writeBits(_containsColor ? 1 : 0, 1);
+		coder.writeBits(_containsMaxLength ? 1 : 0, 1);
+		coder.writeBits(_containsFont ? 1 : 0, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(autoSize ? 1 : 0, 1);
+		coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
+		coder.writeBits(selectable ? 1 : 0, 1);
+		coder.writeBits(bordered ? 1 : 0, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(html ? 1 : 0, 1);
+		coder.writeBits(useFontGlyphs ? 1 : 0, 1);
 
-    /** Sets the right margin in twips.
+		if (_containsFont)
+		{
+			coder.writeWord(fontIdentifier, 2);
+			coder.writeWord(fontHeight, 2);
+		}
 
-        @param aNumber the width of the right margin.
-        */
-    public void setRightMargin(int aNumber)
-    {
-        rightMargin = aNumber;
-    }
+		if (_containsColor)
+			color.encode(coder);
 
-    /** Gets the indentation of the first line of text in twips.
+		if (_containsMaxLength)
+			coder.writeWord(maxLength, 2);
 
-        @param aNumber the indentation for the first line.
-        */
-    public void setIndent(int aNumber)
-    {
-        indent = aNumber;
-    }
+		if (containsLayoutInfo())
+		{
+			coder.writeWord((alignment != Transform.VALUE_NOT_SET) ? alignment
+							: 0, 1);
+			coder
+							.writeWord(
+											(leftMargin != Transform.VALUE_NOT_SET) ? leftMargin
+															: 0, 2);
+			coder
+							.writeWord(
+											(rightMargin != Transform.VALUE_NOT_SET) ? rightMargin
+															: 0, 2);
+			coder
+							.writeWord(
+											(indent != Transform.VALUE_NOT_SET) ? indent
+															: 0, 2);
+			coder.writeWord((leading != Transform.VALUE_NOT_SET) ? leading : 0,
+							2);
+		}
 
-    /** Sets the leading in twips.
+		coder.writeString(variableName);
+		coder.writeWord(0, 1);
 
-        @param aNumber the value for the leading.
-        */
-    public void setLeading(int aNumber)
-    {
-        leading = aNumber;
-    }
+		if (_containsText)
+		{
+			coder.writeString(initialText);
+			coder.writeWord(0, 1);
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.endObject(name());
+	}
 
-    /** Sets the name of the variable the value in the text field will be assigned to.
+	public void decode(FSCoder coder)
+	{
+		boolean _containsFont = false;
+		boolean _containsColor = false;
+		boolean _containsMaxLength = false;
+		boolean _containsText = false;
+		boolean _containsLayout = false;
 
-        @param aString the name of the variable.
-        */
-    public void setVariableName(String aString)
-    {
-        variableName = aString;
-    }
+		super.decode(coder);
 
-    /** Sets the value that will initially be displayed in the text field.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @param aString the initial text displayed.
-        */
-    public void setInitialText(String aString)
-    {
-        initialText = aString;
-    }
+		bounds = new FSBounds(coder);
 
-    /** Sets the attributes for the object. The Hashtable contains a list of key-value pairs. The key is one of the pre-defined attribute names while the value is an instance of a wrapper class (Boolean, Integer or String) that will be assigned to the specified attribute.
+		_containsText = coder.readBits(1, false) != 0 ? true : false;
+		wordWrapped = coder.readBits(1, false) != 0 ? true : false;
+		multiline = coder.readBits(1, false) != 0 ? true : false;
+		password = coder.readBits(1, false) != 0 ? true : false;
+		readOnly = coder.readBits(1, false) != 0 ? true : false;
+		_containsColor = coder.readBits(1, false) != 0 ? true : false;
+		_containsMaxLength = coder.readBits(1, false) != 0 ? true : false;
+		_containsFont = coder.readBits(1, false) != 0 ? true : false;
+		reserved1 = coder.readBits(1, false);
+		autoSize = coder.readBits(1, false) != 0 ? true : false;
+		_containsLayout = coder.readBits(1, false) != 0 ? true : false;
+		selectable = coder.readBits(1, false) != 0 ? true : false;
+		bordered = coder.readBits(1, false) != 0 ? true : false;
+		reserved2 = coder.readBits(1, false) != 0 ? true : false;
+		html = coder.readBits(1, false) != 0 ? true : false;
+		useFontGlyphs = coder.readBits(1, false) != 0 ? true : false;
 
-        @param attributes the list of attributes for the object.
-        */
-    public void setAttributes(Hashtable attributes)
-    {
-        if (attributes.get(WordWrapped) != null)
-            setWordWrapped(((Boolean)attributes.get(WordWrapped)).booleanValue());
-        if (attributes.get(Multiline) != null)
-            setMultiline(((Boolean)attributes.get(Multiline)).booleanValue());
-        if (attributes.get(Password) != null)
-            setPassword(((Boolean)attributes.get(Password)).booleanValue());
-        if (attributes.get(ReadOnly) != null)
-            setReadOnly(((Boolean)attributes.get(ReadOnly)).booleanValue());
-        if (attributes.get(Selectable) != null)
-            setSelectable(((Boolean)attributes.get(Selectable)).booleanValue());
-        if (attributes.get(Bordered) != null)
-            setBordered(((Boolean)attributes.get(Bordered)).booleanValue());
-        if (attributes.get(HTML) != null)
-            setHTML(((Boolean)attributes.get(HTML)).booleanValue());
-// Flash 6
-        if (attributes.get(AutoSize) != null)
-            setAutoSize(((Boolean)attributes.get(AutoSize)).booleanValue());
-// End Flash 6
-        if (attributes.get(UseFontGlyphs) != null)
-            setUseFontGlyphs(((Boolean)attributes.get(UseFontGlyphs)).booleanValue());
-        if (attributes.get(FontIdentifier) != null)
-            setFontIdentifier(((Integer)attributes.get(FontIdentifier)).intValue());
-        if (attributes.get(FontHeight) != null)
-            setFontHeight(((Integer)attributes.get(FontHeight)).intValue());
-        if (attributes.get(Color) != null)
-            setColor((FSColor)attributes.get(Color));
-        if (attributes.get(MaxLength) != null)
-            setMaxLength(((Integer)attributes.get(MaxLength)).intValue());
-        if (attributes.get(LeftMargin) != null)
-            setLeftMargin(((Integer)attributes.get(LeftMargin)).intValue());
-        if (attributes.get(RightMargin) != null)
-            setRightMargin(((Integer)attributes.get(RightMargin)).intValue());
-        if (attributes.get(Indent) != null)
-            setIndent(((Integer)attributes.get(Indent)).intValue());
-        if (attributes.get(Leading) != null)
-            setLeading(((Integer)attributes.get(Leading)).intValue());
-        if (attributes.get(VariableName) != null)
-            setVariableName((String)attributes.get(VariableName));
-        if (attributes.get(InitialText) != null)
-            setInitialText((String)attributes.get(InitialText));
-    }
+		if (_containsFont)
+		{
+			fontIdentifier = coder.readWord(2, false);
+			fontHeight = coder.readWord(2, false);
+		}
 
-    public Object clone()
-    {
-        FSDefineTextField anObject = (FSDefineTextField)super.clone();
-        
-        anObject.bounds = (bounds != null) ? (FSBounds)bounds.clone() : null;
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
+		if (_containsColor)
+			color = new FSColor(coder);
 
-        return anObject;
-    }
+		if (_containsMaxLength)
+			maxLength = coder.readWord(2, false);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineTextField typedObject = (FSDefineTextField)anObject;
-            
-            if (bounds != null)
-                result = bounds.equals(typedObject.bounds);
-            else
-                result = bounds == typedObject.bounds;
+		if (_containsLayout)
+		{
+			alignment = coder.readWord(1, false);
+			leftMargin = coder.readWord(2, false);
+			rightMargin = coder.readWord(2, false);
+			indent = coder.readWord(2, false);
+			leading = coder.readWord(2, true);
+		}
 
-            result = result &amp;&amp; wordWrapped == typedObject.wordWrapped;
-            result = result &amp;&amp; multiline == typedObject.multiline;
-            result = result &amp;&amp; password == typedObject.password;
-            result = result &amp;&amp; readOnly == typedObject.readOnly;
-            result = result &amp;&amp; reserved1 == typedObject.reserved1;
-// Flash 6
-            result = result &amp;&amp; autoSize == typedObject.autoSize;
-// End Flash 6
-            result = result &amp;&amp; selectable == typedObject.selectable;
-            result = result &amp;&amp; bordered == typedObject.bordered;
-            result = result &amp;&amp; reserved2 == typedObject.reserved2;
-            result = result &amp;&amp; html == typedObject.html;
-            result = result &amp;&amp; useFontGlyphs == typedObject.useFontGlyphs;
-            result = result &amp;&amp; fontIdentifier == typedObject.fontIdentifier;
-            result = result &amp;&amp; fontHeight == typedObject.fontHeight;
+		variableName = coder.readString();
 
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
+		if (_containsText)
+			initialText = coder.readString();
 
-            result = result &amp;&amp; maxLength == typedObject.maxLength;
-            
-            if (containsLayoutInfo())
-            {
-                result = result &amp;&amp; alignment == typedObject.alignment;
-                result = result &amp;&amp; leftMargin == typedObject.leftMargin;
-                result = result &amp;&amp; rightMargin == typedObject.rightMargin;
-                result = result &amp;&amp; indent == typedObject.indent;
-                result = result &amp;&amp; leading == typedObject.leading;
-            }
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.endObject(name());
+	}
 
-            if (variableName != null)
-                result = result &amp;&amp; variableName.equals(typedObject.variableName);
-            else
-                result = result &amp;&amp; variableName == typedObject.variableName;
-                
-            if (initialText != null)
-                result = result &amp;&amp; initialText.equals(typedObject.initialText);
-            else
-                result = result &amp;&amp; initialText == typedObject.initialText;
-       }
-        return result;
-    }
+	private boolean containsColor()
+	{
+		return color != null;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;bounds&quot;, bounds, depth);
-            Transform.append(buffer, &quot;wordWrapped&quot;, wordWrapped);
-            Transform.append(buffer, &quot;multiline&quot;, multiline);
-            Transform.append(buffer, &quot;password&quot;, password);
-            Transform.append(buffer, &quot;readOnly&quot;, readOnly);
-// Flash 6
-            Transform.append(buffer, &quot;autoSize&quot;, autoSize);
-// End Flash 6
-            Transform.append(buffer, &quot;selectable&quot;, selectable);
-            Transform.append(buffer, &quot;bordered&quot;, bordered);
-            Transform.append(buffer, &quot;HTML&quot;, html);
-            Transform.append(buffer, &quot;useFontGlyphs&quot;, useFontGlyphs);
-            Transform.append(buffer, &quot;fontIdentifier&quot;, fontIdentifier);
-            Transform.append(buffer, &quot;fontHeight&quot;, fontHeight);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            Transform.append(buffer, &quot;maxLength&quot;, maxLength);
-            Transform.append(buffer, &quot;alignment&quot;, alignment);
-            Transform.append(buffer, &quot;leftMargin&quot;, leftMargin);
-            Transform.append(buffer, &quot;rightMargin&quot;, rightMargin);
-            Transform.append(buffer, &quot;indent&quot;, indent);
-            Transform.append(buffer, &quot;leading&quot;, leading);
-            Transform.append(buffer, &quot;variableName&quot;, variableName);
-            Transform.append(buffer, &quot;initalText&quot;, initialText);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	private boolean containsFont()
+	{
+		return fontIdentifier != 0 &amp;&amp; fontHeight != 0;
+	}
 
-    public int length(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsMaxLength = containsMaxLength();
-        boolean _containsText = containsText();
-        
-        super.length(coder);
-    
-        coder.context[FSCoder.TransparentColors] = 1;
+	private boolean containsMaxLength()
+	{
+		return maxLength &gt; 0;
+	}
 
-        length += bounds.length(coder);
-        length += 2;
-        length += (_containsFont) ? 4 : 0;
-        length += (_containsColor) ? color.length(coder) : 0;
-        length += (_containsMaxLength) ? 2 : 0;
-        length += (containsLayoutInfo()) ? 9 : 0;
-        length += coder.strlen(variableName, true);
-        length += (_containsText) ? coder.strlen(initialText, true) : 0;
-        
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsMaxLength = containsMaxLength();
-        boolean _containsText = containsText();
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+	private boolean containsLayoutInfo()
+	{
+		boolean layout = false;
 
-        bounds.encode(coder);
-        coder.writeBits(_containsText ? 1 : 0, 1);
-        coder.writeBits(wordWrapped ? 1 : 0, 1);
-        coder.writeBits(multiline ? 1 : 0, 1);
-        coder.writeBits(password ? 1 : 0, 1);
-        coder.writeBits(readOnly ? 1 : 0, 1);
-        coder.writeBits(_containsColor ? 1 : 0, 1);
-        coder.writeBits(_containsMaxLength ? 1 : 0, 1);
-        coder.writeBits(_containsFont ? 1 : 0, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(autoSize ? 1 : 0, 1);
-        coder.writeBits(containsLayoutInfo() ? 1 : 0, 1);
-        coder.writeBits(selectable ? 1 : 0, 1);
-        coder.writeBits(bordered ? 1 : 0, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(html ? 1 : 0, 1);
-        coder.writeBits(useFontGlyphs ? 1 : 0, 1);
-    
-        if (_containsFont)
-        {
-            coder.writeWord(fontIdentifier, 2);
-            coder.writeWord(fontHeight, 2);
-        }
-    
-        if (_containsColor)
-            color.encode(coder);
-    
-        if (_containsMaxLength)
-            coder.writeWord(maxLength, 2);
-    
-        if (containsLayoutInfo())
-        {
-            coder.writeWord((alignment != Transform.VALUE_NOT_SET) ? alignment : 0, 1);
-            coder.writeWord((leftMargin != Transform.VALUE_NOT_SET) ? leftMargin : 0, 2);
-            coder.writeWord((rightMargin != Transform.VALUE_NOT_SET) ? rightMargin : 0, 2);
-            coder.writeWord((indent != Transform.VALUE_NOT_SET) ? indent : 0, 2);
-            coder.writeWord((leading != Transform.VALUE_NOT_SET) ? leading : 0, 2);
-        }
-    
-        coder.writeString(variableName);
-        coder.writeWord(0, 1);
-    
-        if (_containsText)
-        {
-            coder.writeString(initialText);
-            coder.writeWord(0, 1);
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean _containsFont = false;
-        boolean _containsColor = false;
-        boolean _containsMaxLength = false;
-        boolean _containsText = false;
-        boolean _containsLayout = false;
+		layout = alignment != Transform.VALUE_NOT_SET;
+		layout = layout || leftMargin != Transform.VALUE_NOT_SET;
+		layout = layout || rightMargin != Transform.VALUE_NOT_SET;
+		layout = layout || indent != Transform.VALUE_NOT_SET;
+		layout = layout || leading != Transform.VALUE_NOT_SET;
 
-        super.decode(coder);
+		return layout;
+	}
 
-        coder.context[FSCoder.TransparentColors] = 1;
-
-        bounds = new FSBounds(coder);
-
-        _containsText = coder.readBits(1, false) != 0 ? true : false;
-        wordWrapped = coder.readBits(1, false) != 0 ? true : false;
-        multiline = coder.readBits(1, false) != 0 ? true : false;
-        password = coder.readBits(1, false) != 0 ? true : false;
-        readOnly = coder.readBits(1, false) != 0 ? true : false;
-        _containsColor = coder.readBits(1, false) != 0 ? true : false;
-        _containsMaxLength = coder.readBits(1, false) != 0 ? true : false;
-        _containsFont = coder.readBits(1, false) != 0 ? true : false;
-        reserved1 = coder.readBits(1, false);
-        autoSize = coder.readBits(1, false) != 0 ? true : false;
-        _containsLayout = coder.readBits(1, false) != 0 ? true : false;
-        selectable = coder.readBits(1, false) != 0 ? true : false;
-        bordered = coder.readBits(1, false) != 0 ? true : false;
-        reserved2 = coder.readBits(1, false) != 0 ? true : false;
-        html = coder.readBits(1, false) != 0 ? true : false;
-        useFontGlyphs = coder.readBits(1, false) != 0 ? true : false;
-        
-        if (_containsFont)
-        {
-             fontIdentifier = coder.readWord(2, false);
-             fontHeight = coder.readWord(2, false);
-        }
-
-        if (_containsColor)
-            color = new FSColor(coder);
-
-        if (_containsMaxLength)
-            maxLength = coder.readWord(2, false);
-
-        if (_containsLayout)
-        {
-            alignment = coder.readWord(1, false);
-            leftMargin = coder.readWord(2, false);
-            rightMargin = coder.readWord(2, false);
-            indent = coder.readWord(2, false);
-            leading = coder.readWord(2, true);
-        }
-
-        variableName = coder.readString();
-
-        if (_containsText)
-            initialText = coder.readString();
-
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    private boolean containsColor()
-    {
-        return color != null;
-    }
-    
-    private boolean containsFont()
-    {
-        return fontIdentifier != 0 &amp;&amp; fontHeight != 0;
-    }
-    
-    private boolean containsMaxLength()
-    {
-        return maxLength &gt; 0;
-    }
-    
-    private boolean containsLayoutInfo()
-    {
-        boolean layout = false;
-        
-        layout = alignment != Transform.VALUE_NOT_SET;
-        layout = layout || leftMargin != Transform.VALUE_NOT_SET;
-        layout = layout || rightMargin != Transform.VALUE_NOT_SET;
-        layout = layout || indent != Transform.VALUE_NOT_SET;
-        layout = layout || leading != Transform.VALUE_NOT_SET;
-        
-        return layout;
-    }
-
-    private boolean containsText()
-    {
-        return initialText != null &amp;&amp; initialText.length() &gt; 0;
-    }    
+	private boolean containsText()
+	{
+		return initialText != null &amp;&amp; initialText.length() &gt; 0;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSDefineVideo.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDefineVideo.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDefineVideo.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,355 +34,401 @@
 import java.util.Iterator;
 
 /**
-The FSDefineVideo class is used to display video within a Flash file. 
- 
-&lt;p&gt;Video objects contain a unique identifier and are treated in the same way as shapes, buttons, images, etc. The video data displayed is define using the FSVideoFrame class. Each frame of video is displayed whenever display list is updated using the FSShowFrame object - any timing information stored within the video data is ignored.&lt;/p&gt;
+ * The FSDefineVideo class is used to display video within a Flash file.
+ * 
+ * &lt;p&gt;
+ * Video objects contain a unique identifier and are treated in the same way as
+ * shapes, buttons, images, etc. The video data displayed is define using the
+ * FSVideoFrame class. Each frame of video is displayed whenever display list is
+ * updated using the FSShowFrame object - any timing information stored within
+ * the video data is ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * An FSDefineVideo is defined with the following information:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference
+ * the video from other objects, e.g. when adding or removing from the display
+ * list.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameCount&lt;/td&gt;
+ * &lt;td&gt;The number of frames that will be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;width&lt;/td&gt;
+ * &lt;td&gt;Width of each frame in pixels&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;height&lt;/td&gt;
+ * &lt;td&gt;Height of each frame in pixels.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;deblocking&lt;/td&gt;
+ * &lt;td&gt;Whether a filter is used when assembling the blocks of video data into a
+ * frame. This may be set to Off to turn off the deblock filter in the Flash
+ * Player; On to turn on the Flash Player's filter or UseVideo to allow the
+ * video data to specify whether the deblocking filter is used.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;smoothing&lt;/td&gt;
+ * &lt;td&gt;Controls whether the Flash Player performs smoothing to increase the
+ * quality of the image displayed albeit at the price of performance.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr &gt;
+ * &lt;td&gt;codec&lt;/td&gt;
+ * &lt;td&gt;Identifies the format of the video data either FSDefineVideo.H263 for
+ * data encoded using the Sorenson modified H263 format or
+ * FSDefineVideo.ScreenVideo for data encoded using Macromedia's Screen Video
+ * format.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The ScreenVideo format was introduced in Flash 7, only the H263 format was
+ * supported in Flash 6.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineVideo class represents the DefineVideo of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 6. The
+ * ScreenVideo format was introduced in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSDefineVideo extends FSDefineObject
+{
+	/** The video data was encoded using the Sorenson modified H263 format. */
+	public static final int H263 = 2;
 
-&lt;p&gt;An FSDefineVideo is defined with the following information:&lt;/p&gt;
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** The video data was encoded using Macromedia's ScreenVideo format. */
+	public static final int ScreenVideo = 3;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Instruct the Flash Player to use the deblocking value specified in the
+	 * video data.
+	 */
+	public static final int UseVideo = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Instruct the Flash Player to turn the deblocking filter off. */
+	public static final int Off = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A unique identifier, in the range 1..65535, that is used to reference the video 
-from other objects, e.g. when adding or removing from the display list.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Instruct the Flash Player to turn the deblocking filter on. */
+	public static final int On = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_2&quot;&gt;frameCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of frames that will be displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	private int frameCount = 0;
+	private int width = 0;
+	private int height = 0;
+	private int deblocking = 0;
+	private boolean smoothing = false;
+	private int codec = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_3&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Width of each frame in pixels&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSDefineVideo object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDefineVideo(FSCoder coder)
+	{
+		super(DefineVideo, 0);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_4&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Height of each frame in pixels.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineVideo object with the specified parameters.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for this object
+	 * @param count
+	 *            the number of video frames.
+	 * @param width
+	 *            the width of each frame in pixels.
+	 * @param height
+	 *            the height of each frame in pixels.
+	 * @param deblocking
+	 *            controls whether the Flash Player's deblocking filter is used,
+	 *            either Off, On or UseVideo to allow the video data to specify
+	 *            whether the deblocking filter is used.
+	 * @param smoothing
+	 *            turns smoothing on or off to improve the quality of the
+	 *            displayed image.
+	 * @param codec
+	 *            the format of the video data. Flash 6 supports
+	 *            FSDefineVideo.H263. Support for Macromedia's ScreenVideo
+	 *            format was added in Flash 7.
+	 */
+	public FSDefineVideo(int anIdentifier, int count, int width, int height,
+							int deblocking, boolean smoothing, int codec)
+	{
+		super(DefineVideo, anIdentifier);
+		setFrameCount(count);
+		setWidth(width);
+		setHeight(height);
+		setDeblocking(deblocking);
+		setSmoothing(smoothing);
+		setCodec(codec);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_5&quot;&gt;deblocking&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Whether a filter is used when assembling the blocks of video data into a frame. 
-This may be set to Off to turn off the deblock filter in the Flash Player; On to 
-turn on the Flash Player's filter or UseVideo to allow the video data to specify 
-whether the deblocking filter is used.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDefineVideo object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDefineVideo object.
+	 */
+	public FSDefineVideo(FSDefineVideo obj)
+	{
+		super(obj);
+		frameCount = obj.frameCount;
+		width = obj.width;
+		height = obj.height;
+		deblocking = obj.deblocking;
+		smoothing = obj.smoothing;
+		codec = obj.codec;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_6&quot;&gt;smoothing&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Controls whether the Flash Player performs smoothing to increase the quality 
-of the image displayed albeit at the price of performance.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the number of frames in the video.
+	 * 
+	 * @return the number of video frames.
+	 */
+	public int getFrameCount()
+	{
+		return frameCount;
+	}
 
-&lt;tr
-&gt;&lt;td&gt;&lt;a name=&quot;FSDefineVideo_7&quot;&gt;codec&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the format of the video data either FSDefineVideo.H263 for data encoded 
-using the Sorenson modified H263 format or FSDefineVideo.ScreenVideo for data 
-encoded using Macromedia's Screen Video format.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Sets the number of frames in the video.
+	 * 
+	 * @param count
+	 *            the number of video frames.
+	 */
+	public void setFrameCount(int count)
+	{
+		frameCount = count;
+	}
 
-&lt;p&gt;The ScreenVideo format was introduced in Flash 7, only the H263 format was supported in Flash 6.&lt;/p&gt;
+	/**
+	 * Gets the width of each frame in pixels.
+	 * 
+	 * @return the width of the frame.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the width of each frame in pixels.
+	 * 
+	 * @param width
+	 *            the width of the frame.
+	 */
+	public void setWidth(int width)
+	{
+		this.width = width;
+	}
 
-&lt;p&gt;The FSDefineVideo class represents the DefineVideo of the Macromedia Flash (SWF) 
-File Format Specification. It was introduced in Flash 6. The ScreenVideo format 
-was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSDefineVideo extends FSDefineObject
-{
-    /// The video data was encoded using the Sorenson modified H263 format.
-    public static final int H263 = 2;
-    
-// Flash 7
-    /// The video data was encoded using Macromedia's ScreenVideo format.
-    public static final int ScreenVideo = 3;
-// End Flash 7
-    
-/** Instruct the Flash Player to use the deblocking value specified in the video data. */
-    public static final int UseVideo = 0;
-/** Instruct the Flash Player to turn the deblocking filter off. */
-    public static final int Off = 1;
-/** Instruct the Flash Player to turn the deblocking filter on. */
-    public static final int On  = 2;
-    
-    private int frameCount = 0;
-    private int width = 0;
-    private int height = 0;
-    private int deblocking = 0;
-    private boolean smoothing = false;
-    private int codec = 0;
+	/**
+	 * Gets the height of each frame in pixels.
+	 * 
+	 * @return the height of the frame.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-    /**
-     * Construct an FSDefineVideo object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDefineVideo(FSCoder coder)
-    {
-        super(DefineVideo, 0);
-        decode(coder);
-    }
-    /**
-     * Constructs an FSDefineVideo object with the specified parameters.
-     *
-     * @param anIdentifier the unique identifier for this object
-     * @param count the number of video frames.
-     * @param width the width of each frame in pixels.
-     * @param height the height of each frame in pixels.
-     * @param deblocking controls whether the Flash Player's deblocking filter is used, either Off, On or UseVideo to allow the video data to specify whether the deblocking filter is used. 
-     * @param smoothing turns smoothing on or off to improve the quality of the displayed image.
-     * @param codec the format of the video data. Flash 6 supports FSDefineVideo.H263. Support for Macromedia's 
-     * ScreenVideo format was added in Flash 7.
-     */
-    public FSDefineVideo(int anIdentifier, int count, int width, int height, int deblocking, boolean smoothing, int codec)
-    {
-        super(DefineVideo, anIdentifier);
-        setFrameCount(count);
-        setWidth(width);
-        setHeight(height);
-        setDeblocking(deblocking);
-        setSmoothing(smoothing);
-        setCodec(codec);
-    }
-    /**
-     * Constructs an FSDefineVideo object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDefineVideo object.
-     */
-    public FSDefineVideo(FSDefineVideo obj)
-    {
-        super(obj);
-        frameCount = obj.frameCount;
-        width = obj.width;
-        height = obj.height;
-        deblocking = obj.deblocking;
-        smoothing = obj.smoothing;
-        codec = obj.codec;
-    }    
+	/**
+	 * Sets the height of each frame in pixels.
+	 * 
+	 * @param height
+	 *            the height of the frame.
+	 */
+	public void setHeight(int height)
+	{
+		this.height = height;
+	}
 
-    /**
-     * Gets the number of frames in the video.
-     * 
-     * @return the number of video frames.
-     */ 
-    public int getFrameCount()
-    {
-        return frameCount;
-    }
+	/**
+	 * Gets the method used to control the Flash Player's deblocking filter.
+	 * 
+	 * @return the deblocking filter control, either FSDefineVideo.Off,
+	 *         FSDefineVideo.On or FSDefineVideo.UseVideo to allow the video
+	 *         data to specify whether the deblocking filter is used.
+	 */
+	public int getDeblocking()
+	{
+		return deblocking;
+	}
 
-    /**
-     * Sets the number of frames in the video.
-     * 
-     * @param count the number of video frames.
-     */ 
-    public void setFrameCount(int count)
-    {
-        frameCount = count;
-    }
-    
-    /**
-     * Gets the width of each frame in pixels.
-     * 
-     * @return the width of the frame.
-     */ 
-    public int getWidth() 
-    {
-        return width;
-    }
+	/**
+	 * Sets the method used to control the Flash Player's deblocking filter.
+	 * 
+	 * @param deblocking
+	 *            the deblocking filter control, either FSDefineVideo.Off,
+	 *            FSDefineVideo.On or FSDefineVideo.UseVideo to allow the video
+	 *            data to specify whether the deblocking filter is used.
+	 */
+	public void setDeblocking(int deblocking)
+	{
+		this.deblocking = deblocking;
+	}
 
-    /**
-     * Sets the width of each frame in pixels.
-     * 
-     * @param width the width of the frame.
-     */ 
-    public void setWidth(int width)
-    {
-        this.width = width;
-    }
-    
-    /**
-     * Gets the height of each frame in pixels.
-     * 
-     * @return the height of the frame.
-     */ 
-    public int getHeight() 
-    {
-        return height;
-    }
+	/**
+	 * Gets the method used to control Flash Player's smoothing filter.
+	 * 
+	 * @return true if smoothing is turned on, false if it is turned off.
+	 */
+	public boolean getSmoothing()
+	{
+		return smoothing;
+	}
 
-    /**
-     * Sets the height of each frame in pixels.
-     * 
-     * @param height the height of the frame.
-     */ 
-    public void setHeight(int height)
-    {
-        this.height = height;
-    }
-    
-    /**
-     * Gets the method used to control the Flash Player's deblocking filter.
-     * 
-     * @return the deblocking filter control, either FSDefineVideo.Off, FSDefineVideo.On or
-     * FSDefineVideo.UseVideo to allow the video data to specify whether the deblocking 
-     * filter is used.
-     */ 
-    public int getDeblocking() 
-    {
-        return deblocking;
-    }
+	/**
+	 * Sets the method used to control Flash Player's smoothing filter.
+	 * 
+	 * @param smoothing
+	 *            true if smoothing is turned on, false if it is turned off.
+	 */
+	public void setSmoothing(boolean smoothing)
+	{
+		this.smoothing = smoothing;
+	}
 
-    /**
-     * Sets the method used to control the Flash Player's deblocking filter.
-     * 
-     * @param deblocking the deblocking filter control, either FSDefineVideo.Off, FSDefineVideo.On
-     * or FSDefineVideo.UseVideo to allow the video data to specify whether the deblocking filter 
-     * is used.
-     */ 
-    public void setDeblocking(int deblocking)
-    {
-        this.deblocking = deblocking;
-    }
+	/**
+	 * Get the format used to encode the video data, either FSDefineVideo.H263
+	 * for data encoded using the Sorenson modified H263 format or
+	 * FSDefineVideo.ScreenVideo (Flash 7 only) for data encoded using
+	 * Macromedia's Screen Video format.
+	 * 
+	 * @return the codec used to encode the video, either FSDefineVideo.H263 or
+	 *         FSDefineVideo.ScreenVideo.
+	 */
+	public int getCodec()
+	{
+		return codec;
+	}
 
-    /**
-     * Gets the method used to control Flash Player's smoothing filter.
-     * 
-     * @return true if smoothing is turned on, false if it is turned off.
-     */
-    public boolean getSmoothing() 
-    {
-        return smoothing;
-    }
+	/**
+	 * Set the format used to encode the video data, either FSDefineVideo.H263
+	 * for data encoded using the Sorenson modified H263 format or
+	 * FSDefineVideo.ScreenVideo (Flash 7 only) for data encoded using
+	 * Macromedia's Screen Video format.
+	 * 
+	 * @param codec
+	 *            the format used encode the video, either FSDefineVideo.H263 or
+	 *            FSDefineVideo.ScreenVideo.
+	 */
+	public void setCodec(int codec)
+	{
+		this.codec = codec;
+	}
 
-    /**
-     * Sets the method used to control Flash Player's smoothing filter.
-     * 
-     * @param smoothing true if smoothing is turned on, false if it is turned off.
-     */
-    public void setSmoothing(boolean smoothing)
-    {
-        this.smoothing = smoothing;
-    }
+	public Object clone()
+	{
+		FSDefineVideo anObject = (FSDefineVideo) super.clone();
 
-    /**
-     * Get the format used to encode the video data, either FSDefineVideo.H263 for data 
-     * encoded using the Sorenson modified H263 format or FSDefineVideo.ScreenVideo (Flash 7 only) 
-     * for data encoded using Macromedia's Screen Video format.
-     *
-     * @return the codec used to encode the video, either FSDefineVideo.H263 or FSDefineVideo.ScreenVideo.
-     */
-    public int getCodec() 
-    {
-        return codec;
-    }
+		return anObject;
+	}
 
-    /**
-     * Set the format used to encode the video data, either FSDefineVideo.H263 for data encoded 
-     * using the Sorenson modified H263 format or FSDefineVideo.ScreenVideo (Flash 7 only) for 
-     * data encoded using Macromedia's Screen Video format.
-     *
-     * @param codec the format used encode the video, either FSDefineVideo.H263 or FSDefineVideo.ScreenVideo.
-     */
-    public void setCodec(int codec)
-    {
-        this.codec = codec;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public Object clone()
-    {
-        FSDefineVideo anObject = (FSDefineVideo)super.clone();
-        
-        return anObject;
-    }
+		if (super.equals(anObject))
+		{
+			FSDefineVideo typedObject = (FSDefineVideo) anObject;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDefineVideo typedObject = (FSDefineVideo)anObject;
-            
-            result = frameCount == typedObject.frameCount;
-            result = result &amp;&amp; width == typedObject.width;
-            result = result &amp;&amp; height == typedObject.height;
-            result = result &amp;&amp; deblocking == typedObject.deblocking;
-            result = result &amp;&amp; smoothing == typedObject.smoothing;
-            result = result &amp;&amp; codec == typedObject.codec;
-        }
-        return result;
-    }
+			result = frameCount == typedObject.frameCount;
+			result = result &amp;&amp; width == typedObject.width;
+			result = result &amp;&amp; height == typedObject.height;
+			result = result &amp;&amp; deblocking == typedObject.deblocking;
+			result = result &amp;&amp; smoothing == typedObject.smoothing;
+			result = result &amp;&amp; codec == typedObject.codec;
+		}
+		return result;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;frameCount&quot;, frameCount);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;deblocking&quot;, deblocking);
-            Transform.append(buffer, &quot;smoothing&quot;, smoothing);
-            Transform.append(buffer, &quot;codec&quot;, codec);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;frameCount&quot;, frameCount);
+			Transform.append(buffer, &quot;width&quot;, width);
+			Transform.append(buffer, &quot;height&quot;, height);
+			Transform.append(buffer, &quot;deblocking&quot;, deblocking);
+			Transform.append(buffer, &quot;smoothing&quot;, smoothing);
+			Transform.append(buffer, &quot;codec&quot;, codec);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 8;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(frameCount, 2);
-        coder.writeWord(width, 2);
-        coder.writeWord(height, 2);
-        coder.writeBits(0, 5);
-        coder.writeBits(deblocking, 2);
-        coder.writeBits(smoothing ? 1 : 0, 1);
-        coder.writeWord(codec, 1);
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        frameCount = coder.readWord(2, false);
-        width = coder.readWord(2, false);
-        height = coder.readWord(2, false);
+		length += 8;
 
-        coder.readBits(5, false);
-        deblocking = coder.readBits(2, false);
-        smoothing = coder.readBits(1, false) == 1 ? true : false;
-        
-        codec = coder.readWord(1, false);
+		return length;
+	}
 
-        coder.endObject(name());
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(frameCount, 2);
+		coder.writeWord(width, 2);
+		coder.writeWord(height, 2);
+		coder.writeBits(0, 5);
+		coder.writeBits(deblocking, 2);
+		coder.writeBits(smoothing ? 1 : 0, 1);
+		coder.writeWord(codec, 1);
+
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		frameCount = coder.readWord(2, false);
+		width = coder.readWord(2, false);
+		height = coder.readWord(2, false);
+
+		coder.readBits(5, false);
+		deblocking = coder.readBits(2, false);
+		smoothing = coder.readBits(1, false) == 1 ? true : false;
+
+		codec = coder.readWord(1, false);
+
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSDoAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSDoAction.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSDoAction.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,344 +33,375 @@
 import java.util.*;
 
 /**
-FSDoAction is used to specify a sequence of actions that are executed when a 
-frame is displayed.
+ * FSDoAction is used to specify a sequence of actions that are executed when a
+ * frame is displayed.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of FSActionObjects which are executed by the Flash Player when
+ * the current frame is displayed. The actions are executed in the order they
+ * appear in the array.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedActions&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded actions can also be set. The
+ * encoded actions are typically generated by the parser in the Translate
+ * framework. The actions array and encodedActions cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To define the actions for a given frame the FSDoAction object should be added
+ * to a movie after the previous frame is displayed but before the FSShowFrame
+ * object that displays the 'current' frame and triggers the actions to be
+ * executed.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Only one FSDoAction object can be used to specify the actions for a given
+ * frame. If more than one FSDoAction object is added in a single frame only the
+ * actions contained in the last FSDoAction object (before the FSShowFrame
+ * object) will be executed when the frame is displayed. The other FSDoAction
+ * objects will be ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;_root&quot;));
+ *  actions.add(new FSAction(FSAction.GetVariable));
+ *  ...
+ * 
+ *  movie.add(new FSShowFrame()); // previous frame
+ *  ...
+ * 
+ *  movie.add(new FSDoAction(actions));
+ *  movie.add(new FSShowFrame()); // frame where actions will be executed
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDoAction class represents the DoAction tag from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSDoAction extends FSMovieObject
+{
+	private ArrayList actions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private byte[] encodedActions = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSDoAction object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSDoAction(FSCoder coder)
+	{
+		super(FSMovieObject.DoAction);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDoAction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDoAction object with an array of actions.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public FSDoAction(ArrayList anArray)
+	{
+		super(FSMovieObject.DoAction);
+		setActions(anArray);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDoAction_1&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSActionObjects which are executed by the Flash Player when the 
-current frame is displayed. The actions are executed in the order they appear in 
-the array.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDoAction object with an array of encoded actions
+	 * generated by the classes in Translate.
+	 * 
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSDoAction(byte[] bytes)
+	{
+		super(FSMovieObject.DoAction);
+		setEncodedActions(bytes);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSDoAction_2&quot;&gt;encodedActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded actions can also be set. The encoded 
-actions are typically generated by the parser in the Translate framework. The 
-actions array and encodedActions cannot both be valid at the same time. Accessor 
-methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSDoAction object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSDoAction object.
+	 */
+	public FSDoAction(FSDoAction obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-&lt;p&gt;To define the actions for a given frame the FSDoAction object should be added 
-to a movie after the previous frame is displayed but before the FSShowFrame 
-object that displays the 'current' frame and triggers the actions to be executed.&lt;/p&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-&lt;p&gt;Only one FSDoAction object can be used to specify the actions for a given 
-frame. If more than one FSDoAction object is added in a single frame only the 
-actions contained in the last FSDoAction object (before the FSShowFrame object) 
-will be executed when the frame is displayed. The other FSDoAction objects will 
-be ignored.&lt;/p&gt;
+	/**
+	 * Adds the action object to the array of actions. If the object already
+	 * contains encoded actions then they will be deleted.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Get the array of actions that are executed when the frame is displayed.
+	 * 
+	 * @return the array of action objects.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-&lt;pre&gt;
-ArrayList actions = new ArrayList();
+	/**
+	 * Set the array of actions that will be executed when the next ShowFrame
+	 * tag is executed by the Flash Player. If the object already contains
+	 * encoded actions then they will be deleted.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(new FSAction(FSAction.GetVariable));
-...
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-movie.add(new FSShowFrame()); // previous frame
-...
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-movie.add(new FSDoAction(actions));
-movie.add(new FSShowFrame()); // frame where actions will be executed
-&lt;/pre&gt;
+	public Object clone()
+	{
+		FSDoAction anObject = (FSDoAction) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-&lt;p&gt;The FSDoAction class represents the DoAction tag from the Macromedia Flash 
-(SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSDoAction extends FSMovieObject
-{
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-    
-    /**
-     * Construct an FSDoAction object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSDoAction(FSCoder coder)
-    {
-        super(FSMovieObject.DoAction);
-        decode(coder);
-    }
-    /** Constructs an FSDoAction object with an array of actions.
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
+		return anObject;
+	}
 
-        @param anArray the array of action objects.
-        */
-    public FSDoAction(ArrayList anArray)
-    {
-        super(FSMovieObject.DoAction);
-        setActions(anArray);
-    }
-    /**
-     * Constructs an FSDoAction object with an array of encoded actions
-     * generated by the classes in Translate.
-     * 
-     * @param bytes an array of encoded action objects.
-     */
-    public FSDoAction(byte[] bytes)
-    {
-        super(FSMovieObject.DoAction);
-        setEncodedActions(bytes);
-    }
-    /**
-     * Constructs an FSDoAction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSDoAction object.
-     */
-    public FSDoAction(FSDoAction obj)
-    {
-        super(obj);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }    
+		if (super.equals(anObject))
+		{
+			FSDoAction typedObject = (FSDoAction) anObject;
 
-    /** 
-     * Adds the action object to the array of actions. If the object already
-     * contains encoded actions then they will be deleted.
-     * 
-     * @param anAction an object belonging to a class derived from FSActionObject.
-     */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+			if (actions != null)
+			{
+				result = actions.equals(typedObject.actions);
+			} else
+			{
+				result = Transform.equals(encodedActions,
+								typedObject.encodedActions);
+			}
+		}
+		return result;
+	}
 
-    /** Get the array of actions that are executed when the frame is displayed.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the array of action objects.
-        */
-    public ArrayList getActions() 
-    { 
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
-    /** 
-     * Set the array of actions that will be executed when the next ShowFrame 
-     * tag is executed by the Flash Player.  If the object already contains 
-     * encoded actions then they will be deleted.
-     * 
-     * @param anArray the array of action objects.
-     */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-    }
+			if (actions != null)
+				Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			else
+				buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    public Object clone()
-    {
-        FSDoAction anObject = (FSDoAction)super.clone();
-        
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSDoAction typedObject = (FSDoAction)anObject;
-            
-            if (actions != null)
-            {
-                result = actions.equals(typedObject.actions);
-            }
-            else
-            {
-                result = Transform.equals(encodedActions, typedObject.encodedActions);
-            }
-        }
-        return result;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
+			int count = actions.size();
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
-                
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			for (int i = 0; i &lt; count; i++)
+			{
+				currentAction = (FSActionObject) actions.get(i);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	int count = actions.size();
-        	
-            for (int i=0; i&lt;count; i++)
-            {
-                currentAction = (FSActionObject)actions.get(i);
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if (count == 0 || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+			if (count == 0 || (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-            
-                action.encode(coder);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-                coder.setPointer(next);
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
-            
-            int len = length;
-            int start;
-            
-            while (len &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length];
-            coder.readBytes(encodedActions);
-        }
-        coder.endObject(name());
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		if (actions != null)
+		{
+			FSActionObject action = null;
+
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (action.getLength() &lt;&lt; 3);
+
+				action.encode(coder);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+				coder.setPointer(next);
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
+
+			int len = length;
+			int start;
+
+			while (len &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSMovie.decodeAction(coder));
+				len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[length];
+			coder.readBytes(encodedActions);
+		}
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSEnableDebugger.java
===================================================================
--- trunk/src/com/flagstone/transform/FSEnableDebugger.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSEnableDebugger.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,138 +34,160 @@
 import java.util.Iterator;
 
 /**
-Enables a movie to be debugged when played using the Flash authoring tool, allowing the 
-variables defined in the arrays of actions specified in object to be inspected.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * Enables a movie to be debugged when played using the Flash authoring tool,
+ * allowing the variables defined in the arrays of actions specified in object
+ * to be inspected.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;password&lt;/td&gt;
+ * &lt;td&gt;An MD5 encrypted password.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In order to use the debugger a password must be supplied. When encrypted
+ * using the MD5 algorithm it must match the value stored in the password
+ * attribute.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSEnableDebugger class represents the EnableDebugger data structure of
+ * the Macromedia Flash (SWF) File Format Specification. It was introduced in
+ * Flash 5.
+ * &lt;/p&gt;
+ */
+public class FSEnableDebugger extends FSMovieObject
+{
+	private String password = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSEnableDebugger object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSEnableDebugger(FSCoder coder)
+	{
+		super(EnableDebugger);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnableDebugger_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSEnableDebugger2 object with an MD5 encrypted password.
+	 * 
+	 * @param password
+	 *            the string defining the password.
+	 */
+	public FSEnableDebugger(String password)
+	{
+		super(EnableDebugger);
+		setPassword(password);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnableDebugger_1&quot;&gt;password&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An MD5 encrypted password.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSEnableDebugger object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSEnableDebugger object.
+	 */
+	public FSEnableDebugger(FSEnableDebugger obj)
+	{
+		super(obj);
+		password = new String(obj.password);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the MD5 encrypted password.
+	 * 
+	 * @return the string defining the password.
+	 */
+	public String getPassword()
+	{
+		return password;
+	}
 
-&lt;p&gt;In order to use the debugger a password must be supplied. When encrypted using the MD5 algorithm it must match the value stored in the password attribute.&lt;/p&gt;
+	/**
+	 * Sets the MD5 encrypted password.
+	 * 
+	 * @param aString
+	 *            the string defining the password.
+	 */
+	public void setPassword(String aString)
+	{
+		password = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSEnableDebugger class represents the EnableDebugger data structure of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSEnableDebugger extends FSMovieObject
-{
-    private String password = null;
-        
-    /**
-     * Construct an FSEnableDebugger object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSEnableDebugger(FSCoder coder)
-    {
-        super(EnableDebugger);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSEnableDebugger2 object with an MD5 encrypted password.
-     *
-     * @param password the string defining the password.
-     */
-    public FSEnableDebugger(String password)
-    {
-        super(EnableDebugger);
-        setPassword(password);
-    }
-    /**
-     * Constructs an FSEnableDebugger object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSEnableDebugger object.
-     */
-    public FSEnableDebugger(FSEnableDebugger obj)
-    {
-        super(obj);
-        password = new String(obj.password);
-    }    
+		if (super.equals(anObject))
+		{
+			FSEnableDebugger typedObject = (FSEnableDebugger) anObject;
 
-    /** Gets the MD5 encrypted password.
+			if (password != null)
+				result = password.equals(typedObject.password);
+			else
+				result = typedObject.password == null;
+		}
+		return result;
+	}
 
-        @return the string defining the password.
-        */
-    public String getPassword() { return password; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the MD5 encrypted password.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;password&quot;, password);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aString the string defining the password.
-        */
-    public void setPassword(String aString)
-    {
-        password = aString;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSEnableDebugger typedObject = (FSEnableDebugger)anObject;
-            
-            if (password != null)
-                result = password.equals(typedObject.password);
-            else
-                result = typedObject.password == null;
-        }
-        return result;
-    }
+		length += 2 + coder.strlen(password, true);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;password&quot;, password);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		return length;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        length += 2 + coder.strlen(password, true);
-            
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(0, 2);
-         coder.writeString(password);
-        coder.writeWord(0, 1);
-        
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+		coder.writeWord(0, 2);
+		coder.writeString(password);
+		coder.writeWord(0, 1);
 
-        coder.readWord(2, false);
-        password = coder.readString();
-        
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		coder.readWord(2, false);
+		password = coder.readString();
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSEnableDebugger2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSEnableDebugger2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSEnableDebugger2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,138 +31,161 @@
 package com.flagstone.transform;
 
 /**
-Enables a movie to be debugged when played using the Flash authoring tool, allowing the 
-variables defined in the arrays of actions specified in object to be inspected.
+ * Enables a movie to be debugged when played using the Flash authoring tool,
+ * allowing the variables defined in the arrays of actions specified in object
+ * to be inspected.
  * 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;password&lt;/td&gt;
+ * &lt;td&gt;An MD5 encrypted password.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In order to use the debugger a password must be supplied. When encrypted
+ * using the MD5 algorithm it must match the value stored in the password
+ * attribute.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSEnableDebugger2 class represents the EnableDebugger2 data structure
+ * introduced in Flash 6. It replaced EnableDebugger in Flash 5 with a different
+ * format to support internal changes in the Flash Player. The functionality was
+ * not changed.
+ * &lt;/p&gt;
+ */
+public class FSEnableDebugger2 extends FSMovieObject
+{
+	private String password = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSEnableDebugger2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSEnableDebugger2(FSCoder coder)
+	{
+		super(EnableDebugger2);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnableDebugger2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSEnableDebugger2 object with an MD5 encrypted password.
+	 * 
+	 * @param password
+	 *            the string defining the password.
+	 */
+	public FSEnableDebugger2(String password)
+	{
+		super(EnableDebugger2);
+		setPassword(password);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnableDebugger2_1&quot;&gt;password&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An MD5 encrypted password.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSEnableDebugger2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSEnableDebugger2 object.
+	 */
+	public FSEnableDebugger2(FSEnableDebugger2 obj)
+	{
+		super(obj);
+		password = new String(obj.password);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the MD5 encrypted password.
+	 * 
+	 * @return the string defining the password.
+	 */
+	public String getPassword()
+	{
+		return password;
+	}
 
-&lt;p&gt;In order to use the debugger a password must be supplied. When encrypted using the MD5 algorithm it must match the value stored in the password attribute.&lt;/p&gt;
+	/**
+	 * Sets the MD5 encrypted password.
+	 * 
+	 * @param aString
+	 *            the string defining the password.
+	 */
+	public void setPassword(String aString)
+	{
+		password = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSEnableDebugger2 class represents the EnableDebugger2 data structure introduced in Flash 6. It replaced EnableDebugger in Flash 5 with a different format to support internal changes in the Flash Player. The functionality was not changed.&lt;/p&gt;
- */  
-public class FSEnableDebugger2 extends FSMovieObject
-{
-    private String password = null;
-        
-    /**
-     * Construct an FSEnableDebugger2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSEnableDebugger2(FSCoder coder)
-    {
-        super(EnableDebugger2);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSEnableDebugger2 object with an MD5 encrypted password.
-     *
-     * @param password the string defining the password.
-     */
-    public FSEnableDebugger2(String password)
-    {
-        super(EnableDebugger2);
-        setPassword(password);
-    }
-    /**
-     * Constructs an FSEnableDebugger2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSEnableDebugger2 object.
-     */
-    public FSEnableDebugger2(FSEnableDebugger2 obj)
-    {
-        super(obj);
-        password = new String(obj.password);
-    }    
+		if (super.equals(anObject))
+		{
+			FSEnableDebugger2 typedObject = (FSEnableDebugger2) anObject;
 
-    /** Gets the MD5 encrypted password.
+			if (password != null)
+				result = password.equals(typedObject.password);
+			else
+				result = typedObject.password == null;
+		}
+		return result;
+	}
 
-        @return the string defining the password.
-        */
-    public String getPassword() { return password; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the MD5 encrypted password.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;password&quot;, password);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aString the string defining the password.
-        */
-    public void setPassword(String aString)
-    {
-        password = aString;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSEnableDebugger2 typedObject = (FSEnableDebugger2)anObject;
-            
-            if (password != null)
-                result = password.equals(typedObject.password);
-            else
-                result = typedObject.password == null;
-        }
-        return result;
-    }
+		length += 2 + coder.strlen(password, true);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;password&quot;, password);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		return length;
+	}
 
-     public int length(FSCoder coder)
-    {
-        super.length(coder);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        length += 2 + coder.strlen(password, true);
-            
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(0, 2);
-        coder.writeString(password);
-        coder.writeWord(0, 1);
-        
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+		coder.writeWord(0, 2);
+		coder.writeString(password);
+		coder.writeWord(0, 1);
 
-        coder.readWord(2, false);
-        password = coder.readString();
-        
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		coder.readWord(2, false);
+		password = coder.readString();
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSEnvelope.java
===================================================================
--- trunk/src/com/flagstone/transform/FSEnvelope.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSEnvelope.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,178 +34,228 @@
 import java.util.Iterator;
 
 /**
-FSEnvelope is used to define an envelope which controls how a particular sound is 
-played over time. 
- 
-&lt;p&gt;Each FSEnvelope object defines a point in the envelope. The FSSound object contains an array of FSEnvelope objects which define the complete envelope.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnvelope_0&quot;&gt;mark&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The location in the playback sound data stream where the following level information applies.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnvelope_1&quot;&gt;left&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sound level for the left channel, in the range 0..65535.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSEnvelope_2&quot;&gt;right&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sound level for the right channel, in the range 0..65535..&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
-
-&lt;p&gt;The Flash Player plays sounds at a fixed rate of 44.1KHz, therefore sounds sampled at a lower frequency are interpolated with each sample repeated to generated the 44.1Khz playback rate. For example each sample in a sound sampled at 22KHz is played twice to generated the 44.1Khz playback rate.&lt;/p&gt;
-
-&lt;p&gt;The envelope defines the sample number (and hence the time) in the playback data stream where the level information applies and &lt;b&gt;not&lt;/b&gt; the sample number in the original sound data. For example to set the level 0.1 seconds into a sound that plays for 1 second the value for the mark attribute in the envelope object would be 44100 * 0.1/1.0 = 4410.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSEnvelope class represents the SoundEnvelope structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
+ * FSEnvelope is used to define an envelope which controls how a particular
+ * sound is played over time.
+ * 
+ * &lt;p&gt;
+ * Each FSEnvelope object defines a point in the envelope. The FSSound object
+ * contains an array of FSEnvelope objects which define the complete envelope.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;mark&lt;/td&gt;
+ * &lt;td&gt;The location in the playback sound data stream where the following level
+ * information applies.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;left&lt;/td&gt;
+ * &lt;td&gt;The sound level for the left channel, in the range 0..65535.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;right&lt;/td&gt;
+ * &lt;td&gt;The sound level for the right channel, in the range 0..65535..&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The Flash Player plays sounds at a fixed rate of 44.1KHz, therefore sounds
+ * sampled at a lower frequency are interpolated with each sample repeated to
+ * generated the 44.1Khz playback rate. For example each sample in a sound
+ * sampled at 22KHz is played twice to generated the 44.1Khz playback rate.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The envelope defines the sample number (and hence the time) in the playback
+ * data stream where the level information applies and &lt;b&gt;not&lt;/b&gt; the sample
+ * number in the original sound data. For example to set the level 0.1 seconds
+ * into a sound that plays for 1 second the value for the mark attribute in the
+ * envelope object would be 44100 * 0.1/1.0 = 4410.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSEnvelope class represents the SoundEnvelope structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
  */
 public class FSEnvelope extends FSTransformObject
 {
-    private int mark = 0;
-    private int left = 0;
-    private int right = 0;
+	private int mark = 0;
+	private int left = 0;
+	private int right = 0;
 
-    /**
-     * Construct an FSEnvelope object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSEnvelope(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an envelope specifying the mark, left and right values.
+	/**
+	 * Construct an FSEnvelope object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSEnvelope(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-        @param markValue the sample number in the 44.1KHz playback data stream where the levels for the channels is applied.
-        @param leftValue the level for the left sound channel, in the range 0..65535.
-        @param rightValue the level for the right sound channel, in the range 0..65535.
-        */
-    public FSEnvelope(int markValue, int leftValue, int rightValue)
-    {
-        setMark(markValue);
-        setLeft(leftValue);
-        setRight(rightValue);
-    }
-    /**
-     * Constructs an FSEnvelope object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSEnvelope object.
-     */
-    public FSEnvelope(FSEnvelope obj)
-    {
-        mark = obj.mark;
-        left = obj.left;
-        right = obj.right;
-    }    
+	/**
+	 * Constructs an envelope specifying the mark, left and right values.
+	 * 
+	 * @param markValue
+	 *            the sample number in the 44.1KHz playback data stream where
+	 *            the levels for the channels is applied.
+	 * @param leftValue
+	 *            the level for the left sound channel, in the range 0..65535.
+	 * @param rightValue
+	 *            the level for the right sound channel, in the range 0..65535.
+	 */
+	public FSEnvelope(int markValue, int leftValue, int rightValue)
+	{
+		setMark(markValue);
+		setLeft(leftValue);
+		setRight(rightValue);
+	}
 
-    /** Gets the sample number in the 44.1KHz playback data stream where the level information is applied.
+	/**
+	 * Constructs an FSEnvelope object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSEnvelope object.
+	 */
+	public FSEnvelope(FSEnvelope obj)
+	{
+		mark = obj.mark;
+		left = obj.left;
+		right = obj.right;
+	}
 
-        @return the mark value.
-        */
-    public int getMark()  { return mark; }
+	/**
+	 * Gets the sample number in the 44.1KHz playback data stream where the
+	 * level information is applied.
+	 * 
+	 * @return the mark value.
+	 */
+	public int getMark()
+	{
+		return mark;
+	}
 
-    /** Gets the level of the sound played in the left channel.
+	/**
+	 * Gets the level of the sound played in the left channel.
+	 * 
+	 * @return the left value.
+	 */
+	public int getLeft()
+	{
+		return left;
+	}
 
-        @return the left value.
-        */
-    public int getLeft()  { return left; }
+	/**
+	 * Gets the level of the sound played in the right channel.
+	 * 
+	 * @return the right value.
+	 */
+	public int getRight()
+	{
+		return right;
+	}
 
-    /** Gets the level of the sound played in the right channel.
+	/**
+	 * Sets the sample number in the 44.1KHz playback data stream where the
+	 * levels for the channels is applied.
+	 * 
+	 * @param aNumber
+	 *            the mark value.
+	 */
+	public void setMark(int aNumber)
+	{
+		mark = aNumber;
+	}
 
-        @return the right value.
-        */
-    public int getRight()  { return right; }
+	/**
+	 * Sets the level for the left sound channel.
+	 * 
+	 * @param leftValue
+	 *            the level for the left sound channel.
+	 */
+	public void setLeft(int leftValue)
+	{
+		left = leftValue;
+	}
 
-    /** Sets the sample number in the 44.1KHz playback data stream where the levels for the channels is applied.
+	/**
+	 * Sets the level for the right sound channel.
+	 * 
+	 * @param rightValue
+	 *            the level for the right sound channel.
+	 */
+	public void setRight(int rightValue)
+	{
+		right = rightValue;
+	}
 
-        @param aNumber the mark value.
-        */
-    public void setMark(int aNumber)
-    {
-        mark = aNumber;
-    }
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the level for the left sound channel.
+		if (super.equals(anObject))
+		{
+			FSEnvelope typedObject = (FSEnvelope) anObject;
 
-        @param leftValue the level for the left sound channel.
-        */
-    public void setLeft(int leftValue)
-    {
-        left = leftValue;
-    }
+			result = mark == typedObject.mark;
+			result = result &amp;&amp; left == typedObject.left;
+			result = result &amp;&amp; right == typedObject.right;
+		}
+		return result;
+	}
 
-    /** Sets the level for the right sound channel.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param rightValue the level for the right sound channel.
-        */
-    public void setRight(int rightValue)
-    {
-        right = rightValue;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(name() + &quot;: {&quot;);
+			Transform.append(buffer, &quot;mark&quot;, mark);
+			Transform.append(buffer, &quot;left&quot;, left);
+			Transform.append(buffer, &quot;right&quot;, right);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSEnvelope typedObject = (FSEnvelope)anObject;
-            
-            result = mark == typedObject.mark;
-            result = result &amp;&amp; left == typedObject.left;
-            result = result &amp;&amp; right == typedObject.right;
-        }
-        return result;
-    }
+	public int length(FSCoder coder)
+	{
+		int length = 8;
+		return length;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(mark, 4);
+		coder.writeWord(left, 2);
+		coder.writeWord(right, 2);
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(name() + &quot;: {&quot;);
-            Transform.append(buffer, &quot;mark&quot;, mark);
-            Transform.append(buffer, &quot;left&quot;, left);
-            Transform.append(buffer, &quot;right&quot;, right);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 8;
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(mark, 4);
-        coder.writeWord(left, 2);
-        coder.writeWord(right, 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        mark = coder.readWord(4, false);
-        left = coder.readWord(2, false);
-        right = coder.readWord(2, false);
-    }
+	public void decode(FSCoder coder)
+	{
+		mark = coder.readWord(4, false);
+		left = coder.readWord(2, false);
+		right = coder.readWord(2, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSExceptionHandler.java
===================================================================
--- trunk/src/com/flagstone/transform/FSExceptionHandler.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSExceptionHandler.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,614 +33,701 @@
 import java.util.*;
 
 /**
-The FSExceptionHandler class is used to specify try..catch blocks so exceptions can be thrown 
-and handled when executing a series of actions.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * The FSExceptionHandler class is used to specify try..catch blocks so
+ * exceptions can be thrown and handled when executing a series of actions.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;type&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;register&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The number of the register that the thrown object will be assigned to.
+ * Optional, Omitted if the variable attribute is set.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;variable&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The variable in memory that the thrown object will be assigned to.
+ * Optional, Omitted if the register attribute is set.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;tryActions&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The actions executed in the try block of the exception.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;catchActions &lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The actions executed in the catch block of the exception. Defining
+ * actions for the catch block is optional and may be set to the null object or
+ * an empty array if no actions will be executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;finalActions&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The actions executed in a finally block of the exception. Defining
+ * actions for the finally block is optional and may be set to the null object
+ * or an empty array if no actions will be executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The thrown object can be assigned to either one of the Flash Player's 256
+ * internal registers or to a variable in memory. If a register number is set
+ * the variable name is set to null. Similarly if a variable name is set then
+ * the register number is set to zero.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSExceptionHandler class contains three arrays of actions supporting the
+ * standard syntax for an exception with try, catch and finally blocks. An
+ * exception is thrown by a Throw action which pops a value off the stack and
+ * assigns it to either a named variable or one of the Flash Player's internal
+ * registered so it can be processed by the actions in the catch block.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Exceptions may be nest to any level if a thrown exception is not handled by
+ * the immediate catch block it is propagated to the next handler in the
+ * exception hierarchy and so on until it is caught.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Both the catch and finally blocks are optional when defining an exception,
+ * the corresponding arguments in constructors and accessor methods may be set
+ * to null.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSExceptionHandler represents the Try action introduced in Flash 7 and is
+ * used to directly support the exception handling syntax defined in
+ * ActionScript 2.0.
+ * &lt;/p&gt;
+ */
+public class FSExceptionHandler extends FSActionObject
+{
+	private int register = 0;
+	private String variable = null;
+	private ArrayList tryActions = null;
+	private ArrayList catchActions = null;
+	private ArrayList finalActions = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSExceptionHandler object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSExceptionHandler(FSCoder coder)
+	{
+		super(ExceptionHandler);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs a new exception handler with the thrown object assigned to a
+	 * local variable.
+	 * 
+	 * @param name
+	 *            the name of the variable that the thrown object will be
+	 *            assigned to.
+	 * @param tryArray
+	 *            actions that will be executed in the try block of the
+	 *            exception.
+	 * @param catchArray
+	 *            actions that will be executed in the catch block of the
+	 *            exception, if one is defined. This may be null is no catch
+	 *            block is required - the exception will be handled by another
+	 *            catche block higher in the exception tree.
+	 * @param finallyArray
+	 *            actions that will be executed in the finally block of the
+	 *            exception, if one is defined. This may be null is no finally
+	 *            block is required.
+	 */
+	public FSExceptionHandler(String name, ArrayList tryArray,
+								ArrayList catchArray, ArrayList finallyArray)
+	{
+		super(ExceptionHandler);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_1&quot;&gt;register&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the register that the thrown object will be assigned to. Optional, Omitted if the variable attribute is set.&lt;/td&gt;
-&lt;/tr&gt;
+		register = 0;
+		variable = name;
+		tryActions = tryArray;
+		catchActions = catchArray;
+		finalActions = finallyArray;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_2&quot;&gt;variable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The variable in memory that the thrown object will be assigned to. Optional, Omitted if the register attribute is set.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs a new exception handler with the thrown object assigned to one
+	 * of the Flash Player's internal registers.
+	 * 
+	 * @param index
+	 *            the number of the register that the thrown object will be
+	 *            assigned to.
+	 * @param tryArray
+	 *            actions that will be executed in the try block of the
+	 *            exception.
+	 * @param catchArray
+	 *            actions that will be executed in the catch block of the
+	 *            exception, if one is defined. This may be null is no catch
+	 *            block is required - the exception will be handled by another
+	 *            catche block higher in the exception tree.
+	 * @param finallyArray
+	 *            actions that will be executed in the finally block of the
+	 *            exception, if one is defined. This may be null is no finally
+	 *            block is required.
+	 */
+	public FSExceptionHandler(int index, ArrayList tryArray,
+								ArrayList catchArray, ArrayList finallyArray)
+	{
+		super(ExceptionHandler);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_3&quot;&gt;tryActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The actions executed in the try block of the exception.&lt;/td&gt;
-&lt;/tr&gt;
+		register = index;
+		variable = null;
+		tryActions = tryArray;
+		catchActions = catchArray;
+		finalActions = finallyArray;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_4&quot;&gt;catchActions &lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The actions executed in the catch block of the exception. Defining actions for the catch block is optional and may be set to the null object or an empty array if no actions will be executed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSExceptionHandler object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSExceptionHandler object.
+	 */
+	public FSExceptionHandler(FSExceptionHandler obj)
+	{
+		super(obj);
+		register = obj.register;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExceptionHandler_5&quot;&gt;finalActions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The actions executed in a finally block of the exception. Defining actions for the finally block is optional and may be set to the null object or an empty array if no actions will be executed.&lt;/td&gt;
-&lt;/tr&gt;
+		if (obj.variable != null)
+			variable = new String(obj.variable);
 
-&lt;/table&gt;
+		tryActions = new ArrayList(obj.tryActions.size());
 
-&lt;p&gt;The thrown object can be assigned to either one of the Flash Player's 256 internal registers or to a variable in memory. If a register number is set the variable name is set to null. Similarly if a variable name is set then the register number is set to zero.&lt;/p&gt;
+		for (Iterator i = obj.tryActions.iterator(); i.hasNext();)
+			tryActions.add(((FSActionObject) i.next()).clone());
 
-&lt;p&gt;The FSExceptionHandler class contains three arrays of actions supporting the standard syntax for an exception with try, catch and finally blocks. An exception is thrown by a Throw action which pops a value off the stack and assigns it to either a named variable or one of the Flash Player's internal registered so it can be processed by the actions in the catch block.&lt;/p&gt;
+		if (obj.catchActions != null)
+		{
+			catchActions = new ArrayList(obj.catchActions.size());
 
-&lt;p&gt;Exceptions may be nest to any level if a thrown exception is not handled by the immediate catch block it is propagated to the next handler in the exception hierarchy and so on until it is caught.&lt;/p&gt;
+			for (Iterator i = obj.catchActions.iterator(); i.hasNext();)
+				catchActions.add(((FSActionObject) i.next()).clone());
+		}
 
-&lt;p&gt;Both the catch and finally blocks are optional when defining an exception, the corresponding arguments in constructors and accessor methods may be set to null.&lt;/p&gt;
+		if (obj.finalActions != null)
+		{
+			finalActions = new ArrayList(obj.finalActions.size());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			for (Iterator i = obj.finalActions.iterator(); i.hasNext();)
+				finalActions.add(((FSActionObject) i.next()).clone());
+		}
+	}
 
-&lt;p&gt;The FSExceptionHandler represents the Try action introduced in Flash 7 and is used to directly support the exception handling syntax defined in ActionScript 2.0.&lt;/p&gt;
- */  
-public class FSExceptionHandler extends FSActionObject
-{
-    private int register = 0;
-    private String variable = null;
-    
-    private ArrayList tryActions = null;
-    private ArrayList catchActions = null;
-    private ArrayList finalActions = null;
+	/**
+	 * Adds the action object to the array of actions for the try block.
+	 * 
+	 * @param anAction
+	 *            an action.
+	 */
+	public void addToTry(FSActionObject anAction)
+	{
+		tryActions.add(anAction);
+	}
 
-    /**
-     * Construct an FSExceptionHandler object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSExceptionHandler(FSCoder coder)
-    {
-        super(ExceptionHandler);
-        decode(coder);
-    }
-    /**
-     * Constructs a new exception handler with the thrown object assigned to a local variable.
-     *
-     * @param name the name of the variable that the thrown object will be assigned to.
-     * @param tryArray actions that will be executed in the try block of the exception.
-     * @param catchArray actions that will be executed in the catch block of the exception, if one is defined. This may be null is no catch block is required - the exception will be handled by another catche block higher in the exception tree.
-     * @param finallyArray actions that will be executed in the finally block of the exception, if one is defined. This may be null is no finally block is required.
-     */
-    public FSExceptionHandler(String name, ArrayList tryArray, ArrayList catchArray, ArrayList finallyArray)
-    {
-        super(ExceptionHandler);
-    
-        register = 0;
-        variable = name;
-        tryActions = tryArray;
-        catchActions = catchArray;
-        finalActions = finallyArray;
-    }
-    /**
-     * Constructs a new exception handler with the thrown object assigned to one of the 
-     * Flash Player's internal registers.
-     *
-     * @param index the number of the register that the thrown object will be assigned to.
-     * @param tryArray actions that will be executed in the try block of the exception.
-     * @param catchArray actions that will be executed in the catch block of the exception, if one is defined. This may be null is no catch block is required - the exception will be handled by another catche block higher in the exception tree.
-     * @param finallyArray actions that will be executed in the finally block of the exception, if one is defined. This may be null is no finally block is required.
-     */
-    public FSExceptionHandler(int index, ArrayList tryArray, ArrayList catchArray, ArrayList finallyArray)
-    {
-        super(ExceptionHandler);
-    
-        register = index;
-        variable = null;
-        tryActions = tryArray;
-        catchActions = catchArray;
-        finalActions = finallyArray;
-    }
-    /**
-     * Constructs an FSExceptionHandler object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSExceptionHandler object.
-     */
-    public FSExceptionHandler(FSExceptionHandler obj)
-    {
-        super(obj);
-        register = obj.register;
-        
-        if (obj.variable != null)
-            variable = new String(obj.variable);
-        
-        tryActions = new ArrayList(obj.tryActions.size());
-        
-        for (Iterator i = obj.tryActions.iterator(); i.hasNext();)
-            tryActions.add(((FSActionObject)i.next()).clone());
-        
-        if (obj.catchActions != null)
-        {
-            catchActions = new ArrayList(obj.catchActions.size());
-            
-            for (Iterator i = obj.catchActions.iterator(); i.hasNext();)
-                catchActions.add(((FSActionObject)i.next()).clone());
-        }
-        
-        if (obj.finalActions != null)
-        {
-            finalActions = new ArrayList(obj.finalActions.size());
-            
-            for (Iterator i = obj.finalActions.iterator(); i.hasNext();)
-                finalActions.add(((FSActionObject)i.next()).clone());
-        }
-    }    
+	/**
+	 * Adds the action object to the array of actions for the catch block.
+	 * 
+	 * @param anAction
+	 *            an action.
+	 */
+	public void addToCatch(FSActionObject anAction)
+	{
+		if (catchActions == null)
+			catchActions = new ArrayList();
 
-    /** Adds the action object to the array of actions for the try block.
+		catchActions.add(anAction);
+	}
 
-        @param anAction an action.
-        */
-    public void addToTry(FSActionObject anAction)
-    {
-        tryActions.add(anAction);
-    }
+	/**
+	 * Adds the action object to the array of actions for the finally block.
+	 * 
+	 * @param anAction
+	 *            an action.
+	 */
+	public void addToFinally(FSActionObject anAction)
+	{
+		if (catchActions == null)
+			finalActions = new ArrayList();
 
-    /** Adds the action object to the array of actions for the catch block.
+		finalActions.add(anAction);
+	}
 
-        @param anAction an action.
-        */
-    public void addToCatch(FSActionObject anAction)
-    {
-        if (catchActions == null)
-            catchActions = new ArrayList();
-                
-        catchActions.add(anAction);
-    }
+	/**
+	 * Gets the name of the variable which the exception object is assigned to.
+	 * 
+	 * @return the name of the function. Returns null if the exception object
+	 *         will be assigned to a register.
+	 */
+	public String getVariable()
+	{
+		return variable;
+	}
 
-    /** Adds the action object to the array of actions for the finally block.
+	/**
+	 * Sets the name of the variable that the exception object is assigned to.
+	 * 
+	 * @param name
+	 *            the name of the variable. May be null if the exception object
+	 *            will be signed to a register.
+	 */
+	public void setVariable(String name)
+	{
+		variable = name;
+		register = 0;
+	}
 
-        @param anAction an action.
-        */
-    public void addToFinally(FSActionObject anAction)
-    {
-        if (catchActions == null)
-            finalActions = new ArrayList();
-                
-        finalActions.add(anAction);
-    }
+	/**
+	 * Gets the index of the register that the exception object is assigned to.
+	 * 
+	 * @return the number of register. Returns 0 if the exception object will be
+	 *         assigned to a local variable.
+	 */
+	public int getRegister()
+	{
+		return register;
+	}
 
-    /** Gets the name of the variable which the exception object is assigned to.
+	/**
+	 * Sets the index of the register that the exception object is assigned to.
+	 * 
+	 * @param index
+	 *            the number of the register. May be 0 if the exception object
+	 *            will be assigned to a local variable.
+	 */
+	public void setRegister(int index)
+	{
+		register = index;
+		variable = null;
+	}
 
-        @return the name of the function. Returns null if the exception object
-        will be assigned to a register.
-        */
-    public String getVariable() 
-    {
-        return variable;
-    }
-    
-    /**
-     * Sets the name of the variable that the exception object is assigned to.
-     * 
-     * @param name the name of the variable. May be null if the exception object will
-     * be signed to a register.
-     */
-    public void setVariable(String name)
-    {
-        variable = name;
-        register = 0;
-    }
+	/**
+	 * Gets the array of actions executed in the try block.
+	 * 
+	 * @return the array of actions for the try block.
+	 */
+	public ArrayList getTryActions()
+	{
+		return tryActions;
+	}
 
-    /** 
-     * Gets the index of the register that the exception object is assigned to.
-     * 
-     * @return the number of register. Returns 0 if the exception object will be assigned
-     * to a local variable.
-     */
-    public int getRegister()
-    {
-        return register;
-    }
-    
-    /**
-     * Sets the index of the register that the exception object is assigned to.
-     * 
-     * @param index the number of the register. May be 0 if the exception object
-     * will be assigned to a local variable.
-     */
-    public void setRegister(int index)
-    {
-        register = index;
-        variable = null;
-    }
+	/**
+	 * Sets the array of actions executed in the try block.
+	 * 
+	 * @param array
+	 *            the array of actions for the try block.
+	 */
+	public void setTryActions(ArrayList array)
+	{
+		tryActions = array;
+	}
 
-    /** Gets the array of actions executed in the try block.
+	/**
+	 * Gets the array of actions executed in the catch block.
+	 * 
+	 * @return the array of actions for the catch block.
+	 */
+	public ArrayList getCatchActions()
+	{
+		return catchActions;
+	}
 
-        @return the array of actions for the try block.
-        */
-    public ArrayList getTryActions() 
-    {
-        return tryActions;
-    }
+	/**
+	 * Sets the array of actions executed in the catch block.
+	 * 
+	 * @param array
+	 *            the array of actions for the catch block.
+	 */
+	public void setCatchActions(ArrayList array)
+	{
+		catchActions = array;
+	}
 
-    /** Sets the array of actions executed in the try block.
+	/**
+	 * Gets the array of actions executed in the finally block.
+	 * 
+	 * @return the array of actions for the finally block.
+	 */
+	public ArrayList getFinalActions()
+	{
+		return finalActions;
+	}
 
-        @param array the array of actions for the try block.
-        */
-    public void setTryActions(ArrayList array) 
-    {
-        tryActions = array;
-    }
+	/**
+	 * Sets the array of actions executed in the final block.
+	 * 
+	 * @param array
+	 *            the array of actions for the final block.
+	 */
+	public void setFinalActions(ArrayList array)
+	{
+		finalActions = array;
+	}
 
-    /** Gets the array of actions executed in the catch block.
+	public Object clone()
+	{
+		FSExceptionHandler anObject = (FSExceptionHandler) super.clone();
 
-        @return the array of actions for the catch block.
-        */
-    public ArrayList getCatchActions() 
-    {
-        return catchActions;
-    }
+		anObject.tryActions = new ArrayList();
+		anObject.catchActions = new ArrayList();
+		anObject.finalActions = new ArrayList();
 
-    /** Sets the array of actions executed in the catch block.
+		for (Iterator i = tryActions.iterator(); i.hasNext();)
+			anObject.tryActions.add(((FSActionObject) i.next()).clone());
 
-        @param array the array of actions for the catch block.
-        */
-    public void setCatchActions(ArrayList array) 
-    {
-        catchActions = array;
-    }
+		for (Iterator i = catchActions.iterator(); i.hasNext();)
+			anObject.catchActions.add(((FSActionObject) i.next()).clone());
 
-    /** Gets the array of actions executed in the finally block.
+		for (Iterator i = finalActions.iterator(); i.hasNext();)
+			anObject.finalActions.add(((FSActionObject) i.next()).clone());
 
-        @return the array of actions for the finally block.
-        */
-    public ArrayList getFinalActions() 
-    {
-        return finalActions;
-    }
+		return anObject;
+	}
 
-    /** Sets the array of actions executed in the final block.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param array the array of actions for the final block.
-        */
-    public void setFinalActions(ArrayList array) 
-    {
-        finalActions = array;
-    }
+		if (super.equals(anObject))
+		{
+			FSExceptionHandler typedObject = (FSExceptionHandler) anObject;
 
-    public Object clone()
-    {
-        FSExceptionHandler anObject = (FSExceptionHandler)super.clone();
-        
-         anObject.tryActions = new ArrayList();
-         anObject.catchActions = new ArrayList();
-         anObject.finalActions = new ArrayList();
-            
-        for (Iterator i = tryActions.iterator(); i.hasNext();)
-            anObject.tryActions.add(((FSActionObject)i.next()).clone());
+			if (variable != null)
+				result = variable.equals(typedObject.variable);
+			else
+				result = variable == typedObject.variable;
 
-        for (Iterator i = catchActions.iterator(); i.hasNext();)
-            anObject.catchActions.add(((FSActionObject)i.next()).clone());
+			result = result &amp;&amp; register == typedObject.register;
 
-        for (Iterator i = finalActions.iterator(); i.hasNext();)
-            anObject.finalActions.add(((FSActionObject)i.next()).clone());
+			if (tryActions != null)
+				result = result &amp;&amp; tryActions.equals(typedObject.tryActions);
+			else
+				result = result &amp;&amp; tryActions == typedObject.tryActions;
 
-        return anObject;
-    }
+			if (catchActions != null)
+				result = result
+								&amp;&amp; catchActions
+												.equals(typedObject.catchActions);
+			else
+				result = result &amp;&amp; catchActions == typedObject.catchActions;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSExceptionHandler typedObject = (FSExceptionHandler)anObject;
-            
-            if (variable != null)
-                result = variable.equals(typedObject.variable);
-            else
-                result = variable == typedObject.variable;
-                
-            result = result &amp;&amp; register == typedObject.register;
+			if (finalActions != null)
+				result = result
+								&amp;&amp; finalActions
+												.equals(typedObject.finalActions);
+			else
+				result = result &amp;&amp; finalActions == typedObject.finalActions;
+		}
+		return result;
+	}
 
-            if (tryActions != null)
-                result = result &amp;&amp; tryActions.equals(typedObject.tryActions);
-            else
-                result = result &amp;&amp; tryActions == typedObject.tryActions;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-            if (catchActions != null)
-                result = result &amp;&amp; catchActions.equals(typedObject.catchActions);
-            else
-                result = result &amp;&amp; catchActions == typedObject.catchActions;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;variable&quot;, variable);
+			Transform.append(buffer, &quot;register&quot;, register);
+			Transform.append(buffer, &quot;tryActions&quot;, tryActions, depth);
+			Transform.append(buffer, &quot;catchActions&quot;, catchActions, depth);
+			Transform.append(buffer, &quot;finalActions&quot;, finalActions, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-            if (finalActions != null)
-                result = result &amp;&amp; finalActions.equals(typedObject.finalActions);
-            else
-                result = result &amp;&amp; finalActions == typedObject.finalActions;
-        }
-        return result;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;variable&quot;, variable);        
-            Transform.append(buffer, &quot;register&quot;, register);
-            Transform.append(buffer, &quot;tryActions&quot;, tryActions, depth);
-            Transform.append(buffer, &quot;catchActions&quot;, catchActions, depth);
-            Transform.append(buffer, &quot;finalActions&quot;, finalActions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		length += 7;
+		length += (variable != null) ? coder.strlen(variable, true) : 1;
 
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += 7;
-        length += (variable != null) ? coder.strlen(variable, true) : 1;
-        
-        for (Iterator i = tryActions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            length += currentAction.length(coder);
-            length += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
+		for (Iterator i = tryActions.iterator(); i.hasNext();)
+		{
+			FSActionObject currentAction = (FSActionObject) i.next();
 
-        if (catchActions != null)
-        {
-            for (Iterator i = catchActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
+			length += currentAction.length(coder);
+			length += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
 
-        if (finalActions != null)
-        {
-            for (Iterator i = finalActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        super.encode(coder);
+		if (catchActions != null)
+		{
+			for (Iterator i = catchActions.iterator(); i.hasNext();)
+			{
+				FSActionObject currentAction = (FSActionObject) i.next();
 
-        coder.writeBits(0, 5);
-        coder.writeBits(variable == null ? 1 : 0, 1);
-        coder.writeBits(catchActions != null &amp;&amp; catchActions.size() &gt; 0 ? 1 : 0, 1);
-        coder.writeBits(finalActions != null &amp;&amp; finalActions.size() &gt; 0 ? 1 : 0, 1);
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
+		}
 
-        int tryLength = 0;
-        
-        for (Iterator i = tryActions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            tryLength += currentAction.getLength();
-            tryLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        
-        coder.writeWord(tryLength, 2);
+		if (finalActions != null)
+		{
+			for (Iterator i = finalActions.iterator(); i.hasNext();)
+			{
+				FSActionObject currentAction = (FSActionObject) i.next();
 
-        int catchLength = 0;
-        
-        if (catchActions != null)
-        {
-            for (Iterator i = catchActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                catchLength += currentAction.getLength();
-                catchLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
-        
-        coder.writeWord(catchLength, 2);
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
+		}
+		return length;
+	}
 
-        int finalLength = 0;
-        
-        if (finalActions != null)
-        {
-            for (Iterator i = finalActions.iterator(); i.hasNext();)
-            {
-                FSActionObject currentAction = (FSActionObject)i.next();
-                
-                finalLength += currentAction.getLength();
-                finalLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-        }
-        
-        coder.writeWord(finalLength, 2);
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        if (variable != null)
-            coder.writeString(variable);
-        else
-            coder.writeWord(register, 1);
+		coder.writeBits(0, 5);
+		coder.writeBits(variable == null ? 1 : 0, 1);
+		coder
+						.writeBits(catchActions != null
+										&amp;&amp; catchActions.size() &gt; 0 ? 1 : 0, 1);
+		coder
+						.writeBits(finalActions != null
+										&amp;&amp; finalActions.size() &gt; 0 ? 1 : 0, 1);
 
-        for (Iterator i=tryActions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-                
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
+		int tryLength = 0;
 
-        if (catchActions != null)
-        {
-            for (Iterator i=catchActions.iterator(); i.hasNext();)
-            {
-                FSActionObject action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-        }
+		for (Iterator i = tryActions.iterator(); i.hasNext();)
+		{
+			FSActionObject currentAction = (FSActionObject) i.next();
 
-        if (finalActions != null)
-        {
-            for (Iterator i=finalActions.iterator(); i.hasNext();)
-            {
-                FSActionObject action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (action.getLength() &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-        }
+			tryLength += currentAction.getLength();
+			tryLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsVariable = false;
-        boolean containsCatch = false;
-        boolean containsFinal = false;
-        
-        super.decode(coder);
-        
-        coder.readBits(5, false);
-        containsVariable = coder.readBits(1, false) != 1;
-        containsCatch = coder.readBits(1, false) == 1;
-        containsFinal = coder.readBits(1, false) == 1;
+		coder.writeWord(tryLength, 2);
 
-        int tryLength = coder.readWord(2, false);
-        int catchLength = coder.readWord(2, false);
-        int finalLength = coder.readWord(2, false);
+		int catchLength = 0;
 
-        tryActions = new ArrayList();
-        
-        if (containsCatch)
-            catchActions = new ArrayList();
-            
-        if (containsFinal)
-            finalActions = new ArrayList();
+		if (catchActions != null)
+		{
+			for (Iterator i = catchActions.iterator(); i.hasNext();)
+			{
+				FSActionObject currentAction = (FSActionObject) i.next();
 
-        /*
-         * Both the variable name and register index are represented 
-         * in Describe so pretend fields are consecutive.
-         */
-        if (containsVariable)
-        {
-            variable = coder.readString();
-        }
-        else
-        {
-            register = coder.readWord(1, false);
-        }
+				catchLength += currentAction.getLength();
+				catchLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
+		}
 
-        while (tryLength &gt; 0)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            if (anAction != null)
-            {
-                tryLength -= anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-                tryActions.add(anAction);
-            }
-            else
-            {
-                coder.adjustPointer(8);
-                tryLength =- 1;
-            }
-        }
-        if (containsCatch)
-        {
-            while (catchLength &gt; 0)
-            {
-                FSActionObject anAction = FSMovie.decodeAction(coder);
-                
-                if (anAction != null)
-                {
-                    catchLength -= anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-                    catchActions.add(anAction);
-                }
-                else
-                {
-                    coder.adjustPointer(8);
-                    tryLength =- 1;
-                }
-            }
-        }
-        if (containsFinal)
-        {
-            while (finalLength &gt; 0)
-            {
-                FSActionObject anAction = FSMovie.decodeAction(coder);
-                
-                if (anAction != null)
-                {
-                    finalLength -= anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-                    finalActions.add(anAction);
-                }
-                else
-                {
-                    coder.adjustPointer(8);
-                    tryLength =- 1;
-                }
-            }
-        }
+		coder.writeWord(catchLength, 2);
 
-        coder.endObject(name());
-    }
+		int finalLength = 0;
+
+		if (finalActions != null)
+		{
+			for (Iterator i = finalActions.iterator(); i.hasNext();)
+			{
+				FSActionObject currentAction = (FSActionObject) i.next();
+
+				finalLength += currentAction.getLength();
+				finalLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
+		}
+
+		coder.writeWord(finalLength, 2);
+
+		if (variable != null)
+			coder.writeString(variable);
+		else
+			coder.writeWord(register, 1);
+
+		for (Iterator i = tryActions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
+
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
+
+			action.encode(coder);
+			coder.setPointer(next);
+
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
+
+		if (catchActions != null)
+		{
+			for (Iterator i = catchActions.iterator(); i.hasNext();)
+			{
+				FSActionObject action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (action.getLength() &lt;&lt; 3);
+
+				action.encode(coder);
+				coder.setPointer(next);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+		}
+
+		if (finalActions != null)
+		{
+			for (Iterator i = finalActions.iterator(); i.hasNext();)
+			{
+				FSActionObject action = (FSActionObject) i.next();
+
+				int objStart = coder.getPointer();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (action.getLength() &lt;&lt; 3);
+
+				action.encode(coder);
+				coder.setPointer(next);
+
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
+
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+		}
+
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		boolean containsVariable = false;
+		boolean containsCatch = false;
+		boolean containsFinal = false;
+
+		super.decode(coder);
+
+		coder.readBits(5, false);
+		containsVariable = coder.readBits(1, false) != 1;
+		containsCatch = coder.readBits(1, false) == 1;
+		containsFinal = coder.readBits(1, false) == 1;
+
+		int tryLength = coder.readWord(2, false);
+		int catchLength = coder.readWord(2, false);
+		int finalLength = coder.readWord(2, false);
+
+		tryActions = new ArrayList();
+
+		if (containsCatch)
+			catchActions = new ArrayList();
+
+		if (containsFinal)
+			finalActions = new ArrayList();
+
+		/*
+		 * Both the variable name and register index are represented in Describe
+		 * so pretend fields are consecutive.
+		 */
+		if (containsVariable)
+		{
+			variable = coder.readString();
+		} else
+		{
+			register = coder.readWord(1, false);
+		}
+
+		while (tryLength &gt; 0)
+		{
+			FSActionObject anAction = FSMovie.decodeAction(coder);
+
+			if (anAction != null)
+			{
+				tryLength -= anAction.getLength()
+								+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+				tryActions.add(anAction);
+			} else
+			{
+				coder.adjustPointer(8);
+				tryLength = -1;
+			}
+		}
+		if (containsCatch)
+		{
+			while (catchLength &gt; 0)
+			{
+				FSActionObject anAction = FSMovie.decodeAction(coder);
+
+				if (anAction != null)
+				{
+					catchLength -= anAction.getLength()
+									+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+					catchActions.add(anAction);
+				} else
+				{
+					coder.adjustPointer(8);
+					tryLength = -1;
+				}
+			}
+		}
+		if (containsFinal)
+		{
+			while (finalLength &gt; 0)
+			{
+				FSActionObject anAction = FSMovie.decodeAction(coder);
+
+				if (anAction != null)
+				{
+					finalLength -= anAction.getLength()
+									+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+					finalActions.add(anAction);
+				} else
+				{
+					coder.adjustPointer(8);
+					tryLength = -1;
+				}
+			}
+		}
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSExport.java
===================================================================
--- trunk/src/com/flagstone/transform/FSExport.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSExport.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,192 +33,222 @@
 import java.util.*;
 
 /**
-FSExport is used to export shapes and other objects so they can be used in another Flash file. 
- 
-&lt;p&gt;Since the identifier for an object is only unique within a given Flash file, each object exported must be given a name so it can referenced when it is imported.&lt;/p&gt;
+ * FSExport is used to export shapes and other objects so they can be used in
+ * another Flash file.
+ * 
+ * &lt;p&gt;
+ * Since the identifier for an object is only unique within a given Flash file,
+ * each object exported must be given a name so it can referenced when it is
+ * imported.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;A HashTable containing key-value pairs where the key is the identifier
+ * of the object being exported and the value is name assigned to the object so
+ * it can be referenced when it is imported into a Flash file.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;P&gt;
+ * To export an object from a Flash file:
+ * &lt;/P&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSDefineShape(...);
+ * 
+ *  movie.add(shape);
+ *  movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * The object can then be imported into another file:
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSExport class represents the ExportAssets tag in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5.
+ * &lt;/p&gt;
+ */
+public class FSExport extends FSMovieObject
+{
+	private Hashtable objects = new Hashtable();
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	FSExport()
+	{
+		super(Export);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSExport object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSExport(FSCoder coder)
+	{
+		super(Export);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExport_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSExport object that exports the object with the specified
+	 * identifier. The exported object is assigned the specified name to allow
+	 * it to be referenced in files importing the object.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be exported.
+	 * @param aString
+	 *            the name of the exported object to allow it to be referenced.
+	 */
+	public FSExport(int anIdentifier, String aString)
+	{
+		super(Export);
+		add(anIdentifier, aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSExport_1&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A HashTable containing key-value pairs where the key is the identifier of the object being exported and the value is name assigned to the object so it can be referenced when it is imported into a Flash file.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSExport object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSExport object.
+	 */
+	public FSExport(FSExport obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		objects = new Hashtable(obj.objects.size());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
+		{
+			Object key = i.next();
+			objects.put(key, new String((String) objects.get(key)));
+		}
+	}
 
-&lt;P&gt;To export an object from a Flash file:&lt;/P&gt;
+	/**
+	 * Adds the identifier and name to the list of objects to be exported.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be exported.
+	 * @param aString
+	 *            the name of the exported object to allow it to be referenced.
+	 */
+	public void add(int anIdentifier, String aString)
+	{
+		objects.put(new Integer(anIdentifier), aString);
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(...);
+	/**
+	 * Gets the table of objects to be imported.
+	 * 
+	 * @return the table of imported objects.
+	 */
+	public Hashtable getObjects()
+	{
+		return objects;
+	}
 
-movie.add(shape);
-movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+	/**
+	 * Sets the table of objects to be imported.
+	 * 
+	 * @param aTable
+	 *            the table of objects being imported.
+	 */
+	public void setObjects(Hashtable aTable)
+	{
+		objects = aTable;
+	}
 
-The object can then be imported into another file:
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			result = objects.equals(((FSExport) anObject).getObjects());
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;The FSExport class represents the ExportAssets tag in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSExport extends FSMovieObject
-{
-    private Hashtable objects = new Hashtable();
-        
-    FSExport()
-    {
-        super(Export);
-    }
-    /**
-     * Construct an FSExport object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSExport(FSCoder coder)
-    {
-        super(Export);
-        decode(coder);
-    }
-    /** Constructs an FSExport object that exports the object with the specified identifier. The exported object is assigned the specified name to allow it to be referenced in files importing the object. 
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;objects&quot;, objects, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anIdentifier the identifier of the object to be exported.
-        @param aString the name of the exported object to allow it to be referenced.
-        */
-    public FSExport(int anIdentifier, String aString)
-    {
-        super(Export);
-        add(anIdentifier, aString);
-    }
-    /**
-     * Constructs an FSExport object by copying values from an existing object.
-     *
-     * @param obj an FSExport object.
-     */
-    public FSExport(FSExport obj)
-    {
-        super(obj);
-        
-        objects = new Hashtable(obj.objects.size());
-        
-        for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
-        {
-            Object key = i.next();
-            objects.put(key, new String((String)objects.get(key)));
-        }
-    }    
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Adds the identifier and name to the list of objects to be exported.
+		length += 2;
 
-        @param anIdentifier the identifier of the object to be exported.
-        @param aString the name of the exported object to allow it to be referenced.
-        */
-    public void add(int anIdentifier, String aString)
-    {
-        objects.put(new Integer(anIdentifier), aString);
-    }
+		for (Enumeration e = objects.keys(); e.hasMoreElements();)
+		{
+			String name = (String) (objects.get(e.nextElement()));
 
-    /** Gets the table of objects to be imported.
+			length += 2;
+			length += coder.strlen(name, true);
+		}
+		return length;
+	}
 
-        @return the table of imported objects.
-        */
-    public Hashtable getObjects()
-    {
-        return objects;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the table of objects to be imported.
+		coder.writeWord(objects.size(), 2);
 
-        @param aTable the table of objects being imported.
-        */
-    public void setObjects(Hashtable aTable)
-    {
-       objects = aTable;
-    }
+		for (Enumeration e = objects.keys(); e.hasMoreElements();)
+		{
+			Integer identifier = (Integer) (e.nextElement());
+			String name = (String) (objects.get(identifier));
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            result = objects.equals(((FSExport)anObject).getObjects());
-        }
-        return result;
-    }
+			coder.writeWord(identifier.intValue(), 2);
+			coder.writeString(name);
+			coder.writeWord(0, 1);
+		}
+		coder.endObject(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		int count = coder.readWord(2, false);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		for (int i = 0; i &lt; count; i++)
+		{
+			int identifier = coder.readWord(2, false);
+			String name = coder.readString();
 
-        length += 2;
-
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            String name = (String)(objects.get(e.nextElement()));
-
-            length += 2;
-            length += coder.strlen(name, true);
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(objects.size(), 2);
-
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            Integer identifier = (Integer)(e.nextElement());
-            String name = (String)(objects.get(identifier));
-
-            coder.writeWord(identifier.intValue(), 2);
-            coder.writeString(name);
-            coder.writeWord(0, 1);
-        }        
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int count = coder.readWord(2, false);
-
-        for (int i=0; i&lt;count; i++)
-        {
-            int identifier = coder.readWord(2, false);
-            String name = coder.readString();
-
-            add(identifier, name);
-        }
-        coder.endObject(name());
-    }
+			add(identifier, name);
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSFillStyle.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFillStyle.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSFillStyle.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,102 +30,113 @@
 
 package com.flagstone.transform;
 
-/** 
-FSFillStyle is an abstract base class for the different types of fill style that 
-can be applied to shapes.
-*/
+/**
+ * FSFillStyle is an abstract base class for the different types of fill style
+ * that can be applied to shapes.
+ */
 public abstract class FSFillStyle extends FSTransformObject
 {
-    /** Defines the type for a solid fill style. */
-    public static final int Solid = 0;
-    /** Defines the type for a linear gradient fill style. */
-    public static final int Linear  = 16;
-    /** Defines the type for a radial gradient fill style. */
-    public static final int Radial  = 18;
-    /** Defines the type for a tiled bitmap fill style. */
-    public static final int Tiled = 64;
-    /** Defines the type for a clipped bitmap fill style. */
-    public static final int Clipped = 65;
-    /** Defines the type for a tiled bitmap fill style - added in Flash 7. */
-    public static final int Unsmoothed_Tiled = 66;
-    /** Defines the type for a clipped bitmap fill style - added in Flash 7. */
-    public static final int Unsmoothed_Clipped = 67;
-    
-    protected int type = 0;
-    
-    FSFillStyle()
-    {
-    }
+	/** Defines the type for a solid fill style. */
+	public static final int Solid = 0;
 
-    protected FSFillStyle(FSCoder coder)
-    {
-        decode(coder);
-    }
-    protected FSFillStyle(FSFillStyle obj)
-    {
-        type = obj.type;
-    }
-    protected FSFillStyle(int aType)
-    {
-        setType(aType);
-    }
+	/** Defines the type for a linear gradient fill style. */
+	public static final int Linear = 16;
 
-    /** 
-     * Gets the type of the fill style. The type attribute is read-only and may be used 
-     * when iterating through an array of fill style objects to identify the type of 
-     * fill style without using run-time type checking provided by the compiler.
+	/** Defines the type for a radial gradient fill style. */
+	public static final int Radial = 18;
 
-        @return the type of fill.
-        */
-    public int getType() 
-    { 
-        return type;
-    }
+	/** Defines the type for a tiled bitmap fill style. */
+	public static final int Tiled = 64;
 
-    /** Sets the type of the fill style.
+	/** Defines the type for a clipped bitmap fill style. */
+	public static final int Clipped = 65;
 
-        @param aType the type of fill.
-        */
-    public void setType(int aType)
-    { 
-        type = aType; 
-    }
+	/** Defines the type for a tiled bitmap fill style - added in Flash 7. */
+	public static final int Unsmoothed_Tiled = 66;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSFillStyle typedObject = (FSFillStyle)anObject;
-            
-            result = type == typedObject.type;
-        }
-        
-        return result;
-    }
+	/** Defines the type for a clipped bitmap fill style - added in Flash 7. */
+	public static final int Unsmoothed_Clipped = 67;
 
-    public int length(FSCoder coder)
-    {
-        int length = 1;
-    
-         return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(type, 1);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        type = coder.readWord(1, false);
-    }
+	protected int type = 0;
+
+	FSFillStyle()
+	{
+	}
+
+	protected FSFillStyle(FSCoder coder)
+	{
+		decode(coder);
+	}
+
+	protected FSFillStyle(FSFillStyle obj)
+	{
+		type = obj.type;
+	}
+
+	protected FSFillStyle(int aType)
+	{
+		setType(aType);
+	}
+
+	/**
+	 * Gets the type of the fill style. The type attribute is read-only and may
+	 * be used when iterating through an array of fill style objects to identify
+	 * the type of fill style without using run-time type checking provided by
+	 * the compiler.
+	 * 
+	 * @return the type of fill.
+	 */
+	public int getType()
+	{
+		return type;
+	}
+
+	/**
+	 * Sets the type of the fill style.
+	 * 
+	 * @param aType
+	 *            the type of fill.
+	 */
+	public void setType(int aType)
+	{
+		type = aType;
+	}
+
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
+
+		if (super.equals(anObject))
+		{
+			FSFillStyle typedObject = (FSFillStyle) anObject;
+
+			result = type == typedObject.type;
+		}
+
+		return result;
+	}
+
+	public int length(FSCoder coder)
+	{
+		int length = 1;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(type, 1);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		type = coder.readWord(1, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSFontInfo.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFontInfo.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSFontInfo.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,402 +33,467 @@
 import java.util.*;
 
 /**
-FSFontInfo defines the name and face of a font and maps the codes for a given character 
-set to the glyphs that are drawn to represent each character.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSFontInfo defines the name and face of a font and maps the codes for a given
+ * character set to the glyphs that are drawn to represent each character.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier, in the range 1..65535, for the FSDefineFont
+ * object that contains the glyphs for the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encoding&lt;/td&gt;
+ * &lt;td&gt;Specifies whether the codes for the character set are represented using
+ * ANSI (ASCII), SJIS or Unicode.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Whether the font is bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;italic&lt;/td&gt;
+ * &lt;td&gt;Whether the font is rendered in italics.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;isSmall&lt;/td&gt;
+ * &lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;codes&lt;/td&gt;
+ * &lt;td&gt;An array mapping a glyph index to a particular character code in the
+ * font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The ANSI character set is used for Latin languages, SJIS is used for Japanese
+ * language characters and Unicode is used for any character set. The encoding
+ * attributes uses the constants FSText.ANSI, FSText.SJIS or FSText.Unicode for
+ * each character set type.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The index of each entry in the codes array matches the index in the
+ * corresponding glyph in the shapes array of an FSDefineFont object, allowing a
+ * given character code to be mapped to a given glyph.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The class allows the font associated with a Flash file to be mapped to a font
+ * installed on the device where the Flash Player displaying the file is hosted.
+ * The use of a font from a device is not automatic but is determined by the
+ * HTML tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when
+ * it is first started. If a device does not support a given font then the
+ * glyphs in the FSDefineFont class are used to render the characters.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * An important distinction between the host device to specify the font and
+ * using the glyphs in an FSDefineFont object is that the device is not
+ * anti-aliased and the rendering is dependent on the host device. The glyphs in
+ * an FSDefineFont object are anti-aliased and are guaranteed to look identical
+ * on every device the text is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFontInfo class represents the DefineFontInfo data structure from the
+ * Flash specification. It was introduced in Flash 1. Support for small fonts
+ * was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSFontInfo extends FSMovieObject
+{
+	private int identifier = 0;
+	private String name = &quot;&quot;;
+	private int encoding = FSText.Unicode;
+	private boolean small = false;
+	private boolean italic = false;
+	private boolean bold = false;
+	private ArrayList codes = new ArrayList();
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/*
+	 * attributes used to retain state during encoding.
+	 */
+	private boolean _containsWideCodes = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSFontInfo object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFontInfo(FSCoder coder)
+	{
+		super(FSMovieObject.FontInfo);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier, in the range 1..65535, for the FSDefineFont object that contains the glyphs for the font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs a basic FSFontInfo object specifying only the name of the
+	 * font.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 * @param aName
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public FSFontInfo(int anIdentifier, String aName)
+	{
+		super(FSMovieObject.FontInfo);
+		setIdentifier(anIdentifier);
+		setName(aName);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_2&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of the font.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSFontInfo object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSFontInfo object.
+	 */
+	public FSFontInfo(FSFontInfo obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		name = new String(obj.name);
+		encoding = obj.encoding;
+		small = obj.small;
+		italic = obj.italic;
+		bold = obj.bold;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_3&quot;&gt;encoding&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Specifies whether the codes for the character set are represented using ANSI (ASCII), SJIS or Unicode.&lt;/td&gt;
-&lt;/tr&gt;
+		codes = new ArrayList(obj.codes.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_4&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.codes.iterator(); i.hasNext();)
+			codes.add(new Integer(((Integer) i.next()).intValue()));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_5&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is bold.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the font that this font information is for.
+	 * 
+	 * @return the identifier of the FSDefineFont object that contains the
+	 *         glyphs for the font.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_6&quot;&gt;italic&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is rendered in italics.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the name of the font family.
+	 * 
+	 * @return the name of the font.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_7&quot;&gt;isSmall&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the encoding scheme used for characters rendered in the font, either
+	 * FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	 * 
+	 * @return the font character encoding.
+	 */
+	public int getEncoding()
+	{
+		return encoding;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo_8&quot;&gt;codes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array mapping a glyph index to a particular character code in the font.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	// Flash 7
+	/**
+	 * Does the font have a small point size. This is used only with a Unicode
+	 * font encoding.
+	 * 
+	 * @return a boolean indicating whether the font will be aligned on pixel
+	 *         boundaries.
+	 */
+	public boolean isSmall()
+	{
+		return small;
+	}
 
-&lt;p&gt;The ANSI character set is used for Latin languages, SJIS is used for Japanese 
-language characters and Unicode is used for any character set. The encoding 
-attributes uses the constants FSText.ANSI, FSText.SJIS or FSText.Unicode 
-for each character set type.&lt;/p&gt;
+	/**
+	 * Sets the font is small. Used only with Unicode fonts.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating the font will be aligned on pixel
+	 *            boundaries.
+	 */
+	public void setSmall(boolean aBool)
+	{
+		small = aBool;
+	}
 
-&lt;p&gt;The index of each entry in the codes array matches the index in the corresponding 
-glyph in the shapes array of an FSDefineFont object, allowing a given character 
-code to be mapped to a given glyph.&lt;/p&gt;
+	// End Flash 7
 
-&lt;p&gt;The class allows the font associated with a Flash file to be mapped to a font 
-installed on the device where the Flash Player displaying the file is hosted. 
-The use of a font from a device is not automatic but is determined by the HTML 
-tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when it is first 
-started. If a device does not support a given font then the glyphs in the FSDefineFont 
-class are used to render the characters.&lt;/p&gt;
+	/**
+	 * Is the font italics.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in italics.
+	 */
+	public boolean isItalic()
+	{
+		return italic;
+	}
 
-&lt;p&gt;An important distinction between the host device to specify the font and using 
-the glyphs in an FSDefineFont object is that the device is not anti-aliased and 
-the rendering is dependent on the host device. The glyphs in an FSDefineFont 
-object are anti-aliased and are guaranteed to look identical on every device the 
-text is displayed.&lt;/p&gt;
+	/**
+	 * Is the font bold.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in a bold face.
+	 */
+	public boolean isBold()
+	{
+		return bold;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the array of character codes.
+	 * 
+	 * @return the array of character codes.
+	 */
+	public ArrayList getCodes()
+	{
+		return codes;
+	}
 
-&lt;p&gt;The FSFontInfo class represents the DefineFontInfo data structure from the 
-Flash specification. It was introduced in Flash 1. Support for small fonts was 
-added in Flash 7.&lt;/p&gt;
- */
-public class FSFontInfo extends FSMovieObject
-{
-    private int identifier = 0;
-    private String name = &quot;&quot;;
-    private int encoding = FSText.Unicode;
-    private boolean small = false;
-    private boolean italic = false;
-    private boolean bold = false;
-    private ArrayList codes = new ArrayList();
-    
-    /*
-     * attributes used to retain state during encoding.
-     */
-    private boolean _containsWideCodes = false;
-    
-    /**
-     * Construct an FSFontInfo object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFontInfo(FSCoder coder)
-    {
-        super(FSMovieObject.FontInfo);
-        decode(coder);
-    }
-    /**  Constructs a basic FSFontInfo object specifying only the name of the font.
-    
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        @param aName the name assigned to the font, identifying the font family.
-        */
-    public FSFontInfo(int anIdentifier, String aName)
-    {
-        super(FSMovieObject.FontInfo);
-        setIdentifier(anIdentifier);
-        setName(aName);
-    }
-    /**
-     * Constructs an FSFontInfo object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSFontInfo object.
-     */
-    public FSFontInfo(FSFontInfo obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        name = new String(obj.name);
-        encoding = obj.encoding;
-        small = obj.small;
-        italic = obj.italic;
-        bold = obj.bold;
-        
-        codes = new ArrayList(obj.codes.size());
-        
-        for (Iterator i = obj.codes.iterator(); i.hasNext();)
-            codes.add(new Integer(((Integer)i.next()).intValue()));
-    }    
+	/**
+	 * Sets the identifier of the font that this font information is for.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /** Gets the identifier of the font that this font information is for.
+	/**
+	 * Sets the name of the font.
+	 * 
+	 * @param aString
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-        @return the identifier of the FSDefineFont object that contains the glyphs for the font.
-        */
-    public int getIdentifier() { return identifier; }
+	/**
+	 * Sets the font character encoding.
+	 * 
+	 * @param anEncoding
+	 *            the encoding used to identify characters, either FSText.ASCII,
+	 *            FSText.SJIS or FSText.Unicode.
+	 */
+	public void setEncoding(int anEncoding)
+	{
+		encoding = anEncoding;
+	}
 
-    /** Gets the name of the font family.
+	/**
+	 * Sets the font is italics.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            italics.
+	 */
+	public void setItalic(boolean aBool)
+	{
+		italic = aBool;
+	}
 
-        @return the name of the font.
-        */
-    public String getName() 
-    {
-        return name;
-    }
+	/**
+	 * Sets the font is bold.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            bold face.
+	 */
+	public void setBold(boolean aBool)
+	{
+		bold = aBool;
+	}
 
-    /** Gets the encoding scheme used for characters rendered in the font, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	/**
+	 * Sets the array of character codes. The index position of a character code
+	 * in the array identifies the index of the corresponding glyph in the
+	 * FSDefineFont object.
+	 * 
+	 * @param anArray
+	 *            the array mapping glyphs to particular character codes.
+	 */
+	public void setCodes(ArrayList anArray)
+	{
+		codes = anArray;
+	}
 
-        @return the font character encoding.
-        */
-    public int getEncoding() 
-    {
-        return encoding;
-    }
+	public Object clone()
+	{
+		FSFontInfo anObject = (FSFontInfo) super.clone();
 
-// Flash 7
-    /** Does the font have a small point size. This is used only with a Unicode 
-     *  font encoding.
-     * 
-     *  @return a boolean indicating whether the font will be aligned on pixel boundaries.
-     */
-    public boolean isSmall() 
-    {
-        return small;
-    }
+		anObject.codes = new ArrayList();
 
-    /** Sets the font is small. Used only with Unicode fonts.
-     * 
-     *  @param aBool a boolean flag indicating the font will be aligned on pixel boundaries.
-     */
-    public void setSmall(boolean aBool)
-    {
-        small = aBool;
-    }
-// End Flash 7
-    
-    /** Is the font italics.
+		for (Iterator i = codes.iterator(); i.hasNext();)
+			anObject.codes.add(new Integer(((Integer) i.next()).intValue()));
 
-        @return a boolean indicating whether the font is rendered in italics.
-        */
-    public boolean isItalic() 
-    {
-        return italic;
-    }
+		return anObject;
+	}
 
-    /** Is the font bold.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return a boolean indicating whether the font is rendered in a bold face.
-        */
-    public boolean isBold()
-    {
-        return bold;
-    }
+		if (super.equals(anObject))
+		{
+			FSFontInfo typedObject = (FSFontInfo) anObject;
 
-    /** Gets the array of character codes.
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; encoding == typedObject.encoding;
+			result = result &amp;&amp; small == typedObject.small;
+			result = result &amp;&amp; italic == typedObject.italic;
+			result = result &amp;&amp; bold == typedObject.bold;
 
-        @return the array of character codes.
-        */
-    public ArrayList getCodes()
-    {
-        return codes;
-    }
+			if (name != null)
+				result = result &amp;&amp; name.equals(typedObject.name);
+			else
+				result = result &amp;&amp; name == typedObject.name;
 
-    /** Sets the identifier of the font that this font information is for.
+			if (codes != null)
+				result = result &amp;&amp; codes.equals(typedObject.codes);
+			else
+				result = result &amp;&amp; codes == typedObject.codes;
+		}
+		return result;
+	}
 
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the name of the font.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;encoding&quot;, encoding);
+			// Flash 7
+			Transform.append(buffer, &quot;small&quot;, small);
+			// End Flash 7
+			Transform.append(buffer, &quot;italic&quot;, italic);
+			Transform.append(buffer, &quot;bold&quot;, bold);
+			Transform.append(buffer, &quot;name&quot;, name);
+			Transform.append(buffer, &quot;codes&quot;, codes, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aString the name assigned to the font, identifying the font family.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the font character encoding.
+		length += 4;
+		length += coder.strlen(name, false);
 
-        @param anEncoding the encoding used to identify characters, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
-        */
-    public void setEncoding(int anEncoding)
-    {
-        encoding = anEncoding;
-    }
+		_containsWideCodes = false;
 
-    /** Sets the font is italics.
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+		{
+			if (((Integer) codesIterator.next()).intValue() &gt; 255)
+				_containsWideCodes = true;
+		}
 
-        @param aBool a boolean flag indicating whether the font will be rendered in italics.
-        */
-    public void setItalic(boolean aBool)
-    {
-        italic = aBool;
-    }
+		length += codes.size() * (_containsWideCodes ? 2 : 1);
 
-    /** Sets the font is bold.
+		return length;
+	}
 
-        @param aBool a boolean flag indicating whether the font will be rendered in bold face.
-        */
-    public void setBold(boolean aBool)
-    {
-        bold = aBool;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the array of character codes. The index position of a character code in the array identifies the index of the corresponding glyph in the FSDefineFont object.
+		coder.writeWord(identifier, 2);
+		coder.writeWord(coder.strlen(name, false), 1);
+		coder.writeString(name);
+		coder.writeBits(0, 2);
+		coder.writeBits(small ? 1 : 0, 1);
+		coder.writeBits(encoding, 2);
+		coder.writeBits(italic ? 1 : 0, 1);
+		coder.writeBits(bold ? 1 : 0, 1);
+		coder.writeBits(_containsWideCodes ? 1 : 0, 1);
 
-        @param anArray the array mapping glyphs to particular character codes.
-        */
-    public void setCodes(ArrayList anArray)
-    {
-        codes = anArray;
-    }
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+			coder.writeWord(((Integer) codesIterator.next()).intValue(),
+							_containsWideCodes ? 2 : 1);
 
-    public Object clone()
-    {
-        FSFontInfo anObject = (FSFontInfo)super.clone();
-        
-        anObject.codes = new ArrayList();
-            
-        for (Iterator i = codes.iterator(); i.hasNext();)
-            anObject.codes.add(new Integer(((Integer)i.next()).intValue()));
+		coder.endObject(name());
+	}
 
-        return anObject;
-    }
+	public void decode(FSCoder coder)
+	{
+		int nameLength = 0;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSFontInfo typedObject = (FSFontInfo)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; encoding == typedObject.encoding;
-            result = result &amp;&amp; small == typedObject.small;
-            result = result &amp;&amp; italic == typedObject.italic;
-            result = result &amp;&amp; bold == typedObject.bold;
+		codes = new ArrayList();
 
-            if (name != null)
-                result = result &amp;&amp; name.equals(typedObject.name);
-            else
-                result = result &amp;&amp; name == typedObject.name;
+		super.decode(coder);
 
-            if (codes != null)
-                result = result &amp;&amp; codes.equals(typedObject.codes);
-            else
-                result = result &amp;&amp; codes == typedObject.codes;
-        }
-        return result;
-    }
+		identifier = coder.readWord(2, false);
+		nameLength = coder.readWord(1, false);
+		name = coder.readString(nameLength);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;encoding&quot;, encoding);
-// Flash 7
-            Transform.append(buffer, &quot;small&quot;, small);
-// End Flash 7
-            Transform.append(buffer, &quot;italic&quot;, italic);
-            Transform.append(buffer, &quot;bold&quot;, bold);
-            Transform.append(buffer, &quot;name&quot;, name);
-            Transform.append(buffer, &quot;codes&quot;, codes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (name.length() &gt; 0)
+		{
+			while (name.charAt(name.length() - 1) == 0)
+			{
+				name = name.substring(0, name.length() - 1);
+			}
+		}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        length += coder.strlen(name, false);
-        
-        _containsWideCodes = false;
-    
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-        {
-            if (((Integer)codesIterator.next()).intValue() &gt; 255)
-                _containsWideCodes = true;
-        }
-        
-        length += codes.size()*(_containsWideCodes ? 2 : 1);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {    
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        coder.writeWord(coder.strlen(name, false), 1);
-        coder.writeString(name);
-        coder.writeBits(0, 2);
-        coder.writeBits(small ? 1 : 0, 1);
-        coder.writeBits(encoding, 2);
-        coder.writeBits(italic ? 1 : 0, 1);
-        coder.writeBits(bold ? 1 : 0, 1);
-        coder.writeBits(_containsWideCodes ? 1 : 0, 1);
-        
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-            coder.writeWord(((Integer)codesIterator.next()).intValue(), _containsWideCodes ? 2 : 1);    
+		/* reserved */coder.readBits(2, false);
+		small = coder.readBits(1, false) != 0 ? true : false;
+		encoding = coder.readBits(2, false);
+		italic = coder.readBits(1, false) != 0 ? true : false;
+		bold = coder.readBits(1, false) != 0 ? true : false;
+		_containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int nameLength = 0;
-       
-        codes = new ArrayList();
-        
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        nameLength = coder.readWord(1, false);
-        name = coder.readString(nameLength);
+		int bytesRead = 3 + nameLength + 1;
 
-        if (name.length() &gt; 0)
-        {
-            while (name.charAt(name.length()-1) == 0) {
-            	name = name.substring(0, name.length()-1);
-            }
-        }
-        
-        /* reserved */ coder.readBits(2, false);
-        small = coder.readBits(1, false) != 0 ? true : false;
-        encoding = coder.readBits(2, false);
-        italic = coder.readBits(1, false) != 0 ? true : false;
-        bold = coder.readBits(1, false) != 0 ? true : false;
-        _containsWideCodes = coder.readBits(1, false) != 0 ? true : false;
+		while (bytesRead &lt; length)
+		{
+			codes.add(new Integer(coder.readWord(_containsWideCodes ? 2 : 1,
+							false)));
+			bytesRead += (_containsWideCodes) ? 2 : 1;
+		}
 
-        int bytesRead = 3 + nameLength + 1;
-
-        while (bytesRead &lt; length)
-        {
-            codes.add(new Integer(coder.readWord(_containsWideCodes ? 2 : 1, false)));
-            bytesRead += (_containsWideCodes) ? 2 : 1;
-        }
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSFontInfo2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFontInfo2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSFontInfo2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,379 +33,483 @@
 import java.util.*;
 
 /**
-FSFontInfo2 describes the mapping of codes for a given character set to the glyphs that 
-are drawn to represent the character. 
- 
-&lt;p&gt;It extends the functionality provided by FSFontInfo by adding a language attribute which is support to support line-breaking when displaying text in different spoken languages. Support for small fonts was added in Flash 7.&lt;/P&gt;
+ * FSFontInfo2 describes the mapping of codes for a given character set to the
+ * glyphs that are drawn to represent the character.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by FSFontInfo by adding a language
+ * attribute which is support to support line-breaking when displaying text in
+ * different spoken languages. Support for small fonts was added in Flash 7.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * The class allows the font associated with a Flash file to be mapped to a font
+ * installed on the device where the Flash Player displaying the file is hosted.
+ * The use of a font from a device is not automatic but is determined by the
+ * HTML tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when
+ * it is first started. If a device does not support a given font then the
+ * glyphs in the FSDefineFont class are used to render the characters.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * An important distinction between the host device to specify the font and
+ * using the glyphs in an FSDefineFont object is that the device is not
+ * anti-aliased and the rendering is dependent on the host device. The glyphs in
+ * an FSDefineFont object are anti-aliased and are guaranteed to look identical
+ * on every device the text is displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier for an FSDefineFont object that contains all the
+ * glyphs for the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;small&lt;/td&gt;
+ * &lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;encoding&lt;/td&gt;
+ * &lt;td&gt;Specifies whether the character codes areTransform.ANSI,Transform.SJIS,
+ * Unicode.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;bold&lt;/td&gt;
+ * &lt;td&gt;Whether the font is bold.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;italic&lt;/td&gt;
+ * &lt;td&gt;Whether the font is italicised.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;language&lt;/td&gt;
+ * &lt;td&gt;A code identifying the spoken language for a font, either Latin,
+ * Japanese, Korean, SimplifiedChinese or TraditionalChinese. The language code
+ * is used to assist in determining the position of line breaks in text
+ * displayed using the font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;codes&lt;/td&gt;
+ * &lt;td&gt;An array mapping a glyph index to a particular character code in the
+ * font.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The index of each entry in the codes array matches the index in the
+ * corresponding glyph in the shapes array of an FSDefineFont object, allowing a
+ * given character code to be mapped to a given glyph.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFontInfo2 class supports the DefineFontInfo2 data structure introduced
+ * in Flash 6. Support for small fonts was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSFontInfo2 extends FSMovieObject
+{
+	private int identifier = 0;
+	private String name = &quot;&quot;;
+	private boolean small = false;
+	private int encoding = FSText.Unicode;
+	private boolean italic = false;
+	private boolean bold = false;
+	private int language = 1; // FSText.Latin
+	private ArrayList codes = new ArrayList();
 
-&lt;p&gt;The class allows the font associated with a Flash file to be mapped to a font installed on the device where the Flash Player displaying the file is hosted. The use of a font from a device is not automatic but is determined by the HTML tag option &lt;i&gt;deviceFont&lt;/i&gt; which is passed to the Flash Player when it is first started. If a device does not support a given font then the glyphs in the FSDefineFont class are used to render the characters.&lt;/p&gt;
+	/**
+	 * Construct an FSFontInfo2 object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFontInfo2(FSCoder coder)
+	{
+		super(FontInfo2);
+		decode(coder);
+	}
 
-&lt;p&gt;An important distinction between the host device to specify the font and using the glyphs in an FSDefineFont object is that the device is not anti-aliased and the rendering is dependent on the host device. The glyphs in an FSDefineFont object are anti-aliased and are guaranteed to look identical on every device the text is displayed.&lt;/p&gt;
+	/**
+	 * Constructs a basic FSFontInfo2 object specifying only the name of the
+	 * font.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 * @param aName
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public FSFontInfo2(int anIdentifier, String aName)
+	{
+		super(FontInfo2);
+		setIdentifier(anIdentifier);
+		setName(aName);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSFontInfo2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSFontInfo2 object.
+	 */
+	public FSFontInfo2(FSFontInfo2 obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		name = new String(obj.name);
+		encoding = obj.encoding;
+		small = obj.small;
+		italic = obj.italic;
+		bold = obj.bold;
+		language = obj.language;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		codes = new ArrayList(obj.codes.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFontInfo2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.codes.iterator(); i.hasNext();)
+			codes.add(new Integer(((Integer) i.next()).intValue()));
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The unique identifier for an FSDefineFont object that contains all the glyphs for the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_2&quot;&gt;name&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The name of the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_3&quot;&gt;small&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Indicates the font is small enough to align to pixel boundaries.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_4&quot;&gt;encoding&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Specifies whether the character codes areTransform.ANSI,Transform.SJIS, Unicode.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_5&quot;&gt;bold&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is bold.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_6&quot;&gt;italic&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Whether the font is italicised.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_7&quot;&gt;language&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A code identifying the spoken language for a font, either Latin, Japanese, Korean, SimplifiedChinese or TraditionalChinese. The language code is used to assist in determining the position of line breaks in text displayed using the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSFontInfo2_8&quot;&gt;codes&lt;/a&gt;&lt;/td&gt;&lt;td&gt;An array mapping a glyph index to a particular character code in the font.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the identifier of the font that this font information is for.
+	 * 
+	 * @return the identifier of the FSDefineFont object that contains the
+	 *         glyphs for the font.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;p&gt;The index of each entry in the codes array matches the index in the corresponding glyph in the shapes array of an FSDefineFont object, allowing a given character code to be mapped to a given glyph.&lt;/p&gt;
+	/**
+	 * Gets the name of the font family.
+	 * 
+	 * @return the name of the font.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the encoding scheme used for characters rendered in the font, either
+	 * FSText.ASCII, FSText.SJIS or FSText.Unicode.
+	 * 
+	 * @return the font character encoding.
+	 */
+	public int getEncoding()
+	{
+		return encoding;
+	}
 
-&lt;p&gt;The FSFontInfo2 class supports the DefineFontInfo2 data structure introduced 
-in Flash 6. Support for small fonts was added in Flash 7.&lt;/p&gt;
- */  
-public class FSFontInfo2 extends FSMovieObject
-{
-    private int identifier = 0;
-    private String name = &quot;&quot;;
-    private boolean small = false;
-    private int encoding = FSText.Unicode;
-    private boolean italic = false;
-    private boolean bold = false;
-    private int language = 1; // FSText.Latin
-    private ArrayList codes = new ArrayList();
-    
-    /**
-     * Construct an FSFontInfo2 object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFontInfo2(FSCoder coder)
-    {
-        super(FontInfo2);
-        decode(coder);
-    }
-    /**  Constructs a basic FSFontInfo2 object specifying only the name of the font.
-    
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        @param aName the name assigned to the font, identifying the font family.
-        */
-    public FSFontInfo2(int anIdentifier, String aName)
-    {
-        super(FontInfo2);
-        setIdentifier(anIdentifier);
-        setName(aName);
-    }
-    /**
-     * Constructs an FSFontInfo2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSFontInfo2 object.
-     */
-    public FSFontInfo2(FSFontInfo2 obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        name = new String(obj.name);
-        encoding = obj.encoding;
-        small = obj.small;
-        italic = obj.italic;
-        bold = obj.bold;
-        language = obj.language;
-        
-        codes = new ArrayList(obj.codes.size());
-        
-        for (Iterator i = obj.codes.iterator(); i.hasNext();)
-            codes.add(new Integer(((Integer)i.next()).intValue()));
-    }    
+	// Flash 7
+	/**
+	 * Does the font have a small point size. This is used only with a Unicode
+	 * font encoding.
+	 * 
+	 * @return a boolean indicating whether the font will be aligned on pixel
+	 *         boundaries.
+	 */
+	public boolean isSmall()
+	{
+		return small;
+	}
 
-    /** Gets the identifier of the font that this font information is for.
+	/**
+	 * Sets the font is small. Used only with Unicode fonts.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating the font will be aligned on pixel
+	 *            boundaries.
+	 */
+	public void setSmall(boolean aBool)
+	{
+		small = aBool;
+	}
 
-        @return the identifier of the FSDefineFont object that contains the glyphs for the font.
-        */
-    public int getIdentifier() { return identifier; }
+	// Flash 7
 
-    /** Gets the name of the font family.
+	/**
+	 * Is the font italics.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in italics.
+	 */
+	public boolean isItalic()
+	{
+		return italic;
+	}
 
-        @return the name of the font.
-        */
-    public String getName() 
-    {
-        return name;
-    }
+	/**
+	 * Is the font bold.
+	 * 
+	 * @return a boolean indicating whether the font is rendered in a bold face.
+	 */
+	public boolean isBold()
+	{
+		return bold;
+	}
 
-    /** 
-     * Gets the encoding scheme used for characters rendered in the font, either FSText.ASCII, 
-     * FSText.SJIS or FSText.Unicode.
+	/**
+	 * Gets the language code identifying the type of spoken language for the
+	 * font, either FSText.Japanese, FSText.Korean, FSText.Latin,
+	 * FSText.SimplifiedChinese or FSText.TraditionalChinese.
+	 * 
+	 * @return the language code used to determine how line-breaks are inserted
+	 *         into text rendered using the font.
+	 */
+	public int getLanguage()
+	{
+		return language;
+	}
 
-        @return the font character encoding.
-        */
-    public int getEncoding() 
-    {
-        return encoding;
-    }
+	/**
+	 * Gets the array of character codes.
+	 * 
+	 * @return the array of character codes.
+	 */
+	public ArrayList getCodes()
+	{
+		return codes;
+	}
 
-// Flash 7
-    /** Does the font have a small point size. This is used only with a Unicode 
-     *  font encoding.
-     * 
-     *  @return a boolean indicating whether the font will be aligned on pixel boundaries.
-     */
-    public boolean isSmall() 
-    {
-        return small;
-    }
+	/**
+	 * Sets the identifier of the font that this font information is for.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineFont that contains the
+	 *            glyphs for the font.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /** Sets the font is small. Used only with Unicode fonts.
-     * 
-     *  @param aBool a boolean flag indicating the font will be aligned on pixel boundaries.
-     */
-    public void setSmall(boolean aBool)
-    {
-        small = aBool;
-    }
-// Flash 7
+	/**
+	 * Sets the name of the font.
+	 * 
+	 * @param aString
+	 *            the name assigned to the font, identifying the font family.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-    /** Is the font italics.
+	/**
+	 * Sets the font character encoding.
+	 * 
+	 * @param anEncoding
+	 *            the encoding used to identify characters, either FSText.ASCII,
+	 *            FSText.SJIS or FSText.Unicode.
+	 */
+	public void setEncoding(int anEncoding)
+	{
+		encoding = anEncoding;
+	}
 
-        @return a boolean indicating whether the font is rendered in italics.
-        */
-    public boolean isItalic() 
-    {
-        return italic;
-    }
+	/**
+	 * Sets the font is italics.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            italics.
+	 */
+	public void setItalic(boolean aBool)
+	{
+		italic = aBool;
+	}
 
-    /** Is the font bold.
+	/**
+	 * Sets the font is bold.
+	 * 
+	 * @param aBool
+	 *            a boolean flag indicating whether the font will be rendered in
+	 *            bold face.
+	 */
+	public void setBold(boolean aBool)
+	{
+		bold = aBool;
+	}
 
-        @return a boolean indicating whether the font is rendered in a bold face.
-        */
-    public boolean isBold()
-    {
-        return bold;
-    }
+	/**
+	 * Sets the language code used to determine the position of line-breaks in
+	 * text rendered using the font.
+	 * 
+	 * The language attribute is ignored if the object is encoded in a Flash 5
+	 * movie.
+	 * 
+	 * @param code
+	 *            the code identifying the spoken language either Latin,
+	 *            Japanese, Korean, SimplifiedChinese or TraditionalChinese.
+	 */
+	public void setLanguage(int code)
+	{
+		language = code;
+	}
 
-    /** 
-     * Gets the language code identifying the type of spoken language for the font, 
-     * either FSText.Japanese, FSText.Korean, FSText.Latin, FSText.SimplifiedChinese or 
-     * FSText.TraditionalChinese.
+	/**
+	 * Sets the array of character codes.
+	 * 
+	 * @param anArray
+	 *            the array mapping glyphs to particular character codes. The
+	 *            ordinal position of a character code in the array identifies
+	 *            the index of the corresponding glyph in the FSDefineFont
+	 *            object.
+	 */
+	public void setCodes(ArrayList anArray)
+	{
+		codes = anArray;
+	}
 
-        @return the language code used to determine how line-breaks are inserted into 
-        text rendered using the font.
-        */
-    public int getLanguage()
-    {
-        return language;
-    }
+	public Object clone()
+	{
+		FSFontInfo2 anObject = (FSFontInfo2) super.clone();
 
-    /** Gets the array of character codes.
+		anObject.codes = new ArrayList();
 
-        @return the array of character codes.
-        */
-    public ArrayList getCodes()
-    {
-        return codes;
-    }
+		for (Iterator i = codes.iterator(); i.hasNext();)
+			anObject.codes.add(new Integer(((Integer) i.next()).intValue()));
 
-    /** Sets the identifier of the font that this font information is for.
+		return anObject;
+	}
 
-        @param anIdentifier the unique identifier of the FSDefineFont that contains the glyphs for the font.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the name of the font.
+		if (super.equals(anObject))
+		{
+			FSFontInfo2 typedObject = (FSFontInfo2) anObject;
 
-        @param aString the name assigned to the font, identifying the font family.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; encoding == typedObject.encoding;
+			result = result &amp;&amp; small == typedObject.small;
+			result = result &amp;&amp; italic == typedObject.italic;
+			result = result &amp;&amp; bold == typedObject.bold;
+			result = result &amp;&amp; language == typedObject.language;
 
-    /** Sets the font character encoding.
+			if (name != null)
+				result = result &amp;&amp; name.equals(typedObject.name);
+			else
+				result = result &amp;&amp; name == typedObject.name;
 
-        @param anEncoding the encoding used to identify characters, either FSText.ASCII, FSText.SJIS or FSText.Unicode.
-        */
-    public void setEncoding(int anEncoding)
-    {
-        encoding = anEncoding;
-    }
+			if (codes != null)
+				result = result &amp;&amp; codes.equals(typedObject.codes);
+			else
+				result = result &amp;&amp; codes == typedObject.codes;
+		}
+		return result;
+	}
 
-    /** Sets the font is italics.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param aBool a boolean flag indicating whether the font will be rendered in italics.
-        */
-    public void setItalic(boolean aBool)
-    {
-        italic = aBool;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;encoding&quot;, encoding);
+			// Flash 7
+			Transform.append(buffer, &quot;small&quot;, small);
+			// End Flash 7
+			Transform.append(buffer, &quot;italic&quot;, italic);
+			Transform.append(buffer, &quot;bold&quot;, bold);
+			Transform.append(buffer, &quot;language&quot;, language);
+			Transform.append(buffer, &quot;name&quot;, name);
+			Transform.append(buffer, &quot;codes&quot;, codes, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the font is bold.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param aBool a boolean flag indicating whether the font will be rendered in bold face.
-        */
-    public void setBold(boolean aBool)
-    {
-        bold = aBool;
-    }
+		length += 4;
+		length += coder.strlen(name, false);
+		length += 1;
+		length += codes.size() * 2;
 
-    /** Sets the language code used to determine the position of line-breaks in text rendered using the font.
-    
-        The language attribute is ignored if the object is encoded in a Flash 5 movie.
+		return length;
+	}
 
-        @param code the code identifying the spoken language either Latin, Japanese, Korean, SimplifiedChinese or TraditionalChinese.
-        */
-    public void setLanguage(int code)
-    {
-        language = code;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Sets the array of character codes.
+		coder.writeWord(identifier, 2);
+		coder.writeWord(coder.strlen(name, false), 1);
+		coder.writeString(name);
+		coder.writeBits(0, 2);
+		coder.writeBits(small ? 1 : 0, 1);
+		coder.writeBits(encoding, 2);
+		coder.writeBits(italic ? 1 : 0, 1);
+		coder.writeBits(bold ? 1 : 0, 1);
+		coder.writeBits(1, 1);
+		coder.writeWord(language, 1);
 
-        @param anArray the array mapping glyphs to particular character codes. The ordinal position of a character code in the array identifies the index of the corresponding glyph in the FSDefineFont object.
-        */
-    public void setCodes(ArrayList anArray)
-    {
-        codes = anArray;
-    }
+		for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
+			coder.writeWord(((Integer) codesIterator.next()).intValue(), 2);
 
-    public Object clone()
-    {
-        FSFontInfo2 anObject = (FSFontInfo2)super.clone();
-        
-        anObject.codes = new ArrayList();
-            
-        for (Iterator i = codes.iterator(); i.hasNext();)
-            anObject.codes.add(new Integer(((Integer)i.next()).intValue()));
+		coder.endObject(name());
+	}
 
-        return anObject;
-    }
+	public void decode(FSCoder coder)
+	{
+		int nameLength = 0;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSFontInfo2 typedObject = (FSFontInfo2)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; encoding == typedObject.encoding;
-            result = result &amp;&amp; small == typedObject.small;
-            result = result &amp;&amp; italic == typedObject.italic;
-            result = result &amp;&amp; bold == typedObject.bold;
-            result = result &amp;&amp; language == typedObject.language;
+		codes = new ArrayList();
 
-            if (name != null)
-                result = result &amp;&amp; name.equals(typedObject.name);
-            else
-                result = result &amp;&amp; name == typedObject.name;
+		super.decode(coder);
 
-            if (codes != null)
-                result = result &amp;&amp; codes.equals(typedObject.codes);
-            else
-                result = result &amp;&amp; codes == typedObject.codes;
-        }
-        return result;
-    }
+		identifier = coder.readWord(2, false);
+		nameLength = coder.readWord(1, false);
+		name = coder.readString(nameLength);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;encoding&quot;, encoding);
-// Flash 7
-            Transform.append(buffer, &quot;small&quot;, small);
-// End Flash 7
-            Transform.append(buffer, &quot;italic&quot;, italic);
-            Transform.append(buffer, &quot;bold&quot;, bold);
-            Transform.append(buffer, &quot;language&quot;, language);
-            Transform.append(buffer, &quot;name&quot;, name);
-            Transform.append(buffer, &quot;codes&quot;, codes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (name.length() &gt; 0)
+		{
+			while (name.charAt(name.length() - 1) == 0)
+			{
+				name = name.substring(0, name.length() - 1);
+			}
+		}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        length += coder.strlen(name, false);
-        length += 1;
-        length += codes.size()*2;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {    
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        coder.writeWord(coder.strlen(name, false), 1);
-        coder.writeString(name);
-        coder.writeBits(0, 2);
-        coder.writeBits(small ? 1 : 0, 1);
-        coder.writeBits(encoding, 2);
-        coder.writeBits(italic ? 1 : 0, 1);
-        coder.writeBits(bold ? 1 : 0, 1);
-        coder.writeBits(1, 1);
-        coder.writeWord(language, 1);
-    
-        for (Iterator codesIterator = codes.iterator(); codesIterator.hasNext();)
-            coder.writeWord(((Integer)codesIterator.next()).intValue(), 2);    
+		/* reserved */coder.readBits(2, false);
+		small = coder.readBits(1, false) != 0 ? true : false;
+		encoding = coder.readBits(2, false);
+		italic = coder.readBits(1, false) != 0 ? true : false;
+		bold = coder.readBits(1, false) != 0 ? true : false;
+		/* containsWideCodes */coder.readBits(1, false);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int nameLength = 0;
-        
-        codes = new ArrayList();
-        
-         super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        nameLength = coder.readWord(1, false);
-        name = coder.readString(nameLength);
+		int bytesRead = 4 + nameLength + 1;
 
-        if (name.length() &gt; 0)
-        {
-            while (name.charAt(name.length()-1) == 0) {
-            	name = name.substring(0, name.length()-1);
-            }
-        }
-        
-        /* reserved */ coder.readBits(2, false);
-        small = coder.readBits(1, false) != 0 ? true : false;
-        encoding = coder.readBits(2, false);
-        italic = coder.readBits(1, false) != 0 ? true : false;
-        bold = coder.readBits(1, false) != 0 ? true : false;
-        /* containsWideCodes */ coder.readBits(1, false);
+		language = coder.readWord(1, false);
 
-        int bytesRead = 4 + nameLength + 1;
+		while (bytesRead &lt; length)
+		{
+			codes.add(new Integer(coder.readWord(2, false)));
+			bytesRead += 2;
+		}
 
-        language = coder.readWord(1, false);
-
-        while (bytesRead &lt; length)
-        {
-            codes.add(new Integer(coder.readWord(2, false)));
-            bytesRead += 2;
-        }
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSFrame.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFrame.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSFrame.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,291 +30,304 @@
 
 package com.flagstone.transform;
 
-
 import java.util.*;
 import com.flagstone.transform.*;
 
-/** 
- * The Frame class is used to provide a higher level view of a movie. Rather 
- * than viewing movies as a sequence of individual objects each representing a 
- * given data structure in the encoded Flash file, objects can be grouped together 
- * in frames which presents a more logical view of a movie and makes movie
- * manipulation and search for specific objects easier to handle.
+/**
+ * The Frame class is used to provide a higher level view of a movie. Rather
+ * than viewing movies as a sequence of individual objects each representing a
+ * given data structure in the encoded Flash file, objects can be grouped
+ * together in frames which presents a more logical view of a movie and makes
+ * movie manipulation and search for specific objects easier to handle.
  * 
  * Each Frame object has the following attributes:
- *
+ * 
  * number - The position in the movie when the frame will be displayed.
  * 
- * label - An optional name assigned to a frame. The FSGotoFrame2 object can 
- * be used to move to a named frame when playing a movie or movie clip.
+ * label - An optional name assigned to a frame. The FSGotoFrame2 object can be
+ * used to move to a named frame when playing a movie or movie clip.
  * 
- * definitions - An array containing objects that define items for display in a 
- * movie. Definitions are sub-classes of the FSDefineObject class and define shapes, 
- * fonts, images and sounds that are displayed or played by the Flash Player.
- *
- * commands - An array containing objects that define commands that affect the 
+ * definitions - An array containing objects that define items for display in a
+ * movie. Definitions are sub-classes of the FSDefineObject class and define
+ * shapes, fonts, images and sounds that are displayed or played by the Flash
+ * Player.
+ * 
+ * commands - An array containing objects that define commands that affect the
  * display list or the Flash Player directly.
  * 
- * actions - An array that define actions that are executed when a frame is displayed.
- *
- * Frame objects simplify the handling of movies. FSDoAction, FSFrameLabel and 
- * FSShowFrame classes can now &quot;hidden&quot; from view. They are generated automatically 
- * by the FSFrame object when it is added to an FSMovie object.
+ * actions - An array that define actions that are executed when a frame is
+ * displayed.
  * 
- * The framesFromMovie(FSMovie aMovie) method allows an existing movie to be 
- * viewed as an array of FSFrame objects. Objects from the movie are copied into 
- * each frame so changes made to the attributes of each object are reflected 
- * in the movie. The frame objects are not synchronised with the movie, so any 
- * objects added to a frame are not added to the FSMovie. The easiest way to do 
+ * Frame objects simplify the handling of movies. FSDoAction, FSFrameLabel and
+ * FSShowFrame classes can now &quot;hidden&quot; from view. They are generated
+ * automatically by the FSFrame object when it is added to an FSMovie object.
+ * 
+ * The framesFromMovie(FSMovie aMovie) method allows an existing movie to be
+ * viewed as an array of FSFrame objects. Objects from the movie are copied into
+ * each frame so changes made to the attributes of each object are reflected in
+ * the movie. The frame objects are not synchronised with the movie, so any
+ * objects added to a frame are not added to the FSMovie. The easiest way to do
  * this is to remove the existing objects from the movie and add all the frames.
- *
- * ArrayList frames = FSFrame.framesFromMovie(aMovie);
- * ...
- * ...
+ * 
+ * ArrayList frames = FSFrame.framesFromMovie(aMovie); ... ...
  * aMovie.getObjects().clear();
- *   
+ * 
  * for (Iterator i = frames.iterator(); i.hasNext();)
- *     ((FSFrame)i.next()).addToMovie(aMovie);
- *
- * When the contents of an FSFrame object is added to a movie if a label defined 
- * then an FSFrameLabel object will be added. Similarly if actions are defined 
- * then an FSDoAction object will be added. An FSShowFrame object which instructs
- * the Flash Player to update the display list with all the changes is added.
- *
+ * ((FSFrame)i.next()).addToMovie(aMovie);
+ * 
+ * When the contents of an FSFrame object is added to a movie if a label defined
+ * then an FSFrameLabel object will be added. Similarly if actions are defined
+ * then an FSDoAction object will be added. An FSShowFrame object which
+ * instructs the Flash Player to update the display list with all the changes is
+ * added.
+ * 
  */
 public final class FSFrame
 {
-    /** 
-     * Create a frame based view of a movie. Objects from the movie are grouped 
-     * into Frame objects. Objects from the movie are added to the frame so any 
-     * changes made are reflected in the movie. However objects added or removed 
-     * from a frame are not reflected in the movie.
-     * 
-     * @param aMovie an FSMovie object.
-     * @return an array of Frame objects.
-     */
-    public static ArrayList framesFromMovie(FSMovie aMovie)
-    {
-        ArrayList frames = new ArrayList();
+	/**
+	 * Create a frame based view of a movie. Objects from the movie are grouped
+	 * into Frame objects. Objects from the movie are added to the frame so any
+	 * changes made are reflected in the movie. However objects added or removed
+	 * from a frame are not reflected in the movie.
+	 * 
+	 * @param aMovie
+	 *            an FSMovie object.
+	 * @return an array of Frame objects.
+	 */
+	public static ArrayList framesFromMovie(FSMovie aMovie)
+	{
+		ArrayList frames = new ArrayList();
 
-        FSFrame currentFrame = new FSFrame();
- 
-        for (Iterator i = aMovie.getObjects().iterator(); i.hasNext();)
-        {
-            FSMovieObject currentObject = (FSMovieObject)i.next();
-            
-            if (currentObject instanceof FSDoAction)
-            {
-                currentFrame.actions = ((FSDoAction)currentObject).getActions();
-            }
-            else if (currentObject instanceof FSFrameLabel)
-            {
-                currentFrame.label = ((FSFrameLabel)currentObject).getLabel();
-            }
-            else if (currentObject instanceof FSDefineObject)
-            {
-                currentFrame.addDefinition((FSDefineObject)currentObject);
-            }
-			else if (currentObject instanceof FSShowFrame)
+		FSFrame currentFrame = new FSFrame();
+
+		for (Iterator i = aMovie.getObjects().iterator(); i.hasNext();)
+		{
+			FSMovieObject currentObject = (FSMovieObject) i.next();
+
+			if (currentObject instanceof FSDoAction)
 			{
-                frames.add(currentFrame);
-                currentFrame = new FSFrame();
+				currentFrame.actions = ((FSDoAction) currentObject)
+								.getActions();
+			} else if (currentObject instanceof FSFrameLabel)
+			{
+				currentFrame.label = ((FSFrameLabel) currentObject).getLabel();
+			} else if (currentObject instanceof FSDefineObject)
+			{
+				currentFrame.addDefinition((FSDefineObject) currentObject);
+			} else if (currentObject instanceof FSShowFrame)
+			{
+				frames.add(currentFrame);
+				currentFrame = new FSFrame();
+			} else
+			{
+				currentFrame.addCommand(currentObject);
 			}
-            else
-            {
-                currentFrame.addCommand(currentObject);
-            }   
-        }
-        return frames;
-     }    
+		}
+		return frames;
+	}
 
-    private String label = null;
-    private ArrayList definitions = null;
-    private ArrayList commands = null;
-    private ArrayList actions = null;
+	private String label = null;
 
-    /** 
-     * Constructs an empty frame with no label defined and the definitions, 
-     * commands and actions arrays empty.
-     */
-    public FSFrame()
-    {
-        definitions = new ArrayList();
-        commands = new ArrayList();
-        actions = new ArrayList();
-    }
+	private ArrayList definitions = null;
 
-    /** 
-     * Constructs a frame with with the specified label, definitions, commands
-     * and actions. The label is optional and may be set to null if no label is 
-     * defined. Similarly if no definitions, commands or actions are defined for 
-     * a given frame then the corresponding argument may be set to null.
-     * 
-     * @param label a label for the frame. Maybe null if no label is defined.
-     * 
-     * @param definitions an array of definition objects. Maybe null if no 
-     * definitions are defined.
-     * 
-     * @param commands an array of objects used to manipulate the display list. 
-     * Maybe null if no display list commands are defined.
-     * 
-     * @param actions an array of action objects that will be executed when the 
-     * frame is displayed. Maybe null if no actions are defined.
-     */
-    public FSFrame(String label, ArrayList definitions, ArrayList commands, ArrayList actions)
-    {
-        setLabel(label);
-        setDefinitions(definitions);
-        setCommands(commands);
-        setActions(actions);
-    }
+	private ArrayList commands = null;
 
-    /** 
-     * Adds the action object to the frame.
-     * 
-     * @param anObject the action object to be added to the frame.
-     */
-    public void addAction(FSActionObject anObject)
-    {
-    	if (actions == null)
-    		actions = new ArrayList();
-    		
-        actions.add(anObject);
-    }
+	private ArrayList actions = null;
 
-    /** 
-     * Adds an object to the frame that defines an object to be displayed in the 
-     * movie.
-     * 
-     * @param anObject a sub-class of FSDefineObject.
-     */
-    public void addDefinition(FSDefineObject anObject)
-    {
+	/**
+	 * Constructs an empty frame with no label defined and the definitions,
+	 * commands and actions arrays empty.
+	 */
+	public FSFrame()
+	{
+		definitions = new ArrayList();
+		commands = new ArrayList();
+		actions = new ArrayList();
+	}
+
+	/**
+	 * Constructs a frame with with the specified label, definitions, commands
+	 * and actions. The label is optional and may be set to null if no label is
+	 * defined. Similarly if no definitions, commands or actions are defined for
+	 * a given frame then the corresponding argument may be set to null.
+	 * 
+	 * @param label
+	 *            a label for the frame. Maybe null if no label is defined.
+	 * 
+	 * @param definitions
+	 *            an array of definition objects. Maybe null if no definitions
+	 *            are defined.
+	 * 
+	 * @param commands
+	 *            an array of objects used to manipulate the display list. Maybe
+	 *            null if no display list commands are defined.
+	 * 
+	 * @param actions
+	 *            an array of action objects that will be executed when the
+	 *            frame is displayed. Maybe null if no actions are defined.
+	 */
+	public FSFrame(String label, ArrayList definitions, ArrayList commands,
+					ArrayList actions)
+	{
+		setLabel(label);
+		setDefinitions(definitions);
+		setCommands(commands);
+		setActions(actions);
+	}
+
+	/**
+	 * Adds the action object to the frame.
+	 * 
+	 * @param anObject
+	 *            the action object to be added to the frame.
+	 */
+	public void addAction(FSActionObject anObject)
+	{
+		if (actions == null)
+			actions = new ArrayList();
+
+		actions.add(anObject);
+	}
+
+	/**
+	 * Adds an object to the frame that defines an object to be displayed in the
+	 * movie.
+	 * 
+	 * @param anObject
+	 *            a sub-class of FSDefineObject.
+	 */
+	public void addDefinition(FSDefineObject anObject)
+	{
 		if (definitions == null)
 			definitions = new ArrayList();
-    		
-        definitions.add(anObject);
-    }
 
-    /** 
-     * Adds the display list command to the frame.
-     * 
-     * @param anObject an FSMovieObject the manipulates the display list.
-     */
-    public void addCommand(FSMovieObject anObject)
-    {
-        commands.add(anObject);
-    }
+		definitions.add(anObject);
+	}
 
-    /** 
-     * Gets the label assigned to the frame.
-     * 
-     * @return the label.
-     */
-    public String getLabel()
-    {
-        return label;
-    }
+	/**
+	 * Adds the display list command to the frame.
+	 * 
+	 * @param anObject
+	 *            an FSMovieObject the manipulates the display list.
+	 */
+	public void addCommand(FSMovieObject anObject)
+	{
+		commands.add(anObject);
+	}
 
-    /** 
-     * Gets the array of definition objects contained in the frame.
-     * 
-     * @return the array of definitions.
-     */
-    public ArrayList getDefinitions()
-    {
-        return definitions;
-    }
+	/**
+	 * Gets the label assigned to the frame.
+	 * 
+	 * @return the label.
+	 */
+	public String getLabel()
+	{
+		return label;
+	}
 
-    /**
-     * Gets the array of commands that update the display list. 
-     * 
-     * @return the array of commands objects.
-     */
-    public ArrayList getCommands()
-    {
-        return commands;
-    }
+	/**
+	 * Gets the array of definition objects contained in the frame.
+	 * 
+	 * @return the array of definitions.
+	 */
+	public ArrayList getDefinitions()
+	{
+		return definitions;
+	}
 
-    /**
-     * Gets the array of action objects that will be execute when the frame is 
-     * displayed.
-     * 
-     * @return the array of actions defined for the frame.
-     */
-    public ArrayList getActions()
-    {
-        return actions;
-    }
-    
-    /** 
-     * Sets the label for the frame.
-     * 
-     * @param aString the label.
-     */
-    public void setLabel(String aString)
-    {
-    	label = aString;
-    }
+	/**
+	 * Gets the array of commands that update the display list.
+	 * 
+	 * @return the array of commands objects.
+	 */
+	public ArrayList getCommands()
+	{
+		return commands;
+	}
 
-    /** 
-     * Sets the array of action objects for the frame.
-     * 
-     * @param anArray the array of actions.
-     */
-    public void setDefinitions(ArrayList anArray)
-    {
-        definitions = anArray;
-    }
+	/**
+	 * Gets the array of action objects that will be execute when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of actions defined for the frame.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-    /** 
-     * Sets the array of commands that updated the display list for the frame. 
-     * The changes are visible when the frame is displayed.
-     *
-     * @param anArray the array of command objects.
-     */
-    public void setCommands(ArrayList anArray)
-    {
-        commands = anArray;
-    }
+	/**
+	 * Sets the label for the frame.
+	 * 
+	 * @param aString
+	 *            the label.
+	 */
+	public void setLabel(String aString)
+	{
+		label = aString;
+	}
 
-    /** 
-     * Sets the array of action objects for the frame.
-     * 
-     * @param anArray the array of actions.
-     */
-    public void setActions(ArrayList anArray)
-    {
-    	actions = anArray;
-    }
+	/**
+	 * Sets the array of action objects for the frame.
+	 * 
+	 * @param anArray
+	 *            the array of actions.
+	 */
+	public void setDefinitions(ArrayList anArray)
+	{
+		definitions = anArray;
+	}
 
-    /** 
-     * Add the objects in the frame to the movie. The contents of the definitions 
-     * and commands arrays are added to the movie. If a label is assigned to the 
-     * frame then an FSFrameLabel object is added to the movie. If actions are 
-     * defined then an FSDoAction object is added containing the actions defined 
-     * in the frame. 
-     * 
-     * @param aMovie an FSMovie object.
-     */
-    public void addToMovie(FSMovie aMovie)
-    {
-    	if (definitions != null || definitions.size() &gt; 0)
-    	{
+	/**
+	 * Sets the array of commands that updated the display list for the frame.
+	 * The changes are visible when the frame is displayed.
+	 * 
+	 * @param anArray
+	 *            the array of command objects.
+	 */
+	public void setCommands(ArrayList anArray)
+	{
+		commands = anArray;
+	}
+
+	/**
+	 * Sets the array of action objects for the frame.
+	 * 
+	 * @param anArray
+	 *            the array of actions.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
+
+	/**
+	 * Add the objects in the frame to the movie. The contents of the
+	 * definitions and commands arrays are added to the movie. If a label is
+	 * assigned to the frame then an FSFrameLabel object is added to the movie.
+	 * If actions are defined then an FSDoAction object is added containing the
+	 * actions defined in the frame.
+	 * 
+	 * @param aMovie
+	 *            an FSMovie object.
+	 */
+	public void addToMovie(FSMovie aMovie)
+	{
+		if (definitions != null || definitions.size() &gt; 0)
+		{
 			for (Iterator i = definitions.iterator(); i.hasNext();)
-				aMovie.add((FSMovieObject)i.next());
-    	}
-            
-        if (label != null &amp;&amp; label.length() &gt; 0)
-            aMovie.add(new FSFrameLabel(label));
+				aMovie.add((FSMovieObject) i.next());
+		}
 
+		if (label != null &amp;&amp; label.length() &gt; 0)
+			aMovie.add(new FSFrameLabel(label));
+
 		if (actions != null &amp;&amp; actions.size() &gt; 0)
 			aMovie.add(new FSDoAction(actions));
 
-        for (Iterator j = commands.iterator(); j.hasNext();)
-            aMovie.add((FSMovieObject)j.next());
-            
-        aMovie.add(new FSShowFrame());
-    }
+		for (Iterator j = commands.iterator(); j.hasNext();)
+			aMovie.add((FSMovieObject) j.next());
+
+		aMovie.add(new FSShowFrame());
+	}
 }
-

Modified: trunk/src/com/flagstone/transform/FSFrameLabel.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFrameLabel.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSFrameLabel.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -34,306 +34,382 @@
 import java.util.Iterator;
 
 /**
-FSFrameLabel defines a name for the current frame in a movie or movie clip.
+ * FSFrameLabel defines a name for the current frame in a movie or movie clip.
+ * 
+ * &lt;p&gt;
+ * The name can be referenced from other objects such as FSGotoFrame2 to
+ * simplify the creation of scripts to control movies by using a predefined name
+ * rather than the frame number. The label assigned to a particular frame should
+ * be unique. Frames may also be reference externally when specifying the movie
+ * to play using a URL - similar to the way names links are used in HTML. When
+ * the Flash Player loaded a movie it will begin playing at the frame specified
+ * in the URL.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;label&lt;/td&gt;
+ * &lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;isAnchor&lt;/td&gt;
+ * &lt;td&gt;Will the label be used as an anchor.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The name is assigned to a particular frame when the FSFrameLabel object is
+ * defined prior to the FSShowFrame object that displays all the objects on the
+ * display list. The frame can then be referenced by its name once it has been
+ * defined. A frame cannot be referenced before the Player has loaded and
+ * displayed the frame that contains the corresponding FSFrameLabel object.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following simplified code samples illustrate how to use the FSFrameLabel
+ * class to refer to a frame by its name rather than a number.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Using the FSFrameLabel object.&lt;br/&gt; This examples uses the FSFrameLabel
+ * object to allow the movie to loop back and replay an animation starting at a
+ * named frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  movie.add(new FSFrameLabel(&quot;Frame Name&quot;));
+ *  ...
+ *  movie.add(new FSShowFrame());
+ * 
+ *  ...
+ * 
+ *  FSDoAction frameAction = new FSDoAction();
+ * 
+ *  frameAction.add(new FSPush(&quot;FirstFrame&quot;));
+ *  frameAction.add(new FSGotoFrame2(false));
+ * 
+ *  movie.add(frameAction);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Controlling a movie clip.&lt;br/&gt; The FSFrameLabel object can also be used
+ * to control the time-line of a movie clip. In this case though the mechanism
+ * is slightly different. From Flash 5 onward movie clips are defined as
+ * objects. The ExecuteMethod action is used to execute the gotoAndPlay() or
+ * gotoAndStop() methods that control a movie clip's time-line:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // First define the commands that animate the movie clip.
+ *  ArrayList commands = new ArrayList();
+ *  ...
+ *  commands.add(new FSFrameLabel(&quot;Frame Name&quot;));
+ *  commands.add(new FSShowFrame());
+ * 
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  // Add the movie clip to the display list on layer 1 at (400, 400). Give it the name
+ *  // &quot;movieClip&quot; to allow it to be referenced later.
+ * 
+ *  movie.add(movieClip);
+ *  movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, &quot;movieClip&quot;, 400, 400));
+ * 
+ *  // Create the FSDoAction object that will start the movie clip playing.
+ * 
+ *  FSDoAction clipActions = new FSDoAction();
+ * 
+ *  // Movie clips objects can be controlled by executing pre-defined methods.
+ * 
+ *  // Define the arguments followed by their number for the gotoAndPlay method.
+ * 
+ *  clipActions.add(new FSPush(&quot;Frame Name&quot;));
+ *  clipActions.add(new FSPush(1));
+ * 
+ *  // Get the movie clip object using its name. It's location is specified relative to the &quot;_root&quot;
+ *  // level which represents the main time-line of the movie.
+ * 
+ *  clipActions.add(new FSPush(&quot;_root&quot;));
+ *  clipActions.add(new FSPush(&quot;movieClip&quot;));
+ *  clipActions.add(FSAction.GetAttribute());
+ * 
+ *  actions.add(new FSPush(&quot;gotoAndPlay&quot;));
+ *  actions.add(FSAction.ExecuteMethod());
+ * 
+ *  movie.add(clipActions);
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Defining an anchored frame.&lt;br/&gt; Specifying a frame name as an anchor
+ * allows a movie start playing from any frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Define the anchored frame in a movie.
+ *  movie.add(new FSFrameLabel(&quot;StartHere&quot;, true));
+ *  movie.add(new FSShowFrame());
+ *  ....
+ *  movie.encodeToFile(&quot;movie.swf&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To start playing the movie at the frame labeled &quot;StartHere&quot; specify the label
+ * using the same format a HTML anchors:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  <A HREF="http://www.flagstonesoftware.com/flash/movie.swf#StartHere">http://www.flagstonesoftware.com/flash/movie.swf#StartHere</A>
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This may be used either in a browser window to load a file or form within a
+ * movie using the FSGetUrl or FSGetUrl2 actions.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFrameLabel class represents the FrameLabel tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3. In Flash
+ * 6 the label can support named anchors which allows a frame to be specified as
+ * the starting point when displaying a Flash movie in a web browser.
+ * &lt;/p&gt;
+ */
+public class FSFrameLabel extends FSMovieObject
+{
+	private String label = null;
 
-&lt;p&gt;The name can be referenced from other objects such as FSGotoFrame2 to simplify the creation of scripts to control movies by using a predefined name rather than the frame number. The label assigned to a particular frame should be unique. Frames may also be reference externally when specifying the movie to play using a URL - similar to the way names links are used in HTML. When the Flash Player loaded a movie it will begin playing at the frame specified in the URL.&lt;/p&gt;
+	// Flash 6
+	private boolean anchor = false;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	// End Flash 6
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	FSFrameLabel()
+	{
+		super(FrameLabel);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFrameLabel_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSFrameLabel object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFrameLabel(FSCoder coder)
+	{
+		super(FrameLabel);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFrameLabel_1&quot;&gt;label&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSFrameLabel object with the specified name.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 */
+	public FSFrameLabel(String aString)
+	{
+		super(FrameLabel);
+		setLabel(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFrameLabel_2&quot;&gt;isAnchor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Will the label be used as an anchor.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 6
+	/**
+	 * Constructs an FSFrameLabel object with the specified name. If the
+	 * isAnchor flag is true then the frame will be directly selectable by a URL
+	 * and the Flash Player will begin playing the movie at the specified frame.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 * @param isAnchor
+	 *            if true the name will be used as an anchor when referencing
+	 *            the frame in a URL.
+	 */
+	public FSFrameLabel(String aString, boolean isAnchor)
+	{
+		super(FrameLabel);
+		setLabel(aString);
+		setAnchor(isAnchor);
+	}
 
-&lt;/table&gt;
+	// End Flash 6
+	/**
+	 * Constructs an FSFrameLabel object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSFrameLabel object.
+	 */
+	public FSFrameLabel(FSFrameLabel obj)
+	{
+		super(obj);
+		label = new String(label);
+		anchor = obj.anchor;
+	}
 
-&lt;p&gt;The name is assigned to a particular frame when the FSFrameLabel object is defined prior to the FSShowFrame object that displays all the objects on the display list. The frame can then be referenced by its name once it has been defined. A frame cannot be referenced before the Player has loaded and displayed the frame that contains the corresponding FSFrameLabel object.&lt;/p&gt;
+	/**
+	 * Gets the label.
+	 * 
+	 * @return the string defining the label.
+	 */
+	public String getLabel()
+	{
+		return label;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the label.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 */
+	public void setLabel(String aString)
+	{
+		label = aString;
+	}
 
-&lt;p&gt;The following simplified code samples illustrate how to use the FSFrameLabel class to refer to a frame by its name rather than a number.&lt;/P&gt;
+	// Flash 6
+	/**
+	 * Sets the label defining whether it will be referenced as an anchor or
+	 * not.
+	 * 
+	 * @param aString
+	 *            the string that defines the label that will be assigned to the
+	 *            current frame.
+	 * @param isAnchor
+	 *            if true the name will be used as an anchor when referencing
+	 *            the frame in a URL.
+	 */
+	public void setLabel(String aString, boolean isAnchor)
+	{
+		label = aString;
+		anchor = isAnchor;
+	}
 
-&lt;p&gt;1. Using the FSFrameLabel object.&lt;br/&gt;
-This examples uses the FSFrameLabel object to allow the movie to loop back and replay an animation starting at a named frame.&lt;/p&gt;
+	/**
+	 * Gets the flag indicating whether the frame name is also used as an anchor
+	 * so the frame can be referenced from outside of the movie.
+	 * 
+	 * @return true if the frame is an anchor frame, false otherwise.
+	 */
+	public boolean getAnchor()
+	{
+		return anchor;
+	}
 
-&lt;pre&gt;
-movie.add(new FSFrameLabel(&quot;Frame Name&quot;));
-...
-movie.add(new FSShowFrame());
+	/**
+	 * Sets the flag indicating whether the frame name is also used as an anchor
+	 * so the frame can be referenced from outside of the movie.
+	 * 
+	 * @param isAnchor
+	 *            true if the frame is an anchor frame, false otherwise.
+	 */
+	public void setAnchor(boolean isAnchor)
+	{
+		anchor = isAnchor;
+	}
 
-...
+	// Flash 6
 
-FSDoAction frameAction = new FSDoAction();
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-frameAction.add(new FSPush(&quot;FirstFrame&quot;));
-frameAction.add(new FSGotoFrame2(false));
+		if (super.equals(anObject))
+		{
+			FSFrameLabel typedObject = (FSFrameLabel) anObject;
 
-movie.add(frameAction);
+			if (label != null)
+				result = label.equals(typedObject.label);
+			else
+				result = typedObject.label == null;
 
-&lt;/pre&gt;
+			// Flash 6
+			result = result &amp;&amp; anchor == typedObject.anchor;
+			// Flash 7
+		}
+		return result;
+	}
 
-&lt;p&gt;2. Controlling a movie clip.&lt;br/&gt;
-The FSFrameLabel object can also be used to control the time-line of a movie clip. In this case though the mechanism is slightly different. From Flash 5 onward movie clips are defined as objects. The ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop() methods that control a movie clip's time-line:&lt;/p&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;pre&gt;
-// First define the commands that animate the movie clip.
-ArrayList commands = new ArrayList();
-...
-commands.add(new FSFrameLabel(&quot;Frame Name&quot;));
-commands.add(new FSShowFrame());
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;label&quot;, label);
+			// Flash 6
+			Transform.append(buffer, &quot;anchor&quot;, anchor);
+			// End Flash 6
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-// Add the movie clip to the display list on layer 1 at (400, 400). Give it the name
-// &quot;movieClip&quot; to allow it to be referenced later.
+		length += coder.strlen(label, true);
 
-movie.add(movieClip);
-movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, &quot;movieClip&quot;, 400, 400));
+		// Flash 6
+		length += anchor ? 1 : 0;
+		// End Flash 6
 
-// Create the FSDoAction object that will start the movie clip playing.
+		return length;
+	}
 
-FSDoAction clipActions = new FSDoAction();
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeString(label);
+		coder.writeWord(0, 1);
 
-// Movie clips objects can be controlled by executing pre-defined methods.
+		// Flash 6
+		if (anchor)
+			coder.writeWord(1, 1);
+		// End Flash 6
+		coder.endObject(name());
+	}
 
-// Define the arguments followed by their number for the gotoAndPlay method.
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-clipActions.add(new FSPush(&quot;Frame Name&quot;));
-clipActions.add(new FSPush(1));
+		int start = coder.getPointer();
+		int strlen = 0;
 
-// Get the movie clip object using its name. It's location is specified relative to the &quot;_root&quot;
-// level which represents the main time-line of the movie.
+		for (strlen = 0; coder.scanWord(1, false) != 0; coder.adjustPointer(8), strlen++)
+			;
 
-clipActions.add(new FSPush(&quot;_root&quot;));
-clipActions.add(new FSPush(&quot;movieClip&quot;));
-clipActions.add(FSAction.GetAttribute());
+		coder.setPointer(start);
+		label = coder.readString(strlen++);
+		coder.adjustPointer(8);
 
-actions.add(new FSPush(&quot;gotoAndPlay&quot;));
-actions.add(FSAction.ExecuteMethod());
+		// Flash 6
+		if (strlen &lt; length)
+			anchor = coder.readWord(1, false) != 0 ? true : false;
+		// End Flash 6
 
-movie.add(clipActions);
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;3. Defining an anchored frame.&lt;br/&gt;
-Specifying a frame name as an anchor allows a movie start playing from any frame.&lt;/p&gt;
-
-&lt;pre&gt;
-// Define the anchored frame in a movie.
-movie.add(new FSFrameLabel(&quot;StartHere&quot;, true));
-movie.add(new FSShowFrame());
-....
-movie.encodeToFile(&quot;movie.swf&quot;);
-&lt;/pre&gt;
-
-&lt;p&gt;To start playing the movie at the frame labeled &quot;StartHere&quot; specify the label using the same format a HTML anchors:&lt;/p&gt;
-
-&lt;pre&gt;
-<A HREF="http://www.flagstonesoftware.com/flash/movie.swf#StartHere">http://www.flagstonesoftware.com/flash/movie.swf#StartHere</A>
-&lt;/pre&gt;
-
-&lt;p&gt;This may be used either in a browser window to load a file or form within a movie using the FSGetUrl or FSGetUrl2 actions.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSFrameLabel class represents the FrameLabel tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3. In Flash 6 the label can support named anchors which allows a frame to be specified as the starting point when displaying a Flash movie in a web browser.&lt;/p&gt;
- */
-public class FSFrameLabel extends FSMovieObject
-{
-    private String label = null;
-// Flash 6
-    private boolean anchor = false;
-// End Flash 6
-
-    FSFrameLabel()
-    {
-        super(FrameLabel);
-    }
-
-    /**
-     * Construct an FSFrameLabel object, initalizing it with values decoded from
-     * an encoded object.
-     *
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFrameLabel(FSCoder coder)
-    {
-        super(FrameLabel);
-        decode(coder);
-    }
-    /** Constructs an FSFrameLabel object with the specified name.
-
-        @param aString the string that defines the label that will be assigned to the current frame.
-        */
-    public FSFrameLabel(String aString)
-    {
-        super(FrameLabel);
-        setLabel(aString);
-    }
-// Flash 6
-    /** Constructs an FSFrameLabel object with the specified name. If the isAnchor
-     *  flag is true then the frame will be directly selectable by a URL and the
-     *  Flash Player will begin playing the movie at the specified frame.
-     *
-     *  @param aString the string that defines the label that will be assigned to the current frame.
-     *  @param isAnchor if true the name will be used as an anchor when referencing the frame in a URL.
-     */
-    public FSFrameLabel(String aString, boolean isAnchor)
-    {
-        super(FrameLabel);
-        setLabel(aString);
-        setAnchor(isAnchor);
-    }
-// End Flash 6
-    /**
-     * Constructs an FSFrameLabel object by copying values from an existing
-     * object.
-     *
-     * @param obj an FSFrameLabel object.
-     */
-    public FSFrameLabel(FSFrameLabel obj)
-    {
-        super(obj);
-        label = new String(label);
-        anchor = obj.anchor;
-    }
-
-    /** Gets the label.
-
-        @return the string defining the label.
-        */
-    public String getLabel() { return label; }
-
-    /** Sets the label.
-
-        @param aString the string that defines the label that will be assigned to the current frame.
-        */
-    public void setLabel(String aString)
-    {
-        label = aString;
-    }
-
-// Flash 6
-    /** Sets the label defining whether it will be referenced as an anchor or not.
-     *
-     *  @param aString the string that defines the label that will be assigned to the current frame.
-     *  @param isAnchor if true the name will be used as an anchor when referencing the frame in a URL.
-     */
-    public void setLabel(String aString, boolean isAnchor)
-    {
-        label = aString;
-        anchor = isAnchor;
-    }
-
-    /** Gets the flag indicating whether the frame name is also used as an anchor
-     *  so the frame can be referenced from outside of the movie.
-     *
-     *  @return true if the frame is an anchor frame, false otherwise.
-     */
-    public boolean getAnchor() { return anchor; }
-
-    /** Sets the flag indicating whether the frame name is also used as an anchor
-     *  so the frame can be referenced from outside of the movie.
-     *
-     *  @param isAnchor true if the frame is an anchor frame, false otherwise.
-     */
-    public void setAnchor(boolean isAnchor)
-    {
-        anchor = isAnchor;
-    }
-// Flash 6
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-
-        if (super.equals(anObject))
-        {
-            FSFrameLabel typedObject = (FSFrameLabel)anObject;
-
-            if (label != null)
-                result = label.equals(typedObject.label);
-            else
-                result = typedObject.label == null;
-
-// Flash 6
-            result = result &amp;&amp;  anchor == typedObject.anchor;
-// Flash 7
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;label&quot;, label);
-// Flash 6
-            Transform.append(buffer, &quot;anchor&quot;, anchor);
-// End Flash 6
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += coder.strlen(label, true);
-
-// Flash 6
-        length += anchor ? 1 : 0;
-// End Flash 6
-
-        return length;
-    }
-
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeString(label);
-        coder.writeWord(0, 1);
-
-// Flash 6
-        if (anchor)
-            coder.writeWord(1, 1);
-// End Flash 6
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int start = coder.getPointer();
-        int strlen = 0;
-
-        for (strlen=0; coder.scanWord(1, false) != 0; coder.adjustPointer(8), strlen++);
-
-        coder.setPointer(start);
-        label = coder.readString(strlen++);
-        coder.adjustPointer(8);
-
-// Flash 6
-        if (strlen &lt; length)
-            anchor = coder.readWord(1, false) != 0 ? true : false;
-// End Flash 6
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSFree.java
===================================================================
--- trunk/src/com/flagstone/transform/FSFree.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSFree.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,121 +31,142 @@
 package com.flagstone.transform;
 
 /**
-FSFree deletes the object with the specified identifier, freeing up resources in the Flash Player.
+ * FSFree deletes the object with the specified identifier, freeing up resources
+ * in the Flash Player.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the object, in the range 1..65535, that will be
+ * deleted from the Flash Player's memory.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSFree class represents the FreeCharacter tag from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSFree extends FSMovieObject
+{
+	private int identifier = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSFree object, initializing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSFree(FSCoder coder)
+	{
+		super(Free);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSFree object with the specified identifier. The identifier
+	 * must be in the range 1..65535.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be deleted.
+	 */
+	public FSFree(int anIdentifier)
+	{
+		super(Free);
+		setIdentifier(anIdentifier);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFree_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSFree object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSFree object.
+	 */
+	public FSFree(FSFree obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSFree_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the object, in the range 1..65535, that will be deleted from the Flash Player's memory.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the object to be deleted.
+	 * 
+	 * @return the object's identifier.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the identifier of the object to be deleted. The identifier must be
+	 * in the range 1..65535.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be deleted.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSFree class represents the FreeCharacter tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSFree extends FSMovieObject
-{
-    private int identifier = 0;
-        
-    /**
-     * Construct an FSFree object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSFree(FSCoder coder)
-    {
-        super(Free);
-        decode(coder);
-    }
-    /** Constructs an FSFree object with the specified identifier. The identifier must be in the range 1..65535.
+		if (super.equals(anObject))
+		{
+			result = identifier == ((FSFree) anObject).getIdentifier();
+		}
+		return result;
+	}
 
-        @param anIdentifier the identifier of the object to be deleted.
-        */
-    public FSFree(int anIdentifier)
-    {
-        super(Free);
-        setIdentifier(anIdentifier);
-    }
-    /**
-     * Constructs an FSFree object by copying values from an existing object.
-     *
-     * @param obj an FSFree object.
-     */
-    public FSFree(FSFree obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-    }    
- 
-    /** Gets the identifier of the object to be deleted.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the object's identifier.
-        */
-    public int getIdentifier() { return identifier; }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the identifier of the object to be deleted. The identifier must be in the range 1..65535.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anIdentifier the identifier of the object to be deleted.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		length += 2;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            result = identifier == ((FSFree)anObject).getIdentifier();
-        }
-        return result;
-    }
+		return length;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(identifier, 2);
+		coder.endObject(name());
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += 2;
-            
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(identifier, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);        
-        identifier = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		identifier = coder.readWord(2, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSGetUrl.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGetUrl.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGetUrl.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,238 +31,305 @@
 package com.flagstone.transform;
 
 /**
-FSGetUrl is used to display a web page or load a movie clip into the Flash Player.
+ * FSGetUrl is used to display a web page or load a movie clip into the Flash
+ * Player.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a&gt;url&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The fully qualified uniform resource location where the movie clip or
+ * web page will be retrieved from.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;target&lt;/td&gt;
+ * &lt;td&gt;A level in the Flash Player where the movie clip will be loaded or frame
+ * or window in the browser where the web page will be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To display a web page or new Flash movie the target can either be the name of
+ * the web browser frame or one of the following reserved words:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the frame with the name defined in an HTML
+ * &lt;frame&gt; tag.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_blank&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in a new window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_self&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the current window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_top&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the top level frame of the current window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;_parent&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;opens the new page in the parent frame of the frame where the Flash
+ * Player id displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/td&gt;
+ * &lt;td&gt;(blank string) opens the new page in the current frame or window.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To load a movie clip into the currently playing movie then the target is a
+ * string literal of the form &quot;_level&lt;i&gt;n&lt;/i&gt;&quot;. The Flash Player supports the
+ * concept of virtual layers (analogous to the layers in the Display List).
+ * Higher levels are displayed in front of lower levels. The background of each
+ * level is transparent allowing movie clips on lower levels to be visible in
+ * areas not filled by the movie clip on a given level. The main movie is loaded
+ * into _level0. Movie clips are loaded into any level above this (1, 2, 124,
+ * etc.). If a movie clip is loaded into a level that already contains a movie
+ * clip then the existing clip is replaced by the new one.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a web page into the named frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;,">http://www.myserver.com/page.html&quot;,</A> &quot;myFrame&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a web page in a new window:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;,">http://www.myserver.com/page.html&quot;,</A> &quot;_blank&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a web page into the current window or
+ * frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;,">http://www.myserver.com/page.html&quot;,</A> &quot;&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * or
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html&amp;quot;">http://www.myserver.com/page.html&quot;</A>);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To create an action that will load a movie clip into the currently playing
+ * movie:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/movieClip.swf&amp;quot;,">http://www.myserver.com/movieClip.swf&quot;,</A>
+ * 				&quot;_level1&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGetUrl is a class for representing the ActionGetUrl action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSGetUrl extends FSActionObject
+{
+	private String url = null;
+	private String target = &quot;&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	FSGetUrl()
+	{
+		super(FSActionObject.GetUrl);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSGetUrl object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGetUrl(FSCoder coder)
+	{
+		super(FSActionObject.GetUrl);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGetUrl_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGetUrl with the specified url and target frame.
+	 * 
+	 * @param urlString
+	 *            a fully qualified URL.
+	 * @param targetString
+	 *            the location (in the Flash Player or web browser) where the
+	 *            contents of file retrieved via the url will be displayed.
+	 */
+	public FSGetUrl(String urlString, String targetString)
+	{
+		super(FSActionObject.GetUrl);
+		setUrl(urlString);
+		setTarget(targetString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl_1&quot;&gt;url&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The fully qualified uniform resource location where the movie clip or web page will be retrieved from.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGetUrl with the specified url. The target defaults to the
+	 * current window.
+	 * 
+	 * @param urlString
+	 *            a fully qualified URL.
+	 */
+	public FSGetUrl(String urlString)
+	{
+		super(FSActionObject.GetUrl);
+		setUrl(urlString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl_2&quot;&gt;target&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A level in the Flash Player where the movie clip will be loaded or frame or window in the browser where the web page will be displayed.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSGetUrl object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGetUrl object.
+	 */
+	public FSGetUrl(FSGetUrl obj)
+	{
+		super(obj);
+		url = new String(obj.url);
+		target = new String(obj.target);
+	}
 
-&lt;p&gt;To display a web page or new Flash movie the target can either be the name of the web browser frame or one of the following reserved words:&lt;/p&gt;
+	/**
+	 * Gets the URL.
+	 * 
+	 * @return the URL that web page or movie clip will be loaded from.
+	 */
+	public String getUrl()
+	{
+		return url;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Gets the name of the target frame.
+	 * 
+	 * @return the name of the location (in the Flash Player or web browser)
+	 *         where the web page or movie clip will be displayed.
+	 */
+	public String getTarget()
+	{
+		return target;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the frame with the name defined in an HTML &lt;frame&gt; tag.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the URL of the file to be retrieved.
+	 * 
+	 * @param aString
+	 *            a fully qualified URL.
+	 */
+	public void setUrl(String aString)
+	{
+		url = aString;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_blank&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in a new window.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the name of the Target where the URL will be displayed. The target
+	 * may be a frame or window in a web browser when displaying a web page or a
+	 * level in the current movie when loading a movie clip.
+	 * 
+	 * @param aString
+	 *            the name of the location (in the Flash Player or web browser)
+	 *            where contents of file retrieved via the url will be
+	 *            displayed.
+	 */
+	public void setTarget(String aString)
+	{
+		target = aString;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_self&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the current window.&lt;/td&gt;
-&lt;/tr&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_top&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the top level frame of the current window.&lt;/td&gt;
-&lt;/tr&gt;
+		if (super.equals(anObject))
+		{
+			FSGetUrl typedObject = (FSGetUrl) anObject;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;_parent&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;opens the new page in the parent frame of the frame where the Flash Player id displayed.&lt;/td&gt;
-&lt;/tr&gt;
+			result = url.equals(typedObject.url);
+			result = result &amp;&amp; target.equals(typedObject.target);
+		}
+		return result;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/td&gt;
-&lt;td&gt;(blank string) opens the new page in the current frame or window.&lt;/td&gt;
-&lt;/tr&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;/table&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;url&quot;, url);
+			Transform.append(buffer, &quot;target&quot;, target);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;To load a movie clip into the currently playing movie then the target is a string literal of the form &quot;_level&lt;i&gt;n&lt;/i&gt;&quot;. The Flash Player supports the concept of virtual layers (analogous to the layers in the Display List). Higher levels are displayed in front of lower levels. The background of each level is transparent allowing movie clips on lower levels to be visible in areas not filled by the movie clip on a given level. The main movie is loaded into _level0. Movie clips are loaded into any level above this (1, 2, 124, etc.). If a movie clip is loaded into a level that already contains a movie clip then the existing clip is replaced by the new one.&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		length += coder.strlen(url, true);
+		length += coder.strlen(target, true);
 
-&lt;p&gt;To create an action that will load a web page into the named frame:&lt;/p&gt;
+		return length;
+	}
 
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;, &quot;myFrame&quot;);
-&lt;/pre&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-&lt;p&gt;To create an action that will load a web page in a new window:&lt;/p&gt;
+		coder.writeString(url);
+		coder.writeWord(0, 1);
 
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;, &quot;_blank&quot;);
-&lt;/pre&gt;
+		coder.writeString(target);
+		coder.writeWord(0, 1);
+		coder.endObject(name());
+	}
 
-&lt;p&gt;To create an action that will load a web page into the current window or frame:&lt;/p&gt;
-
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;, &quot;&quot;);
-&lt;/pre&gt;
-
-&lt;p&gt;or&lt;/p&gt;
-
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/page.html">http://www.myserver.com/page.html</A>&quot;);
-&lt;/pre&gt;
-
-&lt;p&gt;To create an action that will load a movie clip into the currently playing movie:&lt;/p&gt;
-
-&lt;pre&gt;
-FSGetUrl anAction = new FSGetUrl(&quot;<A HREF="http://www.myserver.com/movieClip.swf">http://www.myserver.com/movieClip.swf</A>&quot;, &quot;_level1&quot;);
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSGetUrl is a class for representing the ActionGetUrl action of the Macromedia Flash (SWF) File Format Specification. It was introduced in  Flash 1.&lt;/p&gt;
- */
-public class FSGetUrl extends FSActionObject
-{
-    private String url = null;
-    private String target = &quot;&quot;;
-    
-    FSGetUrl()
-    {
-        super(FSActionObject.GetUrl);
-    }
-    /**
-     * Construct an FSGetUrl object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGetUrl(FSCoder coder)
-    {
-        super(FSActionObject.GetUrl);
-        decode(coder);
-    }
-    /** Constructs an FSGetUrl with the specified url and target frame. 
-
-        @param urlString a fully qualified URL.
-        @param targetString the location (in the Flash Player or web browser) where the contents of file retrieved via the url will be displayed.
-        */
-    public FSGetUrl(String urlString, String targetString)
-    {
-        super(FSActionObject.GetUrl);
-        setUrl(urlString);
-        setTarget(targetString);
-    }
-    /**  Constructs an FSGetUrl with the specified url. The target defaults to the current window. 
-
-        @param urlString a fully qualified URL.
-        */
-    public FSGetUrl(String urlString)
-    {
-        super(FSActionObject.GetUrl);
-        setUrl(urlString);
-    }
-    /**
-     * Constructs an FSGetUrl object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGetUrl object.
-     */
-    public FSGetUrl(FSGetUrl obj)
-    {
-        super(obj);
-        url = new String(obj.url);
-        target = new String(obj.target);
-    }    
-
-    /** Gets the URL. 
-
-        @return the URL that web page or movie clip will be loaded from.
-        */
-    public String getUrl() { return url; }
-
-    /** Gets the name of the target frame. 
-
-        @return the name of the location (in the Flash Player or web browser) where the web page or movie clip will be displayed.
-        */    
-    public String getTarget() { return target; }
-
-    /**  Sets the URL of the file to be retrieved.
-
-        @param aString a fully qualified URL.
-        */
-    public void setUrl(String aString)
-    {
-        url = aString;
-    } 
-
-    /** Sets the name of the Target where the URL will be displayed. The target may be a frame or window in a web browser when displaying a web page or a level in the current movie when loading a movie clip.
-
-        @param aString the name of the location (in the Flash Player or web browser) where contents of file retrieved via the url will be displayed.
-        */
-    public void setTarget(String aString)
-    {
-        target = aString;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSGetUrl typedObject = (FSGetUrl)anObject;
-            
-            result = url.equals(typedObject.url);
-            result = result &amp;&amp; target.equals(typedObject.target);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;url&quot;, url);
-            Transform.append(buffer, &quot;target&quot;, target);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += coder.strlen(url, true);
-        length += coder.strlen(target, true);
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeString(url);
-        coder.writeWord(0, 1);
-
-        coder.writeString(target);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        url = coder.readString();
-        target = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		url = coder.readString();
+		target = coder.readString();
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSGetUrl2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGetUrl2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGetUrl2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,240 +31,358 @@
 package com.flagstone.transform;
 
 /**
-The FSGetUrl2 action is used to either load a web page or movie clip or load or submit 
-variable values to/from a server.
-  
-&lt;p&gt;It extends the functionality provided by the FSGetUrl action by allowing the variables defined in a movie to be submitted as form values to a server. Variables defined in a movie can also be initialised by loading a file containing variable name / value assignments.&lt;/p&gt;
+ * The FSGetUrl2 action is used to either load a web page or movie clip or load
+ * or submit variable values to/from a server.
+ * 
+ * &lt;p&gt;
+ * It extends the functionality provided by the FSGetUrl action by allowing the
+ * variables defined in a movie to be submitted as form values to a server.
+ * Variables defined in a movie can also be initialised by loading a file
+ * containing variable name / value assignments.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;requestType&lt;/td&gt;
+ * &lt;td&gt;The type of request generated by the action.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSGetUrl2 is a stack-based action, however the type of request being
+ * submitted to the server is defined by the requestType attribute. Two
+ * arguments, &lt;i&gt;url&lt;/i&gt; and &lt;i&gt;target/level&lt;/i&gt; are popped from the stack.
+ * The &lt;i&gt;url&lt;/i&gt; is the first argument popped from the stack and is a fully
+ * qualified uniform resource location where the movie clip or web page will be
+ * retrieved from. The second argument is either a &lt;i&gt;target&lt;/i&gt; - the name of
+ * a specific movie clip, e.g. _root.movieClip or the name of a level in the
+ * main movie into which a movie clip has been loaded, e.g. _level1.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Request Types&lt;/b&gt;&lt;br/&gt; The &lt;i&gt;request type&lt;/i&gt; is specified as an
+ * attribute of the FSGetUrl2 action. Whether a new web page, movie clip or
+ * variable values are loaded is specified by the following types of request:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Type of Request&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToLevel&lt;/td&gt;
+ * &lt;td&gt;Load a movie to the specified level.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToLevelWithGet&lt;/td&gt;
+ * &lt;td&gt;Load a movie submitting the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToLevelWithPost&lt;/td&gt;
+ * &lt;td&gt;Load a movie submitting the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToTarget&lt;/td&gt;
+ * &lt;td&gt;Load a new Flash movie or web page to the specified target.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToTargetWithGet&lt;/td&gt;
+ * &lt;td&gt;Load a new Flash movie or web page to the specified target, submitting
+ * the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;MovieToTargetWithPost&lt;/td&gt;
+ * &lt;td&gt;Load a new Flash movie or web page to the specified target, submitting
+ * the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToLevel&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToLevelWithGet&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level,
+ * submitting the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToLevelWithPost&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level,
+ * submitting the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToTarget&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToTargetWithGet&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified target,
+ * submitting the movie variables using the HTTP GET method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;VariablesToTargetWithPost&lt;/td&gt;
+ * &lt;td&gt;Load values for selected movie variables to the specified target,
+ * submitting the movie variables using the HTTP POST method.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * When variables are submitted they are encoded using standard x-www-urlencoded
+ * encoding.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Targets&lt;/b&gt;&lt;br/&gt; The &lt;i&gt;target&lt;/i&gt; can either be the name of the frame
+ * can be one of the following reserved words:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt; opens the new page in the frame with the name
+ * defined in the HTML &lt;frame&gt; tag.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_blank&lt;/code&gt; opens the new page in a new window.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_self&lt;/code&gt; opens the new page in the current window.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_top&lt;/code&gt; opens the new page in the top level frame of the
+ * current window.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;_parent&lt;/code&gt; opens the new page in the parent frame of the
+ * frame where the Flash Player id displayed.&lt;/li&gt;
+ * &lt;li&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt; (blank string) opens the new page in the current frame
+ * or window.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Levels&lt;/b&gt;&lt;br/&gt; Levels are virtual layers (analogous to the layers in
+ * the Display List). Higher levels are displayed in front of lower levels. The
+ * background of each level is transparent allowing movie clips on lower levels
+ * to be visible in areas not filled by the movie clip on a given level. The
+ * main movie is loaded into level 0. Movie clips are loaded into any level
+ * above this (1, 2, 124, etc.). If a movie clip is loaded into a level that
+ * already contains a movie clip then the existing clip is replaced by the new
+ * one. The level follows the general form: &quot;_level&lt;i&gt;n&lt;/i&gt;&quot; loads a movie
+ * clip into the current movie at level &lt;i&gt;n&lt;/i&gt;.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Display a movie in the named frame:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction frameActions = new FSDoAction();
+ * 
+ * // Push the target followed by the url
+ * 
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movie.swf&amp;quot;">http://www.server.com/movie.swf&quot;</A>));
+ * frameActions.add(new FSPush(&quot;aFrame&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToTarget));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Load a movie clip into the current movie at level 1:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movieClip.swf&amp;quot;">http://www.server.com/movieClip.swf&quot;</A>));
+ * frameActions.add(new FSPush(&quot;_level1&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToLevel));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Submit the value of a variable as an argument to a server script:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Set the variable
+ * 
+ * frameActions.add(new FSPush(&quot;MyVariable&quot;));
+ * frameActions.add(new FSPush(23));
+ * frameActions.add(FSAction.SetVariable());
+ * 
+ * // Submit it to the server script
+ * 
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php&amp;quot;">http://www.server.com/cgi-bin/form.php&quot;</A>));
+ * frameActions.add(new FSPush(&quot;&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToTargetWithPost));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Initialise the variables in a movie clip using name/value pairs returned from
+ * a server script:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * 
+ * // Specify the level where the movie clip is loaded.
+ * 
+ * frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php&amp;quot;">http://www.server.com/cgi-bin/form.php&quot;</A>));
+ * frameActions.add(new FSPush(&quot;_level1&quot;));
+ * frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToLevelWithGet));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGetUrl2 is a class for representing the ActionGetUrl2 action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 4.
+ * &lt;/p&gt;
+ */
+public class FSGetUrl2 extends FSActionObject
+{
+	/** Load a movie without submitting the movie variables. */
+	public static final int MovieToLevel = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Load a movie submitting the movie variables using HTTP GET. */
+	public static final int MovieToLevelWithGet = 1;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Load a movie submitting the movie variables using HTTP POST. */
+	public static final int MovieToLevelWithPost = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load a movie or web page without submitting the movie variables. */
+	public static final int MovieToTarget = 64;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGetUrl2_1&quot;&gt;requestType&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The type of request generated by the action.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/** Load a movie or web page submitting the movie variables using HTTP GET. */
+	public static final int MovieToTargetWithGet = 65;
 
-&lt;p&gt;FSGetUrl2 is a stack-based action, however the type of request being submitted to the server is defined by the requestType attribute. Two arguments, &lt;i&gt;url&lt;/i&gt; and &lt;i&gt;target/level&lt;/i&gt; are popped from the stack. The &lt;i&gt;url&lt;/i&gt; is the first argument popped from the stack and is a fully qualified uniform resource location where the movie clip or web page will be retrieved from. The second argument is either a &lt;i&gt;target&lt;/i&gt; - the name of a specific movie clip, e.g. _root.movieClip or the name of a level in the main movie into which a movie clip has been loaded, e.g. _level1.&lt;/p&gt;
+	/** Load a movie or web page submitting the movie variables using HTTP POST. */
+	public static final int MovieToTargetWithPost = 66;
 
-&lt;p&gt;&lt;b&gt;Request Types&lt;/b&gt;&lt;br/&gt;
-The &lt;i&gt;request type&lt;/i&gt; is specified as an attribute of the FSGetUrl2 action. Whether a new web page, movie clip or variable values are loaded is specified by the following types of request:&lt;/p&gt;
+	/** Load variables without submitting the movie variables. */
+	public static final int VariablesToLevel = 128;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Type of Request&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
+	/** Load variables submitting the movie variables using HTTP GET. */
+	public static final int VariablesToLevelWithGet = 129;
 
-&lt;tr&gt;&lt;td&gt;MovieToLevel&lt;/td&gt;&lt;td&gt;Load a movie to the specified level.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToLevelWithGet&lt;/td&gt;&lt;td&gt;Load a movie submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToLevelWithPost&lt;/td&gt;&lt;td&gt;Load a movie submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
+	/** Load variables submitting the movie variables using HTTP POST. */
+	public static final int VariablesToLevelWithPost = 130;
 
-&lt;tr&gt;&lt;td&gt;MovieToTarget&lt;/td&gt;&lt;td&gt;Load a new Flash movie or web page to the specified target.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToTargetWithGet&lt;/td&gt;&lt;td&gt;Load a new Flash movie or web page to the specified target, submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;MovieToTargetWithPost&lt;/td&gt;&lt;td&gt;Load a new Flash movie or web page to the specified target, submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
+	/** Load variables without submitting the movie variables. */
+	public static final int VariablesToTarget = 192;
 
-&lt;tr&gt;&lt;td&gt;VariablesToLevel&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToLevelWithGet&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level, submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToLevelWithPost&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level, submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
+	/** Load variables submitting the movie variables using HTTP GET. */
+	public static final int VariablesToTargetWithGet = 193;
 
-&lt;tr&gt;&lt;td&gt;VariablesToTarget&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified level.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToTargetWithGet&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified target, submitting the movie variables using the HTTP GET method.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;VariablesToTargetWithPost&lt;/td&gt;&lt;td&gt;Load values for selected movie variables to the specified target, submitting the movie variables using the HTTP POST method.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** Load variables submitting the movie variables using HTTP POST. */
+	public static final int VariablesToTargetWithPost = 194;
 
-&lt;p&gt;When variables are submitted they are encoded using standard x-www-urlencoded encoding.&lt;/p&gt;
+	private int requestType = MovieToLevel;
 
-&lt;p&gt;&lt;b&gt;Targets&lt;/b&gt;&lt;br/&gt;
-The &lt;i&gt;target&lt;/i&gt; can either be the name of the frame can be one of the following reserved words:&lt;/p&gt;
+	/**
+	 * Construct an FSGetUrl2 object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGetUrl2(FSCoder coder)
+	{
+		super(GetUrl2);
+		decode(coder);
+	}
 
-&lt;ul&gt;
-&lt;li&gt;&lt;code&gt;&quot;name&quot;&lt;/code&gt; opens the new page in the frame with the name defined in the HTML &lt;frame&gt; tag.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_blank&lt;/code&gt; opens the new page in a new window.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_self&lt;/code&gt; opens the new page in the current window.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_top&lt;/code&gt; opens the new page in the top level frame of the current window.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;_parent&lt;/code&gt; opens the new page in the parent frame of the frame where the Flash Player id displayed.&lt;/li&gt;
-&lt;li&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt; (blank string) opens the new page in the current frame or window.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Constructs an FSGetUrl2 using the specified request type.
+	 * 
+	 * @param aType
+	 *            the type of request to be performed. Must be one of the
+	 *            constants defined in this class.
+	 */
+	public FSGetUrl2(int aType)
+	{
+		super(GetUrl2);
+		setRequestType(aType);
+	}
 
-&lt;p&gt;&lt;b&gt;Levels&lt;/b&gt;&lt;br/&gt;
-Levels are virtual layers (analogous to the layers in the Display List). Higher levels are displayed in front of lower levels. The background of each level is transparent allowing movie clips on lower levels to be visible in areas not filled by the movie clip on a given level. The main movie is loaded into level 0. Movie clips are loaded into any level above this (1, 2, 124, etc.). If a movie clip is loaded into a level that already contains a movie clip then the existing clip is replaced by the new one. The level follows the general form: &quot;_level&lt;i&gt;n&lt;/i&gt;&quot; loads a movie clip into the current movie at level &lt;i&gt;n&lt;/i&gt;.&lt;/p&gt;
+	/**
+	 * Constructs an FSGetUrl2 object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGetUrl2 object.
+	 */
+	public FSGetUrl2(FSGetUrl2 obj)
+	{
+		super(obj);
+		requestType = obj.requestType;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the request type.
+	 * 
+	 * @return the type of request to be performed.
+	 */
+	public int getRequestType()
+	{
+		return requestType;
+	}
 
-&lt;p&gt;Display a movie in the named frame:&lt;/p&gt;
+	/**
+	 * Sets the request type.
+	 * 
+	 * @param aType
+	 *            the type of request to be performed. Must be one of the
+	 *            constants defined in this class.
+	 */
+	public void setRequestType(int aType)
+	{
+		requestType = aType;
+	}
 
-&lt;pre&gt;
-FSDoAction frameActions = new FSDoAction();
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-// Push the target followed by the url
+		if (super.equals(anObject))
+			result = requestType == ((FSGetUrl2) anObject).getRequestType();
 
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movie.swf">http://www.server.com/movie.swf</A>&quot;));
-frameActions.add(new FSPush(&quot;aFrame&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToTarget));
-&lt;/pre&gt;
+		return result;
+	}
 
-&lt;p&gt;Load a movie clip into the current movie at level 1:&lt;/p&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;pre&gt;
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/movieClip.swf">http://www.server.com/movieClip.swf</A>&quot;));
-frameActions.add(new FSPush(&quot;_level1&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.MovieToLevel));
-&lt;/pre&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;requestType&quot;, requestType);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;Submit the value of a variable as an argument to a server script:&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;pre&gt;
-// Set the variable
+		length += 1;
 
-frameActions.add(new FSPush(&quot;MyVariable&quot;));
-frameActions.add(new FSPush(23));
-frameActions.add(FSAction.SetVariable());
+		return length;
+	}
 
-// Submit it to the server script
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(requestType, 1);
+		coder.endObject(name());
+	}
 
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php">http://www.server.com/cgi-bin/form.php</A>&quot;));
-frameActions.add(new FSPush(&quot;&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToTargetWithPost));
-&lt;/pre&gt;
-
-&lt;p&gt;Initialise the variables in a movie clip using name/value pairs returned from a server script:&lt;/p&gt;
-
-&lt;pre&gt;
-
-// Specify the level where the movie clip is loaded.
-
-frameActions.add(new FSPush(&quot;<A HREF="http://www.server.com/cgi-bin/form.php">http://www.server.com/cgi-bin/form.php</A>&quot;));
-frameActions.add(new FSPush(&quot;_level1&quot;));
-frameActions.add(new FSGetUrl2(FSGetUrl2.VariablesToLevelWithGet));
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSGetUrl2 is a class for representing the ActionGetUrl2 action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSGetUrl2 extends FSActionObject
-{
-    /** Load a movie without submitting the movie variables. */
-    public static final int MovieToLevel = 0;
-    /** Load a movie submitting the movie variables using HTTP GET. */
-    public static final int MovieToLevelWithGet  = 1;
-    /** Load a movie submitting the movie variables using HTTP POST. */
-    public static final int MovieToLevelWithPost = 2;
-    /** Load a movie or web page without submitting the movie variables. */
-    public static final int MovieToTarget = 64;
-    /** Load a movie or web page submitting the movie variables using HTTP GET. */
-    public static final int MovieToTargetWithGet  = 65;
-    /** Load a movie or web page submitting the movie variables using HTTP POST. */
-    public static final int MovieToTargetWithPost = 66;
-
-    /** Load variables without submitting the movie variables. */
-    public static final int VariablesToLevel = 128;
-    /** Load variables submitting the movie variables using HTTP GET. */
-    public static final int VariablesToLevelWithGet  = 129;
-    /** Load variables submitting the movie variables using HTTP POST. */
-    public static final int VariablesToLevelWithPost = 130;
-    /** Load variables without submitting the movie variables. */
-    public static final int VariablesToTarget = 192;
-    /** Load variables submitting the movie variables using HTTP GET. */
-    public static final int VariablesToTargetWithGet  = 193;
-    /** Load variables submitting the movie variables using HTTP POST. */
-    public static final int VariablesToTargetWithPost = 194;
-        
-    private int requestType = MovieToLevel;
-    
-    /**
-     * Construct an FSGetUrl2 object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGetUrl2(FSCoder coder)
-    {
-        super(GetUrl2);
-        decode(coder);
-    }
-    /** Constructs an FSGetUrl2 using the specified request type. 
-
-        @param aType the type of request to be performed. Must be one of the constants defined in this class.
-        */
-    public FSGetUrl2(int aType)
-    {
-        super(GetUrl2);
-        setRequestType(aType);
-    }
-    /**
-     * Constructs an FSGetUrl2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGetUrl2 object.
-     */
-    public FSGetUrl2(FSGetUrl2 obj)
-    {
-        super(obj);
-        requestType = obj.requestType;
-    }    
-
-    /** Gets the request type. 
-
-        @return the type of request to be performed.
-        */
-    public int getRequestType() { return requestType; }
-
-    /** Sets the request type. 
-
-        @param aType the type of request to be performed. Must be one of the constants defined in this class.
-        */
-    public void setRequestType(int aType)
-    {
-        requestType = aType;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = requestType == ((FSGetUrl2)anObject).getRequestType();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;requestType&quot;, requestType);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(requestType, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        requestType = coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		requestType = coder.readWord(1, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSGotoFrame.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGotoFrame.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGotoFrame.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,148 +31,181 @@
 package com.flagstone.transform;
 
 /**
-The FSGotoFrame action instructs the player to move to the specified frame in the current 
-movie's main time-line.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * The FSGotoFrame action instructs the player to move to the specified frame in
+ * the current movie's main time-line.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameNumber&lt;/td&gt;
+ * &lt;td&gt;The number of the frame in the movie's main time-line, in the range
+ * 1..65535, to move to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The movie will start playing immediately from the specified frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ * FSGotoFrame gotoFrame = new FSGotoFrame(12);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoFrame is only used to control the main time-line of a movie.
+ * Controlling how an individual movie clip is played is handled by a different
+ * mechanism. From Flash 5 onward movie clips are defined as objects. The
+ * ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop()
+ * methods that control a movie clip's time-line:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(&quot;frameName&quot;));
+ * frameAction.add(new FSPush(1));
+ * 
+ * // Get a reference to the object.
+ * 
+ * frameAction.add(new FSPush(&quot;_root&quot;));
+ * frameAction.add(new FSPush(&quot;movieClip&quot;));
+ * frameAction.add(new FSAction(FSAction.GetAttribute));
+ * 
+ * // Place the name of the method on the stack then execute it.
+ * 
+ * frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * frameAction.add(new FSAction(FSAction.ExecuteMethod));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGotoFrame represents the ActionGotoFrame action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3. This class is
+ * now superseded by the FSGotoFrame2 action which allows either the name of a
+ * frame or a number of be specified.
+ * &lt;/p&gt;
+ */
+public class FSGotoFrame extends FSActionObject
+{
+	private int frameNumber = 1;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSGotoFrame object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGotoFrame(FSCoder coder)
+	{
+		super(GotoFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGotoFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoFrame with the specified frame number. The frame
+	 * number must be in the range 1..65535.
+	 * 
+	 * @param aNumber
+	 *            the number of the frame.
+	 */
+	public FSGotoFrame(int aNumber)
+	{
+		super(GotoFrame);
+		setFrameNumber(aNumber);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGotoFrame_1&quot;&gt;frameNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the frame in the movie's main time-line, in the range 1..65535, to move to.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSGotoFrame(FSGotoFrame obj)
+	{
+		super(obj);
+		frameNumber = obj.frameNumber;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the number of the frame to move the main time-line to.
+	 * 
+	 * @return the frame number.
+	 */
+	public int getFrameNumber()
+	{
+		return frameNumber;
+	}
 
-&lt;p&gt;The movie will start playing immediately from the specified frame.&lt;/p&gt;
+	/**
+	 * Sets the number of the frame to move the main time-line to. The frame
+	 * number must be in the range 1..65535.
+	 * 
+	 * @param aNumber
+	 *            the frame number.
+	 */
+	public void setFrameNumber(int aNumber)
+	{
+		frameNumber = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSGotoFrame gotoFrame = new FSGotoFrame(12);
-&lt;/pre&gt;
+		if (super.equals(anObject))
+			result = frameNumber == ((FSGotoFrame) anObject).getFrameNumber();
 
-&lt;p&gt;FSGotoFrame is only used to control the main time-line of a movie. Controlling how an individual movie clip is played is handled by a different mechanism. From Flash 5 onward movie clips are defined as objects. The ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop() methods that control a movie clip's time-line:&lt;/p&gt;
+		return result;
+	}
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-frameAction.add(new FSPush(&quot;frameName&quot;));
-frameAction.add(new FSPush(1));
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;}&quot;);
+			Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-// Get a reference to the object.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-frameAction.add(new FSPush(&quot;_root&quot;));
-frameAction.add(new FSPush(&quot;movieClip&quot;));
-frameAction.add(new FSAction(FSAction.GetAttribute));
+		length += 2;
 
-// Place the name of the method on the stack then execute it.
+		return length;
+	}
 
-frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
-frameAction.add(new FSAction(FSAction.ExecuteMethod));
-&lt;/pre&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(frameNumber, 2);
+		coder.endObject(name());
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-&lt;p&gt;The FSGotoFrame represents the ActionGotoFrame action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3. This class is now superseded by the FSGotoFrame2 action which allows either the name of a frame or a number of be specified.&lt;/p&gt; */
-public class FSGotoFrame extends FSActionObject
-{
-    private int frameNumber = 1;
-
-    /**
-     * Construct an FSGotoFrame object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGotoFrame(FSCoder coder)
-    {
-        super(GotoFrame);
-        decode(coder);
-    }
-    /** Constructs an FSGotoFrame with the specified frame number. The frame number must be in the range 1..65535.
-
-        @param aNumber the number of the frame.
-        */
-    public FSGotoFrame(int aNumber)
-    {
-        super(GotoFrame);
-        setFrameNumber(aNumber);
-    }
-    /**
-     * Constructs an FSGotoFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSGotoFrame(FSGotoFrame obj)
-    {
-        super(obj);
-        frameNumber = obj.frameNumber;
-    }    
-
-    /** Gets the number of the frame to move the main time-line to.
-
-        @return the frame number.
-        */
-    public int getFrameNumber() { return frameNumber; }
-
-    /** Sets the number of the frame to move the main time-line to. The frame number must be in the range 1..65535.
-
-        @param aNumber the frame number.
-        */
-    public void setFrameNumber(int aNumber)
-    {
-        frameNumber = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = frameNumber == ((FSGotoFrame)anObject).getFrameNumber();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;}&quot;);
-            Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(frameNumber, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        frameNumber = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+		frameNumber = coder.readWord(2, false);
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSGotoFrame2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGotoFrame2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGotoFrame2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,273 +31,324 @@
 package com.flagstone.transform;
 
 /**
-The FSGotoFrame2 action instructs the player to go to the named or numbered frame in the 
-current movie's main time-line. It extends the functionality provided by the FSGotoFrame action by allowing 
-the name of a frame, previously assigned using the FSFrameLabel object, to be specified.&lt;/p&gt;
+ * The FSGotoFrame2 action instructs the player to go to the named or numbered
+ * frame in the current movie's main time-line. It extends the functionality
+ * provided by the FSGotoFrame action by allowing the name of a frame,
+ * previously assigned using the FSFrameLabel object, to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;play&lt;/td&gt;
+ * &lt;td&gt;A boolean flag indicating whether the Flash Player should start playing
+ * the frame as soon as it is loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameOffset&lt;/td&gt;
+ * &lt;td&gt;An offset added to the frame number of the stack to generate the final
+ * frame number that the timeline should move to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Up to Flash Version 4, movies contained a single sequence of 65536 frames. In
+ * Flash 5 the concept of Scenes was added which allowed movies to contain
+ * 'pages' of frames. FSGotoFrame2 contains a frameOffset attribute which allows
+ * the frames in each scene to be referenced by its 'logical' number. The
+ * frameOffset for a given scene is added to the frame number to generate the
+ * 'physical' page number.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoFrame2 is a stack-based action. The name or number of the frame is
+ * pushed onto the stack before the FSGotoFrame2 action is executed. If a
+ * frameOffset is specified it is added to the number of the frame identified by
+ * the stack arguments to give the final frame number. Whether the movie starts
+ * playing the frame is controlled by the boolean attribute, &lt;i&gt;play&lt;/i&gt;. When
+ * set to true the movie starts playing the frame as soon as it has been loaded
+ * by the Flash Player.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Start playing a movie at the specified frame number:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(12));
+ * actions.add(new FSGotoFrame2(true));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Move to the named frame but do not start playing immediately:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSMovie movie = new FSMovie();
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+ * 
+ * actions.add(new FSPush(&quot;FirstFrame&quot;));
+ * actions.add(new FSGotoFrame2(false));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * To use the concept of scenes in a movie, divide the physical frames into a
+ * sequence of logical pages:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * 
+ *  int sceneSize = 1024;
+ *  int scene = 5;
+ *  boolean play = true;
+ * 
+ *  // Goto the first frame in scene 5.
+ * 
+ *  frameAction.add(new FSPush(1));
+ *  frameAction.add(new FSGotoFrame2(scene*sceneSize, play);
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoFrame2 is only used to control the main time-line of a movie.
+ * Controlling how an individual movie clip is played is handled by a different
+ * mechanism. From Flash 5 onward movie clips are defined as objects. The
+ * ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop()
+ * methods that control a movie clip's time-line:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push the arguments followed by the number of arguments onto the stack
+ * 
+ * frameAction.add(new FSPush(&quot;frameName&quot;));
+ * frameAction.add(new FSPush(1));
+ * 
+ * // Get a reference to the object.
+ * 
+ * frameAction.add(new FSPush(&quot;_root&quot;));
+ * frameAction.add(new FSPush(&quot;movieClip&quot;));
+ * frameAction.add(FSAction.GetAttribute());
+ * 
+ * // Place the name of the method on the stack then execute it.
+ * 
+ * frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * frameAction.add(FSAction.ExecuteMethod());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGotoFrame2 is a class for representing the ActionGotoFrame2 action of
+ * the Macromedia Flash (SWF) File Format Specification. It was introduced in
+ * Flash 4 and supersedes the FSGotoFrame action. In Flash 5 the frameOffset
+ * attribute was added which allows movies to be divided into a series of
+ * 'pages'.
+ * &lt;/p&gt;
+ */
+public class FSGotoFrame2 extends FSActionObject
+{
+	private boolean playFrame = false;
+	private int frameOffset = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSGotoFrame2 object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGotoFrame2(FSCoder coder)
+	{
+		super(GotoFrame2);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoFrame2 object with the specified play flag setting.
+	 * 
+	 * @param aBool
+	 *            true if the player should being playing the movie at the
+	 *            specified frame. false if the player should stop playing the
+	 *            movie.
+	 */
+	public FSGotoFrame2(boolean aBool)
+	{
+		super(GotoFrame2);
+		setPlayFrame(aBool);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoFrame2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 5
+	/**
+	 * Constructs an FSGotoFrame2 object with the specified play flag setting
+	 * and frame offset for a given scene.
+	 * 
+	 * @param offset
+	 *            a number which will be added to the number of the frame popped
+	 *            from the stack to give the final frame number.
+	 * @param aBool
+	 *            true if the player should being playing the movie at the
+	 *            specified frame, false if the player should stop playing the
+	 *            movie.
+	 */
+	public FSGotoFrame2(int offset, boolean aBool)
+	{
+		super(GotoFrame2);
+		setPlayFrame(aBool);
+		setFrameOffset(offset);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoFrame2_1&quot;&gt;play&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A boolean flag indicating whether the Flash Player should start playing the frame as soon as it 
-is loaded.&lt;/td&gt;
-&lt;/tr&gt;
+	// End Flash 5
+	/**
+	 * Constructs an FSGotoFrame2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSGotoFrame2(FSGotoFrame2 obj)
+	{
+		super(obj);
+		playFrame = obj.playFrame;
+		frameOffset = obj.frameOffset;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoFrame2_2&quot;&gt;frameOffset&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An offset added to the frame number of the stack to generate the final frame number that the 
-timeline should move to.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 5
+	/**
+	 * Gets the offset that will be added to the 'logical' frame number obtained
+	 * from the stack to generate the 'physical' frame number.
+	 * 
+	 * @return an offset that will be added to the frame number obtained form
+	 *         the stack.
+	 */
+	public int getFrameOffset()
+	{
+		return frameOffset;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the offset that will be added to the 'logical' frame number obtained
+	 * from the stack to generate the 'physical' frame number.
+	 * 
+	 * @param offset
+	 *            a number that will be added to the frame number obtained form
+	 *            the stack.
+	 */
+	public void setFrameOffset(int offset)
+	{
+		frameOffset = offset;
+	}
 
-&lt;p&gt;Up to Flash Version 4, movies contained a single sequence of 65536 frames. In Flash 5 the 
-concept of Scenes was added which allowed movies to contain 'pages' of frames. FSGotoFrame2 
-contains a frameOffset attribute which allows the frames in each scene to be referenced by 
-its 'logical' number. The frameOffset for a given scene is added to the frame number to 
-generate the 'physical' page number.&lt;/p&gt;
+	// End Flash 5
 
-&lt;p&gt;FSGotoFrame2 is a stack-based action. The name or number of the frame is pushed onto the 
-stack before the FSGotoFrame2 action is executed. If a frameOffset is specified it is added 
-to the number of the frame identified by the stack arguments to give the final frame number. 
-Whether the movie starts playing the frame is controlled by the boolean attribute, &lt;i&gt;play&lt;/i&gt;. 
-When set to true the movie starts playing the frame as soon as it has been loaded by the Flash 
-Player.&lt;/p&gt;
+	/**
+	 * Gets the play flag.
+	 * 
+	 * @return true if the player will being playing the movie at the specified
+	 *         frame, false otherwise.
+	 */
+	public boolean getPlayFrame()
+	{
+		return playFrame;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the play flag.
+	 * 
+	 * @param aBool
+	 *            true if the player should being playing the movie at the
+	 *            specified frame. false if the player should stop playing the
+	 *            movie.
+	 */
+	public void setPlayFrame(boolean aBool)
+	{
+		playFrame = aBool;
+	}
 
-&lt;p&gt;Start playing a movie at the specified frame number:&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+		if (super.equals(anObject))
+		{
+			FSGotoFrame2 typedObject = (FSGotoFrame2) anObject;
 
-actions.add(new FSPush(12));
-actions.add(new FSGotoFrame2(true));
-&lt;/pre&gt;
+			result = playFrame == typedObject.playFrame;
+			result = result &amp;&amp; frameOffset == typedObject.frameOffset;
+		}
+		return result;
+	}
 
-&lt;p&gt;Move to the named frame but do not start playing immediately:&lt;/p&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
-FSDoAction actions = new FSDoAction();
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;}&quot;);
+			Transform.append(buffer, &quot;playFrame&quot;, playFrame);
+			// Flash 5
+			Transform.append(buffer, &quot;frameOffset&quot;, frameOffset);
+			// End Flash 5
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-actions.add(new FSPush(&quot;FirstFrame&quot;));
-actions.add(new FSGotoFrame2(false));
-&lt;/pre&gt;
+		length += 1 + ((frameOffset &gt; 0) ? 2 : 0);
 
-&lt;p&gt;To use the concept of scenes in a movie, divide the physical frames into a sequence of logical pages:&lt;/p&gt;
+		return length;
+	}
 
-&lt;pre&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-int sceneSize = 1024;
-int scene = 5;
-boolean play = true;
+		coder.writeBits(0, 6);
+		coder.writeBits(frameOffset != 0 ? 1 : 0, 1);
+		coder.writeBits(playFrame ? 1 : 0, 1);
 
-// Goto the first frame in scene 5.
+		// Flash 5
+		if (frameOffset &gt; 0)
+			coder.writeWord(frameOffset, 2);
+		// End Flash 5
 
-frameAction.add(new FSPush(1));
-frameAction.add(new FSGotoFrame2(scene*sceneSize, play);
+		coder.endObject(name());
+	}
 
-&lt;/pre&gt;
+	public void decode(FSCoder coder)
+	{
+		boolean containsOffset = false;
 
-&lt;p&gt;FSGotoFrame2 is only used to control the main time-line of a movie. Controlling how an individual 
-movie clip is played is handled by a different mechanism. From Flash 5 onward movie clips are defined 
-as objects. The ExecuteMethod action is used to execute the gotoAndPlay() or gotoAndStop() methods 
-that control a movie clip's time-line:&lt;/p&gt;
+		super.decode(coder);
+		coder.readBits(6, false);
+		containsOffset = coder.readBits(1, false) != 0 ? true : false;
+		playFrame = coder.readBits(1, false) != 0 ? true : false;
 
-&lt;pre&gt;
-// Push the arguments followed by the number of arguments onto the stack
+		// Flash 5
+		if (containsOffset)
+			frameOffset = coder.readWord(2, false);
+		// End Flash 5
 
-frameAction.add(new FSPush(&quot;frameName&quot;));
-frameAction.add(new FSPush(1));
-
-// Get a reference to the object.
-
-frameAction.add(new FSPush(&quot;_root&quot;));
-frameAction.add(new FSPush(&quot;movieClip&quot;));
-frameAction.add(FSAction.GetAttribute());
-
-// Place the name of the method on the stack then execute it.
-
-frameAction.add(new FSPush(&quot;gotoAndPlay&quot;));
-frameAction.add(FSAction.ExecuteMethod());
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSGotoFrame2 is a class for representing the ActionGotoFrame2 action of the Macromedia 
-Flash (SWF) File Format Specification. It  was introduced in Flash 4 and supersedes the FSGotoFrame 
-action. In Flash 5 the frameOffset attribute was added which allows movies to be divided into a 
-series of 'pages'.&lt;/p&gt;
- */  
-public class FSGotoFrame2 extends FSActionObject
-{
-    private boolean playFrame = false;
-    private int frameOffset = 0;
-    
-    /**
-     * Construct an FSGotoFrame2 object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGotoFrame2(FSCoder coder)
-    {
-        super(GotoFrame2);
-        decode(coder);
-    }
-    /** Constructs an FSGotoFrame2 object with the specified play flag setting. 
-
-        @param aBool true if the player should being playing the movie at the specified frame. 
-        false if the player should stop playing the movie.
-        */
-    public FSGotoFrame2(boolean aBool)
-    {
-        super(GotoFrame2);
-        setPlayFrame(aBool);
-    }
-// Flash 5
-    /** Constructs an FSGotoFrame2 object with the specified play flag setting 
-     *  and frame offset for a given scene. 
-     *  
-     *  @param offset a number which will be added to the number of the frame popped from the 
-     *  stack to give the final frame number.
-     *  @param aBool true if the player should being playing the movie at the specified frame, 
-     *  false if the player should stop playing the movie.
-     */
-    public FSGotoFrame2(int offset, boolean aBool)
-    {
-        super(GotoFrame2);
-        setPlayFrame(aBool);
-        setFrameOffset(offset);
-    }
-//  End Flash 5
-    /**
-     * Constructs an FSGotoFrame2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSGotoFrame2(FSGotoFrame2 obj)
-    {
-        super(obj);
-        playFrame = obj.playFrame;
-        frameOffset = obj.frameOffset;
-    }    
-//  Flash 5
-    /** Gets the offset that will be added to the 'logical' frame number obtained 
-     *  from the stack to generate the 'physical' frame number.
-     * 
-     *  @return an offset that will be added to the frame number obtained form the stack.
-     */
-    public int getFrameOffset() 
-    { 
-        return frameOffset; 
-    }
-
-    /** Sets the offset that will be added to the 'logical' frame number obtained 
-     *  from the stack to generate the 'physical' frame number.
-     * 
-     *  @param offset a number that will be added to the frame number obtained form the stack.
-     */
-    public void setFrameOffset(int offset)
-    {
-        frameOffset = offset;
-    } 
-// End Flash 5
-
-    /** Gets the play flag. 
-
-        @return true if the player will being playing the movie at the specified frame, false otherwise.
-        */
-    public boolean getPlayFrame() { return playFrame; }
-
-    /** Sets the play flag. 
-
-        @param aBool true if the player should being playing the movie at the specified frame. false if the player should stop playing the movie.
-        */
-    public void setPlayFrame(boolean aBool)
-    {
-        playFrame = aBool;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSGotoFrame2 typedObject = (FSGotoFrame2)anObject;
-            
-            result = playFrame == typedObject.playFrame;
-            result = result &amp;&amp; frameOffset == typedObject.frameOffset;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;}&quot;);
-            Transform.append(buffer, &quot;playFrame&quot;, playFrame);
-// Flash 5
-            Transform.append(buffer, &quot;frameOffset&quot;, frameOffset);
-// End Flash 5
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1 + ((frameOffset &gt; 0) ? 2 : 0);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeBits(0, 6);
-        coder.writeBits(frameOffset != 0 ? 1 : 0, 1);
-        coder.writeBits(playFrame ? 1 : 0, 1);
-        
-// Flash 5
-        if (frameOffset &gt; 0)
-            coder.writeWord(frameOffset, 2);
-// End Flash 5
-        
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsOffset = false; 
-        
-        super.decode(coder);
-        coder.readBits(6, false);
-        containsOffset = coder.readBits(1, false) != 0 ? true : false;
-        playFrame = coder.readBits(1, false) != 0 ? true : false;
-
-// Flash 5
-        if (containsOffset)
-            frameOffset = coder.readWord(2, false);
-// End Flash 5
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSGotoLabel.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGotoLabel.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGotoLabel.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,155 +31,180 @@
 package com.flagstone.transform;
 
 /**
-The FSGotoLabel action instructs the player to move to the frame in the current movie 
-with the specified label.
+ * The FSGotoLabel action instructs the player to move to the frame in the
+ * current movie with the specified label.
+ * 
+ * &lt;p&gt;
+ * The label is assigned to the frame using the FSFrameLabel object.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;label&lt;/td&gt;
+ * &lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSMovie movie = new FSMovie();
+ * 
+ *  // Assign the name to the &quot;current&quot; frame
+ * 
+ *  movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
+ *  movie.add(new FSShowFrame());
+ *  ...
+ * 
+ *  // Move the timeline back to the named frame when the actions
+ *  // associated with this frame is executed.
+ * 
+ *  FSDoAction actions = new FSDoAction();
+ * 
+ *  actions.add(new FSGotoLabel(&quot;FirstFrame&quot;));
+ * 
+ *  movie.add(actions);
+ *  movie.add(new FSShowFrame());
+ * 
+ * &lt;/pre&gt;
+ * 
+ * 
+ * &lt;p&gt;
+ * The scope of a frame is delineated by successive FSShowFrame objects. To
+ * assign a label to a frame the FSFrameLabel object can be added at any point
+ * prior to the FSShowFrame object that marks the end of the frame.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSGotoLabel represents the ActionGotoLabel action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSGotoLabel extends FSActionObject
+{
+	private String label = null;
 
-&lt;p&gt;The label is assigned to the frame using the FSFrameLabel object.&lt;/p&gt;
+	FSGotoLabel()
+	{
+		super(GotoLabel);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSGotoLabel object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGotoLabel(FSCoder coder)
+	{
+		super(GotoLabel);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoLabel action with the specified frame label.
+	 * 
+	 * @param aString
+	 *            the label assigned a particular frame in the movie.
+	 */
+	public FSGotoLabel(String aString)
+	{
+		super(GotoLabel);
+		setLabel(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoLabel_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGotoLabel object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGotoLabel object.
+	 */
+	public FSGotoLabel(FSGotoLabel obj)
+	{
+		super(obj);
+		label = new String(obj.label);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGotoLabel_1&quot;&gt;label&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name that will be assigned to the current frame.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the frame label.
+	 * 
+	 * @return the label assigned to the frame.
+	 */
+	public String getLabel()
+	{
+		return label;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the frame label.
+	 * 
+	 * @param aString
+	 *            the label assigned a particular frame in the movie.
+	 */
+	public void setLabel(String aString)
+	{
+		label = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
+		if (super.equals(anObject))
+			result = label.equals(((FSGotoLabel) anObject).getLabel());
 
-// Assign the name to the &quot;current&quot; frame
+		return result;
+	}
 
-movie.add(new FSFrameLabel(&quot;FirstFrame&quot;));
-movie.add(new FSShowFrame());
-...
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-// Move the timeline back to the named frame when the actions
-// associated with this frame is executed.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;}&quot;);
+			Transform.append(buffer, &quot;label&quot;, label);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-FSDoAction actions = new FSDoAction();
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-actions.add(new FSGotoLabel(&quot;FirstFrame&quot;));
+		length += coder.strlen(label, true);
 
-movie.add(actions);
-movie.add(new FSShowFrame());
+		return length;
+	}
 
-&lt;/pre&gt;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
+		coder.writeString(label);
+		coder.writeWord(0, 1);
+		coder.endObject(name());
+	}
 
-&lt;p&gt;The scope of a frame is delineated by successive FSShowFrame objects. To assign a label to a frame the FSFrameLabel object can be added at any point prior to the FSShowFrame object that marks the end of the frame.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;FSGotoLabel represents the ActionGotoLabel action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt; */  
-public class FSGotoLabel extends FSActionObject
-{
-    private String label = null;
-    
-    FSGotoLabel()
-    {
-        super(GotoLabel);
-    }
-    /**
-     * Construct an FSGotoLabel object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGotoLabel(FSCoder coder)
-    {
-        super(GotoLabel);
-        decode(coder);
-    }
-    /** Constructs an FSGotoLabel action with the specified frame label. 
-
-        @param aString the label assigned a particular frame in the movie.
-        */
-    public FSGotoLabel(String aString)
-    {
-        super(GotoLabel);
-        setLabel(aString);
-    }
-    /**
-     * Constructs an FSGotoLabel object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoLabel object.
-     */
-    public FSGotoLabel(FSGotoLabel obj)
-    {
-        super(obj);
-        label = new String(obj.label);
-    }    
-
-    /** Gets the frame label.
-
-        @return the label assigned to the frame.
-        */
-    public String getLabel() { return label; }
-
-    /** Sets the frame label. 
-
-        @param aString the label assigned a particular frame in the movie.
-        */
-    public void setLabel(String aString)
-    {
-        label = aString;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = label.equals(((FSGotoLabel)anObject).getLabel());
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;}&quot;);
-            Transform.append(buffer, &quot;label&quot;, label);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += coder.strlen(label, true);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-         coder.writeString(label);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        label = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		label = coder.readString();
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSGradient.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGradient.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGradient.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,169 +31,211 @@
 package com.flagstone.transform;
 
 /**
-FSGradient defines a control point that is used to specify how a gradient colour is displayed. 
+ * FSGradient defines a control point that is used to specify how a gradient
+ * colour is displayed.
+ * 
+ * &lt;p&gt;
+ * Two or more control points are used to define how the colour changes across
+ * the gradient square. Each control point specifies:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;ratio&lt;/td&gt;
+ * &lt;td&gt;The location of the control point across the gradient square.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;color&lt;/td&gt;
+ * &lt;td&gt;The colour displayed at the control point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The location of the control point is defined by a ratio - a number between 0
+ * and 255 - that specifies the relative location in the square. For Linear
+ * Gradient Fills a ratio of zero is mapped to the left side of the gradient
+ * square and 255 is mapped to the right side of the square. For Radial Gradient
+ * Fills a ratio of zero is mapped to the centre of the gradient square and 255
+ * is mapped to the edge of the largest circle that fits inside the gradient
+ * square. A ratio is used rather than specifying coordinates within the
+ * gradient square as the coordinate space is transformed to fit the shape that
+ * the gradient is being displayed in.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Note that the object used to create the shape definition determines whether
+ * the alpha channel is encoded in the gradient colours. Simply specifying the
+ * level of transparency in the FSColor object is not sufficient.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGradient class represents the GradientRecord structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSGradient extends FSTransformObject
+{
+	private int ratio = 0;
+	private FSColor color = null;
 
-&lt;p&gt;Two or more control points are used to define how the colour changes across the gradient square. Each control point specifies:&lt;/p&gt;
+	/**
+	 * Construct an FSGradient object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGradient(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSGradient object with the specified ratio and color.
+	 * 
+	 * @param aRatio
+	 *            the ratio along the gradient square.
+	 * @param aColor
+	 *            the color at the control point.
+	 */
+	public FSGradient(int aRatio, FSColor aColor)
+	{
+		setRatio(aRatio);
+		setColor(aColor);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSGradient object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGradient object.
+	 */
+	public FSGradient(FSGradient obj)
+	{
+		ratio = obj.ratio;
+		color = new FSColor(obj.color);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGradient_0&quot;&gt;ratio&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The location of the control point across the gradient square.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the ratio that defines the relative point across the gradient
+	 * square.
+	 * 
+	 * @return the ratio where the control point is located.
+	 */
+	public int getRatio()
+	{
+		return ratio;
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGradient_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour displayed at the control point.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the colour that is displayed at the control point across the
+	 * gradient square defined by the ratio.
+	 * 
+	 * @return the color at the control point.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-&lt;p&gt;The location of the control point is defined by a ratio - a number between 0 and 255 - that specifies the relative location in the square. For Linear Gradient Fills a ratio of zero is mapped to the left side of the gradient square and 255 is mapped to the right side of the square. For Radial Gradient Fills a ratio of zero is mapped to the centre of the gradient square and 255 is mapped to the edge of the largest circle that fits inside the gradient square. A ratio is used rather than specifying coordinates within the gradient square as the coordinate space is transformed to fit the shape that the gradient is being displayed in.&lt;/p&gt;
+	/**
+	 * Sets the ratio that defines the control point across the gradient square.
+	 * 
+	 * @param aNumber
+	 *            the ratio along the gradient square.
+	 */
+	public void setRatio(int aNumber)
+	{
+		ratio = aNumber;
+	}
 
-&lt;p&gt;Note that the object used to create the shape definition determines whether the alpha channel is encoded in the gradient colours. Simply specifying the level of transparency in the FSColor object is not sufficient.&lt;/p&gt;
+	/**
+	 * Sets the colour that is displayed at the control point across the
+	 * gradient square.
+	 * 
+	 * @param aColor
+	 *            the color at the control point.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public Object clone()
+	{
+		FSGradient anObject = (FSGradient) super.clone();
 
-&lt;p&gt;The FSGradient class represents the GradientRecord structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSGradient extends FSTransformObject
-{
-    private int ratio = 0;
-    private FSColor color = null;
-    
-    /**
-     * Construct an FSGradient object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGradient(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSGradient object with the specified ratio and color.
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-        @param aRatio the ratio along the gradient square.
-        @param aColor the color at the control point.
-        */
-    public FSGradient(int aRatio, FSColor aColor)
-    {
-        setRatio(aRatio);
-        setColor(aColor);
-    }
-    /**
-     * Constructs an FSGradient object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGradient object.
-     */
-    public FSGradient(FSGradient obj)
-    {
-        ratio = obj.ratio;
-        color = new FSColor(obj.color);
-    }    
+		return anObject;
+	}
 
-    /** Gets the ratio that defines the relative point across the gradient square.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the ratio where the control point is located.
-        */
-    public int getRatio() 
-    {
-        return ratio;
-    }
+		if (super.equals(anObject))
+		{
+			FSGradient typedObject = (FSGradient) anObject;
 
-    /** Gets the colour that is displayed at the control point across the gradient square defined by the ratio.
+			result = ratio == typedObject.ratio;
 
-        @return the color at the control point.
-        */
-    public FSColor getColor() 
-    {
-        return color;
-    }
+			if (color != null)
+				result = result &amp;&amp; color.equals(typedObject.color);
+			else
+				result = result &amp;&amp; color == typedObject.color;
+		}
+		return result;
+	}
 
-    /** Sets the ratio that defines the control point across the gradient square.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param aNumber the ratio along the gradient square.
-        */
-    public void setRatio(int aNumber)
-    {
-        ratio = aNumber;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;ratio&quot;, ratio);
+			Transform.append(buffer, &quot;color&quot;, color, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the colour that is displayed at the control point across the gradient square.
+	public int length(FSCoder coder)
+	{
+		int length = 1;
 
-        @param aColor the color at the control point.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+		length += color.length(coder);
 
-    public Object clone()
-    {
-        FSGradient anObject = (FSGradient)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
+		return length;
+	}
 
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(ratio, 1);
+		color.encode(coder);
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSGradient typedObject = (FSGradient)anObject;
-            
-            result = ratio == typedObject.ratio;
-
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;ratio&quot;, ratio);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 1;
-    
-        length += color.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(ratio, 1);
-        color.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        ratio = coder.readWord(1, false);
-        color = new FSColor(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		ratio = coder.readWord(1, false);
+		color = new FSColor(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSGradientFill.java
===================================================================
--- trunk/src/com/flagstone/transform/FSGradientFill.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSGradientFill.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,270 +33,360 @@
 import java.util.*;
 
 /**
-FSGradientFill defines how a colour changes across an area to be filled with colour. 
- 
-&lt;p&gt;Two types of gradient fill are supported:&lt;/p&gt;
+ * FSGradientFill defines how a colour changes across an area to be filled with
+ * colour.
+ * 
+ * &lt;p&gt;
+ * Two types of gradient fill are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Linear&lt;/td&gt;
+ * &lt;td&gt;The gradient changes in one direction across the area to be filled.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Radial&lt;/td&gt;
+ * &lt;td&gt;The gradient changes radially from the centre of the area to be filled.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Gradients are defined in terms of a standard space called the gradient
+ * square, centred at (0,0) and extending from (-16384, -16384) to (16384,
+ * 16384).
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/gradientSquare.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * A coordinate transform is required to map the gradient square to the
+ * coordinates of the filled area. The transformation is applied in two steps.
+ * First the gradient square is scaled so the colour covers the shape followed
+ * by a translation to map the gradient square coordinates to the coordinate
+ * range of the shape.
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;gradientMapping.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * A series of control points is used to control how the colour displayed
+ * changes across the gradient. At least two control points are required to
+ * define a gradient - one for the starting colour and one for the final colour.
+ * Up to eight control points may be specified to generate complex colour
+ * transitions. When the Flash Player displays the control points they are
+ * sorted by the ratio defined in each FSGradient object, with the smallest
+ * ratio value displayed first.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;The type of gradient fill, either FSFillStyle.Linear or
+ * FSFillStyle.Radial.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;A coordinate transformation used to map the gradient square into the
+ * coordinates of the area to be filled.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;gradients&lt;/td&gt;
+ * &lt;td&gt;An array of up to eight FSGradient objects that define the control
+ * points across the gradient square that control the colour transitions. The
+ * Flash Player performs the interpolation of the colour values between the
+ * control points.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In addition to specifying the type of gradient fill that will be displayed
+ * the type attribute may be used when iterating through an array of fill style
+ * objects to identify the type of fill style without using run-time type
+ * checking.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * For the coordinate transformation, the scaling factor is calculated by diving
+ * the width of the gradient square by the width of the shape:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * float gradientSquareWidth = 32768.0f;
+ * 
+ * float scale = gradientSquareWidth / shapeWidth;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The translation is defined by calculating the difference between the minimum
+ * coordinates of the &lt;em&gt;scaled&lt;/em&gt; gradient square and the minimum
+ * coordinates of the shape:
+ * 
+ * &lt;pre&gt;
+ * int gradientX = -16384; // minimum x coordinate of the gradient square.
+ * 
+ * int gradientY = -16384; // minimum y coordinate of the gradient square.
+ * 
+ * // Get the minimum coordinates of the shape being filled;
+ * int shapeX = shape.getBounds().getMinX();
+ * 
+ * int shapeY = shape.getBounds().getMinY();
+ * 
+ * // Now calculate the translation
+ * int translateX = shapeX - (gradientX / scale);
+ * 
+ * int translateY = shapeY - (gradientY / scale);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform has a convenient constructor to create the two-step
+ * transformation:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform composite = new FSCoordTransform(translateX, translateY,
+ * 				scale, scale);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The transform is independent of any transformation defined for the parent
+ * shape in which the gradient is displayed. The gradient will be displayed
+ * correctly if the shape is scaled, rotated, etc., when it is added to the
+ * display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSGradientFill class represents the FillStyle structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSGradientFill extends FSFillStyle
+{
+	private FSCoordTransform transform = null;
+	private ArrayList gradients = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSGradientFill object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSGradientFill(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;Linear&lt;/td&gt;
-&lt;td&gt;The gradient changes in one direction across the area to be filled.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGradientFill object specifying the type, coordinate
+	 * transform and array of gradient records.
+	 * 
+	 * @param aType
+	 *            the type of gradient fill, either FSFillStyle.Linear or
+	 *            FSFillStyle.Radial.
+	 * @param aTransform
+	 *            the coordinate transform mapping the gradient square onto
+	 *            physical coordinates.
+	 * @param anArray
+	 *            an array of up to eight FSGradient objects defining the
+	 *            control points for the gradient.
+	 */
+	public FSGradientFill(int aType, FSCoordTransform aTransform,
+							ArrayList anArray)
+	{
+		super(aType);
+		setTransform(aTransform);
+		setGradients(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;Radial&lt;/td&gt;
-&lt;td&gt;The gradient changes radially from the centre of the area to be filled.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSGradientFill object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSGradientFill object.
+	 */
+	public FSGradientFill(FSGradientFill obj)
+	{
+		super(obj);
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;/table&gt;
+		gradients = new ArrayList(obj.gradients.size());
 
-&lt;p&gt;Gradients are defined in terms of a  standard space called the gradient square, centred at (0,0) and extending from (-16384, -16384) to (16384, 16384).&lt;/p&gt;
+		for (Iterator i = obj.gradients.iterator(); i.hasNext();)
+			gradients.add(((FSGradient) i.next()).clone());
+	}
 
-&lt;img src=&quot;doc-files/gradientSquare.gif&quot;&gt;
+	/**
+	 * Add a FSGradient object to the array of gradient objects.
+	 * 
+	 * @param aGradient
+	 *            an FSGradient object.
+	 */
+	public void add(FSGradient aGradient)
+	{
+		gradients.add(aGradient);
+	}
 
-&lt;p&gt;A coordinate transform is required to map the gradient square to the coordinates of the filled area. The transformation is applied in two steps. First the gradient square is scaled so the colour covers the shape followed by a translation to map the gradient square coordinates to the coordinate range of the shape.&lt;/p&gt;
+	/**
+	 * Gets the coordinate transform mapping the gradient square onto physical
+	 * coordinates.
+	 * 
+	 * @return the coordinate transform.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;img src=&quot;gradientMapping.gif&quot;&gt;
+	/**
+	 * Gets the array of up to eight FSGradient objects defining the control
+	 * points for the gradient.
+	 * 
+	 * @return the array of control points.
+	 */
+	public ArrayList getGradients()
+	{
+		return gradients;
+	}
 
-&lt;p&gt;A series of control points is used to control how the colour displayed changes across the gradient. At least two control points are required to define a gradient - one for the starting colour and one for the final colour. Up to eight control points may be specified to generate complex colour transitions. When the Flash Player displays the control points they are sorted by the ratio defined in each FSGradient object, with the smallest ratio value displayed first.
-&lt;/p&gt;
+	/**
+	 * Sets the coordinate transform mapping the gradient square onto physical
+	 * coordinates.
+	 * 
+	 * @param aTransform
+	 *            the coordinate transform.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Sets the array of control points that define the gradient.
+	 * 
+	 * @param anArray
+	 *            an array of up to eight FSGradient objects.
+	 */
+	public void setGradients(ArrayList anArray)
+	{
+		gradients = anArray;
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	public Object clone()
+	{
+		FSGradientFill anObject = (FSGradientFill) super.clone();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSGradientFill_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The type of gradient fill, either FSFillStyle.Linear or FSFillStyle.Radial.&lt;/td&gt;
-&lt;/tr&gt;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGradientFill_1&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A coordinate transformation used to map the gradient square into the coordinates of the area to be filled.&lt;/td&gt;
-&lt;/tr&gt;
+		anObject.gradients = new ArrayList();
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSGradientFill_2&quot;&gt;gradients&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of up to eight FSGradient objects that define the control points across the gradient square that control the colour transitions. The Flash Player performs the interpolation of the colour values between the control points.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		for (Iterator i = gradients.iterator(); i.hasNext();)
+			anObject.gradients.add(((FSGradient) i.next()).clone());
 
-&lt;p&gt;In addition to specifying the type of gradient fill that will be displayed the type attribute may be used when iterating through an array of fill style objects to identify the type of fill style without using run-time type checking.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;For the coordinate transformation, the scaling factor is calculated by diving the width of the gradient square by the width of the shape:&lt;/p&gt;
+		if (super.equals(anObject))
+		{
+			FSGradientFill typedObject = (FSGradientFill) anObject;
 
-&lt;pre&gt;
-float gradientSquareWidth = 32768.0f;
-float scale = gradientSquareWidth / shapeWidth; 
-&lt;/pre&gt;
+			if (transform != null)
+				result = transform.equals(typedObject.transform);
+			else
+				result = transform == typedObject.transform;
 
-&lt;p&gt;The translation is defined by calculating the difference between the minimum coordinates of the &lt;em&gt;scaled&lt;/em&gt; gradient square and the minimum coordinates of the shape:
+			if (gradients != null)
+				result = result &amp;&amp; gradients.equals(typedObject.gradients);
+			else
+				result = result &amp;&amp; gradients == typedObject.gradients;
+		}
 
-&lt;pre&gt;
-int gradientX = -16384; // minimum x coordinate of the gradient square.
-int gradientY = -16384; // minimum y coordinate of the gradient square.
+		return result;
+	}
 
-// Get the minimum coordinates of the shape being filled;
-int shapeX = shape.getBounds().getMinX();
-int shapeY = shape.getBounds().getMinY();
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-// Now calculate the translation
-int translateX = shapeX - (gradientX / scale);
-int translateY = shapeY - (gradientY / scale);
-&lt;/pre&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			Transform.append(buffer, &quot;gradients&quot;, gradients, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSCoordTransform has a convenient constructor to create the two-step transformation:&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		int length = super.length(coder);
 
-&lt;pre&gt;
-FSCoordTransform composite = new FSCoordTransform(translateX, translateY, scale, scale);
-&lt;/pre&gt;
+		length += transform.length(coder);
+		length += 1;
 
-&lt;p&gt;The transform is independent of any transformation defined for the parent shape in which the gradient is displayed. The gradient will be displayed correctly if the shape is scaled, rotated, etc., when it is added to the display list.&lt;/p&gt;
+		for (Iterator gradientIterator = gradients.iterator(); gradientIterator
+						.hasNext();)
+			length += ((FSTransformObject) gradientIterator.next())
+							.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		return length;
+	}
 
-&lt;p&gt;The FSGradientFill class represents the FillStyle structure from the Macromedia Flash 
-(SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSGradientFill extends FSFillStyle
-{
-    private FSCoordTransform transform = null;
-    private ArrayList gradients = null;
-    
-    /**
-     * Construct an FSGradientFill object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSGradientFill(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**  Constructs an FSGradientFill object specifying the type, coordinate transform and array of gradient records.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param aType the type of gradient fill, either FSFillStyle.Linear or FSFillStyle.Radial.
-        @param aTransform the coordinate transform mapping the gradient square onto physical coordinates.
-        @param anArray an array of up to eight FSGradient objects defining the control points for the gradient.
-        */
-    public FSGradientFill(int aType, FSCoordTransform aTransform, ArrayList anArray)
-    {
-        super(aType);
-        setTransform(aTransform);
-        setGradients(anArray);
-    }
-    /**
-     * Constructs an FSGradientFill object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGradientFill object.
-     */
-    public FSGradientFill(FSGradientFill obj)
-    {
-        super(obj);
-        transform = new FSCoordTransform(obj.transform);
-        
-        gradients = new ArrayList(obj.gradients.size());
-        
-        for (Iterator i = obj.gradients.iterator(); i.hasNext();)
-            gradients.add(((FSGradient)i.next()).clone());
-    }    
+		transform.encode(coder);
+		coder.writeWord(gradients.size(), 1);
 
-    /** Add a FSGradient object to the array of gradient objects.
+		for (Iterator gradientIterator = gradients.iterator(); gradientIterator
+						.hasNext();)
+			((FSTransformObject) gradientIterator.next()).encode(coder);
+	}
 
-        @param aGradient an FSGradient object.
-        */
-    public void add(FSGradient aGradient) { gradients.add(aGradient); }
-    
-    /** Gets the coordinate transform mapping the gradient square onto physical coordinates.
+	public void decode(FSCoder coder)
+	{
+		int count = 0;
 
-        @return the coordinate transform.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+		super.decode(coder);
 
-    /** Gets the array of up to eight FSGradient objects defining the control points for the gradient.
+		transform = new FSCoordTransform(coder);
 
-        @return the array of control points.
-        */
-    public ArrayList getGradients()
-    {
-        return gradients;
-    }
-    
-    /** Sets the coordinate transform mapping the gradient square onto physical coordinates.
+		/*
+		 * A maximum of 8 gradients can be defined. A mask is applied to the
+		 * upper 4 bits as they are set in some files. The count is also limited
+		 * to 8 just in case there is an attempt at obfuscation.
+		 */
 
-        @param aTransform the coordinate transform.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+		count = coder.readWord(1, false) &amp; 0x0F;
 
-    /** Sets the array of control points that define the gradient.
+		if (count &gt; 8)
+			count -= 8;
 
-        @param anArray an array of up to eight FSGradient objects.
-        */
-    public void setGradients(ArrayList anArray)
-    {
-        gradients = anArray;
-    }
+		gradients = new ArrayList(count);
 
-    public Object clone()
-    {
-        FSGradientFill anObject = (FSGradientFill)super.clone();
-        
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-         
-        anObject.gradients = new ArrayList();
-            
-        for (Iterator i = gradients.iterator(); i.hasNext();)
-            anObject.gradients.add(((FSGradient)i.next()).clone());
-
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSGradientFill typedObject = (FSGradientFill)anObject;
-            
-            if (transform != null)
-                result = transform.equals(typedObject.transform);
-            else
-                result = transform == typedObject.transform;
-
-            if (gradients != null)
-                result = result &amp;&amp; gradients.equals(typedObject.gradients);
-            else
-                result = result &amp;&amp; gradients == typedObject.gradients;
-        }
-        
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;gradients&quot;, gradients, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = super.length(coder);
-    
-        length += transform.length(coder);
-        length += 1;
-    
-        for (Iterator gradientIterator = gradients.iterator(); gradientIterator.hasNext();) 
-            length += ((FSTransformObject)gradientIterator.next()).length(coder);
-
-         return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        transform.encode(coder);
-        coder.writeWord(gradients.size(), 1);
-    
-        for (Iterator gradientIterator = gradients.iterator(); gradientIterator.hasNext();) 
-            ((FSTransformObject)gradientIterator.next()).encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int count = 0;
-        
-        super.decode(coder);
-
-        transform = new FSCoordTransform(coder);
-        
-        /* 
-         * A maximum of 8 gradients can be defined. A mask is applied to the 
-         * upper 4 bits as they are set in some files. The count is also limited
-         * to 8 just in case there is an attempt at obfuscation.
-         */
-         
-        count = coder.readWord(1, false) &amp; 0x0F;
-        
-        if (count &gt; 8)
-            count -= 8;
-        
-        gradients = new ArrayList(count);
-
-        for (int i=0; i&lt;count; i++)
-            gradients.add(new FSGradient(coder));
-    }
+		for (int i = 0; i &lt; count; i++)
+			gradients.add(new FSGradient(coder));
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSHeader.java
===================================================================
--- trunk/src/com/flagstone/transform/FSHeader.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSHeader.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -1,4 +1,5 @@
 package com.flagstone.transform;
+
 /*
  * FSHeader.java
  * 
@@ -32,288 +33,320 @@
 import java.io.*;
 
 /**
- * The FSHeader class can be used to quickly decode the header information in
- * a flash file to get information about the number of frames, screen size
- * etc. Only the first few bytes are decoded so this avoid the cost of using 
- * the FSMovie class which decodes all the data structures. However if a file
- * is compressed then the entire contents will have to be unzipped first in
- * order to decode the header information.
+ * The FSHeader class can be used to quickly decode the header information in a
+ * flash file to get information about the number of frames, screen size etc.
+ * Only the first few bytes are decoded so this avoid the cost of using the
+ * FSMovie class which decodes all the data structures. However if a file is
+ * compressed then the entire contents will have to be unzipped first in order
+ * to decode the header information.
  * 
- * Note: The coordinate system used for the screen extends from the TOP LEFT 
+ * Note: The coordinate system used for the screen extends from the TOP LEFT
  * corner with the positive x-axis extending to the left and the positive y-axis
  * extending DOWN, unlike &quot;traditional&quot; Cartesian systems. The (minX, minY) and
- * (maxX, maxY) coordinates specify the range of values used for the x and y 
- * axes. (minX, minY) is often (0,0) but may contain any positive or negative 
+ * (maxX, maxY) coordinates specify the range of values used for the x and y
+ * axes. (minX, minY) is often (0,0) but may contain any positive or negative
  * values.
  */
 public final class FSHeader
 {
-    private String signature = null;
-    private int version = 0;
-    private int minX = 0;
-    private int minY = 0;
-    private int maxX = 0;
-    private int maxY = 0;
-    private int length = 0;
-    private float frameRate = 0.0f;
-    private int frameCount = 0;
-    
-    /**
-     * Create a new FSHeader object and initialize it with the information
-     * decoded from the Flash file.
-     * 
-     * @param filename the path to a file.
-     * 
-     * @throws FileNotFoundException if the file referenced by the path does 
-     * not exist or refers to a directory.
-     * 
-     * @throws IOException if there is an error reading the file.
-     * 
-     * @throws DataFormatException if the file is not a flash file or there is
-     * an error unzipping a compressed flash file.
-     */
-    public FSHeader(String filename) throws IOException, DataFormatException
-    {
-        decodeFromFile(filename);
-    }
-    
-    /**
-     * Create a new FSHeader object and initialize it with the information
-     * decoded from the Flash file.
-     * 
-     * @param file a File containing the abstract path to a file.
-     * 
-     * @throws FileNotFoundException if the file referenced by the path does 
-     * not exist or refers to a directory.
-     * 
-     * @throws IOException if there is an error reading the file.
-     * 
-     * @throws DataFormatException if the file is not a flash file or there is
-     * an error unzipping a compressed flash file.
-     */
-    public FSHeader(File file) throws IOException, DataFormatException
-    {
-        decodeFromFile(file);
-    }
+	private String signature = null;
 
-    /**
-     * Create a new FSHeader object and initialize it with the information
-     * decoded from the binary data.
-     *
-     * @param bytes the encoded binary data from a Flash file.
-     * 
-     * @throws DataFormatException if the data is not in the flash format or 
-     * there is an error unzipping the data if it is compressed.
-     */
-    public FSHeader(byte[] bytes) throws IOException, DataFormatException
-    {
-        decodeFromData(bytes);
-    }
+	private int version = 0;
 
-    /**
-     * Return the signature used to identify the file type: &quot;FWS&quot; (&quot;SWF&quot; in 
-     * reverse) for regular Flash files or &quot;CWS&quot; for compressed (zipped) Flash
-     * files.
-     * 
-     * @return the signature used to identify the file as a Flash file.
-     */
-    public String getSignature()
-    {
-        return signature;
-    }
+	private int minX = 0;
 
-    /**
-     * Return the version number of Flash format used n the file.
-     * 
-     * @return the Flash version number
-     */
-    public int getVersion()
-    {
-        return version;
-    }
+	private int minY = 0;
 
-    /**
-     * Return the length in bytes of the file when uncompressed.
-     * 
-     * @return the length of the (uncompressed) file in bytes.
-     */
-    public int getLength()
-    {
-        return length;
-    }
+	private int maxX = 0;
 
-    /**
-     * Return the x-coordinate of the top left corner of the screen.
-     * 
-     * @return the x-coordinate of the top left corner
-     */
-    public int getMinX() 
-    {
-        return minX;
-    }
+	private int maxY = 0;
 
-    /**
-     * Return the x-coordinate of the bottom right corner of the screen.
-     * 
-     * @return the x-coordinate of the bottom right corner
-     */
-    public int getMaxX() 
-    {
-        return maxX;
-    }
+	private int length = 0;
 
-    /**
-     * The y-coordinate of the top left corner of the screen.
-     * 
-     * @return the y-coordinate of the top left corner
-     */
-    public int getMinY() 
-    {
-        return minY;
-    }
+	private float frameRate = 0.0f;
 
-    /**
-     * The y-coordinate of the bottom right corner of the screen.
-     * 
-     * @return the y-coordinate of the bottom right corner
-     */
-    public int getMaxY()
-    {
-        return maxY;
-    }
+	private int frameCount = 0;
 
-    /**
-     * Return the number of frames per second at which the Flash Player will 
-     * attempt to display the file.
-     * 
-     * @return the frame rate in frames per second.
-     */
-    public float getFrameRate()
-    {
-        return frameRate;
-    }
+	/**
+	 * Create a new FSHeader object and initialize it with the information
+	 * decoded from the Flash file.
+	 * 
+	 * @param filename
+	 *            the path to a file.
+	 * 
+	 * @throws FileNotFoundException
+	 *             if the file referenced by the path does not exist or refers
+	 *             to a directory.
+	 * 
+	 * @throws IOException
+	 *             if there is an error reading the file.
+	 * 
+	 * @throws DataFormatException
+	 *             if the file is not a flash file or there is an error
+	 *             unzipping a compressed flash file.
+	 */
+	public FSHeader(String filename) throws IOException, DataFormatException
+	{
+		decodeFromFile(filename);
+	}
 
-    /**
-     * Return the number of frames in the movie.
-     * 
-     * @return the number of frames in the movie
-     */
-    public int getNumberOfFrames()
-    {
-        return frameCount;
-    }
+	/**
+	 * Create a new FSHeader object and initialize it with the information
+	 * decoded from the Flash file.
+	 * 
+	 * @param file
+	 *            a File containing the abstract path to a file.
+	 * 
+	 * @throws FileNotFoundException
+	 *             if the file referenced by the path does not exist or refers
+	 *             to a directory.
+	 * 
+	 * @throws IOException
+	 *             if there is an error reading the file.
+	 * 
+	 * @throws DataFormatException
+	 *             if the file is not a flash file or there is an error
+	 *             unzipping a compressed flash file.
+	 */
+	public FSHeader(File file) throws IOException, DataFormatException
+	{
+		decodeFromFile(file);
+	}
 
-    /**
-     * Initialize the FSHeader object with the specified flash file.
-     * 
-     * @param fileName the path to a file.
-     * 
-     * @throws FileNotFoundException if the file referenced by the path does 
-     * not exist or refers to a directory.
-     * 
-     * @throws IOException if there is an error reading the file.
-     * 
-     * @throws DataFormatException if the file is not a flash file or there is
-     * an error unzipping a compressed flash file.
-     */
-    public void decodeFromFile(String fileName) throws IOException, DataFormatException
-    {
-        decodeFromFile(new File(fileName));
-    }
-    
-    /**
-     * Initialize the FSHeader object with the specified flash file.
-     * 
-     * @param file a File containing the abstract path to a file.
-     * 
-     * @throws FileNotFoundException if the file referenced by the path does 
-     * not exist or refers to a directory.
-     * 
-     * @throws IOException if there is an error reading the file.
-     * 
-     * @throws DataFormatException if the file is not a flash file or there is
-     * an error unzipping a compressed flash file.
-     */
-    public void decodeFromFile(File file) throws IOException, DataFormatException
-    {
-        FileInputStream fileContents = new FileInputStream(file);
-        
-        int fileLength = (int)file.length();
-        byte[] contents = new byte[fileLength];
-        
-        fileContents.read(contents);
-        fileContents.close();
-        
-        decodeFromData(contents);
-    }
+	/**
+	 * Create a new FSHeader object and initialize it with the information
+	 * decoded from the binary data.
+	 * 
+	 * @param bytes
+	 *            the encoded binary data from a Flash file.
+	 * 
+	 * @throws DataFormatException
+	 *             if the data is not in the flash format or there is an error
+	 *             unzipping the data if it is compressed.
+	 */
+	public FSHeader(byte[] bytes) throws IOException, DataFormatException
+	{
+		decodeFromData(bytes);
+	}
 
-    /**
-     * Initialize the FSHeader object with binary flash data.
-     * 
-     * @param bytes the encoded binary data from a Flash file.
-     * 
-     * @throws DataFormatException if the data is not in the flash format or 
-     * there is an error unzipping the data if it is compressed.
-     */
-    public void decodeFromData(byte[] bytes) throws DataFormatException
-    {
-        FSCoder coder = null;
+	/**
+	 * Return the signature used to identify the file type: &quot;FWS&quot; (&quot;SWF&quot; in
+	 * reverse) for regular Flash files or &quot;CWS&quot; for compressed (zipped) Flash
+	 * files.
+	 * 
+	 * @return the signature used to identify the file as a Flash file.
+	 */
+	public String getSignature()
+	{
+		return signature;
+	}
 
-        isFlash(bytes);
+	/**
+	 * Return the version number of Flash format used n the file.
+	 * 
+	 * @return the Flash version number
+	 */
+	public int getVersion()
+	{
+		return version;
+	}
 
-        if (bytes[0] == 0x43)
-            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
-        else
-            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
-        
-        signature = coder.readString(3, &quot;UTF8&quot;);
-        version = coder.readWord(1, false);
-        length = coder.readWord(4, false);
+	/**
+	 * Return the length in bytes of the file when uncompressed.
+	 * 
+	 * @return the length of the (uncompressed) file in bytes.
+	 */
+	public int getLength()
+	{
+		return length;
+	}
 
-        coder.alignToByte();
-        
-        int fieldSize = coder.readBits(5, false);
-        
-        minX = coder.readBits(fieldSize, true);
-        maxX = coder.readBits(fieldSize, true);
-        minY = coder.readBits(fieldSize, true);
-        maxY = coder.readBits(fieldSize, true);
-        
-        coder.alignToByte();
+	/**
+	 * Return the x-coordinate of the top left corner of the screen.
+	 * 
+	 * @return the x-coordinate of the top left corner
+	 */
+	public int getMinX()
+	{
+		return minX;
+	}
 
-        frameRate = coder.readFixedWord(1, 1);
-        frameCount = coder.readWord(2, false);
-    }
-    
-    private void isFlash(byte[] bytes) throws DataFormatException
-    {
-        if (bytes == null || bytes.length &lt; 8)
-            throw new DataFormatException(&quot;Flash data is null or empty.&quot;);
-            
-        boolean isFlash = (bytes[0] == 0x43 || bytes[0] == 0x46) &amp;&amp; bytes[1] == 0x57 &amp;&amp; bytes[2] == 0x53;
-                
-        if (isFlash == false)
-            throw new DataFormatException(&quot;Data does not start with a valid Flash signature.&quot;);
-    }
-    
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        int movieLength = 0;
+	/**
+	 * Return the x-coordinate of the bottom right corner of the screen.
+	 * 
+	 * @return the x-coordinate of the bottom right corner
+	 */
+	public int getMaxX()
+	{
+		return maxX;
+	}
 
-        for (int i=0; i&lt;4; i++)
-            movieLength += (bytes[i+4] &amp; 0x000000FF) &lt;&lt; (i*8);
-            
-        byte[] data = new byte[movieLength];
-        
-        // copy the uncompressed signature, version and length
-        
-        for (int i=0; i&lt;8; i++)
-            data[i] = bytes[i];            
-        
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes, 8, bytes.length-8);
-        inflater.inflate(data, 8, movieLength-8);
+	/**
+	 * The y-coordinate of the top left corner of the screen.
+	 * 
+	 * @return the y-coordinate of the top left corner
+	 */
+	public int getMinY()
+	{
+		return minY;
+	}
 
-        return data;
-    }
+	/**
+	 * The y-coordinate of the bottom right corner of the screen.
+	 * 
+	 * @return the y-coordinate of the bottom right corner
+	 */
+	public int getMaxY()
+	{
+		return maxY;
+	}
+
+	/**
+	 * Return the number of frames per second at which the Flash Player will
+	 * attempt to display the file.
+	 * 
+	 * @return the frame rate in frames per second.
+	 */
+	public float getFrameRate()
+	{
+		return frameRate;
+	}
+
+	/**
+	 * Return the number of frames in the movie.
+	 * 
+	 * @return the number of frames in the movie
+	 */
+	public int getNumberOfFrames()
+	{
+		return frameCount;
+	}
+
+	/**
+	 * Initialize the FSHeader object with the specified flash file.
+	 * 
+	 * @param fileName
+	 *            the path to a file.
+	 * 
+	 * @throws FileNotFoundException
+	 *             if the file referenced by the path does not exist or refers
+	 *             to a directory.
+	 * 
+	 * @throws IOException
+	 *             if there is an error reading the file.
+	 * 
+	 * @throws DataFormatException
+	 *             if the file is not a flash file or there is an error
+	 *             unzipping a compressed flash file.
+	 */
+	public void decodeFromFile(String fileName) throws IOException,
+					DataFormatException
+	{
+		decodeFromFile(new File(fileName));
+	}
+
+	/**
+	 * Initialize the FSHeader object with the specified flash file.
+	 * 
+	 * @param file
+	 *            a File containing the abstract path to a file.
+	 * 
+	 * @throws FileNotFoundException
+	 *             if the file referenced by the path does not exist or refers
+	 *             to a directory.
+	 * 
+	 * @throws IOException
+	 *             if there is an error reading the file.
+	 * 
+	 * @throws DataFormatException
+	 *             if the file is not a flash file or there is an error
+	 *             unzipping a compressed flash file.
+	 */
+	public void decodeFromFile(File file) throws IOException,
+					DataFormatException
+	{
+		FileInputStream fileContents = new FileInputStream(file);
+
+		int fileLength = (int) file.length();
+		byte[] contents = new byte[fileLength];
+
+		fileContents.read(contents);
+		fileContents.close();
+
+		decodeFromData(contents);
+	}
+
+	/**
+	 * Initialize the FSHeader object with binary flash data.
+	 * 
+	 * @param bytes
+	 *            the encoded binary data from a Flash file.
+	 * 
+	 * @throws DataFormatException
+	 *             if the data is not in the flash format or there is an error
+	 *             unzipping the data if it is compressed.
+	 */
+	public void decodeFromData(byte[] bytes) throws DataFormatException
+	{
+		FSCoder coder = null;
+
+		isFlash(bytes);
+
+		if (bytes[0] == 0x43)
+			coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
+		else
+			coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
+
+		signature = coder.readString(3, &quot;UTF8&quot;);
+		version = coder.readWord(1, false);
+		length = coder.readWord(4, false);
+
+		coder.alignToByte();
+
+		int fieldSize = coder.readBits(5, false);
+
+		minX = coder.readBits(fieldSize, true);
+		maxX = coder.readBits(fieldSize, true);
+		minY = coder.readBits(fieldSize, true);
+		maxY = coder.readBits(fieldSize, true);
+
+		coder.alignToByte();
+
+		frameRate = coder.readFixedWord(1, 1);
+		frameCount = coder.readWord(2, false);
+	}
+
+	private void isFlash(byte[] bytes) throws DataFormatException
+	{
+		if (bytes == null || bytes.length &lt; 8)
+			throw new DataFormatException(&quot;Flash data is null or empty.&quot;);
+
+		boolean isFlash = (bytes[0] == 0x43 || bytes[0] == 0x46)
+						&amp;&amp; bytes[1] == 0x57 &amp;&amp; bytes[2] == 0x53;
+
+		if (isFlash == false)
+			throw new DataFormatException(
+							&quot;Data does not start with a valid Flash signature.&quot;);
+	}
+
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		int movieLength = 0;
+
+		for (int i = 0; i &lt; 4; i++)
+			movieLength += (bytes[i + 4] &amp; 0x000000FF) &lt;&lt; (i * 8);
+
+		byte[] data = new byte[movieLength];
+
+		// copy the uncompressed signature, version and length
+
+		for (int i = 0; i &lt; 8; i++)
+			data[i] = bytes[i];
+
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes, 8, bytes.length - 8);
+		inflater.inflate(data, 8, movieLength - 8);
+
+		return data;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSIf.java
===================================================================
--- trunk/src/com/flagstone/transform/FSIf.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSIf.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,138 +31,183 @@
 package com.flagstone.transform;
 
 /**
-The FSIf action is used to perform a conditional branch to control the actions executed 
-by the Flash Player. 
- 
-&lt;p&gt;When executed, the FSIf action pops a value from the stack and evaluates it to see whether it evaluates as true or false. If the boolean value is true the offset attribute of the FSIf action is added to the Flash Player's instruction pointer and execution of the stream of actions continues from that location. If the boolean value is false then no branch is taken.&lt;/p&gt;
+ * The FSIf action is used to perform a conditional branch to control the
+ * actions executed by the Flash Player.
+ * 
+ * &lt;p&gt;
+ * When executed, the FSIf action pops a value from the stack and evaluates it
+ * to see whether it evaluates as true or false. If the boolean value is true
+ * the offset attribute of the FSIf action is added to the Flash Player's
+ * instruction pointer and execution of the stream of actions continues from
+ * that location. If the boolean value is false then no branch is taken.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Although the Flash Player contains an instruction pointer it does not support
+ * an explicit address space. The instruction pointer is used to reference
+ * actions within the current stream of actions being executed whether they are
+ * associated with a given frame, button or movie clip. The value contained in
+ * the instruction pointer is the address relative to the start of the current
+ * stream.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;offset&lt;/td&gt;
+ * &lt;td&gt;The offset, relative to the current instruction pointer, to jump to if
+ * the value on the Stack evaluates to true.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The offset is a signed number, allowing branches up to -32768 to 32767 bytes.
+ * The instruction pointer points to the next instruction in the stream of
+ * actions being executed so specifying an offset of zero will have no effect on
+ * the sequence of instructions executed.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * If the value popped off the stack is a number it is evaluated as true if it
+ * is non-zero. If the value is a string it is evaluated to true if it is not an
+ * empty string (&quot;&quot;) or the strings &quot;0&quot; or &quot;false&quot;.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(&quot;a&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(3));
+ * actions.add(FSAction.Equals());
+ * actions.add(new FSIf(32));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSIf class represents the ActionIf action of the Macromedia Flash (SWF)
+ * File Format Specification. It was introduced in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSIf extends FSActionObject
+{
+	private int offset = 0;
 
-&lt;p&gt;Although the Flash Player contains an instruction pointer it does not support an explicit address space. The instruction pointer is used to reference actions within the current stream of actions being executed whether they are associated with a given frame, button or movie clip. The value contained in the instruction pointer is the address relative to the start of the current stream.&lt;/p&gt;
+	/**
+	 * Construct an FSIf object, initializing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSIf(FSCoder coder)
+	{
+		super(If);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an if action with the specified offset. The offset must be in
+	 * the range -32768..32767.
+	 * 
+	 * @param anOffset
+	 *            the number of bytes to add to the instruction pointer if the
+	 *            value popped off the stack evaluates to true.
+	 */
+	public FSIf(int anOffset)
+	{
+		super(If);
+		setOffset(anOffset);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSIf object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSIf object.
+	 */
+	public FSIf(FSIf obj)
+	{
+		super(obj);
+		offset = obj.offset;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSIf_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the offset that will be added to the instruction pointer if the
+	 * value at the top of the stack evaluates to true (non-zero).
+	 * 
+	 * @return the number of bytes representing the offset.
+	 */
+	public int getOffset()
+	{
+		return offset;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSIf_1&quot;&gt;offset&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The offset, relative to the current instruction pointer, to jump to if the value on the Stack evaluates to true.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Sets the offset to add to the instruction pointer if the value at the top
+	 * of the stack evaluates to true (non-zero). The offset must be in the
+	 * range -32768..32767.
+	 * 
+	 * @param aNumber
+	 *            the number of bytes to add to the instruction pointer.
+	 */
+	public void setOffset(int aNumber)
+	{
+		offset = aNumber;
+	}
 
-&lt;p&gt;The offset is a signed number, allowing branches up to -32768 to 32767 bytes. The instruction pointer points to the next instruction in the stream of actions being executed so specifying an offset of zero will have no effect on the sequence of instructions executed.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;If the value popped off the stack is a number it is evaluated as true if it is non-zero. If the value is a string it is evaluated to true if it is not an empty string (&quot;&quot;) or the strings &quot;0&quot; or &quot;false&quot;.&lt;/p&gt;
+		if (super.equals(anObject))
+			result = offset == ((FSIf) anObject).getOffset();
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+		return result;
+	}
 
-actions.add(new FSPush(&quot;a&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(3));
-actions.add(FSAction.Equals());
-actions.add(new FSIf(32));
-&lt;/pre&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;offset&quot;, offset);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSIf class represents the ActionIf action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSIf extends FSActionObject
-{
-    private int offset = 0;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /**
-     * Construct an FSIf object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSIf(FSCoder coder)
-    {
-        super(If);
-        decode(coder);
-    }
-    /** Constructs an if action with the specified offset. The offset must be in the range  -32768..32767.
+		length += 2;
 
-        @param anOffset the number of bytes to add to the instruction pointer if the value popped off the stack evaluates to true.
-        */    
-    public FSIf(int anOffset)
-    {
-        super(If);
-        setOffset(anOffset);
-    }
-    /**
-     * Constructs an FSIf object by copying values from an existing object.
-     *
-     * @param obj an FSIf object.
-     */
-    public FSIf(FSIf obj)
-    {
-        super(obj);
-        offset = obj.offset;
-    }    
+		return length;
+	}
 
-    /** Gets the offset that will be added to the instruction pointer if the value at the top of the stack evaluates to true (non-zero).
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(offset, 2);
+		coder.endObject(name());
+	}
 
-        @return the number of bytes representing the offset.
-        */
-    public int getOffset() { return offset; }
-
-    /** Sets the offset to add to the instruction pointer if the value at the top of the stack evaluates to true (non-zero). The offset must be in the range  -32768..32767.
-
-        @param aNumber the number of bytes to add to the instruction pointer.
-        */
-    public void setOffset(int aNumber)
-    {
-        offset = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = offset == ((FSIf)anObject).getOffset();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;offset&quot;, offset);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(offset, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        offset = coder.readWord(2, true);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		offset = coder.readWord(2, true);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSImageBlock.java
===================================================================
--- trunk/src/com/flagstone/transform/FSImageBlock.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSImageBlock.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -4,17 +4,17 @@
 import java.util.zip.Inflater;
 
 /**
- * When an image is sent in a ScreenVideo stream only pixel information for the 
- * portions of the image that change are sent. FSImageBlock is used to sub-divide
- * an image into a set of blocks. The blocks from successive frames can then 
- * be compared to determine which blocks are encoded in the stream.
+ * When an image is sent in a ScreenVideo stream only pixel information for the
+ * portions of the image that change are sent. FSImageBlock is used to
+ * sub-divide an image into a set of blocks. The blocks from successive frames
+ * can then be compared to determine which blocks are encoded in the stream.
  * 
  * An image is divided by tiling the blocks across the image from top-left to
  * bottom right. If the image is not covered an integer number of blocks then
- * the size of the blocks along the right and bottom edges of the image are 
+ * the size of the blocks along the right and bottom edges of the image are
  * reduced in size.
  * 
- * The FSImageBlock is a contains class for the image data and is used in 
+ * The FSImageBlock is a contains class for the image data and is used in
  * conjunction with the FsStreamVideoPacket class.
  */
 public class FSImageBlock implements Cloneable
@@ -27,120 +27,124 @@
 	 * Create a new image block with the specified width and height and image
 	 * data. The image is compressed using the zip format.
 	 * 
-	 * @param width the width of the block in pixels.
-	 * @param height the height of the block in pixels
-	 * @param data the pixels covered by the block, compressed using the zip 
-	 * format.
+	 * @param width
+	 *            the width of the block in pixels.
+	 * @param height
+	 *            the height of the block in pixels
+	 * @param data
+	 *            the pixels covered by the block, compressed using the zip
+	 *            format.
 	 */
-    public FSImageBlock(int width, int height, byte[] data)
+	public FSImageBlock(int width, int height, byte[] data)
 	{
-    	this.width = width;
-    	this.height = height;
-    	block = data;
+		this.width = width;
+		this.height = height;
+		block = data;
 	}
-	
-    /**
-     * Return the width of the block. although the block size is specified in 
-     * parent FSScreenVideoPacket object the actual block size used may vary
-     * if the tiled array of blocks overlaps the edge of the image.
-     * 
-     * @return the width of the block in pixels.
-     */
-    public int getWidth() 
-    {
-        return width;
-    }
 
-    /**
-     * Return the height of the block. although the block size is specified in 
-     * parent FSScreenVideoPacket object the actual block size used may vary
-     * if the tiled array of blocks overlaps the edge of the image.
-     * 
-     * @return the height of the block in pixels.
-     */
-    public int getHeight() 
-    {
-        return height;
-    }
+	/**
+	 * Return the width of the block. although the block size is specified in
+	 * parent FSScreenVideoPacket object the actual block size used may vary if
+	 * the tiled array of blocks overlaps the edge of the image.
+	 * 
+	 * @return the width of the block in pixels.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-    /**
-     * Returns the zipped image data for the block.
-     * 
-     * @return an array of bytes containing the portion of the image in the 
-     * block.
-     */
-    public byte[] getData() 
-    {
-        return block;
-    }
-    
-    /**
-     * When a ScreenVideo stream is created only the image blocks that change
-     * are included. The blocks that do not change are encoded as empty blocks
-     * which have width and height of zero and do not contain any image data.
-     * This convenience method is used to determine when an image block contains
-     * any valid image data.
-     * 
-     * @return true if the block covers an area of the image that changed or 
-     * false if no image data is included.
-     */
-    public boolean isEmpty()
-    {
-    	return width == 0 || height == 0 || block == null || block.length == 0;
-    }
+	/**
+	 * Return the height of the block. although the block size is specified in
+	 * parent FSScreenVideoPacket object the actual block size used may vary if
+	 * the tiled array of blocks overlaps the edge of the image.
+	 * 
+	 * @return the height of the block in pixels.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-    public Object clone()
-    {
-    	return new FSImageBlock(width, height, block);
-    }
-    
-    public boolean equals(Object anObject)
-    {
-        if (anObject == null) {
-        	return false;
-        }
-        
-        if (this == anObject) {
-        	return true;
-        }
-        
-        boolean result = false;
-        
-        if (anObject instanceof FSImageBlock)
-        {
-            FSImageBlock typedObject = (FSImageBlock)anObject;
-            
-            try
-            {
-                result = width == typedObject.width;
-                result = result &amp;&amp; height == typedObject.height;
-                
-            	byte[] a = unzip(block);
-            	byte[] b = unzip(typedObject.block);
-            	
-                result = result &amp;&amp; Transform.equals(a, b);
-            }
-            catch (DataFormatException e)
-            {
-            	result = false;
-            }
-        }
-        return result;
-    }
+	/**
+	 * Returns the zipped image data for the block.
+	 * 
+	 * @return an array of bytes containing the portion of the image in the
+	 *         block.
+	 */
+	public byte[] getData()
+	{
+		return block;
+	}
 
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        byte[] data = new byte[width*height*3];
-        int count = 0;
-        
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes);
-        count = inflater.inflate(data);
-        
-        byte[] uncompressedData = new byte[count];
-        
-        System.arraycopy(data, 0, uncompressedData, 0, count);
+	/**
+	 * When a ScreenVideo stream is created only the image blocks that change
+	 * are included. The blocks that do not change are encoded as empty blocks
+	 * which have width and height of zero and do not contain any image data.
+	 * This convenience method is used to determine when an image block contains
+	 * any valid image data.
+	 * 
+	 * @return true if the block covers an area of the image that changed or
+	 *         false if no image data is included.
+	 */
+	public boolean isEmpty()
+	{
+		return width == 0 || height == 0 || block == null || block.length == 0;
+	}
 
-        return uncompressedData;
-    }
+	public Object clone()
+	{
+		return new FSImageBlock(width, height, block);
+	}
+
+	public boolean equals(Object anObject)
+	{
+		if (anObject == null)
+		{
+			return false;
+		}
+
+		if (this == anObject)
+		{
+			return true;
+		}
+
+		boolean result = false;
+
+		if (anObject instanceof FSImageBlock)
+		{
+			FSImageBlock typedObject = (FSImageBlock) anObject;
+
+			try
+			{
+				result = width == typedObject.width;
+				result = result &amp;&amp; height == typedObject.height;
+
+				byte[] a = unzip(block);
+				byte[] b = unzip(typedObject.block);
+
+				result = result &amp;&amp; Transform.equals(a, b);
+			} catch (DataFormatException e)
+			{
+				result = false;
+			}
+		}
+		return result;
+	}
+
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		byte[] data = new byte[width * height * 3];
+		int count = 0;
+
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes);
+		count = inflater.inflate(data);
+
+		byte[] uncompressedData = new byte[count];
+
+		System.arraycopy(data, 0, uncompressedData, 0, count);
+
+		return uncompressedData;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSImport.java
===================================================================
--- trunk/src/com/flagstone/transform/FSImport.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSImport.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,238 +33,290 @@
 import java.util.*;
 
 /**
-FSImport is used to import shapes and other objects from another Flash file. 
+ * FSImport is used to import shapes and other objects from another Flash file.
+ * 
+ * &lt;p&gt;
+ * Since the identifier for an object is only unique within a given Flash file,
+ * imported objects are referenced by a name assigned when the object is
+ * exported.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Attribute&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;url&lt;/td&gt;
+ * &lt;td&gt;The URL of the file containing the object to be imported. The URL must
+ * be in the same sub-domain and relative to the URL of the Flash file
+ * containing the file importing the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;A HashTable containing key-value pairs where the key is the identifier
+ * of the object being imported and the value is name assigned to the object
+ * when it was exported into a Flash file.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * To provide a degree of security the Flash Player will only import files that
+ * originate from the same domain as the file that it is currently playing. For
+ * example if the Flash file being shown was loaded from
+ * www.mydomain.com/flash.swf then the file contains the exported objects must
+ * reside somewhere at www.mydomain.com. This prevents a malicious Flash file
+ * from loading files from an unknown third party.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * To export an object from a Flash file:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSDefineShape(...);
+ * 
+ *  movie.add(shape);
+ *  movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The object can then be imported:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSImport class represents the ImportAssets data structure in the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5.
+ * &lt;/p&gt;
+ */
+public class FSImport extends FSMovieObject
+{
+	private String url = null;
+	private Hashtable objects = new Hashtable();
 
-&lt;p&gt;Since the identifier for an object is only unique within a given Flash file, imported objects are referenced by a name assigned when the object is exported.&lt;/p&gt;
+	FSImport()
+	{
+		super(Import);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSImport object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSImport(FSCoder coder)
+	{
+		super(Import);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;th align=&quot;left&quot;&gt;Attribute&lt;/th&gt;
-&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSImport object that imports an object from the specified
+	 * file. The exported object is referenced by a name assigned to it when it
+	 * was exported. The newly imported object must be assigned an identifier
+	 * that is unique within the movie the object is imported into. Limited
+	 * security is provided by requiring that the URL must be in the same domain
+	 * or sub-domain as the URL of the movie which contains this object.
+	 * 
+	 * @param aUrl
+	 *            the URL referencing the file to be imported.
+	 * @param anIdentifier
+	 *            the identifier of the object to be exported.
+	 * @param aString
+	 *            the name of the exported object to allow it to be referenced.
+	 */
+	public FSImport(String aUrl, int anIdentifier, String aString)
+	{
+		super(Import);
+		setUrl(aUrl);
+		add(anIdentifier, aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSImport_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSImport object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSImport object.
+	 */
+	public FSImport(FSImport obj)
+	{
+		super(obj);
+		url = new String(obj.url);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSImport_1&quot;&gt;url&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The URL of the file containing the object to be imported. The URL must be in the same sub-domain and relative to the URL of the Flash file containing the file importing the object.&lt;/td&gt;
-&lt;/tr&gt;
+		objects = new Hashtable(obj.objects.size());
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSImport_2&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A HashTable containing key-value pairs where the key is the identifier of the object being imported and the value is name assigned to the object when it was exported into a Flash file.&lt;/td&gt;
-&lt;/tr&gt;
+		for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
+		{
+			Object key = i.next();
+			objects.put(key, new String((String) objects.get(key)));
+		}
+	}
 
-&lt;/table&gt;
+	/**
+	 * Adds the identifier and name to the list of objects to be imported.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object to be imported.
+	 * @param aString
+	 *            the name of the imported object to allow it to be referenced.
+	 */
+	public void add(int anIdentifier, String aString)
+	{
+		objects.put(new Integer(anIdentifier), aString);
+	}
 
-&lt;p&gt;To provide a degree of security the Flash Player will only import files that originate from the same domain as the file that it is currently playing. For example if the Flash file being shown was loaded from www.mydomain.com/flash.swf then the file contains the exported objects must reside somewhere at www.mydomain.com. This prevents a malicious Flash file from loading files from an unknown third party.&lt;/p&gt;
+	/**
+	 * Gets the URL of the file containing the object to be imported. Limited
+	 * security is provided by requiring that the URL must be in the same domain
+	 * or sub-domain as the URL of the movie which contains this object.
+	 * 
+	 * @return the URL of the file containing the object to be imported.
+	 */
+	public String getUrl()
+	{
+		return url;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Gets the table of objects to be imported.
+	 * 
+	 * @return the table of imported objects.
+	 */
+	public Hashtable getObjects()
+	{
+		return objects;
+	}
 
-&lt;p&gt;To export an object from a Flash file:&lt;/p&gt;
+	/**
+	 * Sets the URL of the file containing the imported objects. The URL must be
+	 * in the same sub-domain and relative to the URL of the file containing the
+	 * FSImport object.
+	 * 
+	 * @param aString
+	 *            a URL relative to the URL of the file containing the FSImport
+	 *            object.
+	 */
+	public void setUrl(String aString)
+	{
+		url = aString;
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(...);
+	/**
+	 * Sets the table of objects to be imported.
+	 * 
+	 * @param aTable
+	 *            the table of objects being imported.
+	 */
+	public void setObjects(Hashtable aTable)
+	{
+		objects = aTable;
+	}
 
-movie.add(shape);
-movie.add(new FSExport(shape.getIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The object can then be imported:&lt;/p&gt;
+		if (super.equals(anObject))
+		{
+			if (url != null)
+				result = url.equals(((FSImport) anObject).getUrl());
+			else
+				result = ((FSImport) anObject).getUrl() == null;
 
-&lt;pre&gt;
-movie.add(new FSImport(&quot;exportFile.swf&quot;, movie.newIdentifier(), &quot;Shape&quot;));
-&lt;/pre&gt;
+			result = result
+							&amp;&amp; objects.equals(((FSImport) anObject)
+											.getObjects());
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;The FSImport class represents the ImportAssets data structure in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSImport extends FSMovieObject
-{
-    private String url = null;
-    private Hashtable objects = new Hashtable();
-        
-    FSImport()
-    {
-        super(Import);
-    }
-    /**
-     * Construct an FSImport object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSImport(FSCoder coder)
-    {
-        super(Import);
-        decode(coder);
-    }
-    /** Constructs an FSImport object that imports an object from the specified file. The exported object is referenced by a name assigned to it when it was exported. The newly imported object must be assigned an identifier that is unique within the movie the object is imported into. Limited security is provided by requiring that the URL must be in the same domain or sub-domain as the URL of the movie which contains this object.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;url&quot;, url);
+			Transform.append(buffer, &quot;objects&quot;, objects, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aUrl the URL referencing the file to be imported.
-        @param anIdentifier the identifier of the object to be exported.
-        @param aString the name of the exported object to allow it to be referenced.
-        */
-    public FSImport(String aUrl, int anIdentifier, String aString)
-    {
-        super(Import);
-        setUrl(aUrl);
-        add(anIdentifier, aString);
-    }
-    /**
-     * Constructs an FSImport object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSImport object.
-     */
-    public FSImport(FSImport obj)
-    {
-        super(obj);
-        url = new String(obj.url);
-        
-        objects = new Hashtable(obj.objects.size());
-        
-        for (Iterator i = obj.objects.keySet().iterator(); i.hasNext();)
-        {
-            Object key = i.next();
-            objects.put(key, new String((String)objects.get(key)));
-        }
-    }    
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Adds the identifier and name to the list of objects to be imported.
+		length += coder.strlen(url, true);
+		length += 2;
 
-        @param anIdentifier the identifier of the object to be imported.
-        @param aString the name of the imported object to allow it to be referenced.
-        */
-    public void add(int anIdentifier, String aString)
-    {
-        objects.put(new Integer(anIdentifier), aString);
-    }
+		for (Enumeration e = objects.keys(); e.hasMoreElements();)
+		{
+			String name = (String) (objects.get(e.nextElement()));
 
-    /** Gets the URL of the file containing the object to be imported. Limited security is provided by requiring that the URL must be in the same domain or sub-domain as the URL of the movie which contains this object.
+			length += 2;
+			length += coder.strlen(name, true);
+		}
 
-        @return the URL of the file containing the object to be imported.
-        */
-    public String getUrl() 
-    {
-        return url;
-    }
+		return length;
+	}
 
-    /** Gets the table of objects to be imported. 
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @return the table of imported objects.
-        */
-    public Hashtable getObjects() 
-    {
-        return objects;
-    }
+		coder.writeString(url);
+		coder.writeWord(0, 1);
 
-    /**  Sets the URL of the file containing the imported objects. The URL must be in the same sub-domain and relative to the URL of the file containing the FSImport object.
+		coder.writeWord(objects.size(), 2);
 
-        @param aString a URL relative to the URL of the file containing the FSImport object.
-        */
-    public void setUrl(String aString)
-    {
-        url = aString;
-    }
+		for (Enumeration e = objects.keys(); e.hasMoreElements();)
+		{
+			Integer identifier = (Integer) (e.nextElement());
+			String name = (String) (objects.get(identifier));
 
-    /** Sets the table of objects to be imported.
+			coder.writeWord(identifier.intValue(), 2);
+			coder.writeString(name);
+			coder.writeWord(0, 1);
+		}
+		coder.endObject(name());
+	}
 
-        @param aTable the table of objects being imported.
-        */
-    public void setObjects(Hashtable aTable)
-    {
-        objects = aTable;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            if (url != null)
-                result = url.equals(((FSImport)anObject).getUrl());
-            else
-                result = ((FSImport)anObject).getUrl() == null;
-                
-            result = result &amp;&amp; objects.equals(((FSImport)anObject).getObjects());
-        }
-        return result;
-    }
+		url = coder.readString();
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		int count = coder.readWord(2, false);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;url&quot;, url);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		for (int i = 0; i &lt; count; i++)
+		{
+			int identifier = coder.readWord(2, false);
+			String name = coder.readString();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += coder.strlen(url, true);
-        length += 2;
-
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            String name = (String)(objects.get(e.nextElement()));
-            
-            length += 2;
-            length += coder.strlen(name, true);
-        }
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-           
-        coder.writeString(url);
-        coder.writeWord(0, 1);
-
-        coder.writeWord(objects.size(), 2);
-
-        for (Enumeration e = objects.keys(); e.hasMoreElements(); )
-        {
-            Integer identifier = (Integer)(e.nextElement());
-            String name = (String) (objects.get(identifier));
-
-            coder.writeWord(identifier.intValue(), 2);
-            coder.writeString(name);
-            coder.writeWord(0, 1);
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        url = coder.readString();
-        
-        int count = coder.readWord(2, false);
-
-        for (int i=0; i&lt;count; i++)
-        {
-            int identifier = coder.readWord(2, false);
-            String name = coder.readString();
-
-            add(identifier, name);
-        }
-        coder.endObject(name());
-    }
+			add(identifier, name);
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSInitialize.java
===================================================================
--- trunk/src/com/flagstone/transform/FSInitialize.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSInitialize.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,368 +33,408 @@
 import java.util.*;
 
 /**
-FSInitialize is used to specify a sequence of actions that are executed to initialise 
- a movie clip before it is displayed.
- 
-&lt;p&gt;It implements the #initclip pragma in the ActionScript language.&lt;/p&gt;
+ * FSInitialize is used to specify a sequence of actions that are executed to
+ * initialise a movie clip before it is displayed.
+ * 
+ * &lt;p&gt;
+ * It implements the #initclip pragma in the ActionScript language.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the FSDefineMovieClip object that defines the movie
+ * clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of actions that will be executed to initialize the movie clips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Unlike the FSDoAction class which specifies the actions that are executed
+ * when a particular frame is displayed the actions contained in an FSInitialize
+ * object are executed only once, regardless of where the object is included in
+ * a movie. If a frame containing the FSInitialize object is played again the
+ * actions are skipped. Also there can only be one FSInitialize object for each
+ * movie clip defined in the movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;_root&quot;));
+ *  actions.add(FSAction.GetVariable());
+ * 
+ *  int clipId = movie.newIdentifier();
+ * 
+ *  movie.add(new FSDefineMovieClip(clipId, clipObjects));
+ *  ...
+ * 
+ *  movie.add(new FSInitialize(clipId, actions));
+ *  ...
+ *  movie.add(new FSShowFrame()); 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSInitialize class represents the DoInitAction tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 6.
+ * &lt;/p&gt;
+ * 
+ * @see FSDoAction
+ */
+public class FSInitialize extends FSMovieObject
+{
+	private int identifier = 0;
+	private ArrayList actions = null;
+	private byte[] encodedActions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSInitialize object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSInitialize(FSCoder coder)
+	{
+ 		super(Initialize);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSInitialize object that will initialize the movie clip
+	 * with the specified identifier with the actions in the array.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the movie clip to initialize
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public FSInitialize(int anIdentifier, ArrayList anArray)
+	{
+		super(Initialize);
+		setIdentifier(anIdentifier);
+		setActions(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSInitialize_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSInitialize object that will initialize the movie clip
+	 * with the specified identifier with the encoded actions.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the movie clip to initialize
+	 * @param bytes
+	 *            an array of encoded action objects.
+	 */
+	public FSInitialize(int anIdentifier, byte[] bytes)
+	{
+		super(Initialize);
+		setIdentifier(anIdentifier);
+		setEncodedActions(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSInitialize_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the FSDefineMovieClip object that defines the movie clip.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSInitialize object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSInitialize object.
+	 */
+	public FSInitialize(FSInitialize obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSInitialize_2&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of actions that will be executed to initialize the movie clips.&lt;/td&gt;
-&lt;/tr&gt;
+		identifier = obj.identifier;
 
-&lt;/table&gt;
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-&lt;p&gt;Unlike the FSDoAction class which specifies the actions that are executed when a particular frame is displayed the actions contained in an FSInitialize object are executed only once, regardless of where the object is included in a movie. If a frame containing the FSInitialize object is played again the actions are skipped. Also there can only be one FSInitialize object for each movie clip defined in the movie.&lt;/p&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			encodedActions = Transform.clone(obj.encodedActions);
+		}
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Returns the identifier of the movie clip that will be initialized.
+	 * 
+	 * @return the identifier of the movie clip.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;pre&gt;
-ArrayList actions = new ArrayList();
+	/**
+	 * Sets the identifier of the movie clip that will be initialized.
+	 * 
+	 * @param aNumber
+	 *            the identifier of the movie clip. The value must be in the
+	 *            range 1..65535.
+	 */
+	public void setIdentifier(int aNumber)
+	{
+		identifier = aNumber;
+	}
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(FSAction.GetVariable());
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		actions.add(anAction);
+	}
 
-int clipId = movie.newIdentifier();
+	/**
+	 * Get the array of actions that are used to initialize the movie clip.
+	 * 
+	 * @return the array of action objects.
+	 */
+	public ArrayList getActions()
+	{
+		if (encodedActions != null)
+		{
+			actions = FSMovie.decodeActions(encodedActions);
+			encodedActions = null;
+		}
+		return actions;
+	}
 
-movie.add(new FSDefineMovieClip(clipId, clipObjects));
-...
+	/**
+	 * Set the array of actions of the movie clip that will be initialized
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+		encodedActions = null;
+	}
 
-movie.add(new FSInitialize(clipId, actions));
-...
-movie.add(new FSShowFrame()); 
-&lt;/pre&gt;
+	/**
+	 * Get the array of encoded actions that are executed when the frame is
+	 * displayed.
+	 * 
+	 * @return the array of action objects or null if the actions have been
+	 *         decoded.
+	 */
+	public byte[] getEncodedActions()
+	{
+		return encodedActions;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Set the array of encoded actions generated by the classes in the
+	 * Translate framework. If the object already contains an array of actions
+	 * then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded actions.
+	 */
+	public void setEncodedActions(byte[] bytes)
+	{
+		encodedActions = bytes;
+		actions = null;
+	}
 
-&lt;p&gt;The FSInitialize class represents the DoInitAction tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 6.&lt;/p&gt;
+	public Object clone()
+	{
+		FSInitialize anObject = (FSInitialize) super.clone();
 
<A HREF="https://lists.berlios.de/mailman/listinfo/transform-svn">- at see</A> FSDoAction
- */  
-public class FSInitialize extends FSMovieObject
-{
-    private int identifier = 0;
-    private ArrayList actions = null;
-    private byte[] encodedActions = null;
-    
-    /**
-     * Construct an FSInitialize object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSInitialize(FSCoder coder)
-    {
-        super(Initialize);
-        decode(coder);
-    }
-    /**  
-     * Constructs an FSInitialize object that will initialize the movie clip 
-     * with the specified identifier with the actions in the array.
-     *
-     * @param anIdentifier the identifier of the movie clip to initialize
-     * @param anArray the array of action objects.
-     */
-    public FSInitialize(int anIdentifier, ArrayList anArray)
-    {
-        super(Initialize);
-        setIdentifier(anIdentifier);
-        setActions(anArray);
-    }
-    /**  
-     * Constructs an FSInitialize object that will initialize the movie clip 
-     * with the specified identifier with the encoded actions.
-     *
-     * @param anIdentifier the identifier of the movie clip to initialize
-     * @param bytes an array of encoded action objects.
-     */
-    public FSInitialize(int anIdentifier, byte[] bytes)
-    {
-        super(Initialize);
-        setIdentifier(anIdentifier);
-        setEncodedActions(bytes);
-    }
-    /**
-     * Constructs an FSInitialize object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSInitialize object.
-     */
-    public FSInitialize(FSInitialize obj)
-    {
-        super(obj);
+		if (actions != null)
+		{
+			anObject.actions = new ArrayList();
 
-        identifier = obj.identifier;
-        
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            encodedActions = Transform.clone(obj.encodedActions);
-        }
-    }    
+			for (Iterator i = actions.iterator(); i.hasNext();)
+				anObject.actions.add(((FSActionObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedActions = Transform.clone(encodedActions);
+		}
+		return anObject;
+	}
 
-    /** Returns the identifier of the movie clip that will be initialized. 
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the identifier of the movie clip.
-        */     
-    public int getIdentifier() 
-    {
-        return identifier;
-    }
+		if (super.equals(anObject))
+		{
+			FSInitialize typedObject = (FSInitialize) anObject;
 
-    /** Sets the identifier of the movie clip that will be initialized.
+			result = identifier == typedObject.identifier;
 
-        @param aNumber the identifier of the movie clip. The value must be in the 
-        range 1..65535.
-        */     
-    public void setIdentifier(int aNumber)
-    {
-        identifier = aNumber;
-    }
-    
-    /** Adds the action object to the array of actions.
+			if (actions != null)
+				result = result &amp;&amp; actions.equals(typedObject.actions);
+			else
+				result = result
+								&amp;&amp; Transform.equals(encodedActions,
+												typedObject.encodedActions);
+		}
+		return result;
+	}
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }            
-        actions.add(anAction);
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Get the array of actions that are used to initialize the movie clip.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
 
-        @return the array of action objects.
-        */
-    public ArrayList getActions() 
-    { 
-        if (encodedActions != null)
-        {
-            actions = FSMovie.decodeActions(encodedActions);
-            encodedActions = null;
-        }
-        return actions;
-    }
+			if (actions != null)
+				Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			else
+				buffer.append(&quot;actions = &lt;data&gt;; &quot;);
 
-    /** Set the array of actions of the movie clip that will be initialized
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anArray the array of action objects.
-        */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-        encodedActions = null;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** 
-     * Get the array of encoded actions that are executed when the frame is displayed.
-     *
-     * @return the array of action objects or null if the actions have been
-     * decoded.
-     */
-    public byte[] getEncodedActions() 
-    { 
-        return encodedActions;
-    }
-    /** 
-     * Set the array of encoded actions generated by the classes in the Translate
-     * framework. If the object already contains an array of actions then they 
-     * will be deleted.
-     * 
-     * @param bytes the array of encoded actions.
-     */
-    public void setEncodedActions(byte[] bytes)
-    {
-        encodedActions = bytes;
-        actions = null;
-    }
+		length += 2;
 
-    public Object clone()
-    {
-        FSInitialize anObject = (FSInitialize)super.clone();
-        
-        if (actions != null)
-        {
-            anObject.actions = new ArrayList();
-            
-            for (Iterator i = actions.iterator(); i.hasNext();)
-                anObject.actions.add(((FSActionObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedActions = Transform.clone(encodedActions);
-        }
-        return anObject;
-    }
+		if (actions != null)
+		{
+			FSActionObject currentAction = null;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSInitialize typedObject = (FSInitialize)anObject;
-            
-            result = identifier == typedObject.identifier;
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				currentAction = (FSActionObject) i.next();
 
-            if (actions != null)
-                result = result &amp;&amp; actions.equals(typedObject.actions);
-            else
-                result = result &amp;&amp; Transform.equals(encodedActions, typedObject.encodedActions);
-        }
-        return result;
-    }
+				length += currentAction.length(coder);
+				length += (currentAction.getType() &gt; 128) ? 3 : 1;
+			}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+			if ((actions.size() == 0)
+							|| (currentAction.getType() != FSAction.End))
+			{
+				length += 1;
+			}
+		} else
+		{
+			length += encodedActions.length;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            
-            if (actions != null)
-                Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            else
-                buffer.append(&quot;actions = &lt;data&gt;; &quot;);
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				length += 1;
+			}
+		}
+		return length;
+	}
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
+		coder.writeWord(identifier, 2);
 
-        if (actions != null)
-        {
-        	FSActionObject currentAction = null;
-        	
-            for (Iterator i = actions.iterator(); i.hasNext();)
-            {
-                currentAction = (FSActionObject)i.next();
-            
-                length += currentAction.length(coder);
-                length += (currentAction.getType() &gt; 128) ? 3 : 1;
-            }
-            
-            if ((actions.size() == 0) || (currentAction.getType() != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        else
-        {
-            length += encodedActions.length;
+		if (actions != null)
+		{
+			FSActionObject action = null;
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-            	length += 1;
-            }
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
+			for (Iterator i = actions.iterator(); i.hasNext();)
+			{
+				action = (FSActionObject) i.next();
 
-        if (actions != null)
-        {
-        	FSActionObject action = null;
-        	
-            for (Iterator i=actions.iterator(); i.hasNext();)
-            {
-                action = (FSActionObject)i.next();
-                
-                int objStart = coder.getPointer();
-                int length = action.getLength();
-                int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-                int next = start + (length &lt;&lt; 3);
-            
-                action.encode(coder);
-                coder.setPointer(next);
-            
-                int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-                if (delta != 0)
-                {
-                    coder.context[FSCoder.CodingError] = 1;
-                    coder.context[FSCoder.TypeInError] = action.getType();
-                    coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                    coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                    coder.context[FSCoder.Delta] = delta;
-                }
-            }
-            
-            if ((actions.size() == 0) || (action.getType() != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        else
-        {
-            coder.writeBytes(encodedActions);
+				int objStart = coder.getPointer();
+				int length = action.getLength();
+				int start = coder.getPointer()
+								+ ((action.getType() &gt; 128) ? 24 : 8);
+				int next = start + (length &lt;&lt; 3);
 
-            if ((encodedActions.length == 0) || (encodedActions[encodedActions.length-1] != FSAction.End)) {
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
+				action.encode(coder);
+				coder.setPointer(next);
 
-        identifier = coder.readWord(2, false);
+				int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        if (coder.context[FSCoder.DecodeActions] == 1)
-        {
-            actions = new ArrayList();
-            
-            int len = length-2;
-            int start;
-            
-            while (len &gt; 0) 
-            {
-                start = coder.getPointer();
-                
-                actions.add(FSMovie.decodeAction(coder));
-                len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-            }
-        }
-        else
-        {
-            encodedActions = new byte[length-2];
-            coder.readBytes(encodedActions);
-        }
-        coder.endObject(name());
-    }
+				if (delta != 0)
+				{
+					coder.context[FSCoder.CodingError] = 1;
+					coder.context[FSCoder.TypeInError] = action.getType();
+					coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+					coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+					coder.context[FSCoder.Delta] = delta;
+				}
+			}
+
+			if ((actions.size() == 0) || (action.getType() != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		} else
+		{
+			coder.writeBytes(encodedActions);
+
+			if ((encodedActions.length == 0)
+							|| (encodedActions[encodedActions.length - 1] != FSAction.End))
+			{
+				coder.writeWord(0, 1);
+			}
+		}
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		identifier = coder.readWord(2, false);
+
+		if (coder.context[FSCoder.DecodeActions] == 1)
+		{
+			actions = new ArrayList();
+
+			int len = length - 2;
+			int start;
+
+			while (len &gt; 0)
+			{
+				start = coder.getPointer();
+
+				actions.add(FSMovie.decodeAction(coder));
+				len -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+			}
+		} else
+		{
+			encodedActions = new byte[length - 2];
+			coder.readBytes(encodedActions);
+		}
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSJPEGEncodingTable.java
===================================================================
--- trunk/src/com/flagstone/transform/FSJPEGEncodingTable.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSJPEGEncodingTable.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,187 +31,222 @@
 package com.flagstone.transform;
 
 /**
-FSJPEGEncodingTable defines an encoding table for JPEG images. 
+ * FSJPEGEncodingTable defines an encoding table for JPEG images.
+ * 
+ * &lt;p&gt;
+ * The encoding table is shared between all images defined using the
+ * FSDefineJPEGImage class so there should only be one FSJPEGEncodingTable
+ * object defined in a movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodingTable&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing the encoding table data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSJPEGEncodingTable class is not essential to define JPEG encoded images
+ * in a movie using the FSDefineJPEGImage class. If an FSJPEGEncodingTable
+ * object is created with an empty encoding table then the Flash Player will
+ * still display JPEG images defined using FSDefineJPEGImage objects correctly.
+ * When an FSJPEGEncodingTable with an empty encoding table is encoded to a
+ * Flash file, the &quot;end of stream&quot; marker 0xFFD9 is encoded allowing the empty
+ * table to be decoded correctly.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The simplest way to use the FSJPEGEncodingTable and FSDefineJPEGImage classes
+ * to define JPEG encoded images is to create an empty encoding table then
+ * construct the FSDefineJPEGImage object(s) with the image data from a file:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * File aFile = new File(filename);
+ * byte[] bytes = new byte[(int) aFile.length()];
+ * 
+ * try
+ * {
+ * 	FileInputStream imageContents = new FileInputStream(aFile);
+ * 	imageContents.read(bytes);
+ * 	imageContents.close();
+ * } catch (FileNotFoundException e)
+ * {
+ * 	throw new FileNotFoundException(filename);
+ * } catch (IOException e)
+ * {
+ * 	throw new IOException(filename);
+ * }
+ * 
+ * movie.add(new FSJPEGEncodingTable());
+ * movie.add(new FSDefineJPEGImage(movie.newIdentifier(), bytes));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSJPEGEncodingTable class represents the JPEGEncodingTable tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSJPEGEncodingTable extends FSMovieObject
+{
+	private byte[] encodingTable = null;
 
-&lt;p&gt;The encoding table is shared between all images defined using the FSDefineJPEGImage class so there should only be one FSJPEGEncodingTable object defined in a movie.&lt;/p&gt;
+	/**
+	 * Construct an FSJPEGEncodingTable object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSJPEGEncodingTable(FSCoder coder)
+	{
+		super(FSMovieObject.JPEGTables);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSJPEGEncodingTable object with an empty encoding table.
+	 */
+	public FSJPEGEncodingTable()
+	{
+		super(FSMovieObject.JPEGTables);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSJPEGEncodingTable object with the encoding table data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes contains the data for the encoding table.
+	 */
+	public FSJPEGEncodingTable(byte[] bytes)
+	{
+		super(FSMovieObject.JPEGTables);
+		setEncodingTable(bytes);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSJPEGEncodingTable_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSJPEGEncodingTable object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSJPEGEncodingTable object.
+	 */
+	public FSJPEGEncodingTable(FSJPEGEncodingTable obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSJPEGEncodingTable_0&quot;&gt;encodingTable&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing the encoding table data.&lt;/td&gt;
-&lt;/tr&gt;
+		if (obj.encodingTable != null)
+			encodingTable = Transform.clone(obj.encodingTable);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the encoding table.
+	 * 
+	 * @return the array of bytes contains the data for the encoding table.
+	 */
+	public byte[] getEncodingTable()
+	{
+		return encodingTable;
+	}
 
-&lt;p&gt;The FSJPEGEncodingTable class is not essential to define JPEG encoded images in a movie using the FSDefineJPEGImage class. If an FSJPEGEncodingTable object is created with an empty encoding table then the Flash Player will still display JPEG images defined using FSDefineJPEGImage objects correctly. When an FSJPEGEncodingTable with an empty encoding table is encoded to a Flash file, the &quot;end of stream&quot; marker 0xFFD9 is encoded allowing the empty table to be decoded correctly.&lt;/p&gt;
+	/**
+	 * Sets the encoding table.
+	 * 
+	 * @param bytes
+	 *            an array of bytes contains the data for the encoding table.
+	 */
+	public void setEncodingTable(byte[] bytes)
+	{
+		encodingTable = bytes;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	public Object clone()
+	{
+		FSJPEGEncodingTable anObject = (FSJPEGEncodingTable) super.clone();
 
-&lt;p&gt;The simplest way to use the FSJPEGEncodingTable and FSDefineJPEGImage classes to define JPEG encoded images is to create an empty encoding table then construct the FSDefineJPEGImage object(s) with the image data from a file:&lt;/p&gt;
+		anObject.encodingTable = Transform.clone(encodingTable);
 
-&lt;pre&gt;
-File aFile = new File(filename);
-byte[] bytes = new byte[(int)aFile.length()];
+		return anObject;
+	}
 
-try {
-    FileInputStream imageContents = new FileInputStream(aFile);            
-    imageContents.read(bytes);
-    imageContents.close();
-}
-catch (FileNotFoundException e) {
-    throw new FileNotFoundException(filename);
-}
-catch (IOException e) {
-    throw new IOException(filename);
-}
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-movie.add(new FSJPEGEncodingTable());
-movie.add(new FSDefineJPEGImage(movie.newIdentifier(), bytes));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSJPEGEncodingTable typedObject = (FSJPEGEncodingTable) anObject;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			result = Transform.equals(encodingTable, typedObject.encodingTable);
+		}
+		return result;
+	}
 
-&lt;p&gt;The FSJPEGEncodingTable class represents the JPEGEncodingTable tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSJPEGEncodingTable extends FSMovieObject
-{
-    private byte[] encodingTable = null;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /**
-     * Construct an FSJPEGEncodingTable object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSJPEGEncodingTable(FSCoder coder)
-    {
-        super(FSMovieObject.JPEGTables);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSJPEGEncodingTable object with an empty encoding table. 
-     */ 
-    public FSJPEGEncodingTable()
-    {
-        super(FSMovieObject.JPEGTables);
-    }
-    /** Constructs an FSJPEGEncodingTable object with the encoding table data.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param bytes an array of bytes contains the data for the encoding table.
-        */ 
-    public FSJPEGEncodingTable(byte[] bytes)
-    {
-        super(FSMovieObject.JPEGTables);
-        setEncodingTable(bytes);
-    }
-    /**
-     * Constructs an FSJPEGEncodingTable object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSJPEGEncodingTable object.
-     */
-    public FSJPEGEncodingTable(FSJPEGEncodingTable obj)
-    {
-        super(obj);
-        
-        if (obj.encodingTable != null)
-            encodingTable = Transform.clone(obj.encodingTable);
-    }    
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the encoding table.
+		length += (encodingTable == null) ? 2 : encodingTable.length;
 
-        @return the array of bytes contains the data for the encoding table.
-        */
-    public byte[] getEncodingTable() { return encodingTable; }
+		return length;
+	}
 
-    /** Sets the encoding table.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param bytes an array of bytes contains the data for the encoding table.
-        */
-    public void setEncodingTable(byte[] bytes)
-    {
-        encodingTable = bytes;
-    }
+		if (encodingTable == null)
+		{
+			coder.writeWord((byte) 0xFF, 1);
+			coder.writeWord((byte) 0xD9, 1);
+		} else
+		{
+			coder.writeBytes(encodingTable);
+		}
+		coder.endObject(name());
+	}
 
-    public Object clone()
-    {
-        FSJPEGEncodingTable anObject = (FSJPEGEncodingTable)super.clone();
-        
-        anObject.encodingTable = Transform.clone(encodingTable);
-        
-        return anObject;
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSJPEGEncodingTable typedObject = (FSJPEGEncodingTable)anObject;
-            
-            result = Transform.equals(encodingTable, typedObject.encodingTable);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;encodingTable&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }        
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += (encodingTable == null) ? 2 : encodingTable.length;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        if (encodingTable == null)
-        {
-            coder.writeWord((byte)0xFF, 1);
-            coder.writeWord((byte)0xD9, 1);
-        }
-        else
-        {
-            coder.writeBytes(encodingTable);
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        if (length == 0)
-        {
-            encodingTable = null;
-        }
-        else
-        {
-            encodingTable = new byte[length];
-            coder.readBytes(encodingTable);        
-        }
-        coder.endObject(name());
-    }
+		if (length == 0)
+		{
+			encodingTable = null;
+		} else
+		{
+			encodingTable = new byte[length];
+			coder.readBytes(encodingTable);
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSJump.java
===================================================================
--- trunk/src/com/flagstone/transform/FSJump.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSJump.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,131 +31,165 @@
 package com.flagstone.transform;
 
 /**
-The FSJump action performs an unconditional branch to control the actions executed by the Flash Player. 
- 
-&lt;p&gt;When executed the FSJump action adds an offset to the instruction pointer and execution of the stream of actions continues from that address.&lt;/p&gt;
+ * The FSJump action performs an unconditional branch to control the actions
+ * executed by the Flash Player.
+ * 
+ * &lt;p&gt;
+ * When executed the FSJump action adds an offset to the instruction pointer and
+ * execution of the stream of actions continues from that address.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Although the Flash Player contains an instruction pointer it does not support
+ * an explicit address space. The instruction pointer is used to reference
+ * actions within the current stream of actions being executed whether they are
+ * associated with a given frame, button or movie clip. The value contained in
+ * the instruction pointer is the address relative to the start of the current
+ * stream.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;offset&lt;/td&gt;
+ * &lt;td&gt;The offset, relative to the current instruction pointer, to jump to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The offset is a signed number allowing branches up to -32768 to 32767 bytes.
+ * The instruction pointer points to the next instruction so specifying an
+ * offset of zero will have no effect on the sequence of instructions executed.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSJump(32));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSJump class represents the ActionJump action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSJump extends FSActionObject
+{
+	private int offset = 0;
 
-&lt;p&gt;Although the Flash Player contains an instruction pointer it does not support an explicit address space. The instruction pointer is used to reference actions within the current stream of actions being executed whether they are associated with a given frame, button or movie clip. The value contained in the instruction pointer is the address relative to the start of the current stream.&lt;/p&gt;
+	/**
+	 * Construct an FSJump object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSJump(FSCoder coder)
+	{
+		super(Jump);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSJump action with the specified offset. The offset must be
+	 * in the range -32768..32767.
+	 * 
+	 * @param anOffset
+	 *            the number of bytes to add to the instruction pointer.
+	 */
+	public FSJump(int anOffset)
+	{
+		super(Jump);
+		setOffset(anOffset);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSJump object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSJump object.
+	 */
+	public FSJump(FSJump obj)
+	{
+		super(obj);
+		offset = obj.offset;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSJump_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the offset that will be added to the instruction pointer.
+	 * 
+	 * @return the number of bytes to add to the instruction pointer.
+	 */
+	public int getOffset()
+	{
+		return offset;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSJump_1&quot;&gt;offset&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The offset, relative to the current instruction pointer, to jump to.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Sets the offset to add to the instruction pointer. The offset must be in
+	 * the range -32768..32767.
+	 * 
+	 * @param anOffset
+	 *            the number of bytes to add to the instruction pointer.
+	 */
+	public void setOffset(int anOffset)
+	{
+		offset = anOffset;
+	}
 
-&lt;p&gt;The offset is a signed number allowing branches up to -32768 to 32767 bytes. The instruction pointer points to the next instruction so specifying an offset of zero will have no effect on the sequence of instructions executed.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+		if (super.equals(anObject))
+			result = offset == ((FSJump) anObject).getOffset();
 
-actions.add(new FSJump(32));
-&lt;/pre&gt;
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;The FSJump class represents the ActionJump action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSJump extends FSActionObject
-{
-    private int offset = 0;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;offset&quot;, offset);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /**
-     * Construct an FSJump object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSJump(FSCoder coder)
-    {
-        super(Jump);
-        decode(coder);
-    }
-    /** Constructs an FSJump action with the specified offset. The offset must be in the range -32768..32767.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param anOffset the number of bytes to add to the instruction pointer.
-        */
-    public FSJump(int anOffset)
-    {
-        super(Jump);
-        setOffset(anOffset);
-    }
-    /**
-     * Constructs an FSJump object by copying values from an existing object.
-     *
-     * @param obj an FSJump object.
-     */
-    public FSJump(FSJump obj)
-    {
-        super(obj);
-        offset = obj.offset;
-    }    
+		length += 2;
 
-    /** Gets the offset that will be added to the instruction pointer.
+		return length;
+	}
 
-        @return the number of bytes to add to the instruction pointer.
-        */
-    public int getOffset() { return offset; }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(offset, 2);
+		coder.endObject(name());
+	}
 
-    /** Sets the offset to add to the instruction pointer. The offset must be in the range -32768..32767.
-
-        @param anOffset the number of bytes to add to the instruction pointer.
-        */
-    public void setOffset(int anOffset)
-    {
-        offset = anOffset;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = offset == ((FSJump)anObject).getOffset();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;offset&quot;, offset);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(offset, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        offset = coder.readWord(2, true);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		offset = coder.readWord(2, true);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSKerning.java
===================================================================
--- trunk/src/com/flagstone/transform/FSKerning.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSKerning.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,183 +31,235 @@
 package com.flagstone.transform;
 
 /**
-FSKerning describes the spacing between a pair of glyphs. 
+ * FSKerning describes the spacing between a pair of glyphs.
+ * 
+ * &lt;p&gt;
+ * The kerning is used to fine-tune the spacing between specific pairs of
+ * characters to make them visually more appealing. The glyphs are identified by
+ * an index into the glyph table for the font. The adjustment is specified
+ * relative to the advance define for the left glyph.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;leftIndex&lt;/td&gt;
+ * &lt;td&gt;The index into the code table that identifies the glyph on the left side
+ * of the pair.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;rightIndex&lt;/td&gt;
+ * &lt;td&gt;The index into a code table that identifies the glyph on the right side
+ * of the pair.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;adjustment&lt;/td&gt;
+ * &lt;td&gt;The adjustment in twips that will be added to the advance for the glyph
+ * on the left side of the pair to obtain the final spacing between the glyphs.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSKerning objects are only used within FSDefineFont2 objects and provide more
+ * precise control over the layout of a font's glyph than was possible using the
+ * FSDefineFont and FSFontInfo objects.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSKerning class represents the KerningRecord from the Macromedia Flash (SWF)
+ * File Format Specification. It was introduced in Flash 2.
+ * &lt;/p&gt;
+ */
+public class FSKerning extends FSTransformObject
+{
+	private int leftGlyphIndex = 0;
+	private int rightGlyphIndex = 0;
+	private int adjustment = 0;
 
-&lt;p&gt;The kerning is used to fine-tune the spacing between specific pairs of characters to make them visually more appealing. The glyphs are identified by an index into the glyph table for the font. The adjustment is specified relative to the advance define for the left glyph.&lt;/p&gt;
+	/**
+	 * Construct an FSKerning object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSKerning(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSKerning object specifying the glyph indexes and
+	 * adjustment. The value for the adjustment must be specified in twips.
+	 * 
+	 * @param leftIndex
+	 *            the index in a code table for the glyph on the left side of
+	 *            the pair.
+	 * @param rightIndex
+	 *            the index in a code table for the glyph on the right side of
+	 *            the pair.
+	 * @param adjust
+	 *            the adjustment that will be added to the advance defined for
+	 *            the left glyph.
+	 */
+	public FSKerning(int leftIndex, int rightIndex, int adjust)
+	{
+		setLeftGlyphIndex(leftIndex);
+		setRightGlyphIndex(rightIndex);
+		setAdjustment(adjust);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSKerning object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSKerning object.
+	 */
+	public FSKerning(FSKerning obj)
+	{
+		leftGlyphIndex = obj.leftGlyphIndex;
+		rightGlyphIndex = obj.rightGlyphIndex;
+		adjustment = obj.adjustment;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSKerning_0&quot;&gt;leftGlyphIndex&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index into the code table that identifies the glyph on the left side of the pair.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the index of the left glyph in the kerning pair.
+	 * 
+	 * @return the index in a code table for the glyph on the left side of the
+	 *         pair.
+	 */
+	public int getLeftGlyphIndex()
+	{
+		return leftGlyphIndex;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSKerning_1&quot;&gt;rightGlyphIndex&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index into a code table that identifies the glyph on the right side of the pair.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the index of the right glyph in the kerning pair.
+	 * 
+	 * @return the index in a code table for the glyph on the right side of the
+	 *         pair.
+	 */
+	public int getRightGlyphIndex()
+	{
+		return rightGlyphIndex;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSKerning_2&quot;&gt;adjustment&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The adjustment in twips that will be added to the advance for the glyph on the left side of the pair to obtain the final spacing between the glyphs.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the adjustment, in twips, to the advance of the left glyph.
+	 * 
+	 * @return the adjustment that will be added to the advance defined for the
+	 *         left glyph.
+	 */
+	public int getAdjustment()
+	{
+		return adjustment;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the index of the left glyph in the kerning pair.
+	 * 
+	 * @param anIndex
+	 *            the index in a code table for the glyph on the left side of
+	 *            the pair.
+	 */
+	public void setLeftGlyphIndex(int anIndex)
+	{
+		leftGlyphIndex = anIndex;
+	}
 
-&lt;p&gt;FSKerning objects are only used within FSDefineFont2 objects and provide more precise control over the layout of a font's glyph than was possible using the FSDefineFont and FSFontInfo objects.&lt;/p&gt;
+	/**
+	 * Sets the index of the right glyph in the kerning pair.
+	 * 
+	 * @param anIndex
+	 *            the index in a code table for the glyph on the right side of
+	 *            the pair.
+	 */
+	public void setRightGlyphIndex(int anIndex)
+	{
+		rightGlyphIndex = anIndex;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the adjustment, in twips, to the advance of the left glyph.
+	 * 
+	 * @param aNumber
+	 *            the adjustment that will be added to the advance defined for
+	 *            the left glyph.
+	 */
+	public void setAdjustment(int aNumber)
+	{
+		adjustment = aNumber;
+	}
 
-&lt;p&gt;FSKerning class represents the KerningRecord from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2.&lt;/p&gt;
- */
-public class FSKerning extends FSTransformObject
-{
-    private int leftGlyphIndex = 0;
-    private int rightGlyphIndex = 0;
-    private int adjustment = 0;
-    
-    /**
-     * Construct an FSKerning object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSKerning(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSKerning object specifying the glyph indexes and adjustment. The value for the adjustment must be specified in twips.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param leftIndex the index in a code table for the glyph on the left side of the pair.
-        @param rightIndex the index in a code table for the glyph on the right side of the pair.
-        @param adjust the adjustment that will be added to the advance defined for the left glyph.
-        */
-    public FSKerning(int leftIndex, int rightIndex, int adjust)
-    {
-        setLeftGlyphIndex(leftIndex);
-        setRightGlyphIndex(rightIndex);
-        setAdjustment(adjust);
-    }
-    /**
-     * Constructs an FSKerning object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSKerning object.
-     */
-    public FSKerning(FSKerning obj)
-    {
-        leftGlyphIndex = obj.leftGlyphIndex;
-        rightGlyphIndex = obj.rightGlyphIndex;
-        adjustment = obj.adjustment;
-    }    
+		if (super.equals(anObject))
+		{
+			FSKerning typedObject = (FSKerning) anObject;
 
-    /** Gets the index of the left glyph in the kerning pair.
+			result = leftGlyphIndex == typedObject.leftGlyphIndex;
+			result = result &amp;&amp; rightGlyphIndex == typedObject.rightGlyphIndex;
+			result = result &amp;&amp; adjustment == typedObject.adjustment;
+		}
+		return result;
+	}
 
-        @return the index in a code table for the glyph on the left side of the pair.
-        */
-    public int getLeftGlyphIndex()  { return leftGlyphIndex; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the index of the right glyph in the kerning pair.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;leftGlyphIndex&quot;, leftGlyphIndex);
+			Transform.append(buffer, &quot;rightGlyphIndex&quot;, rightGlyphIndex);
+			Transform.append(buffer, &quot;adjustment&quot;, adjustment);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the index in a code table for the glyph on the right side of the pair.
-        */
-    public int getRightGlyphIndex()  { return rightGlyphIndex; }
+	public int length(FSCoder coder)
+	{
+		int length = (coder.context[FSCoder.WideCodes] != 0) ? 4 : 2;
 
-    /** Gets the adjustment, in twips, to the advance of the left glyph.
+		length += 2;
 
-        @return the adjustment that will be added to the advance defined for the left glyph.
-        */
-    public int getAdjustment() { return adjustment; }
+		return length;
+	}
 
-    /** Sets the index of the left glyph in the kerning pair.
+	public void encode(FSCoder coder)
+	{
+		int numberOfBytes = (coder.context[FSCoder.WideCodes] != 0) ? 2 : 1;
 
-        @param anIndex the index in a code table for the glyph on the left side of the pair.
-        */
-    public void setLeftGlyphIndex(int anIndex)
-    {
-        leftGlyphIndex = anIndex;
-    }
+		coder.writeWord(leftGlyphIndex, numberOfBytes);
+		coder.writeWord(rightGlyphIndex, numberOfBytes);
+		coder.writeWord(adjustment, 2);
+	}
 
-    /** Sets the index of the right glyph in the kerning pair.
+	public void decode(FSCoder coder)
+	{
+		int numberOfBytes = (coder.context[FSCoder.WideCodes] != 0) ? 2 : 1;
 
-        @param anIndex the index in a code table for the glyph on the right side of the pair.
-        */
-    public void setRightGlyphIndex(int anIndex)
-    {
-        rightGlyphIndex = anIndex;
-    }
-
-    /** Sets the adjustment, in twips, to the advance of the left glyph.
-
-        @param aNumber the adjustment that will be added to the advance defined for the left glyph.
-        */
-    public void setAdjustment(int aNumber) 
-    {
-        adjustment = aNumber;
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSKerning typedObject = (FSKerning)anObject;
-            
-            result = leftGlyphIndex == typedObject.leftGlyphIndex;
-            result = result &amp;&amp; rightGlyphIndex == typedObject.rightGlyphIndex;
-            result = result &amp;&amp; adjustment == typedObject.adjustment;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;leftGlyphIndex&quot;, leftGlyphIndex);
-            Transform.append(buffer, &quot;rightGlyphIndex&quot;, rightGlyphIndex);
-            Transform.append(buffer, &quot;adjustment&quot;, adjustment);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = (coder.context[FSCoder.WideCodes] != 0) ? 4 : 2;
-    
-        length += 2;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        int numberOfBytes = (coder.context[FSCoder.WideCodes] != 0) ? 2 : 1;
-    
-        coder.writeWord(leftGlyphIndex, numberOfBytes);
-        coder.writeWord(rightGlyphIndex, numberOfBytes);
-        coder.writeWord(adjustment, 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int numberOfBytes = (coder.context[FSCoder.WideCodes] != 0) ? 2 : 1;
-
-        leftGlyphIndex = coder.readWord(numberOfBytes, false);
-        rightGlyphIndex = coder.readWord(numberOfBytes, false);
-        adjustment = coder.readWord(2, true);
-    }
+		leftGlyphIndex = coder.readWord(numberOfBytes, false);
+		rightGlyphIndex = coder.readWord(numberOfBytes, false);
+		adjustment = coder.readWord(2, true);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSLayer.java
===================================================================
--- trunk/src/com/flagstone/transform/FSLayer.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSLayer.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,11 +33,11 @@
 import java.util.*;
 
 /**
- * The Layer class can be used to simplify the creation of movies. It provides
- * a series of methods that can be used to control how an object is displayed
- * and provides an API that is easier to use when compared to creating the 
- * commands (FSPlaceObject, FSRemoveObject, etc.) used to manipulate the Flash 
- * Player's display list directly. The following code:
+ * The Layer class can be used to simplify the creation of movies. It provides a
+ * series of methods that can be used to control how an object is displayed and
+ * provides an API that is easier to use when compared to creating the commands
+ * (FSPlaceObject, FSRemoveObject, etc.) used to manipulate the Flash Player's
+ * display list directly. The following code:
  * 
  * &lt;pre&gt;
  * FSLayer layer = new Layer(1);
@@ -61,12 +61,12 @@
  * movie.add(FSShowFrame.getInstance());
  * &lt;/pre&gt;
  * 
- * After each set of commands the display list is updated by executing the 
+ * After each set of commands the display list is updated by executing the
  * show() method - this adds a ShowFrame instruction to the final movie which
  * tells the Flash Player to render the display list on the screen.
  * 
- * The select() method is only used when displaying an object for the first 
- * time or re-displaying it after it was deleted from the display list.
+ * The select() method is only used when displaying an object for the first time
+ * or re-displaying it after it was deleted from the display list.
  * 
  * The commands that manipulate the display list can also be combined to apply
  * several operations at once:
@@ -92,15 +92,15 @@
  * movie.add(FSShowFrame.getInstance());
  * &lt;/pre&gt;
  * 
- * An operation is use to set the attributes on either an FSPlaceObject2 or 
- * FSRemoveObject2 object so operations of the same type cannot be combined
- * to create a cumulative effect. For example:
+ * An operation is use to set the attributes on either an FSPlaceObject2 or
+ * FSRemoveObject2 object so operations of the same type cannot be combined to
+ * create a cumulative effect. For example:
  * 
  * &lt;pre&gt;
  * layer.move(x1, y1);
  * layer.move(x2, y2);
  * &lt;/pre&gt;
- *
+ * 
  * is the same as:
  * 
  * &lt;pre&gt;
@@ -110,382 +110,420 @@
  * and not:
  * 
  * &lt;pre&gt;
- * layer.move(x1+x2, y1+y2);
+ * layer.move(x1 + x2, y1 + y2);
  * &lt;/pre&gt;
  * 
- * The most obvious benefit is code that is easier to write and read however
- * the benefits of using layers come to the fore when creating movies with 
- * multiple objects. Currently the movie object represents the main time-line and
- * the commands to control and display each object must be interleaved together.
- * This quickly becomes unwieldy and error prone if several objects are involved.
- * With layers, each can be regarded as the time-line for a single object. The 
- * object can then be manipulated more easily and the final set of Layers merged
- * together to create a single time-line. The only limitation in the merging 
- * process is that all the Layers must start at the same point in time. 
+ * The most obvious benefit is code that is easier to write and read however the
+ * benefits of using layers come to the fore when creating movies with multiple
+ * objects. Currently the movie object represents the main time-line and the
+ * commands to control and display each object must be interleaved together.
+ * This quickly becomes unwieldy and error prone if several objects are
+ * involved. With layers, each can be regarded as the time-line for a single
+ * object. The object can then be manipulated more easily and the final set of
+ * Layers merged together to create a single time-line. The only limitation in
+ * the merging process is that all the Layers must start at the same point in
+ * time.
  * 
- * Each Layer object created must be assigned a unique number. In Flash an object 
- * to be displayed is assigned to a given layer with (typically) only one object 
- * displayed on a given layer. The layer number is used to control the order in 
- * which the objects are displayed. Objects placed on a higher layer number are 
- * displayed in front of object placed on a lower layer number. 
+ * Each Layer object created must be assigned a unique number. In Flash an
+ * object to be displayed is assigned to a given layer with (typically) only one
+ * object displayed on a given layer. The layer number is used to control the
+ * order in which the objects are displayed. Objects placed on a higher layer
+ * number are displayed in front of object placed on a lower layer number.
  * 
  */
 public final class FSLayer
 {
 	/**
-	 * Merge layers together to create a single time-line. Each layer is 
-	 * assumed to start at the same point in time. The process steps through 
-	 * each of the layers, frame by frame, adding all the commands used to 
-	 * manipulate the Flash Player's display list into a single group.
+	 * Merge layers together to create a single time-line. Each layer is assumed
+	 * to start at the same point in time. The process steps through each of the
+	 * layers, frame by frame, adding all the commands used to manipulate the
+	 * Flash Player's display list into a single group.
 	 * 
-	 * @param layers and array of FSLayer objects.
+	 * @param layers
+	 *            and array of FSLayer objects.
 	 * 
-	 * @return an array of all the objects contained in each layer. This array 
-	 * can then be added to the movie.
+	 * @return an array of all the objects contained in each layer. This array
+	 *         can then be added to the movie.
 	 */
-    public static ArrayList merge(ArrayList layers)
-    {
-        ArrayList objects = new ArrayList();
-        
-        int[] idx = new int[layers.size()];
-        
-        for (int i=0; i&lt;idx.length; i++) {
-        	idx[i] = 0;
-        }
-        
-        while (true)
-        {
-        	ArrayList array = null;
-        	FSMovieObject object;
+	public static ArrayList merge(ArrayList layers)
+	{
+		ArrayList objects = new ArrayList();
 
-        	for (int i=0; i&lt;idx.length; i++)
-            {
-        		array = ((FSLayer)layers.get(i)).getObjects();
-        		
-        		while (idx[i] &lt; array.size())
-        		{
-        			object = (FSMovieObject)array.get(idx[i]++);
-        			
-        			if (object.getType() == FSMovieObject.ShowFrame) {
-        				break;
-        			}
-        			
-        			objects.add(object);
-        		}
-        		
-        		if (idx[i] == array.size()) {
-        			array = null;
-        		}
-            }
-        	objects.add(FSShowFrame.getInstance());
-        	
-        	if (array == null) {
-        		break;
-        	}
-        }
-        
-        return objects;
-    }    
+		int[] idx = new int[layers.size()];
 
-    private int layer;
-    private int identifier;
-    private FSPlaceObject2 place;
-    
-    private ArrayList displayList;
+		for (int i = 0; i &lt; idx.length; i++)
+		{
+			idx[i] = 0;
+		}
 
-    /**
-     * Create a new Layer object. Layers are used to define the order in which
-     * objects are displayed. Objects placed on a high layer number are 
-     * displayed in front of those on a lower layer.
-     * 
-     * @param number the layer number on the display list.
-     */
-    public FSLayer(int number)
-    {
-    	layer = number;
-    	identifier = 0;
-    	displayList = new ArrayList();
-    }
-    
-    /**
-     * Return the layer number. The Flash Player assumes that there is only 
-     * one object placed on each layer and so each must have a unique number.
-     * 
-     * @return the layer number.
-     */
-    public int getLayer()
-    {
-    	return layer;
-    }
-    
-    /**
-     * Return the identifier of the object on the layer. Note: it is possible 
-     * to place more than one object on a layer however only one should be 
-     * visible on the display list at a given time.
-     * 
-     * @return the unique identifier used to reference the object.
-     */
-    public int getIdentifier()
-    {
-    	return identifier;
-    }
-    
-    /**
-     * Return the array of commands used to manipulate the object on the display
-     * list.
-     * 
-     * @return an array of FSMovieObject containing the definition of the object
-     * (shape, text, etc) to be displayed and the associated commands that 
-     * update the position of the object on the screen.
-     */
-    public ArrayList getObjects()
-    {
-    	return displayList;
-    }
+		while (true)
+		{
+			ArrayList array = null;
+			FSMovieObject object;
 
-    /**
-     * Add an object to the layer. The object may be selected later for display.
-     * 
-     * @param definition an object defining an image, shape, text, sound
-     * or video.
-     */
-    public void add(FSDefineObject definition)
-    {
+			for (int i = 0; i &lt; idx.length; i++)
+			{
+				array = ((FSLayer) layers.get(i)).getObjects();
+
+				while (idx[i] &lt; array.size())
+				{
+					object = (FSMovieObject) array.get(idx[i]++);
+
+					if (object.getType() == FSMovieObject.ShowFrame)
+					{
+						break;
+					}
+
+					objects.add(object);
+				}
+
+				if (idx[i] == array.size())
+				{
+					array = null;
+				}
+			}
+			objects.add(FSShowFrame.getInstance());
+
+			if (array == null)
+			{
+				break;
+			}
+		}
+
+		return objects;
+	}
+
+	private int layer;
+
+	private int identifier;
+
+	private FSPlaceObject2 place;
+
+	private ArrayList displayList;
+
+	/**
+	 * Create a new Layer object. Layers are used to define the order in which
+	 * objects are displayed. Objects placed on a high layer number are
+	 * displayed in front of those on a lower layer.
+	 * 
+	 * @param number
+	 *            the layer number on the display list.
+	 */
+	public FSLayer(int number)
+	{
+		layer = number;
+		identifier = 0;
+		displayList = new ArrayList();
+	}
+
+	/**
+	 * Return the layer number. The Flash Player assumes that there is only one
+	 * object placed on each layer and so each must have a unique number.
+	 * 
+	 * @return the layer number.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
+
+	/**
+	 * Return the identifier of the object on the layer. Note: it is possible to
+	 * place more than one object on a layer however only one should be visible
+	 * on the display list at a given time.
+	 * 
+	 * @return the unique identifier used to reference the object.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
+
+	/**
+	 * Return the array of commands used to manipulate the object on the display
+	 * list.
+	 * 
+	 * @return an array of FSMovieObject containing the definition of the object
+	 *         (shape, text, etc) to be displayed and the associated commands
+	 *         that update the position of the object on the screen.
+	 */
+	public ArrayList getObjects()
+	{
+		return displayList;
+	}
+
+	/**
+	 * Add an object to the layer. The object may be selected later for display.
+	 * 
+	 * @param definition
+	 *            an object defining an image, shape, text, sound or video.
+	 */
+	public void add(FSDefineObject definition)
+	{
 		displayList.add(definition);
-    }
-    
-    /**
-     * Select the object previously added to the layer to be added on the 
-     * display list. The object will be placed at the default coordinates (0,0).
-     * 
-     * IMPORTANT: You only need to use this method when adding an object to the
-     * display list for the first time or when re-adding it after it has been
-     * deleted. Since the display list has one layer per object then the layer
-     * number can be used to identify which object to update.
-     * 
-     * @param id an object definition, FSDefineShape, FSDefineImage, etc. that 
-     * will be added to the display list.
-     */
-    public void select(int id)
-    {
+	}
+
+	/**
+	 * Select the object previously added to the layer to be added on the
+	 * display list. The object will be placed at the default coordinates (0,0).
+	 * 
+	 * IMPORTANT: You only need to use this method when adding an object to the
+	 * display list for the first time or when re-adding it after it has been
+	 * deleted. Since the display list has one layer per object then the layer
+	 * number can be used to identify which object to update.
+	 * 
+	 * @param id
+	 *            an object definition, FSDefineShape, FSDefineImage, etc. that
+	 *            will be added to the display list.
+	 */
+	public void select(int id)
+	{
 		identifier = id;
-		place = new FSPlaceObject2(id, layer, 0,0);
+		place = new FSPlaceObject2(id, layer, 0, 0);
 		displayList.add(place);
-    }
+	}
 
-    /**
-     * Add an object to the later and select it to be added on the display list.
-     * 
-     * @param definition an object definition, FSDefineShape, FSDefineImage,
-     * etc. that will be added to the display list.
-     */
-    public void select(FSDefineObject definition)
-    {
+	/**
+	 * Add an object to the later and select it to be added on the display list.
+	 * 
+	 * @param definition
+	 *            an object definition, FSDefineShape, FSDefineImage, etc. that
+	 *            will be added to the display list.
+	 */
+	public void select(FSDefineObject definition)
+	{
 		add(definition);
 		select(definition.getIdentifier());
-    }
+	}
 
-    /**
-     * Set the coordinates where the object will be displayed.
-     * 
-     * @param x the x-coordinate, expressed in twips.
-     * @param y the y-coordinate, expressed in twips.
-     */
-    public void move(int x, int y) 
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, x, y);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setTransform(new FSCoordTransform(x, y));
-    	}
-    }
-    
-    /**
-     * Change the colour of the object to the values (r,g,b). The colour will
-     * be opaque so you cannot use this method to change only the colour of 
-     * a transparent object.
-     * 
-     * @param r the red component of the colour.
-     * @param g the green component of the colour.
-     * @param b the blue component of the colour.
-     */
-    public void color(int r, int g, int b)
-    {
-    	color(r,g,b,255);
-    }
-    
-    /**
-     * Change the colour of the object to the values (r,g,b,a).
-     * 
-     * @param r the red component of the colour.
-     * @param g the green component of the colour.
-     * @param b the blue component of the colour.
-     * @param a the transparency component.
-     */
-    public void color(int r, int g, int b, int a)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, new FSColorTransform(r, g, b, a));
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setColorTransform(new FSColorTransform(r, g, b, a));
-    	}
-    }
-    
-    /** 
-     * Set the number of layers that the outline of the object will clip when
-     * placed on the display list.
-     * 
-     * @param depth the number of layers that will be clipped.
-     */
-    public void clip(int depth)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, (FSCoordTransform)null);
-    		place.setClippingDepth(depth);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setClippingDepth(depth);
-    	}
-    }
-    
-    /**
-     * Set the point in the morphing process for a morph shape in the range 
-     * 0.0 to 1.0. May be set to zero if the shape being placed is not being 
-     * morphed.
-     * 
-     * @param ratio the ratio between the starting shape and the end shape.
-     */
-    public void morph(float ratio)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, ratio, null);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setRatio(ratio);
-    	}
-    }
-    
-    /**
-     * Assign a name to the object.
-     * 
-     * @param name a string that can be used to reference the object.
-     */
-    public void name(String name)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, (FSCoordTransform)null);
-    		place.setName(name);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setName(name);
-    	}
-    }
-        
-    /**
-     * Remove the object from the display list.
-     */
-    public void remove()
-    {
-    	if (place != null) {
-    		place = null;
-    	}
-    	
-    	displayList.add(new FSRemoveObject2(layer));
-    }
+	/**
+	 * Set the coordinates where the object will be displayed.
+	 * 
+	 * @param x
+	 *            the x-coordinate, expressed in twips.
+	 * @param y
+	 *            the y-coordinate, expressed in twips.
+	 */
+	public void move(int x, int y)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, x, y);
+			displayList.add(place);
+		} else
+		{
+			place.setTransform(new FSCoordTransform(x, y));
+		}
+	}
 
-    /**
-     * Replace the object on the display list.
-     */
-    public void replace(int id)
-    {
+	/**
+	 * Change the colour of the object to the values (r,g,b). The colour will be
+	 * opaque so you cannot use this method to change only the colour of a
+	 * transparent object.
+	 * 
+	 * @param r
+	 *            the red component of the colour.
+	 * @param g
+	 *            the green component of the colour.
+	 * @param b
+	 *            the blue component of the colour.
+	 */
+	public void color(int r, int g, int b)
+	{
+		color(r, g, b, 255);
+	}
+
+	/**
+	 * Change the colour of the object to the values (r,g,b,a).
+	 * 
+	 * @param r
+	 *            the red component of the colour.
+	 * @param g
+	 *            the green component of the colour.
+	 * @param b
+	 *            the blue component of the colour.
+	 * @param a
+	 *            the transparency component.
+	 */
+	public void color(int r, int g, int b, int a)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, new FSColorTransform(r, g, b, a));
+			displayList.add(place);
+		} else
+		{
+			place.setColorTransform(new FSColorTransform(r, g, b, a));
+		}
+	}
+
+	/**
+	 * Set the number of layers that the outline of the object will clip when
+	 * placed on the display list.
+	 * 
+	 * @param depth
+	 *            the number of layers that will be clipped.
+	 */
+	public void clip(int depth)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, (FSCoordTransform) null);
+			place.setClippingDepth(depth);
+			displayList.add(place);
+		} else
+		{
+			place.setClippingDepth(depth);
+		}
+	}
+
+	/**
+	 * Set the point in the morphing process for a morph shape in the range 0.0
+	 * to 1.0. May be set to zero if the shape being placed is not being
+	 * morphed.
+	 * 
+	 * @param ratio
+	 *            the ratio between the starting shape and the end shape.
+	 */
+	public void morph(float ratio)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, ratio, null);
+			displayList.add(place);
+		} else
+		{
+			place.setRatio(ratio);
+		}
+	}
+
+	/**
+	 * Assign a name to the object.
+	 * 
+	 * @param name
+	 *            a string that can be used to reference the object.
+	 */
+	public void name(String name)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, (FSCoordTransform) null);
+			place.setName(name);
+			displayList.add(place);
+		} else
+		{
+			place.setName(name);
+		}
+	}
+
+	/**
+	 * Remove the object from the display list.
+	 */
+	public void remove()
+	{
+		if (place != null)
+		{
+			place = null;
+		}
+
+		displayList.add(new FSRemoveObject2(layer));
+	}
+
+	/**
+	 * Replace the object on the display list.
+	 */
+	public void replace(int id)
+	{
 		identifier = id;
 
-		if (place == null) {
-    		place = new FSPlaceObject2(id, layer);
-    		displayList.add(place);
-    	}
-    	else {
-    		place.setIdentifier(id);
-    		place.setPlaceType(FSPlaceObject2.Replace);
-    	}
-    }
+		if (place == null)
+		{
+			place = new FSPlaceObject2(id, layer);
+			displayList.add(place);
+		} else
+		{
+			place.setIdentifier(id);
+			place.setPlaceType(FSPlaceObject2.Replace);
+		}
+	}
 
-    /**
-     * Change the colour of the object by applying a color transform.
-     * 
-     * @param color the color transform to apply to the shape.
-     */
-    public void change(FSColorTransform color)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, color);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setColorTransform(color);
-    	}
-    }
-    
-    /**
-     * Change the position, orientation and scaling of the object by applying a 
-     * 2D coordinate transform.
-     * 
-     * Use this method to apply more complex coordinate transforms to an object
-     * for example that composite move, scaling and rotation operations in a 
-     * single step.
-     * 
-     * @param coord the coordinate transform to apply to the object.
-     */
-    public void change(FSCoordTransform coord)
-    {
-    	if (place == null) {
-    		place = new FSPlaceObject2(layer, coord);
-    		displayList.add(place);
-    	}
-    	else {
-        	place.setTransform(coord);
-    	}
-    }
-    
-    /**
-     * Instruct the Flash Player to display a frame and render the contents of 
-     * the display list, applying the commands previously set. You must use this 
-     * method for any of the other operations to take effect.
-     * 
-     */
-    public void show()
-    {
-    	show(1);
-    }
-    
-    /**
-     * Display one or more frames. The state (position, orientation, visibility,
-     * etc.) of the object will remain unchanged for the duration of the 
-     * added frames. 
-     * 
-     * @param count the number of frames to be displayed.
-     * @throws IllegalArgumentException is the number of frames is less than 1.
-     */
-    public void show(int count)
-    {
-    	if (count &lt; 1) {
-    		throw new IllegalArgumentException(&quot;Must show at least one frame&quot;);
-    	}
-    	
-    	if (place != null) {
-    		place = null;
-    	}
-    	
-    	for (int i=0; i&lt;count; i++) {
-    		displayList.add(FSShowFrame.getInstance());
-    	}
-    }
+	/**
+	 * Change the colour of the object by applying a color transform.
+	 * 
+	 * @param color
+	 *            the color transform to apply to the shape.
+	 */
+	public void change(FSColorTransform color)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, color);
+			displayList.add(place);
+		} else
+		{
+			place.setColorTransform(color);
+		}
+	}
+
+	/**
+	 * Change the position, orientation and scaling of the object by applying a
+	 * 2D coordinate transform.
+	 * 
+	 * Use this method to apply more complex coordinate transforms to an object
+	 * for example that composite move, scaling and rotation operations in a
+	 * single step.
+	 * 
+	 * @param coord
+	 *            the coordinate transform to apply to the object.
+	 */
+	public void change(FSCoordTransform coord)
+	{
+		if (place == null)
+		{
+			place = new FSPlaceObject2(layer, coord);
+			displayList.add(place);
+		} else
+		{
+			place.setTransform(coord);
+		}
+	}
+
+	/**
+	 * Instruct the Flash Player to display a frame and render the contents of
+	 * the display list, applying the commands previously set. You must use this
+	 * method for any of the other operations to take effect.
+	 * 
+	 */
+	public void show()
+	{
+		show(1);
+	}
+
+	/**
+	 * Display one or more frames. The state (position, orientation, visibility,
+	 * etc.) of the object will remain unchanged for the duration of the added
+	 * frames.
+	 * 
+	 * @param count
+	 *            the number of frames to be displayed.
+	 * @throws IllegalArgumentException
+	 *             is the number of frames is less than 1.
+	 */
+	public void show(int count)
+	{
+		if (count &lt; 1)
+		{
+			throw new IllegalArgumentException(&quot;Must show at least one frame&quot;);
+		}
+
+		if (place != null)
+		{
+			place = null;
+		}
+
+		for (int i = 0; i &lt; count; i++)
+		{
+			displayList.add(FSShowFrame.getInstance());
+		}
+	}
 }
-

Modified: trunk/src/com/flagstone/transform/FSLimitScript.java
===================================================================
--- trunk/src/com/flagstone/transform/FSLimitScript.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSLimitScript.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,169 +31,199 @@
 package com.flagstone.transform;
 
 /**
-The FSLimitScript is used to define the execution environment of the Flash Player, 
-limiting the resources available when executing actions.
+ * The FSLimitScript is used to define the execution environment of the Flash
+ * Player, limiting the resources available when executing actions.
+ * 
+ * &lt;p&gt;
+ * FSLimitScript can be used to limit the maximum recursion depth and limit the
+ * time a sequence of actions can execute for. This provides a rudimentary
+ * mechanism for people viewing a movie to regain control of the Flash Player
+ * should a script fail.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;depth&lt;/td&gt;
+ * &lt;td&gt;The maximum depth, in the range 1..65535, that a sequence of actions can
+ * recurse to.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;timeout&lt;/td&gt;
+ * &lt;td&gt;The maximum time, in seconds, that a sequence of actions will execute
+ * before the Flash Player present a dialog box asking whether the script should
+ * be terminated.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSLimitScript represents the ScriptLimits tag in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSLimitScript extends FSMovieObject
+{
+	private int depth = 0;
+	private int timeout = 0;
 
-&lt;p&gt;FSLimitScript can be used to limit the maximum recursion depth and limit the time a sequence of actions can execute for. This provides a rudimentary mechanism for people viewing a movie to regain control of the Flash Player should a script fail.&lt;/p&gt;
+	/**
+	 * Construct an FSLimitScript object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSLimitScript(FSCoder coder)
+	{
+		super(LimitScript);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSLimitScript object that limits the recursion depth to
+	 * &lt;em&gt;depth&lt;/em&gt; levels and specifies that any sequence of actions will
+	 * timeout after &lt;em&gt;timeout&lt;/em&gt; seconds.
+	 * 
+	 * @param depth
+	 *            the maximum depth a sequence of actions can recurse to.
+	 * @param timeout
+	 *            the time in seconds that a sequence of actions is allowed to
+	 *            execute before the Flash Player displays a dialog box asking
+	 *            whether the script should be terminated.
+	 */
+	public FSLimitScript(int depth, int timeout)
+	{
+		super(LimitScript);
+		setDepth(depth);
+		setTimeout(timeout);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSLimitScript object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSLimitScript object.
+	 */
+	public FSLimitScript(FSLimitScript obj)
+	{
+		super(obj);
+		depth = obj.depth;
+		timeout = obj.timeout;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLimitScript_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the maximum recursion level.
+	 * 
+	 * @return the maximum depth a sequence of actions can recurse to.
+	 */
+	public int getDepth()
+	{
+		return depth;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLimitScript_1&quot;&gt;depth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum depth, in the range 1..65535, that a sequence of actions can recurse to.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the maximum recursion level.
+	 * 
+	 * @param depth
+	 *            the maximum depth a sequence of actions can recurse to.
+	 */
+	public void setDepth(int depth)
+	{
+		this.depth = depth;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLimitScript_1&quot;&gt;timeout&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The maximum time, in seconds, that a sequence of actions will execute before the Flash Player present a dialog box asking whether the script should be terminated.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the maximum time a sequence of actions will execute before the Flash
+	 * Player present a dialog box asking whether the script should be
+	 * terminated.
+	 * 
+	 * @return the time in seconds that a sequence of actions is allowed to
+	 *         execute.
+	 */
+	public int getTimeout()
+	{
+		return timeout;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the maximum time a sequence of actions will execute before the Flash
+	 * Player present a dialog box asking whether the script should be
+	 * terminated.
+	 * 
+	 * @param time
+	 *            the time in seconds that a sequence of actions is allowed to
+	 *            execute.
+	 */
+	public void setTimeout(int time)
+	{
+		timeout = time;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSLimitScript represents the ScriptLimits tag in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSLimitScript extends FSMovieObject
-{
-    private int depth = 0; 
-    private int timeout = 0; 
-    
-    /**
-     * Construct an FSLimitScript object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSLimitScript(FSCoder coder)
-    {
-        super(LimitScript);
-        decode(coder);
-    }
-    /**
-     * Constructs an FSLimitScript object that limits the recursion depth to &lt;em&gt;depth&lt;/em&gt; levels
-     * and specifies that any sequence of actions will timeout after &lt;em&gt;timeout&lt;/em&gt; seconds.
-     *
-     * @param depth the maximum depth a sequence of actions can recurse to.
-     * @param timeout the time in seconds that a sequence of actions is allowed to execute before the Flash Player displays a dialog box asking whether the script should be terminated.
-     */
-    public FSLimitScript(int depth, int timeout)
-    {
-        super(LimitScript);
-        setDepth(depth);
-        setTimeout(timeout);
-    }
-    /**
-     * Constructs an FSLimitScript object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSLimitScript object.
-     */
-    public FSLimitScript(FSLimitScript obj)
-    {
-        super(obj);
-        depth = obj.depth;
-        timeout = obj.timeout;
-    }    
+		if (super.equals(anObject))
+		{
+			FSLimitScript typedObject = (FSLimitScript) anObject;
 
-    /**
-     * Gets the maximum recursion level.
-     *
-     * @return the maximum depth a sequence of actions can recurse to.
-     */
-    public int getDepth() 
-    {
-        return depth;
-    }
+			result = depth == typedObject.depth;
+			result = result &amp;&amp; timeout == typedObject.timeout;
+		}
+		return result;
+	}
 
-    /**
-     * Sets the maximum recursion level.
-     *
-     * @param depth the maximum depth a sequence of actions can recurse to.
-     */
-    public void setDepth(int depth)
-    {
-        this.depth = depth;
-    }
-    
-    /**
-     * Gets the maximum time a sequence of actions will execute before the Flash Player present a dialog box asking whether the script should be terminated.
-     *
-     * @return the time in seconds that a sequence of actions is allowed to execute.
-     */
-    public int getTimeout() 
-    {
-        return timeout;
-    }
+	public void appendDescription(StringBuffer buffer, int stackDepth)
+	{
+		buffer.append(name());
 
-    /**
-     * Sets the maximum time a sequence of actions will execute before the Flash Player present a dialog box asking whether the script should be terminated.
-     *
-     * @param time the time in seconds that a sequence of actions is allowed to execute.
-     */
-    public void setTimeout(int time)
-    {
-        timeout = time;
-    }
-    
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSLimitScript typedObject = (FSLimitScript) anObject;
-            
-            result = depth == typedObject.depth;
-            result = result &amp;&amp; timeout == typedObject.timeout;
-        }
-        return result;
-    }
+		if (stackDepth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;depth&quot;, depth);
+			Transform.append(buffer, &quot;timeout&quot;, timeout);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public void appendDescription(StringBuffer buffer, int stackDepth)
-    {
-        buffer.append(name());
-        
-        if (stackDepth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;depth&quot;, depth);
-            Transform.append(buffer, &quot;timeout&quot;, timeout);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(depth, 2);
-        coder.writeWord(timeout, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        depth = coder.readWord(2, false);
-        timeout = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+		length += 4;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(depth, 2);
+		coder.writeWord(timeout, 2);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		depth = coder.readWord(2, false);
+		timeout = coder.readWord(2, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSLine.java
===================================================================
--- trunk/src/com/flagstone/transform/FSLine.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSLine.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,225 +31,260 @@
 package com.flagstone.transform;
 
 /**
-FSLine defines a straight line. 
+ * FSLine defines a straight line. The line is drawn from the current drawing
+ * point to the end point specified in the FSLine object which is specified
+ * relative to the current drawing point. Once the line is drawn, the end of the
+ * line is now the current drawing point.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;x&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of the end point of the line, relative to the current
+ * drawing point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;y&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of the end point of the line, relative to the current
+ * drawing point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The relative coordinates are specified in twips (where 20 twips = 1 pixel)
+ * and must be in the range -65536..65535.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Lines are drawn with rounded corners and line ends. Different join and line
+ * end styles can be created by drawing line segments as a sequence of filled
+ * shapes. With 1 twip equal to 1/20th of a pixel this technique can easily be
+ * used to draw the narrowest of visible lines.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * &lt;p&gt;
+ * The FSLine class represents the StraightEdge record from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSLine extends FSTransformObject
+{
+	private int x = 0;
+	private int y = 0;
 
-&lt;p&gt;The line is drawn from the current drawing point to the end point specified in the FSLine object which is specified relative to the current drawing point. Once the line is drawn, the end of the line is now the current drawing point.&lt;/P&gt;
+	/**
+	 * Construct an FSLine object and initialise it with the values decoded from
+	 * an encoded line.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing the encoded colour transform.
+	 */
+	public FSLine(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSLine with the specified relative coordinates.
+	 * 
+	 * @param xValue
+	 *            the x-coordinate of the end point, specified relative to the
+	 *            current drawing point.
+	 * @param yValue
+	 *            the y-coordinate of the end point, specified relative to the
+	 *            current drawing point.
+	 */
+	public FSLine(int xValue, int yValue)
+	{
+		setX(xValue);
+		setY(yValue);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSCoordTransform object by copying an existing object.
+	 */
+	public FSLine(FSLine obj)
+	{
+		x = obj.x;
+		y = obj.y;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLine_0&quot;&gt;x&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The x-coordinate of the end point of the line, relative to the current drawing point.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the relative x-coordinate.
+	 * 
+	 * @return the x-coordinate of the end point.
+	 */
+	public int getX()
+	{
+		return x;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSLine_1&quot;&gt;y&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The y-coordinate of the end point of the line, relative to the current drawing point.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the relative y-coordinate.
+	 * 
+	 * @return the y-coordinate of the end point.
+	 */
+	public int getY()
+	{
+		return y;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the relative x-coordinate.
+	 * 
+	 * @param aNumber
+	 *            the x-coordinate of the end point.
+	 */
+	public void setX(int aNumber)
+	{
+		x = aNumber;
+	}
 
-&lt;p&gt;The relative coordinates are specified in twips (where 20 twips = 1 pixel) and must be in the range -65536..65535.&lt;/p&gt;
+	/**
+	 * Sets the relative y-coordinate.
+	 * 
+	 * @param aNumber
+	 *            the y-coordinate of the end point.
+	 */
+	public void setY(int aNumber)
+	{
+		y = aNumber;
+	}
 
-&lt;p&gt;Lines are drawn with rounded corners and line ends. Different join and line end styles can be created by drawing line segments as a sequence of filled shapes. With 1 twip equal to 1/20th of a pixel this technique can easily be used to draw the narrowest of visible lines.&lt;/p&gt;
+	/**
+	 * Sets the relative x and y coordinates.
+	 * 
+	 * @param xValue
+	 *            the x-coordinate of the end point.
+	 * @param yValue
+	 *            the y-coordinate of the end point.
+	 */
+	public void setPoint(int xValue, int yValue)
+	{
+		x = xValue;
+		y = yValue;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSLine class represents the StraightEdge record from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSLine extends FSTransformObject
-{
-    private int x = 0;
-    private int y = 0;
+		if (super.equals(anObject))
+		{
+			FSLine typedObject = (FSLine) anObject;
 
-    /**
-     * Construct an FSLine object and initialize it with the values decoded from 
-     * an encoded line.
-     * 
-     * @param coder an FSCoder object containing the encoded colour transform.
-     */
-    public FSLine(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSLine with the specified relative coordinates.
+			result = x == typedObject.x;
+			result = result &amp;&amp; y == typedObject.y;
+		}
+		return result;
+	}
 
-        @param xValue the x-coordinate of the end point, specified relative to the current drawing point.
-        @param yValue the y-coordinate of the end point, specified relative to the current drawing point.
-        */
-    public FSLine(int xValue, int yValue)
-    {
-        setX(xValue);
-        setY(yValue);
-    }
-    /**
-     * Construct an FSCoordTransform object by copying an existing object.
-     */
-    public FSLine(FSLine obj)
-    {
-        x = obj.x;
-        y = obj.y;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the relative x-coordinate.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;x&quot;, x);
+			Transform.append(buffer, &quot;y&quot;, y);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the x-coordinate of the end point.
-        */
-    public int getX() 
-    {
-        return x;
-    }
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 7;
 
-    /** Gets the relative y-coordinate.
+		int _fieldSize = FSCoder.size(new int[]
+		{
+			x, y, 1 }, true);
 
-        @return the y-coordinate of the end point.*/
-    public int getY() 
-    {
-        return y;
-    }
+		if (containsGeneralLine())
+			numberOfBits += _fieldSize * 2;
+		else
+		{
+			numberOfBits += 1 + _fieldSize;
+		}
 
-    /** Sets the relative x-coordinate.
+		coder.context[FSCoder.NumberOfShapeBits] += numberOfBits;
 
-        @param aNumber the x-coordinate of the end point.
-        */
-    public void setX(int aNumber)
-    {
-        x = aNumber;
-    }
+		return numberOfBits;
+	}
 
-    /** Sets the relative y-coordinate.
+	public void encode(FSCoder coder)
+	{
+		boolean _containsGeneralLine = containsGeneralLine();
+		boolean _containsVerticalLine = containsVerticalLine();
 
-        @param aNumber the y-coordinate of the end point.
-        */
-    public void setY(int aNumber)
-    {
-        y = aNumber;
-    }
+		int _fieldSize = FSCoder.size(new int[]
+		{
+			x, y, 1 }, true);
 
-    /** Sets the relative x and y coordinates.
+		coder.writeBits(1, 1);
+		coder.writeBits(1, 1);
+		coder.writeBits(_fieldSize - 2, 4);
+		coder.writeBits(_containsGeneralLine ? 1 : 0, 1);
 
-        @param xValue the x-coordinate of the end point.
-        @param yValue the y-coordinate of the end point.
-        */
-    public void setPoint(int xValue, int yValue)
-    {
-        x = xValue;
-        y = yValue;
-    }
+		if (_containsGeneralLine)
+		{
+			coder.writeBits(x, _fieldSize);
+			coder.writeBits(y, _fieldSize);
+		} else
+		{
+			coder.writeBits(_containsVerticalLine ? 1 : 0, 1);
+			coder.writeBits(_containsVerticalLine ? y : x, _fieldSize);
+		}
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSLine typedObject = (FSLine)anObject;
-            
-            result = x == typedObject.x;
-            result = result &amp;&amp; y == typedObject.y;
-        }
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		/* shapeType */coder.readBits(1, false);
+		/* edgeType */coder.readBits(1, false);
+		int fieldSize = coder.readBits(4, false) + 2;
 
-     public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		boolean _containsGeneralLine = coder.readBits(1, false) != 0 ? true
+						: false;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;x&quot;, x);
-            Transform.append(buffer, &quot;y&quot;, y);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (_containsGeneralLine)
+		{
+			x = coder.readBits(fieldSize, true);
+			y = coder.readBits(fieldSize, true);
+		} else
+		{
+			boolean _containsVerticalLine = coder.readBits(1, false) != 0;
 
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 7;
-    
-        int _fieldSize = FSCoder.size(new int[]{x, y, 1}, true);
+			if (_containsVerticalLine)
+			{
+				y = coder.readBits(fieldSize, true);
+			} else
+			{
+				x = coder.readBits(fieldSize, true);
+			}
+		}
+	}
 
-        if (containsGeneralLine())
-            numberOfBits += _fieldSize * 2;
-        else
-        {
-            numberOfBits += 1 + _fieldSize;
-        }
-    
-        coder.context[FSCoder.NumberOfShapeBits] += numberOfBits;
+	private boolean containsGeneralLine()
+	{
+		return x != 0 &amp;&amp; y != 0;
+	}
 
-        return numberOfBits;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsGeneralLine = containsGeneralLine();
-        boolean _containsVerticalLine = containsVerticalLine();
-        
-        int _fieldSize = FSCoder.size(new int[]{x, y, 1}, true);
-
-        coder.writeBits(1, 1);
-        coder.writeBits(1, 1);
-        coder.writeBits(_fieldSize-2, 4);
-        coder.writeBits(_containsGeneralLine ? 1 : 0, 1);
-            
-        if (_containsGeneralLine)
-        {
-            coder.writeBits(x, _fieldSize);
-            coder.writeBits(y, _fieldSize);
-        }
-        else
-        {
-            coder.writeBits(_containsVerticalLine ? 1 : 0, 1);
-            coder.writeBits(_containsVerticalLine ? y : x, _fieldSize);
-        } 
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        /* shapeType */ coder.readBits(1, false);
-        /* edgeType */ coder.readBits(1, false);
-        int fieldSize = coder.readBits(4, false)+2;
-
-        boolean _containsGeneralLine = coder.readBits(1, false) != 0 ? true : false;
-
-        if (_containsGeneralLine)
-        {
-            x = coder.readBits(fieldSize, true);
-            y = coder.readBits(fieldSize, true);
-        }
-        else
-        {
-            boolean _containsVerticalLine = coder.readBits(1, false) != 0;
-
-            if (_containsVerticalLine)
-            {
-                y = coder.readBits(fieldSize, true);
-            }
-            else
-            {
-                x = coder.readBits(fieldSize, true);
-            }
-        }
-    }
-    
-    private boolean containsGeneralLine()
-    {
-        return x != 0 &amp;&amp; y != 0;
-    }
-    
-    private boolean containsVerticalLine()
-    {
-        return x == 0;
-    }
+	private boolean containsVerticalLine()
+	{
+		return x == 0;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSLineStyle.java
===================================================================
--- trunk/src/com/flagstone/transform/FSLineStyle.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSLineStyle.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,11 +30,12 @@
 
 package com.flagstone.transform;
 
-/** The FSLineStyle is the abstract root class for line styles.
-*/
+/**
+ * The FSLineStyle is the abstract root class for line styles.
+ */
 public abstract class FSLineStyle extends FSTransformObject
 {
-    FSLineStyle()
-    {
-    }
+	FSLineStyle()
+	{
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSMorphBitmapFill.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMorphBitmapFill.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMorphBitmapFill.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,211 +31,284 @@
 package com.flagstone.transform;
 
 /**
-FSMorphBitmapFill uses a bitmap image to fill an area of a morphing shape. 
+ * FSMorphBitmapFill uses a bitmap image to fill an area of a morphing shape.
+ * 
+ * &lt;p&gt;
+ * Two types of bitmap fill are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;Clipped - the image is placed in the middle of the area to be filled. If
+ * the area to be filled is larger than the image then the colour at the edge of
+ * the image is used to fill the remaining area.&lt;/li&gt;
+ * &lt;li&gt;Tiled - the image is tiled across the area to be filled.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;The type of bitmap fill, either FSFillStyle.Tiled or
+ * FSFillStyle.Clipped.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the image that will be displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;start&lt;/td&gt;
+ * &lt;td&gt;An optional FSCoordTransform object that will be applied to the image,
+ * to change its origin, orientation, etc., at the start of the morphing
+ * process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;end&lt;/td&gt;
+ * &lt;td&gt;An optional FSCoordTransform object that will be applied to the image,
+ * to change its origin, orientation, etc., at the end of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The bitmap is referenced using the identifier obtains from an instance of an
+ * FSDefineJPEGImage, FSDefineJPEGImage2, FSDefineJPEGImage3, FSDefineImage or
+ * FSDefineImage2 object. Only one image can be displayed throughout the
+ * morphing process.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When an image is loaded its width and height default to twips rather than
+ * pixels. An image 300 x 200 pixels will be displayed as 300 x 200 twips (15 x
+ * 10 pixels). Scaling the image by 20 (20 twips = 1 pixel) would restore it to
+ * its original size. The FSCoordTransform attribute in the FSBitmapFill object
+ * can be used to scale the image to its original size.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The image is drawn with the top left corner at the origin of the shape being
+ * filled so the scaling transform must be composited with the translation
+ * transform that places the image at the desired location within the shape.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSMorphBitmapFill class represents the MorphFillStyle structure from the
+ * Macromedia Flash (SWF) File Format Specification. Shape morphing was
+ * introduced in Flash 3.
+ * &lt;/P&gt;
+ */
+public class FSMorphBitmapFill extends FSFillStyle
+{
+	private int identifier = 0;
+	private FSCoordTransform startTransform = new FSCoordTransform(0, 0);
+	private FSCoordTransform endTransform = new FSCoordTransform(0, 0);
 
-&lt;p&gt;Two types of bitmap fill are supported:&lt;/p&gt;
+	/**
+	 * Construct an FSMorphBitmapFill object an initialise it with values
+	 * decoded from an encoded FSMorphBitmapFill object.
+	 * 
+	 * @param coder
+	 *            an FSCoder object containing an FSMorphBitmapFill encoded as
+	 *            binary data.
+	 */
+	public FSMorphBitmapFill(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;ul&gt;
-&lt;li&gt;Clipped - the image is placed in the middle of the area to be filled. If the area to be filled is larger
-than the image then the colour at the edge of the image is used to fill the remaining area.&lt;/li&gt;
-&lt;li&gt;Tiled - the image is tiled across the area to be filled.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Constructs an FSMorphBitmapFill specifying the type, bitmap image and
+	 * coordinated transforms for the image at the start and end of the morphing
+	 * process.
+	 * 
+	 * @param aType
+	 *            the type of fill either FSFillStyle.Tiled or
+	 *            FSFillStyle.Clipped.
+	 * @param anIdentifier
+	 *            the identifier for the bitmap image.
+	 * @param aStartTransform
+	 *            the transform applied to the image at the start of the
+	 *            morphing process.
+	 * @param anEndTransform
+	 *            the transform applied to the image at the end of the morphing
+	 *            process.
+	 */
+	public FSMorphBitmapFill(int aType, int anIdentifier,
+								FSCoordTransform aStartTransform,
+								FSCoordTransform anEndTransform)
+	{
+		super(aType);
+		setIdentifier(anIdentifier);
+		setStartTransform(aStartTransform);
+		setEndTransform(anEndTransform);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSMorphBitmapFill object by copying an existing object.
+	 * 
+	 * @param obj
+	 *            an FSMorphBitmapFill object.
+	 */
+	public FSMorphBitmapFill(FSMorphBitmapFill obj)
+	{
+		identifier = obj.identifier;
+		startTransform = new FSCoordTransform(obj.startTransform);
+		endTransform = new FSCoordTransform(obj.endTransform);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Gets the identifier of the bitmap image.
+	 * 
+	 * @return the image's identifier.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphBitmapFill_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The type of bitmap fill, either FSFillStyle.Tiled or FSFillStyle.Clipped.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the starting coordinate transform for the image.
+	 * 
+	 * @return the starting coordinate transform.
+	 */
+	public FSCoordTransform getStartTransform()
+	{
+		return startTransform;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphBitmapFill_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the image that will be displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the ending coordinate transform for the image.
+	 * 
+	 * @return the ending coordinate transform.
+	 */
+	public FSCoordTransform getEndTransform()
+	{
+		return endTransform;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphBitmapFill_2&quot;&gt;startTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An optional FSCoordTransform object that will be applied to the image, to change its origin, orientation, etc., at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the identifier of the bitmap image to be used in the morphing
+	 * process.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the bitmap image.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphBitmapFill_3&quot;&gt;endTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An optional FSCoordTransform object that will be applied to the image, to change its origin, orientation, etc., at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the coordinate transform for the image at the start of the morphing
+	 * process.
+	 * 
+	 * @param aTransform
+	 *            the starting coordinate transform.
+	 */
+	public void setStartTransform(FSCoordTransform aTransform)
+	{
+		startTransform = aTransform;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the coordinate transform for the image at the end of the morphing
+	 * process.
+	 * 
+	 * @param aTransform
+	 *            the ending coordinate transform.
+	 */
+	public void setEndTransform(FSCoordTransform aTransform)
+	{
+		endTransform = aTransform;
+	}
 
-&lt;p&gt;The bitmap is referenced using the identifier obtains from an instance of an FSDefineJPEGImage, FSDefineJPEGImage2, FSDefineJPEGImage3, FSDefineImage or FSDefineImage2 object. Only one image can be displayed throughout the morphing process.&lt;/p&gt;
+	public Object clone()
+	{
+		FSMorphBitmapFill anObject = (FSMorphBitmapFill) super.clone();
 
-&lt;p&gt;When an image is loaded its width and height default to twips rather than pixels. An image 300 x 200 pixels will be displayed as 300 x 200 twips (15 x 10 pixels). Scaling the image by 20 (20 twips = 1 pixel) would restore it to its original size. The FSCoordTransform attribute in the FSBitmapFill object can be used to scale the image to its original size.&lt;/p&gt;
+		anObject.startTransform = (startTransform != null) ? (FSCoordTransform) startTransform
+						.clone()
+						: null;
+		anObject.endTransform = (endTransform != null) ? (FSCoordTransform) endTransform
+						.clone()
+						: null;
 
-&lt;p&gt;The image is drawn with the top left corner at the origin of the shape being filled so the scaling transform must be composited with the translation transform that places the image at the desired location within the shape.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSMorphBitmapFill class represents the MorphFillStyle structure from the Macromedia Flash (SWF) File Format Specification. Shape morphing was introduced in Flash 3.&lt;/P&gt;
- */  
-public class FSMorphBitmapFill extends FSFillStyle
-{
-    private int identifier = 0;
-    private FSCoordTransform startTransform = new FSCoordTransform(0,0);
-    private FSCoordTransform endTransform = new FSCoordTransform(0,0);
+		if (super.equals(anObject))
+		{
+			FSMorphBitmapFill typedObject = (FSMorphBitmapFill) anObject;
 
-    /**
-     * Construct an FSMorphBitmapFill object an initialize it with values 
-     * decoded from an encoded FSMorphBitmapFill object.
-     * 
-     * @param coder an FSCoder object containing an FSMorphBitmapFill encoded 
-     * as binary data.
-     */
-    public FSMorphBitmapFill(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSMorphBitmapFill specifying the type, bitmap image and coordinated transforms for the image at the start and end of the morphing process.
+			result = identifier == typedObject.identifier;
 
-        @param aType the type of fill either FSFillStyle.Tiled or FSFillStyle.Clipped.
-        @param anIdentifier the identifier for the bitmap image.
-        @param aStartTransform the transform applied to the image at the start of the morphing process.
-        @param anEndTransform the transform applied to the image at the end of the morphing process.
-        */
-    public FSMorphBitmapFill(int aType, int anIdentifier, FSCoordTransform aStartTransform, FSCoordTransform anEndTransform)
-    {
-        super(aType);
-        setIdentifier(anIdentifier);
-        setStartTransform(aStartTransform);
-        setEndTransform(anEndTransform);
-    }
-    /**
-     * Construct an FSMorphBitmapFill object by copying an existing object.
-     * 
-     * @param obj an FSMorphBitmapFill object. 
-     */
-    public FSMorphBitmapFill(FSMorphBitmapFill obj)
-    {
-        identifier = obj.identifier;
-        startTransform = new FSCoordTransform(obj.startTransform);
-        endTransform = new FSCoordTransform(obj.endTransform);
-    }   
+			if (startTransform != null)
+				result = result
+								&amp;&amp; startTransform
+												.equals(typedObject.startTransform);
+			else
+				result = result &amp;&amp; startTransform == typedObject.startTransform;
 
-    /** Gets the identifier of the bitmap image.
+			if (endTransform != null)
+				result = result
+								&amp;&amp; endTransform
+												.equals(typedObject.endTransform);
+			else
+				result = result &amp;&amp; endTransform == typedObject.endTransform;
+		}
+		return result;
+	}
 
-        @return the image's identifier.
-        */
-    public int getIdentifier() { return identifier; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the starting coordinate transform for the image.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;startTransform&quot;, startTransform, depth);
+			Transform.append(buffer, &quot;endTransform&quot;, endTransform, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the starting coordinate transform.
-        */
-    public FSCoordTransform getStartTransform() { return startTransform; }
+	public int length(FSCoder coder)
+	{
+		int length = super.length(coder);
 
-    /** Gets the ending coordinate transform for the image.
+		length += 2;
+		length += startTransform.length(coder);
+		length += endTransform.length(coder);
 
-        @return the ending coordinate transform.
-        */
-    public FSCoordTransform getEndTransform() { return endTransform; }
+		return length;
+	}
 
-    /** Sets the identifier of the bitmap image to be used in the morphing process.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(identifier, 2);
+		startTransform.encode(coder);
+		endTransform.encode(coder);
+	}
 
-        @param anIdentifier the identifier of the bitmap image.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier= anIdentifier;
-    }
-
-    /** Sets the coordinate transform for the image at the start of the morphing process.
-
-        @param aTransform the starting coordinate transform.
-        */
-    public void setStartTransform(FSCoordTransform aTransform)
-    {
-        startTransform = aTransform;
-    }
-
-    /** Sets the coordinate transform for the image at the end of the morphing process.
-
-        @param aTransform the ending coordinate transform.
-        */
-    public void setEndTransform(FSCoordTransform aTransform)
-    {
-        endTransform = aTransform;
-    }
-
-    public Object clone()
-    {
-        FSMorphBitmapFill anObject = (FSMorphBitmapFill)super.clone();
-        
-        anObject.startTransform = (startTransform != null) ? (FSCoordTransform)startTransform.clone() : null;
-        anObject.endTransform = (endTransform != null) ? (FSCoordTransform)endTransform.clone() : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSMorphBitmapFill typedObject = (FSMorphBitmapFill)anObject;
-            
-            result = identifier == typedObject.identifier;
-
-            if (startTransform != null)
-                result = result &amp;&amp; startTransform.equals(typedObject.startTransform);
-            else
-                result = result &amp;&amp; startTransform == typedObject.startTransform;
-
-            if (endTransform != null)
-                result = result &amp;&amp; endTransform.equals(typedObject.endTransform);
-            else
-                result = result &amp;&amp; endTransform == typedObject.endTransform;
-        }
-        return result;
-    }
-
-     public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;startTransform&quot;, startTransform, depth);
-            Transform.append(buffer, &quot;endTransform&quot;, endTransform, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = super.length(coder);
-
-        length += 2;
-        length += startTransform.length(coder);
-        length += endTransform.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(identifier, 2);
-        startTransform.encode(coder);
-        endTransform.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        identifier= coder.readWord(2, false);
-        startTransform.decode(coder);
-        endTransform.decode(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		identifier = coder.readWord(2, false);
+		startTransform.decode(coder);
+		endTransform.decode(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSMorphGradient.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMorphGradient.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMorphGradient.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,230 +31,299 @@
 package com.flagstone.transform;
 
 /**
-FSMorphGradient defines the control points that is used to specify how a gradient fill is 
-displayed at the start and end of the shape morphing process. 
- 
-&lt;p&gt;Two or more control points are used to define how the colour changes across the gradient square.&lt;/p&gt;
+ * FSMorphGradient defines the control points that is used to specify how a
+ * gradient fill is displayed at the start and end of the shape morphing
+ * process.
+ * 
+ * &lt;p&gt;
+ * Two or more control points are used to define how the colour changes across
+ * the gradient square.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startRatio&lt;/td&gt;
+ * &lt;td&gt;The location of the control point across the gradient square at the
+ * start of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;endRatio&lt;/td&gt;
+ * &lt;td&gt;The location of the control point across the gradient square at the end
+ * of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startColor&lt;/td&gt;
+ * &lt;td&gt;The colour at the control point at the start of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startColor&lt;/td&gt;
+ * &lt;td&gt;The colour at the control point at the end of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The location of the control point is defined by a ratio - a number between 0
+ * and 255 that specifies the relative location in the square. For Linear
+ * Gradient Fills a ratio of zero is mapped to the left side of the gradient
+ * square and 255 is mapped to the right side of the square. For Radial Gradient
+ * Fills a ratio of zero is mapped to the centre of the gradient square and 255
+ * is mapped to the edge of the largest circle that fits inside the gradient
+ * square.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * FSMorphGradients are only used in FSDefineMorphShape objects which support
+ * transparent colours so values for all the colour channels must be specified
+ * in the FSColor objects.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When the Flash Player displays the gradient control points they are sorted by
+ * the ratio with the FSGradient object with the smallest ratio value displayed
+ * first.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSMorphGradient class represents the MorphGradientRecord structure from
+ * the Macromedia Flash (SWF) File Format Specification. Shape morphing was
+ * introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSMorphGradient extends FSTransformObject
+{
+	private int startRatio = 0;
+	private int endRatio = 0;
+	private FSColor startColor = null;
+	private FSColor endColor = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSMorphGradient object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSMorphGradient(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphGradient object specifying the starting and ending
+	 * ratios and colours.
+	 * 
+	 * @param aStartRatio
+	 *            the ratio along the gradient square at the start of the
+	 *            morphing process.
+	 * @param anEndRatio
+	 *            the ratio along the gradient square at the end of the morphing
+	 *            process.
+	 * @param aStartColor
+	 *            the colour at the starting control point.
+	 * @param anEndColor
+	 *            the colour at the ending control point.
+	 */
+	public FSMorphGradient(int aStartRatio, int anEndRatio,
+							FSColor aStartColor, FSColor anEndColor)
+	{
+		setStartRatio(aStartRatio);
+		setEndRatio(anEndRatio);
+		setStartColor(aStartColor);
+		setEndColor(anEndColor);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradient_0&quot;&gt;startRatio&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The location of the control point across the gradient square at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphGradient object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSMorphGradient object.
+	 */
+	public FSMorphGradient(FSMorphGradient obj)
+	{
+		startRatio = obj.startRatio;
+		endRatio = obj.endRatio;
+		startColor = new FSColor(obj.startColor);
+		endColor = new FSColor(obj.endColor);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradient_1&quot;&gt;endRatio&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The location of the control point across the gradient square at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the ratio at the start of the morphing process.
+	 * 
+	 * @return the start ratio.
+	 */
+	public int getStartRatio()
+	{
+		return startRatio;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradient_2&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour at the control point at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the ratio at the end of the morphing process.
+	 * 
+	 * @return the end ratio.
+	 */
+	public int getEndRatio()
+	{
+		return endRatio;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradient_3&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour at the control point at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the colour at the start of the morphing process.
+	 * 
+	 * @return the start colour.
+	 */
+	public FSColor getStartColor()
+	{
+		return startColor;
+	}
 
-&lt;p&gt;The location of the control point is defined by a ratio - a number between 0 and 255 that specifies the relative location in the square. For Linear Gradient Fills a ratio of zero is mapped to the left side of the gradient square and 255 is mapped to the right side of the square. For Radial Gradient Fills a ratio of zero is mapped to the centre of the gradient square and 255 is mapped to the edge of the largest circle that fits inside the gradient square.&lt;/p&gt;
+	/**
+	 * Gets the colour at the end of the morphing process.
+	 * 
+	 * @return the end colour.
+	 */
+	public FSColor getEndColor()
+	{
+		return endColor;
+	}
 
-&lt;p&gt;FSMorphGradients are only used in FSDefineMorphShape objects which support transparent colours so values for all the colour channels must be specified in the FSColor objects.&lt;/p&gt;
+	/**
+	 * Sets the ratio along the gradient square at the start of the morphing
+	 * process.
+	 * 
+	 * @param aNumber
+	 *            the starting ratio.
+	 */
+	public void setStartRatio(int aNumber)
+	{
+		startRatio = aNumber;
+	}
 
-&lt;p&gt;When the Flash Player displays the gradient control points they are sorted by the ratio with the FSGradient object with the smallest ratio value displayed first.&lt;/p&gt;
+	/**
+	 * Sets the ratio along the gradient square at the end of the morphing
+	 * process.
+	 * 
+	 * @param aNumber
+	 *            the ending ratio.
+	 */
+	public void setEndRatio(int aNumber)
+	{
+		endRatio = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the colour at the start of the morphing process.
+	 * 
+	 * @param aColor
+	 *            the start colour.
+	 */
+	public void setStartColor(FSColor aColor)
+	{
+		startColor = aColor;
+	}
 
-&lt;p&gt;The FSMorphGradient class represents the MorphGradientRecord structure from the Macromedia Flash (SWF) File Format Specification. Shape morphing was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSMorphGradient extends FSTransformObject
-{
-    private int startRatio = 0;
-    private int endRatio = 0;
-    private FSColor startColor = null;
-    private FSColor endColor = null;
-    
-    /**
-     * Construct an FSMorphGradient object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSMorphGradient(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSMorphGradient object specifying the starting and ending ratios and colours.
+	/**
+	 * Sets the colour at the end of the morphing process.
+	 * 
+	 * @param aColor
+	 *            the end colour.
+	 */
+	public void setEndColor(FSColor aColor)
+	{
+		endColor = aColor;
+	}
 
-        @param aStartRatio the ratio along the gradient square at the start of the morphing process.
-        @param anEndRatio the ratio along the gradient square at the end of the morphing process.
-        @param aStartColor the colour at the starting control point.
-        @param anEndColor the colour at the ending control point.
-        */
-    public FSMorphGradient(int aStartRatio, int anEndRatio, FSColor aStartColor, FSColor anEndColor)
-    {
-        setStartRatio(aStartRatio);
-        setEndRatio(anEndRatio);
-        setStartColor(aStartColor);
-        setEndColor(anEndColor);
-    }
-    /**
-     * Constructs an FSMorphGradient object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSMorphGradient object.
-     */
-    public FSMorphGradient(FSMorphGradient obj)
-    {
-        startRatio = obj.startRatio;
-        endRatio = obj.endRatio;
-        startColor = new FSColor(obj.startColor);
-        endColor = new FSColor(obj.endColor);
-    }    
+	public Object clone()
+	{
+		FSMorphGradient anObject = (FSMorphGradient) super.clone();
 
-    /** Gets the ratio at the start of the morphing process.
+		anObject.startColor = (startColor != null) ? (FSColor) startColor
+						.clone() : null;
+		anObject.endColor = (endColor != null) ? (FSColor) endColor.clone()
+						: null;
 
-        @return the start ratio.
-        */
-    public int getStartRatio() { return startRatio; }
+		return anObject;
+	}
 
-    /** Gets the ratio at the end of the morphing process.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the end ratio.
-        */
-    public int getEndRatio() { return endRatio; }
+		if (super.equals(anObject))
+		{
+			FSMorphGradient typedObject = (FSMorphGradient) anObject;
 
-    /** Gets the colour at the start of the morphing process.
+			result = startRatio == typedObject.startRatio;
+			result = result &amp;&amp; endRatio == typedObject.endRatio;
 
-        @return the start colour.
-        */
-    public FSColor getStartColor() { return startColor; }
+			if (startColor != null)
+				result = result &amp;&amp; startColor.equals(typedObject.startColor);
+			else
+				result = result &amp;&amp; startColor == typedObject.startColor;
 
-    /** Gets the colour at the end of the morphing process.
+			if (endColor != null)
+				result = result &amp;&amp; endColor.equals(typedObject.endColor);
+			else
+				result = result &amp;&amp; endColor == typedObject.endColor;
+		}
+		return result;
+	}
 
-        @return the end colour.
-        */
-    public FSColor getEndColor() { return endColor; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the ratio along the gradient square at the start of the morphing process.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;startRatio&quot;, startRatio);
+			Transform.append(buffer, &quot;endRatio&quot;, endRatio);
+			Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
+			Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aNumber the starting ratio.
-        */
-    public void setStartRatio(int aNumber)
-    {
-        startRatio = aNumber;
-    }
+	public int length(FSCoder coder)
+	{
+		int length = 2;
 
-    /** Sets the ratio along the gradient square at the end of the morphing process.
+		length += startColor.length(coder);
+		length += endColor.length(coder);
 
-        @param aNumber the ending ratio.
-        */
-    public void setEndRatio(int aNumber)
-    {
-        endRatio = aNumber;
-    }
+		return length;
+	}
 
-    /** Sets the colour at the start of the morphing process.
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(startRatio, 1);
+		startColor.encode(coder);
+		coder.writeWord(endRatio, 1);
+		endColor.encode(coder);
+	}
 
-        @param aColor the start colour.
-        */
-    public void setStartColor(FSColor aColor)
-    {
-        startColor = aColor;
-    }
-
-    /** Sets the colour at the end of the morphing process.
-
-        @param aColor the end colour.
-        */
-    public void setEndColor(FSColor aColor)
-    {
-        endColor = aColor;
-    }
-
-    public Object clone()
-    {
-        FSMorphGradient anObject = (FSMorphGradient)super.clone();
-        
-        anObject.startColor = (startColor != null) ? (FSColor)startColor.clone() : null;
-        anObject.endColor = (endColor != null) ? (FSColor)endColor.clone() : null;
-
-        return anObject;
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSMorphGradient typedObject = (FSMorphGradient)anObject;
-            
-            result = startRatio == typedObject.startRatio;
-            result = result &amp;&amp; endRatio == typedObject.endRatio;
-
-            if (startColor != null)
-                result = result &amp;&amp; startColor.equals(typedObject.startColor);
-            else
-                result = result &amp;&amp; startColor == typedObject.startColor;
-
-            if (endColor != null)
-                result = result &amp;&amp; endColor.equals(typedObject.endColor);
-            else
-                result = result &amp;&amp; endColor == typedObject.endColor;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startRatio&quot;, startRatio);
-            Transform.append(buffer, &quot;endRatio&quot;, endRatio);
-            Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
-            Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 2;
-    
-        length += startColor.length(coder);
-        length += endColor.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(startRatio, 1);
-        startColor.encode(coder);
-        coder.writeWord(endRatio, 1);
-        endColor.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        startRatio = coder.readWord(1, false);
-        startColor = new FSColor(coder);
-        endRatio = coder.readWord(1, false);
-        endColor = new FSColor(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		startRatio = coder.readWord(1, false);
+		startColor = new FSColor(coder);
+		endRatio = coder.readWord(1, false);
+		endColor = new FSColor(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSMorphGradientFill.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMorphGradientFill.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMorphGradientFill.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,298 +33,412 @@
 import java.util.*;
 
 /**
-FSMorphGradientFill defines how a colour changes across an area filled in a morphing shape. 
- 
-&lt;p&gt;Two type of gradient fill are supported:&lt;/p&gt;
+ * FSMorphGradientFill defines how a colour changes across an area filled in a
+ * morphing shape.
+ * 
+ * &lt;p&gt;
+ * Two type of gradient fill are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Linear&lt;/td&gt;
+ * &lt;td&gt;The gradient changes in one direction across the area to be filled.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;Radial&lt;/td&gt;
+ * &lt;td&gt;The gradient changes radially from the centre of the area to be filled.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Gradients are defined in terms of a standard space called the gradient
+ * square, centred at (0,0) and extending from (-16384, -16384) to (16384,
+ * 16384).
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/gradientSquare.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * A coordinate transform is required to map the gradient square to the
+ * coordinates of the filled area. The transformation is applied in two steps.
+ * First the gradient square is scaled so the colour covers the shape followed
+ * by a translation to map the gradient square coordinates to the coordinate
+ * range of the shape.
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;gradientMapping.gif&quot;&gt;
+ * 
+ * &lt;p&gt;
+ * A series of control points is used to control how the colour displayed
+ * changes across the gradient. At least two control points are required to
+ * define a gradient - one for the starting colour and one for the final colour.
+ * Up to eight control points may be specified to generate complex colour
+ * transitions. When the Flash Player displays the control points they are
+ * sorted by the ratio defined in each FSGradient object, with the smallest
+ * ratio value displayed first.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;The type of gradient fill, either FSFillStyle.Linear or
+ * FSFillStyle.Radial.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;startTransform&lt;/td&gt;
+ * &lt;td&gt;The coordinate transform used to map the logical coordinates of the
+ * gradient square on to a set of physical coordinates at the start of the
+ * morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;endTransform&lt;/td&gt;
+ * &lt;td&gt;The coordinate transform used to map the logical coordinates of the
+ * gradient square on to a set of physical coordinates at the end of the
+ * morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;gradients&lt;/td&gt;
+ * &lt;td&gt;An array of up to eight FSGradient objects that define the control
+ * points across the gradient square that control the colour transitions. The
+ * Flash Player performs the interpolation of the colour values between the
+ * control points. Alpha channel (defining transparency) must be defined for the
+ * colour in each control point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In addition to specifying the type of gradient fill that will be displayed
+ * the type attribute may be used when iterating through an array of fill style
+ * objects to identify the type of fill style without using run-time type
+ * checking.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * For the coordinate transformation, the scaling factor is calculated by diving
+ * the width of the gradient square by the width of the shape:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * float gradientSquareWidth = 32768.0f;
+ * 
+ * float scale = gradientSquareWidth / shapeWidth;
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The translation is defined by calculating the difference between the minimum
+ * coordinates of the &lt;em&gt;scaled&lt;/em&gt; gradient square and the minimum
+ * coordinates of the shape:
+ * 
+ * &lt;pre&gt;
+ * int gradientX = -16384; // minimum x coordinate of the gradient square.
+ * 
+ * int gradientY = -16384; // minimum y coordinate of the gradient square.
+ * 
+ * // Get the minimum coordinates of the shape being filled;
+ * int shapeX = shape.getBounds().getMinX();
+ * 
+ * int shapeY = shape.getBounds().getMinY();
+ * 
+ * // Now calculate the translation
+ * int translateX = shapeX - (gradientX / scale);
+ * 
+ * int translateY = shapeY - (gradientY / scale);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The FSCoordTransform has a convenient constructor to create the two-step
+ * transformation:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform composite = new FSCoordTransform(translateX, translateY,
+ * 				scale, scale);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The transform is independent of any transformation defined for the parent
+ * shape in which the gradient is displayed. The gradient will be displayed
+ * correctly if the shape is scaled, rotated, etc. when it is added to the
+ * display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The above process is repeated to calculate the transform for the gradient
+ * fill at the end of the morphing process. The transforms are independent of
+ * any transformation defined for the parent morphing shape in which the
+ * gradients are displayed.
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSMorphGradientFill class represents the MorphFillStyle structure from
+ * the Macromedia Flash (SWF) File Format Specification. It was introduced in
+ * Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSMorphGradientFill extends FSFillStyle
+{
+	private FSCoordTransform startTransform = null;
+	private FSCoordTransform endTransform = null;
+	private ArrayList gradients = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSMorphGradientFill object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSMorphGradientFill(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;Linear&lt;/td&gt;
-&lt;td&gt;The gradient changes in one direction across the area to be filled.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphGradientFill object specifying the type of fill,
+	 * starting and ending coordinate transforms and the array of gradient
+	 * records.
+	 * 
+	 * @param aType
+	 *            the type of gradient fill, either FSFillStyle.Linear or
+	 *            FSFillStyle.Radial.
+	 * @param aStartTransform
+	 *            the coordinate transform mapping the gradient square onto
+	 *            physical coordinates at the start of the morphing process.
+	 * @param anEndTransform
+	 *            the coordinate transform mapping the gradient square onto
+	 *            physical coordinates at the end of the morphing process.
+	 * @param anArray
+	 *            an array of up to eight FSMorphGradient objects defining the
+	 *            control points for the gradient.
+	 */
+	public FSMorphGradientFill(int aType, FSCoordTransform aStartTransform,
+								FSCoordTransform anEndTransform,
+								ArrayList anArray)
+	{
+		super(aType);
+		setStartTransform(aStartTransform);
+		setEndTransform(anEndTransform);
+		setGradients(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;Radial&lt;/td&gt;
-&lt;td&gt;The gradient changes radially from the centre of the area to be filled.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphGradientFill object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSMorphGradientFill object.
+	 */
+	public FSMorphGradientFill(FSMorphGradientFill obj)
+	{
+		super(obj);
+		startTransform = new FSCoordTransform(obj.startTransform);
+		endTransform = new FSCoordTransform(obj.endTransform);
 
-&lt;/table&gt;
+		gradients = new ArrayList(obj.gradients.size());
 
-&lt;p&gt;Gradients are defined in terms of a  standard space called the gradient square, centred at (0,0) and extending from (-16384, -16384) to (16384, 16384).&lt;/p&gt;
+		for (Iterator i = obj.gradients.iterator(); i.hasNext();)
+			gradients.add(((FSGradient) i.next()).clone());
+	}
 
-&lt;img src=&quot;doc-files/gradientSquare.gif&quot;&gt;
+	/**
+	 * Add a FSMorphGradient object to the array of gradient objects.
+	 * 
+	 * @param aGradient
+	 *            an FSMorphGradient object.
+	 */
+	public void add(FSMorphGradient aGradient)
+	{
+		gradients.add(aGradient);
+	}
 
-&lt;p&gt;A coordinate transform is required to map the gradient square to the coordinates of the filled area. The transformation is applied in two steps. First the gradient square is scaled so the colour covers the shape followed by a translation to map the gradient square coordinates to the coordinate range of the shape.&lt;/p&gt;
+	/**
+	 * Gets the coordinate transform mapping the gradient square onto physical
+	 * coordinates at the start of the morphing process.
+	 * 
+	 * @return the starting coordinate transform.
+	 */
+	public FSCoordTransform getStartTransform()
+	{
+		return startTransform;
+	}
 
-&lt;img src=&quot;gradientMapping.gif&quot;&gt;
+	/**
+	 * Gets the coordinate transform mapping the gradient square onto physical
+	 * coordinates at the end of the morphing process.
+	 * 
+	 * @return the ending coordinate transform.
+	 */
+	public FSCoordTransform getEndTransform()
+	{
+		return endTransform;
+	}
 
-&lt;p&gt;A series of control points is used to control how the colour displayed changes across the gradient. At least two control points are required to define a gradient - one for the starting colour and one for the final colour. Up to eight control points may be specified to generate complex colour transitions. When the Flash Player displays the control points they are sorted by the ratio defined in each FSGradient object, with the smallest ratio value displayed first.
-&lt;/p&gt;
+	/**
+	 * Gets the array of up to eight FSMorphGradient objects defining the
+	 * control points for the gradient.
+	 * 
+	 * @return the array of control points.
+	 */
+	public ArrayList getGradients()
+	{
+		return gradients;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Sets the coordinate transform mapping the gradient square onto physical
+	 * coordinates at the start of the morphing process.
+	 * 
+	 * @param aTransform
+	 *            the starting coordinate transform.
+	 */
+	public void setStartTransform(FSCoordTransform aTransform)
+	{
+		startTransform = aTransform;
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Sets the coordinate transform mapping the gradient square onto physical
+	 * coordinates at the end of the morphing process.
+	 * 
+	 * @param aTransform
+	 *            the ending coordinate transform.
+	 */
+	public void setEndTransform(FSCoordTransform aTransform)
+	{
+		endTransform = aTransform;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradientFill_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The type of gradient fill, either FSFillStyle.Linear or FSFillStyle.Radial.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the array of control points that define the gradient.
+	 * 
+	 * @param anArray
+	 *            an array of up to eight FSMorphGradient objects.
+	 */
+	public void setGradients(ArrayList anArray)
+	{
+		gradients = anArray;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradientFill_1&quot;&gt;startTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The coordinate transform used to map the logical coordinates of the gradient square on to a set of physical coordinates at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	public Object clone()
+	{
+		FSMorphGradientFill anObject = (FSMorphGradientFill) super.clone();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradientFill_1&quot;&gt;endTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The coordinate transform used to map the logical coordinates of the gradient square on to a set of physical coordinates at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+		anObject.startTransform = (startTransform != null) ? (FSCoordTransform) startTransform
+						.clone()
+						: null;
+		anObject.endTransform = (endTransform != null) ? (FSCoordTransform) endTransform
+						.clone()
+						: null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphGradientFill_2&quot;&gt;gradients&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of up to eight FSGradient objects that define the control points across the gradient square that control the colour transitions. The Flash Player performs the interpolation of the colour values between the control points. Alpha channel (defining transparency) must be defined for the colour in each control point.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		anObject.gradients = new ArrayList();
 
-&lt;p&gt;In addition to specifying the type of gradient fill that will be displayed the type attribute may be used when iterating through an array of fill style objects to identify the type of fill style without using run-time type checking.&lt;/p&gt;
+		for (Iterator i = gradients.iterator(); i.hasNext();)
+			anObject.gradients.add(((FSMorphGradient) i.next()).clone());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+		return anObject;
+	}
 
-&lt;p&gt;For the coordinate transformation, the scaling factor is calculated by diving the width of the gradient square by the width of the shape:&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-float gradientSquareWidth = 32768.0f;
-float scale = gradientSquareWidth / shapeWidth; 
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSMorphGradientFill typedObject = (FSMorphGradientFill) anObject;
 
-&lt;p&gt;The translation is defined by calculating the difference between the minimum coordinates of the &lt;em&gt;scaled&lt;/em&gt; gradient square and the minimum coordinates of the shape:
+			if (startTransform != null)
+				result = startTransform.equals(typedObject.startTransform);
+			else
+				result = startTransform == typedObject.startTransform;
 
-&lt;pre&gt;
-int gradientX = -16384; // minimum x coordinate of the gradient square.
-int gradientY = -16384; // minimum y coordinate of the gradient square.
+			if (endTransform != null)
+				result = result
+								&amp;&amp; endTransform
+												.equals(typedObject.endTransform);
+			else
+				result = result &amp;&amp; endTransform == typedObject.endTransform;
 
-// Get the minimum coordinates of the shape being filled;
-int shapeX = shape.getBounds().getMinX();
-int shapeY = shape.getBounds().getMinY();
+			if (gradients != null)
+				result = result &amp;&amp; gradients.equals(typedObject.gradients);
+			else
+				result = result &amp;&amp; gradients == typedObject.gradients;
+		}
 
-// Now calculate the translation
-int translateX = shapeX - (gradientX / scale);
-int translateY = shapeY - (gradientY / scale);
-&lt;/pre&gt;
+		return result;
+	}
 
-&lt;p&gt;The FSCoordTransform has a convenient constructor to create the two-step transformation:&lt;/p&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;pre&gt;
-FSCoordTransform composite = new FSCoordTransform(translateX, translateY, scale, scale);
-&lt;/pre&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;startTransform&quot;, startTransform, depth);
+			Transform.append(buffer, &quot;endTransform&quot;, endTransform, depth);
+			Transform.append(buffer, &quot;gradients&quot;, gradients, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The transform is independent of any transformation defined for the parent shape in which the gradient is displayed. The gradient will be displayed correctly if the shape is scaled, rotated, etc. when it is added to the display list.&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		int length = super.length(coder);
 
-&lt;p&gt;The above process is repeated to calculate the transform for the gradient fill at the end of the morphing process. The transforms are independent of any transformation defined for the parent morphing shape in which the gradients are displayed.
+		length += startTransform.length(coder);
+		length += endTransform.length(coder);
+		length += 1;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		for (Iterator gradientIterator = gradients.iterator(); gradientIterator
+						.hasNext();)
+			length += ((FSTransformObject) gradientIterator.next())
+							.length(coder);
 
-&lt;p&gt;The FSMorphGradientFill class represents the MorphFillStyle structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSMorphGradientFill extends FSFillStyle
-{
-    private FSCoordTransform startTransform = null;
-    private FSCoordTransform endTransform = null;
-    private ArrayList gradients = null;
-    
-    /**
-     * Construct an FSMorphGradientFill object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSMorphGradientFill(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSMorphGradientFill object specifying the type of fill, starting and ending coordinate transforms and the array of gradient records.
+		return length;
+	}
 
-        @param aType the type of gradient fill, either FSFillStyle.Linear or FSFillStyle.Radial.
-        @param aStartTransform the coordinate transform mapping the gradient square onto physical coordinates at the start of the morphing process.
-        @param anEndTransform the coordinate transform mapping the gradient square onto physical coordinates at the end of the morphing process.
-        @param anArray an array of up to eight FSMorphGradient objects defining the control points for the gradient.
-        */
-    public FSMorphGradientFill(int aType, FSCoordTransform aStartTransform, FSCoordTransform anEndTransform, ArrayList anArray)
-    {
-        super(aType);
-        setStartTransform(aStartTransform);
-        setEndTransform(anEndTransform);
-        setGradients(anArray);
-    }
-    /**
-     * Constructs an FSMorphGradientFill object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSMorphGradientFill object.
-     */
-    public FSMorphGradientFill(FSMorphGradientFill obj)
-    {
-        super(obj);
-        startTransform = new FSCoordTransform(obj.startTransform);
-        endTransform = new FSCoordTransform(obj.endTransform);
-        
-        gradients = new ArrayList(obj.gradients.size());
-        
-        for (Iterator i = obj.gradients.iterator(); i.hasNext();)
-            gradients.add(((FSGradient)i.next()).clone());
-    }    
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		startTransform.encode(coder);
+		endTransform.encode(coder);
+		coder.writeWord(gradients.size(), 1);
 
-    /** Add a FSMorphGradient object to the array of gradient objects.
+		for (Iterator gradientIterator = gradients.iterator(); gradientIterator
+						.hasNext();)
+			((FSTransformObject) gradientIterator.next()).encode(coder);
+	}
 
-        @param aGradient an FSMorphGradient object.
-        */
-    public void add(FSMorphGradient aGradient) { gradients.add(aGradient); }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-    /** Gets the coordinate transform mapping the gradient square onto physical coordinates at the start of the morphing process.
+		startTransform = new FSCoordTransform(coder);
+		endTransform = new FSCoordTransform(coder);
 
-        @return the starting coordinate transform.
-        */
-    public FSCoordTransform getStartTransform() { return startTransform; }
+		int count = coder.readWord(1, false);
 
-    /** Gets the coordinate transform mapping the gradient square onto physical coordinates at the end of the morphing process.
+		gradients = new ArrayList(count);
 
-        @return the ending coordinate transform.
-        */
-    public FSCoordTransform getEndTransform() { return endTransform; }
-
-    /** Gets the array of up to eight FSMorphGradient objects defining the control points for the gradient.
-
-        @return the array of control points.
-        */
-    public ArrayList getGradients() 
-    { 
-        return gradients;
-    }
-    
-    /** Sets the coordinate transform mapping the gradient square onto physical coordinates at the start of the morphing process.
-
-        @param aTransform the starting coordinate transform.
-        */
-    public void setStartTransform(FSCoordTransform aTransform)
-    {
-        startTransform = aTransform;
-    }
-
-    /** Sets the coordinate transform mapping the gradient square onto physical coordinates at the end of the morphing process.
-
-        @param aTransform the ending coordinate transform.
-        */
-    public void setEndTransform(FSCoordTransform aTransform)
-    {
-        endTransform = aTransform;
-    }
-
-    /** Sets the array of control points that define the gradient.
-
-        @param anArray an array of up to eight FSMorphGradient objects.
-        */
-    public void setGradients(ArrayList anArray)
-    {
-        gradients = anArray;
-    }
-
-    public Object clone()
-    {
-        FSMorphGradientFill anObject = (FSMorphGradientFill)super.clone();
-        
-        anObject.startTransform = (startTransform != null) ? (FSCoordTransform)startTransform.clone() : null;
-        anObject.endTransform = (endTransform != null) ? (FSCoordTransform)endTransform.clone() : null;
-        
-        anObject.gradients = new ArrayList();
-            
-        for (Iterator i = gradients.iterator(); i.hasNext();)
-            anObject.gradients.add(((FSMorphGradient)i.next()).clone());
-
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSMorphGradientFill typedObject = (FSMorphGradientFill)anObject;
-            
-            if (startTransform != null)
-                result = startTransform.equals(typedObject.startTransform);
-            else
-                result = startTransform == typedObject.startTransform;
-
-            if (endTransform != null)
-                result = result &amp;&amp; endTransform.equals(typedObject.endTransform);
-            else
-                result = result &amp;&amp; endTransform == typedObject.endTransform;
-
-            if (gradients != null)
-                result = result &amp;&amp; gradients.equals(typedObject.gradients);
-            else
-                result = result &amp;&amp; gradients == typedObject.gradients;
-        }
-        
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startTransform&quot;, startTransform, depth);
-            Transform.append(buffer, &quot;endTransform&quot;, endTransform, depth);
-            Transform.append(buffer, &quot;gradients&quot;, gradients, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = super.length(coder);
-    
-        length += startTransform.length(coder);
-        length += endTransform.length(coder);
-        length += 1;
-    
-        for (Iterator gradientIterator = gradients.iterator(); gradientIterator.hasNext();) 
-            length += ((FSTransformObject)gradientIterator.next()).length(coder);
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        startTransform.encode(coder);
-        endTransform.encode(coder);
-        coder.writeWord(gradients.size(), 1);
-    
-        for (Iterator gradientIterator = gradients.iterator(); gradientIterator.hasNext();) 
-            ((FSTransformObject)gradientIterator.next()).encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        startTransform = new FSCoordTransform(coder);
-        endTransform = new FSCoordTransform(coder);
-        
-        int count = coder.readWord(1, false);
-                            
-        gradients = new ArrayList(count);
-
-        for (int i=0; i&lt;count; i++)
-        {
-            FSMorphGradient aGradient = new FSMorphGradient(coder);
-            gradients.add(aGradient);
-        }
-    }
+		for (int i = 0; i &lt; count; i++)
+		{
+			FSMorphGradient aGradient = new FSMorphGradient(coder);
+			gradients.add(aGradient);
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSMorphSolidFill.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMorphSolidFill.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMorphSolidFill.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,178 +31,215 @@
 package com.flagstone.transform;
 
 /**
-FSMorphSolidFill defines the solid colours that are used to fill a morphing shape at 
-the start and end of the morphing process.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSMorphSolidFill defines the solid colours that are used to fill a morphing
+ * shape at the start and end of the morphing process.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;start&lt;/td&gt;
+ * &lt;td&gt;The colour applied to the shape at the start of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;end&lt;/td&gt;
+ * &lt;td&gt;The colour applied to the shape at the end of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The parent class, FSFillStyle allows the type to be set. This should only be
+ * used for manipulating bitmap and gradient fill styles.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSMorphSolidFill object is added to a FSDefineMorphShape so both the
+ * start colour and end colour should have a value specified for the alpha
+ * channel that defines how transparent the colour is.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSColor red = new FSColor(255, 0, 0, 128);
+ * 
+ * FSColor green = new FSColor(0, 255, 0, 128);
+ * 
+ * FSMorphSolidFill fill = new FSMorphSolidFill(red, green);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSMorphSolidFill class represents the MorphFillStyle structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSMorphSolidFill extends FSFillStyle
+{
+	private FSColor startColor = null;
+	private FSColor endColor = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSMorphSolidFill object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSMorphSolidFill(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidFill_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphSolidFill object specifying the starting and ending
+	 * colours.
+	 * 
+	 * @param aStartColor
+	 *            the colour at the start of the morphing process.
+	 * @param anEndColor
+	 *            the colour at the end of the morphing process.
+	 */
+	public FSMorphSolidFill(FSColor aStartColor, FSColor anEndColor)
+	{
+		super(Solid);
+		setStartColor(aStartColor);
+		setEndColor(anEndColor);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidFill_1&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour applied to the shape at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphSolidFill object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSMorphSolidFill object.
+	 */
+	public FSMorphSolidFill(FSMorphSolidFill obj)
+	{
+		super(obj);
+		startColor = new FSColor(obj.startColor);
+		endColor = new FSColor(obj.endColor);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidFill_2&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour applied to the shape at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the colour at the start of the morphing process.
+	 * 
+	 * @return the starting colour.
+	 */
+	public FSColor getStartColor()
+	{
+		return startColor;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the colour at the end of the morphing process.
+	 * 
+	 * @return the end colour.
+	 */
+	public FSColor getEndColor()
+	{
+		return endColor;
+	}
 
-&lt;p&gt;The parent class, FSFillStyle allows the type to be set. This should only be used for manipulating bitmap and gradient fill styles.&lt;/p&gt; 
+	/**
+	 * Sets the colour at the start of the morphing process.
+	 * 
+	 * @param aColor
+	 *            the start colour.
+	 */
+	public void setStartColor(FSColor aColor)
+	{
+		startColor = aColor;
+	}
 
-&lt;p&gt;The FSMorphSolidFill object is added to a FSDefineMorphShape so both the start colour and end colour should have a value specified for the alpha channel that defines how transparent the colour is.&lt;/p&gt;
+	/**
+	 * Sets the colour at the end of the morphing process.
+	 * 
+	 * @param aColor
+	 *            the end colour.
+	 */
+	public void setEndColor(FSColor aColor)
+	{
+		endColor = aColor;
+	}
 
-&lt;pre&gt;
-FSColor red = new FSColor(255, 0, 0, 128);
-FSColor green = new FSColor(0, 255, 0, 128);
-FSMorphSolidFill fill = new FSMorphSolidFill(red, green);
-&lt;/pre&gt;
+	public Object clone()
+	{
+		FSMorphSolidFill anObject = (FSMorphSolidFill) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.startColor = (startColor != null) ? (FSColor) startColor
+						.clone() : null;
+		anObject.endColor = (endColor != null) ? (FSColor) endColor.clone()
+						: null;
 
-&lt;p&gt;The FSMorphSolidFill class represents the MorphFillStyle structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSMorphSolidFill extends FSFillStyle
-{
-    private FSColor startColor = null;
-    private FSColor endColor = null;
-    
-    /**
-     * Construct an FSMorphSolidFill object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSMorphSolidFill(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSMorphSolidFill object specifying the starting and ending colours.
+		return anObject;
+	}
 
-        @param aStartColor the colour at the start of the morphing process.
-        @param anEndColor the colour at the end of the morphing process.
-        */
-    public FSMorphSolidFill(FSColor aStartColor, FSColor anEndColor)
-    {
-        super(Solid);
-        setStartColor(aStartColor);
-        setEndColor(anEndColor);
-    }
-    /**
-     * Constructs an FSMorphSolidFill object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSMorphSolidFill object.
-     */
-    public FSMorphSolidFill(FSMorphSolidFill obj)
-    {
-        super(obj);
-        startColor = new FSColor(obj.startColor);
-        endColor = new FSColor(obj.endColor);
-    }    
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the colour at the start of the morphing process.
+		if (super.equals(anObject))
+		{
+			FSMorphSolidFill typedObject = (FSMorphSolidFill) anObject;
 
-        @return the starting colour.
-        */
-    public FSColor getStartColor() { return startColor; }
+			if (startColor != null)
+				result = startColor.equals(typedObject.startColor);
+			else
+				result = startColor == typedObject.startColor;
 
-    /** Gets the colour at the end of the morphing process.
+			if (endColor != null)
+				result = result &amp;&amp; endColor.equals(typedObject.endColor);
+			else
+				result = result &amp;&amp; endColor == typedObject.endColor;
+		}
+		return result;
+	}
 
-        @return the end colour.
-        */
-    public FSColor getEndColor() { return endColor; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the colour at the start of the morphing process.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
+			Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aColor the start colour.
-        */
-    public void setStartColor(FSColor aColor)
-    {
-        startColor = aColor;
-    }
+	public int length(FSCoder coder)
+	{
+		int length = super.length(coder);
 
-    /** Sets the colour at the end of the morphing process.
+		length += startColor.length(coder);
+		length += endColor.length(coder);
 
-        @param aColor the end colour.
-        */
-    public void setEndColor(FSColor aColor)
-    {
-        endColor = aColor;
-    }
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSMorphSolidFill anObject = (FSMorphSolidFill)super.clone();
-        
-        anObject.startColor = (startColor != null) ? (FSColor)startColor.clone() : null;
-        anObject.endColor = (endColor != null) ? (FSColor)endColor.clone() : null;
-        
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		startColor.encode(coder);
+		endColor.encode(coder);
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSMorphSolidFill typedObject = (FSMorphSolidFill)anObject;
-            
-            if (startColor != null)
-                result = startColor.equals(typedObject.startColor);
-            else
-                result = startColor == typedObject.startColor;
-
-            if (endColor != null)
-                result = result &amp;&amp; endColor.equals(typedObject.endColor);
-            else
-                result = result &amp;&amp; endColor == typedObject.endColor;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
-            Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = super.length(coder);
-    
-        length += startColor.length(coder);
-        length += endColor.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        startColor.encode(coder);
-        endColor.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        startColor = new FSColor(coder);
-        endColor = new FSColor(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		startColor = new FSColor(coder);
+		endColor = new FSColor(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSMorphSolidLine.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMorphSolidLine.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMorphSolidLine.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,231 +31,281 @@
 package com.flagstone.transform;
 
 /**
-FSMorphSolidLine defines the width and colour of a line drawn for a morphing shape. 
- 
-&lt;p&gt;It specifies the width and colour of the line at the start and end of the morphing process. The transparency value for the colour should also be specified. As with the FSSolidLine class all lines are drawn with rounded corners and end caps. Different join and line end styles can be created by drawing very narrow shapes.&lt;/p&gt;
+ * FSMorphSolidLine defines the width and colour of a line drawn for a morphing
+ * shape.
+ * 
+ * &lt;p&gt;
+ * It specifies the width and colour of the line at the start and end of the
+ * morphing process. The transparency value for the colour should also be
+ * specified. As with the FSSolidLine class all lines are drawn with rounded
+ * corners and end caps. Different join and line end styles can be created by
+ * drawing very narrow shapes.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_0&quot;&gt;startWidth&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The width of the line at the start of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_1&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The colour applied to the line at the start of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_2&quot;&gt;endWidth&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The width of the line at the end of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_3&quot;&gt;endColor&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The colour applied to the line at the end of the morphing process.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSDefineMorphShape object support transparent colours so alpha channel
+ * information must be specified in the colour objects.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSMorphSolidLine class represents the MorphLineStyle structure from the
+ * Macromedia Flash (SWF) File Format Specification. Shape morphing was
+ * introduced in Flash 3.
+ * &lt;/P&gt;
+ */
+public class FSMorphSolidLine extends FSLineStyle
+{
+	private int startWidth = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int endWidth = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private FSColor startColor = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_0&quot;&gt;startWidth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The width of the line at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	private FSColor endColor = null;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_1&quot;&gt;startColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour applied to the line at the start of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSMorphSolidLine object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSMorphSolidLine(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_2&quot;&gt;endWidth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The width of the line at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSMorphLineStyle object specifying the starting and ending
+	 * widths and colours.
+	 * 
+	 * @param aStartWidth
+	 *            the width of the line at the start of the morphing process.
+	 * @param anEndWidth
+	 *            the width of the line at the end of the morphing process.
+	 * @param aStartColor
+	 *            the colour of the line at the start of the morphing process.
+	 * @param anEndColor
+	 *            the colour of the line at the end of the morphing process.
+	 */
+	public FSMorphSolidLine(int aStartWidth, int anEndWidth,
+							FSColor aStartColor, FSColor anEndColor)
+	{
+		setStartWidth(aStartWidth);
+		setEndWidth(anEndWidth);
+		setStartColor(aStartColor);
+		setEndColor(anEndColor);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSMorphSolidLine_3&quot;&gt;endColor&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour applied to the line at the end of the morphing process.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSMorphSolidLine object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSMorphSolidLine object.
+	 */
+	public FSMorphSolidLine(FSMorphSolidLine obj)
+	{
+		startWidth = obj.startWidth;
+		endWidth = obj.endWidth;
+		startColor = new FSColor(obj.startColor);
+		endColor = new FSColor(obj.endColor);
+	}
 
-&lt;p&gt;The FSDefineMorphShape object support transparent colours so alpha channel information must be specified in the colour objects.&lt;/p&gt;
+	/**
+	 * Gets the width of the line at the start of the morphing process.
+	 * 
+	 * @return the starting width of the line.
+	 */
+	public int getStartWidth()
+	{
+		return startWidth;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Gets the width of the line at the end of the morphing process.
+	 * 
+	 * @return the ending width of the line.
+	 */
+	public int getEndWidth()
+	{
+		return endWidth;
+	}
 
-&lt;p&gt;The FSMorphSolidLine class represents the MorphLineStyle structure from the Macromedia Flash (SWF) File Format Specification. Shape morphing was introduced in Flash 3.&lt;/P&gt;
- */  
-public class FSMorphSolidLine extends FSLineStyle
-{
-    private int startWidth = 0;
-    private int endWidth = 0;
-    private FSColor startColor = null;
-    private FSColor endColor = null;
-    
-    /**
-     * Construct an FSMorphSolidLine object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSMorphSolidLine(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSMorphLineStyle object specifying the starting and ending widths and colours.
+	/**
+	 * Gets the colour of the line at the start of the morphing process.
+	 * 
+	 * @return the starting colour of the line.
+	 */
+	public FSColor getStartColor()
+	{
+		return startColor;
+	}
 
-        @param aStartWidth the width of the line at the start of the morphing process.
-        @param anEndWidth the width of the line at the end of the morphing process.
-        @param aStartColor the colour of the line at the start of the morphing process.
-        @param anEndColor the colour of the line at the end of the morphing process.
-        */
-    public FSMorphSolidLine(int aStartWidth, int anEndWidth, FSColor aStartColor, FSColor anEndColor)
-    {
-        setStartWidth(aStartWidth);
-        setEndWidth(anEndWidth);
-        setStartColor(aStartColor);
-        setEndColor(anEndColor);
-    }
-    /**
-     * Constructs an FSMorphSolidLine object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSMorphSolidLine object.
-     */
-    public FSMorphSolidLine(FSMorphSolidLine obj)
-    {
-        startWidth = obj.startWidth;
-        endWidth = obj.endWidth;
-        startColor = new FSColor(obj.startColor);
-        endColor = new FSColor(obj.endColor);
-    }    
+	/**
+	 * Gets the colour of the line at the end of the morphing process.
+	 * 
+	 * @return the ending colour of the line.
+	 */
+	public FSColor getEndColor()
+	{
+		return endColor;
+	}
 
-    /** Gets the width of the line at the start of the morphing process.
+	/**
+	 * Sets the width of the line at the start of the morphing process.
+	 * 
+	 * @param aNumber
+	 *            the starting width of the line.
+	 */
+	public void setStartWidth(int aNumber)
+	{
+		startWidth = aNumber;
+	}
 
-        @return the starting width of the line.
-        */
-    public int getStartWidth() 
-    { 
-        return startWidth; 
-    }
+	/**
+	 * Sets the width of the line at the end of the morphing process.
+	 * 
+	 * @param aNumber
+	 *            the ending width of the line.
+	 */
+	public void setEndWidth(int aNumber)
+	{
+		endWidth = aNumber;
+	}
 
-    /** Gets the width of the line at the end of the morphing process.
+	/**
+	 * Gets the colour of the line at the start of the morphing process.
+	 * 
+	 * @param aColor
+	 *            the starting colour of the line.
+	 */
+	public void setStartColor(FSColor aColor)
+	{
+		startColor = aColor;
+	}
 
-        @return the ending width of the line.
-        */
-    public int getEndWidth() 
-    { 
-        return endWidth; 
-    }
+	/**
+	 * Sets the colour of the line at the end of the morphing process.
+	 * 
+	 * @param aColor
+	 *            the ending colour of the line.
+	 */
+	public void setEndColor(FSColor aColor)
+	{
+		endColor = aColor;
+	}
 
-    /** Gets the colour of the line at the start of the morphing process.
+	public Object clone()
+	{
+		FSMorphSolidLine anObject = (FSMorphSolidLine) super.clone();
 
-        @return the starting colour of the line.
-        */
-    public FSColor getStartColor() { return startColor; }
+		anObject.startColor = (startColor != null) ? (FSColor) startColor
+						.clone() : null;
+		anObject.endColor = (endColor != null) ? (FSColor) endColor.clone()
+						: null;
 
-    /** Gets the colour of the line at the end of the morphing process.
+		return anObject;
+	}
 
-        @return the ending colour of the line.
-        */
-    public FSColor getEndColor() { return endColor; }
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the width of the line at the start of the morphing process.
+		if (super.equals(anObject))
+		{
+			FSMorphSolidLine typedObject = (FSMorphSolidLine) anObject;
 
-        @param aNumber the starting width of the line.
-        */
-    public void setStartWidth(int aNumber)
-    {
-        startWidth = aNumber;
-    }
+			result = startWidth == typedObject.startWidth;
+			result = result &amp;&amp; endWidth == typedObject.endWidth;
 
-    /** Sets the width of the line at the end of the morphing process.
+			if (startColor != null)
+				result = result &amp;&amp; startColor.equals(typedObject.startColor);
+			else
+				result = result &amp;&amp; startColor == typedObject.startColor;
 
-        @param aNumber the ending width of the line.
-        */
-    public void setEndWidth(int aNumber)
-    {
-        endWidth = aNumber;
-    }
+			if (endColor != null)
+				result = result &amp;&amp; endColor.equals(typedObject.endColor);
+			else
+				result = result &amp;&amp; endColor == typedObject.endColor;
+		}
+		return result;
+	}
 
-    /** Gets the colour of the line at the start of the morphing process.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param aColor the starting colour of the line.
-        */
-    public void setStartColor(FSColor aColor)
-    {
-        startColor = aColor;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;startWidth&quot;, startWidth);
+			Transform.append(buffer, &quot;endWidth&quot;, endWidth);
+			Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
+			Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the colour of the line at the end of the morphing process.
+	public int length(FSCoder coder)
+	{
+		int length = 4;
 
-        @param aColor the ending colour of the line.
-        */
-    public void setEndColor(FSColor aColor)
-    {
-        endColor = aColor;
-    }
+		length += startColor.length(coder);
+		length += endColor.length(coder);
 
-    public Object clone()
-    {
-        FSMorphSolidLine anObject = (FSMorphSolidLine)super.clone();
-        
-        anObject.startColor = (startColor != null) ? (FSColor)startColor.clone() : null;
-        anObject.endColor = (endColor != null) ? (FSColor)endColor.clone() : null;
-        
-        return anObject;
-    }
+		return length;
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSMorphSolidLine typedObject = (FSMorphSolidLine)anObject;
-            
-            result = startWidth == typedObject.startWidth;
-            result = result &amp;&amp; endWidth == typedObject.endWidth;
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(startWidth, 2);
+		coder.writeWord(endWidth, 2);
+		startColor.encode(coder);
+		endColor.encode(coder);
+	}
 
-            if (startColor != null)
-                result = result &amp;&amp; startColor.equals(typedObject.startColor);
-            else
-                result = result &amp;&amp; startColor == typedObject.startColor;
-
-            if (endColor != null)
-                result = result &amp;&amp; endColor.equals(typedObject.endColor);
-            else
-                result = result &amp;&amp; endColor == typedObject.endColor;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;startWidth&quot;, startWidth);
-            Transform.append(buffer, &quot;endWidth&quot;, endWidth);
-            Transform.append(buffer, &quot;startColor&quot;, startColor, depth);
-            Transform.append(buffer, &quot;endColor&quot;, endColor, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 4;
-    
-        length += startColor.length(coder);
-        length += endColor.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(startWidth, 2);
-        coder.writeWord(endWidth, 2);
-        startColor.encode(coder);
-        endColor.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        startWidth = coder.readWord(2, false);
-        endWidth = coder.readWord(2, false);
-        startColor = new FSColor(coder);
-        endColor = new FSColor(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		startWidth = coder.readWord(2, false);
+		endWidth = coder.readWord(2, false);
+		startColor = new FSColor(coder);
+		endColor = new FSColor(coder);
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSMovie.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovie.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMovie.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -35,1570 +35,1752 @@
 import java.io.*;
 
 /**
-FSMovie is a container class for the objects that represents the data structures in a Flash file.
-
-&lt;p&gt;FSMovie is the core class of the Transform package. It is used to parse and generate Flash files, translating the binary format of the Flash file into an array objects that can be inspected and updated.&lt;/p&gt;
-
-&lt;p&gt;An FSMovie object also contains the attributes that make up the header information of the Flash file, identifying the version support, size of the Flash Player screen, etc.:&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSMovie_0&quot;&gt;signature&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The signature is a three character code that identifies that the file contains Flash encoded data. For Flash versions 1 to 5 this was 'F', 'W', 'S' (&quot;SWF&quot; reversed). In Flash 6, zlib compressed files were introduced to reduce file sizes. Compressed files are identified by the signature,  'C', 'W', 'S'.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSMovie_1&quot;&gt;version&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The version of Flash that is contained in the file.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSMovie_2&quot;&gt;frameSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSBounds object that define the size of the Flash Player's screen when playing the movie.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSMovie_3&quot;&gt;frameRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of frames per second that the movie will be played at.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSMovie_4&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSMovieObjects that define the shapes, buttons, images etc to be displayed along with the commands that control how the movie is animated.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;The header information defined in the Macromedia Flash (SWF) File Format Specification also identifies the length of the (uncompressed) movie and the number of frames. These attributes are derived when the FSMovie object is encoded to a file.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;Generating a Flash File&lt;/h1&gt;
-
-&lt;p&gt;Flash files can be built from scratch by simply constructing instances of objects that represent
-the respective Flash data structure and adding them to an FSMovie object in the order they will
-be executed by the Flash player.&lt;/p&gt;
-
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
-
-// Define a shape to be displayed
-
-FSDefineShape rectangle = new FSDefineShape(movie.newIdentifier(), ....);
-
-// Set the size of the Flash Player screen 400x400 and the number of
-// frames displayed per second.
-
-movie.setFrameSize(new FSBounds(0, 0, 400, 400));
-movie.setFrameRate(1.0);
-
-// Set the background colour for the movie
-
-movie.add(new FSSetBackgroundColor(FSColor.lightblue()));
-
-// Add the shape to the movie. All objects must be defined before
-// they can be used.
-
-movie.add(rectangle);
-
-// Place the shape in the centre of the screen (200,200) on the first layer
-// in the Flash Player's display list.
-
-movie.add(new FSPlaceObject2(FSPlaceObject2.New, rectangle.getIdentifier(), 1, 200, 200));
-
-// Display the frame
-
-movie.add(new FSShowFrame());
-
-&lt;/pre&gt;
-
-&lt;p&gt;Note that when the shape was defined a call was made to the newIdentifier() method on the movie. Each object that defines either a shape, button, sound etc., is assigned a unique identifier to allow the object to be referenced in objects such as FSPlaceObject which places the shape on the Flash Player's display list. The identifier is unique only within a movie so the FSMovie class maintains a counter that is used to generate values for the identifiers that are assigned to objects derived from the FSDefineObject class.&lt;/p&gt;
-
-&lt;p&gt;To generate a Flash file use the &lt;code&gt;encodeToFile(String fileName)&lt;/code&gt; method:&lt;/p&gt;
-
-&lt;pre&gt;
-try {
-    aMovie.encodeToFile(filename);
-}
-catch (Exception e) {
-    ... Process Exception ...
-}
-&lt;/pre&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;Parsing a Flash File&lt;/h1&gt;
-
-&lt;p&gt;To parse a Flash file simply create an instance using the &lt;code&gt;FSMovie(String fileName)&lt;/code&gt;
-constructor:&lt;/p&gt;
-
-&lt;pre&gt;
-FSMovie aMovie = null;
-String fileName = &quot;aFlashFile.swf&quot;;
-
-try {
-    aMovie = new FSMovie(filename);
-}
-catch (Exception e) {
-    ... Process Exception ...
-}
-&lt;/pre&gt;
-
-&lt;p&gt;The objects array of the movie will contain an instance of the respective package class for
-each data structure  decoded from the file. The objects may be inspected and their attributes
-changed accordingly.&lt;/p&gt;
-
-&lt;p&gt;The FSMovie object keeps track of the identifiers assigned to objects that define the shapes,
-buttons, sounds etc. that make up a Flash file. If a new object is added to the movie then
-the call to newIdentifier() is guaranteed to return a value that is unique within the movie.&lt;/p&gt;
-
-&lt;p&gt;&lt;b&gt;Multiple Language Support&lt;/b&gt;&lt;br&gt;Formal support for Unicode strings was added in
-Flash 6, providing a unified mechanism for supporting different languages. Previously
-Macromedia released different versions of the Flash authoring tool that supported a
-character set unique to a given language, for example SJIS for the Japanese language
-edition. The FSMovie class includes the &lt;em&gt;encoding&lt;/em&gt; attribute that identifies
-the character set used to encode the strings found in objects such as FSFrameLabel
-and FSDefineTextField. Note this does not include the characters in font definitions.
-The default value of UTF8 is the same encoding scheme used by Macromedia so files
-containing Flash 6 or later may be decoded from any source. For earlier version of
-Flash the encoding attribute may be set to match the character set of the application
-used to encoded the Flash file.&lt;/p&gt;';
-*/
+ * FSMovie is a container class for the objects that represents the data
+ * structures in a Flash file.
+ * 
+ * FSMovie is the core class of the Transform package. It is used to parse and
+ * generate Flash files, translating the binary format of the Flash file into an
+ * array objects that can be inspected and updated.
+ * 
+ * An FSMovie object also contains the attributes that make up the header
+ * information of the Flash file, identifying the version support, size of the
+ * Flash Player screen, etc.:
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;signature&lt;/td&gt;
+ * &lt;td&gt;The signature is a three character code that identifies that the file
+ * contains Flash encoded data. For Flash versions 1 to 5 this was 'F', 'W', 'S'
+ * (&quot;SWF&quot; reversed). In Flash 6, zlib compressed files were introduced to reduce
+ * file sizes. Compressed files are identified by the signature, 'C', 'W', 'S'.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;version&lt;/td&gt;
+ * &lt;td&gt;The version of Flash that is contained in the file.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameSize&lt;/td&gt;
+ * &lt;td&gt;An FSBounds object that define the size of the Flash Player's screen
+ * when playing the movie.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameRate&lt;/td&gt;
+ * &lt;td&gt;The number of frames per second that the movie will be played at.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of FSMovieObjects that define the shapes, buttons, images etc
+ * to be displayed along with the commands that control how the movie is
+ * animated.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * The header information defined in the Macromedia Flash (SWF) File Format
+ * Specification also identifies the length of the (uncompressed) movie and the
+ * number of frames. These attributes are derived when the FSMovie object is
+ * encoded to a file.
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Generating a Flash File&lt;/h1&gt;
+ * 
+ * Flash files can be built from scratch by simply constructing instances of
+ * objects that represent the respective Flash data structure and adding them to
+ * an FSMovie object in the order they will be executed by the Flash player.
+ * 
+ * &lt;pre&gt;
+ *  FSMovie movie = new FSMovie();
+ * 
+ *  // Define a shape to be displayed
+ *  FSDefineShape rectangle = new FSDefineShape(movie.newIdentifier(), ....);
+ * 
+ *  // Set the size of the Flash Player screen 400x400 and the number of
+ *  // frames displayed per second.
+ *  movie.setFrameSize(new FSBounds(0, 0, 400, 400));
+ *  movie.setFrameRate(1.0);
+ * 
+ *  // Set the background colour for the movie
+ *  movie.add(new FSSetBackgroundColor(FSColor.lightblue()));
+ * 
+ *  // Add the shape to the movie. All objects must be defined before
+ *  // they can be used.
+ *  movie.add(rectangle);
+ * 
+ *  // Place the shape in the centre of the screen (200,200) on the first layer
+ *  // in the Flash Player's display list.
+ *  movie.add(new FSPlaceObject2(FSPlaceObject2.New, rectangle.getIdentifier(), 1, 200, 200));
+ * 
+ *  // Display the frame
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * Note that when the shape was defined a call was made to the newIdentifier()
+ * method on the movie. Each object that defines either a shape, button, sound
+ * etc., is assigned a unique identifier to allow the object to be referenced in
+ * objects such as FSPlaceObject which places the shape on the Flash Player's
+ * display list. The identifier is unique only within a movie so the FSMovie
+ * class maintains a counter that is used to generate values for the identifiers
+ * that are assigned to objects derived from the Definition class.
+ * 
+ * To generate a Flash file use the &lt;code&gt;encodeToFile(String fileName)&lt;/code&gt;
+ * method:
+ * 
+ * &lt;pre&gt;
+ *  try {
+ *  aMovie.encodeToFile(filename);
+ *  }
+ *  catch (Exception e) {
+ *  ... Process Exception ...
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Parsing a Flash File&lt;/h1&gt;
+ * 
+ * To parse a Flash file simply create an instance using the
+ * &lt;code&gt;FSMovie(String fileName)&lt;/code&gt; constructor:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSMovie aMovie = null;
+ *  String fileName = &quot;aFlashFile.swf&quot;;
+ * 
+ *  try {
+ *  aMovie = new FSMovie(filename);
+ *  }
+ *  catch (Exception e) {
+ *  ... Process Exception ...
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * The objects array of the movie will contain an instance of the respective
+ * package class for each data structure decoded from the file. The objects may
+ * be inspected and their attributes changed accordingly.
+ * 
+ * The FSMovie object keeps track of the identifiers assigned to objects that
+ * define the shapes, buttons, sounds etc. that make up a Flash file. If a new
+ * object is added to the movie then the call to newIdentifier() is guaranteed
+ * to return a value that is unique within the movie.
+ * 
+ * &lt;b&gt;Multiple Language Support&lt;/b&gt;&lt;br&gt;
+ * Formal support for Unicode strings was added in Flash 6, providing a unified
+ * mechanism for supporting different languages. Previously Macromedia released
+ * different versions of the Flash authoring tool that supported a character set
+ * unique to a given language, for example SJIS for the Japanese language
+ * edition. The FSMovie class includes the &lt;em&gt;encoding&lt;/em&gt; attribute that
+ * identifies the character set used to encode the strings found in objects such
+ * as FSFrameLabel and FSDefineTextField. Note this does not include the
+ * characters in font definitions. The default value of UTF8 is the same
+ * encoding scheme used by Macromedia so files containing Flash 6 or later may
+ * be decoded from any source. For earlier version of Flash the encoding
+ * attribute may be set to match the character set of the application used to
+ * encoded the Flash file.
+ * &lt;/p&gt;';
+ */
 public class FSMovie implements Cloneable
 {
-    static void encodeObjects(FSCoder coder, ArrayList array)
-    {
-        for (Iterator i = array.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
+	static void encodeObjects(FSCoder coder, ArrayList array)
+	{
+		for (Iterator i = array.iterator(); i.hasNext();)
+		{
+			FSMovieObject object = (FSMovieObject) i.next();
 
-            int objStart = coder.getPointer();
-            int objLength = object.getLength();
-            int start = coder.getPointer() + ((object.getExtendLength() || objLength &gt;= 63) ? 48 : 16);
-            int next = start + (objLength &lt;&lt; 3);
+			int objStart = coder.getPointer();
+			int objLength = object.getLength();
+			int start = coder.getPointer()
+							+ ((object.getExtendLength() || objLength &gt;= 63) ? 48
+											: 16);
+			int next = start + (objLength &lt;&lt; 3);
 
-            object.encode(coder);
-            coder.setPointer(next);
+			object.encode(coder);
+			coder.setPointer(next);
 
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = object.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
-    }
-    static FSMovieObject decodeObject(FSCoder coder)
-    {
-        FSMovieObject currentObject = null;
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = object.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
+	}
 
-        int objStart = coder.getPointer();
-        int type = coder.scanWord(2, false) &gt;&gt; 6;
-        int length = coder.scanWord(2, false) &amp; 0x3F;
-        int next = coder.getPointer() + 16 + (length &lt;&lt; 3);
-        int identifier = 0;
+	static FSMovieObject decodeObject(FSCoder coder)
+	{
+		FSMovieObject currentObject = null;
 
-        if (type == 0)
-        {
-            /*
-             * Skip over the End object so it does not generate an event.
-             */
-            coder.setPointer(next);
-            return currentObject;
-        }
+		int objStart = coder.getPointer();
+		int type = coder.scanWord(2, false) &gt;&gt; 6;
+		int length = coder.scanWord(2, false) &amp; 0x3F;
+		int next = coder.getPointer() + 16 + (length &lt;&lt; 3);
+		int identifier = 0;
 
-        if (length == 0x3F)
-        {
-            coder.adjustPointer(16);
-            length = coder.scanWord(4, false);
-            next = coder.getPointer() + 32 + (length &lt;&lt; 3);
-            coder.adjustPointer(-16);
-        }
+		if (type == 0)
+		{
+			/*
+			 * Skip over the End object so it does not generate an event.
+			 */
+			coder.setPointer(next);
+			return currentObject;
+		}
 
-        switch (type)
-        {
-            case FSMovieObject.ShowFrame:
-                currentObject = FSShowFrame.getInstance();
-                coder.setPointer(next);
-                break;
-            case FSMovieObject.DefineShape:
-                currentObject = new FSDefineShape(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.PlaceObject:
-                currentObject = new FSPlaceObject(coder);
-                break;
-            case FSMovieObject.RemoveObject:
-                currentObject = new FSRemoveObject(coder);
-                break;
-            case FSMovieObject.DefineJPEGImage:
-                currentObject = new FSDefineJPEGImage(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineButton:
-                currentObject = new FSDefineButton(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.JPEGTables:
-                currentObject = new FSJPEGEncodingTable(coder);
-                break;
-            case FSMovieObject.SetBackgroundColor:
-                currentObject = new FSSetBackgroundColor(coder);
-                break;
-            case FSMovieObject.DefineFont:
-                currentObject = new FSDefineFont(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineText:
-                currentObject = new FSDefineText(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DoAction:
-                currentObject = new FSDoAction(coder);
-                break;
-            case FSMovieObject.FontInfo:
-                currentObject = new FSFontInfo(coder);
-                break;
-            case FSMovieObject.DefineSound:
-                currentObject = new FSDefineSound(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.StartSound:
-                currentObject = new FSStartSound(coder);
-                break;
-            case FSMovieObject.SoundStreamHead:
-                currentObject = new FSSoundStreamHead(coder);
-                break;
-            case FSMovieObject.SoundStreamBlock:
-                currentObject = new FSSoundStreamBlock(coder);
-                break;
-// Flash 2
-            case FSMovieObject.ButtonSound:
-                currentObject = new FSButtonSound(coder);
-                break;
-            case FSMovieObject.DefineImage:
-                currentObject = new FSDefineImage(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineJPEGImage2:
-                currentObject = new FSDefineJPEGImage2(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineShape2:
-                currentObject = new FSDefineShape2(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.ButtonColorTransform:
-                currentObject = new FSButtonColorTransform(coder);
-                break;
-            case FSMovieObject.Protect:
-                currentObject = new FSProtect(coder);
-                break;
-// Flash 3
-            case FSMovieObject.Free:
-                currentObject = new FSFree(coder);
-                break;
-            case FSMovieObject.PlaceObject2:
-                currentObject = new FSPlaceObject2(coder);
-                break;
-            case FSMovieObject.RemoveObject2:
-                currentObject = new FSRemoveObject2(coder);
-                break;
-            case FSMovieObject.DefineShape3:
-                currentObject = new FSDefineShape3(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineText2:
-                currentObject = new FSDefineText2(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineButton2:
-                currentObject = new FSDefineButton2(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineJPEGImage3:
-                currentObject = new FSDefineJPEGImage3(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineImage2:
-                currentObject = new FSDefineImage2(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineMovieClip:
-                currentObject = new FSDefineMovieClip(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.FrameLabel:
-                currentObject = new FSFrameLabel(coder);
-                break;
-            case FSMovieObject.SoundStreamHead2:
-                currentObject = new FSSoundStreamHead2(coder);
-                break;
-            case FSMovieObject.DefineMorphShape:
-                currentObject = new FSDefineMorphShape(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.DefineFont2:
-                currentObject = new FSDefineFont2(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-// Flash 4
-            case FSMovieObject.PathsArePostscript:
-                currentObject = FSPathsArePostscript.getInstance();
-                coder.setPointer(next);
-                break;
-            case FSMovieObject.DefineTextField:
-                currentObject = new FSDefineTextField(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.QuicktimeMovie:
-                currentObject = new FSQuicktimeMovie(coder);
-                break;
-            case FSMovieObject.SerialNumber:
-                currentObject = new FSSerialNumber(coder);
-                break;
-            case FSMovieObject.DefineBitsPtr:
-                currentObject = new FSPointer(coder);
-                break;
-// Flash 5
-            case FSMovieObject.EnableDebugger:
-                currentObject = new FSEnableDebugger(coder);
-                break;
-            case FSMovieObject.Export:
-                currentObject = new FSExport(coder);
-                break;
-            case FSMovieObject.Import:
-                currentObject = new FSImport(coder);
-                break;
-// Flash 6
-            case FSMovieObject.Initialize:
-                currentObject = new FSInitialize(coder);
-                break;
-            case FSMovieObject.DefineVideo:
-                currentObject = new FSDefineVideo(coder);
-                identifier = ((FSDefineObject)currentObject).getIdentifier();
-                break;
-            case FSMovieObject.VideoFrame:
-                currentObject = new FSVideoFrame(coder);
-                break;
-            case FSMovieObject.FontInfo2:
-                currentObject = new FSFontInfo2(coder);
-                break;
-            case FSMovieObject.EnableDebugger2:
-                currentObject = new FSEnableDebugger2(coder);
-                break;
-// Flash 7
-            case FSMovieObject.LimitScript:
-                currentObject = new FSLimitScript(coder);
-                break;
-            case FSMovieObject.TabOrder:
-                currentObject = new FSTabOrder(coder);
-                break;
-            default:
-                currentObject = new FSUnknownObject(coder);
-                break;
-        }
+		if (length == 0x3F)
+		{
+			coder.adjustPointer(16);
+			length = coder.scanWord(4, false);
+			next = coder.getPointer() + 32 + (length &lt;&lt; 3);
+			coder.adjustPointer(-16);
+		}
 
-        int delta = (coder.getPointer() - next) &gt;&gt; 3;
+		switch (type)
+		{
+			case FSMovieObject.ShowFrame:
+				currentObject = FSShowFrame.getInstance();
+				coder.setPointer(next);
+				break;
+			case FSMovieObject.DefineShape:
+				currentObject = new FSDefineShape(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.PlaceObject:
+				currentObject = new FSPlaceObject(coder);
+				break;
+			case FSMovieObject.RemoveObject:
+				currentObject = new FSRemoveObject(coder);
+				break;
+			case FSMovieObject.DefineJPEGImage:
+				currentObject = new FSDefineJPEGImage(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineButton:
+				currentObject = new FSDefineButton(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.JPEGTables:
+				currentObject = new FSJPEGEncodingTable(coder);
+				break;
+			case FSMovieObject.SetBackgroundColor:
+				currentObject = new FSSetBackgroundColor(coder);
+				break;
+			case FSMovieObject.DefineFont:
+				currentObject = new FSDefineFont(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineText:
+				currentObject = new FSDefineText(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DoAction:
+				currentObject = new FSDoAction(coder);
+				break;
+			case FSMovieObject.FontInfo:
+				currentObject = new FSFontInfo(coder);
+				break;
+			case FSMovieObject.DefineSound:
+				currentObject = new FSDefineSound(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.StartSound:
+				currentObject = new FSStartSound(coder);
+				break;
+			case FSMovieObject.SoundStreamHead:
+				currentObject = new FSSoundStreamHead(coder);
+				break;
+			case FSMovieObject.SoundStreamBlock:
+				currentObject = new FSSoundStreamBlock(coder);
+				break;
+			// Flash 2
+			case FSMovieObject.ButtonSound:
+				currentObject = new FSButtonSound(coder);
+				break;
+			case FSMovieObject.DefineImage:
+				currentObject = new FSDefineImage(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineJPEGImage2:
+				currentObject = new FSDefineJPEGImage2(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineShape2:
+				currentObject = new FSDefineShape2(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.ButtonColorTransform:
+				currentObject = new FSButtonColorTransform(coder);
+				break;
+			case FSMovieObject.Protect:
+				currentObject = new FSProtect(coder);
+				break;
+			// Flash 3
+			case FSMovieObject.Free:
+				currentObject = new FSFree(coder);
+				break;
+			case FSMovieObject.PlaceObject2:
+				currentObject = new FSPlaceObject2(coder);
+				break;
+			case FSMovieObject.RemoveObject2:
+				currentObject = new FSRemoveObject2(coder);
+				break;
+			case FSMovieObject.DefineShape3:
+				currentObject = new FSDefineShape3(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineText2:
+				currentObject = new FSDefineText2(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineButton2:
+				currentObject = new FSDefineButton2(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineJPEGImage3:
+				currentObject = new FSDefineJPEGImage3(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineImage2:
+				currentObject = new FSDefineImage2(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineMovieClip:
+				currentObject = new FSDefineMovieClip(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.FrameLabel:
+				currentObject = new FSFrameLabel(coder);
+				break;
+			case FSMovieObject.SoundStreamHead2:
+				currentObject = new FSSoundStreamHead2(coder);
+				break;
+			case FSMovieObject.DefineMorphShape:
+				currentObject = new FSDefineMorphShape(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.DefineFont2:
+				currentObject = new FSDefineFont2(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			// Flash 4
+			case FSMovieObject.PathsArePostscript:
+				currentObject = FSPathsArePostscript.getInstance();
+				coder.setPointer(next);
+				break;
+			case FSMovieObject.DefineTextField:
+				currentObject = new FSDefineTextField(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.QuicktimeMovie:
+				currentObject = new FSQuicktimeMovie(coder);
+				break;
+			case FSMovieObject.SerialNumber:
+				currentObject = new FSSerialNumber(coder);
+				break;
+			case FSMovieObject.DefineBitsPtr:
+				currentObject = new FSPointer(coder);
+				break;
+			// Flash 5
+			case FSMovieObject.EnableDebugger:
+				currentObject = new FSEnableDebugger(coder);
+				break;
+			case FSMovieObject.Export:
+				currentObject = new FSExport(coder);
+				break;
+			case FSMovieObject.Import:
+				currentObject = new FSImport(coder);
+				break;
+			// Flash 6
+			case FSMovieObject.Initialize:
+				currentObject = new FSInitialize(coder);
+				break;
+			case FSMovieObject.DefineVideo:
+				currentObject = new FSDefineVideo(coder);
+				identifier = ((FSDefineObject) currentObject).getIdentifier();
+				break;
+			case FSMovieObject.VideoFrame:
+				currentObject = new FSVideoFrame(coder);
+				break;
+			case FSMovieObject.FontInfo2:
+				currentObject = new FSFontInfo2(coder);
+				break;
+			case FSMovieObject.EnableDebugger2:
+				currentObject = new FSEnableDebugger2(coder);
+				break;
+			// Flash 7
+			case FSMovieObject.LimitScript:
+				currentObject = new FSLimitScript(coder);
+				break;
+			case FSMovieObject.TabOrder:
+				currentObject = new FSTabOrder(coder);
+				break;
+			default:
+				currentObject = new FSUnknownObject(coder);
+				break;
+		}
 
-        if (delta != 0)
-        {
-            coder.context[FSCoder.CodingError] = 1;
-            coder.context[FSCoder.TypeInError] = currentObject.getType();
-            coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-            coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-            coder.context[FSCoder.Delta] = delta;
-        }
+		int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        coder.setPointer(next);
+		if (delta != 0)
+		{
+			coder.context[FSCoder.CodingError] = 1;
+			coder.context[FSCoder.TypeInError] = currentObject.getType();
+			coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+			coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+			coder.context[FSCoder.Delta] = delta;
+		}
 
-        if (identifier != 0)
-            coder.context[FSCoder.Identifier] = Math.max(coder.context[FSCoder.Identifier], identifier);
+		coder.setPointer(next);
 
-        return currentObject;
-    }
+		if (identifier != 0)
+			coder.context[FSCoder.Identifier] = Math.max(
+							coder.context[FSCoder.Identifier], identifier);
 
-    static FSActionObject decodeAction(FSCoder coder)
-    {
-        FSActionObject anAction = null;
+		return currentObject;
+	}
 
-        int objStart = coder.getPointer();
-        int type = coder.scanWord(1, false);
-        int length = 0;
-        int start = coder.getPointer() + 8;
-        int next = start;
+	static FSActionObject decodeAction(FSCoder coder)
+	{
+		FSActionObject anAction = null;
 
-        if (type &gt; 128)
-        {
-            coder.adjustPointer(8);
-            length = coder.scanWord(2, false);
-            start = coder.getPointer() + 16;
-            next = start + (length &lt;&lt; 3);
-            coder.adjustPointer(-8);
-        }
+		int objStart = coder.getPointer();
+		int type = coder.scanWord(1, false);
+		int length = 0;
+		int start = coder.getPointer() + 8;
+		int next = start;
 
-        switch (type)
-        {
-            case FSAction.End:
-            case FSAction.NextFrame:
-            case FSAction.PrevFrame:
-            case FSAction.Play:
-            case FSAction.Stop:
-            case FSAction.ToggleQuality:
-            case FSAction.StopSounds:
-                anAction = FSAction.getInstance(type);
-                coder.adjustPointer(8);
-                break;
-            case FSActionObject.GetUrl:
-                anAction = new FSGetUrl(coder);
-                break;
-// Flash 3
-            case FSActionObject.GotoFrame:
-                anAction = new FSGotoFrame(coder);
-                break;
-// Flash 4
-            case FSActionObject.GotoLabel:
-                anAction = new FSGotoLabel(coder);
-                break;
-            case FSActionObject.SetTarget:
-                anAction = new FSSetTarget(coder);
-                break;
-            case FSActionObject.WaitForFrame:
-                anAction = new FSWaitForFrame(coder);
-                break;
-            case FSAction.IntegerAdd:
-            case FSAction.Subtract:
-            case FSAction.IntegerEquals:
-            case FSAction.IntegerLess:
-            case FSAction.Multiply:
-            case FSAction.Divide:
-            case FSAction.And:
-            case FSAction.Or:
-            case FSAction.Not:
-            case FSAction.StringEquals:
-            case FSAction.StringLength:
-            case FSAction.StringExtract:
-            case FSAction.Pop:
-            case FSAction.ToInteger:
-            case FSAction.GetVariable:
-            case FSAction.SetVariable:
-            case FSAction.SetTarget2:
-            case FSAction.StringAdd:
-            case FSAction.GetProperty:
-            case FSAction.SetProperty:
-            case FSAction.CloneSprite:
-            case FSAction.RemoveSprite:
-            case FSAction.Trace:
-            case FSAction.StartDrag:
-            case FSAction.EndDrag:
-            case FSAction.StringLess:
-            case FSAction.RandomNumber:
-            case FSAction.MBStringLength:
-            case FSAction.CharToAscii:
-            case FSAction.AsciiToChar:
-            case FSAction.GetTime:
-            case FSAction.MBStringExtract:
-            case FSAction.MBCharToAscii:
-            case FSAction.MBAsciiToChar:
-                anAction = FSAction.getInstance(type);
-                coder.adjustPointer(8);
-                break;
-            case FSActionObject.Call:
-                anAction = FSCall.getInstance();
-                coder.setPointer(next);
-                break;
-            case FSActionObject.Push:
-                anAction = new FSPush(coder);
-                break;
-            case FSActionObject.WaitForFrame2:
-                anAction = new FSWaitForFrame2(coder);
-                break;
-            case FSActionObject.Jump:
-                anAction = new FSJump(coder);
-                break;
-            case FSActionObject.If:
-                anAction = new FSIf(coder);
-                break;
-            case FSActionObject.GetUrl2:
-                anAction = new FSGetUrl2(coder);
-                break;
-            case FSActionObject.GotoFrame2:
-                anAction = new FSGotoFrame2(coder);
-                break;
-// Flash 5
-            case FSAction.Add:
-            case FSAction.Equals:
-            case FSAction.Less:
-            case FSAction.Modulo:
-            case FSAction.Enumerate:
-            case FSAction.Duplicate:
-            case FSAction.Swap:
-            case FSAction.ExecuteMethod:
-            case FSAction.NewMethod:
-            case FSAction.ExecuteFunction:
-            case FSAction.GetAttribute:
-            case FSAction.SetAttribute:
-            case FSAction.Increment:
-            case FSAction.Decrement:
-            case FSAction.LogicalShiftLeft:
-            case FSAction.LogicalShiftRight:
-            case FSAction.ArithmeticShiftRight:
-            case FSAction.BitwiseAnd:
-            case FSAction.BitwiseOr:
-            case FSAction.BitwiseXOr:
-            case FSAction.NamedObject:
-            case FSAction.NewArray:
-            case FSAction.NewObject:
-            case FSAction.DeleteVariable:
-            case FSAction.Delete:
-            case FSAction.Return:
-            case FSAction.ToNumber:
-            case FSAction.ToString:
-            case FSAction.GetType:
-            case FSAction.GetTarget:
-            case FSAction.NewVariable:
-            case FSAction.InitVariable:
-                anAction = FSAction.getInstance(type);
-                coder.adjustPointer(8);
-                break;
-            case FSActionObject.Table:
-                anAction = new FSTable(coder);
-                length = anAction.getLength();
-                next = start + (length &lt;&lt; 3);
-                break;
-            case FSActionObject.RegisterCopy:
-                anAction = new FSRegisterCopy(coder);
-                break;
-            case FSActionObject.NewFunction:
-                anAction = new FSNewFunction(coder);
-                length = anAction.getLength();
-                next = start + (length &lt;&lt; 3);
-                break;
-            case FSActionObject.With:
-                anAction = new FSWith(coder);
-                length = anAction.getLength();
-                next = start + (length &lt;&lt; 3);
-                break;
-// Flash 6
-            case FSAction.InstanceOf:
-            case FSAction.EnumerateObject:
-            case FSAction.Greater:
-            case FSAction.StringGreater:
-            case FSAction.StrictEquals:
-                anAction = FSAction.getInstance(type);
-                coder.adjustPointer(8);
-                break;
-// Flash 7
-            case FSAction.Cast:
-            case FSAction.Extends:
-            case FSAction.Implements:
-            case FSAction.Throw:
-                anAction = FSAction.getInstance(type);
-                coder.adjustPointer(8);
-                break;
-            case FSActionObject.ExceptionHandler:
-                anAction = new FSExceptionHandler(coder);
-                break;
-            case FSActionObject.NewFunction2:
-                anAction = new FSNewFunction2(coder);
-                length = anAction.getLength();
-                next = start + (length &lt;&lt; 3);
-                break;
-            default:
-                anAction = new FSUnknownAction(coder);
-                break;
-        }
+		if (type &gt; 128)
+		{
+			coder.adjustPointer(8);
+			length = coder.scanWord(2, false);
+			start = coder.getPointer() + 16;
+			next = start + (length &lt;&lt; 3);
+			coder.adjustPointer(-8);
+		}
 
-        int delta = (coder.getPointer() - next) &gt;&gt; 3;
+		switch (type)
+		{
+			case FSAction.End:
+			case FSAction.NextFrame:
+			case FSAction.PrevFrame:
+			case FSAction.Play:
+			case FSAction.Stop:
+			case FSAction.ToggleQuality:
+			case FSAction.StopSounds:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.GetUrl:
+				anAction = new FSGetUrl(coder);
+				break;
+			// Flash 3
+			case FSActionObject.GotoFrame:
+				anAction = new FSGotoFrame(coder);
+				break;
+			// Flash 4
+			case FSActionObject.GotoLabel:
+				anAction = new FSGotoLabel(coder);
+				break;
+			case FSActionObject.SetTarget:
+				anAction = new FSSetTarget(coder);
+				break;
+			case FSActionObject.WaitForFrame:
+				anAction = new FSWaitForFrame(coder);
+				break;
+			case FSAction.IntegerAdd:
+			case FSAction.Subtract:
+			case FSAction.IntegerEquals:
+			case FSAction.IntegerLess:
+			case FSAction.Multiply:
+			case FSAction.Divide:
+			case FSAction.And:
+			case FSAction.Or:
+			case FSAction.Not:
+			case FSAction.StringEquals:
+			case FSAction.StringLength:
+			case FSAction.StringExtract:
+			case FSAction.Pop:
+			case FSAction.ToInteger:
+			case FSAction.GetVariable:
+			case FSAction.SetVariable:
+			case FSAction.SetTarget2:
+			case FSAction.StringAdd:
+			case FSAction.GetProperty:
+			case FSAction.SetProperty:
+			case FSAction.CloneSprite:
+			case FSAction.RemoveSprite:
+			case FSAction.Trace:
+			case FSAction.StartDrag:
+			case FSAction.EndDrag:
+			case FSAction.StringLess:
+			case FSAction.RandomNumber:
+			case FSAction.MBStringLength:
+			case FSAction.CharToAscii:
+			case FSAction.AsciiToChar:
+			case FSAction.GetTime:
+			case FSAction.MBStringExtract:
+			case FSAction.MBCharToAscii:
+			case FSAction.MBAsciiToChar:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.Call:
+				anAction = FSCall.getInstance();
+				coder.setPointer(next);
+				break;
+			case FSActionObject.Push:
+				anAction = new FSPush(coder);
+				break;
+			case FSActionObject.WaitForFrame2:
+				anAction = new FSWaitForFrame2(coder);
+				break;
+			case FSActionObject.Jump:
+				anAction = new FSJump(coder);
+				break;
+			case FSActionObject.If:
+				anAction = new FSIf(coder);
+				break;
+			case FSActionObject.GetUrl2:
+				anAction = new FSGetUrl2(coder);
+				break;
+			case FSActionObject.GotoFrame2:
+				anAction = new FSGotoFrame2(coder);
+				break;
+			// Flash 5
+			case FSAction.Add:
+			case FSAction.Equals:
+			case FSAction.Less:
+			case FSAction.Modulo:
+			case FSAction.Enumerate:
+			case FSAction.Duplicate:
+			case FSAction.Swap:
+			case FSAction.ExecuteMethod:
+			case FSAction.NewMethod:
+			case FSAction.ExecuteFunction:
+			case FSAction.GetAttribute:
+			case FSAction.SetAttribute:
+			case FSAction.Increment:
+			case FSAction.Decrement:
+			case FSAction.LogicalShiftLeft:
+			case FSAction.LogicalShiftRight:
+			case FSAction.ArithmeticShiftRight:
+			case FSAction.BitwiseAnd:
+			case FSAction.BitwiseOr:
+			case FSAction.BitwiseXOr:
+			case FSAction.NamedObject:
+			case FSAction.NewArray:
+			case FSAction.NewObject:
+			case FSAction.DeleteVariable:
+			case FSAction.Delete:
+			case FSAction.Return:
+			case FSAction.ToNumber:
+			case FSAction.ToString:
+			case FSAction.GetType:
+			case FSAction.GetTarget:
+			case FSAction.NewVariable:
+			case FSAction.InitVariable:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.Table:
+				anAction = new FSTable(coder);
+				length = anAction.getLength();
+				next = start + (length &lt;&lt; 3);
+				break;
+			case FSActionObject.RegisterCopy:
+				anAction = new FSRegisterCopy(coder);
+				break;
+			case FSActionObject.NewFunction:
+				anAction = new FSNewFunction(coder);
+				length = anAction.getLength();
+				next = start + (length &lt;&lt; 3);
+				break;
+			case FSActionObject.With:
+				anAction = new FSWith(coder);
+				length = anAction.getLength();
+				next = start + (length &lt;&lt; 3);
+				break;
+			// Flash 6
+			case FSAction.InstanceOf:
+			case FSAction.EnumerateObject:
+			case FSAction.Greater:
+			case FSAction.StringGreater:
+			case FSAction.StrictEquals:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			// Flash 7
+			case FSAction.Cast:
+			case FSAction.Extends:
+			case FSAction.Implements:
+			case FSAction.Throw:
+				anAction = FSAction.getInstance(type);
+				coder.adjustPointer(8);
+				break;
+			case FSActionObject.ExceptionHandler:
+				anAction = new FSExceptionHandler(coder);
+				break;
+			case FSActionObject.NewFunction2:
+				anAction = new FSNewFunction2(coder);
+				length = anAction.getLength();
+				next = start + (length &lt;&lt; 3);
+				break;
+			default:
+				anAction = new FSUnknownAction(coder);
+				break;
+		}
 
-        if (delta != 0)
-        {
-            coder.context[FSCoder.CodingError] = 1;
-            coder.context[FSCoder.TypeInError] = anAction.getType();
-            coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-            coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-            coder.context[FSCoder.Delta] = delta;
-        }
+		int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        coder.setPointer(next);
+		if (delta != 0)
+		{
+			coder.context[FSCoder.CodingError] = 1;
+			coder.context[FSCoder.TypeInError] = anAction.getType();
+			coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+			coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+			coder.context[FSCoder.Delta] = delta;
+		}
 
-        return anAction;
-    }
+		coder.setPointer(next);
 
-    static ArrayList decodeActions(byte[] encodedActions)
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, encodedActions);
-        int length = encodedActions.length;
-        int start;
+		return anAction;
+	}
 
-        ArrayList array = new ArrayList();
+	static ArrayList decodeActions(byte[] encodedActions)
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, encodedActions);
+		int length = encodedActions.length;
+		int start;
 
-        while (length &gt; 0)
-        {
-            start = coder.getPointer();
+		ArrayList array = new ArrayList();
 
-            array.add(FSMovie.decodeAction(coder));
-            length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
-        }
-        return array;
-    }
+		while (length &gt; 0)
+		{
+			start = coder.getPointer();
 
-    static ArrayList decodeShape(byte[] bytes)
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
+			array.add(FSMovie.decodeAction(coder));
+			length -= (coder.getPointer() - start) &gt;&gt;&gt; 3;
+		}
+		return array;
+	}
 
-        return decodeShape(coder);
-    }
+	static ArrayList decodeShape(byte[] bytes)
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
 
-    static ArrayList decodeShape(FSCoder coder)
-    {
-        ArrayList objects = new ArrayList();
+		return decodeShape(coder);
+	}
 
-        int fillBits = coder.readBits(4, false);
-        int lineBits = coder.readBits(4, false);
+	static ArrayList decodeShape(FSCoder coder)
+	{
+		ArrayList objects = new ArrayList();
 
-        coder.context[FSCoder.NumberOfFillBits] = fillBits;
-        coder.context[FSCoder.NumberOfLineBits] = lineBits;
+		int fillBits = coder.readBits(4, false);
+		int lineBits = coder.readBits(4, false);
 
-        while (coder.scanBits(6, false) &gt; 0)
-        {
-            if ((coder.scanBits(6, false) &amp; 0x20) &gt; 0)
-            {
-                if ((coder.scanBits(6, false) &amp; 0x10) &gt; 0)
-                    objects.add(new FSLine(coder));
-                else
-                    objects.add(new FSCurve(coder));
-            }
-            else
-            {
-                objects.add(new FSShapeStyle(coder));
-            }
-        }
+		coder.context[FSCoder.NumberOfFillBits] = fillBits;
+		coder.context[FSCoder.NumberOfLineBits] = lineBits;
 
-        coder.adjustPointer(6); // Skip over end of shape marker
-        coder.alignToByte();
+		while (coder.scanBits(6, false) &gt; 0)
+		{
+			if ((coder.scanBits(6, false) &amp; 0x20) &gt; 0)
+			{
+				if ((coder.scanBits(6, false) &amp; 0x10) &gt; 0)
+					objects.add(new FSLine(coder));
+				else
+					objects.add(new FSCurve(coder));
+			} else
+			{
+				objects.add(new FSShapeStyle(coder));
+			}
+		}
 
-        return objects;
-    }
+		coder.adjustPointer(6); // Skip over end of shape marker
+		coder.alignToByte();
 
-    private boolean decodeActions = true;
-    private boolean decodeShapes = true;
-    private boolean decodeGlyphs = true;
+		return objects;
+	}
 
-    private int identifier = 0;
-    private String encoding = &quot;UTF8&quot;;
+	private boolean decodeActions = true;
+	private boolean decodeShapes = true;
+	private boolean decodeGlyphs = true;
 
-    private String signature = &quot;&quot;;
-    private int version = Transform.VERSION;
-    private FSBounds frameSize = null;
-    private int length = 0;
-    private float frameRate = 0.0f;
-    private int frameCount = 0;
+	private int identifier = 0;
+	private String encoding = &quot;UTF8&quot;;
+	private String signature = &quot;&quot;;
+	private int version = Transform.VERSION;
+	private FSBounds frameSize = null;
+	private int length = 0;
+	private float frameRate = 0.0f;
+	private int frameCount = 0;
+	private ArrayList objects = new ArrayList();
 
-    private ArrayList objects = new ArrayList();
+	/**
+	 * Constructs an FSMovie object with no objects. The Flash version defaults
+	 * to the package constant Transform.VERSION. From VERSION = 6 onwards the
+	 * signature attribute defaults to &quot;CWS&quot; indicating that the binary data
+	 * generated when a movie is encoded movie will be compressed using the zlib
+	 * algorithm.
+	 */
+	public FSMovie()
+	{
+		if (Transform.VERSION &gt; 5)
+			signature = &quot;CWS&quot;;
+		else
+			signature = &quot;FWS&quot;;
+	}
 
-    /** Constructs an FSMovie object with no objects. The Flash version defaults to the package constant Transform.VERSION. From VERSION = 6 onwards the signature attribute defaults to &quot;CWS&quot; indicating that the binary data generated when a movie is encoded movie will be compressed using the zlib algorithm.
+	/**
+	 * Constructs an FSMovie object with the specified bounding rectangle, frame
+	 * rate and no objects. The Flash version defaults to the package constant
+	 * Transform.VERSION. From VERSION = 6 onwards the signature attribute
+	 * defaults to &quot;CWS&quot; indicating that the binary data generated when a movie
+	 * is encoded movie will be compressed using the zlib algorithm.
+	 * 
+	 * @param aBounds
+	 *            the bounding rectangle that defines the size of each frame in
+	 *            the coder.
+	 * @param framesPerSecond
+	 *            the number of frames per second that the Player plays the
+	 *            movie at.
+	 */
+	public FSMovie(FSBounds aBounds, float framesPerSecond)
+	{
+		if (Transform.VERSION &gt; 5)
+			signature = &quot;CWS&quot;;
+		else
+			signature = &quot;FWS&quot;;
 
-        */
-    public FSMovie()
-    {
-        if (Transform.VERSION &gt; 5)
-            signature = &quot;CWS&quot;;
-        else
-            signature = &quot;FWS&quot;;
-    }
+		setFrameSize(aBounds);
+		setFrameRate(framesPerSecond);
+	}
 
-    /** Constructs an FSMovie object with the specified bounding rectangle, frame rate and no objects. The Flash version defaults to the package constant Transform.VERSION. From VERSION = 6 onwards the signature attribute defaults to &quot;CWS&quot; indicating that the binary data generated when a movie is encoded movie will be compressed using the zlib algorithm.
+	/**
+	 * Constructs an FSMovie object with the specified signature, version,
+	 * bounding rectangle, frame rate and array of objects.
+	 * 
+	 * The signature controls whether the file will be compressed when encoded.
+	 * If the signature is &quot;FWS&quot; the file will not be compressed. If the
+	 * signature is &quot;CWS&quot; then the file will be compressed using the zlib
+	 * algorithm after encoding. Note that compressed Flash files are only
+	 * readable by a Flash Player that supports Flash from version 6 onwards.
+	 * 
+	 * @param encoding
+	 *            the format used to encode or decode strings.
+	 * @param signature
+	 *            a string indicating that the file contains Flash data, either
+	 *            &quot;FWS&quot; for uncompressed files or &quot;CWS&quot; for compressed files.
+	 * @param version
+	 *            the version number of Flash implemented in this coder.
+	 * @param aBounds
+	 *            the bounding rectangle that defines the size of each frame in
+	 *            the coder.
+	 * @param framesPerSecond
+	 *            the number of frames per second that the Player plays the
+	 *            movie at.
+	 * @param anArray
+	 *            the array of objects that define the coder.
+	 */
+	public FSMovie(String encoding, String signature, int version,
+					FSBounds aBounds, float framesPerSecond, ArrayList anArray)
+	{
+		setEncoding(encoding);
+		setSignature(signature);
+		setVersion(version);
+		setFrameSize(aBounds);
+		setFrameRate(framesPerSecond);
+		setObjects(anArray);
+	}
 
-        @param aBounds the bounding rectangle that defines the size of each frame in the coder.
-        @param framesPerSecond the number of frames per second that the Player plays the movie at.
-        */
-    public FSMovie(FSBounds aBounds, float framesPerSecond)
-    {
-        if (Transform.VERSION &gt; 5)
-            signature = &quot;CWS&quot;;
-        else
-            signature = &quot;FWS&quot;;
+	/**
+	 * Constructs an FSMovie object and decodes the contents of the specified
+	 * file to generate an array of objects representing the Flash file. If an
+	 * error occurs while reading and parsing the file then an exception is
+	 * thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash file that will be parsed.
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws FSCoderException -
+	 *             if an error occurs while decoding the file.
+	 * @throws IOException -
+	 *             if an I/O error occurs while reading the file.
+	 */
+	public FSMovie(String fileName) throws IOException, DataFormatException
+	{
+		decodeFromFile(fileName);
+	}
 
-        setFrameSize(aBounds);
-        setFrameRate(framesPerSecond);
-    }
+	/**
+	 * Constructs an FSMovie object and decodes the contents of the specified
+	 * file to generate an array of objects representing the Flash file. If an
+	 * error occurs while reading and parsing the file a message is sent to the
+	 * registered movie listener object.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash file that will be parsed.
+	 * @param listener
+	 *            an FSMovieListener object where errors messages are sent.
+	 * 
+	 * @deprecated
+	 */
+	public FSMovie(String fileName, FSMovieListener listener)
+	{
+		decodeFromFile(fileName, listener);
+	}
 
-    /**
-     * Constructs an FSMovie object with the specified signature, version, bounding rectangle,
-     * frame rate and array of objects.
-     *
-     * The signature controls whether the file will be compressed when encoded. If the signature is
-     * &quot;FWS&quot; the file will not be compressed. If the signature is &quot;CWS&quot; then the file will be
-     * compressed using the zlib algorithm after encoding. Note that compressed Flash files are
-     * only readable by a Flash Player that supports Flash from version 6 onwards.
-     *
-        @param encoding the format used to encode or decode strings.
-        @param signature a string indicating that the file contains Flash data,
-        either &quot;FWS&quot; for uncompressed files or &quot;CWS&quot; for compressed files.
-        @param version the version number of Flash implemented in this coder.
-        @param aBounds the bounding rectangle that defines the size of each frame in the coder.
-        @param framesPerSecond the number of frames per second that the Player plays the movie at.
-        @param anArray the array of objects that define the coder.
-        */
-    public FSMovie(String encoding, String signature, int version, FSBounds aBounds, float framesPerSecond, ArrayList anArray)
-    {
-        setEncoding(encoding);
-        setSignature(signature);
-        setVersion(version);
-        setFrameSize(aBounds);
-        setFrameRate(framesPerSecond);
-        setObjects(anArray);
-    }
+	/**
+	 * Constructs an FSMovie object and decodes the binary data presented in the
+	 * byte array to generate an array of objects representing the Flash data.
+	 * If an error occurs while parsing the data then an Exception is thrown.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the Flash binary data.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws FSCoderException -
+	 *             if an error occurs while decoding the file.
+	 * @throws IOException -
+	 *             if an I/O error occurs while reading the file.
+	 */
+	public FSMovie(byte[] data) throws DataFormatException, IOException
+	{
+		decodeFromData(data);
+	}
 
-    /** Constructs an FSMovie object and decodes the contents of the specified
-     * 	file to generate an array of objects representing the Flash file. If
-     * an error occurs while reading and parsing the file then an exception is
-     * thrown.
-     *
-     * @param fileName the path to the Flash file that will be parsed.
-     * @throws FileNotFoundException - if an error occurs while reading the file.
-     * @throws DataFormatException - if the file does not contain Flash data.
-     * @throws FSCoderException - if an error occurs while decoding the file.
-     * @throws IOException - if an I/O error occurs while reading the file.
-     */
-    public FSMovie(String fileName) throws IOException, DataFormatException
-    {
-        decodeFromFile(fileName);
-    }
-    /**
-     * Constructs an FSMovie object and decodes the contents of the specified
-     * file to generate an array of objects representing the Flash file. If
-     * an error occurs while reading and parsing the file a message is sent
-     * to the registered movie listener object.
-     *
-     * @param fileName the path to the Flash file that will be parsed.
-     * @param listener an FSMovieListener object where errors messages are
-     * sent.
-     *
-     * @deprecated
-     */
-    public FSMovie(String fileName, FSMovieListener listener)
-    {
-        decodeFromFile(fileName, listener);
-    }
+	/**
+	 * Constructs an FSMovie object and decodes the binary data presented in the
+	 * byte array to generate an array of objects representing the Flash data.
+	 * If an error occurs while parsing the data then a message is sent to the
+	 * movie listener.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the Flash binary data.
+	 * @param listener
+	 *            an FSMovieListener object where errors messages are sent.
+	 * 
+	 * @deprecated using the constructor FSMovie(byte[]) which throws an
+	 *             exception if an error is detected.
+	 */
+	public FSMovie(byte[] data, FSMovieListener listener)
+	{
+		decodeFromData(data, listener);
+	}
 
-    /**
-     * Constructs an FSMovie object and decodes the binary data presented in the byte array to generate
-     * an array of objects representing the Flash data. If an error occurs while parsing the data then
-     * an Exception is thrown.
-     *
-     * @param data an array of bytes containing the Flash binary data.
-     * @throws DataFormatException - if the file does not contain Flash data.
-     * @throws FSCoderException - if an error occurs while decoding the file.
-     * @throws IOException - if an I/O error occurs while reading the file.
-     */
-    public FSMovie(byte[] data) throws DataFormatException, IOException
-    {
-        decodeFromData(data);
-    }
-    /**
-     * Constructs an FSMovie object and decodes the binary data presented in the byte
-     * array to generate an array of objects representing the Flash data. If an error
-     * occurs while parsing the data then a message is sent to the movie listener.
-     *
-     * @param data an array of bytes containing the Flash binary data.
-     * @param listener an FSMovieListener object where errors messages are
-     * sent.
-     *
-     * @deprecated using the constructor FSMovie(byte[]) which throws an
-     * exception if an error is detected.
-     */
-    public FSMovie(byte[] data, FSMovieListener listener)
-    {
-        decodeFromData(data, listener);
-    }
+	/**
+	 * Returns a unique identifier for an object derived from the FSDefineObject
+	 * class. In order to reference objects that define items such as shapes,
+	 * sounds, etc. each must be assigned an identifier that is unique for a
+	 * given Movie.
+	 * 
+	 * When binary data is decoded into a sequence of objects, the Movie class
+	 * tracks each Define tag decoded, recording the highest value. If a new
+	 * Define tag is added to the array of decoded objects the identifier
+	 * assigned to the new tag will be guaranteed to be unique.
+	 * 
+	 * @return an unique identifier for objects that define shapes, sounds, etc.
+	 *         in a Flash file.
+	 */
+	public synchronized int newIdentifier()
+	{
+		return ++identifier;
+	}
 
-    /** Returns a unique identifier for an object derived from the FSDefineObject class. In order to reference objects that define items such as shapes, sounds, etc. each must be assigned an identifier that is unique for a given Movie.
+	/**
+	 * Gets the current value for the unique identifier that will be assigned to
+	 * definition objects (classes derived from the FSDefineObject class). The
+	 * value returned is the last value requested using the newIdentifier()
+	 * method.
+	 * 
+	 * @return current value for the unique identifier.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-        When binary data is decoded into a sequence of objects, the Movie class tracks each Define tag decoded, recording the highest value. If a new Define tag is added to the array of decoded objects the identifier assigned to the new tag will be guaranteed to be unique.
+	/**
+	 * Sets the initial value for the unique identifier assigned to definition
+	 * objects. When a new identifier is requested the identifier is incremented
+	 * before being returned. For most situations the method argument will be
+	 * zero. This method should be used with caution as generating definition
+	 * object with duplicate identifiers will most probably crash the program
+	 * displaying the Flash file generated.
+	 * 
+	 * @param aValue
+	 *            the initial value for the unique identifier.
+	 */
+	public void setIdentifier(int aValue)
+	{
+		identifier = aValue;
+	}
 
-        @return an unique identifier for objects that define shapes, sounds, etc. in a Flash file.
-        */
-    public synchronized int newIdentifier()
-    {
-        return ++identifier;
-    }
+	/**
+	 * Gets the encoding scheme for strings encoded and decoded from Flash
+	 * files. The default encoding format is UTF8 which provides backward
+	 * compatibility for Flash files that contain ASCII encoded string. For
+	 * files generated by internationalized versions of the Flash authoring tool
+	 * any string recognised by the Java environment as identifying a character
+	 * encoding scheme may be used. For example, &quot;SJIS&quot; may be used to decode
+	 * files generated using the Japanese language version of Flash - Version 5
+	 * or earlier.
+	 * 
+	 * With the introduction of Flash 6 support for Unicode strings was added so
+	 * the default encoding of UTF8 will be useful for most applications.
+	 * 
+	 * @return the string identifying the format for strings. Any string
+	 *         recognised by the Java environment may be used, &quot;ASCII&quot;, &quot;SJIS&quot;
+	 *         and UTF8&quot; will be the three most commonly used.
+	 */
+	public String getEncoding()
+	{
+		return encoding;
+	}
 
-    /** Gets the current value for the unique identifier that will be assigned to definition objects (classes derived from the FSDefineObject class). The value returned is the last value requested using the newIdentifier() method.
+	/**
+	 * Sets the encoding scheme for strings encoded and decoded from Flash
+	 * files. For files generated by internationalized versions of the Flash
+	 * authoring tool any string recognised by the Java environment as
+	 * identifying a character encoding scheme may be used. For example, &quot;SJIS&quot;
+	 * may be used to decode files generated using the Japanese language version
+	 * of Flash - Version 5 or earlier.
+	 * 
+	 * @param encoding
+	 *            string identifying the format for strings. Any string
+	 *            recognised by the Java environment may be used, &quot;ASCII&quot;,
+	 *            &quot;SJIS&quot; and UTF8&quot; will be the three most commonly used.
+	 */
+	public void setEncoding(String encoding)
+	{
+		this.encoding = encoding;
+	}
 
-        @return current value for the unique identifier.
-        */
-    public int getIdentifier()
-    {
-        return identifier;
-    }
+	public void setDecodeActions(boolean decode)
+	{
+		decodeActions = decode;
+	}
 
-    /** Sets the initial value for the unique identifier assigned to definition objects. When a new identifier is requested the identifier is incremented before being returned. For most situations the method argument will be zero. This method should be used with caution as generating definition object with duplicate identifiers will most probably crash the program displaying the Flash file generated.
+	public boolean willDecodeActions()
+	{
+		return decodeActions;
+	}
 
-        @param aValue the initial value for the unique identifier.
-        */
-    public void setIdentifier(int aValue)
-    {
-        identifier = aValue;
-    }
+	public void setDecodeShapes(boolean decode)
+	{
+		decodeShapes = decode;
+	}
 
-    /**
-     * Gets the encoding scheme for strings encoded and decoded from Flash files. The default
-     * encoding format is UTF8 which provides backward compatibility for Flash files that contain
-     * ASCII encoded string. For files generated by internationalized versions of the Flash
-     * authoring tool any string recognised by the Java environment as identifying a character
-     * encoding scheme may be used. For example, &quot;SJIS&quot; may be used to decode files generated
-     * using the Japanese language version of Flash - Version 5 or earlier.
-     *
-     * With the introduction of Flash 6 support for Unicode strings was added so the default
-     * encoding of UTF8 will be useful for most applications.
-     *
-     * @return the string identifying the format for strings. Any string recognised by the Java
-     * environment may be used, &quot;ASCII&quot;, &quot;SJIS&quot; and UTF8&quot; will be the three most commonly used.
-     */
-    public String getEncoding()
-    {
-        return encoding;
-    }
+	public boolean willDecodeShapes()
+	{
+		return decodeShapes;
+	}
 
-    /**
-     * Sets the encoding scheme for strings encoded and decoded from Flash files. For files
-     * generated by internationalized versions of the Flash authoring tool any string recognised
-     * by the Java environment as identifying a character encoding scheme may be used. For example,
-     * &quot;SJIS&quot; may be used to decode files generated using the Japanese language version of
-     * Flash - Version 5 or earlier.
-     *
-     * @param encoding string identifying the format for strings. Any string recognised by the Java
-     * environment may be used, &quot;ASCII&quot;, &quot;SJIS&quot; and UTF8&quot; will be the three most commonly used.
-     */
-    public void setEncoding(String encoding)
-    {
-        this.encoding = encoding;
-    }
+	public void setDecodeGlyphs(boolean decode)
+	{
+		decodeGlyphs = decode;
+	}
 
-    public void setDecodeActions(boolean decode)
-    {
-        decodeActions = decode;
-    }
-    public boolean willDecodeActions()
-    {
-        return decodeActions;
-    }
-    public void setDecodeShapes(boolean decode)
-    {
-        decodeShapes = decode;
-    }
-    public boolean willDecodeShapes()
-    {
-        return decodeShapes;
-    }
-    public void setDecodeGlyphs(boolean decode)
-    {
-        decodeGlyphs = decode;
-    }
-    public boolean willDecodeGlyphs()
-    {
-        return decodeGlyphs;
-    }
-    /**
-     * Gets the signature identifying that the movie contains Flash. Up to version 5 the string
-     * &quot;FWS&quot; identifies that data is encoded using the Flash file format. From Flash version 6
-     * onwards Flash data could also be compressed using the zlib algorithm to reduce the file
-     * size. A signature of &quot;CWS&quot; is used to denote that a file contain compressed Flash data.
-     * The original signature &quot;FWS&quot; is still used to denote that a file contains uncompressed
-     * data.
-     *
-     * When encoding a FSMovie object the signature also determines whether the data generated
-     * will be compressed.
-     *
-     * @return the string identifying the format for the encoded Flash data.
-     */
-    public String getSignature()
-    {
-        return signature;
-    }
+	public boolean willDecodeGlyphs()
+	{
+		return decodeGlyphs;
+	}
 
-    /**
-     * Sets the signature for the Flash data when it is encoded. The signature is used to control
-     * whether the encoded data will be compressed. If the signature is &quot;CWS&quot; then the movie
-     * data will be compressed. If the signature is &quot;FWS&quot; then the data will not be compressed.
-     *
-     * @param aString the signature used for the encoded Flash file.
-     */
-    public void setSignature(String aString)
-    {
-        signature = aString;
-    }
+	/**
+	 * Gets the signature identifying that the movie contains Flash. Up to
+	 * version 5 the string &quot;FWS&quot; identifies that data is encoded using the
+	 * Flash file format. From Flash version 6 onwards Flash data could also be
+	 * compressed using the zlib algorithm to reduce the file size. A signature
+	 * of &quot;CWS&quot; is used to denote that a file contain compressed Flash data. The
+	 * original signature &quot;FWS&quot; is still used to denote that a file contains
+	 * uncompressed data.
+	 * 
+	 * When encoding a FSMovie object the signature also determines whether the
+	 * data generated will be compressed.
+	 * 
+	 * @return the string identifying the format for the encoded Flash data.
+	 */
+	public String getSignature()
+	{
+		return signature;
+	}
 
-    /** Gets the number representing the version of Flash that the movie represents.
+	/**
+	 * Sets the signature for the Flash data when it is encoded. The signature
+	 * is used to control whether the encoded data will be compressed. If the
+	 * signature is &quot;CWS&quot; then the movie data will be compressed. If the
+	 * signature is &quot;FWS&quot; then the data will not be compressed.
+	 * 
+	 * @param aString
+	 *            the signature used for the encoded Flash file.
+	 */
+	public void setSignature(String aString)
+	{
+		signature = aString;
+	}
 
-        @return an integer defining the Flash version number for the coder.
-        */
-    public int getVersion()
-    {
-        return version;
-    }
+	/**
+	 * Gets the number representing the version of Flash that the movie
+	 * represents.
+	 * 
+	 * @return an integer defining the Flash version number for the coder.
+	 */
+	public int getVersion()
+	{
+		return version;
+	}
 
-    /** Sets the Flash version supported in this Movie. Note that there are no restrictions on the objects that can be used in a coder. Using objects that are not supported by an earlier version of the Flash file format may cause the Player to not display the movie correctly or even crash the Player.
+	/**
+	 * Sets the Flash version supported in this Movie. Note that there are no
+	 * restrictions on the objects that can be used in a coder. Using objects
+	 * that are not supported by an earlier version of the Flash file format may
+	 * cause the Player to not display the movie correctly or even crash the
+	 * Player.
+	 * 
+	 * @param aNumber
+	 *            the version of the Flash file format that this movie utilises.
+	 */
+	public void setVersion(int aNumber)
+	{
+		version = aNumber;
+	}
 
-        @param aNumber the version of the Flash file format that this movie utilises.
-        */
-    public void setVersion(int aNumber)
-    {
-        version = aNumber;
-    }
+	/**
+	 * Gets the bounding rectangle that defines the size of the player screen.
+	 * 
+	 * @return the FSBounds object that defines the bounding rectangle that
+	 *         describes the size of each frame in the coder.
+	 */
+	public FSBounds getFrameSize()
+	{
+		return frameSize;
+	}
 
-    /** Gets the bounding rectangle that defines the size of the player screen.
+	/**
+	 * Sets the bounding rectangle that defines the size of the player screen.
+	 * The coordinates of the bounding rectangle are also used to define the
+	 * coordinate range. For example if a 400 x 400 pixel rectangle is defined,
+	 * specifying the values for the x and y coordinates the range -200 to 200
+	 * sets the centre of the screen at (0,0), if the x and y coordinates are
+	 * specified in the range 0 to 400 then the centre of the screen will be at
+	 * (200, 200).
+	 * 
+	 * @param aBounds
+	 *            the FSBounds object that defines the frame size.
+	 */
+	public void setFrameSize(FSBounds aBounds)
+	{
+		frameSize = aBounds;
+	}
 
-        @return the FSBounds object that defines the bounding rectangle that describes the size of each frame in the coder.
-        */
-    public FSBounds getFrameSize()
-    {
-        return frameSize;
-    }
+	/**
+	 * Gets the number of frames played per second that the movie will be
+	 * displayed at.
+	 * 
+	 * @return the speed the movie will be played at.
+	 */
+	public float getFrameRate()
+	{
+		return frameRate;
+	}
 
-    /** Sets the bounding rectangle that defines the size of the player screen. The coordinates of the bounding rectangle are also used to define the coordinate range. For example if a 400 x 400 pixel  rectangle is defined, specifying the values for the x and y coordinates the range -200 to 200 sets the centre of the screen at (0,0), if the x and y coordinates are specified in the range 0 to 400 then the centre of the screen will be at (200, 200).
+	/**
+	 * Sets the number of frames played per second that the Player will display
+	 * the coder.
+	 * 
+	 * @param aNumber
+	 *            the number of frames per second that the movie is played.
+	 */
+	public void setFrameRate(float aNumber)
+	{
+		frameRate = aNumber;
+	}
 
-        @param aBounds the FSBounds object that defines the frame size.
-        */
-    public void setFrameSize (FSBounds aBounds)
-    {
-        frameSize = aBounds;
-    }
+	/**
+	 * Gets the array of objects contained in the Movie.
+	 * 
+	 * @return the array of objects that describe a coder.
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-    /** Gets the number of frames played per second that the movie will be displayed at.
+	/**
+	 * Sets the array of objects contained in the Movie.
+	 * 
+	 * @param anArray
+	 *            the array of objects that describe a coder.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-        @return the speed the movie will be played at.
-        */
-    public float getFrameRate()
-    {
-        return frameRate;
-    }
+	/**
+	 * Adds the object to the Movie.
+	 * 
+	 * @param anObject
+	 *            the object to be added to the movie.
+	 */
+	public void add(FSMovieObject anObject)
+	{
+		objects.add(anObject);
+	}
 
-    /** Sets the number of frames played per second that the Player will display the coder.
+	/**
+	 * Adds all of the objects in the array to the Movie.
+	 * 
+	 * @param array
+	 *            an array of FSMovieObjects.
+	 */
+	public void add(ArrayList array)
+	{
+		objects.addAll(array);
+	}
 
-        @param aNumber the number of frames per second that the movie is played.
-        */
-    public void setFrameRate (float aNumber)
-    {
-        frameRate = aNumber;
-    }
+	/**
+	 * Gets an array of objects from the Movie with the specified type. For
+	 * example to retrieve all the FSDefineShape objects specified in a movie:
+	 * 
+	 * &lt;pre&gt;
+	 * ArrayList allShapes = aMovie.getObjectsOfType(FSMovieObject.DefineShape);
+	 * &lt;/pre&gt;
+	 * 
+	 * Note that only objects at the &quot;top-level&quot; in the movie are checked,
+	 * namely movie or definition objects. Objects &quot;owned&quot; by another object
+	 * such as Action objects inside FSDoAction, FSButtonEvent or FSClipEvent
+	 * objects cannot be retrieved using this method.
+	 * 
+	 * @param aType
+	 *            the type to search the movie for.
+	 */
+	public ArrayList getObjectsOfType(int aType)
+	{
+		ArrayList selectedObjects = new ArrayList();
 
-    /** Gets the array of objects contained in the Movie.
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject currentObject = (FSMovieObject) i.next();
 
-        @return the array of objects that describe a coder.
-        */
-    public ArrayList getObjects() { return objects; }
+			if (currentObject.getType() == aType)
+				selectedObjects.add(currentObject);
+		}
+		return selectedObjects;
+	}
 
-    /** Sets the array of objects contained in the Movie.
+	/**
+	 * Decodes the contents of the specified file. An object for each tag
+	 * decoded from the file is placed in the Movie's object array in the order
+	 * they were decoded from the file. If an error occurs while reading and
+	 * parsing the file then an exception is thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash file that will be parsed.
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws FSCoderException -
+	 *             if an error occurs while decoding the file.
+	 * @throws IOException -
+	 *             if an I/O error occurs while reading the file.
+	 */
+	public void decodeFromFile(String fileName) throws FileNotFoundException,
+					DataFormatException, IOException
+	{
+		FileInputStream fileContents = null;
 
-        @param anArray the array of objects that describe a coder.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		File swfFile = new File(fileName);
 
-    /** Adds the object to the Movie.
+		fileContents = new FileInputStream(swfFile);
 
-        @param anObject the object to be added to the movie.
-        */
-    public void add(FSMovieObject anObject)
-    {
-        objects.add(anObject);
-    }
+		int fileLength = (int) swfFile.length();
+		byte[] contents = new byte[fileLength];
 
-    /** Adds all of the objects in the array to the Movie.
+		fileContents.read(contents);
+		fileContents.close();
 
-        @param array an array of FSMovieObjects.
-        */
-    public void add(ArrayList array)
-    {
-        objects.addAll(array);
-    }
+		decodeFromData(contents);
+	}
 
-    /**
-     * Gets an array of objects from the Movie with the specified type. For example
-     * to retrieve all the FSDefineShape objects specified in a movie:
+	/**
+	 * Decodes the contents of the specified file. An object for each tag
+	 * decoded from the file is placed in the Movie's object array in the order
+	 * they were decoded from the file. If an error occurs while reading and
+	 * parsing the file then a message is sent to the movie listener.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash file that will be parsed.
+	 * @param listener
+	 *            an FSMovieListener object where errors messages are sent.
+	 * 
+	 * @deprecated use the decodeFromFile(String) method which throws an
+	 *             exception if an error is detected.
+	 * 
+	 */
+	public void decodeFromFile(String fileName, FSMovieListener listener)
+	{
+		FileInputStream fileContents = null;
 
-        &lt;pre&gt;
-         ArrayList allShapes= aMovie.getObjectsOfType(FSMovieObject.DefineShape);
-        &lt;/pre&gt;
+		try
+		{
+			File swfFile = new File(fileName);
 
-        Note that only objects at the &quot;top-level&quot; in the movie are checked, namely
-        movie or definition objects. Objects &quot;owned&quot; by another object such as
-        Action objects inside FSDoAction, FSButtonEvent or FSClipEvent objects
-        cannot be retrieved using this method.
+			fileContents = new FileInputStream(swfFile);
 
-        @param aType the type to search the movie for.
-        */
-    public ArrayList getObjectsOfType(int aType)
-    {
-        ArrayList selectedObjects = new ArrayList();
+			int fileLength = (int) swfFile.length();
+			byte[] contents = new byte[fileLength];
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject currentObject = (FSMovieObject)i.next();
+			fileContents.read(contents);
+			fileContents.close();
 
-            if (currentObject.getType() == aType)
-                selectedObjects.add(currentObject);
-        }
-        return selectedObjects;
-    }
+			decodeFromData(contents, listener);
+		} catch (SecurityException e)
+		{
+			if (listener != null)
+				listener.logEvent(new FSMovieEvent(FSMovieEvent.Decode,
+								FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
+		} catch (FileNotFoundException e)
+		{
+			if (listener != null)
+				listener.logEvent(new FSMovieEvent(FSMovieEvent.Decode,
+								FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
+		} catch (IOException e)
+		{
+			if (listener != null)
+				listener.logEvent(new FSMovieEvent(FSMovieEvent.Decode,
+								FSMovieEvent.Error, 0, 0, &quot;FileReadError&quot;));
+		}
+	}
 
-    /**
-     * Decodes the contents of the specified file. An object for each tag decoded from the file
-     * is placed in the  Movie's object array in the order they were decoded from the file. If
-     * an error occurs while reading and parsing the file then an exception is thrown.
-     *
-     * @param fileName the path to the Flash file that will be parsed.
-     * @throws FileNotFoundException - if an error occurs while reading the file.
-     * @throws DataFormatException - if the file does not contain Flash data.
-     * @throws FSCoderException - if an error occurs while decoding the file.
-     * @throws IOException - if an I/O error occurs while reading the file.
-     */
-    public void decodeFromFile(String fileName) throws FileNotFoundException, DataFormatException, IOException
-    {
-        FileInputStream fileContents = null;
+	/**
+	 * Decodes the binary Flash data stored in the byte array. If an error
+	 * occurs while the data is being decoded an exception is thrown. The array
+	 * of objects in the Movie will contain the last tag successfully decoded.
+	 * 
+	 * @param bytes
+	 *            an array of bytes that contain the encoded Flash objects.
+	 * 
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws FSCoderException -
+	 *             if an error occurs while decoding the file.
+	 * @throws IOException -
+	 *             if an I/O error occurs while reading the file.
+	 */
+	public void decodeFromData(byte[] bytes) throws DataFormatException,
+					IOException
+	{
+		FSCoder coder = null;
+		FSMovieObject object = null;
 
-        File swfFile = new File(fileName);
+		isFlash(bytes);
 
-        fileContents = new FileInputStream(swfFile);
+		if (bytes[0] == 0x43)
+			coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
+		else
+			coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
 
-        int fileLength = (int)swfFile.length();
-        byte[] contents = new byte[fileLength];
+		signature = coder.readString(3, &quot;UTF8&quot;);
+		version = coder.readWord(1, false);
+		/* length */coder.readWord(4, false);
+		frameSize = new FSBounds(coder);
+		frameRate = coder.readFixedWord(1, 1);
+		frameCount = coder.readWord(2, false);
 
-        fileContents.read(contents);
-        fileContents.close();
+		coder.context[FSCoder.Version] = version;
+		coder.context[FSCoder.DecodeActions] = decodeActions ? 1 : 0;
+		coder.context[FSCoder.DecodeShapes] = decodeShapes ? 1 : 0;
+		coder.context[FSCoder.DecodeGlyphs] = decodeGlyphs ? 1 : 0;
 
-        decodeFromData(contents);
-    }
-    /**
-     * Decodes the contents of the specified file. An object for each tag decoded from the file
-     * is placed in the  Movie's object array in the order they were decoded from the file. If
-     * an error occurs while reading and parsing the file then a message is sent to the
-     * movie listener.
-     *
-     * @param fileName the path to the Flash file that will be parsed.
-     * @param listener an FSMovieListener object where errors messages are
-     * sent.
-     *
-     * @deprecated use the decodeFromFile(String) method which throws an
-     * exception if an error is detected.
-     *
-     */
-    public void decodeFromFile(String fileName, FSMovieListener listener)
-    {
-        FileInputStream fileContents = null;
+		while ((object = decodeObject(coder)) != null)
+		{
+			objects.add(object);
 
-        try
-        {
-            File swfFile = new File(fileName);
+			if (coder.context[FSCoder.CodingError] == 1)
+			{
+				throw new FSCoderException(
+								coder.context[FSCoder.TypeInError],
+								coder.context[FSCoder.StartOfError],
+								coder.context[FSCoder.ExpectedLength],
+								coder.context[FSCoder.Delta],
+								(coder.context[FSCoder.Delta] &gt; 0) ? &quot;ObjectOverflow&quot;
+												: &quot;ObjectUnderflow&quot;);
+			}
+		}
+		identifier = coder.context[FSCoder.Identifier];
+	}
 
-            fileContents = new FileInputStream(swfFile);
+	/**
+	 * Decodes the binary Flash data stored in the byte array. If an error
+	 * occurs while the data is being decoded a message is sent to the movie
+	 * listner object. The array of objects in the Movie will contain the last
+	 * tag successfully decoded.
+	 * 
+	 * @param bytes
+	 *            an array of bytes that contain the encoded Flash objects.
+	 * @param listener
+	 *            an FSMovieListener object where errors messages are sent.
+	 * 
+	 * @deprecated use the decodeFromData(bytep[]) method which throws an
+	 *             exception if an error is detected.
+	 */
+	public void decodeFromData(byte[] bytes, FSMovieListener listener)
+	{
+		FSCoder coder = null;
+		FSMovieObject object = null;
 
-            int fileLength = (int)swfFile.length();
-            byte[] contents = new byte[fileLength];
+		try
+		{
+			isFlash(bytes);
 
-            fileContents.read(contents);
-            fileContents.close();
+			if (bytes[0] == 0x43)
+				coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
+			else
+				coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
 
-            decodeFromData(contents, listener);
-        }
-        catch (SecurityException e)
-        {
-            if (listener != null)
-                listener.logEvent(new FSMovieEvent(FSMovieEvent.Decode, FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
-        }
-        catch (FileNotFoundException e)
-        {
-            if (listener != null)
-                listener.logEvent(new FSMovieEvent(FSMovieEvent.Decode, FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
-        }
-        catch (IOException e)
-        {
-            if (listener != null)
-                listener.logEvent(new FSMovieEvent(FSMovieEvent.Decode, FSMovieEvent.Error, 0, 0, &quot;FileReadError&quot;));
-        }
-    }
+			coder.context[FSCoder.Action] = FSMovieEvent.Decode;
+			coder.setListener(listener);
+			coder.beginObject(&quot;FSMovie&quot;);
 
-   /**
-    * Decodes the binary Flash data stored in the byte array. If an error occurs while the data
-    * is being decoded an exception is thrown. The array of objects in the Movie will
-    * contain the last tag successfully decoded.
-    *
-    * @param bytes an array of bytes that contain the encoded Flash objects.
-    *
-    * @throws DataFormatException - if the file does not contain Flash data.
-    * @throws FSCoderException - if an error occurs while decoding the file.
-    * @throws IOException - if an I/O error occurs while reading the file.
-    */
-    public void decodeFromData(byte[] bytes) throws DataFormatException, IOException
-    {
-        FSCoder coder = null;
-        FSMovieObject object = null;
+			signature = coder.readString(3, &quot;UTF8&quot;);
+			version = coder.readWord(1, false);
+			length = coder.readWord(4, false);
+			frameSize = new FSBounds(coder);
+			frameRate = coder.readFixedWord(1, 1);
+			frameCount = coder.readWord(2, false);
 
-        isFlash(bytes);
+			coder.context[FSCoder.Version] = version;
 
-        if (bytes[0] == 0x43)
-            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
-        else
-            coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
+			coder.beginObject(&quot;ArrayList&quot;);
 
-        signature = coder.readString(3, &quot;UTF8&quot;);
-        version = coder.readWord(1, false);
-        /* length */ coder.readWord(4, false);
-        frameSize = new FSBounds(coder);
-        frameRate = coder.readFixedWord(1, 1);
-        frameCount = coder.readWord(2, false);
+			while ((object = decodeObject(coder)) != null)
+			{
+				objects.add(object);
+			}
 
-        coder.context[FSCoder.Version] = version;
-        coder.context[FSCoder.DecodeActions] = decodeActions ? 1 : 0;
-        coder.context[FSCoder.DecodeShapes] = decodeShapes ? 1 : 0;
-        coder.context[FSCoder.DecodeGlyphs] = decodeGlyphs ? 1 : 0;
+			coder.endObject(&quot;ArrayList&quot;);
 
-        while ((object = decodeObject(coder)) != null)
-        {
-            objects.add(object);
+			identifier = coder.context[FSCoder.Identifier];
 
-            if (coder.context[FSCoder.CodingError] == 1)
-            {
-                throw new FSCoderException(
-                    coder.context[FSCoder.TypeInError],
-                    coder.context[FSCoder.StartOfError],
-                    coder.context[FSCoder.ExpectedLength],
-                    coder.context[FSCoder.Delta],
-                    (coder.context[FSCoder.Delta] &gt; 0) ? &quot;ObjectOverflow&quot; : &quot;ObjectUnderflow&quot;);
-            }
-        }
-        identifier = coder.context[FSCoder.Identifier];
-    }
+			coder.endObject(&quot;FSMovie&quot;);
+		} catch (DataFormatException e)
+		{
+			coder.logError(&quot;DataFormatError&quot;, 0, 0);
+		}
+	}
 
-    /**
-     * Decodes the binary Flash data stored in the byte array. If an error occurs while the data
-     * is being decoded a message is sent to the movie listner object. The array of objects in
-     * the Movie will contain the last tag successfully decoded.
-     *
-     * @param bytes an array of bytes that contain the encoded Flash objects.
-     * @param listener an FSMovieListener object where errors messages are
-     * sent.
-     *
-     * @deprecated use the decodeFromData(bytep[]) method which throws an
-     * exception if an error is detected.
-     */
-    public void decodeFromData(byte[] bytes, FSMovieListener listener)
-    {
-        FSCoder coder = null;
-        FSMovieObject object = null;
+	/**
+	 * Encodes the array of objects and writes the data to the specified file.
+	 * If an error occurs while encoding the file then an exception is thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash file that the movie will be encoded to.
+	 * 
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while opening the file.
+	 * @throws FSCoderException -
+	 *             if an error occurs while encoding the file.
+	 * @throws IOException -
+	 *             if an I/O error occurs while writing the file.
+	 */
+	public void encodeToFile(String fileName) throws FileNotFoundException,
+					IOException
+	{
+		FileOutputStream fileContents = null;
 
-        try
-        {
-            isFlash(bytes);
+		fileContents = new FileOutputStream(fileName);
 
-            if (bytes[0] == 0x43)
-                coder = new FSCoder(FSCoder.LITTLE_ENDIAN, unzip(bytes));
-            else
-                coder = new FSCoder(FSCoder.LITTLE_ENDIAN, bytes);
+		byte[] encodedData = encode();
 
-            coder.context[FSCoder.Action]  = FSMovieEvent.Decode;
-            coder.setListener(listener);
-            coder.beginObject(&quot;FSMovie&quot;);
+		fileContents.write(encodedData);
+		fileContents.close();
+	}
 
-            signature = coder.readString(3, &quot;UTF8&quot;);
-            version = coder.readWord(1, false);
-            length = coder.readWord(4, false);
-            frameSize = new FSBounds(coder);
-            frameRate = coder.readFixedWord(1, 1);
-            frameCount = coder.readWord(2, false);
+	/**
+	 * Encodes the array of objects and writes the data to the specified file.
+	 * If an error occurs while encoding the file then a message is sent to the
+	 * movie listener.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash file that the movie will be encoded to.
+	 * @param listener
+	 *            an FSMovieListener object where errors messages are sent.
+	 * 
+	 * @deprecated use the encodeToFile(String) method which throws an exception
+	 *             if an error is detected.
+	 */
+	public void encodeToFile(String fileName, FSMovieListener listener)
+	{
+		FileOutputStream fileContents = null;
 
-            coder.context[FSCoder.Version] = version;
+		try
+		{
+			fileContents = new FileOutputStream(fileName);
 
-            coder.beginObject(&quot;ArrayList&quot;);
+			byte[] encodedData = encode(listener);
 
-            while ((object = decodeObject(coder)) != null)
-            {
-                objects.add(object);
-            }
+			fileContents.write(encodedData);
+			fileContents.close();
+		} catch (SecurityException e)
+		{
+			if (listener != null)
+				listener.logEvent(new FSMovieEvent(FSMovieEvent.Encode,
+								FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
+		} catch (FileNotFoundException e)
+		{
+			if (listener != null)
+				listener.logEvent(new FSMovieEvent(FSMovieEvent.Encode,
+								FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
+		} catch (IOException e)
+		{
+			if (listener != null)
+				listener.logEvent(new FSMovieEvent(FSMovieEvent.Encode,
+								FSMovieEvent.Error, 0, 0, &quot;FileWriteError&quot;));
+		}
+	}
 
-            coder.endObject(&quot;ArrayList&quot;);
+	/**
+	 * Returns the encoded representation of the array of objects that this
+	 * Movie contains. If an error occurs while encoding the file then an
+	 * exception is thrown.
+	 * 
+	 * @return the array of bytes representing the encoded objects.
+	 * @throws FSCoderException -
+	 *             if an error occurs while encoding the file.
+	 * @throws IOException -
+	 *             if an I/O error occurs while encoding the file.
+	 */
+	public byte[] encode() throws IOException
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]);
 
-            identifier = coder.context[FSCoder.Identifier];
+		coder.context[FSCoder.Action] = FSMovieEvent.Encode;
+		coder.context[FSCoder.Version] = version;
 
-            coder.endObject(&quot;FSMovie&quot;);
-        }
-        catch (DataFormatException e)
-        {
-            coder.logError(&quot;DataFormatError&quot;, 0, 0);
-        }
-    }
+		int fileLength = length(coder);
 
-    /**
-     * Encodes the array of objects and writes the data to the specified file. If an error occurs
-     * while encoding the file then an exception is thrown.
-     *
-     * @param fileName the path to the Flash file that the movie will be encoded to.
-     *
-     * @throws FileNotFoundException - if an error occurs while opening the file.
-     * @throws FSCoderException - if an error occurs while encoding the file.
-     * @throws IOException - if an I/O error occurs while writing the file.
-     */
-    public void encodeToFile(String fileName) throws FileNotFoundException, IOException
-    {
-        FileOutputStream fileContents = null;
+		coder.setData(FSCoder.LITTLE_ENDIAN, new byte[fileLength]);
 
-        fileContents = new FileOutputStream(fileName);
+		coder.writeString(signature, &quot;UTF8&quot;);
+		coder.writeWord(version, 1);
+		coder.writeWord(fileLength, 4);
+		frameSize.encode(coder);
+		coder.writeFixedWord(frameRate, 1, 1);
+		coder.writeWord(numberOfFrames(), 2);
 
-        byte[] encodedData = encode();
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject object = (FSMovieObject) i.next();
 
-        fileContents.write(encodedData);
-        fileContents.close();
-    }
-    /**
-     * Encodes the array of objects and writes the data to the specified file. If an error occurs
-     * while encoding the file then a message is sent to the movie listener.
-     *
-     * @param fileName the path to the Flash file that the movie will be encoded to.
-     * @param listener an FSMovieListener object where errors messages are
-     * sent.
-     *
-     * @deprecated use the encodeToFile(String) method which throws an
-     * exception if an error is detected.
-     */
-    public void encodeToFile(String fileName, FSMovieListener listener)
-    {
-        FileOutputStream fileContents = null;
+			int len = object.getLength();
+			int start = coder.getPointer()
+							+ ((object.getExtendLength() || len &gt;= 63) ? 48
+											: 16);
+			int next = start + (len &lt;&lt; 3);
 
-        try
-        {
-            fileContents = new FileOutputStream(fileName);
+			object.encode(coder);
+			coder.setPointer(next);
 
-            byte[] encodedData = encode(listener);
+			if (coder.context[FSCoder.CodingError] == 1)
+			{
+				throw new FSCoderException(
+								coder.context[FSCoder.TypeInError],
+								coder.context[FSCoder.StartOfError],
+								coder.context[FSCoder.ExpectedLength],
+								coder.context[FSCoder.Delta],
+								(coder.context[FSCoder.Delta] &gt; 0) ? &quot;ObjectOverflow&quot;
+												: &quot;ObjectUnderflow&quot;);
+			}
+		}
+		coder.writeWord(0, 2);
 
-            fileContents.write(encodedData);
-            fileContents.close();
-        }
-        catch (SecurityException e)
-        {
-            if (listener != null)
-                listener.logEvent(new FSMovieEvent(FSMovieEvent.Encode, FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
-        }
-        catch (FileNotFoundException e)
-        {
-            if (listener != null)
-                listener.logEvent(new FSMovieEvent(FSMovieEvent.Encode, FSMovieEvent.Error, 0, 0, &quot;FileNotFoundError&quot;));
-        }
-        catch (IOException e)
-        {
-            if (listener != null)
-                listener.logEvent(new FSMovieEvent(FSMovieEvent.Encode, FSMovieEvent.Error, 0, 0, &quot;FileWriteError&quot;));
-        }
-    }
+		byte[] data = null;
 
-    /**
-     * Returns the encoded representation of the array of objects that this Movie contains.
-     * If an error occurs while encoding the file then an exception is thrown.
-     *
-     * @return the array of bytes representing the encoded objects.
-     * @throws FSCoderException - if an error occurs while encoding the file.
-     * @throws IOException - if an I/O error occurs while encoding the file.
-     */
-    public byte[] encode() throws IOException
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]);
+		try
+		{
+			if (signature.equals(&quot;CWS&quot;))
+				data = zip(coder.getData(), fileLength);
+			else
+				data = coder.getData();
+		} catch (DataFormatException e)
+		{
+			throw new IOException(&quot;Error compressing Flash file.&quot;);
+		}
+		return data;
+	}
 
-        coder.context[FSCoder.Action]  = FSMovieEvent.Encode;
-        coder.context[FSCoder.Version] = version;
+	/**
+	 * Returns the encoded representation of the array of objects that this
+	 * Movie contains. If an error occurs while encoding the file then a message
+	 * is sent to the movie listner.
+	 * 
+	 * @return the array of bytes representing the encoded objects.
+	 * @param listener
+	 *            an FSMovieListener object where errors messages are sent.
+	 * 
+	 * @deprecated use the encode() method which throws an exception if an error
+	 *             is detected.
+	 */
+	public byte[] encode(FSMovieListener listener)
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]);
 
-        int fileLength = length(coder);
+		coder.context[FSCoder.Action] = FSMovieEvent.Encode;
+		coder.context[FSCoder.Version] = version;
 
-        coder.setData(FSCoder.LITTLE_ENDIAN, new byte[fileLength]);
+		int fileLength = length(coder);
 
-        coder.writeString(signature, &quot;UTF8&quot;);
-        coder.writeWord(version, 1);
-        coder.writeWord(fileLength, 4);
-        frameSize.encode(coder);
-        coder.writeFixedWord(frameRate, 1, 1);
-        coder.writeWord(numberOfFrames(), 2);
+		coder.setData(FSCoder.LITTLE_ENDIAN, new byte[fileLength]);
+		coder.setListener(listener);
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
+		coder.beginObject(&quot;FSMovie&quot;);
 
-            int len = object.getLength();
-            int start = coder.getPointer() + ((object.getExtendLength() || len &gt;= 63) ? 48 : 16);
-            int next = start + (len &lt;&lt; 3);
+		coder.writeString(signature, &quot;UTF8&quot;);
+		coder.writeWord(version, 1);
+		coder.writeWord(fileLength, 4);
+		frameSize.encode(coder);
+		coder.writeFixedWord(frameRate, 8, 8);
+		coder.writeWord(numberOfFrames(), 2);
 
-            object.encode(coder);
-            coder.setPointer(next);
+		coder.beginObject(&quot;ArrayList&quot;);
 
-            if (coder.context[FSCoder.CodingError] == 1)
-            {
-                throw new FSCoderException(
-                    coder.context[FSCoder.TypeInError],
-                    coder.context[FSCoder.StartOfError],
-                    coder.context[FSCoder.ExpectedLength],
-                    coder.context[FSCoder.Delta],
-                    (coder.context[FSCoder.Delta] &gt; 0) ? &quot;ObjectOverflow&quot; : &quot;ObjectUnderflow&quot;);
-            }
-        }
-        coder.writeWord(0, 2);
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject object = (FSMovieObject) i.next();
 
-        byte[] data = null;
+			int len = object.getLength();
+			int start = coder.getPointer()
+							+ ((object.getExtendLength() || len &gt;= 63) ? 48
+											: 16);
+			int next = start + (len &lt;&lt; 3);
 
-        try
-        {
-             if (signature.equals(&quot;CWS&quot;))
-                 data = zip(coder.getData(), fileLength);
-             else
-                data = coder.getData();
-        }
-        catch (DataFormatException e)
-        {
-            throw new IOException(&quot;Error compressing Flash file.&quot;);
-        }
-        return data;
-    }
+			object.encode(coder);
+			coder.setPointer(next);
 
-    /**
-     * Returns the encoded representation of the array of objects that this Movie contains.
-     * If an error occurs while encoding the file then a message is sent to the
-     * movie listner.
-     *
-     * @return the array of bytes representing the encoded objects.
-     * @param listener an FSMovieListener object where errors messages are
-     * sent.
-     *
-     * @deprecated use the encode() method which throws an exception if an
-     * error is detected.
-     */
-    public byte[] encode(FSMovieListener listener)
-    {
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, new byte[0]);
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        coder.context[FSCoder.Action]  = FSMovieEvent.Encode;
-        coder.context[FSCoder.Version] = version;
+			if (delta &lt; 0)
+				coder.logError(&quot;ObjectOverflow&quot;, next, -delta);
+			else if (delta &gt; 0)
+				coder.logError(&quot;ObjectUnderflow&quot;, next, delta);
+		}
 
-        int fileLength = length(coder);
+		coder.endObject(&quot;ArrayList&quot;);
+		coder.writeWord(0, 2);
+		coder.endObject(&quot;FSMovie&quot;);
 
-         coder.setData(FSCoder.LITTLE_ENDIAN, new byte[fileLength]);
-         coder.setListener(listener);
+		byte[] data = null;
 
-        coder.beginObject(&quot;FSMovie&quot;);
+		try
+		{
+			if (signature.equals(&quot;CWS&quot;))
+				data = zip(coder.getData(), fileLength);
+			else
+				data = coder.getData();
+		} catch (DataFormatException e)
+		{
+			coder.logError(&quot;DataFormatError&quot;, 0, 0);
+		}
+		return data;
+	}
 
-        coder.writeString(signature, &quot;UTF8&quot;);
-        coder.writeWord(version, 1);
-        coder.writeWord(fileLength, 4);
-        frameSize.encode(coder);
-        coder.writeFixedWord(frameRate, 8, 8);
-        coder.writeWord(numberOfFrames(), 2);
+	/**
+	 * Creates a deep copy of the entire movie.
+	 * 
+	 * @return a copy of the movie.
+	 */
+	public Object clone()
+	{
+		FSMovie anObject = null;
 
-        coder.beginObject(&quot;ArrayList&quot;);
+		try
+		{
+			anObject = (FSMovie) super.clone();
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
+			anObject.frameSize = (frameSize != null) ? (FSBounds) frameSize
+							.clone() : null;
 
-            int len = object.getLength();
-            int start = coder.getPointer() + ((object.getExtendLength() || len &gt;= 63) ? 48 : 16);
-            int next = start + (len &lt;&lt; 3);
+			anObject.objects = new ArrayList();
 
-            object.encode(coder);
-            coder.setPointer(next);
+			for (Iterator i = objects.iterator(); i.hasNext();)
+				anObject.objects.add(((FSMovieObject) i.next()).clone());
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError(&quot;Cannot clone movie.&quot;);
+		}
 
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
+		return anObject;
+	}
 
-            if (delta &lt; 0)
-                coder.logError(&quot;ObjectOverflow&quot;, next, -delta);
-            else if (delta &gt; 0)
-                coder.logError(&quot;ObjectUnderflow&quot;, next, delta);
-        }
+	/**
+	 * Returns true if anObject is equal to this one. The comparison is
+	 * performed on all the objects contained in the movie. Objects are
+	 * considered equal if they would generate identical binary data when they
+	 * are encoded to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        coder.endObject(&quot;ArrayList&quot;);
-        coder.writeWord(0, 2);
-        coder.endObject(&quot;FSMovie&quot;);
+		if (super.equals(anObject))
+		{
+			FSMovie typedObject = (FSMovie) anObject;
 
-        byte[] data = null;
+			result = version == typedObject.version;
 
-        try
-        {
-            if (signature.equals(&quot;CWS&quot;))
-                data = zip(coder.getData(), fileLength);
-            else
-                data = coder.getData();
-        }
-        catch (DataFormatException e)
-        {
-            coder.logError(&quot;DataFormatError&quot;, 0, 0);
-        }
-        return data;
-    }
+			if (frameSize != null)
+				result = result &amp;&amp; frameSize.equals(typedObject.frameSize);
+			else
+				result = result &amp;&amp; frameSize == typedObject.frameSize;
 
-    /** Creates a deep copy of the entire movie.
+			result = result &amp;&amp; frameRate == typedObject.frameRate;
+			result = result
+							&amp;&amp; objects
+											.equals(((FSMovie) anObject)
+															.getObjects());
+		}
+		return result;
+	}
 
-        @return a copy of the movie.
-        */
-    public Object clone()
-    {
-        FSMovie anObject = null;
+	/**
+	 * AppendDescription is used to present a string description of the object
+	 * including all nested objects up to a specified depth. This method provide
+	 * a more controlled way of creating a string representation of an object
+	 * since large objects such as font or shape definitions can contain dozens
+	 * of nested objects.
+	 * 
+	 * The representation of the object is appended to the StringBuffer, showing
+	 * the name of the class and values of the attributes it contains. If the
+	 * object contains any attributes that are objects then the object graph
+	 * will be traversed up to the specified depth. If objects are nested at a
+	 * level less than specified depth then the full string representation of
+	 * the object is displayed. For objects at the specified depth only the name
+	 * of the class is displayed. Any objects below this depth are not
+	 * displayed.
+	 * 
+	 * @param buffer
+	 *            a StringBuffer to which the description of each object is
+	 *            appended.
+	 * @param depth
+	 *            the maximum level of nesting up to which objects will be
+	 *            displayed.
+	 */
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(&quot;FSMovie&quot;);
+		buffer.append(&quot; : { &quot;);
+		Transform.append(buffer, &quot;signature&quot;, signature);
+		Transform.append(buffer, &quot;version&quot;, version);
+		Transform.append(buffer, &quot;frameSize&quot;, frameSize, depth);
+		Transform.append(buffer, &quot;frameRate&quot;, frameRate);
+		Transform.append(buffer, &quot;objects&quot;, objects, depth);
+		buffer.append(&quot;}&quot;);
+	}
 
-        try {
-            anObject = (FSMovie)super.clone();
+	private int length(FSCoder coder)
+	{
+		int len = 14; // Includes End
 
-            anObject.frameSize = (frameSize != null) ? (FSBounds)frameSize.clone() : null;
+		len += frameSize.length(coder);
 
-            anObject.objects = new ArrayList();
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSMovieObject object = (FSMovieObject) i.next();
 
-            for (Iterator i = objects.iterator(); i.hasNext();)
-                anObject.objects.add(((FSMovieObject)i.next()).clone());
-        }
-        catch (CloneNotSupportedException e)
-        {
-            throw new InternalError(&quot;Cannot clone movie.&quot;);
-        }
+			int objectLength = object.length(coder);
 
-        return anObject;
-    }
+			len += (object.getExtendLength() || objectLength &gt;= 63) ? objectLength + 6
+							: objectLength + 2;
+		}
+		return len;
+	}
 
-    /** Returns true if anObject is equal to this one. The comparison is performed on all the objects contained in the movie. Objects are considered equal if they would generate identical binary data when they are encoded to a Flash file.
+	private int numberOfFrames()
+	{
+		int numberOfFrames = 0;
 
-        @return true if this object would be identical to anObject when encoded.
-        */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			if (((FSMovieObject) i.next()).getType() == FSMovieObject.ShowFrame)
+				numberOfFrames += 1;
+		}
+		return numberOfFrames;
+	}
 
-        if (super.equals(anObject))
-        {
-            FSMovie typedObject = (FSMovie)anObject;
+	private void isFlash(byte[] bytes) throws DataFormatException
+	{
+		if (bytes == null || bytes.length &lt; 8)
+			throw new DataFormatException(&quot;Flash data is null or empty.&quot;);
 
-            result = version == typedObject.version;
+		boolean isFlash = (bytes[0] == 0x43 || bytes[0] == 0x46)
+						&amp;&amp; bytes[1] == 0x57 &amp;&amp; bytes[2] == 0x53;
 
-            if (frameSize != null)
-                result = result &amp;&amp; frameSize.equals(typedObject.frameSize);
-            else
-                result = result &amp;&amp; frameSize == typedObject.frameSize;
+		// if (isFlash &amp;&amp; bytes[3] &gt; Transform.VERSION)
+		// throw new DataFormatException(&quot;Cannot decode files later than version
+		// &quot; + Transform.VERSION + &quot;.&quot;);
 
-            result = result &amp;&amp; frameRate == typedObject.frameRate;
-            result = result &amp;&amp; objects.equals(((FSMovie)anObject).getObjects());
-        }
-        return result;
-    }
+		if (isFlash == false)
+			throw new DataFormatException(
+							&quot;Data does not start with a valid Flash signature.&quot;);
+	}
 
-    /**
-     * AppendDescription is used to present a string description of the object including
-     * all nested objects up to a specified depth. This method provide a more controlled
-     * way of creating a string representation of an object since large objects such as
-     * font or shape definitions can contain dozens of nested objects.
-     *
-     * The representation of the object is appended to the StringBuffer, showing the
-     * name of the class and values of the attributes it contains. If the object contains
-     * any attributes that are objects then the object graph will be traversed up to the
-     * specified depth. If objects are nested at a level less than specified depth then
-     * the full string representation of the object is displayed. For objects at the
-     * specified depth only the name of the class is displayed. Any objects below this
-     * depth are not displayed.
-     *
-     * @param buffer a StringBuffer to which the description of each object is appended.
-     * @param depth the maximum level of nesting up to which objects will be displayed.
-     */
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(&quot;FSMovie&quot;);
-        buffer.append(&quot; : { &quot;);
-        Transform.append(buffer, &quot;signature&quot;, signature);
-        Transform.append(buffer, &quot;version&quot;, version);
-        Transform.append(buffer, &quot;frameSize&quot;, frameSize, depth);
-        Transform.append(buffer, &quot;frameRate&quot;, frameRate);
-        Transform.append(buffer, &quot;objects&quot;, objects, depth);
-        buffer.append(&quot;}&quot;);
-    }
+	private byte[] zip(byte[] bytes, int len) throws DataFormatException
+	{
+		byte[] compressedData = null;
 
-    private int length(FSCoder coder)
-    {
-        int len = 14; // Includes End
+		Deflater deflater = new Deflater();
+		byte[] data = new byte[len];
 
-        len += frameSize.length(coder);
+		deflater.setInput(bytes, 8, len - 8);
+		deflater.finish();
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            FSMovieObject object = (FSMovieObject)i.next();
+		int bytesCompressed = deflater.deflate(data);
 
-            int objectLength = object.length(coder);
+		compressedData = new byte[8 + bytesCompressed];
 
-            len += (object.getExtendLength() || objectLength &gt;= 63) ? objectLength+6 : objectLength+2;
-         }
-        return len;
-    }
+		int i = 0;
+		int j = 0;
 
-    private int numberOfFrames()
-    {
-        int numberOfFrames = 0;
+		for (i = 0; i &lt; 8; i++)
+			compressedData[i] = bytes[i];
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-            if (((FSMovieObject)i.next()).getType() == FSMovieObject.ShowFrame)
-                numberOfFrames += 1;
-        }
-        return numberOfFrames;
-    }
+		for (j = 0; j &lt; bytesCompressed; i++, j++)
+			compressedData[i] = data[j];
 
-    private void isFlash(byte[] bytes) throws DataFormatException
-    {
-        if (bytes == null || bytes.length &lt; 8)
-            throw new DataFormatException(&quot;Flash data is null or empty.&quot;);
+		return compressedData;
+	}
 
-        boolean isFlash = (bytes[0] == 0x43 || bytes[0] == 0x46) &amp;&amp; bytes[1] == 0x57 &amp;&amp; bytes[2] == 0x53;
+	private byte[] unzip(byte[] bytes) throws DataFormatException
+	{
+		int movieLength = 0;
 
-//        if (isFlash &amp;&amp; bytes[3] &gt; Transform.VERSION)
-//            throw new DataFormatException(&quot;Cannot decode files later than version &quot; + Transform.VERSION + &quot;.&quot;);
+		for (int i = 0; i &lt; 4; i++)
+			movieLength += (bytes[i + 4] &amp; 0x000000FF) &lt;&lt; (i * 8);
 
-        if (isFlash == false)
-            throw new DataFormatException(&quot;Data does not start with a valid Flash signature.&quot;);
-    }
+		byte[] data = new byte[movieLength];
 
-    private byte[] zip(byte[] bytes, int len) throws DataFormatException
-    {
-        byte[] compressedData = null;
+		// copy the uncompressed signature, version and length
 
-        Deflater deflater = new Deflater();
-        byte[] data = new byte[len];
+		for (int i = 0; i &lt; 8; i++)
+			data[i] = bytes[i];
 
-        deflater.setInput(bytes, 8, len-8);
-        deflater.finish();
+		Inflater inflater = new Inflater();
+		inflater.setInput(bytes, 8, bytes.length - 8);
+		inflater.inflate(data, 8, movieLength - 8);
 
-        int bytesCompressed = deflater.deflate(data);
-
-        compressedData = new byte[8+bytesCompressed];
-
-        int i = 0;
-        int j = 0;
-
-        for (i=0; i&lt;8; i++)
-            compressedData[i] = bytes[i];
-
-        for (j=0; j&lt;bytesCompressed; i++, j++)
-            compressedData[i] = data[j];
-
-        return compressedData;
-    }
-
-    private byte[] unzip(byte[] bytes) throws DataFormatException
-    {
-        int movieLength = 0;
-
-        for (int i=0; i&lt;4; i++)
-            movieLength += (bytes[i+4] &amp; 0x000000FF) &lt;&lt; (i*8);
-
-        byte[] data = new byte[movieLength];
-
-        // copy the uncompressed signature, version and length
-
-        for (int i=0; i&lt;8; i++)
-            data[i] = bytes[i];
-
-        Inflater inflater = new Inflater();
-        inflater.setInput(bytes, 8, bytes.length-8);
-        inflater.inflate(data, 8, movieLength-8);
-
-        return data;
-    }
+		return data;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSMovieEvent.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovieEvent.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMovieEvent.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -32,144 +32,176 @@
 
 /**
  * @deprecated the FSMovieEvent will no longer be supported in future releases
- * to report decoding and encoding events and to report errors. Instead methods
- * which report errors through exceptions are preferred. If an error occurs then
- * it is due to an error which cannot be easily recovered from therefore the
- * FSMovieEvent will no longer be used.
+ *             to report decoding and encoding events and to report errors.
+ *             Instead methods which report errors through exceptions are
+ *             preferred. If an error occurs then it is due to an error which
+ *             cannot be easily recovered from therefore the FSMovieEvent will
+ *             no longer be used.
  * 
- * The FSMovieEvent class is a container class for the information generated for events 
- * while a movie is being encoded or decoded.
- *
+ * The FSMovieEvent class is a container class for the information generated for
+ * events while a movie is being encoded or decoded.
+ * 
  */
 public class FSMovieEvent
 {
-    /** Identifies an event generated while a movie is being encoded. */
-    public static final int Encode = 0;
-    /** Identifies an event generated while a movie is being decoded. */
-    public static final int Decode = 1;
+	/** Identifies an event generated while a movie is being encoded. */
+	public static final int Encode = 0;
 
-    /** Identifies an event generated when an object in a movie begins to be encoded or decoded. */
-    public static final int Begin = 0;
-    /** Identifies an event generated when an object in a movie completes being encoded or decoded. */
-    public static final int End = 1;
-    /** Identifies an error occurred while a movie is being encoded or decoded. */
-    public static final int Error  = 2;
-    /** Identifies a value read from the binary Flash file as it is being decoded. */
-    public static final int Value = 3;
+	/** Identifies an event generated while a movie is being decoded. */
+	public static final int Decode = 1;
 
-    private int action = 0;
-    private int event = 0;
-    private int location = 0;
-    private int length = 0;
+	/**
+	 * Identifies an event generated when an object in a movie begins to be
+	 * encoded or decoded.
+	 */
+	public static final int Begin = 0;
 
-    private Object value;
+	/**
+	 * Identifies an event generated when an object in a movie completes being
+	 * encoded or decoded.
+	 */
+	public static final int End = 1;
 
-    /**
-     * Constructs an FSMovieEvent object reporting whether the event.
-     * 
-     * @param anAction identifies whether the event was generated while the movie was being encoded
-     * or decoded.
-     * 
-     * @param anEvent identifies the type of event, signalling either the start and end of each object
-     * being decoded, a value decoded while will be assigned to an object attributes or whether an
-     * error occurred.
-     * 
-     * @param aLocation identifies the offset in bits from the start of the movie where the event occurred.
-     * 
-     * @param aLength identifies the number of bits involved when decoding a value. This is set to zero 
-     * for Begin, End and Error events.
-     * 
-     * @param aValue depends on the type of event generated. For Begin and End events, aValue is a String
-     * containing the name of the object being encoded or decoded. For Value events, aValue is an object
-     * wrapping the value being decoded. For Error events, aValue is an error message describing the error
-     * that occurred.
-     */
-    public FSMovieEvent(int anAction, int anEvent, int aLocation, int aLength, Object aValue)
-    {
-        action = anAction;
-        event = anEvent;
-        location = aLocation;
-        length = aLength;
-        value = aValue;
-    }
-    
-    /**
-     * Returns the type of action that generated the event, either Decode when a movie is being decoded
-     * or Encode when a movie is being encoded.
-     * 
-     * @return FSMovieEvent.Decode or FSMovieEvent.Encode according to whether a movie is being decoded 
-     * or encoded.
-     */
-    public int getAction() 
-    { 
-        return action;
-    }
+	/** Identifies an error occurred while a movie is being encoded or decoded. */
+	public static final int Error = 2;
 
-    /**
-     * Identifies the type of event that occurred.
-     * 
-     * FSMovieEvent.Begin occurs when an object in a movie begins the process of being encoded
-     * or decoded.
-     * 
-     * FSMovieEvent.End occurs when an object in a movie completes the process of being encoded
-     * or decoded.
-     * 
-     * FSMovieEvent.Value occurs when an attribute of an object is decoded.
-     * 
-     * FSMovieEvent.Error occurs when an error is detected while encoding or decoding a movie.
-     * 
-     * @return the type of event that occurred.
-     */
-    public int getEvent() 
-    { 
-        return event;
-    }
+	/**
+	 * Identifies a value read from the binary Flash file as it is being
+	 * decoded.
+	 */
+	public static final int Value = 3;
 
-    /**
-     * Identifies the offset in bits from the start of the movie where the event occurred.
-     * 
-     * @return the bit offset where the event occurred.
-     */
-    public int getLocation() 
-    { 
-        return location;
-    }
+	private int action = 0;
 
-    /**
-     * Identifies the number of bits involved when decoding a value. This is set to zero 
-     * for Begin, End and Error events.
-     * 
-     * @return the number of bits read from the file for the decoded value.
-     */
-    public int getLength() 
-    { 
-        return length;
-    }
+	private int event = 0;
 
-    /**
-     * Returns an object containing information on the event. The object depends on the type of event 
-     * generated. For Begin and End events, aValue is a String containing the name of the object being 
-     * encoded or decoded. For Value events, aValue is an object wrapping the value being decoded. For 
-     * Error events, aValue is String containing an error message describing the error that occurred.
-     * 
-     * @return an object containing information associated with the event.
-     */
-    public Object getValue() 
-    { 
-        return value;
-    }
+	private int location = 0;
 
-    /**
-     * Generates a string representation of the event object.
-     * 
-     * @return a string reporting the values in the attributes.
-     */
-    public String toString()
-    {
-        String description = null;
+	private int length = 0;
 
-        description = &quot;FSMovieEvent: { action = &quot; + action + &quot;; event = &quot; + event + &quot;; location = &quot; + location + &quot;; length = &quot; + length + &quot;; value = &quot; + value.toString() + &quot;};&quot;;
+	private Object value;
 
-        return description;
-    }
+	/**
+	 * Constructs an FSMovieEvent object reporting whether the event.
+	 * 
+	 * @param anAction
+	 *            identifies whether the event was generated while the movie was
+	 *            being encoded or decoded.
+	 * 
+	 * @param anEvent
+	 *            identifies the type of event, signalling either the start and
+	 *            end of each object being decoded, a value decoded while will
+	 *            be assigned to an object attributes or whether an error
+	 *            occurred.
+	 * 
+	 * @param aLocation
+	 *            identifies the offset in bits from the start of the movie
+	 *            where the event occurred.
+	 * 
+	 * @param aLength
+	 *            identifies the number of bits involved when decoding a value.
+	 *            This is set to zero for Begin, End and Error events.
+	 * 
+	 * @param aValue
+	 *            depends on the type of event generated. For Begin and End
+	 *            events, aValue is a String containing the name of the object
+	 *            being encoded or decoded. For Value events, aValue is an
+	 *            object wrapping the value being decoded. For Error events,
+	 *            aValue is an error message describing the error that occurred.
+	 */
+	public FSMovieEvent(int anAction, int anEvent, int aLocation, int aLength,
+						Object aValue)
+	{
+		action = anAction;
+		event = anEvent;
+		location = aLocation;
+		length = aLength;
+		value = aValue;
+	}
+
+	/**
+	 * Returns the type of action that generated the event, either Decode when a
+	 * movie is being decoded or Encode when a movie is being encoded.
+	 * 
+	 * @return FSMovieEvent.Decode or FSMovieEvent.Encode according to whether a
+	 *         movie is being decoded or encoded.
+	 */
+	public int getAction()
+	{
+		return action;
+	}
+
+	/**
+	 * Identifies the type of event that occurred.
+	 * 
+	 * FSMovieEvent.Begin occurs when an object in a movie begins the process of
+	 * being encoded or decoded.
+	 * 
+	 * FSMovieEvent.End occurs when an object in a movie completes the process
+	 * of being encoded or decoded.
+	 * 
+	 * FSMovieEvent.Value occurs when an attribute of an object is decoded.
+	 * 
+	 * FSMovieEvent.Error occurs when an error is detected while encoding or
+	 * decoding a movie.
+	 * 
+	 * @return the type of event that occurred.
+	 */
+	public int getEvent()
+	{
+		return event;
+	}
+
+	/**
+	 * Identifies the offset in bits from the start of the movie where the event
+	 * occurred.
+	 * 
+	 * @return the bit offset where the event occurred.
+	 */
+	public int getLocation()
+	{
+		return location;
+	}
+
+	/**
+	 * Identifies the number of bits involved when decoding a value. This is set
+	 * to zero for Begin, End and Error events.
+	 * 
+	 * @return the number of bits read from the file for the decoded value.
+	 */
+	public int getLength()
+	{
+		return length;
+	}
+
+	/**
+	 * Returns an object containing information on the event. The object depends
+	 * on the type of event generated. For Begin and End events, aValue is a
+	 * String containing the name of the object being encoded or decoded. For
+	 * Value events, aValue is an object wrapping the value being decoded. For
+	 * Error events, aValue is String containing an error message describing the
+	 * error that occurred.
+	 * 
+	 * @return an object containing information associated with the event.
+	 */
+	public Object getValue()
+	{
+		return value;
+	}
+
+	/**
+	 * Generates a string representation of the event object.
+	 * 
+	 * @return a string reporting the values in the attributes.
+	 */
+	public String toString()
+	{
+		String description = null;
+
+		description = &quot;FSMovieEvent: { action = &quot; + action + &quot;; event = &quot;
+						+ event + &quot;; location = &quot; + location + &quot;; length = &quot;
+						+ length + &quot;; value = &quot; + value.toString() + &quot;};&quot;;
+
+		return description;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSMovieListener.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovieListener.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMovieListener.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,27 +31,30 @@
 package com.flagstone.transform;
 
 /**
- * @deprecated the FSMovieListener interface will no longer be used future 
- * release to report decoding and encoding events and to report errors. Instead 
- * methods which report errors through exceptions are preferred. If an error 
- * occurs then it is due to a design error or corrupt data in a Flash file which 
- * cannot be easily recovered from therefore the FSMovieListener interface will 
- * no longer be used.
-
- * The FSMovieListener interface defines the methods required to register an object to 
- * receive event information from an FSMovie object as it encodes and decodes Flash 
- * movies.
- *
+ * @deprecated the FSMovieListener interface will no longer be used future
+ *             release to report decoding and encoding events and to report
+ *             errors. Instead methods which report errors through exceptions
+ *             are preferred. If an error occurs then it is due to a design
+ *             error or corrupt data in a Flash file which cannot be easily
+ *             recovered from therefore the FSMovieListener interface will no
+ *             longer be used.
+ * 
+ * The FSMovieListener interface defines the methods required to register an
+ * object to receive event information from an FSMovie object as it encodes and
+ * decodes Flash movies.
+ * 
  */
 public interface FSMovieListener
 {
-    /**
-     * @deprecated
-     * 
-     * The FSMovie object calls this method to send FSMovieEvent object to a registered
-     * listener.
-     * 
-     * @param anEvent an FSMovieEvent object containing the information about an event.
-     */
-    public void logEvent(FSMovieEvent anEvent);
+	/**
+	 * @deprecated
+	 * 
+	 * The FSMovie object calls this method to send FSMovieEvent object to a
+	 * registered listener.
+	 * 
+	 * @param anEvent
+	 *            an FSMovieEvent object containing the information about an
+	 *            event.
+	 */
+	public void logEvent(FSMovieEvent anEvent);
 }

Modified: trunk/src/com/flagstone/transform/FSMovieObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSMovieObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSMovieObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -27,242 +27,297 @@
  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  */
- 
+
 package com.flagstone.transform;
 
-/** 
- * The FSMovieObject is the root class for objects that represent each of the 
+/**
+ * The FSMovieObject is the root class for objects that represent each of the
  * tagged data structures that make up the Flash file format specification.
- *
- * Each of the major data structures defined in the Flash file format specification 
- * start with a header that contains the type identifying the data structure followed 
- * by the number of bytes that the body of the encoded data structure occupies in 
- * the file. The FSMovieObject manages the encoding and decoding of this information.
- *
+ * 
+ * Each of the major data structures defined in the Flash file format
+ * specification start with a header that contains the type identifying the data
+ * structure followed by the number of bytes that the body of the encoded data
+ * structure occupies in the file. The FSMovieObject manages the encoding and
+ * decoding of this information.
+ * 
  * This class is primarily used internally in the library however the getType()
- * method is useful when manipulating decoded Flash files. Rather than using the 
- * runtime type checking provided in the Java environment the method can be used 
- * to identify the class, derived from FSMovieObject, that represents each data 
+ * method is useful when manipulating decoded Flash files. Rather than using the
+ * runtime type checking provided in the Java environment the method can be used
+ * to identify the class, derived from FSMovieObject, that represents each data
  * structure, improving performance.
  */
 
 public abstract class FSMovieObject extends FSTransformObject
 {
-    /** Type used to identify ShowFrame objects. */
-    public static final int ShowFrame            = 1;
-    /** Type used to identify DefineShape objects. */
-    public static final int DefineShape          = 2;
-    /** Type used to identify PlaceObject objects. */
-    public static final int PlaceObject          = 4;
-    /** Type used to identify RemoveObject objects. */
-    public static final int RemoveObject         = 5;
-    /** Type used to identify DefineJPEGImage objects. */
-    public static final int DefineJPEGImage      = 6;
-    /** Type used to identify DefineButton objects. */
-    public static final int DefineButton         = 7;
-    /** Type used to identify JPEGTables objects. */
-    public static final int JPEGTables           = 8;
-    /** Type used to identify SetBackgroundColor objects. */
-    public static final int SetBackgroundColor   = 9;
-    /** Type used to identify DefineFont objects. */
-    public static final int DefineFont           = 10;
-    /** Type used to identify DefineText objects. */
-    public static final int DefineText           = 11;
-    /** Type used to identify DoAction objects. */
-    public static final int DoAction             = 12;
-    /** Type used to identify FontInfo objects. */
-    public static final int FontInfo             = 13;
-    /** Type used to identify DefineSound objects. */
-    public static final int DefineSound          = 14;
-    /** Type used to identify StartSound objects. */
-    public static final int StartSound           = 15;
-    /** Type used to identify SoundStreamHead objects. */
-    public static final int SoundStreamHead      = 18;
-    /** Type used to identify SoundStreamBlock objects. */
-    public static final int SoundStreamBlock     = 19;
-// Flash 2
-    /// Type used to identify ButtonSound objects.
-    public static final int ButtonSound          = 17;
-    /// Type used to identify DefineImage objects.
-    public static final int DefineImage          = 20;
-    /// Type used to identify DefineJPEGImage2 objects.
-    public static final int DefineJPEGImage2     = 21;
-    /// Type used to identify DefineShape2 objects.
-    public static final int DefineShape2         = 22;
-    /// Type used to identify ButtonColorTransform objects.
-    public static final int ButtonColorTransform = 23;
-    /// Type used to identify Protect objects.
-    public static final int Protect              = 24;
-// Flash 3
-    /// Type used to identify Free objects.
-    public static final int Free                 = 3;
-    /// Type used to identify PlaceObject2 objects.
-    public static final int PlaceObject2         = 26;
-    /// Type used to identify RemoveObject2 objects.
-    public static final int RemoveObject2        = 28;
-    /// Type used to identify DefineShape3 objects.
-    public static final int DefineShape3         = 32;
-    /// Type used to identify DefineText2 objects.
-    public static final int DefineText2          = 33;
-    /// Type used to identify DefineButton2 objects.
-    public static final int DefineButton2        = 34;
-    /// Type used to identify DefineJPEGImage3 objects.
-    public static final int DefineJPEGImage3     = 35;
-    /// Type used to identify DefineImage2 objects.
-    public static final int DefineImage2         = 36;
-    /// Type used to identify DefineMovieClip objects.
-    public static final int DefineMovieClip      = 39;
-    /// Type used to identify FrameLabel objects.
-    public static final int FrameLabel           = 43;
-    /// Type used to identify SoundStreamHead2 objects.
-    public static final int SoundStreamHead2     = 45;
-    /// Type used to identify DefineMorphShape objects.
-    public static final int DefineMorphShape     = 46;
-    /// Type used to identify DefineFont2 objects.
-    public static final int DefineFont2          = 48;
-// Flash 4
-    /// Type used to identify PathsArePostscript objects.
-    public static final int PathsArePostscript   = 25;
-    /// Type used to identify DefineTextField objects.
-    public static final int DefineTextField      = 37;
-    /// Type used to identify QuicktimeMovie objects.
-    public static final int QuicktimeMovie       = 38;
-    /// Type used to identify SerialNumber objects.
-    public static final int SerialNumber         = 41;
-    /// Type used to identify DefineBitsPtr objects.
-    public static final int DefineBitsPtr        = 1023;
-// Flash 5
-    /// Type used to identify Export objects.
-    public static final int Export               = 56;
-    /// Type used to identify Import objects.
-    public static final int Import               = 57;
-    /// Type used to identify EnableDebugger objects.
-    public static final int EnableDebugger       = 58;
-// Flash 6
-    /// Type used to identify Initialize objects.
-    public static final int Initialize           = 59;
-    /// Type used to identify DefineVideo objects.
-    public static final int DefineVideo          = 60;
-    /// Type used to identify VideoFrame objects.
-    public static final int VideoFrame           = 61;
-    /// Type used to identify FontInfo2 objects.
-    public static final int FontInfo2            = 62;
-    /// Type used to identify EnableDebugger2 objects.
-    public static final int EnableDebugger2      = 64;
-// Flash 7
-    /// Type used to identify LimitScript objects.
-    public static final int LimitScript          = 65;
-    /// Type used to identify TabOrder objects.
-    public static final int TabOrder             = 66;
+	/** Type used to identify ShowFrame objects. */
+	public static final int ShowFrame = 1;
 
-    protected int type = 0;
-    protected int length = 0;
-    protected boolean extendLength = false;
+	/** Type used to identify DefineShape objects. */
+	public static final int DefineShape = 2;
 
-    /**
-     * Constructs a movie object with the specified type.
-     * 
-     * @param aType an identifier indicating the type of movie object.
-     */
-    protected FSMovieObject(int aType)
-    {
-        type = aType;
-    }
-    /**
-     * Constructs a movie object by copying an existing one.
-     * 
-     * @param obj an FSMovieObject object. 
-     */
-    protected FSMovieObject(FSMovieObject obj)
-    {
-        type = obj.type;
-        length = obj.length;
-        extendLength = obj.extendLength;
-    }
-    /** 
-     * Gets the code used that identifies the type of the object when it is 
-     * encoded. 
-      *
-     * @return the code used to denote the type of the object.
-     */
-    public int getType() 
-    {
-        return type;
-    }
-    
-    int getLength()
-    {
-        return length;
-    }
-    
-    boolean getExtendLength()
-    {
-        return extendLength;
-    }
-    
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false; 
-        
-        if (super.equals(anObject))
-        {
-            result = type == ((FSMovieObject)anObject).getType();
-        }
-        return result;
-    }
+	/** Type used to identify PlaceObject objects. */
+	public static final int PlaceObject = 4;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
+	/** Type used to identify RemoveObject objects. */
+	public static final int RemoveObject = 5;
 
-    public int length(FSCoder coder)
-    {
-        coder.context[FSCoder.Type] = type;
-        
-        length = 0;
-        
-        return length;
-    }
+	/** Type used to identify DefineJPEGImage objects. */
+	public static final int DefineJPEGImage = 6;
 
-    public void encode(FSCoder coder)
-    {
-        coder.beginObject(name());
+	/** Type used to identify DefineButton objects. */
+	public static final int DefineButton = 7;
 
-        coder.context[FSCoder.Type] = type;
-        
-        if (extendLength == false &amp;&amp; length &lt; 63)
-        {
-            coder.writeWord((type &lt;&lt; 6) | length, 2);            
-        }
-        else
-        {
-            coder.writeWord((type &lt;&lt; 6) | 0x3F, 2);            
-            coder.writeWord(length, 4);            
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        coder.beginObject(name());
+	/** Type used to identify JPEGTables objects. */
+	public static final int JPEGTables = 8;
 
-        type = coder.scanWord(2, false) &gt;&gt; 6;
-        length = coder.scanWord(2, false) &amp; 0x3F;
-        
-        coder.context[FSCoder.Type] = type;
-        coder.setPointer(coder.getPointer()+16);
-        
-        if (length == 0x3F)
-        {
-            length = coder.readWord(4, false);
-            extendLength = true;
-        }
-    }
+	/** Type used to identify SetBackgroundColor objects. */
+	public static final int SetBackgroundColor = 9;
+
+	/** Type used to identify DefineFont objects. */
+	public static final int DefineFont = 10;
+
+	/** Type used to identify DefineText objects. */
+	public static final int DefineText = 11;
+
+	/** Type used to identify DoAction objects. */
+	public static final int DoAction = 12;
+
+	/** Type used to identify FontInfo objects. */
+	public static final int FontInfo = 13;
+
+	/** Type used to identify DefineSound objects. */
+	public static final int DefineSound = 14;
+
+	/** Type used to identify StartSound objects. */
+	public static final int StartSound = 15;
+
+	/** Type used to identify SoundStreamHead objects. */
+	public static final int SoundStreamHead = 18;
+
+	/** Type used to identify SoundStreamBlock objects. */
+	public static final int SoundStreamBlock = 19;
+
+	// Flash 2
+	// / Type used to identify ButtonSound objects.
+	public static final int ButtonSound = 17;
+
+	// / Type used to identify DefineImage objects.
+	public static final int DefineImage = 20;
+
+	// / Type used to identify DefineJPEGImage2 objects.
+	public static final int DefineJPEGImage2 = 21;
+
+	// / Type used to identify DefineShape2 objects.
+	public static final int DefineShape2 = 22;
+
+	// / Type used to identify ButtonColorTransform objects.
+	public static final int ButtonColorTransform = 23;
+
+	// / Type used to identify Protect objects.
+	public static final int Protect = 24;
+
+	// Flash 3
+	// / Type used to identify Free objects.
+	public static final int Free = 3;
+
+	// / Type used to identify PlaceObject2 objects.
+	public static final int PlaceObject2 = 26;
+
+	// / Type used to identify RemoveObject2 objects.
+	public static final int RemoveObject2 = 28;
+
+	// / Type used to identify DefineShape3 objects.
+	public static final int DefineShape3 = 32;
+
+	// / Type used to identify DefineText2 objects.
+	public static final int DefineText2 = 33;
+
+	// / Type used to identify DefineButton2 objects.
+	public static final int DefineButton2 = 34;
+
+	// / Type used to identify DefineJPEGImage3 objects.
+	public static final int DefineJPEGImage3 = 35;
+
+	// / Type used to identify DefineImage2 objects.
+	public static final int DefineImage2 = 36;
+
+	// / Type used to identify DefineMovieClip objects.
+	public static final int DefineMovieClip = 39;
+
+	// / Type used to identify FrameLabel objects.
+	public static final int FrameLabel = 43;
+
+	// / Type used to identify SoundStreamHead2 objects.
+	public static final int SoundStreamHead2 = 45;
+
+	// / Type used to identify DefineMorphShape objects.
+	public static final int DefineMorphShape = 46;
+
+	// / Type used to identify DefineFont2 objects.
+	public static final int DefineFont2 = 48;
+
+	// Flash 4
+	// / Type used to identify PathsArePostscript objects.
+	public static final int PathsArePostscript = 25;
+
+	// / Type used to identify DefineTextField objects.
+	public static final int DefineTextField = 37;
+
+	// / Type used to identify QuicktimeMovie objects.
+	public static final int QuicktimeMovie = 38;
+
+	// / Type used to identify SerialNumber objects.
+	public static final int SerialNumber = 41;
+
+	// / Type used to identify DefineBitsPtr objects.
+	public static final int DefineBitsPtr = 1023;
+
+	// Flash 5
+	// / Type used to identify Export objects.
+	public static final int Export = 56;
+
+	// / Type used to identify Import objects.
+	public static final int Import = 57;
+
+	// / Type used to identify EnableDebugger objects.
+	public static final int EnableDebugger = 58;
+
+	// Flash 6
+	// / Type used to identify Initialize objects.
+	public static final int Initialize = 59;
+
+	// / Type used to identify DefineVideo objects.
+	public static final int DefineVideo = 60;
+
+	// / Type used to identify VideoFrame objects.
+	public static final int VideoFrame = 61;
+
+	// / Type used to identify FontInfo2 objects.
+	public static final int FontInfo2 = 62;
+
+	// / Type used to identify EnableDebugger2 objects.
+	public static final int EnableDebugger2 = 64;
+
+	// Flash 7
+	// / Type used to identify LimitScript objects.
+	public static final int LimitScript = 65;
+
+	// / Type used to identify TabOrder objects.
+	public static final int TabOrder = 66;
+
+	protected int type = 0;
+
+	protected int length = 0;
+
+	protected boolean extendLength = false;
+
+	/**
+	 * Constructs a movie object with the specified type.
+	 * 
+	 * @param aType
+	 *            an identifier indicating the type of movie object.
+	 */
+	protected FSMovieObject(int aType)
+	{
+		type = aType;
+	}
+
+	/**
+	 * Constructs a movie object by copying an existing one.
+	 * 
+	 * @param obj
+	 *            an FSMovieObject object.
+	 */
+	protected FSMovieObject(FSMovieObject obj)
+	{
+		type = obj.type;
+		length = obj.length;
+		extendLength = obj.extendLength;
+	}
+
+	/**
+	 * Gets the code used that identifies the type of the object when it is
+	 * encoded.
+	 * 
+	 * @return the code used to denote the type of the object.
+	 */
+	public int getType()
+	{
+		return type;
+	}
+
+	int getLength()
+	{
+		return length;
+	}
+
+	boolean getExtendLength()
+	{
+		return extendLength;
+	}
+
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
+
+		if (super.equals(anObject))
+		{
+			result = type == ((FSMovieObject) anObject).getType();
+		}
+		return result;
+	}
+
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
+
+	public int length(FSCoder coder)
+	{
+		coder.context[FSCoder.Type] = type;
+
+		length = 0;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
+
+		coder.context[FSCoder.Type] = type;
+
+		if (extendLength == false &amp;&amp; length &lt; 63)
+		{
+			coder.writeWord((type &lt;&lt; 6) | length, 2);
+		} else
+		{
+			coder.writeWord((type &lt;&lt; 6) | 0x3F, 2);
+			coder.writeWord(length, 4);
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		coder.beginObject(name());
+
+		type = coder.scanWord(2, false) &gt;&gt; 6;
+		length = coder.scanWord(2, false) &amp; 0x3F;
+
+		coder.context[FSCoder.Type] = type;
+		coder.setPointer(coder.getPointer() + 16);
+
+		if (length == 0x3F)
+		{
+			length = coder.readWord(4, false);
+			extendLength = true;
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSNewFunction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSNewFunction.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,430 +33,500 @@
 import java.util.*;
 
 /**
-The FSNewFunction action is used to create a user-defined function.
+ * The FSNewFunction action is used to create a user-defined function.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. The type attribute is
+ * read-only and may be used when iterating through an array of FSActionObjects
+ * to identify the object class without using run-time type checking.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;A string defining the name of the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;arguments&lt;/td&gt;
+ * &lt;td&gt;An array containing the names of the arguments. The order of the strings
+ * in the argument array indicate the order in which the values will be popped
+ * off the stack when the function is executed. The fist argument is popped from
+ * the stack first.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * User-defined functions are also used to create methods for user-defined
+ * objects. The name of the function is omitted and the function definition is
+ * assigned to a variable which allows it to be referenced at a alter time. See
+ * the example below:
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The arguments supplied to the function can be referenced by the name supplied
+ * in the arguments array.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * All the action objects added are owned by the function. They will be deleted
+ * when the function definition is deleted.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Define a function&lt;br/&gt; Define a function that increments the value passed
+ * to it:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // List the names of the arguments
+ * 
+ * ArrayList arguments = new ArrayList();
+ * 
+ * arguments.add(&quot;value&quot;);
+ * 
+ * // Now define the actions performed by the function. Values passed to the function
+ * // can be referenced by the name defined in the array of arguments.
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(new FSPush(&quot;value&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(1));
+ * actions.add(FSAction.Add());
+ * actions.add(FSAction.Return());
+ * actions.add(new FSNewFunction(&quot;increment&quot;, arguments, actions));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be referenced using it's name:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(1));
+ * actions.add(new FSPush(&quot;increment&quot;));
+ * actions.add(FSAction.ExecuteFunction());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Defining a method.&lt;br/&gt; When creating a user-defined object the name of
+ * the function can be omitted. Simply assign the function definition to a
+ * variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  actions.add(new FSPush(methodVariable));
+ * 
+ *  FSVector&lt;FSString&gt; arguments;
+ * 
+ *  arguments.push_back(&quot;value&quot;);
+ * 
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;value&quot;));
+ *  actions.add(FSAction.GetVariable());
+ *  actions.add(new FSPush(1));
+ *  actions.add(FSAction.Add());
+ *  actions.add(FSAction.Return());
+ *  actions.add(new FSNewFunction(arguments, actions));
+ *  actions.add(FSAction.SetVariable()));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be executed by pushing the arguments onto the stack
+ * then calling the function assigned to the variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push argument(s) onto stack
+ * 
+ * actions.add(new FSPush(1));
+ * 
+ * // Get the variable that contains the function
+ * 
+ * actions.add(new FSPush(methodVariable));
+ * actions.add(FSAction.GetVariable());
+ * 
+ * // Execute the function
+ * actions.add(FSAction.ExecuteFunction());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSNewFunction class represents the ActionDefineFunction action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5.
+ * &lt;/p&gt;
+ */
+public class FSNewFunction extends FSActionObject
+{
+	private String name = null;
+	private ArrayList arguments = null;
+	private ArrayList actions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	private int actionsLength = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	FSNewFunction()
+	{
+		super(NewFunction);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. The type attribute is read-only and may be used when iterating through an array of FSActionObjects to identify the object class without using run-time type checking.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSNewFunction object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSNewFunction(FSCoder coder)
+	{
+		super(NewFunction);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_1&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A string defining the name of the function.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSNewFunction with the specified name, argument names and
+	 * actions to be executed. The order of the Strings in the argument array
+	 * indicate the order in which the values will be popped off the stack when
+	 * the function is executed. The fist argument is popped from the stack
+	 * first.
+	 * 
+	 * @param aString
+	 *            the name of the function.
+	 * @param argumentArray
+	 *            an array of Strings listing the names of the arguments.
+	 * @param actionArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction(String aString, ArrayList argumentArray,
+							ArrayList actionArray)
+	{
+		super(NewFunction);
+		setName(aString);
+		setArguments(argumentArray);
+		setActions(actionArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_2&quot;&gt;arguments&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array containing the names of the arguments. The order of the strings in the argument array indicate the order in which the values will be popped off the stack when the function is executed. The fist argument is popped from the stack first.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an anonymous FSNewFunction with the specified argument names
+	 * and actions to be executed. Use this constructor when defining functions
+	 * that will be assigned to object variables and used as methods.
+	 * 
+	 * @param argumentArray
+	 *            an array of Strings listing the names of the arguments.
+	 * @param actionArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction(ArrayList argumentArray, ArrayList actionArray)
+	{
+		super(NewFunction);
+		setArguments(argumentArray);
+		setActions(actionArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction_3&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSNewFunction object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSNewFunction object.
+	 */
+	public FSNewFunction(FSNewFunction obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		if (obj.name != null)
+			name = new String(obj.name);
 
-&lt;p&gt;User-defined functions are also used to create methods for user-defined objects. The name of the function is omitted and the function definition is assigned to a variable which allows it to be referenced at a alter time. See the example below:&lt;/p&gt;
+		if (obj.arguments != null)
+		{
+			arguments = new ArrayList(obj.arguments.size());
 
-&lt;p&gt;The arguments supplied to the function can be referenced by the name supplied in the arguments array.&lt;/p&gt;
+			for (Iterator i = obj.arguments.iterator(); i.hasNext();)
+				arguments.add(new String(i.next().toString()));
+		}
 
-&lt;p&gt;All the action objects added are owned by the function. They will be deleted when the function definition is deleted.&lt;/p&gt;
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		}
+	}
 
-&lt;p&gt;1. Define a function&lt;br/&gt;
-Define a function that increments the value passed to it:&lt;/p&gt;
+	/**
+	 * Adds the name of an argument to the array of argument names.
+	 * 
+	 * @param anArgument
+	 *            the name of an argument passed to the FSNewFunction object.
+	 */
+	public void add(String anArgument)
+	{
+		arguments.add(anArgument);
+	}
 
-&lt;pre&gt;
-// List the names of the arguments
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		actions.add(anAction);
+	}
 
-ArrayList arguments = new ArrayList();
+	/**
+	 * Gets the name of the function.
+	 * 
+	 * @return the name of the function.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-arguments.add(&quot;value&quot;);
+	/**
+	 * Gets the names of the function arguments.
+	 * 
+	 * @return the array of argument names.
+	 */
+	public ArrayList getArguments()
+	{
+		return arguments;
+	}
 
-// Now define the actions performed by the function. Values passed to the function
-// can be referenced by the name defined in the array of arguments.
+	/**
+	 * Gets the actions.
+	 * 
+	 * @return the array of actions executed.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Sets the name of the function.
+	 * 
+	 * @param aString
+	 *            the name of the function.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction(&quot;increment&quot;, arguments, actions));
-&lt;/pre&gt;
+	/**
+	 * Sets the names of the function arguments.
+	 * 
+	 * @param anArray
+	 *            an array of Strings listing the names of the arguments.
+	 */
+	public void setArguments(ArrayList anArray)
+	{
+		arguments = anArray;
+	}
 
-&lt;p&gt;The function can then be referenced using it's name:&lt;/p&gt;
+	/**
+	 * Sets the actions.
+	 * 
+	 * @param anArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(1));
-actions.add(new FSPush(&quot;increment&quot;));
-actions.add(FSAction.ExecuteFunction());
-&lt;/pre&gt;
+	public Object clone()
+	{
+		FSNewFunction anObject = (FSNewFunction) super.clone();
 
-&lt;p&gt;2. Defining a method.&lt;br/&gt;
-When creating a user-defined object the name of the function can be omitted. Simply assign the function definition to a variable:&lt;/p&gt;
+		anObject.arguments = new ArrayList();
 
-&lt;pre&gt;
-actions.add(new FSPush(methodVariable));
+		for (Iterator i = arguments.iterator(); i.hasNext();)
+			anObject.arguments.add(new String((String) i.next()));
 
-FSVector&lt;FSString&gt; arguments;
+		anObject.actions = new ArrayList();
 
-arguments.push_back(&quot;value&quot;);
+		for (Iterator i = actions.iterator(); i.hasNext();)
+			anObject.actions.add(((FSActionObject) i.next()).clone());
 
-ArrayList actions = new ArrayList();
+		return anObject;
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction(arguments, actions));
-actions.add(FSAction.SetVariable()));
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The function can then be executed by pushing the arguments onto the stack then calling the function assigned to the variable:&lt;/p&gt;
+		if (super.equals(anObject))
+		{
+			FSNewFunction typedObject = (FSNewFunction) anObject;
 
-&lt;pre&gt;
-// Push argument(s) onto stack
+			if (name != null)
+				result = name.equals(typedObject.name);
+			else
+				result = name == typedObject.name;
 
-actions.add(new FSPush(1));
+			if (arguments != null)
+				result = result &amp;&amp; arguments.equals(typedObject.arguments);
+			else
+				result = result &amp;&amp; arguments == typedObject.arguments;
 
-// Get the variable that contains the function
+			if (actions != null)
+				result = result &amp;&amp; actions.equals(typedObject.actions);
+			else
+				result = result &amp;&amp; actions == typedObject.actions;
+		}
+		return result;
+	}
 
-actions.add(new FSPush(methodVariable));
-actions.add(FSAction.GetVariable());
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-// Execute the function
-actions.add(FSAction.ExecuteFunction());
-&lt;/pre&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;name&quot;, name);
+			Transform.append(buffer, &quot;arguments&quot;, arguments, depth);
+			Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;p&gt;The FSNewFunction class represents the ActionDefineFunction action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
- */  
-public class FSNewFunction extends FSActionObject
-{
-    private String name = null;
-    private ArrayList arguments = null;
-    private ArrayList actions = null;
+		length += (name != null) ? coder.strlen(name, true) : 1;
+		length += 2;
 
-    private int actionsLength = 0;
-    
-    FSNewFunction()
-    {
-        super(NewFunction);
-    }
-    /**
-     * Construct an FSNewFunction object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSNewFunction(FSCoder coder)
-    {
-        super(NewFunction);
-        decode(coder);
-    }
-    /** Constructs an FSNewFunction with the specified name, argument names and actions to be executed. The order of the Strings in the argument array indicate the order in which the values will be popped off the stack when the function is executed. The fist argument is popped from the stack first.
+		if (arguments.size() &gt; 0)
+		{
+			for (int i = 0; i &lt; arguments.size(); i++)
+				length += coder.strlen((String) arguments.get(i), true);
+		}
 
-        @param aString the name of the function.
-        @param argumentArray an array of Strings listing the names of the arguments.
-        @param actionArray the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction(String aString, ArrayList argumentArray, ArrayList actionArray)
-    {
-        super(NewFunction);
-        setName(aString);
-        setArguments(argumentArray);
-        setActions(actionArray);
-    }
-    /** Constructs an anonymous FSNewFunction with the specified argument names and actions to be executed. Use this constructor when defining functions that will be assigned to object variables and used as methods.
+		length += 2;
 
-        @param argumentArray an array of Strings listing the names of the arguments.
-        @param actionArray the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction(ArrayList argumentArray, ArrayList actionArray)
-    {
-        super(NewFunction);
-        setArguments(argumentArray);
-        setActions(actionArray);
-    }
-    /**
-     * Constructs an FSNewFunction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSNewFunction object.
-     */
-    public FSNewFunction(FSNewFunction obj)
-    {
-        super(obj);
+		actionsLength = 0;
 
-        if (obj.name != null)
-            name = new String(obj.name);
-        
-        if (obj.arguments != null)
-        {
-            arguments = new ArrayList(obj.arguments.size());
-            
-            for (Iterator i = obj.arguments.iterator(); i.hasNext();)
-                arguments.add(new String(i.next().toString()));
-        }
+		for (int i = 0; i &lt; actions.size(); i++)
+		{
+			FSActionObject currentAction = (FSActionObject) actions.get(i);
 
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-    }    
-    
-    /** Adds the name of an argument to the array of argument names.
+			actionsLength += currentAction.length(coder);
+			actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
+		length += actionsLength;
 
-        @param anArgument the name of an argument passed to the FSNewFunction object.
-        */
-    public void add(String anArgument)
-    {
-        arguments.add(anArgument); 
-    }
+		return length;
+	}
 
-    /** Adds the action object to the array of actions.
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        actions.add(anAction);
-    }
+		coder.writeWord(type, 1);
+		coder.writeWord(length - actionsLength, 2);
 
-    /** Gets the name of the function.
+		if (name != null)
+			coder.writeString(name);
 
-        @return the name of the function.
-        */
-    public String getName() 
-    {
-        return name;
-    }
+		coder.writeWord(0, 1);
 
-    /** Gets the names of the function arguments.
+		coder.writeWord(arguments.size(), 2);
 
-        @return the array of argument names.
-        */
-    public ArrayList getArguments() 
-    {
-        return arguments;
-    }
+		if (arguments.size() &gt; 0)
+		{
+			for (int i = 0; i &lt; arguments.size(); i++)
+			{
+				coder.writeString((String) arguments.get(i));
+				coder.writeWord(0, 1);
+			}
+		}
 
-    /** Gets the actions.
+		coder.writeWord(actionsLength, 2);
 
-        @return the array of actions executed.
-        */
-    public ArrayList getActions() 
-    {
-        return actions;
-    }
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
 
-    /** Sets the name of the function.
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
 
-        @param aString the name of the function.
-        */
-    public void setName(String aString) 
-    {
-        name = aString;
-    }
+			action.encode(coder);
+			coder.setPointer(next);
 
-    /** Sets the names of the function arguments. 
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        @param anArray an array of Strings listing the names of the arguments.
-        */
-    public void setArguments(ArrayList anArray) 
-    {
-        arguments = anArray;
-    }
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
+		coder.endObject(name());
+	}
 
-    /** Sets the actions.
+	public void decode(FSCoder coder)
+	{
+		int argumentCount = 0;
+		int bytesRead = 0;
 
-        @param anArray the array of actions that define the operation performed by the function.
-        */
-    public void setActions(ArrayList anArray) 
-    {
-        actions = anArray;
-    }
+		arguments = new ArrayList();
+		actions = new ArrayList();
 
-    public Object clone()
-    {
-        FSNewFunction anObject = (FSNewFunction)super.clone();
-        
-         anObject.arguments = new ArrayList();
-            
-        for (Iterator i = arguments.iterator(); i.hasNext();)
-            anObject.arguments.add(new String((String)i.next()));
+		super.decode(coder);
 
-        anObject.actions = new ArrayList();
-            
-        for (Iterator i = actions.iterator(); i.hasNext();)
-            anObject.actions.add(((FSActionObject)i.next()).clone());
+		name = coder.readString();
 
-        return anObject;
-    }
+		argumentCount = coder.readWord(2, false);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSNewFunction typedObject = (FSNewFunction)anObject;
-            
-            if (name != null)
-                result = name.equals(typedObject.name);
-            else
-                result = name == typedObject.name;
+		if (argumentCount &gt; 0)
+		{
+			for (int i = argumentCount; i &gt; 0; i--)
+				arguments.add(coder.readString());
+		}
 
-            if (arguments != null)
-                result = result &amp;&amp; arguments.equals(typedObject.arguments);
-            else
-                result = result &amp;&amp; arguments == typedObject.arguments;
+		actionsLength = coder.readWord(2, false);
+		length += actionsLength;
 
-            if (actions != null)
-                result = result &amp;&amp; actions.equals(typedObject.actions);
-            else
-                result = result &amp;&amp; actions == typedObject.actions;
-        }
-        return result;
-    }
+		while (bytesRead &lt; actionsLength)
+		{
+			FSActionObject anAction = FSMovie.decodeAction(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;name&quot;, name);        
-            Transform.append(buffer, &quot;arguments&quot;, arguments, depth);
-            Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+			bytesRead += anAction.getLength()
+							+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+			actions.add(anAction);
+		}
 
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += (name != null) ? coder.strlen(name, true) : 1;
-        length += 2;
-        
-        if (arguments.size() &gt; 0)
-        {
-            for (int i=0; i&lt;arguments.size(); i++)
-                length += coder.strlen((String)arguments.get(i), true);
-        }
-
-        length += 2;
-        
-        actionsLength = 0;
-
-        for (int i=0; i&lt;actions.size(); i++)
-        {
-            FSActionObject currentAction = (FSActionObject)actions.get(i);
-            
-            actionsLength += currentAction.length(coder);
-            actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        length += actionsLength;
-        
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.beginObject(name());
-
-        coder.writeWord(type, 1);
-        coder.writeWord(length - actionsLength, 2);
-
-        if (name != null)
-            coder.writeString(name);
-
-        coder.writeWord(0, 1);
-
-        coder.writeWord(arguments.size(), 2);
-
-        if (arguments.size() &gt; 0)
-        {
-            for (int i=0; i&lt;arguments.size(); i++)
-            {
-                coder.writeString((String)arguments.get(i));
-                coder.writeWord(0, 1);
-            }
-        }
-        
-        coder.writeWord(actionsLength, 2);
-        
-        for (Iterator i=actions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-                
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int argumentCount = 0;
-        int bytesRead = 0;
-        
-        arguments = new ArrayList();
-        actions = new ArrayList();
-
-        super.decode(coder);
-
-        name = coder.readString();
-        
-        argumentCount = coder.readWord(2, false);
-        
-        if (argumentCount &gt; 0)
-        {
-            for (int i=argumentCount; i&gt;0; i--)
-                arguments.add(coder.readString());
-        }
-            
-        actionsLength = coder.readWord(2, false);
-        length += actionsLength;
-                
-        while (bytesRead &lt; actionsLength)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-            actions.add(anAction);
-        }
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSNewFunction2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNewFunction2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSNewFunction2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,568 +33,666 @@
 import java.util.*;
 
 /**
-The FSNewFunction2 action is used to create a user-defined function. 
+ * The FSNewFunction2 action is used to create a user-defined function.
+ * 
+ * &lt;p&gt;
+ * It was added in Flash 7 to improve the performance of function calls by
+ * allowing variables to be pre-loaded to a set of up to 256 internal registers
+ * and controlling the loading of pre-defined variables such as &lt;em&gt;_root&lt;/em&gt;,
+ * &lt;em&gt;_parent&lt;/em&gt;, &lt;em&gt;_global&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt;, &lt;em&gt;this&lt;/em&gt;
+ * and the &lt;em&gt;arguments&lt;/em&gt; array containing the arguments passed to the
+ * function.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;A string defining the name of the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;registerCount&lt;/td&gt;
+ * &lt;td&gt;The number of registers, up to 256, to allocate for storing variables.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;optimizations&lt;/td&gt;
+ * &lt;td&gt;A code consisting of a number of flags that control the execution
+ * environment for the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;arguments&lt;/td&gt;
+ * &lt;td&gt;An array of FSRegisterVariable objects containing the names of the
+ * arguments and whether they will be assigned to internal registers or defined
+ * in memory as local variables. The order of the FSRegisterVariable objects in
+ * the argument array indicate the order in which the values will be popped off
+ * the stack when the function is executed. The fist argument is popped from the
+ * stack first.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The optimisation attribute is a compound code, containing a number of flags
+ * that control how the environment of the function is initialised. Controlling
+ * the pre-defined variables that are created and pre-loading them into
+ * registers can significantly improve performance.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;CreateSuper&lt;/td&gt;
+ * &lt;td&gt;Create and initialise the &lt;em&gt;super&lt;/em&gt; variable with the parent
+ * class of the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;CreateArguments&lt;/td&gt;
+ * &lt;td&gt;Create the &lt;em&gt;arguments&lt;/em&gt; variable which contains the arguments
+ * passed to the function.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;CreateThis&lt;/td&gt;
+ * &lt;td&gt;Create the and initialise the &lt;em&gt;this&lt;/em&gt; variable with the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadThis&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;this&lt;/em&gt; variable into register number 1.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadArguments&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;parent&lt;/em&gt; variable into register number 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadSuper&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;super&lt;/em&gt; variable into register number 3.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadRoot&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;_root&lt;/em&gt; variable into register number 4.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadParent&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;_parent&lt;/em&gt; variable into register number 5.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;LoadGlobal&lt;/td&gt;
+ * &lt;td&gt;Pre-load the &lt;em&gt;_global&lt;/em&gt; variable into register number 5.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The register numbers that the predefined variables, &lt;em&gt;this&lt;/em&gt;,
+ * &lt;em&gt;parent&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt;, &lt;em&gt;_root&lt;/em&gt;, &lt;em&gt;_parent&lt;/em&gt;
+ * and &lt;em&gt;_global&lt;/em&gt; are assigned to are fixed. When specifying which of
+ * the functions arguments are also assigned to registers it is important avoid
+ * these locations otherwise the variables will be overwritten.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * User-defined functions are also used to create methods for user-defined
+ * objects. The name of the function is omitted and the function definition is
+ * assigned to a variable which allows it to be referenced at a alter time. See
+ * the example below.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The arguments supplied to the function can be referenced by the name supplied
+ * in the arguments array.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * All the action objects added are owned by the function. They will be deleted
+ * when the function definition is deleted.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Define a function&lt;br/&gt; Define a function that increments the value passed
+ * to it:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // List the names of the arguments
+ * 
+ * ArrayList arguments = new ArrayList();
+ * 
+ * arguments.add(&quot;value&quot;);
+ * 
+ * // Now define the actions performed by the function. Values passed to the function
+ * // can be referenced by the name defined in the array of arguments.
+ * 
+ * ArrayList actions = new ArrayList();
+ * 
+ * actions.add(new FSPush(&quot;value&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(1));
+ * actions.add(FSAction.Add());
+ * actions.add(FSAction.Return());
+ * actions.add(new FSNewFunction2(&quot;increment&quot;, arguments, actions));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be referenced using it's name:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(1));
+ * actions.add(new FSPush(&quot;increment&quot;));
+ * actions.add(FSAction.ExecuteFunction());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Defining a method.&lt;br/&gt; When creating a user-defined object the name of
+ * the function can be omitted. Simply assign the function definition to a
+ * variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  actions.add(new FSPush(methodVariable));
+ * 
+ *  FSVector&lt;FSString&gt; arguments;
+ * 
+ *  arguments.push_back(&quot;value&quot;);
+ * 
+ *  ArrayList actions = new ArrayList();
+ * 
+ *  actions.add(new FSPush(&quot;value&quot;));
+ *  actions.add(FSAction.GetVariable());
+ *  actions.add(new FSPush(1));
+ *  actions.add(FSAction.Add());
+ *  actions.add(FSAction.Return());
+ *  actions.add(new FSNewFunction2(arguments, actions));
+ *  actions.add(FSAction.SetVariable()));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The function can then be executed by pushing the arguments onto the stack
+ * then calling the function assigned to the variable:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Push argument(s) onto stack
+ * 
+ * actions.add(new FSPush(1));
+ * 
+ * // Get the variable that contains the function
+ * 
+ * actions.add(new FSPush(methodVariable));
+ * actions.add(FSAction.GetVariable());
+ * 
+ * // Execute the function
+ * actions.add(FSAction.ExecuteMethod());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Controlling the execution environment.&lt;br/&gt; The code that defines the
+ * optimizations that improve execution performance is created by bitwise-ORing
+ * the individual flags together.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * int optimizations = FSNewFunction2.CreateSuper | FSNewFunction2.PreloadSuper;
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSNewFunction class represents the ActionDefineFunction2 action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 7.
+ * &lt;/p&gt;
+ */
+public class FSNewFunction2 extends FSActionObject
+{
+	/** Create and initialized the predefined variable, &lt;em&gt;super&lt;/em&gt;. */
+	public static final int CreateSuper = 4;
 
-&lt;p&gt;It was added in Flash 7 to improve the performance of function calls by allowing 
-variables to be pre-loaded to a set of up to 256 internal registers and controlling 
-the loading of pre-defined variables such as &lt;em&gt;_root&lt;/em&gt;, &lt;em&gt;_parent&lt;/em&gt;, 
-&lt;em&gt;_global&lt;/em&gt;, &lt;em&gt;super&lt;/em&gt;, &lt;em&gt;this&lt;/em&gt; and the &lt;em&gt;arguments&lt;/em&gt; array 
-containing the arguments passed to the function.&lt;/p&gt;
+	/** Create and initialized the predefined variable, &lt;em&gt;arguments&lt;/em&gt;. */
+	public static final int CreateArguments = 16;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Create and initialized the predefined variable, &lt;em&gt;this&lt;/em&gt;. */
+	public static final int CreateThis = 64;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;this&lt;/em&gt;, into register 1. */
+	public static final int LoadThis = 128;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_1&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A string defining the name of the function.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;arguments&lt;/em&gt;, into register 2. */
+	public static final int LoadArguments = 32;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_2&quot;&gt;registerCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of registers, up to 256, to allocate for storing variables.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;super&lt;/em&gt;, into register 3. */
+	public static final int LoadSuper = 8;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_3&quot;&gt;optimizations&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A code consisting of a number of flags that control the execution environment 
-for the function.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;_root&lt;/em&gt;, into register 4. */
+	public static final int LoadRoot = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_4&quot;&gt;arguments&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSRegisterVariable objects containing the names of the arguments 
-and whether they will be assigned to internal registers or defined in memory as 
-local variables. The order of the FSRegisterVariable objects in the argument 
-array indicate the order in which the values will be popped off the stack when 
-the function is executed. The fist argument is popped from the stack first.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;_parent&lt;/em&gt;, into register 5. */
+	public static final int LoadParent = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSNewFunction2_5&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array containing the actions that are executed.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Load the predefine variable, &lt;em&gt;_global&lt;/em&gt;, into register 6. */
+	public static final int LoadGlobal = 32768;
 
-&lt;/table&gt;
+	private String name = null;
+	private int registerCount = 0;
+	private int optimizations = 0;
+	private ArrayList arguments = null;
+	private ArrayList actions = null;
 
-&lt;p&gt;The optimisation attribute is a compound code, containing a number of flags that 
-control how the environment of the function is initialised. Controlling the pre-defined 
-variables that are created and pre-loading them into registers can significantly 
-improve performance.&lt;/p&gt;
+	/*
+	 * variables used to record state when encoding.
+	 */
+	private int _actionsLength = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;
-&lt;th align=&quot;left&quot;&gt;Environment&lt;/th&gt;
-&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSNewFunction2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSNewFunction2(FSCoder coder)
+	{
+		super(NewFunction2);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;CreateSuper&lt;/td&gt;&lt;td&gt;Create and initialise the &lt;em&gt;super&lt;/em&gt; variable with the parent class of the function.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;CreateArguments&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Create the &lt;em&gt;arguments&lt;/em&gt; variable which contains the arguments passed to the function.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;CreateThis&lt;/td&gt;&lt;td&gt;Create the and initialise the &lt;em&gt;this&lt;/em&gt; variable with the object.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadThis&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;this&lt;/em&gt; variable into register number 1.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadArguments&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;parent&lt;/em&gt; variable into register number 2.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadSuper&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;super&lt;/em&gt; variable into register number 3.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadRoot&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;_root&lt;/em&gt; variable into register number 4.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadParent&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;_parent&lt;/em&gt; variable into register number 5.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;LoadGlobal&lt;/td&gt;&lt;td&gt;Pre-load the &lt;em&gt;_global&lt;/em&gt; variable into register number 5.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSNewFunction with the specified name, argument names and
+	 * actions to be executed. The order of the Strings in the argument array
+	 * indicate the order in which the values will be popped off the stack when
+	 * the function is executed. The first argument is popped from the stack
+	 * first.
+	 * 
+	 * @param name
+	 *            the name of the function.
+	 * @param arguments
+	 *            an array of Strings listing the names of the arguments.
+	 * @param actions
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction2(String name, ArrayList arguments, ArrayList actions)
+	{
+		super(NewFunction2);
+		setName(name);
+		setArguments(arguments);
+		setActions(actions);
+	}
 
-&lt;p&gt;The register numbers that the predefined variables, &lt;em&gt;this&lt;/em&gt;, &lt;em&gt;parent&lt;/em&gt;, 
-&lt;em&gt;super&lt;/em&gt;, &lt;em&gt;_root&lt;/em&gt;, &lt;em&gt;_parent&lt;/em&gt; and &lt;em&gt;_global&lt;/em&gt; are assigned 
-to are fixed. When specifying which of the functions arguments are also assigned 
-to registers it is important avoid these locations otherwise the variables will 
-be overwritten.&lt;/p&gt;
+	/**
+	 * Constructs an anonymous FSNewFunction with the specified argument names
+	 * and actions to be executed. Use this constructor when defining functions
+	 * that will be assigned to object variables and used as methods.
+	 * 
+	 * @param arguments
+	 *            an array of Strings listing the names of the arguments.
+	 * @param actions
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public FSNewFunction2(ArrayList arguments, ArrayList actions)
+	{
+		super(NewFunction2);
+		setArguments(arguments);
+		setActions(actions);
+	}
 
-&lt;p&gt;User-defined functions are also used to create methods for user-defined objects. 
-The name of the function is omitted and the function definition is assigned to a 
-variable which allows it to be referenced at a alter time. See the example below.&lt;/p&gt;
+	/**
+	 * Constructs an FSNewFunction2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSNewFunction2 object.
+	 */
+	public FSNewFunction2(FSNewFunction2 obj)
+	{
+		super(obj);
 
-&lt;p&gt;The arguments supplied to the function can be referenced by the name supplied 
-in the arguments array.&lt;/p&gt;
+		if (obj.name != null)
+			name = new String(obj.name);
 
-&lt;p&gt;All the action objects added are owned by the function. They will be deleted 
-when the function definition is deleted.&lt;/p&gt;
+		registerCount = obj.registerCount;
+		optimizations = obj.optimizations;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		if (obj.arguments != null)
+		{
+			arguments = new ArrayList(obj.arguments.size());
 
-&lt;p&gt;1. Define a function&lt;br/&gt;
-Define a function that increments the value passed to it:&lt;/p&gt;
+			for (Iterator i = obj.arguments.iterator(); i.hasNext();)
+				arguments.add(new String(i.next().toString()));
+		}
 
-&lt;pre&gt;
-// List the names of the arguments
+		if (obj.actions != null)
+		{
+			actions = new ArrayList(obj.actions.size());
 
-ArrayList arguments = new ArrayList();
+			for (Iterator i = obj.actions.iterator(); i.hasNext();)
+				actions.add(((FSActionObject) i.next()).clone());
+		}
+	}
 
-arguments.add(&quot;value&quot;);
+	/**
+	 * Adds the name of an argument to the array of argument names.
+	 * 
+	 * @param anArgument
+	 *            the name of an argument passed to the FSNewFunction object.
+	 */
+	public void add(FSRegisterVariable anArgument)
+	{
+		arguments.add(anArgument);
+	}
 
-// Now define the actions performed by the function. Values passed to the function
-// can be referenced by the name defined in the array of arguments.
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		actions.add(anAction);
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Gets the name of the function.
+	 * 
+	 * @return the name of the function.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction2(&quot;increment&quot;, arguments, actions));
-&lt;/pre&gt;
+	/**
+	 * Sets the name of the function. The name may be null when defining
+	 * methods.
+	 * 
+	 * @param aString
+	 *            the name of the function or null for a method.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-&lt;p&gt;The function can then be referenced using it's name:&lt;/p&gt;
+	/**
+	 * Gets the number of registers to allocate for function variables.
+	 * 
+	 * @return the number of registers to allocate.
+	 */
+	public int getRegisterCount()
+	{
+		return registerCount;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(1));
-actions.add(new FSPush(&quot;increment&quot;));
-actions.add(FSAction.ExecuteFunction());
-&lt;/pre&gt;
+	/**
+	 * Sets the number of registers to allocate for function variables. Up to
+	 * 256 registers may be allocated for each function.
+	 * 
+	 * @param count
+	 *            the number of registers to allocate.
+	 */
+	public void setRegisterCount(int count)
+	{
+		registerCount = count;
+	}
 
-&lt;p&gt;2. Defining a method.&lt;br/&gt;
-When creating a user-defined object the name of the function can be omitted. 
-Simply assign the function definition to a variable:&lt;/p&gt;
+	/**
+	 * Get the code containing the compound flags that control the execution
+	 * environment of the function or method.
+	 * 
+	 * @return the code for the optimizations.
+	 */
+	public int getOptimizations()
+	{
+		return optimizations;
+	}
 
-&lt;pre&gt;
-actions.add(new FSPush(methodVariable));
+	/**
+	 * Set the code containing the compound flags that control the execution
+	 * environment of the function or method.
+	 * 
+	 * @param code
+	 *            the compound code can be created by bitwise-ORing the
+	 *            constants that identify the optimizations performed.
+	 */
+	public void setOptimizations(int code)
+	{
+		optimizations = code;
+	}
 
-FSVector&lt;FSString&gt; arguments;
+	/**
+	 * Gets the array of FSRegisterVariables that define the function arguments
+	 * and whether they are assigned to internal registers or to local variables
+	 * in memory.
+	 * 
+	 * @return the array of FSRegisterVariables that define the functions
+	 *         arguments.
+	 */
+	public ArrayList getArguments()
+	{
+		return arguments;
+	}
 
-arguments.push_back(&quot;value&quot;);
+	/**
+	 * Sets the array of FSRegisterVariables that define the function arguments
+	 * and whether they are assigned to internal registers or to local variables
+	 * in memory.
+	 * 
+	 * @param anArray
+	 *            an array of Strings listing the names of the arguments.
+	 */
+	public void setArguments(ArrayList anArray)
+	{
+		arguments = anArray;
+	}
 
-ArrayList actions = new ArrayList();
+	/**
+	 * Gets the actions executed by the function.
+	 * 
+	 * @return the array of actions executed.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-actions.add(new FSPush(&quot;value&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(1));
-actions.add(FSAction.Add());
-actions.add(FSAction.Return());
-actions.add(new FSNewFunction2(arguments, actions));
-actions.add(FSAction.SetVariable()));
-&lt;/pre&gt;
+	/**
+	 * Sets the actions.
+	 * 
+	 * @param anArray
+	 *            the array of actions that define the operation performed by
+	 *            the function.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
 
-&lt;p&gt;The function can then be executed by pushing the arguments onto the stack 
-then calling the function assigned to the variable:&lt;/p&gt;
+	public Object clone()
+	{
+		FSNewFunction2 anObject = (FSNewFunction2) super.clone();
 
-&lt;pre&gt;
-// Push argument(s) onto stack
+		anObject.arguments = new ArrayList();
 
-actions.add(new FSPush(1));
+		for (Iterator i = arguments.iterator(); i.hasNext();)
+			anObject.arguments.add((FSRegisterVariable) ((FSRegisterVariable) i
+							.next()).clone());
 
-// Get the variable that contains the function
+		anObject.actions = new ArrayList();
 
-actions.add(new FSPush(methodVariable));
-actions.add(FSAction.GetVariable());
+		for (Iterator i = actions.iterator(); i.hasNext();)
+			anObject.actions.add(((FSActionObject) i.next()).clone());
 
-// Execute the function
-actions.add(FSAction.ExecuteMethod());
-&lt;/pre&gt;
+		return anObject;
+	}
 
-&lt;p&gt;3. Controlling the execution environment.&lt;br/&gt;
-The code that defines the optimizations that improve execution performance is 
-created by bitwise-ORing the individual flags together.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt; 
-int optimizations = FSNewFunction2.CreateSuper |  FSNewFunction2.PreloadSuper;
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSNewFunction2 typedObject = (FSNewFunction2) anObject;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			if (name != null)
+				result = name.equals(typedObject.name);
+			else
+				result = name == typedObject.name;
 
-&lt;p&gt;The FSNewFunction class represents the ActionDefineFunction2 action of the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSNewFunction2 extends FSActionObject
-{
-/** Create and initialized the predefined variable, &lt;em&gt;super&lt;/em&gt;. */
-    public static final int CreateSuper = 4;
-/** Create and initialized the predefined variable, &lt;em&gt;arguments&lt;/em&gt;. */
-    public static final int CreateArguments = 16;
-/** Create and initialized the predefined variable, &lt;em&gt;this&lt;/em&gt;. */
-    public static final int CreateThis = 64;
+			result = result &amp;&amp; registerCount == typedObject.registerCount;
+			result = result &amp;&amp; optimizations == typedObject.optimizations;
 
-/** Load the predefine variable, &lt;em&gt;this&lt;/em&gt;, into register 1. */
-    public static final int LoadThis = 128;
-/** Load the predefine variable, &lt;em&gt;arguments&lt;/em&gt;, into register 2. */
-    public static final int LoadArguments = 32;
-/** Load the predefine variable, &lt;em&gt;super&lt;/em&gt;, into register 3. */
-    public static final int LoadSuper = 8;
-/** Load the predefine variable, &lt;em&gt;_root&lt;/em&gt;, into register 4. */
-    public static final int LoadRoot = 2;
-/** Load the predefine variable, &lt;em&gt;_parent&lt;/em&gt;, into register 5. */
-    public static final int LoadParent = 1;
-/** Load the predefine variable, &lt;em&gt;_global&lt;/em&gt;, into register 6. */
-    public static final int LoadGlobal = 32768;
-    
-    private String name = null;
-    
-    private int registerCount = 0;
-    private int optimizations = 0;
-    
-    private ArrayList arguments = null;
-    private ArrayList actions = null;
-    
-    /*
-     * variables used to record state when encoding.
-     */
-    private int _actionsLength = 0;
+			if (arguments != null)
+				result = result &amp;&amp; arguments.equals(typedObject.arguments);
+			else
+				result = result &amp;&amp; arguments == typedObject.arguments;
 
-    /**
-     * Construct an FSNewFunction2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSNewFunction2(FSCoder coder)
-    {
-        super(NewFunction2);
-        decode(coder);
-    }
-    /** 
-     * Constructs an FSNewFunction with the specified name, argument names and actions to 
-     * be executed. The order of the Strings in the argument array indicate the order in 
-     * which the values will be popped off the stack when the function is executed. The 
-     * first argument is popped from the stack first.
+			if (actions != null)
+				result = result &amp;&amp; actions.equals(typedObject.actions);
+			else
+				result = result &amp;&amp; actions == typedObject.actions;
+		}
+		return result;
+	}
 
-        @param name the name of the function.
-        @param arguments an array of Strings listing the names of the arguments.
-        @param actions the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction2(String name, ArrayList arguments, ArrayList actions)
-    {
-        super(NewFunction2);
-        setName(name);
-        setArguments(arguments);
-        setActions(actions);
-    }
-    /** 
-     * Constructs an anonymous FSNewFunction with the specified argument names and actions 
-     * to be executed. Use this constructor when defining functions that will be assigned 
-     * to object variables and used as methods.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param arguments an array of Strings listing the names of the arguments.
-        @param actions the array of actions that define the operation performed by the function.
-        */
-    public FSNewFunction2(ArrayList arguments, ArrayList actions)
-    {
-        super(NewFunction2);
-        setArguments(arguments);
-        setActions(actions);
-    }
-    /**
-     * Constructs an FSNewFunction2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSNewFunction2 object.
-     */
-    public FSNewFunction2(FSNewFunction2 obj)
-    {
-        super(obj);
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;name&quot;, name);
+			Transform.append(buffer, &quot;registerCount&quot;, registerCount);
+			Transform.append(buffer, &quot;optimizations&quot;, optimizations);
+			Transform.append(buffer, &quot;arguments&quot;, arguments, depth);
+			Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        if (obj.name != null)
-            name = new String(obj.name);
-        
-        registerCount = obj.registerCount;
-        optimizations = obj.optimizations;
-        
-        if (obj.arguments != null)
-        {
-            arguments = new ArrayList(obj.arguments.size());
-            
-            for (Iterator i = obj.arguments.iterator(); i.hasNext();)
-                arguments.add(new String(i.next().toString()));
-        }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        if (obj.actions != null)
-        {
-            actions = new ArrayList(obj.actions.size());
-            
-            for (Iterator i = obj.actions.iterator(); i.hasNext();)
-                actions.add(((FSActionObject)i.next()).clone());
-        }
-    }    
+		length += (name != null) ? coder.strlen(name, true) : 1;
+		length += 5;
 
-    /** Adds the name of an argument to the array of argument names.
+		for (int i = 0; i &lt; arguments.size(); i++)
+			length += ((FSRegisterVariable) arguments.get(i)).length(coder);
 
-        @param anArgument the name of an argument passed to the FSNewFunction object.
-        */
-    public void add(FSRegisterVariable anArgument)
-    {
-        arguments.add(anArgument); 
-    }
+		length += 2;
 
-    /** Adds the action object to the array of actions.
+		_actionsLength = 0;
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        actions.add(anAction);
-    }
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject currentAction = (FSActionObject) i.next();
 
-    /** Gets the name of the function.
+			_actionsLength += currentAction.length(coder);
+			_actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
+		length += _actionsLength;
 
-        @return the name of the function.
-        */
-    public String getName() 
-    {
-        return name;
-    }
-    
-    /** Sets the name of the function. The name may be null when defining methods.
+		return length;
+	}
 
-        @param aString the name of the function or null for a method.
-        */
-    public void setName(String aString) 
-    {
-        name = aString;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
 
-    /** 
-     * Gets the number of registers to allocate for function variables.
-     * 
-     * @return the number of registers to allocate.
-     */
-    public int getRegisterCount()
-    {
-        return registerCount;
-    }
-    
-    /**
-     * Sets the number of registers to allocate for function variables. Up to
-     * 256 registers may be allocated for each function.
-     * 
-     * @param count the number of registers to allocate.
-     */
-    public void setRegisterCount(int count)
-    {
-        registerCount = count;
-    }
+		coder.writeWord(type, 1);
+		coder.writeWord(length - _actionsLength, 2);
 
-    /** 
-     * Get the code containing the compound flags that control the execution environment
-     * of the function or method.
-     *
-     * @return the code for the optimizations.
-     */
-    public int getOptimizations()
-    {
-        return optimizations;
-    }
-    
-    /** 
-     * Set the code containing the compound flags that control the execution environment
-     * of the function or method.
-     *
-     * @param code the compound code can be created by bitwise-ORing the constants that 
-     * identify the optimizations performed.
-     */
-    public void setOptimizations(int code)
-    {
-        optimizations = code;
-    }
+		if (name != null)
+			coder.writeString(name);
 
-    /** 
-     * Gets the array of FSRegisterVariables that define the function arguments and whether
-     * they are assigned to internal registers or to local variables in memory.
+		coder.writeWord(0, 1);
 
-        @return the array of FSRegisterVariables that define the functions arguments.
-        */
-    public ArrayList getArguments() 
-    {
-        return arguments;
-    }
+		coder.writeWord(arguments.size(), 2);
+		coder.writeWord(registerCount, 1);
+		coder.writeBits(optimizations, 16);
 
-    /**
-     * Sets the array of FSRegisterVariables that define the function arguments and whether
-     * they are assigned to internal registers or to local variables in memory.
-     *
-     * @param anArray an array of Strings listing the names of the arguments.
-     */
-    public void setArguments(ArrayList anArray) 
-    {
-        arguments = anArray;
-    }
+		for (Iterator i = arguments.iterator(); i.hasNext();)
+			((FSRegisterVariable) i.next()).encode(coder);
 
-    /** Gets the actions executed by the function.
+		coder.writeWord(_actionsLength, 2);
 
-        @return the array of actions executed.
-        */
-    public ArrayList getActions() 
-    {
-        return actions;
-    }
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
 
-    /** Sets the actions.
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
 
-        @param anArray the array of actions that define the operation performed by the function.
-        */
-    public void setActions(ArrayList anArray) 
-    {
-        actions = anArray;
-    }
+			action.encode(coder);
+			coder.setPointer(next);
 
-    public Object clone()
-    {
-        FSNewFunction2 anObject = (FSNewFunction2)super.clone();
-        
-         anObject.arguments = new ArrayList();
-            
-        for (Iterator i = arguments.iterator(); i.hasNext();)
-            anObject.arguments.add((FSRegisterVariable)((FSRegisterVariable)i.next()).clone());
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        anObject.actions = new ArrayList();
-            
-        for (Iterator i = actions.iterator(); i.hasNext();)
-            anObject.actions.add(((FSActionObject)i.next()).clone());
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
 
-        return anObject;
-    }
+		coder.endObject(name());
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSNewFunction2 typedObject = (FSNewFunction2)anObject;
-            
-            if (name != null)
-                result = name.equals(typedObject.name);
-            else
-                result = name == typedObject.name;
-                
-            result = result &amp;&amp; registerCount == typedObject.registerCount;
-            result = result &amp;&amp; optimizations == typedObject.optimizations;
+	public void decode(FSCoder coder)
+	{
+		int argumentCount = 0;
+		int bytesRead = 0;
 
-            if (arguments != null)
-                result = result &amp;&amp; arguments.equals(typedObject.arguments);
-            else
-                result = result &amp;&amp; arguments == typedObject.arguments;
+		arguments = new ArrayList();
+		actions = new ArrayList();
 
-            if (actions != null)
-                result = result &amp;&amp; actions.equals(typedObject.actions);
-            else
-                result = result &amp;&amp; actions == typedObject.actions;
-        }
-        return result;
-    }
+		super.decode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;name&quot;, name);        
-            Transform.append(buffer, &quot;registerCount&quot;, registerCount);
-            Transform.append(buffer, &quot;optimizations&quot;, optimizations);
-            Transform.append(buffer, &quot;arguments&quot;, arguments, depth);
-            Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		name = coder.readString();
 
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += (name != null) ? coder.strlen(name, true) : 1;
-        length += 5;
-        
-        for (int i=0; i&lt;arguments.size(); i++)
-            length += ((FSRegisterVariable)arguments.get(i)).length(coder);
-        
-        length += 2;
-        
-        _actionsLength = 0;
+		argumentCount = coder.readWord(2, false);
+		registerCount = coder.readWord(1, false);
+		optimizations = coder.readBits(16, false);
 
-        for (Iterator i = actions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            _actionsLength += currentAction.length(coder);
-            _actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        length += _actionsLength;
-        
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.beginObject(name());
+		for (int i = 0; i &lt; argumentCount; i++)
+			arguments.add(new FSRegisterVariable(coder));
 
-        coder.writeWord(type, 1);
-        coder.writeWord(length - _actionsLength, 2);
+		_actionsLength = coder.readWord(2, false);
+		length += _actionsLength;
 
-        if (name != null)
-            coder.writeString(name);
+		while (bytesRead &lt; _actionsLength)
+		{
+			FSActionObject anAction = FSMovie.decodeAction(coder);
 
-        coder.writeWord(0, 1);
+			bytesRead += anAction.getLength()
+							+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+			actions.add(anAction);
+		}
 
-        coder.writeWord(arguments.size(), 2);
-        coder.writeWord(registerCount, 1);
-        coder.writeBits(optimizations, 16);
-
-        for (Iterator i = arguments.iterator(); i.hasNext();)
-            ((FSRegisterVariable)i.next()).encode(coder);
-
-        coder.writeWord(_actionsLength, 2);
-           
-        for (Iterator i=actions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-                
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
-
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int argumentCount = 0;
-        int bytesRead = 0;
-        
-        arguments = new ArrayList();
-        actions = new ArrayList();
-
-        super.decode(coder);
-
-        name = coder.readString();
-        
-        argumentCount = coder.readWord(2, false);
-        registerCount = coder.readWord(1, false);
-        optimizations = coder.readBits(16, false);
-        
-        for (int i=0; i&lt;argumentCount; i++)
-            arguments.add(new FSRegisterVariable(coder));
-
-        _actionsLength = coder.readWord(2, false);
-        length += _actionsLength;
-        
-        while (bytesRead &lt; _actionsLength)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-            actions.add(anAction);
-        }
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSNull.java
===================================================================
--- trunk/src/com/flagstone/transform/FSNull.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSNull.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,49 +30,52 @@
 
 package com.flagstone.transform;
 
-/** 
-FSNull is a lightweight object that is used solely to allow null values to be pushed 
-onto the Flash Player stack by The FSPush class.
- 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSNull class represents the Null data type from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
-
- */  
+/**
+ * FSNull is a lightweight object that is used solely to allow null values to be
+ * pushed onto the Flash Player stack by The FSPush class.
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSNull class represents the Null data type from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5.
+ * &lt;/p&gt;
+ * 
+ */
 public class FSNull extends FSTransformObject
 {
-    private static final FSNull instance = new FSNull();
-    
-    /**
-     * Returns a canonical FSNull object.
-     * 
-     * @return an object that can safely be shared among objects.
-     */
-    public static FSNull getInstance()
-    {
-        return instance;
-    }
-    
-    /** Constructs an FSNull object. */     
-    public FSNull()
-    {
-    }
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
+	private static final FSNull instance = new FSNull();
 
-    public int length(FSCoder coder) 
-    { 
-        return 0; 
-    }
-    
-    public void encode(FSCoder coder) 
-    {
-    }
-    
-    public void decode(FSCoder coder) 
-    {
-    }
+	/**
+	 * Returns a canonical FSNull object.
+	 * 
+	 * @return an object that can safely be shared among objects.
+	 */
+	public static FSNull getInstance()
+	{
+		return instance;
+	}
+
+	/** Constructs an FSNull object. */
+	public FSNull()
+	{
+	}
+
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
+
+	public int length(FSCoder coder)
+	{
+		return 0;
+	}
+
+	public void encode(FSCoder coder)
+	{
+	}
+
+	public void decode(FSCoder coder)
+	{
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSPathsArePostscript.java
===================================================================
--- trunk/src/com/flagstone/transform/FSPathsArePostscript.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSPathsArePostscript.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,102 +31,115 @@
 package com.flagstone.transform;
 
 /**
-The FSPathsArePostscript class is used to notify the Flash Player that the glyphs encoded
-in a font definition were derived from a PostScript-based font definition.
+ * The FSPathsArePostscript class is used to notify the Flash Player that the
+ * glyphs encoded in a font definition were derived from a PostScript-based font
+ * definition.
+ * 
+ * &lt;p&gt;
+ * The PathsArePostscript is not documented in the current Macromedia Flash
+ * (SWF) File Format Specification. IT was referenced in earlier editions but
+ * its exact function was not known. It is thought that is used to signal to the
+ * Flash Player that the paths describing the outlines of the glyphs in a font
+ * were derived from a font defined using Postscript. The information can be
+ * used to provide better rendering of the glyphs.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * It does not affect the paths defined in FSCurve objects which describe
+ * quadratic Bezier curves. It is included in the package for completeness.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPathsArePostscript class represents the PathsArePostscript tag from the
+ * Macromedia Flash (SWF) File Format Specification. It is not documented in
+ * later editions of the specification. It is not known when this tag was added.
+ * &lt;/p&gt;
+ */
+public class FSPathsArePostscript extends FSMovieObject
+{
+	private static final FSPathsArePostscript instance = new FSPathsArePostscript();
 
-&lt;p&gt;The PathsArePostscript is not documented in the current Macromedia Flash (SWF) 
-File Format Specification. IT was referenced in earlier editions but its exact
-function was not known. It is thought that is used to signal to the Flash 
-Player that the paths describing the outlines of the glyphs in a font were 
-derived from a font defined using Postscript. The information can be used to 
-provide better rendering of the glyphs.&lt;/P&gt;
+	/**
+	 * Returns a canonical FSPathsArePostscript object.
+	 * 
+	 * @return an object that can safely be shared among objects.
+	 */
+	public static FSPathsArePostscript getInstance()
+	{
+		return instance;
+	}
 
-&lt;p&gt;It does not affect the paths defined in FSCurve objects which describe 
-quadratic Bezier curves. It is included in the package for completeness.&lt;/p&gt;
+	/**
+	 * Construct an FSPathsArePostscript object, initalizing it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPathsArePostscript(FSCoder coder)
+	{
+		super(PathsArePostscript);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Constructs an FSPathsArePostscript object. */
+	public FSPathsArePostscript()
+	{
+		super(PathsArePostscript);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSPathsArePostscript object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSPathsArePostscript object.
+	 */
+	public FSPathsArePostscript(FSPathsArePostscript obj)
+	{
+		super(obj);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPathsArePostscript_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
 
-&lt;/table&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		return length;
+	}
 
-&lt;p&gt;The FSPathsArePostscript class represents the PathsArePostscript tag from the 
-Macromedia Flash (SWF) File Format Specification. It is not documented in later 
-editions of the specification. It is not known when this tag was added.&lt;/p&gt;
- */  
-public class FSPathsArePostscript extends FSMovieObject
-{
-    private static final FSPathsArePostscript instance = new FSPathsArePostscript();
-    
-    /**
-     * Returns a canonical FSPathsArePostscript object.
-     * 
-     * @return an object that can safely be shared among objects.
-     */
-    public static FSPathsArePostscript getInstance()
-    {
-        return instance;
-    }
-    
-   /**
-     * Construct an FSPathsArePostscript object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPathsArePostscript(FSCoder coder)
-    {
-        super(PathsArePostscript);
-        decode(coder);
-    }
-    /** Constructs an FSPathsArePostscript object. */
-    public FSPathsArePostscript()
-    {
-        super(PathsArePostscript);
-    }
-    /**
-     * Constructs an FSPathsArePostscript object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSPathsArePostscript object.
-     */
-    public FSPathsArePostscript(FSPathsArePostscript obj)
-    {
-        super(obj);
-    }    
-    
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.context[FSCoder.Empty] = 1;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-            
-        return length;
-    }    
+		super.encode(coder);
 
-    public void encode(FSCoder coder)
-    {
-        coder.context[FSCoder.Empty] = 1;
-        
-        super.encode(coder);
-        
-        coder.context[FSCoder.Empty] = 0;
-        coder.endObject(name());
-    }
+		coder.context[FSCoder.Empty] = 0;
+		coder.endObject(name());
+	}
 
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSPlaceObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSPlaceObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSPlaceObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,318 +31,433 @@
 package com.flagstone.transform;
 
 /**
-FSPlaceObject is used to add an object (shape, button, etc.) to the Flash Player's display list.
-  
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSPlaceObject is used to add an object (shape, button, etc.) to the Flash
+ * Player's display list.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier, in the range 1..65535, of the object to be
+ * displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The Display List layer on which the object is drawn.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;coordTransform&lt;/td&gt;
+ * &lt;td&gt;An FSCoordTransform which defines the location and appearance of the
+ * object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;An FSColorTransform which defines any changes to be made to the object's
+ * original colour. Optional. May be set to null if an object's colour is not
+ * being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Every class that defines a shape, button etc. is assigned a unique
+ * identifier. This is an integer in the range 1..65535 and is used to refer to
+ * objects when performing actions such as adding or removing them from the
+ * display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The display list contains all the objects that are currently visible on the
+ * Flash Player's screen. The display list is ordered in layers, with one (and
+ * only one) object displayed on each layer. The Layer defines the order in
+ * which objects are displayed. Objects with a higher layer number are displayed
+ * in front of objects on a lower layer.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The coordinate transform is principally used to specify the location of the
+ * object when it is drawn on the screen however more complex coordinate
+ * transforms can also be specified such as rotating or scaling the object
+ * without changing the original definition.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Similarly the color transform allows the color of the object to be changed
+ * when it is displayed without changing the original definition. The
+ * FSPlaceObject class only supports opaque colours so although the
+ * FSColorTransform supports transparent colours this information is ignored by
+ * the Flash Player. The colour transform is optional and may be set to the null
+ * object.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following simplified code fragments illustrate how the FSPlaceObject
+ * class can be used.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Display an object.&lt;br/&gt; Display an object on layer 1 at (400, 400).
+ * FSPlaceObject provides a constructor which specifies just the x and y
+ * coordinates, the FSCoordTransform object is constructed internally.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......)
+ * 
+ *  movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Scale an object.&lt;br/&gt; Scale an object to twice its original size by
+ * specifying a more complex coordinate transformation. Complex transforms can
+ * be created by compositing individual steps.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSCoordTransform location = FSCoordTransform.translate(200, 200);
+ * FSCoordTransform scale = FSCoordTransform.scale(2.0, 2.0);
+ * FSCoordTransform transform = FSCoordTransform.composite(location, scale);
+ * 
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, transform));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Move an object.&lt;br/&gt; To move an object the FSPlaceObject class must be
+ * used in conjunction with the FSRemoveObject class to first remove the object
+ * from its existing position before being placed at the new location.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Move shape to a new location, removing the original so it does not get displayed twice.
+ * movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPlaceObject class represents the PlaceObject tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1 and is
+ * superseded by the PlaceObject2 tag which was added in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSPlaceObject extends FSMovieObject
+{
+	private int identifier = 0;
+	private int layer = 0;
+	private FSCoordTransform transform = null;
+	private FSColorTransform colorTransform = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSPlaceObject object, initalising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPlaceObject(FSCoder coder)
+	{
+		super(FSMovieObject.PlaceObject);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject object that places an object with the
+	 * identifier into the display list layer at the specified coordinates
+	 * (x,y).
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 * @param aLayer
+	 *            the layer in the display list where the object will be placed.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be drawn.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be drawn.
+	 */
+	public FSPlaceObject(int anIdentifier, int aLayer, int xLocation,
+							int yLocation)
+	{
+		super(FSMovieObject.PlaceObject);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier, in the range 1..65535, of the object to be displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject object that places the object with the
+	 * identifier at the specified layer with the coordinate transform.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 * @param aLayer
+	 *            the layer in the display list where the object will be placed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that defines the orientation, size
+	 *            and location of the object when it is drawn.
+	 */
+	public FSPlaceObject(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform)
+	{
+		super(FSMovieObject.PlaceObject);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The Display List layer on which the object is drawn.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject object that places the the object with the
+	 * identifier at the specified layer, coordinate transform and colour
+	 * transform.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 * @param aLayer
+	 *            the layer in the display list where the object will be placed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that defines the orientation, size
+	 *            and location of the object when it is drawn.
+	 * @param aColorTransform
+	 *            an FSColorTransform object that defines the colour of the
+	 *            object when it is drawn.
+	 */
+	public FSPlaceObject(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform,
+							FSColorTransform aColorTransform)
+	{
+		super(FSMovieObject.PlaceObject);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(aColorTransform);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_3&quot;&gt;coordTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSCoordTransform which defines the location and appearance of the object.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPlaceObject object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSPlaceObject object.
+	 */
+	public FSPlaceObject(FSPlaceObject obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		layer = obj.layer;
+		transform = new FSCoordTransform(obj.transform);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject_4&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColorTransform which defines any changes to be made to the object's original colour. Optional. May be set to null if an object's colour is not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+		if (obj.colorTransform != null)
+			colorTransform = new FSColorTransform(obj.colorTransform);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the identifier of the object.
+	 * 
+	 * @return the identifier of the object being placed.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;p&gt;Every class that defines a shape, button etc. is assigned a unique identifier. This is an integer in the range 1..65535 and is used to refer to objects when performing actions such as adding or removing them from the display list.&lt;/p&gt;
+	/**
+	 * Gets the layer that defines the order in which objects are displayed.
+	 * 
+	 * @return the layer on which the object will be displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;p&gt;The display list contains all the objects that are currently visible on the Flash Player's screen. The display list is ordered in layers, with one (and only one) object displayed on each layer. The Layer defines the order in which objects are displayed. Objects with a higher layer number are displayed in front of objects on a lower layer.&lt;/p&gt;
+	/**
+	 * Gets the transform that defines the position where the object is
+	 * displayed.
+	 * 
+	 * @return the FSCoordTransform applied to the object when it is drawn.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-&lt;p&gt;The coordinate transform is principally used to specify the location of the object when it is drawn on the screen however more complex coordinate transforms can also be specified such as rotating or scaling the object without changing the original definition.&lt;/p&gt;
+	/**
+	 * Gets the colour transform that defines any colour effects applied when
+	 * the object is displayed.
+	 * 
+	 * @return the FSColorTransform applied to the object when it is drawn.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-&lt;p&gt;Similarly the color transform allows the color of the object to be changed when it is displayed without changing the original definition. The FSPlaceObject class only supports opaque colours so although the FSColorTransform supports transparent colours this information is ignored by the Flash Player. The colour transform is optional and may be set to the null object.&lt;/p&gt;
+	/**
+	 * Sets the identifier of the object.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object to the placed on the
+	 *            display list.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the layer that defines the order in which objects are displayed.
+	 * 
+	 * @param aNumber
+	 *            the layer in the display list where the object will be placed.
+	 */
+	public void setLayer(int aNumber)
+	{
+		layer = aNumber;
+	}
 
-&lt;p&gt;The following simplified code fragments illustrate how the FSPlaceObject class can be used.&lt;/p&gt;
+	/**
+	 * Sets the transform that defines the position where the object is
+	 * displayed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that defines the orientation, size
+	 *            and location of the object when it is drawn.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-&lt;p&gt;1. Display an object.&lt;br/&gt; 
-Display an object on layer 1 at (400, 400). FSPlaceObject provides a constructor which specifies just the x and y coordinates, the FSCoordTransform object is constructed internally.&lt;/p&gt;
+	/**
+	 * Sets the colour transform that defines any colour effects applied when
+	 * the object is displayed.
+	 * 
+	 * @param aColorTransform
+	 *            an FSColorTransform object that defines the colour of the
+	 *            object when it is drawn.
+	 */
+	public void setColorTransform(FSColorTransform aColorTransform)
+	{
+		colorTransform = aColorTransform;
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......)
+	public Object clone()
+	{
+		FSPlaceObject anObject = (FSPlaceObject) super.clone();
 
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-&lt;p&gt;2. Scale an object.&lt;br/&gt;
-Scale an object to twice its original size by specifying a more complex coordinate transformation. Complex transforms can be created by compositing individual steps.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;pre&gt;
-FSCoordTransform location = FSCoordTransform.translate(200, 200);
-FSCoordTransform scale = FSCoordTransform.scale(2.0, 2.0);
-FSCoordTransform transform = FSCoordTransform.composite(location, scale);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, transform));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSPlaceObject typedObject = (FSPlaceObject) anObject;
 
-&lt;p&gt;3. Move an object.&lt;br/&gt;
-To move an object the FSPlaceObject class must be used in conjunction with the FSRemoveObject class to first remove the object from its existing position before being placed at the new location.&lt;/p&gt;
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; layer == typedObject.layer;
 
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-// Move shape to a new location, removing the original so it does not get displayed twice.
-movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
+			if (colorTransform == null)
+				result = result &amp;&amp; (typedObject.getColorTransform() == null);
+			else
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
+		}
+		return result;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;The FSPlaceObject class represents the PlaceObject tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1 and is superseded by the PlaceObject2 tag which was added in Flash 3.&lt;/p&gt;
- */
-public class FSPlaceObject extends FSMovieObject
-{
-    private int identifier = 0;
-    private int layer = 0;
-    private FSCoordTransform transform = null;
-    private FSColorTransform colorTransform = null;
-        
-    /**
-     * Construct an FSPlaceObject object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPlaceObject(FSCoder coder)
-    {
-        super(FSMovieObject.PlaceObject);
-        decode(coder);
-    }
-    /** Constructs an FSPlaceObject object that places an object with the identifier into the display list layer at the specified coordinates (x,y).
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;layer&quot;, layer);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        @param aLayer the layer in the display list where the object will be placed.
-        @param xLocation the x-coordinate where the object will be drawn.
-        @param yLocation the y-coordinate where the object will be drawn.
-        */
-    public FSPlaceObject(int anIdentifier, int aLayer, int xLocation, int yLocation)
-    {
-        super(FSMovieObject.PlaceObject);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 4;
+		length += transform.length(coder);
+		length += (colorTransform != null) ? colorTransform.length(coder) : 0;
 
-    /** Constructs an FSPlaceObject object that places the object with the identifier at the specified layer with the coordinate transform.
+		return length;
+	}
 
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        @param aLayer the layer in the display list where the object will be placed.
-        @param aTransform an FSCoordTransform object that defines the orientation, size and location of the object when it is drawn.
-        */
-    public FSPlaceObject(int anIdentifier, int aLayer, FSCoordTransform aTransform)
-    {
-        super(FSMovieObject.PlaceObject);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Constructs an FSPlaceObject object that places the the object with the identifier at the specified layer, coordinate transform and colour transform.
+		coder.writeWord(identifier, 2);
+		coder.writeWord(layer, 2);
+		transform.encode(coder);
 
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        @param aLayer the layer in the display list where the object will be placed.
-        @param aTransform an FSCoordTransform object that defines the orientation, size and location of the object when it is drawn.
-        @param aColorTransform an FSColorTransform object that defines the colour of the object when it is drawn.
-        */
-    public FSPlaceObject(int anIdentifier, int aLayer, FSCoordTransform aTransform, FSColorTransform aColorTransform)
-    {
-        super(FSMovieObject.PlaceObject);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(aColorTransform);
-    }
-    /**
-     * Constructs an FSPlaceObject object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSPlaceObject object.
-     */
-    public FSPlaceObject(FSPlaceObject obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        layer = obj.layer;
-        transform = new FSCoordTransform(obj.transform);
-        
-        if (obj.colorTransform != null)
-            colorTransform = new FSColorTransform(obj.colorTransform);
-    }    
+		if (colorTransform != null)
+			colorTransform.encode(coder);
 
-    /** Gets the identifier of the object.
+		coder.endObject(name());
+	}
 
-        @return the identifier of the object being placed.
-        */
-    public int getIdentifier() { return identifier; }
+	public void decode(FSCoder coder)
+	{
+		int lengthRead = coder.getPointer();
 
-    /** Gets the layer that defines the order in which objects are displayed.
+		super.decode(coder);
 
-        @return the layer on which the object will be displayed.
-        */
-    public int getLayer() { return layer; }
+		identifier = coder.readWord(2, false);
+		layer = coder.readWord(2, false);
+		transform = new FSCoordTransform(coder);
 
-    /** Gets the transform that defines the position where the object is displayed.
+		lengthRead = (coder.getPointer() - lengthRead) &gt;&gt; 3;
 
-        @return the FSCoordTransform applied to the object when it is drawn.
-        */
-    public FSCoordTransform getTransform() { return transform; }
+		if (length &gt; lengthRead)
+			colorTransform = new FSColorTransform(coder);
 
-    /** Gets the colour transform that defines any colour effects applied when the object is displayed.
-
-        @return the FSColorTransform applied to the object when it is drawn.
-        */
-    public FSColorTransform getColorTransform() { return colorTransform; }
-
-    /** Sets the identifier of the object.
-
-        @param anIdentifier the unique identifier for the object to the placed on the display list.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-
-    /** Sets the layer that defines the order in which objects are displayed.
-
-        @param aNumber the layer in the display list where the object will be placed.
-        */
-    public void setLayer(int aNumber)
-    {
-        layer = aNumber;
-    }
-
-    /** Sets the transform that defines the position where the object is displayed.
-
-        @param aTransform an FSCoordTransform object that defines the orientation, size and location of the object when it is drawn.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
-
-    /** Sets the colour transform that defines any colour effects applied when the object is displayed.
-
-        @param aColorTransform an FSColorTransform object that defines the colour of the object when it is drawn.
-        */
-    public void setColorTransform(FSColorTransform aColorTransform)
-    {
-        colorTransform = aColorTransform;
-    }
-
-    public Object clone()
-    {
-        FSPlaceObject anObject = (FSPlaceObject)super.clone();
-        
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSPlaceObject typedObject = (FSPlaceObject)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; layer == typedObject.layer;
-
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
-
-            if (colorTransform == null)
-                result = result &amp;&amp; (typedObject.getColorTransform() == null);
-            else
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 4;
-        length += transform.length(coder);
-        length += (colorTransform != null) ? colorTransform.length(coder) : 0;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(identifier, 2);
-        coder.writeWord(layer, 2);
-        transform.encode(coder);
-        
-        if (colorTransform != null)
-            colorTransform.encode(coder);
-
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int lengthRead = coder.getPointer();
-        
-        super.decode(coder);
-        
-        identifier = coder.readWord(2, false);
-        layer = coder.readWord(2, false);
-        transform = new FSCoordTransform(coder);
-        
-        lengthRead = (coder.getPointer() - lengthRead) &gt;&gt; 3;
-        
-        if (length &gt; lengthRead)
-            colorTransform = new FSColorTransform(coder);
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSPlaceObject2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSPlaceObject2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSPlaceObject2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,1023 +33,1269 @@
 import java.util.*;
 
 /**
-FSPlaceObject2 is used to add and manipulate objects (shape, button, etc.) on the Flash 
-Player's display list. 
- 
-&lt;p&gt;FSPlaceObject2 supersedes the FSPlaceObject class providing more functionality and easier manipulation of  objects in the display list through the following operations:&lt;/p&gt;
-
-&lt;ul&gt;
-&lt;li&gt;Place a new shape on the display list.&lt;/li&gt;
-&lt;li&gt;Change an existing shape by moving it to new location or changing its appearance.&lt;/li&gt;
-&lt;li&gt;Replace an existing shape with a another.&lt;/li&gt;
-&lt;li&gt;Define clipping layers to mask objects displayed in front of a shape.&lt;/li&gt;
-&lt;li&gt;Control the morphing process that changes one shape into another.&lt;/li&gt;
-&lt;li&gt;Assign names to objects rather than using their identifiers.&lt;/li&gt;
-&lt;li&gt;Define the sequence of actions that are executed when an event occurs in movie clip.&lt;/li&gt;
-&lt;/ul&gt;
-
-&lt;p&gt;&lt;b&gt;Clipping Depth&lt;/b&gt;&lt;br/&gt;
-With the introduction of Flash 3 the display list supported a clipping layer. This 
-allowed the outline of an object to define a clipping path that is used to mask 
-other objects placed in front of it. The clipping depth can be set to mask objects 
-between the layer containing the clipping path and a specified layer.&lt;/p&gt;
-
-&lt;p&lt;b&gt;Shape Morphing&lt;/b&gt;&lt;br/&gt;
-Shapes that will be morphed are defined using the FSDefineMorphShape class which defines a start and end shape. The Flash Player performs the interpolation that transforms one shape into another. The progress of the morphing process is controlled by a ratio which ranges from 0.0 to 1.0, where 0 generates a shape identical to the starting shape in the FSDefineMorphShape object and 1.0 generates the shape at the end of the morphing process.&lt;/p&gt;
-
-&lt;p&lt;b&gt;Movie Clip Events&lt;/b&gt;&lt;br/&gt;
-With the introduction of Flash 5, movie clips (defined using the FSDefineMovieClip class) could specify sequences of actions that would be performed in response to mouse or keyboard events. The actions are specified using FSClipEvent objects and the FSPlaceObject2 class is used to register the actions in response to a particular event with the Flash player. Multiple events can be handled by defining an FSClipEvent for each type of event. For more information see the FSClipEvent class.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_1&quot;&gt;place&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Indicates whether a new object is being placed in the display list or an existing object is being modified or replaced.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_2&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the object to added to the display list.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_3&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Defines the order in which objects are displayed.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_4&quot;&gt;transform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. A coordinate transform defines the position, scale and rotation of the object.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_5&quot;&gt;colorTransform&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. A colour transform defines any colour changes such as transparency effects.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_6&quot;&gt;depth&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. The layer number up to which objects will be clipped by this object's outline.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_7&quot;&gt;ratio&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. The point for the morphing process of a shape.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_8&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. A name to assign to the object.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_9&quot;&gt;events&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Optional. An array of FSClipEvent objects that define the actions that are performed when a specific movie clip event occurs.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSPlaceObject2_10&quot;&gt;encodedEvents&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of bytes containing encoded clip events can also be set. The encoded objects are typically generated by the parser in the Translate framework. The events array and encodedEvents cannot both be valid at the same time. Accessor methods used to set either of the attributes will set the other to null.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;Since only one object can be placed on a given layer an existing object on the display list can be identified by the layer it is displayed on rather than its identifier. Therefore Layer is the only required attribute. The remaining attributes are optional according to the different operation being performed:&lt;/p&gt;
-
-&lt;ul&gt;
-&lt;li&gt;If an existing object on the display list is being modified then only the layer number is required. Previously in the FSPlaceObject class both the identifier and the layer number were required.&lt;/li&gt;
-&lt;li&gt;If no coordinate transform is applied to the shape (the default is a unity transform that does not change the shape) then it is not encoded.&lt;/li&gt;
-&lt;li&gt;Similarly if no colour transform is applied to the shape (the default is a unity transform that does not change the shape's colour) then it is not encoded.&lt;/li&gt;
-&lt;li&gt;If a shape is not being morphed then the ratio attribute may be left at its default value (-1.0).&lt;/li&gt;
-&lt;li&gt;If a shape is not used to define a clipping area then the depth attribute may be left at its default value (0).&lt;/li&gt;
-&lt;li&gt;If a name is net assigned to an object the name attribute may be left its default value (an empty string).&lt;/li&gt;
-&lt;li&gt;If no events are being defined for a movie clip then the array of FSClipEvent object may be left empty.&lt;/li&gt;
-&lt;/ul&gt;
-
-&lt;p&gt;The class provides a range of constructors which define different subsets of the attributes according to the type of operation that will be performed on an object in the Flash Player's display list. If an attribute is not specified in a constructor then it will be assigned a default value and will be omitted when the object is encoded.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-
-&lt;p&gt;The following code samples illustrate how to use the FSPlaceObject2 class to manipulate objects on the display list. These examples use constructors with the most convenient (simplest) arguments. To define more complex place operations constructors are provided that take larger numbers of arguments and allow more complex transformations to be specified.&lt;/p&gt;
-
-&lt;p&gt;1. Display an object.&lt;br/&gt;
-To display an object at a given location the placeType, identifier, layer number and x,y coordinates are required.&lt;/p&gt;
-
-&lt;pre&gt;
-// Add the shape to the display list - on layer 1 at coordinates (400, 400)
-// The constructor allows just the x and y coordinate to be defined, the
-// FSCoordTransform object is constructed internally.
-
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......);
-
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;2. Move an object.&lt;br/&gt;
-To move an object only the layer number is required. This simplifies the code required to manipulate existing objects when compared to the original FSPlaceObject class.&lt;/p&gt;
-
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-
-// Move shape to a new location.
-movie.add(new FSPlaceObject2(1, 250, 300));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;3. Replace an existing object with another.&lt;br/&gt;
-To move an object only the layer number is required. This simplifies the code required to manipulate existing objects when compared to the original FSPlaceObject class.&lt;/p&gt;
-
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-
-// Replace the shape.
-movie.add(new FSPlaceObject2(newShape.getIdentifier(), 1));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;4. Defining a clipping layer.&lt;br/&gt;
-The number of layers to clip using the outline of the shape as a path can be specified when placing the shape on the display list.&lt;/p&gt;
-
-&lt;pre&gt;
-// Add the shape to the display list and clip objects on the next two layers
-
-currentLayer = 1;
-clipTo = currentLayer + 2;
-
-movie.add(new FSPlaceObject2(shape.getIdentifier(), currentLayer, clipTo, 400, 400));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;5. Controlling the morphing process.&lt;br/&gt;
-The ratio attribute controls the progress as an FSDefineMorphShape object changes from one shape into another.&lt;/p&gt;
-
-&lt;pre&gt;
-FSShape triangle = new FSShape(....);
-FSShape hexagon = new FSShape(....);
-
-FSDefineMorphShape shape = new FSDefineMorphShape(movie.newIdentifier(), ...., triangle, hexagon);
-
-movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 400, 400));
-
-// Morph the shapes over 10 frames
-
-for (float i=0.1; i&lt;1.0; i+= 0.1)
+ * FSPlaceObject2 is used to add and manipulate objects (shape, button, etc.) on
+ * the Flash Player's display list.
+ * 
+ * &lt;p&gt;
+ * FSPlaceObject2 supersedes the FSPlaceObject class providing more
+ * functionality and easier manipulation of objects in the display list through
+ * the following operations:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;Place a new shape on the display list.&lt;/li&gt;
+ * &lt;li&gt;Change an existing shape by moving it to new location or changing its
+ * appearance.&lt;/li&gt;
+ * &lt;li&gt;Replace an existing shape with a another.&lt;/li&gt;
+ * &lt;li&gt;Define clipping layers to mask objects displayed in front of a shape.&lt;/li&gt;
+ * &lt;li&gt;Control the morphing process that changes one shape into another.&lt;/li&gt;
+ * &lt;li&gt;Assign names to objects rather than using their identifiers.&lt;/li&gt;
+ * &lt;li&gt;Define the sequence of actions that are executed when an event occurs in
+ * movie clip.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * &lt;b&gt;Clipping Depth&lt;/b&gt;&lt;br/&gt; With the introduction of Flash 3 the display
+ * list supported a clipping layer. This allowed the outline of an object to
+ * define a clipping path that is used to mask other objects placed in front of
+ * it. The clipping depth can be set to mask objects between the layer
+ * containing the clipping path and a specified layer.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&lt;b&gt;Shape Morphing&lt;/b&gt;&lt;br/&gt; Shapes that will be morphed are defined using
+ * the FSDefineMorphShape class which defines a start and end shape. The Flash
+ * Player performs the interpolation that transforms one shape into another. The
+ * progress of the morphing process is controlled by a ratio which ranges from
+ * 0.0 to 1.0, where 0 generates a shape identical to the starting shape in the
+ * FSDefineMorphShape object and 1.0 generates the shape at the end of the
+ * morphing process.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&lt;b&gt;Movie Clip Events&lt;/b&gt;&lt;br/&gt; With the introduction of Flash 5, movie
+ * clips (defined using the FSDefineMovieClip class) could specify sequences of
+ * actions that would be performed in response to mouse or keyboard events. The
+ * actions are specified using FSClipEvent objects and the FSPlaceObject2 class
+ * is used to register the actions in response to a particular event with the
+ * Flash player. Multiple events can be handled by defining an FSClipEvent for
+ * each type of event. For more information see the FSClipEvent class.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;place&lt;/td&gt;
+ * &lt;td&gt;Indicates whether a new object is being placed in the display list or an
+ * existing object is being modified or replaced.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the object to added to the display list.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;Defines the order in which objects are displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;transform&lt;/td&gt;
+ * &lt;td&gt;Optional. A coordinate transform defines the position, scale and
+ * rotation of the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;colorTransform&lt;/td&gt;
+ * &lt;td&gt;Optional. A colour transform defines any colour changes such as
+ * transparency effects.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;depth&lt;/td&gt;
+ * &lt;td&gt;Optional. The layer number up to which objects will be clipped by this
+ * object's outline.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;ratio&lt;/td&gt;
+ * &lt;td&gt;Optional. The point for the morphing process of a shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;Optional. A name to assign to the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;events&lt;/td&gt;
+ * &lt;td&gt;Optional. An array of FSClipEvent objects that define the actions that
+ * are performed when a specific movie clip event occurs.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;encodedEvents&lt;/td&gt;
+ * &lt;td&gt;An array of bytes containing encoded clip events can also be set. The
+ * encoded objects are typically generated by the parser in the Translate
+ * framework. The events array and encodedEvents cannot both be valid at the
+ * same time. Accessor methods used to set either of the attributes will set the
+ * other to null.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Since only one object can be placed on a given layer an existing object on
+ * the display list can be identified by the layer it is displayed on rather
+ * than its identifier. Therefore Layer is the only required attribute. The
+ * remaining attributes are optional according to the different operation being
+ * performed:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;If an existing object on the display list is being modified then only
+ * the layer number is required. Previously in the FSPlaceObject class both the
+ * identifier and the layer number were required.&lt;/li&gt;
+ * &lt;li&gt;If no coordinate transform is applied to the shape (the default is a
+ * unity transform that does not change the shape) then it is not encoded.&lt;/li&gt;
+ * &lt;li&gt;Similarly if no colour transform is applied to the shape (the default is
+ * a unity transform that does not change the shape's colour) then it is not
+ * encoded.&lt;/li&gt;
+ * &lt;li&gt;If a shape is not being morphed then the ratio attribute may be left at
+ * its default value (-1.0).&lt;/li&gt;
+ * &lt;li&gt;If a shape is not used to define a clipping area then the depth
+ * attribute may be left at its default value (0).&lt;/li&gt;
+ * &lt;li&gt;If a name is net assigned to an object the name attribute may be left
+ * its default value (an empty string).&lt;/li&gt;
+ * &lt;li&gt;If no events are being defined for a movie clip then the array of
+ * FSClipEvent object may be left empty.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * The class provides a range of constructors which define different subsets of
+ * the attributes according to the type of operation that will be performed on
+ * an object in the Flash Player's display list. If an attribute is not
+ * specified in a constructor then it will be assigned a default value and will
+ * be omitted when the object is encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The following code samples illustrate how to use the FSPlaceObject2 class to
+ * manipulate objects on the display list. These examples use constructors with
+ * the most convenient (simplest) arguments. To define more complex place
+ * operations constructors are provided that take larger numbers of arguments
+ * and allow more complex transformations to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Display an object.&lt;br/&gt; To display an object at a given location the
+ * placeType, identifier, layer number and x,y coordinates are required.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Add the shape to the display list - on layer 1 at coordinates (400, 400)
+ *  // The constructor allows just the x and y coordinate to be defined, the
+ *  // FSCoordTransform object is constructed internally.
+ * 
+ *  FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), ......);
+ * 
+ *  movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Move an object.&lt;br/&gt; To move an object only the layer number is required.
+ * This simplifies the code required to manipulate existing objects when
+ * compared to the original FSPlaceObject class.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Move shape to a new location.
+ * movie.add(new FSPlaceObject2(1, 250, 300));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Replace an existing object with another.&lt;br/&gt; To move an object only the
+ * layer number is required. This simplifies the code required to manipulate
+ * existing objects when compared to the original FSPlaceObject class.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Replace the shape.
+ * movie.add(new FSPlaceObject2(newShape.getIdentifier(), 1));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 4. Defining a clipping layer.&lt;br/&gt; The number of layers to clip using the
+ * outline of the shape as a path can be specified when placing the shape on the
+ * display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list and clip objects on the next two layers
+ * 
+ * currentLayer = 1;
+ * clipTo = currentLayer + 2;
+ * 
+ * movie.add(new FSPlaceObject2(shape.getIdentifier(), currentLayer, clipTo, 400,
+ * 				400));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 5. Controlling the morphing process.&lt;br/&gt; The ratio attribute controls the
+ * progress as an FSDefineMorphShape object changes from one shape into another.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSShape triangle = new FSShape(....);
+ *  FSShape hexagon = new FSShape(....);
+ * 
+ *  FSDefineMorphShape shape = new FSDefineMorphShape(movie.newIdentifier(), ...., triangle, hexagon);
+ * 
+ *  movie.add(new FSPlaceObject2(shape.getIdentifier(), 1, 0.0, 400, 400));
+ * 
+ *  // Morph the shapes over 10 frames
+ * 
+ *  for (float i=0.1; i&lt;1.0; i+= 0.1)
+ *  {
+ *  movie.add(new FSPlaceObject(1, i));
+ *  movie.add(new FSShowFrame());
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 6. Defining a movie clip event.&lt;br/&gt; FSClipEvent objects are ONLY used to
+ * define the sequence of actions executed when a particular event occurs in a
+ * movie clip.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Define an array of clip events that will contain one event that defines the
+ *  // behaviour of the movie clip in response to a mouse down event.
+ * 
+ *  ArrayList events = new ArrayList();
+ * 
+ *  FSClipEvent clipEvent = new FSClipEvent(FSClipEvent.MouseDown);
+ * 
+ *  // Add one or more actions for the mouse down event.
+ * 
+ *  clipEvent.add(...);
+ *  ...
+ * 
+ *  // Add the clip event to the array of events for the movie clip.
+ * 
+ *  events.add(clipEvent);
+ * 
+ *  // Create the commands to animate the movie clip.
+ * 
+ *  ArrayList commands = new ArrayList();
+ * 
+ *  commands.add(...);
+ * 
+ *  FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+ * 
+ *  // Now place the movie clip on the screen on layer 1 at (400, 400).
+ * 
+ *  movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPlaceObject2 class represents the PlaceObject2 tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSPlaceObject2 extends FSMovieObject
 {
-    movie.add(new FSPlaceObject(1, i));
-    movie.add(new FSShowFrame());
-}
-&lt;/pre&gt;
+	/* Update an existing object on the display list */
+	public static final int Modify = 1;
 
-&lt;p&gt;6. Defining a movie clip event.&lt;br/&gt;
-FSClipEvent objects are ONLY used to define the sequence of actions executed when a particular event occurs in a movie clip.&lt;/p&gt;
+	/* Add a new object to the display list */
+	public static final int New = 2;
 
-&lt;pre&gt;
-// Define an array of clip events that will contain one event that defines the
-// behaviour of the movie clip in response to a mouse down event.
+	/* Replace an existing object on the display list with a new one */
+	public static final int Replace = 3;
 
-ArrayList events = new ArrayList();
+	private int place = New;
+	private int layer = 0;
+	private int identifier = 0;
+	private FSCoordTransform transform = null;
+	private FSColorTransform colorTransform = null;
+	private float ratio = -1.0f;
+	private int clippingDepth = 0;
+	private String name = null;
+	private ArrayList clipEvents = null;
+	private byte[] encodedEvents = null;
 
-FSClipEvent clipEvent = new FSClipEvent(FSClipEvent.MouseDown);
+	/**
+	 * Construct an FSPlaceObject2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPlaceObject2(FSCoder coder)
+	{
+		super(PlaceObject2);
+		decode(coder);
+	}
 
-// Add one or more actions for the mouse down event.
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new object on the display
+	 * list at the coordinates on the screen.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, int xLocation,
+							int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-clipEvent.add(...);
-...
+	/**
+	 * Constructs an FSPlaceObject2 object to place new morphing shape on the
+	 * display list at the coordinates on the screen.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aRatio
+	 *            the ratio of the progress in morphing the shape.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, float aRatio,
+							int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setRatio(aRatio);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-// Add the clip event to the array of events for the movie clip.
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new shape on the display
+	 * list with the specified coordinate and optional colour transform.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+	}
 
-events.add(clipEvent);
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new shape on the display
+	 * list with the specified coordinate and optional colour transform.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 * @param aColorTransform
+	 *            a FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer,
+							FSCoordTransform aTransform,
+							FSColorTransform aColorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(aTransform);
+		setColorTransform(aColorTransform);
+	}
 
-// Create the commands to animate the movie clip.
+	/**
+	 * Constructs an FSPlaceObject2 object to place a new shape on the display
+	 * list at the coordinates on the screen that defines a clipping path that
+	 * will clip objects for the specified number of layers.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param aDepth
+	 *            the layer number up to which objects will be clipped by this
+	 *            object's outline.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, int aDepth,
+							int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setClippingDepth(aDepth);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-ArrayList commands = new ArrayList();
+	/**
+	 * Constructs an FSPlaceObject2 object that places a new, named movie clip
+	 * on the display list at the coordinates on the screen.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new movie clip to be displayed.
+	 * @param aLayer
+	 *            the layer number on which the clip is being displayed.
+	 * @param anArray
+	 *            an array of FSClipEvent objects that define the events
+	 *            responded to by the movie clip.
+	 * @param aName
+	 *            a c-string that define a name for the movie clip.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, ArrayList anArray,
+							String aName, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setClipEvents(anArray);
+		setName(aName);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-commands.add(...);
+	/**
+	 * Constructs an FSPlaceObject2 object that places a new, named movie clip
+	 * on the display list at the coordinates on the screen. The array of bytes
+	 * contains the encoded FSClipEvent objects which specify the events and
+	 * actions that the movie clip will respond to. These are typically
+	 * generated using the classes in the Translate framework.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new movie clip to be displayed.
+	 * @param aLayer
+	 *            the layer number on which the clip is being displayed.
+	 * @param bytes
+	 *            an array of encoded clip event objects.
+	 * @param aName
+	 *            a c-string that define a name for the movie clip.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer, byte[] bytes,
+							String aName, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.New);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setEncodedEvents(bytes);
+		setName(aName);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-FSDefineMovieClip movieClip = new FSDefineMovieClip(movie.newIdentifier(), commands);
+	/**
+	 * Constructs an FSPlaceObject2 object that replaces the object at the
+	 * specified layer in the display list, aLayer with the object with the
+	 * identifier, anIdentifier. The location and transforms currently applied
+	 * to the object being replaced will be preserved.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the object that will replaced the one
+	 *            current displayed on &lt;i&gt;aLayer&lt;/i&gt;.
+	 * @param aLayer
+	 *            the layer number on which the object being replaced is
+	 *            displayed.
+	 */
+	public FSPlaceObject2(int anIdentifier, int aLayer)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Replace);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+	}
 
-// Now place the movie clip on the screen on layer 1 at (400, 400).
+	/**
+	 * Constructs an FSPlaceObject2 object that changes the location of the
+	 * object in the display list at layer, aLayer to the coordinates (x,y).
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int aLayer, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-movie.add(new FSPlaceObject2(movieClip.getIdentifier(), 1, events, 400, 400));
-&lt;/pre&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that applies the specified coordinate
+	 * transform to the object in the display list at layer, aLayer.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aLayer, FSCoordTransform transform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setTransform(transform);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Constructs an FSPlaceObject2 object that applied the specified colour
+	 * transform to the object in the display list at layer, aLayer.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param colorTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aLayer, FSColorTransform colorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setColorTransform(colorTransform);
+	}
 
-&lt;p&gt;The FSPlaceObject2 class represents the PlaceObject2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */  
-public class FSPlaceObject2 extends FSMovieObject
-{
-    /* Update an existing object on the display list */
-    public static final int Modify = 1;
-    /* Add a new object to the display list */
-    public static final int New = 2;
-    /* Replace an existing object on the display list with a new one */
-    public static final int Replace = 3;
-    
-    private int place = New;
-    private int layer = 0;
-    private int identifier = 0;
+	/**
+	 * Constructs an FSPlaceObject2 object that applies the specified coordinate
+	 * and colour transforms to the object in the display list at layer, aLayer.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 * @param colorTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aLayer, FSCoordTransform transform,
+							FSColorTransform colorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setTransform(transform);
+		setColorTransform(colorTransform);
+	}
 
-    private FSCoordTransform transform = null;
-    private FSColorTransform colorTransform = null;
+	/**
+	 * Constructs an FSPlaceObject2 object that changes the location of the
+	 * object in the display list at layer, aLayer to the coordinates (x,y).
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param aRatio
+	 *            the ratio of the progress in morphing the shape.
+	 * @param xLocation
+	 *            the x-coordinate where the object will be displayed.
+	 * @param yLocation
+	 *            the y-coordinate where the object will be displayed.
+	 */
+	public FSPlaceObject2(int aLayer, float aRatio, int xLocation, int yLocation)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setRatio(aRatio);
+		setTransform(new FSCoordTransform(xLocation, yLocation));
+	}
 
-    private float ratio = -1.0f;
-    private int clippingDepth = 0;
+	/**
+	 * Constructs an FSPlaceObject2 object that modifies the morphing shape
+	 * located on layer, aLayer in the display list. The progress of the
+	 * morphing process is controlled by aRatio.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 * @param aRatio
+	 *            the ratio of the progress in morphing the shape.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed.
+	 */
+	public FSPlaceObject2(int aLayer, float aRatio, FSCoordTransform transform)
+	{
+		super(PlaceObject2);
+		setPlaceType(FSPlaceObject2.Modify);
+		setLayer(aLayer);
+		setRatio(aRatio);
+		setTransform(transform);
+	}
 
-    private String name = null;
-    private ArrayList clipEvents = null;
-    private byte[] encodedEvents = null;
-        
-    /**
-     * Construct an FSPlaceObject2 object, initialising it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPlaceObject2(FSCoder coder)
-    {
-        super(PlaceObject2);
-        decode(coder);
-    }
-    /** Constructs an FSPlaceObject2 object to place a new object on the display list at the coordinates on the screen.
+	/**
+	 * Constructs an FSPlaceObject2 object with the specified placement type,
+	 * object identifier, layer number, coordinate transform and colour
+	 * transform. The exact operation performed is dependent on the placement
+	 * type specified.
+	 * 
+	 * @param aPlace
+	 *            the type of operation to be performed, either New, Modify or
+	 *            Replace.
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 * @param aLayer
+	 *            the layer number on which an object is being displayed.
+	 * @param transform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 * @param colorTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed in the display list at layer, aLayer.
+	 */
+	public FSPlaceObject2(int aPlace, int anIdentifier, int aLayer,
+							FSCoordTransform transform,
+							FSColorTransform colorTransform)
+	{
+		super(PlaceObject2);
+		setPlaceType(aPlace);
+		setIdentifier(anIdentifier);
+		setLayer(aLayer);
+		setTransform(transform);
+		setColorTransform(colorTransform);
+	}
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+	/**
+	 * Constructs an FSPlaceObject2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSPlaceObject2 object.
+	 */
+	public FSPlaceObject2(FSPlaceObject2 obj)
+	{
+		super(obj);
+		place = obj.place;
+		layer = obj.layer;
+		identifier = obj.identifier;
 
-    /** Constructs an FSPlaceObject2 object to place new morphing shape on the display list at the coordinates on the screen.
+		if (obj.transform != null)
+			transform = new FSCoordTransform(obj.transform);
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aRatio the ratio of the progress in morphing the shape.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, float aRatio, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setRatio(aRatio);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+		if (obj.colorTransform != null)
+			colorTransform = new FSColorTransform(obj.colorTransform);
 
-    /** Constructs an FSPlaceObject2 object to place a new shape on the display list with the specified coordinate and optional colour transform.
+		ratio = obj.ratio;
+		clippingDepth = obj.clippingDepth;
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aTransform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, FSCoordTransform aTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-    }
+		if (obj.name != null)
+			name = new String(obj.name);
 
-    /** Constructs an FSPlaceObject2 object to place a new shape on the display list with the specified coordinate and optional colour transform.
+		if (obj.clipEvents != null)
+		{
+			clipEvents = new ArrayList(obj.clipEvents.size());
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aTransform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        @param aColorTransform a FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, FSCoordTransform aTransform, FSColorTransform aColorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(aTransform);
-        setColorTransform(aColorTransform);
-    }
+			for (Iterator i = obj.clipEvents.iterator(); i.hasNext();)
+				clipEvents.add(((FSClipEvent) i.next()).clone());
+		} else
+		{
+			encodedEvents = Transform.clone(encodedEvents);
+		}
+	}
 
-    /** Constructs an FSPlaceObject2 object to place a new shape on the display list at the coordinates on the screen that defines a clipping path that will clip objects for the specified number of layers.
+	/**
+	 * Adds a clip event to the array of clip events. If the object already
+	 * contains a set of encoded clip event objects they will be deleted.
+	 * 
+	 * @param aClipEvent
+	 *            a clip event object.
+	 */
+	public void add(FSClipEvent aClipEvent)
+	{
+		if (clipEvents == null)
+			clipEvents = new ArrayList();
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        @param aLayer the layer number on which an object is being displayed.
-        @param aDepth the layer number up to which objects will be clipped by this object's outline.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, int aDepth, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setClippingDepth(aDepth);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+		clipEvents.add(aClipEvent);
+		encodedEvents = null;
+	}
 
-    /** Constructs an FSPlaceObject2 object that places a new, named movie clip on the display list at the coordinates on the screen.
+	/**
+	 * Gets the array of FSClipEvent object that define the actions that will be
+	 * executed in response to events that occur in the FSDefineMovieClip being
+	 * placed.
+	 * 
+	 * @return the array of clip events
+	 */
+	public ArrayList getClipEvents()
+	{
+		return clipEvents;
+	}
 
-        @param anIdentifier the identifier of a new movie clip to be displayed.
-        @param aLayer the layer number on which the clip is being displayed.
-        @param anArray an array of FSClipEvent objects that define the events responded to by the movie clip.
-        @param aName a c-string that define a name for the movie clip.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer, ArrayList anArray, String aName, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setClipEvents(anArray);
-        setName(aName);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
-    
-    /** Constructs an FSPlaceObject2 object that places a new, named movie clip 
-     * on the display list at the coordinates on the screen. The array of bytes
-     * contains the encoded FSClipEvent objects which specify the events and 
-     * actions that the movie clip will respond to. These are typically generated
-     * using the classes in the Translate framework.
-     * 
-     * @param anIdentifier the identifier of a new movie clip to be displayed.
-     * @param aLayer the layer number on which the clip is being displayed.
-     * @param bytes an array of encoded clip event objects.
-     * @param aName a c-string that define a name for the movie clip.
-     * @param xLocation the x-coordinate where the object will be displayed.
-     * @param yLocation the y-coordinate where the object will be displayed.
-     */
-    public FSPlaceObject2(int anIdentifier, int aLayer, byte[] bytes, String aName, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.New);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setEncodedEvents(bytes);
-        setName(aName);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
-    
-    /** Constructs an FSPlaceObject2 object that replaces the object at the specified layer in the display list, aLayer with the object with the identifier, anIdentifier. The location and transforms currently applied to the object being replaced will be preserved.
+	/**
+	 * Set the array of Clip events. Clip Events are only valid for movie clips
+	 * and the argument should be set to null when placing other types of
+	 * object.
+	 * 
+	 * If the object already contains a set of encoded clip event objects they
+	 * will be deleted.
+	 * 
+	 * @param anArray
+	 *            an array of FSClipEvent objects.
+	 */
+	public void setClipEvents(ArrayList anArray)
+	{
+		clipEvents = anArray;
 
-        @param anIdentifier the identifier of the object that will replaced the one current displayed on &lt;i&gt;aLayer&lt;/i&gt;.
-        @param aLayer the layer number on which the object being replaced is displayed.
-        */
-    public FSPlaceObject2(int anIdentifier, int aLayer)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Replace);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-    }
+		if (encodedEvents != null)
+			encodedEvents = null;
+	}
 
-    /** Constructs an FSPlaceObject2 object that changes the location of the object in the display list at layer, aLayer to the coordinates (x,y).
+	/**
+	 * Set the encoded clip event objects generated by the classes in the
+	 * Translate framework. If the object already contains an array of clip
+	 * events objects then they will be deleted.
+	 * 
+	 * @param bytes
+	 *            the array of encoded clip events.
+	 */
+	public void setEncodedEvents(byte[] bytes)
+	{
+		encodedEvents = bytes;
+		clipEvents = null;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int aLayer, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+	/**
+	 * Gets the type of place operation being performed.
+	 * 
+	 * @return the placement type.
+	 */
+	public int getPlaceType()
+	{
+		return place;
+	}
 
-    /** Constructs an FSPlaceObject2 object that applies the specified coordinate transform to the object in the display list at layer, aLayer.
+	/**
+	 * Gets the Layer on which the object will be displayed in the display list.
+	 * 
+	 * @return the layer number being referenced.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param transform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int aLayer, FSCoordTransform transform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setTransform(transform);
-    }
+	/**
+	 * Gets the identifier of the object to be placed. This is only required
+	 * when placing an object for the first time. Subsequent references to the
+	 * object on this layer can simply use the layer number.
+	 * 
+	 * @return the identifier of an object being placed on the display list.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-    /** Constructs an FSPlaceObject2 object that applied the specified colour transform to the object in the display list at layer, aLayer.
+	/**
+	 * Gets the coordinate transform.
+	 * 
+	 * @return the FSCoordTransform that will be applied to an object in the
+	 *         display list.
+	 */
+	public FSCoordTransform getTransform()
+	{
+		return transform;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param colorTransform an FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int aLayer, FSColorTransform colorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setColorTransform(colorTransform);
-    }
+	/**
+	 * Gets the colour transform.
+	 * 
+	 * @return the FSColorTransform that will be applied to an object in the
+	 *         display list.
+	 */
+	public FSColorTransform getColorTransform()
+	{
+		return colorTransform;
+	}
 
-    /** Constructs an FSPlaceObject2 object that applies the specified coordinate and colour transforms to the object in the display list at layer, aLayer.
+	/**
+	 * Gets the morph ratio, in the range 0.0 to 1.0 that defines the progress
+	 * in the morphing process performed by the Flash Player from the defined
+	 * start and end shapes. A value of 0 indicates the start of the process and
+	 * 65535 the end.
+	 * 
+	 * @return the morph ratio, in the range 0.0..1.0.
+	 */
+	public float getRatio()
+	{
+		return ratio;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param transform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        @param colorTransform an FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-        */
-    public FSPlaceObject2(int aLayer, FSCoordTransform transform, FSColorTransform colorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setTransform(transform);
-        setColorTransform(colorTransform);
-    }
+	/**
+	 * Gets the number of layers that will be clipped by the object placed on
+	 * the layer specified in this object.
+	 * 
+	 * @return the number of layers that will be clipped.
+	 */
+	public int getClippingDepth()
+	{
+		return clippingDepth;
+	}
 
-    /** Constructs an FSPlaceObject2 object that changes the location of the object in the display list at layer, aLayer to the coordinates (x,y).
+	/**
+	 * Gets the name of the object.
+	 * 
+	 * @return the name assigned to an object.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param aRatio the ratio of the progress in morphing the shape.
-        @param xLocation the x-coordinate where the object will be displayed.
-        @param yLocation the y-coordinate where the object will be displayed.
-        */
-    public FSPlaceObject2(int aLayer, float aRatio, int xLocation, int yLocation)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setRatio(aRatio);
-        setTransform(new FSCoordTransform(xLocation, yLocation));
-    }
+	/**
+	 * Sets the type of placement.
+	 * 
+	 * @param aType
+	 *            the type of operation to be performed, either New, Modify or
+	 *            Replace.
+	 */
+	public void setPlaceType(int aType)
+	{
+		place = aType;
+	}
 
-    /** Constructs an FSPlaceObject2 object that modifies the morphing shape located on layer, aLayer in the display list. The progress of the morphing process is controlled by aRatio.
+	/**
+	 * Sets the layer at which the object will be placed.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is being displayed.
+	 */
+	public void setLayer(int aLayer)
+	{
+		layer = aLayer;
+	}
 
-        @param aLayer the layer number on which the object is being displayed.
-        @param aRatio the ratio of the progress in morphing the shape.
-        @param transform an FSCoordTransform object that will be applied to the object displayed.
-        */
-    public FSPlaceObject2(int aLayer, float aRatio, FSCoordTransform transform)
-    {
-        super(PlaceObject2);
-        setPlaceType(FSPlaceObject2.Modify);
-        setLayer(aLayer);
-        setRatio(aRatio);
-        setTransform(transform);
-    }
-    
-    /** Constructs an FSPlaceObject2 object with the specified placement type, object identifier, layer number, coordinate transform and colour transform. The exact operation performed is dependent on the placement type specified.
+	/**
+	 * Sets the identifier of the object.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of a new object to be displayed.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-     @param aPlace the type of operation to be performed, either New, Modify or Replace.
-     @param anIdentifier the identifier of a new object to be displayed.
-     @param aLayer the layer number on which an object is being displayed.
-     @param transform an FSCoordTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-     @param colorTransform an FSColorTransform object that will be applied to the object displayed in the display list at layer, aLayer.
-     */
-    public FSPlaceObject2(int aPlace, int anIdentifier, int aLayer, FSCoordTransform transform, FSColorTransform colorTransform)
-    {
-        super(PlaceObject2);
-        setPlaceType(aPlace);
-        setIdentifier(anIdentifier);
-        setLayer(aLayer);
-        setTransform(transform);
-        setColorTransform(colorTransform);
-    }
-    /**
-     * Constructs an FSPlaceObject2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSPlaceObject2 object.
-     */
-    public FSPlaceObject2(FSPlaceObject2 obj)
-    {
-        super(obj);
-        place = obj.place;
-        layer = obj.layer;
-        identifier = obj.identifier;
-        
-        if (obj.transform != null)
-            transform = new FSCoordTransform(obj.transform);
-        
-        if (obj.colorTransform != null)
-            colorTransform = new FSColorTransform(obj.colorTransform);
-        
-        ratio = obj.ratio;
-        clippingDepth = obj.clippingDepth;
-        
-        if (obj.name != null)
-            name = new String(obj.name);
-        
-        if (obj.clipEvents != null)
-        {
-            clipEvents = new ArrayList(obj.clipEvents.size());
-            
-            for (Iterator i = obj.clipEvents.iterator(); i.hasNext();)
-                clipEvents.add(((FSClipEvent)i.next()).clone());
-        }
-        else
-        {
-            encodedEvents = Transform.clone(encodedEvents);
-        }
-    }    
+	/**
+	 * Sets the coordinate transform that defines the position where the object
+	 * will be displayed. The argument may be null if the location of the object
+	 * is not being changed.
+	 * 
+	 * @param aTransform
+	 *            an FSCoordTransform object that will be applied to the object
+	 *            displayed.
+	 */
+	public void setTransform(FSCoordTransform aTransform)
+	{
+		transform = aTransform;
+	}
 
-    /** Adds a clip event to the array of clip events. If the object already
-     * contains a set of encoded clip event objects they will be deleted.
-     *
-     * @param aClipEvent a clip event object.
-     */
-    public void add(FSClipEvent aClipEvent)
-    {
-        if (clipEvents == null)
-            clipEvents = new ArrayList();
-            
-        clipEvents.add(aClipEvent);
-        encodedEvents = null;
-    }
-    /** 
-     * Gets the array of FSClipEvent object that define the actions that will be 
-     * executed in response to events that occur in the FSDefineMovieClip being placed.
-     *
-     * @return the array of clip events
-     */
-    public ArrayList getClipEvents()
-    {
-        return clipEvents;
-    }
+	/**
+	 * Sets the colour transform that defines the colour effects applied to the
+	 * object. The argument may be null if the color of the object is not being
+	 * changed.
+	 * 
+	 * @param aTransform
+	 *            an FSColorTransform object that will be applied to the object
+	 *            displayed.
+	 */
+	public void setColorTransform(FSColorTransform aTransform)
+	{
+		colorTransform = aTransform;
+	}
 
-    /** 
-     * Set the array of Clip events. Clip Events are only valid for movie clips 
-     * and the argument should be set to null when placing other types of object.
-     * 
-     * If the object already contains a set of encoded clip event objects they 
-     * will be deleted.
-     *
-     * @param anArray an array of FSClipEvent objects.
-     */
-    public void setClipEvents(ArrayList anArray)
-    {
-        clipEvents = anArray;
- 
-        if (encodedEvents != null)
-           encodedEvents = null;
-    }
+	/**
+	 * Sets point of the morphing process for a morph shape in the range 0..1.
+	 * May be set to zero if the shape being placed is not being morphed.
+	 * 
+	 * @param aNumber
+	 *            the progress in the morphing process.
+	 */
+	public void setRatio(float aNumber)
+	{
+		ratio = aNumber;
+	}
 
-    /** 
-     * Set the encoded clip event objects generated by the classes in the Translate 
-     * framework. If the object already contains an array of clip events objects
-     * then they will be deleted.
-     * 
-     * @param bytes the array of encoded clip events.
-     */
-    public void setEncodedEvents(byte[] bytes)
-    {
-        encodedEvents = bytes;
-        clipEvents = null;
-    }
+	/**
+	 * Sets the number of layers that this object will mask. May be set to zero
+	 * if the shape being placed does not define a clipping area.
+	 * 
+	 * @param aNumber
+	 *            the number of layers clipped.
+	 */
+	public void setClippingDepth(int aNumber)
+	{
+		clippingDepth = aNumber;
+	}
 
-    /** Gets the type of place operation being performed.
+	/**
+	 * Set the name of an object to be displayed. If a shape is not being
+	 * assigned a name then setting the argument to null will omit the attribute
+	 * when the object is encoded.
+	 * 
+	 * @param aString
+	 *            the name assigned to the object.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-        @return the placement type.
-        */
-    public int getPlaceType()
-    {
-        return place;
-    }
+	public Object clone()
+	{
+		FSPlaceObject2 anObject = (FSPlaceObject2) super.clone();
 
-    /** Gets the Layer on which the object will be displayed in the display list. 
+		anObject.transform = (transform != null) ? (FSCoordTransform) transform
+						.clone() : null;
+		anObject.colorTransform = (colorTransform != null) ? (FSColorTransform) colorTransform
+						.clone()
+						: null;
 
-        @return the layer number being referenced.
-        */
-    public int getLayer()
-    {
-        return layer;
-    }
+		if (clipEvents != null)
+		{
+			anObject.clipEvents = new ArrayList();
 
-    /** Gets the identifier of the object to be placed. This is only required when placing an object for the first time. Subsequent references to the object on this layer can simply use the layer number.
+			for (Iterator i = clipEvents.iterator(); i.hasNext();)
+				anObject.clipEvents.add(((FSClipEvent) i.next()).clone());
+		} else
+		{
+			anObject.encodedEvents = Transform.clone(encodedEvents);
+		}
+		return anObject;
+	}
 
-        @return the identifier of an object being placed on the display list.
-        */
-    public int getIdentifier()
-    {
-        return identifier;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the coordinate transform.
+		if (super.equals(anObject))
+		{
+			FSPlaceObject2 typedObject = (FSPlaceObject2) anObject;
 
-        @return the FSCoordTransform that will be applied to an object in the display list.
-        */
-    public FSCoordTransform getTransform()
-    {
-        return transform;
-    }
+			result = place == typedObject.place;
+			result = result &amp;&amp; layer == typedObject.layer;
+			result = result &amp;&amp; identifier == typedObject.identifier;
 
-    /** Gets the colour transform.
+			if (transform == null)
+				result = result &amp;&amp; (typedObject.transform == null);
+			else
+				result = result &amp;&amp; transform.equals(typedObject.transform);
 
-        @return the FSColorTransform that will be applied to an object in the display list.
-        */
-    public FSColorTransform getColorTransform()
-    {
-        return colorTransform;
-    }
+			if (colorTransform == null)
+				result = result &amp;&amp; (typedObject.colorTransform == null);
+			else
+				result = result
+								&amp;&amp; colorTransform
+												.equals(typedObject.colorTransform);
 
-    /** Gets the morph ratio, in the range 0.0 to 1.0 that defines the progress in the morphing process performed by the Flash Player from the defined start and end shapes. A value of 0 indicates the start of the process and 65535 the end.
+			result = result &amp;&amp; ratio == typedObject.ratio;
+			result = result &amp;&amp; clippingDepth == typedObject.clippingDepth;
 
-        @return the morph ratio, in the range 0.0..1.0.
-        */
-    public float getRatio()
-    {
-        return ratio;
-    }
+			if (name == null)
+				result = result &amp;&amp; (typedObject.name == null);
+			else
+				result = result &amp;&amp; name.equals(typedObject.name);
 
-    /** Gets the number of layers that will be clipped by the object placed on the layer specified in this object.
+			if (transform != null)
+				result = result &amp;&amp; transform.equals(typedObject.transform);
+			else
+				result = result &amp;&amp; transform == typedObject.transform;
 
-        @return the number of layers that will be clipped.
-        */
-    public int getClippingDepth()
-    { 
-        return clippingDepth;
-    }
+			if (clipEvents != null)
+				result = result &amp;&amp; clipEvents.equals(typedObject.clipEvents);
+			else
+				result = result
+								&amp;&amp; Transform.equals(encodedEvents,
+												typedObject.encodedEvents);
+		}
+		return result;
+	}
 
-    /** Gets the name of the object.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the name assigned to an object.
-        */
-    public String getName()
-    {
-        return name;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;place&quot;, place);
+			Transform.append(buffer, &quot;layer&quot;, layer);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;transform&quot;, transform, depth);
+			Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
+			Transform.append(buffer, &quot;ratio&quot;, ratio);
+			Transform.append(buffer, &quot;clippingDepth&quot;, clippingDepth);
+			Transform.append(buffer, &quot;name&quot;, name);
 
-    /** Sets the type of placement.
+			if (clipEvents != null)
+				Transform.append(buffer, &quot;clipEvents&quot;, clipEvents, depth);
+			else
+				buffer.append(&quot;clipEvents = &lt;data&gt;; &quot;);
 
-        @param aType the type of operation to be performed, either New, Modify or Replace.
-        */
-    public void setPlaceType(int aType)
-    {
-        place = aType;
-    }
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the layer at which the object will be placed. 
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param aLayer the layer number on which the object is being displayed.
-        */
-    public void setLayer(int aLayer)
-    {
-        layer = aLayer;
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    /** Sets the identifier of the object.
+		length += 3;
+		length += (place == 2 || place == 3) ? 2 : 0;
+		length += (containsTransform()) ? transform.length(coder) : 0;
+		length += (containsColorTransform(coder)) ? colorTransform
+						.length(coder) : 0;
+		length += (containsRatio()) ? 2 : 0;
+		length += (containsClippingDepth()) ? 2 : 0;
 
-        @param anIdentifier the identifier of a new object to be displayed.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		length += containsName() ? coder.strlen(name, true) : 0;
 
-    /** Sets the coordinate transform that defines the position where the object will be displayed. The argument may be null if the location of the object is not being changed.
+		if (containsClipEvents())
+		{
+			if (clipEvents != null)
+			{
+				int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
 
-        @param aTransform an FSCoordTransform object that will be applied to the object displayed.
-        */
-    public void setTransform(FSCoordTransform aTransform)
-    {
-        transform = aTransform;
-    }
+				length += 2 + eventSize;
 
-    /** Sets the colour transform that defines the colour effects applied to the object. The argument may be null if the color of the object is not being changed.
+				for (Iterator i = clipEvents.iterator(); i.hasNext();)
+					length += ((FSClipEvent) i.next()).length(coder);
 
-        @param aTransform an FSColorTransform object that will be applied to the object displayed.
-        */
-    public void setColorTransform(FSColorTransform aTransform)
-    {
-        colorTransform = aTransform;
-    }
+				length += eventSize;
+			} else
+			{
+				length += encodedEvents.length;
+			}
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
 
-    /** Sets point of the morphing process for a morph shape in the range 0..1. May be set to zero if the shape being placed is not being morphed.
+		return length;
+	}
 
-        @param aNumber the progress in the morphing process.
-        */
-    public void setRatio(float aNumber)
-    {
-        ratio = aNumber;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** 
-     * Sets the number of layers that this object will mask. May be set to zero 
-     * if the shape being placed does not define a clipping area.
+		coder.context[FSCoder.TransparentColors] = 1;
 
-        @param aNumber the number of layers clipped.
-        */
-    public void setClippingDepth(int aNumber)
-    {
-        clippingDepth = aNumber;
-    }
+		coder.writeBits(containsClipEvents() ? 1 : 0, 1);
+		coder.writeBits(containsClippingDepth() ? 1 : 0, 1);
+		coder.writeBits(containsName() ? 1 : 0, 1);
+		coder.writeBits(containsRatio() ? 1 : 0, 1);
+		coder.writeBits(containsColorTransform(coder) ? 1 : 0, 1);
+		coder.writeBits(containsTransform() ? 1 : 0, 1);
+		coder.writeBits(place, 2);
+		coder.writeWord(layer, 2);
 
-    /** Set the name of an object to be displayed. If a shape is not being assigned a name then setting the argument to null will omit the attribute when the object is encoded.
+		if (place == 2 || place == 3)
+			coder.writeWord(identifier, 2);
+		if (containsTransform())
+			transform.encode(coder);
+		if (containsColorTransform(coder))
+			colorTransform.encode(coder);
+		if (containsRatio())
+			coder.writeWord((int) (ratio * 65535.0f), 2);
 
-        @param aString the name assigned to the object.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+		// if (coder.context[FSCoder.Version] &gt; 5)
+		// {
+		if (containsName())
+		{
+			coder.writeString(name);
+			coder.writeWord(0, 1);
+		}
 
-    public Object clone()
-    {
-        FSPlaceObject2 anObject = (FSPlaceObject2)super.clone();
-        
-        anObject.transform = (transform != null) ? (FSCoordTransform)transform.clone() : null;
-        anObject.colorTransform = (colorTransform != null) ? (FSColorTransform)colorTransform.clone() : null;
-        
-        if (clipEvents != null)
-        {
-            anObject.clipEvents = new ArrayList();
-            
-            for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                anObject.clipEvents.add(((FSClipEvent)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedEvents = Transform.clone(encodedEvents);
-        }
-        return anObject;
-    }
+		if (containsClippingDepth())
+			coder.writeWord(clippingDepth, 2);
+		/*
+		 * } else { if (containsClippingDepth())
+		 * coder.writeWord(clippingDepth+1, 2);
+		 * 
+		 * if (containsName()) { coder.writeString(name); coder.writeWord(0, 1); } }
+		 */
+		if (containsClipEvents())
+		{
+			if (clipEvents != null)
+			{
+				int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
+				int eventMask = 0;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSPlaceObject2 typedObject = (FSPlaceObject2)anObject;
-            
-            result = place == typedObject.place;
-            result = result &amp;&amp; layer == typedObject.layer;
-            result = result &amp;&amp; identifier == typedObject.identifier;
-           
-            if (transform == null)
-                result = result &amp;&amp; (typedObject.transform == null);
-            else
-                result = result &amp;&amp; transform.equals(typedObject.transform);
+				coder.writeWord(0, 2);
 
-            if (colorTransform == null)
-                result = result &amp;&amp; (typedObject.colorTransform == null);
-            else
-                result = result &amp;&amp; colorTransform.equals(typedObject.colorTransform);
+				for (Iterator i = clipEvents.iterator(); i.hasNext();)
+					eventMask |= ((FSClipEvent) i.next()).getEvent();
 
-            result = result &amp;&amp; ratio == typedObject.ratio;
-            result = result &amp;&amp; clippingDepth == typedObject.clippingDepth;
+				coder.writeWord(eventMask, eventSize);
 
-            if (name == null)
-                result = result &amp;&amp; (typedObject.name == null);
-            else
-                result = result &amp;&amp; name.equals(typedObject.name);
-                
-            if (transform != null)
-                result = result &amp;&amp; transform.equals(typedObject.transform);
-            else
-                result = result &amp;&amp; transform == typedObject.transform;
+				for (Iterator i = clipEvents.iterator(); i.hasNext();)
+					((FSTransformObject) i.next()).encode(coder);
 
-            if (clipEvents != null)
-                result = result &amp;&amp; clipEvents.equals(typedObject.clipEvents);
-            else
-                result = result &amp;&amp; Transform.equals(encodedEvents, typedObject.encodedEvents);
-        }
-        return result;
-    }
+				coder.writeWord(0, eventSize);
+			} else
+			{
+				coder.writeBytes(encodedEvents);
+			}
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.endObject(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;place&quot;, place);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;transform&quot;, transform, depth);
-            Transform.append(buffer, &quot;colorTransform&quot;, colorTransform, depth);
-            Transform.append(buffer, &quot;ratio&quot;, ratio);
-            Transform.append(buffer, &quot;clippingDepth&quot;, clippingDepth);
-            Transform.append(buffer, &quot;name&quot;, name);
+	public void decode(FSCoder coder)
+	{
+		boolean containsClipEvents = false;
+		boolean containsClippingDepth = false;
+		boolean containsName = false;
+		boolean containsRatio = false;
+		boolean containsColorTransform = false;
+		boolean containsTransform = false;
 
-            if (clipEvents != null)
-                Transform.append(buffer, &quot;clipEvents&quot;, clipEvents, depth);
-            else
-                buffer.append(&quot;clipEvents = &lt;data&gt;; &quot;);
+		super.decode(coder);
 
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.context[FSCoder.TransparentColors] = 1;
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
+		containsClipEvents = coder.readBits(1, false) != 0 ? true : false;
+		containsClippingDepth = coder.readBits(1, false) != 0 ? true : false;
+		containsName = coder.readBits(1, false) != 0 ? true : false;
+		containsRatio = coder.readBits(1, false) != 0 ? true : false;
+		containsColorTransform = coder.readBits(1, false) != 0 ? true : false;
+		containsTransform = coder.readBits(1, false) != 0 ? true : false;
+		place = coder.readBits(2, false);
+		layer = coder.readWord(2, false);
 
-        coder.context[FSCoder.TransparentColors] = 1;
+		if (place == 2 || place == 3)
+			identifier = coder.readWord(2, false);
 
-        length += 3;
-        length += (place == 2 || place == 3) ? 2 : 0;
-        length += (containsTransform()) ? transform.length(coder) : 0;
-        length += (containsColorTransform(coder)) ? colorTransform.length(coder) : 0;
-        length += (containsRatio()) ? 2 : 0;
-        length += (containsClippingDepth()) ? 2 : 0;
-        
-        length += containsName() ? coder.strlen(name, true) : 0;
+		if (containsTransform)
+			transform = new FSCoordTransform(coder);
 
-        if (containsClipEvents())
-        {
-            if (clipEvents != null)
-            {
-                int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
-            
-                length += 2 + eventSize;
-            
-                for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                    length += ((FSClipEvent)i.next()).length(coder);
-                
-                length += eventSize;
-            }
-            else
-            {
-                length += encodedEvents.length;
-            }
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.context[FSCoder.TransparentColors] = 1;
+		if (containsColorTransform)
+			colorTransform = new FSColorTransform(coder);
 
-        coder.writeBits(containsClipEvents() ? 1 : 0, 1);
-        coder.writeBits(containsClippingDepth() ? 1 : 0, 1);
-        coder.writeBits(containsName() ? 1 : 0, 1);
-        coder.writeBits(containsRatio() ? 1 : 0, 1);
-        coder.writeBits(containsColorTransform(coder) ? 1 : 0, 1);
-        coder.writeBits(containsTransform() ? 1 : 0, 1);
-        coder.writeBits(place, 2);
-        coder.writeWord(layer, 2);
-        
-        if (place == 2 || place == 3)
-            coder.writeWord(identifier, 2);
-        if (containsTransform())
-            transform.encode(coder);
-        if (containsColorTransform(coder))
-            colorTransform.encode(coder);
-        if (containsRatio())
-            coder.writeWord((int)(ratio * 65535.0f), 2);
-            
-//        if (coder.context[FSCoder.Version] &gt; 5)
-//        {
-            if (containsName())
-            {
-                coder.writeString(name);
-                coder.writeWord(0, 1);
-            }
-    
-            if (containsClippingDepth())
-                coder.writeWord(clippingDepth, 2);
-/*        }
-        else
-        {
-            if (containsClippingDepth())
-                coder.writeWord(clippingDepth+1, 2);
+		if (containsRatio)
+			ratio = coder.readWord(2, false) / 65535.0f;
 
-            if (containsName())
-            {
-                coder.writeString(name);
-                coder.writeWord(0, 1);
-            }
-        }
-*/
-        if (containsClipEvents())
-        {
-            if (clipEvents != null)
-            {
-                int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
-                int eventMask = 0;
-            
-                coder.writeWord(0, 2);
+		if (containsName)
+			name = coder.readString();
 
-                for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                    eventMask |= ((FSClipEvent)i.next()).getEvent();
-           
-                coder.writeWord(eventMask, eventSize);
+		if (containsClippingDepth)
+			clippingDepth = coder.readWord(2, false);
 
-                for (Iterator i = clipEvents.iterator(); i.hasNext();)
-                    ((FSTransformObject)i.next()).encode(coder);
-                
-                coder.writeWord(0, eventSize);
-            }
-            else
-            {
-                coder.writeBytes(encodedEvents);
-            }
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsClipEvents = false;
-        boolean containsClippingDepth = false;
-        boolean containsName = false;
-        boolean containsRatio = false;
-        boolean containsColorTransform = false;
-        boolean containsTransform = false;
-       
-        super.decode(coder);
+		if (containsClipEvents)
+		{
+			int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
+			clipEvents = new ArrayList();
 
-        coder.context[FSCoder.TransparentColors] = 1;
+			coder.readWord(2, false);
+			coder.readWord(eventSize, false);
 
-        containsClipEvents = coder.readBits(1, false) != 0 ? true : false;
-        containsClippingDepth = coder.readBits(1, false) != 0 ? true : false;
-        containsName = coder.readBits(1, false) != 0 ? true : false;
-        containsRatio = coder.readBits(1, false) != 0 ? true : false;
-        containsColorTransform = coder.readBits(1, false) != 0 ? true : false;
-        containsTransform = coder.readBits(1, false) != 0 ? true : false;
-        place = coder.readBits(2, false);
-        layer = coder.readWord(2, false);
-        
-        if (place == 2 || place == 3)
-            identifier = coder.readWord(2, false);
-            
-        if (containsTransform)
-            transform = new FSCoordTransform(coder);
+			while (coder.scanWord(eventSize, false) != 0)
+				clipEvents.add(new FSClipEvent(coder));
 
-        if (containsColorTransform)
-            colorTransform = new FSColorTransform(coder);
+			coder.readWord(eventSize, false);
+		}
+		coder.context[FSCoder.TransparentColors] = 0;
+		coder.endObject(name());
+	}
 
-        if (containsRatio)
-            ratio = coder.readWord(2, false) / 65535.0f;
+	private boolean containsTransform()
+	{
+		return transform != null;
+	}
 
-        if (containsName)
-            name = coder.readString();
+	private boolean containsColorTransform(FSCoder coder)
+	{
+		return colorTransform != null;
+	}
 
-        if (containsClippingDepth)
-            clippingDepth = coder.readWord(2, false);
+	private boolean containsClipEvents()
+	{
+		return (clipEvents != null &amp;&amp; clipEvents.size() &gt; 0)
+						|| encodedEvents != null;
+	}
 
-        if (containsClipEvents)
-        {
-            int eventSize = coder.context[FSCoder.Version] &gt; 5 ? 4 : 2;
-            clipEvents = new ArrayList();
-            
-            coder.readWord(2, false);
-            coder.readWord(eventSize, false);
+	private boolean containsClippingDepth()
+	{
+		return clippingDepth &gt; 0;
+	}
 
-            while (coder.scanWord(eventSize, false) != 0)
-                clipEvents.add(new FSClipEvent(coder));
- 
-            coder.readWord(eventSize, false);
-        }
-        coder.context[FSCoder.TransparentColors] = 0;
-        coder.endObject(name());
-    }
+	private boolean containsName()
+	{
+		return name != null &amp;&amp; name.length() &gt; 0;
+	}
 
-    private boolean containsTransform()
-    {
-        return transform != null;
-    }
-
-    private boolean containsColorTransform(FSCoder coder)
-    {
-        return colorTransform != null;
-    }
-
-    private boolean containsClipEvents()
-    {
-        return (clipEvents != null &amp;&amp; clipEvents.size() &gt; 0) || encodedEvents != null;
-    }
-
-    private boolean containsClippingDepth()
-    {
-        return clippingDepth &gt; 0;
-    }
-
-    private boolean containsName()
-    {
-        return name != null &amp;&amp; name.length() &gt; 0;
-    }
-
-    private boolean containsRatio()
-    {
-        return ratio &gt;= 0.0;
-    }
+	private boolean containsRatio()
+	{
+		return ratio &gt;= 0.0;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSPointer.java
===================================================================
--- trunk/src/com/flagstone/transform/FSPointer.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSPointer.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,127 +31,145 @@
 package com.flagstone.transform;
 
 /**
-FSPointer defines an unsigned 32-bit pointer. 
- 
-&lt;p&gt;It is thought that this class was used by Macromedia's Generator product and 
-its exact function is not known. It is included in the framework for completeness.&lt;/p&gt;
+ * FSPointer defines an unsigned 32-bit pointer.
+ * 
+ * &lt;p&gt;
+ * It is thought that this class was used by Macromedia's Generator product and
+ * its exact function is not known. It is included in the framework for
+ * completeness.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;pointer&lt;/td&gt;
+ * &lt;td&gt;The pointer value.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPointer class represents the DefineBitsPtr tag from the Macromedia
+ * Flash (SWF) File Format Specification. It is not documented in later editions
+ * of the specification. It is not known when this tag was added.
+ * &lt;/p&gt;
+ */
+public class FSPointer extends FSMovieObject
+{
+	private int pointer = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSPointer object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPointer(FSCoder coder)
+	{
+		super(DefineBitsPtr);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSPointer object, specifying the pointer.
+	 * 
+	 * @param aPointer
+	 *            the pointer.
+	 */
+	public FSPointer(int aPointer)
+	{
+		super(DefineBitsPtr);
+		setPointer(aPointer);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPointer_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSPointer object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSPointer object.
+	 */
+	public FSPointer(FSPointer obj)
+	{
+		super(obj);
+		pointer = obj.pointer;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPointer_1&quot;&gt;pointer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The pointer value.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the value for the pointer.
+	 * 
+	 * @return the pointer value.
+	 */
+	public int getPointer()
+	{
+		return pointer;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the pointer.
+	 * 
+	 * @param aPointer
+	 *            the pointer.
+	 */
+	public void setPointer(int aPointer)
+	{
+		pointer = aPointer;
+	}
 
-&lt;p&gt;The FSPointer class represents the DefineBitsPtr tag from the Macromedia Flash 
-(SWF) File Format Specification. It is not documented in later editions of the 
-specification. It is not known when this tag was added.&lt;/p&gt;
- */  
-public class FSPointer extends FSMovieObject
-{
-    private int pointer = 0;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Construct an FSPointer object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPointer(FSCoder coder)
-    {
-        super(DefineBitsPtr);
-        decode(coder);
-    }
-    /** Constructs an FSPointer object, specifying the pointer.
+		if (super.equals(anObject))
+		{
+			FSPointer typedObject = (FSPointer) anObject;
 
-        @param aPointer the pointer.
-        */
-    public FSPointer(int aPointer)
-    {
-        super(DefineBitsPtr);
-        setPointer(aPointer);
-    }
-    /**
-     * Constructs an FSPointer object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSPointer object.
-     */
-    public FSPointer(FSPointer obj)
-    {
-        super(obj);
-        pointer = obj.pointer;
-    }    
+			result = pointer == typedObject.pointer;
+		}
+		return result;
+	}
 
-    /** Gets the value for the pointer.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the pointer value.
-        */
-    public int getPointer() { return pointer; }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;pointer&quot;, pointer);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the pointer.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 4;
 
-        @param aPointer the pointer.
-        */
-    public void setPointer(int aPointer)
-    {
-        pointer = aPointer;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSPointer typedObject = (FSPointer)anObject;
-            
-            result = pointer == typedObject.pointer;
-        }
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(pointer, 4);
+		coder.endObject(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;pointer&quot;, pointer);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 4;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(pointer, 4);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        pointer = coder.readWord(4, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		pointer = coder.readWord(4, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSProperty.java
===================================================================
--- trunk/src/com/flagstone/transform/FSProperty.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSProperty.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,91 +31,96 @@
 package com.flagstone.transform;
 
 /**
- * FSProperty is a lightweigth class used to hold codes that specify movie clip 
+ * FSProperty is a lightweight class used to hold codes that specify movie clip
  * and movie properties that will be pushed onto the Flash Player stack.
  * 
  * See FSPush for a list of available properties.
  */
 public class FSProperty extends FSTransformObject
 {
-    private int value = 0;
+	private int value = 0;
 
-    /**
-     * Construct an FSProperty object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSProperty(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**
-     * Construct an FSProperty object with the proerty value.
-     * 
-     * @param aValue an integer representing a movie property.
-     */
-    public FSProperty(int aValue)
-    {
-        setValue(aValue);
-    }
-    /**
-     * Constructs an FSProperty object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSProperty object.
-     */
-    public FSProperty(FSProperty obj)
-    {
-        value = obj.value;
-    }    
+	/**
+	 * Construct an FSProperty object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSProperty(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    public int getValue() 
-    {
-        return value;
-    }
+	/**
+	 * Construct an FSProperty object with the proerty value.
+	 * 
+	 * @param aValue
+	 *            an integer representing a movie property.
+	 */
+	public FSProperty(int aValue)
+	{
+		setValue(aValue);
+	}
 
-    public void setValue(int aValue) 
-    {
-        value = aValue;
-    }
+	/**
+	 * Constructs an FSProperty object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSProperty object.
+	 */
+	public FSProperty(FSProperty obj)
+	{
+		value = obj.value;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = value == ((FSProperty)anObject).getValue();
+	public int getValue()
+	{
+		return value;
+	}
 
-        return result;
-    }
+	public void setValue(int aValue)
+	{
+		value = aValue;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;value&quot;, value);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public int length(FSCoder coder)
-    { 
-        return 5;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.writeWord(1, 1);
-        coder.writeWord(value, 4);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        /* type */ coder.readWord(1, false);
-        value = coder.readWord(4, false);
-    }
+		if (super.equals(anObject))
+			result = value == ((FSProperty) anObject).getValue();
+
+		return result;
+	}
+
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;value&quot;, value);
+			buffer.append(&quot;}&quot;);
+		}
+	}
+
+	public int length(FSCoder coder)
+	{
+		return 5;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(1, 1);
+		coder.writeWord(value, 4);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		/* type */coder.readWord(1, false);
+		value = coder.readWord(4, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSProtect.java
===================================================================
--- trunk/src/com/flagstone/transform/FSProtect.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSProtect.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,159 +31,192 @@
 package com.flagstone.transform;
 
 /**
-FSProtect marks a file as not-readable, preventing the file from being loaded into an editor.
+ * FSProtect marks a file as not-readable, preventing the file from being loaded
+ * into an editor.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;password&lt;/td&gt;
+ * &lt;td&gt;An MD5 encrypted password.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * In order to use the debugger a password must be supplied. When encrypted
+ * using the MD5 algorithm it must match the value stored in the password
+ * attribute.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * IMPORTANT: this form of protection only works with Macromedia's Flash
+ * Authoring tool. Any application that parses Flash files can choose to ignore
+ * or delete this data structure therefore it is not safe to use this to protect
+ * the contents of a Flash file.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Transform will parse all Flash files containing the Protect data structure.
+ * Since the encoded data is can be removed by trivial scripts the level of
+ * copy-protection offered is minimal. Indeed the use of the Protect mechanism
+ * in Flash movies may lead to a false sense of security, putting proprietary
+ * information at risk. Sensitive information should not be included in Flash
+ * movies.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSProtect class represents the Protect tag from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 2. The password
+ * attribute was added in Flash 4.
+ * &lt;/p&gt;
+ */
+public class FSProtect extends FSMovieObject
+{
+	private String password = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSProtect object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSProtect(FSCoder coder)
+	{
+		super(Protect);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Constructs an Protect object. */
+	public FSProtect()
+	{
+		super(Protect);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSProtect_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Constructs an Protect object. */
+	public FSProtect(String password)
+	{
+		super(Protect);
+		setPassword(password);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSProtect_1&quot;&gt;password&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An MD5 encrypted password.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSProtect object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSProtect object.
+	 */
+	public FSProtect(FSProtect obj)
+	{
+		super(obj);
 
-&lt;/table&gt;
+		if (obj.password != null)
+			password = new String(obj.password);
+		else
+			password = obj.password;
+	}
 
-&lt;p&gt;In order to use the debugger a password must be supplied. When encrypted using the MD5 algorithm it must match the value stored in the password attribute.&lt;/p&gt;
+	/**
+	 * Gets the MD5 encrypted password.
+	 * 
+	 * @return the string defining the password.
+	 */
+	public String getPassword()
+	{
+		return password;
+	}
 
-&lt;p&gt;IMPORTANT: this form of protection only works with Macromedia's Flash Authoring tool. Any application that parses Flash files can choose to ignore or delete this data structure therefore it is not safe to use this to protect the contents of a Flash file.&lt;/p&gt;
+	/**
+	 * Sets the MD5 encrypted password.
+	 * 
+	 * @param aString
+	 *            the string defining the password.
+	 */
+	public void setPassword(String aString)
+	{
+		password = aString;
+	}
 
-&lt;p&gt;Transform will parse all Flash files containing the Protect data structure. Since the encoded data is can be removed by trivial scripts the level of copy-protection offered is minimal. Indeed the use of the Protect mechanism in Flash movies may lead to a false sense of security, putting proprietary information at risk. Sensitive information should not be included in Flash movies.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			if (password != null)
+				result = password.equals(((FSProtect) anObject).getPassword());
+			else
+				result = ((FSProtect) anObject).getPassword() == null;
+		}
+		return result;
+	}
 
-&lt;p&gt;The FSProtect class represents the Protect tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 2. The password attribute was added in Flash 5.&lt;/p&gt;
- */
-public class FSProtect extends FSMovieObject
-{
-    private String password = null;
-        
-    /**
-     * Construct an FSProtect object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSProtect(FSCoder coder)
-    {
-        super(Protect);
-        decode(coder);
-    }
-    /** Constructs an Protect object. */
-    public FSProtect()
-    {
-        super(Protect);
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Constructs an Protect object. */
-    public FSProtect(String password)
-    {
-        super(Protect);
-        setPassword(password);
-    }
-    /**
-     * Constructs an FSProtect object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSProtect object.
-     */
-    public FSProtect(FSProtect obj)
-    {
-        super(obj);
-        
-        if (obj.password != null)
-            password = new String(obj.password);
-        else
-            password = obj.password;
-    }    
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;password&quot;, password);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Gets the MD5 encrypted password.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @return the string defining the password.
-        */
-    public String getPassword() { return password; }
+		if ((password != null) &amp;&amp; (password.length() &gt; 0))
+			length += 2 + coder.strlen(password, true);
 
-    /** Sets the MD5 encrypted password.
+		return length;
+	}
 
-        @param aString the string defining the password.
-        */
-    public void setPassword(String aString)
-    {
-        password = aString;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            if (password != null)
-                result = password.equals(((FSProtect)anObject).getPassword());
-            else
-                result = ((FSProtect)anObject).getPassword() == null;
-        }
-        return result;
-    }
+		if ((password != null) &amp;&amp; (password.length() &gt; 0))
+		{
+			coder.writeWord(0, 2);
+			coder.writeString(password);
+			coder.writeWord(0, 1);
+		}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;password&quot;, password);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.endObject(name());
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        if ((password != null) &amp;&amp; (password.length() &gt; 0))
-            length += 2 + coder.strlen(password, true);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        return length;
-    }    
+		/*
+		 * Force a read of the entire password field, including any zero bytes
+		 * that are encountered.
+		 */
+		if (length &gt; 0)
+		{
+			coder.readWord(2, false);
+			password = coder.readString(length - 2);
 
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        if ((password != null) &amp;&amp; (password.length() &gt; 0))
-        {
-            coder.writeWord(0, 2);
-            coder.writeString(password);
-            coder.writeWord(0, 1);
-        }
- 
-         coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        /*
-         * Force a read of the entire password field, including any 
-         * zero bytes that are encountered.
-         */
-        if (length &gt; 0)
-        {
-            coder.readWord(2, false);
-            password = coder.readString(length-2);
-            
-            while (password.charAt(password.length()-1) == 0) {
-            	password = password.substring(0, password.length()-1);
-            }
-        }        
-        coder.endObject(name());
-    }
+			while (password.charAt(password.length() - 1) == 0)
+			{
+				password = password.substring(0, password.length() - 1);
+			}
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSPush.java
===================================================================
--- trunk/src/com/flagstone/transform/FSPush.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSPush.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,655 +33,895 @@
 import java.util.*;
 
 /**
-FSPush is used to push values on the Flash Player's internal stack.
+ * FSPush is used to push values on the Flash Player's internal stack.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;values&lt;/td&gt;
+ * &lt;td&gt;An array of values that will be pushed onto the Flash Player's Stack and
+ * used when executing actions.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPush action supports the full range of data types supported by Flash:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot;&gt;Data Type&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Boolean&lt;/td&gt;
+ * &lt;td&gt;A boolean value, 1 (true) or 0 (false).&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Integer&lt;/td&gt;
+ * &lt;td&gt;A signed 32-bit integer, range -2,147,483,648 to 2,147,483,647.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Double&lt;/td&gt;
+ * &lt;td&gt;A double-precision (64-bit) floating-point number, range approximately
+ * +/- 1.79769313486231570E+308.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;String&lt;/td&gt;
+ * &lt;td&gt;A String. The string is encoded as using the UTF-8 encoding which is
+ * backward compatible with ASCII encoding supported in Flash 5.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Register Index&lt;/td&gt;
+ * &lt;td&gt;The number (0,..3) of one of the Flash player's internal registers.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Table Index&lt;/td&gt;
+ * &lt;td&gt;An index into a table of string literals defined using the FSTable
+ * action.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Null&lt;/td&gt;
+ * &lt;td&gt;A null value.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Void&lt;/td&gt;
+ * &lt;td&gt;A void value.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Movie Clip Property&lt;/td&gt;
+ * &lt;td&gt;A reserved number used to identify a specific property of a movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td nowrap width=&quot;20%&quot;&gt;Player Property&lt;/td&gt;
+ * &lt;td&gt;A reserved number used to identify a specific property of the Flash
+ * Player.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Movie Clip properties are used to access the attributes of the specified
+ * movie clip. To simplify using movie clip properties the values are defined as
+ * constants in the FSPush class:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th nowrap align=&quot;left&quot;&gt;Name&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_x&lt;/td&gt;
+ * &lt;td&gt;The x-coordinate of the current drawing point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_y&lt;/td&gt;
+ * &lt;td&gt;The y-coordinate of the current drawing point.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_xscale&lt;/td&gt;
+ * &lt;td&gt;The scale of the player window in the x-axis.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_yscale&lt;/td&gt;
+ * &lt;td&gt;The scale of the player window in the y-axis.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_currentframe&lt;/td&gt;
+ * &lt;td&gt;The number of the frame currently being displayed&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_totalframes&lt;/td&gt;
+ * &lt;td&gt;The total number of frames in the current movie clip being played.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_alpha&lt;/td&gt;
+ * &lt;td&gt;Whether the player supports alpha channel transparency in colours.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_visible&lt;/td&gt;
+ * &lt;td&gt;Whether the player is currently visible.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_width&lt;/td&gt;
+ * &lt;td&gt;The width of the player, in pixels, on the screen.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_height&lt;/td&gt;
+ * &lt;td&gt;The height of the player, in pixels, on the screen.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_rotation&lt;/td&gt;
+ * &lt;td&gt;The rotation of the movie clip in degrees&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_target&lt;/td&gt;
+ * &lt;td&gt;The current target or context for actions.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_framesloaded&lt;/td&gt;
+ * &lt;td&gt;The number of frames from the movie clip that are currently loaded&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_name&lt;/td&gt;
+ * &lt;td&gt;The name of a movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_droptarget&lt;/td&gt;
+ * &lt;td&gt;Then name of the movie clip currently being dragged.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_url&lt;/td&gt;
+ * &lt;td&gt;The URL of the current movie clip being played.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Player properties are used to access the attributes of the Player showing the
+ * movie clips. To simplify using player properties the values are defined as
+ * constants in the FSPush class:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * &lt;tr&gt;
+ * &lt;th nowrap align=&quot;left&quot;&gt;Name&lt;/th&gt;
+ * &lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_quality&lt;/td&gt;
+ * &lt;td&gt;Whether the player is set to display movie clips at high quality.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_highquality&lt;/td&gt;
+ * &lt;td&gt;Whether the player is set to display movie clips at high quality.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_focusrect&lt;/td&gt;
+ * &lt;td&gt;Whether a bounding yellow rectangle is drawn around the current object
+ * (a sprite or button) has the keyboard and mouse focus.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_soundbuftime&lt;/td&gt;
+ * &lt;td&gt;The number of seconds to buffer streaming sound before playing&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_xmouse&lt;/td&gt;
+ * &lt;td&gt;The current x-coordinate of the mouse location.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;tr&gt;
+ * &lt;td&gt;_ymouse&lt;/td&gt;
+ * &lt;td&gt;The current y-coordinate of the mouse location.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSPush class maintains an array of values that will be pushed onto the
+ * stack. Any basic data types: boolean, int and double passed in the class
+ * constructors or using the add() methods are wrapped internally, in an
+ * Boolean, Integer and Double class respectively - simplifying how the class is
+ * used. Wrapper classes are only used explicitly when parsing a Flash files and
+ * manipulating the values stored in the array.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Push each of the different types value onto the stack:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSPush boolean        = new FSPush(true);
+ *  FSPush integer        = new FSPush(123);
+ *  FSPush double         = new FSPush(123.0);
+ *  FSPush string         = new FSPush(&quot;123&quot;);
+ *  FSPush null           = new FSPush(new FSNull());
+ *  FSPush void           = new FSPush(new FSVoid());
+ *  FSPush registerIndex  = new FSPush(new FSRegisterIndex(0));
+ *  FSPush tableIndex     = new FSPush(new FSTableIndex(0));
+ *  FSPush movieProperty  = new FSPush(FSPush._x);
+ *  FSPush playerProperty = new FSPush(FSPush._xmouse);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * For efficiency a single FSPush action can push several values onto the stack
+ * in a single operation. The order in which values are added to the FSPush
+ * action is the same order in which the values are pushed onto the stack.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSPush push = new FSPush();
+ * 
+ * push.add(123);
+ * push.add(123.0);
+ * push.add(&quot;123&quot;);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * If an array of values are added to a FSPush object then boolean, int and
+ * double values must be wrapped using the Boolean, Integer and Double classes
+ * respectively.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * FSPush is a class for representing the Push action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 4 and contained
+ * either an integer or string argument. It was extended in Flash 5 to support a
+ * number of different data types and allow more than one value to be added in a
+ * single action.
+ * &lt;/p&gt;
+ */
+public class FSPush extends FSActionObject
+{
+	/** The x-origin of the movie clip relative to the parent clip. */
+	public static final int _x = (Transform.VERSION &lt; 5) ? 0x00000000 : 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** The y-origin of the movie clip relative to the parent clip. */
+	public static final int _y = (Transform.VERSION &lt; 5) ? 0x3f800000 : 1;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** The scaling factor of the movie clip in the x direction. */
+	public static final int _xscale = (Transform.VERSION &lt; 5) ? 0x40000000 : 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPush_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/** The scaling factor of the movie clip in the x direction. */
+	public static final int _yscale = (Transform.VERSION &lt; 5) ? 0x40400000 : 3;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSPush_1&quot;&gt;values&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of values that will be pushed onto the Flash Player's Stack and used when executing actions.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/** The number of the current frame playing in the movie clip. */
+	public static final int _currentframe = (Transform.VERSION &lt; 5) ? 0x40800000 : 4;
 
-&lt;p&gt;The FSPush action supports the full range of data types supported by Flash:&lt;/p&gt;
+	/** The total number of frames in the movie clip. */
+	public static final int _totalframes = (Transform.VERSION &lt; 5) ? 0x40a00000 : 5;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Data Type&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Boolean&lt;/td&gt;&lt;td&gt;A boolean value, 1 (true) or 0 (false).&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Integer&lt;/td&gt;&lt;td&gt;A signed 32-bit integer, range -2,147,483,648 to 2,147,483,647.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Double&lt;/td&gt;&lt;td&gt;A double-precision (64-bit) floating-point number, range approximately +/- 1.79769313486231570E+308.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;String&lt;/td&gt;&lt;td&gt;A String. The string is encoded as using the UTF-8 encoding which is backward compatible with ASCII encoding supported in Flash 5.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Register Index&lt;/td&gt;&lt;td&gt;The number (0,..3) of one of the Flash player's internal registers.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Table Index&lt;/td&gt;&lt;td&gt;An index into a table of string literals defined using the FSTable action.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Null&lt;/td&gt;&lt;td&gt;A null value.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Void&lt;/td&gt;&lt;td&gt;A void value.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Movie Clip Property&lt;/td&gt;&lt;td&gt;A reserved number used to identify a specific property of a movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td nowrap width=&quot;20%&quot;&gt;Player Property&lt;/td&gt;&lt;td&gt;A reserved number used to identify a specific property of the Flash Player.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** The transparency of the movie clip. */
+	public static final int _alpha = (Transform.VERSION &lt; 5) ? 0x40c00000 : 6;
 
-&lt;p&gt;Movie Clip properties are used to access the attributes of the specified movie clip. To simplify using movie clip properties the values are defined as constants in the FSPush class:&lt;/p&gt;
+	/** Whether the movie clip is visible. */
+	public static final int _visible = (Transform.VERSION &lt; 5) ? 0x40e00000 : 7;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;th nowrap align=&quot;left&quot;&gt;Name&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_x&lt;/td&gt;&lt;td&gt;The x-coordinate of the current drawing point.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_y&lt;/td&gt;&lt;td&gt;The y-coordinate of the current drawing point.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_xscale&lt;/td&gt;&lt;td&gt;The scale of the player window in the x-axis.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_yscale&lt;/td&gt;&lt;td&gt;The scale of the player window in the y-axis.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_currentframe&lt;/td&gt;&lt;td&gt;The number of the frame currently being displayed&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_totalframes&lt;/td&gt;&lt;td&gt;The total number of frames in the current movie clip being played.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_alpha&lt;/td&gt;&lt;td&gt;Whether the player supports alpha channel transparency in colours.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_visible&lt;/td&gt;&lt;td&gt;Whether the player is currently visible.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_width&lt;/td&gt;&lt;td&gt;The width of the player, in pixels, on the screen.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_height&lt;/td&gt;&lt;td&gt;The height of the player, in pixels, on the screen.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_rotation&lt;/td&gt;&lt;td&gt;The rotation of the movie clip in degrees&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_target&lt;/td&gt;&lt;td&gt;The current target or context for actions.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_framesloaded&lt;/td&gt;&lt;td&gt;The number of frames from the movie clip that are currently loaded&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_name&lt;/td&gt;&lt;td&gt;The name of a movie clip.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_droptarget&lt;/td&gt;&lt;td&gt;Then name of the movie clip currently being dragged.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_url&lt;/td&gt;&lt;td&gt;The URL of the current movie clip being played.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** The width of the movie clip in pixels. */
+	public static final int _width = (Transform.VERSION &lt; 5) ? 0x41000000 : 8;
 
-&lt;p&gt;Player properties are used to access the attributes of the Player showing the movie clips. To simplify using player properties the values are defined as constants in the FSPush class:&lt;/p&gt;
+	/** The height of the movie clip in pixels. */
+	public static final int _height = (Transform.VERSION &lt; 5) ? 0x41100000 : 9;
 
-&lt;table class=&quot;datasheet&quot;&gt;
-&lt;tr&gt;&lt;th nowrap align=&quot;left&quot;&gt;Name&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_quality&lt;/td&gt;&lt;td&gt;Whether the player is set to display movie clips at high quality.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_highquality&lt;/td&gt;&lt;td&gt;Whether the player is set to display movie clips at high quality.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_focusrect&lt;/td&gt;&lt;td&gt;Whether a bounding yellow rectangle is drawn around the current object (a sprite or button) has the keyboard and mouse focus.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_soundbuftime&lt;/td&gt;&lt;td&gt;The number of seconds to buffer streaming sound before playing&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_xmouse&lt;/td&gt;&lt;td&gt;The current x-coordinate of the mouse location.&lt;/td&gt;&lt;/tr&gt;
-&lt;tr&gt;&lt;td&gt;_ymouse&lt;/td&gt;&lt;td&gt;The current y-coordinate of the mouse location.&lt;/td&gt;&lt;/tr&gt;
-&lt;/table&gt;
+	/** The angle of rotation of the movie clip in degrees. */
+	public static final int _rotation = (Transform.VERSION &lt; 5) ? 0x41200000 : 10;
 
-&lt;p&gt;The FSPush class maintains an array of values that will be pushed onto the stack. Any basic data types: boolean, int and double passed in the class constructors or using the add() methods are wrapped internally, in an Boolean, Integer and Double class respectively - simplifying how the class is used. Wrapper classes are only used explicitly when parsing a Flash files and manipulating the values stored in the array.&lt;/p&gt;
+	/** The path of the movie clip relative to the root movie in the Player. */
+	public static final int _target = (Transform.VERSION &lt; 5) ? 0x41300000 : 11;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/** The number of frames form the movie clip loaded. */
+	public static final int _framesloaded = (Transform.VERSION &lt; 5) ? 0x41400000 : 12;
 
-&lt;p&gt;Push each of the different types value onto the stack:&lt;/p&gt;
+	/** The name of movie clip. */
+	public static final int _name = (Transform.VERSION &lt; 5) ? 0x41500000 : 13;
 
-&lt;pre&gt;
-FSPush boolean        = new FSPush(true);
-FSPush integer        = new FSPush(123);
-FSPush double         = new FSPush(123.0);
-FSPush string         = new FSPush(&quot;123&quot;);
-FSPush null           = new FSPush(new FSNull());
-FSPush void           = new FSPush(new FSVoid());
-FSPush registerIndex  = new FSPush(new FSRegisterIndex(0));
-FSPush tableIndex     = new FSPush(new FSTableIndex(0));
-FSPush movieProperty  = new FSPush(FSPush._x);
-FSPush playerProperty = new FSPush(FSPush._xmouse);
-&lt;/pre&gt;
+	/** The name of the movie clip currently being dragged */
+	public static final int _droptarget = (Transform.VERSION &lt; 5) ? 0x41600000 : 14;
 
-&lt;p&gt;For efficiency a single FSPush action can push several values onto the stack in a single operation. The order in which values are added to the FSPush action is the same order in which the values are pushed onto the stack.&lt;/p&gt;
+	/** The URL from which the movie clip was loaded. */
+	public static final int _url = (Transform.VERSION &lt; 5) ? 0x41700000 : 15;
 
-&lt;pre&gt;
-FSPush push = new FSPush();
+	/** Identifies the level of aliasing being performed by the Player. */
+	public static final int _highquality = (Transform.VERSION &lt; 5) ? 0x41800000 : 16;
 
-push.add(123);
-push.add(123.0);
-push.add(&quot;123&quot;);
-&lt;/pre&gt;
+	/**
+	 * Identifies whether a yellow rectangle is drawn around a button or test
+	 * field that has the current focus.
+	 */
+	public static final int _focusrect = (Transform.VERSION &lt; 5) ? 0x41880000
+					: 17;
 
-&lt;p&gt;If an array of values are added to a FSPush object then boolean, int and double values must be wrapped using the Boolean, Integer and Double classes respectively.&lt;/p&gt;
+	/**
+	 * The amount of time streaming sound is buffered by the Player before
+	 * playing.
+	 */
+	public static final int _soundbuftime = (Transform.VERSION &lt; 5) ? 0x41900000
+					: 18;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/** Identifies the level of rendering quality being performed by the Player. */
+	public static final int _quality = 19;
 
-&lt;p&gt;FSPush is a class for representing the Push action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4 and contained either an integer or string argument. It was extended in Flash 5 to support a number of different data types and allow more than one value to be added in a single action.&lt;/p&gt;
- */  
-public class FSPush extends FSActionObject
-{
-/** The x-origin of the movie clip relative to the parent clip.*/
-    public static final int _x = (Transform.VERSION &lt; 5) ? 0x00000000 : 0;
-/** The y-origin of the movie clip relative to the parent clip.*/
-    public static final int _y = (Transform.VERSION &lt; 5) ? 0x3f800000 : 1;
-/** The scaling factor of the movie clip in the x direction.*/
-    public static final int _xscale = (Transform.VERSION &lt; 5) ? 0x40000000 : 2;
-/** The scaling factor of the movie clip in the x direction.*/
-    public static final int _yscale = (Transform.VERSION &lt; 5) ? 0x40400000 : 3;
-/** The number of the current frame playing in the movie clip.*/
-    public static final int _currentframe = (Transform.VERSION &lt; 5) ? 0x40800000 : 4;
-/** The total number of frames in the movie clip.*/
-    public static final int _totalframes = (Transform.VERSION &lt; 5) ? 0x40a00000 : 5;
-/** The transparency of the movie clip.*/
-    public static final int _alpha = (Transform.VERSION &lt; 5) ? 0x40c00000 : 6;
-/** Whether the movie clip is visible.*/
-    public static final int _visible = (Transform.VERSION &lt; 5) ? 0x40e00000 : 7;
-/** The width of the movie clip in pixels.*/
-    public static final int _width = (Transform.VERSION &lt; 5) ? 0x41000000 : 8;
-/** The height of the movie clip in pixels.*/
-    public static final int _height = (Transform.VERSION &lt; 5) ? 0x41100000 : 9;
-/** The angle of rotation of the movie clip in degrees.*/
-    public static final int _rotation = (Transform.VERSION &lt; 5) ? 0x41200000 :10;
-/** The path of the movie clip relative to the root movie in the Player.*/
-    public static final int _target = (Transform.VERSION &lt; 5) ? 0x41300000 : 11;
-/** The number of frames form the movie clip loaded.*/
-    public static final int _framesloaded = (Transform.VERSION &lt; 5) ? 0x41400000 : 12;
-/** The name of movie clip.*/
-    public static final int _name = (Transform.VERSION &lt; 5) ? 0x41500000 : 13;
-/** The name of the movie clip currently being dragged */
-    public static final int _droptarget = (Transform.VERSION &lt; 5) ? 0x41600000 : 14;
-/** The URL from which the movie clip was loaded.*/
-    public static final int _url = (Transform.VERSION &lt; 5) ? 0x41700000 : 15;
-/** Identifies the level of aliasing being performed by the Player.*/
-    public static final int _highquality = (Transform.VERSION &lt; 5) ? 0x41800000 : 16;
-/** Identifies whether a yellow rectangle is drawn around a button or test field that has the current  focus.*/
-    public static final int _focusrect = (Transform.VERSION &lt; 5) ? 0x41880000 : 17;
-/** The amount of time streaming sound is buffered by the Player before playing.*/
-    public static final int _soundbuftime = (Transform.VERSION &lt; 5) ? 0x41900000 : 18;
-/** Identifies the level of rendering quality being performed by the Player.*/
-    public static final int _quality = 19;
-/** The current x-coordinate of the mouse pointer on the Player screen.*/
-    public static final int _xmouse = 20;
-/** The current y-coordinate of the mouse pointer on the Player screen.*/
-    public static final int _ymouse = 21;
+	/** The current x-coordinate of the mouse pointer on the Player screen. */
+	public static final int _xmouse = 20;
 
-    private static HashMap propertyNames = new HashMap();
-        
-    static {
-        propertyNames.put(&quot;_x&quot;, new Integer(_x));
-        propertyNames.put(&quot;_y&quot;, new Integer(_y));
-        propertyNames.put(&quot;_xscale&quot;, new Integer(_xscale));
-        propertyNames.put(&quot;_yscale&quot;, new Integer(_yscale));
-        propertyNames.put(&quot;_currentframe&quot;, new Integer(_currentframe));
-        propertyNames.put(&quot;_totalframes&quot;, new Integer(_totalframes));
-        propertyNames.put(&quot;_alpha&quot;, new Integer(_alpha));
-        propertyNames.put(&quot;_visible&quot;, new Integer(_visible));
-        propertyNames.put(&quot;_width&quot;, new Integer(_width));
-        propertyNames.put(&quot;_height&quot;, new Integer(_height));
-        propertyNames.put(&quot;_rotation&quot;, new Integer(_rotation));
-        propertyNames.put(&quot;_target&quot;, new Integer(_target));
-        propertyNames.put(&quot;_framesloaded&quot;, new Integer(_framesloaded));
-        propertyNames.put(&quot;_name&quot;, new Integer(_name));
-        propertyNames.put(&quot;_droptarget&quot;, new Integer(_droptarget));
-        propertyNames.put(&quot;_url&quot;, new Integer(_url));
-        propertyNames.put(&quot;_highquality&quot;, new Integer(_highquality));
-        propertyNames.put(&quot;_focusrect&quot;, new Integer(_focusrect));
-        propertyNames.put(&quot;_soundbuftime&quot;, new Integer(_soundbuftime));
-        propertyNames.put(&quot;_quality&quot;, new Integer(_quality));
-        propertyNames.put(&quot;_xmouse&quot;, new Integer(_xmouse));
-        propertyNames.put(&quot;_ymouse&quot;, new Integer(_ymouse));
-    }
-    
-/** Translates the name of a property into the integer value used to identify the property by the Flash Player.
+	/** The current y-coordinate of the mouse pointer on the Player screen. */
+	public static final int _ymouse = 21;
 
<A HREF="https://lists.berlios.de/mailman/listinfo/transform-svn">- at param</A> propertyName a String representing the name of the property.
<A HREF="https://lists.berlios.de/mailman/listinfo/transform-svn">- at return</A> the value of a property identifier.
-*/
-    public static Integer propertyWithName (String propertyName)
-    {
-        Integer identifier = null;
-        
-        if (propertyNames.containsKey(propertyName))
-            identifier = (Integer)propertyNames.get(propertyName);
-            
-        return identifier;
-    }
-    
-    private ArrayList values = new ArrayList();
+	private static HashMap propertyNames = new HashMap();
 
-    /**
-     * Construct an FSPush object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSPush(FSCoder coder)
-    {
-        super(Push);
-        decode(coder);
-    }
-    /** Constructs an FSPush action object with no values added. */
-    public FSPush()
-    {
-        super(Push);
-    }
+	static
+	{
+		propertyNames.put(&quot;_x&quot;, new Integer(_x));
+		propertyNames.put(&quot;_y&quot;, new Integer(_y));
+		propertyNames.put(&quot;_xscale&quot;, new Integer(_xscale));
+		propertyNames.put(&quot;_yscale&quot;, new Integer(_yscale));
+		propertyNames.put(&quot;_currentframe&quot;, new Integer(_currentframe));
+		propertyNames.put(&quot;_totalframes&quot;, new Integer(_totalframes));
+		propertyNames.put(&quot;_alpha&quot;, new Integer(_alpha));
+		propertyNames.put(&quot;_visible&quot;, new Integer(_visible));
+		propertyNames.put(&quot;_width&quot;, new Integer(_width));
+		propertyNames.put(&quot;_height&quot;, new Integer(_height));
+		propertyNames.put(&quot;_rotation&quot;, new Integer(_rotation));
+		propertyNames.put(&quot;_target&quot;, new Integer(_target));
+		propertyNames.put(&quot;_framesloaded&quot;, new Integer(_framesloaded));
+		propertyNames.put(&quot;_name&quot;, new Integer(_name));
+		propertyNames.put(&quot;_droptarget&quot;, new Integer(_droptarget));
+		propertyNames.put(&quot;_url&quot;, new Integer(_url));
+		propertyNames.put(&quot;_highquality&quot;, new Integer(_highquality));
+		propertyNames.put(&quot;_focusrect&quot;, new Integer(_focusrect));
+		propertyNames.put(&quot;_soundbuftime&quot;, new Integer(_soundbuftime));
+		propertyNames.put(&quot;_quality&quot;, new Integer(_quality));
+		propertyNames.put(&quot;_xmouse&quot;, new Integer(_xmouse));
+		propertyNames.put(&quot;_ymouse&quot;, new Integer(_ymouse));
+	}
 
-    /** Constructs an FSPush action that will place the specified boolean value on the stack.
+	/**
+	 * Translates the name of a property into the integer value used to identify
+	 * the property by the Flash Player.
+	 * 
+	 * @param propertyName
+	 *            a String representing the name of the property.
+	 * @return the value of a property identifier.
+	 */
+	public static Integer propertyWithName(String propertyName)
+	{
+		Integer identifier = null;
 
-        @param aBoolean boolean value to push onto the stack.
-        */
-    public FSPush(boolean aBoolean)
-    {
-        super(Push);
-        add(aBoolean);
-    }
+		if (propertyNames.containsKey(propertyName))
+			identifier = (Integer) propertyNames.get(propertyName);
 
-    /** Constructs an FSPush action that will place the specified integer on the stack.
+		return identifier;
+	}
 
-        @param aNumber integer value to push onto the stack.
-        */
-    public FSPush(int aNumber)
-    {
-        super(Push);
-        add(aNumber);
-    }
+	private ArrayList values = new ArrayList();
 
-    /** Constructs an FSPush action that will place the specified double value on the stack.
+	/**
+	 * Construct an FSPush object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSPush(FSCoder coder)
+	{
+		super(Push);
+		decode(coder);
+	}
 
-        @param aNumber double-precision floating-point value to push onto the stack.
-        */
-    public FSPush(double aNumber)
-    {
-        super(Push);
-        add(aNumber);
-    }
+	/** 
+	 * Constructs an FSPush action object with no values added. 
+	 */
+	public FSPush()
+	{
+		super(Push);
+	}
 
-    /** Constructs an FSPush action that will place a null value on the stack.
+	/**
+	 * Constructs an FSPush action that will place the specified boolean value
+	 * on the stack.
+	 * 
+	 * @param aBoolean
+	 *            boolean value to push onto the stack.
+	 */
+	public FSPush(boolean aBoolean)
+	{
+		super(Push);
+		add(aBoolean);
+	}
 
-        @param nullValue an instance of the simple FSNull class.
-        */
-    public FSPush(FSNull nullValue)
-    {
-        super(Push);
-        add(nullValue);
-    }
+	/**
+	 * Constructs an FSPush action that will place the specified integer on the
+	 * stack.
+	 * 
+	 * @param aNumber
+	 *            integer value to push onto the stack.
+	 */
+	public FSPush(int aNumber)
+	{
+		super(Push);
+		add(aNumber);
+	}
 
-    /** Constructs an FSPush action that will place a void value on the stack.
+	/**
+	 * Constructs an FSPush action that will place the specified double value on
+	 * the stack.
+	 * 
+	 * @param aNumber
+	 *            double-precision floating-point value to push onto the stack.
+	 */
+	public FSPush(double aNumber)
+	{
+		super(Push);
+		add(aNumber);
+	}
 
-        @param voidValue an instance of the simple FSVoid class.
-        */    
-    public FSPush(FSVoid voidValue)
-    {
-        super(Push);
-        add(voidValue);
-    }
+	/**
+	 * Constructs an FSPush action that will place a null value on the stack.
+	 * 
+	 * @param nullValue
+	 *            an instance of the simple FSNull class.
+	 */
+	public FSPush(FSNull nullValue)
+	{
+		super(Push);
+		add(nullValue);
+	}
 
-    /** Constructs an FSPush action that will place the specified value on the stack.
+	/**
+	 * Constructs an FSPush action that will place a void value on the stack.
+	 * 
+	 * @param voidValue
+	 *            an instance of the simple FSVoid class.
+	 */
+	public FSPush(FSVoid voidValue)
+	{
+		super(Push);
+		add(voidValue);
+	}
 
-        @param aString string literal value to push onto the stack.
-        */    
-    public FSPush(String aString)
-    {
-        super(Push);
-        add(aString);
-    }
+	/**
+	 * Constructs an FSPush action that will place the specified value on the
+	 * stack.
+	 * 
+	 * @param aString
+	 *            string literal value to push onto the stack.
+	 */
+	public FSPush(String aString)
+	{
+		super(Push);
+		add(aString);
+	}
 
-    /** Constructs an FSPush action that reference a variable in a table.
+	/**
+	 * Constructs an FSPush action that reference a variable in a table.
+	 * 
+	 * @param anIndex
+	 *            an index into a literal table to push onto the stack.
+	 */
+	public FSPush(FSTableIndex anIndex)
+	{
+		super(Push);
+		add(anIndex);
+	}
 
-        @param anIndex an index into a literal table to push onto the stack.
-        */    
-    public FSPush(FSTableIndex anIndex)
-    {
-        super(Push);
-        add(anIndex);
-    }
+	/**
+	 * Constructs an FSPush action that references one of the players internal
+	 * registers.
+	 * 
+	 * @param anIndex
+	 *            a reference to one of the Flash Player's internal registers to
+	 *            push onto the stack.
+	 */
+	public FSPush(FSRegisterIndex anIndex)
+	{
+		super(Push);
+		add(anIndex);
+	}
 
-    /** Constructs an FSPush action that references one of the players internal registers.
+	/**
+	 * Constructs an FSPush action that will push the values in the array onto
+	 * the stack.
+	 * 
+	 * @param anArray
+	 *            an array of values to be pushed onto the stack. The values in
+	 *            the array must be one of the following classes: Boolean,
+	 *            Integer, Double, String, FSRegisterIndex or FSTableIndex.
+	 */
+	public FSPush(ArrayList anArray)
+	{
+		super(Push);
+		setValues(anArray);
+	}
 
-        @param anIndex a reference to one of the Flash Player's internal registers to push onto the stack.
-        */
-    public FSPush(FSRegisterIndex anIndex)
-    {
-        super(Push);
-        add(anIndex);
-    }
+	/**
+	 * Constructs an FSPush object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSPush object.
+	 */
+	public FSPush(FSPush obj)
+	{
+		super(obj);
 
-    /** Constructs an FSPush action that will push the values in the array onto the stack.
+		values = new ArrayList(obj.values.size());
 
-        @param anArray an array of values to be pushed onto the stack. The values in the array must be one of the following classes: Boolean, Integer, Double, String, FSRegisterIndex or FSTableIndex.
-        */    
-    public FSPush(ArrayList anArray)
-    {
-        super(Push);
-        setValues(anArray);
-    }
-    /**
-     * Constructs an FSPush object by copying values from an existing object.
-     *
-     * @param obj an FSPush object.
-     */
-    public FSPush(FSPush obj)
-    {
-        super(obj);
+		for (Iterator i = obj.values.iterator(); i.hasNext();)
+		{
+			Object value = i.next();
 
-        values = new ArrayList(obj.values.size());
+			if (value instanceof Boolean)
+				values.add(new Boolean(((Boolean) value).booleanValue()));
+			else if (value instanceof Integer)
+				values.add(new Integer(((Integer) value).intValue()));
+			else if (value instanceof Float)
+				values.add(new Float(((Float) value).floatValue()));
+			else if (value instanceof Double)
+				values.add(new Double(((Double) value).doubleValue()));
+			else if (value instanceof String)
+				values.add(new String((String) value));
+			else if (value instanceof FSProperty)
+				values.add(new FSProperty((FSProperty) value));
+			else if (value instanceof FSNull)
+				values.add(((FSNull) value).clone());
+			else if (value instanceof FSVoid)
+				values.add(((FSVoid) value).clone());
+			else if (value instanceof FSTableIndex)
+				values.add(((FSTableIndex) value).clone());
+			else if (value instanceof FSRegisterIndex)
+				values.add(((FSRegisterIndex) value).clone());
+		}
+	}
 
-        for (Iterator i = obj.values.iterator(); i.hasNext();)
-        {
-            Object value = i.next();
-            
-            if (value instanceof Boolean)
-                values.add(new Boolean(((Boolean)value).booleanValue()));
-            else if (value instanceof Integer)
-                values.add(new Integer(((Integer)value).intValue()));
-            else if (value instanceof Float)
-                values.add(new Float(((Float)value).floatValue()));
-            else if (value instanceof Double)
-                values.add(new Double(((Double)value).doubleValue()));
-            else if (value instanceof String)
-                values.add(new String((String)value));
-            else if (value instanceof FSProperty)
-                values.add(new FSProperty((FSProperty)value));
-            else if (value instanceof FSNull)
-                values.add(((FSNull)value).clone());
-            else if (value instanceof FSVoid)
-                values.add(((FSVoid)value).clone());
-            else if (value instanceof FSTableIndex)
-                values.add(((FSTableIndex)value).clone());
-            else if (value instanceof FSRegisterIndex)
-                values.add(((FSRegisterIndex)value).clone());
-        }
-    }    
+	/**
+	 * Adds a boolean value to the array of values that will be pushed onto the
+	 * stack.
+	 * 
+	 * @param aBool
+	 *            a boolean value.
+	 */
+	public void add(boolean aBool)
+	{
+		values.add(new Boolean(aBool));
+	}
 
-    /** Adds a boolean value to the array of values that will be pushed onto the stack.
+	/**
+	 * Adds an integer value to the array of values that will be pushed onto the
+	 * stack.
+	 * 
+	 * @param anInt
+	 *            an integer (int) value.
+	 */
+	public void add(int anInt)
+	{
+		values.add(new Integer(anInt));
+	}
 
-        @param aBool a boolean value.
-        */
-    public void add(boolean aBool)
-    {
-        values.add(new Boolean(aBool));
-    } 
+	/**
+	 * Adds a double value to the array of values that will be pushed onto the
+	 * stack.
+	 * 
+	 * @param aDouble
+	 *            a double-precision floating-point value.
+	 */
+	public void add(double aDouble)
+	{
+		values.add(new Double(aDouble));
+	}
 
-    /** Adds an integer value to the array of values that will be pushed onto the stack.
+	/**
+	 * Adds a null value to the array of values that will be pushed onto the
+	 * stack.
+	 * 
+	 * @param nullValue
+	 *            a lightweight FSNull object.
+	 */
+	public void add(FSNull nullValue)
+	{
+		values.add(nullValue);
+	}
 
-        @param anInt an integer (int) value.
-        */
-    public void add(int anInt)
-    {
-        values.add(new Integer(anInt));
-    } 
+	/**
+	 * Adds a void value to the array of values that will be pushed onto the
+	 * stack.
+	 * 
+	 * @param voidValue
+	 *            a lightweight FSVoid object.
+	 */
+	public void add(FSVoid voidValue)
+	{
+		values.add(voidValue);
+	}
 
-    /** Adds a double value to the array of values that will be pushed onto the stack.
+	/**
+	 * Adds a String to the array of values that will be pushed onto the stack.
+	 * 
+	 * @param aString
+	 *            a String.
+	 */
+	public void add(String aString)
+	{
+		values.add(aString);
+	}
 
-        @param aDouble a double-precision floating-point value.
-        */
-    public void add(double aDouble)
-    {
-        values.add(new Double(aDouble));
-    } 
+	/**
+	 * Adds an FSTableIndex to the array of values that will be pushed onto the
+	 * stack.
+	 * 
+	 * @param anIndex
+	 *            a FSTableIndex referencing an entry in a table of literals.
+	 */
+	public void add(FSTableIndex anIndex)
+	{
+		values.add(anIndex);
+	}
 
-    /** Adds a null value to the array of values that will be pushed onto the stack.
+	/**
+	 * Adds an FSRegisterIndex to the array of values that will be pushed onto
+	 * the stack.
+	 * 
+	 * @param anIndex
+	 *            a FSRegisterIndex referencing one of the Flash Player's
+	 *            internal registers.
+	 */
+	public void add(FSRegisterIndex anIndex)
+	{
+		values.add(anIndex);
+	}
 
-        @param nullValue a lightweight FSNull object.
-        */
-    public void add(FSNull nullValue)
-    {
-        values.add(nullValue);
-    } 
+	/**
+	 * Gets the array of values.
+	 * 
+	 * @return the array of values that will be pushed onto the stack.
+	 */
+	public ArrayList getValues()
+	{
+		return values;
+	}
 
-    /** Adds a void value to the array of values that will be pushed onto the stack.
+	/**
+	 * Sets the array of values.
+	 * 
+	 * @param anArray
+	 *            replaces the existing array of value with anArray. The values
+	 *            in the array must be one of the following classes: Boolean,
+	 *            Integer, Double, String, FSNull, FSVoid, FSRegisterIndex or
+	 *            FSTableIndex.
+	 */
+	public void setValues(ArrayList anArray)
+	{
+		values = anArray;
+	}
 
-        @param voidValue a lightweight FSVoid object.
-        */
-    public void add(FSVoid voidValue)
-    {
-        values.add(voidValue);
-    } 
+	public Object clone()
+	{
+		FSPush anObject = (FSPush) super.clone();
 
-    /** Adds a String to the array of values that will be pushed onto the stack.
+		anObject.values = new ArrayList(values.size());
 
-        @param aString a String.
-        */
-    public void add(String aString)
-    {
-        values.add(aString);
-    } 
+		for (Iterator i = values.iterator(); i.hasNext();)
+		{
+			Object obj = i.next();
 
-    /** Adds an FSTableIndex to the array of values that will be pushed onto the stack.
+			if (obj instanceof Boolean)
+				anObject.values
+								.add(new Boolean(((Boolean) obj).booleanValue()));
+			else if (obj instanceof Integer)
+				anObject.values.add(new Integer(((Integer) obj).intValue()));
+			else if (obj instanceof Float)
+				anObject.values.add(new Float(((Float) obj).floatValue()));
+			else if (obj instanceof Double)
+				anObject.values.add(new Double(((Double) obj).doubleValue()));
+			else if (obj instanceof String)
+				anObject.values.add(new String((String) obj));
+			else if (obj instanceof FSProperty)
+				anObject.values.add(new FSProperty((FSProperty) obj));
+			else if (obj instanceof FSNull)
+				anObject.values.add(((FSNull) obj).clone());
+			else if (obj instanceof FSVoid)
+				anObject.values.add(((FSVoid) obj).clone());
+			else if (obj instanceof FSTableIndex)
+				anObject.values.add(((FSTableIndex) obj).clone());
+			else if (obj instanceof FSRegisterIndex)
+				anObject.values.add(((FSRegisterIndex) obj).clone());
+		}
 
-        @param anIndex a FSTableIndex referencing an entry in a table of literals.
-        */
-    public void add(FSTableIndex anIndex)
-    {
-        values.add(anIndex);
-    } 
+		return anObject;
+	}
 
-    /** Adds an FSRegisterIndex to the array of values that will be pushed onto the stack.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anIndex a FSRegisterIndex referencing one of the Flash Player's internal registers.
-        */
-    public void add(FSRegisterIndex anIndex)
-    {
-        values.add(anIndex);
-    } 
+		if (super.equals(anObject))
+			result = values.equals(((FSPush) anObject).values);
 
-    /** Gets the array of values.
+		return result;
+	}
 
-        @return the array of values that will be pushed onto the stack.
-        */
-    public ArrayList getValues() { return values; }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Sets the array of values.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;values&quot;, values, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param anArray replaces the existing array of value with anArray. The values in the array must be one of the following classes: Boolean, Integer, Double, String, FSNull, FSVoid, FSRegisterIndex or FSTableIndex.
-        */
-    public void setValues(ArrayList anArray)
-    {
-        values = anArray;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public Object clone()
-    {
-        FSPush anObject = (FSPush)super.clone();
-        
-        anObject.values = new ArrayList(values.size());
+		for (Iterator i = values.iterator(); i.hasNext();)
+		{
+			Object anObject = i.next();
 
-        for (Iterator i = values.iterator(); i.hasNext();)
-        {
-            Object obj = i.next();
-            
-            if (obj instanceof Boolean)
-                anObject.values.add(new Boolean(((Boolean)obj).booleanValue()));
-            else if (obj instanceof Integer)
-                anObject.values.add(new Integer(((Integer)obj).intValue()));
-            else if (obj instanceof Float)
-                anObject.values.add(new Float(((Float)obj).floatValue()));
-            else if (obj instanceof Double)
-                anObject.values.add(new Double(((Double)obj).doubleValue()));
-            else if (obj instanceof String)
-                anObject.values.add(new String((String)obj));
-            else if (obj instanceof FSProperty)
-                anObject.values.add(new FSProperty((FSProperty)obj));
-            else if (obj instanceof FSNull)
-                anObject.values.add(((FSNull)obj).clone());
-            else if (obj instanceof FSVoid)
-                anObject.values.add(((FSVoid)obj).clone());
-            else if (obj instanceof FSTableIndex)
-                anObject.values.add(((FSTableIndex)obj).clone());
-            else if (obj instanceof FSRegisterIndex)
-                anObject.values.add(((FSRegisterIndex)obj).clone());
-        }
+			if (anObject instanceof Boolean)
+				length += 2;
+			else if (anObject instanceof FSProperty)
+				length += 5;
+			else if (anObject instanceof Integer)
+				length += 5;
+			else if (anObject instanceof Double)
+				length += 9;
+			else if (anObject instanceof String)
+				length += 1 + coder.strlen((String) anObject, true);
+			else if (anObject instanceof FSNull)
+				length += 1;
+			else if (anObject instanceof FSVoid)
+				length += 1;
+			else if (anObject instanceof FSTableIndex)
+			{
+				if (((FSTableIndex) anObject).getIndex() &lt; 256)
+					length += 2;
+				else
+					length += 3;
+			} else if (anObject instanceof FSRegisterIndex)
+				length += 2;
+		}
 
-        return anObject;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = values.equals(((FSPush)anObject).values);
-        
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;values&quot;, values, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		for (Iterator i = values.iterator(); i.hasNext();)
+		{
+			Object anObject = i.next();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        for (Iterator i=values.iterator(); i.hasNext();)
-        {
-            Object anObject = i.next();
-            
-            if (anObject instanceof Boolean)
-                length += 2;
-            else if (anObject instanceof FSProperty)
-                length += 5;
-            else if (anObject instanceof Integer)
-                length += 5;
-            else if (anObject instanceof Double)
-                length += 9;
-            else if (anObject instanceof String)
-                length += 1 + coder.strlen((String)anObject, true);
-            else if (anObject instanceof FSNull)
-                length += 1;
-            else if (anObject instanceof FSVoid)
-                length += 1;
-            else if (anObject instanceof FSTableIndex)
-            {
-                if (((FSTableIndex)anObject).getIndex() &lt; 256)
-                    length += 2;
-                else
-                    length += 3;
-            }
-            else if (anObject instanceof FSRegisterIndex)
-                length += 2;
-        }
+			if (anObject instanceof Boolean)
+			{
+				coder.writeWord(5, 1);
+				coder.writeWord(((Boolean) anObject).booleanValue() ? 1 : 0, 1);
+			} else if (anObject instanceof Integer)
+			{
+				coder.writeWord(7, 1);
+				coder.writeWord(((Integer) anObject).intValue(), 4);
+			} else if (anObject instanceof FSProperty)
+			{
+				coder.writeWord(1, 1);
+				coder.writeWord(((FSProperty) anObject).getValue(), 4);
+			} else if (anObject instanceof Double)
+			{
+				coder.writeWord(6, 1);
+				coder.writeDouble(((Double) anObject).doubleValue());
+			} else if (anObject instanceof String)
+			{
+				coder.writeWord(0, 1);
+				coder.writeString((String) anObject);
+				coder.writeWord(0, 1);
+			} else if (anObject instanceof FSNull)
+			{
+				coder.writeWord(2, 1);
+			} else if (anObject instanceof FSVoid)
+			{
+				coder.writeWord(3, 1);
+			} else if (anObject instanceof FSTableIndex)
+			{
+				if (((FSTableIndex) anObject).getIndex() &lt; 256)
+				{
+					coder.writeWord(8, 1);
+					coder.writeWord(((FSTableIndex) anObject).getIndex(), 1);
+				} else
+				{
+					coder.writeWord(9, 1);
+					coder.writeWord(((FSTableIndex) anObject).getIndex(), 2);
+				}
+			} else if (anObject instanceof FSRegisterIndex)
+			{
+				coder.writeWord(4, 1);
+				coder.writeWord(((FSRegisterIndex) anObject).getIndex(), 1);
+			}
+		}
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
+		coder.endObject(name());
+	}
 
-        for (Iterator i=values.iterator(); i.hasNext();)
-        {
-            Object anObject = i.next();
-            
-            if (anObject instanceof Boolean)
-            {
-                coder.writeWord(5, 1);
-                coder.writeWord(((Boolean)anObject).booleanValue() ? 1 : 0, 1);
-            }
-            else if (anObject instanceof Integer)
-            {
-                coder.writeWord(7, 1);
-                coder.writeWord(((Integer)anObject).intValue(), 4);
-            }
-            else if (anObject instanceof FSProperty)
-            {
-                coder.writeWord(1, 1);
-                coder.writeWord(((FSProperty)anObject).getValue(), 4);
-            }
-            else if (anObject instanceof Double)
-            {
-                coder.writeWord(6, 1);
-                coder.writeDouble(((Double)anObject).doubleValue());
-            }
-            else if (anObject instanceof String)
-            {               
-                coder.writeWord(0, 1);
-                coder.writeString((String)anObject);
-                coder.writeWord(0, 1);
-            }
-            else if (anObject instanceof FSNull)
-            {
-                coder.writeWord(2, 1);
-            }
-            else if (anObject instanceof FSVoid)
-            {
-                coder.writeWord(3, 1);
-            }
-            else if (anObject instanceof FSTableIndex)
-            {
-                if (((FSTableIndex)anObject).getIndex() &lt; 256)
-                {
-                    coder.writeWord(8, 1);
-                    coder.writeWord(((FSTableIndex)anObject).getIndex(), 1);
-                }
-                else
-                {
-                    coder.writeWord(9, 1);
-                    coder.writeWord(((FSTableIndex)anObject).getIndex(), 2);
-                }
-            }
-            else if (anObject instanceof FSRegisterIndex)
-            {
-                coder.writeWord(4, 1);
-                coder.writeWord(((FSRegisterIndex)anObject).getIndex(), 1);
-            }
-        }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        int valuesLength = length;
+		int valuesLength = length;
 
-        while (valuesLength &gt; 0)
-        {
-            int dataType = coder.scanWord(1, false);
-            
-            coder.adjustPointer(8);
-            
-            switch (dataType)
-            {
-                case 0:
-                    int start = coder.getPointer();
-                    int strlen = 0;
-                    
-                    for (strlen=0; coder.scanWord(1, false) != 0; coder.adjustPointer(8), strlen++);
-                    
-                    coder.setPointer(start);
-                    values.add(coder.readString(strlen));
-                    coder.adjustPointer(8);
-                    valuesLength -= strlen + 2;
-                    break;
-                case 1: // Pre version 5 property
-                    int propertyValue = coder.readWord(4, false);
-                    values.add(new FSProperty(propertyValue));
-                    valuesLength -= 5;
-                    break;
-                case 2:
-                    values.add(FSNull.getInstance());
-                    valuesLength -= 1;
-                    break;
-                case 3:
-                    values.add(FSVoid.getInstance());
-                    valuesLength -= 1;
-                    break;
-                case 4:
-                    int registerIndex = coder.readWord(1, false);
-                    values.add(new FSRegisterIndex(registerIndex));
-                    valuesLength -= 2;
-                    break;
-                case 5:
-                    boolean boolValue = coder.readWord(1, false) != 0 ? true : false;
-                    values.add(new Boolean(boolValue));
-                    valuesLength -= 2;
-                    break;
-                case 6:
-                    double doubleValue = coder.readDouble();
-                    values.add(new Double(doubleValue));
-                    valuesLength -= 9;
-                    break;
-                case 7:
-                    int intValue = coder.readWord(4, false);
-                    values.add(new Integer(intValue));
-                    valuesLength -= 5;
-                    break;
-                case 8:
-                case 9:
-                    int tableIndex = coder.readWord(dataType == 8 ? 1 : 2, false);
-                    values.add(new FSTableIndex(tableIndex));
-                    valuesLength -= (dataType == 8) ? 2 : 3;
-                    break;
-            }
-        }
+		while (valuesLength &gt; 0)
+		{
+			int dataType = coder.scanWord(1, false);
 
-        coder.endObject(name());
-    }
+			coder.adjustPointer(8);
+
+			switch (dataType)
+			{
+				case 0:
+					int start = coder.getPointer();
+					int strlen = 0;
+
+					for (strlen = 0; coder.scanWord(1, false) != 0; coder
+									.adjustPointer(8), strlen++)
+						;
+
+					coder.setPointer(start);
+					values.add(coder.readString(strlen));
+					coder.adjustPointer(8);
+					valuesLength -= strlen + 2;
+					break;
+				case 1: // Pre version 5 property
+					int propertyValue = coder.readWord(4, false);
+					values.add(new FSProperty(propertyValue));
+					valuesLength -= 5;
+					break;
+				case 2:
+					values.add(FSNull.getInstance());
+					valuesLength -= 1;
+					break;
+				case 3:
+					values.add(FSVoid.getInstance());
+					valuesLength -= 1;
+					break;
+				case 4:
+					int registerIndex = coder.readWord(1, false);
+					values.add(new FSRegisterIndex(registerIndex));
+					valuesLength -= 2;
+					break;
+				case 5:
+					boolean boolValue = coder.readWord(1, false) != 0 ? true
+									: false;
+					values.add(new Boolean(boolValue));
+					valuesLength -= 2;
+					break;
+				case 6:
+					double doubleValue = coder.readDouble();
+					values.add(new Double(doubleValue));
+					valuesLength -= 9;
+					break;
+				case 7:
+					int intValue = coder.readWord(4, false);
+					values.add(new Integer(intValue));
+					valuesLength -= 5;
+					break;
+				case 8:
+				case 9:
+					int tableIndex = coder.readWord(dataType == 8 ? 1 : 2,
+									false);
+					values.add(new FSTableIndex(tableIndex));
+					valuesLength -= (dataType == 8) ? 2 : 3;
+					break;
+			}
+		}
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSQuicktimeMovie.java
===================================================================
--- trunk/src/com/flagstone/transform/FSQuicktimeMovie.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSQuicktimeMovie.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,130 +31,153 @@
 package com.flagstone.transform;
 
 /**
-The FSQuicktimeMovie defines the name of an external Quicktime movie to be played. 
+ * The FSQuicktimeMovie defines the name of an external Quicktime movie to be
+ * played.
+ * 
+ * &lt;p&gt;
+ * The name of the movie can be a reference to a file or to a URL.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;name&lt;/td&gt;
+ * &lt;td&gt;The name of a file or a URL referencing the file to be displayed by the
+ * Flash Player.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSQuicktimeMovie class represents the QuicktimeMovie structure from the
+ * Macromedia Flash (SWF) File Format Specification. This structure is
+ * undocumented in later versions of the specification. It is not known when it
+ * was introduced.
+ * &lt;/p&gt;
+ */
+public class FSQuicktimeMovie extends FSMovieObject
+{
+	private String name = null;
 
-&lt;p&gt;The name of the movie can be a reference to a file or to a URL.&lt;/p&gt;
+	/**
+	 * Construct an FSQuicktimeMovie object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSQuicktimeMovie(FSCoder coder)
+	{
+		super(QuicktimeMovie);
+		decode(coder);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSQuicktimeMovie object referencing the specified file.
+	 * 
+	 * @param aString
+	 *            the file or URL where the file is located.
+	 */
+	public FSQuicktimeMovie(String aString)
+	{
+		super(QuicktimeMovie);
+		setName(aString);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSQuicktimeMovie object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSQuicktimeMovie object.
+	 */
+	public FSQuicktimeMovie(FSQuicktimeMovie obj)
+	{
+		super(obj);
+		name = new String(obj.name);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSQuicktimeMovie_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the reference to the file containing the movie.
+	 * 
+	 * @return the location of the file or URL.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSQuicktimeMovie_0&quot;&gt;name&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name of a file or a URL referencing the file to be displayed by the Flash Player.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Sets the reference to the file containing the movie.
+	 * 
+	 * @param aString
+	 *            the file or URL where the file is located.
+	 */
+	public void setName(String aString)
+	{
+		name = aString;
+	}
 
-&lt;/table&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSQuicktimeMovie typedObject = (FSQuicktimeMovie) anObject;
 
-&lt;p&gt;The FSQuicktimeMovie class represents the QuicktimeMovie structure from the Macromedia Flash (SWF) File Format Specification. This structure is undocumented in later versions of the specification. It is not known when it was introduced.&lt;/p&gt;
- */ 
-public class FSQuicktimeMovie extends FSMovieObject
-{
-    private String name = null;
-        
-    /**
-     * Construct an FSQuicktimeMovie object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSQuicktimeMovie(FSCoder coder)
-    {
-        super(QuicktimeMovie);
-        decode(coder);
-    }
-    /** Constructs an FSQuicktimeMovie object referencing the specified file.
+			if (name != null)
+				result = name.equals(typedObject.name);
+			else
+				result = name == typedObject.name;
+		}
+		return result;
+	}
 
-        @param aString the file or URL where the file is located.
-        */
-    public FSQuicktimeMovie(String aString)
-    {
-        super(QuicktimeMovie);
-        setName(aString);
-    }
-    /**
-     * Constructs an FSQuicktimeMovie object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSQuicktimeMovie object.
-     */
-    public FSQuicktimeMovie(FSQuicktimeMovie obj)
-    {
-        super(obj);
-        name = new String(obj.name);
-    }    
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the reference to the file containing the movie.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;name&quot;, name);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the location of the file or URL.
-        */
-    public String getName() { return name; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the reference to the file containing the movie.
+		length += coder.strlen(name, true);
 
-        @param aString the file or URL where the file is located.
-        */
-    public void setName(String aString)
-    {
-        name = aString;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSQuicktimeMovie typedObject = (FSQuicktimeMovie)anObject;
-            
-            if (name != null)
-                result = name.equals(typedObject.name);
-            else
-                result = name == typedObject.name;
-        }
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeString(name);
+		coder.writeWord(0, 1);
+		coder.endObject(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;name&quot;, name);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += coder.strlen(name, true);
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeString(name);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        name = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		name = coder.readString();
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSRegisterCopy.java
===================================================================
--- trunk/src/com/flagstone/transform/FSRegisterCopy.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSRegisterCopy.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,137 +31,158 @@
 package com.flagstone.transform;
 
 /**
-FSRegisterCopy is used to copy the item at the top of the stack to one of the Flash Player's
-internal registers. 
- 
-&lt;p&gt;The value is not removed from the stack. The number of registers supported was 
-expanded in Flash 7 to 256.&lt;/p&gt;
+ * FSRegisterCopy is used to copy the item at the top of the stack to one of the
+ * Flash Player's internal registers.
+ * 
+ * &lt;p&gt;
+ * The value is not removed from the stack. The number of registers supported
+ * was expanded in Flash 7 to 256.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The Flash Player uses a stack to store values when executing the actions
+ * associated with a button being pushed, frame being played, etc. If a value is
+ * used repeatedly in a calculation, it must be pushed onto the stack each time
+ * using an FSPush action. To speed up the execution of the calculation and
+ * reduce the amount of code required the value can be saved to one of the
+ * internal registers of the Flash Player using the FSRegisterCopy action. This
+ * copies the value currently at the top of the stack into the specified
+ * register. Pushing an FSRegisterIndex object onto the stack creates a
+ * reference to the register so the Flash Player uses the value directly rather
+ * than pushing the value onto the stack then immediately popping to use the
+ * value in a calculation.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * To copy a value from the top of the stack to a register, specify the number
+ * of the register, 0..255, in the constructor:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Copy a useful value into one of the Flash Player's registers
+ * 
+ * actions.add(new FSPush(3.1415296));
+ * actions.add(new FSRegisterCopy(0));
+ * 
+ * // Use a FSRegisterIndex to look it up later
+ * 
+ * actions.add(new FSPush(FSRegisterIndex(0)));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRegisterCopy action represents the ActionStoreRegister action in the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 5 and expanded in Flash 7 to support up to 256 registers.
+ * &lt;/p&gt;
+ */
+public class FSRegisterCopy extends FSActionObject
+{
+	private int registerNumber = 0;
 
-&lt;p&gt;The Flash Player uses a stack to store values when executing the actions 
-associated with a button being  pushed, frame being played, etc. If a value is 
-used repeatedly in a calculation, it must be pushed onto the stack each time using 
-an FSPush action. To speed up the execution of the calculation and reduce the 
-amount of code required the value can be saved to one of the internal registers 
-of the Flash Player using the FSRegisterCopy action. This copies the value 
-currently at the top of the stack into the specified register. Pushing an 
-FSRegisterIndex object onto the stack creates a reference to the register so the 
-Flash Player uses the value directly rather than pushing the value onto the stack 
-then immediately popping to use the value in a calculation.&lt;/p&gt;
+	/**
+	 * Construct an FSRegisterCopy object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRegisterCopy(FSCoder coder)
+	{
+		super(RegisterCopy);
+		decode(coder);
+	}
 
-&lt;p&gt;To copy a value from the top of the stack to a register, specify the number 
-of the register, 0..255, in the constructor:&lt;/p&gt;
+	/**
+	 * Constructs an FSRegisterCopy object with the register number.
+	 * 
+	 * @param anIndex
+	 *            the number of one of the Flash Player's internal registers.
+	 */
+	public FSRegisterCopy(int anIndex)
+	{
+		super(RegisterCopy);
+		setRegisterNumber(anIndex);
+	}
 
-&lt;pre&gt;
-// Copy a useful value into one of the Flash Player's registers
+	/**
+	 * Constructs an FSRegisterCopy object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSRegisterCopy object.
+	 */
+	public FSRegisterCopy(FSRegisterCopy obj)
+	{
+		super(obj);
+		registerNumber = obj.registerNumber;
+	}
 
-actions.add(new FSPush(3.1415296));
-actions.add(new FSRegisterCopy(0));
+	/**
+	 * Gets the number of the Player register that the value on the stack will
+	 * be copied to.
+	 * 
+	 * @return the register number in the range 0..3.
+	 */
+	public int getRegisterNumber()
+	{
+		return registerNumber;
+	}
 
-// Use a FSRegisterIndex to look it up later
+	/**
+	 * Gets the number of the Player register that the value on the stack will
+	 * be copied to.
+	 * 
+	 * @param anIndex
+	 *            the number of one of the Flash Player's internal registers.
+	 */
+	public void setRegisterNumber(int anIndex)
+	{
+		registerNumber = anIndex;
+	}
 
-actions.add(new FSPush(FSRegisterIndex(0)));
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+			result = registerNumber == ((FSRegisterCopy) anObject)
+							.getRegisterNumber();
 
-&lt;p&gt;The FSRegisterCopy action represents the ActionStoreRegister action in the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5 
-and expanded in Flash 7 to support up to 256 registers.&lt;/p&gt;
- */  
-public class FSRegisterCopy extends FSActionObject
-{
-    private int registerNumber = 0;
-    
-    /**
-     * Construct an FSRegisterCopy object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRegisterCopy(FSCoder coder)
-    {
-        super(RegisterCopy);
-        decode(coder);
-    }
-    /** Constructs an FSRegisterCopy object with the register number.
+		return result;
+	}
 
-        @param anIndex the number of one of the Flash Player's internal registers.
-        */
-    public FSRegisterCopy(int anIndex)
-    {
-        super(RegisterCopy);
-        setRegisterNumber(anIndex);
-    }
-    /**
-     * Constructs an FSRegisterCopy object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSRegisterCopy object.
-     */
-    public FSRegisterCopy(FSRegisterCopy obj)
-    {
-        super(obj);
-        registerNumber = obj.registerNumber;
-    }    
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the number of the Player register that the value on the stack will be copied to.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;registerNumber&quot;, registerNumber);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the register number in the range 0..3.
-        */
-    public int getRegisterNumber() 
-    {
-        return registerNumber;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the number of the Player register that the value on the stack will be copied to.
+		length += 1;
 
-        @param anIndex the number of one of the Flash Player's internal registers.
-        */
-    public void setRegisterNumber(int anIndex) 
-    {
-        registerNumber = anIndex;
-    }
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = registerNumber == ((FSRegisterCopy)anObject).getRegisterNumber();
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(registerNumber, 1);
+	}
 
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;registerNumber&quot;, registerNumber);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(registerNumber, 1);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        registerNumber = coder.readWord(1, false);
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		registerNumber = coder.readWord(1, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSRegisterIndex.java
===================================================================
--- trunk/src/com/flagstone/transform/FSRegisterIndex.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSRegisterIndex.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,123 +31,159 @@
 package com.flagstone.transform;
 
 /**
-FSRegisterIndex is used with an FSPush action to refer to one of the Flash Player's 
-internal registers that contains a value to be used in a calculation.
- 
-&lt;p&gt;The number of registers in the Flash Player was increased in Flash 7 to 256.&lt;/p&gt;
+ * FSRegisterIndex is used with an FSPush action to refer to one of the Flash
+ * Player's internal registers that contains a value to be used in a
+ * calculation.
+ * 
+ * &lt;p&gt;
+ * The number of registers in the Flash Player was increased in Flash 7 to 256.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The Flash Player uses a stack to store values when executing the actions
+ * associated with a button being pushed, frame being played, etc. If a value is
+ * used repeatedly in a calculation, it must be pushed onto the stack each time
+ * using an FSPush action. To speed up the execution of the calculation and
+ * reduce the amount of code required the value can be saved to one of the
+ * internal registers of the Flash Player using the FSRegisterCopy action (which
+ * copies the value currently at the top of the stack into the specified
+ * register). An FSRegisterIndex creates a reference to the register so the
+ * Flash Player uses the value directly rather than popping it from the stack.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * To copy a value from the top of the stack to one of the Flash Player's
+ * internal registers specify the register number in the constructor for the
+ * FSRegisterCopy class:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList actions = new ArrayList();
+ *  ...
+ *  actions.add(new FSRegisterCopy(0));
+ *  ...
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * References to one of the Flash Player's internal registers are created using
+ * the FSRegisterIndex class and pushing it onto the stack using the FSPush
+ * class. When the value is used in a calculation then the value will be
+ * retrieved from the specified register.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSPush push = new FSPush();
+ *  push.add(new FSRegisterIndex(0));
+ *  ...
+ *  actions.add(push);
+ *  ...
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The RegisterCopy action and access to the Flash Player's internal registers
+ * was introduced in Flash 5. The number of registers supported was expanded in
+ * Flash 7 to 256.
+ * &lt;/p&gt;
+ */
+public class FSRegisterIndex extends FSTransformObject
+{
+	private int index = 0;
 
-&lt;p&gt;The Flash Player uses a stack to store values when executing the actions associated with a button being  pushed, frame being played, etc. If a value is used repeatedly in a calculation, it must be pushed onto the stack each time using an FSPush action. To speed up the execution of the calculation and reduce the amount of code required the value can be saved to one of the internal registers of the Flash Player using the FSRegisterCopy action (which copies the value currently at the top of the stack into the specified register). An FSRegisterIndex creates a reference to the register so the Flash Player uses the value directly rather than popping it from the stack.&lt;/p&gt;
+	/**
+	 * Construct an FSRegisterIndex object, initalizing it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRegisterIndex(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;p&gt;To copy a value from the top of the stack to one of the Flash Player's internal registers specify the register number in the constructor for the FSRegisterCopy class:&lt;/p&gt;
+	/**
+	 * Constructs an FSRegisterIndex object referencing the value stored in one
+	 * of the Flash Player's internal registers.
+	 * 
+	 * @param anIndex
+	 *            the register number.
+	 */
+	public FSRegisterIndex(int anIndex)
+	{
+		setIndex(anIndex);
+	}
 
-&lt;pre&gt;
-ArrayList actions = new ArrayList();
-...
-actions.add(new FSRegisterCopy(0));
-...
-&lt;/pre&gt;
+	/**
+	 * Constructs an FSRegisterIndex object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSRegisterIndex object.
+	 */
+	public FSRegisterIndex(FSRegisterIndex obj)
+	{
+		index = obj.index;
+	}
 
-&lt;p&gt;References to one of the Flash Player's internal registers are created using the FSRegisterIndex class and pushing it onto the stack using the FSPush class. When the value is used in a calculation then the value will be retrieved from the specified register.&lt;/p&gt;
+	/**
+	 * Gets the number of the Flash Player's internal register.
+	 * 
+	 * @return the register number.
+	 */
+	public int getIndex()
+	{
+		return index;
+	}
 
-&lt;pre&gt;
-FSPush push = new FSPush();
-push.add(new FSRegisterIndex(0));
-...
-actions.add(push);
-...
-&lt;/pre&gt;
+	/**
+	 * Sets the number of the Flash Player's internal register.
+	 * 
+	 * @param anIndex
+	 *            the register number.
+	 */
+	public void setIndex(int anIndex)
+	{
+		index = anIndex;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The RegisterCopy action and access to the Flash Player's internal registers was introduced in Flash 5. The number of registers supported was expanded in Flash 7 to 256.&lt;/p&gt;
- */  
-public class FSRegisterIndex extends FSTransformObject
-{
-    private int index = 0;
+		if (super.equals(anObject))
+			result = index == ((FSRegisterIndex) anObject).getIndex();
 
-    /**
-     * Construct an FSRegisterIndex object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRegisterIndex(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSRegisterIndex object referencing the value stored in one of the Flash Player's internal registers.
+		return result;
+	}
 
-        @param anIndex the register number.
-        */
-    public FSRegisterIndex(int anIndex)
-    {
-        setIndex(anIndex);
-    }
-    /**
-     * Constructs an FSRegisterIndex object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSRegisterIndex object.
-     */
-    public FSRegisterIndex(FSRegisterIndex obj)
-    {
-        index = obj.index;
-    }    
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the number of the Flash Player's internal register.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;index&quot;, index);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the register number.
-        */
-    public int getIndex() 
-    {
-        return index;
-    }
+	public int length(FSCoder coder)
+	{
+		return 2;
+	}
 
-    /** Sets the number of the Flash Player's internal register.
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(4, 1);
+		coder.writeWord(index, 1);
+	}
 
-        @param anIndex the register number.
-        */
-    public void setIndex(int anIndex) 
-    {
-        index = anIndex;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = index == ((FSRegisterIndex)anObject).getIndex();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;index&quot;, index);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    { 
-        return 2;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.writeWord(4, 1);
-        coder.writeWord(index, 1);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        /* type */ coder.readWord(1, false);
-        index = coder.readWord(1, false);
-    }
+	public void decode(FSCoder coder)
+	{
+		/* type */coder.readWord(1, false);
+		index = coder.readWord(1, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSRegisterVariable.java
===================================================================
--- trunk/src/com/flagstone/transform/FSRegisterVariable.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSRegisterVariable.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,139 +31,162 @@
 package com.flagstone.transform;
 
 /**
-FSRegisterVariable is a lightweight class used to identify the register that an argument 
-defined in The FSNewFunction2 class is mapped into when executing the function.
-
-&lt;p&gt;Register numbers up to 255 may be specified. If the number is zero then the 
-argument is defined as a local variable.&lt;/p&gt;
- */  
+ * FSRegisterVariable is a lightweight class used to identify the register that
+ * an argument defined in The FSNewFunction2 class is mapped into when executing
+ * the function.
+ * 
+ * &lt;p&gt;
+ * Register numbers up to 255 may be specified. If the number is zero then the
+ * argument is defined as a local variable.
+ * &lt;/p&gt;
+ */
 public class FSRegisterVariable extends FSTransformObject
 {
-    private int index = 0;
-    private String name = null;
+	private int index = 0;
 
-    /**
-     * Construct an FSRegisterVariable object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRegisterVariable(FSCoder coder)
-    {
-        decode(coder);
-    }    
-    /**
-     * Constructs a new FSRegisterVariable object specifying the name of the argument and 
-     * the number of the register it will be mapped to. If the index is 0 then the 
-     * argument will be stored in a local variable.
-     *
-     * @param index the number of the register, 1..255, 0 if the argument will be stored in a local variable.
-     * @param name the name of the argument.
-     */
-    public FSRegisterVariable(int index, String name)
-    {
-        this.index = index;    
-        this.name = name;
-    }
+	private String name = null;
 
-    /**
-     * Gets the number of the register that will contain the function argument.
-     *
-     * @return the number of the register, 1..255, in which the function argument will be stored, 0 if the argument will be stored in a local variable.
-     */
-    public int getIndex() { return index; }
-    /**
-     * Constructs an FSRegisterVariable object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSRegisterVariable object.
-     */
-    public FSRegisterVariable(FSRegisterVariable obj)
-    {
-        index = obj.index;
-        name = new String(obj.name);
-    }    
+	/**
+	 * Construct an FSRegisterVariable object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRegisterVariable(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    /**
-     * Gets the name of the function argument.
-     *
-     * @return the name of the argument.
-     */
-    public String getName() { return name; }
+	/**
+	 * Constructs a new FSRegisterVariable object specifying the name of the
+	 * argument and the number of the register it will be mapped to. If the
+	 * index is 0 then the argument will be stored in a local variable.
+	 * 
+	 * @param index
+	 *            the number of the register, 1..255, 0 if the argument will be
+	 *            stored in a local variable.
+	 * @param name
+	 *            the name of the argument.
+	 */
+	public FSRegisterVariable(int index, String name)
+	{
+		this.index = index;
+		this.name = name;
+	}
 
-    /**
-     * Sets the number of the register that will contain the function argument.
-     *
-     * @param index the number of the register, 1..255, in which the function argument will be stored, 0 if the argument will be stored in a local variable.
-     */
-    public void setIndex(int index)
-    {
-        this.index = index;
-    }
+	/**
+	 * Gets the number of the register that will contain the function argument.
+	 * 
+	 * @return the number of the register, 1..255, in which the function
+	 *         argument will be stored, 0 if the argument will be stored in a
+	 *         local variable.
+	 */
+	public int getIndex()
+	{
+		return index;
+	}
 
-    /**
-     * Sets the name of the function argument.
-     *
-     * @param name the name of the argument.
-     */
-     public void setName(String name)
-    {
-        this.name = name;
-    }
+	/**
+	 * Constructs an FSRegisterVariable object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSRegisterVariable object.
+	 */
+	public FSRegisterVariable(FSRegisterVariable obj)
+	{
+		index = obj.index;
+		name = new String(obj.name);
+	}
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSRegisterVariable typedObject = (FSRegisterVariable)anObject;
-            
-            result = index == typedObject.index;
-            result = result &amp;&amp; name.equals(typedObject.name);
-        }
-        return result;
-    }
+	/**
+	 * Gets the name of the function argument.
+	 * 
+	 * @return the name of the argument.
+	 */
+	public String getName()
+	{
+		return name;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	/**
+	 * Sets the number of the register that will contain the function argument.
+	 * 
+	 * @param index
+	 *            the number of the register, 1..255, in which the function
+	 *            argument will be stored, 0 if the argument will be stored in a
+	 *            local variable.
+	 */
+	public void setIndex(int index)
+	{
+		this.index = index;
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;index&quot;, index);
-            Transform.append(buffer, &quot;name&quot;, name);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	/**
+	 * Sets the name of the function argument.
+	 * 
+	 * @param name
+	 *            the name of the argument.
+	 */
+	public void setName(String name)
+	{
+		this.name = name;
+	}
 
-    public int length(FSCoder coder)
-    {
-        int length = 1;
-        
-        length += coder.strlen(name, true);
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(index, 1);
-        coder.writeString(name);
-        coder.writeWord(0, 1);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        index = coder.readWord(1, false);
-        name = coder.readString();
-    }
+		if (super.equals(anObject))
+		{
+			FSRegisterVariable typedObject = (FSRegisterVariable) anObject;
+
+			result = index == typedObject.index;
+			result = result &amp;&amp; name.equals(typedObject.name);
+		}
+		return result;
+	}
+
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;index&quot;, index);
+			Transform.append(buffer, &quot;name&quot;, name);
+			buffer.append(&quot;}&quot;);
+		}
+	}
+
+	public int length(FSCoder coder)
+	{
+		int length = 1;
+
+		length += coder.strlen(name, true);
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(index, 1);
+		coder.writeString(name);
+		coder.writeWord(0, 1);
+	}
+
+	public void decode(FSCoder coder)
+	{
+		index = coder.readWord(1, false);
+		name = coder.readString();
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSRemoveObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSRemoveObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSRemoveObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,183 +31,232 @@
 package com.flagstone.transform;
 
 /**
-FSRemoveObject removes an object from the Flash Player's Display List. 
-
-&lt;p&gt;An object placed on the display list is displayed in every frame of a movie until it is explicitly removed. Objects must also be removed if its location or appearance is changed using either the FSPlaceObject or FSPlaceObject2 classes.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSRemoveobject_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveobject_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The unique identifier, in the range 1..65535, of the object.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveobject_2&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The layer at which the object is placed in the Display List.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
-
-&lt;p&gt;Although only one object can be placed on any layer in the display list both the object's unique identifier and the layer number must be specified. The FSRemoveObject class is superseded in Flash 3 by the FSRemoveObject2 class which lifts this requirement allowing an object to be referenced by the layer number it occupies in the display list.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-
-&lt;p&gt;1. Remove an object.&lt;br/&gt;
-To remove an object from the display list the object's identifier and the layer number using when the object was placed is used.&lt;/p&gt;
-
-&lt;pre&gt;
-// Place a shape to the display list for one frame.
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-
-// now remove it.
-movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-&lt;p&gt;2. Move an object.&lt;br/&gt;
-To move an object it first must be removed from the display list and repositioned at its new location. Adding the object, with a new location, on the same layer, although only one object can be displayed on a given layer, will not work. The object will be displayed twice.&lt;/p&gt;
-
-&lt;pre&gt;
-// Add the shape to the display list.
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
-movie.add(new FSShowFrame());
-
-// Move shape to a new location, removing the original so it does not get displayed twice.
-movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
-movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSRemoveObject class represents the RemoveObject tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1 and is superseded by the RemoveObject2 tag which was added in Flash 3.&lt;/p&gt;
+ * FSRemoveObject removes an object from the Flash Player's Display List.
+ * 
+ * &lt;p&gt;
+ * An object placed on the display list is displayed in every frame of a movie
+ * until it is explicitly removed. Objects must also be removed if its location
+ * or appearance is changed using either the FSPlaceObject or FSPlaceObject2
+ * classes.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The unique identifier, in the range 1..65535, of the object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The layer at which the object is placed in the Display List.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although only one object can be placed on any layer in the display list both
+ * the object's unique identifier and the layer number must be specified. The
+ * FSRemoveObject class is superseded in Flash 3 by the FSRemoveObject2 class
+ * which lifts this requirement allowing an object to be referenced by the layer
+ * number it occupies in the display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Remove an object.&lt;br/&gt; To remove an object from the display list the
+ * object's identifier and the layer number using when the object was placed is
+ * used.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Place a shape to the display list for one frame.
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // now remove it.
+ * movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Move an object.&lt;br/&gt; To move an object it first must be removed from the
+ * display list and repositioned at its new location. Adding the object, with a
+ * new location, on the same layer, although only one object can be displayed on
+ * a given layer, will not work. The object will be displayed twice.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Add the shape to the display list.
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 400, 400));
+ * movie.add(new FSShowFrame());
+ * 
+ * // Move shape to a new location, removing the original so it does not get displayed twice.
+ * movie.add(new FSRemoveObject(shape.getIdentifier(), 1));
+ * movie.add(new FSPlaceObject(shape.getIdentifier(), 1, 250, 300));
+ * movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRemoveObject class represents the RemoveObject tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1 and is
+ * superseded by the RemoveObject2 tag which was added in Flash 3.
+ * &lt;/p&gt;
  */
 public class FSRemoveObject extends FSMovieObject
 {
-    private int identifier = 0;
-    private int layer = 0;
+	private int identifier = 0;
+	private int layer = 0;
 
-    /**
-     * Construct an FSRemoveObject object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRemoveObject(FSCoder coder)
-    {
-        super(FSMovieObject.RemoveObject);
-        decode(coder);
-    }
-    /**  Constructs an FSRemoveObject object that will remove an object with the specified identifier from the given layer in the display list.
+	/**
+	 * Construct an FSRemoveObject object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRemoveObject(FSCoder coder)
+	{
+		super(FSMovieObject.RemoveObject);
+		decode(coder);
+	}
 
-        @param anIdentifier the unique identifier for the object currently on the display list.
-        @param layer the layer in the display list where the object is being displayed.
-        */
-    public FSRemoveObject(int anIdentifier, int layer)
-    {
-        super(FSMovieObject.RemoveObject);
-        setIdentifier(anIdentifier);
-        setLayer(layer);
-    }
-    /**
-     * Constructs an FSRemoveObject object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSRemoveObject object.
-     */
-    public FSRemoveObject(FSRemoveObject obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        layer = obj.layer;
-    }    
+	/**
+	 * Constructs an FSRemoveObject object that will remove an object with the
+	 * specified identifier from the given layer in the display list.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object currently on the display
+	 *            list.
+	 * @param layer
+	 *            the layer in the display list where the object is being
+	 *            displayed.
+	 */
+	public FSRemoveObject(int anIdentifier, int layer)
+	{
+		super(FSMovieObject.RemoveObject);
+		setIdentifier(anIdentifier);
+		setLayer(layer);
+	}
 
-    /** Gets the identifier of the object to be removed from the display list.
+	/**
+	 * Constructs an FSRemoveObject object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSRemoveObject object.
+	 */
+	public FSRemoveObject(FSRemoveObject obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		layer = obj.layer;
+	}
 
-        @return the identifier of the object to be removed.
-        */
-    public int getIdentifier() { return identifier; }
+	/**
+	 * Gets the identifier of the object to be removed from the display list.
+	 * 
+	 * @return the identifier of the object to be removed.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-    /** Gets the layer in the display list where the object will be displayed.
+	/**
+	 * Gets the layer in the display list where the object will be displayed.
+	 * 
+	 * @return the layer number where the object to be removed is displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-        @return the layer number where the object to be removed is displayed.
-        */
-    public int getLayer() { return layer; }
+	/**
+	 * Sets the identifier of the object to be removed.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier for the object currently on the display
+	 *            list.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-    /** Sets the identifier of the object to be removed.
+	/**
+	 * Sets the layer in the display list where the object will be displayed.
+	 * 
+	 * @param aLayer
+	 *            the layer in the display list where the object is being
+	 *            displayed.
+	 */
+	public void setLayer(int aLayer)
+	{
+		layer = aLayer;
+	}
 
-        @param anIdentifier the unique identifier for the object currently on the display list.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the layer in the display list where the object will be displayed.
+		if (super.equals(anObject))
+		{
+			FSRemoveObject typedObject = (FSRemoveObject) anObject;
 
-        @param aLayer the layer in the display list where the object is being displayed.
-        */
-    public void setLayer(int aLayer)
-    {
-        layer = aLayer;
-    }
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; layer == typedObject.layer;
+		}
+		return result;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSRemoveObject typedObject = (FSRemoveObject)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; layer == typedObject.layer;
-        }
-        return result;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;layer&quot;, layer);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 4;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 4;
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(identifier, 2);
-        coder.writeWord(layer, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        identifier = coder.readWord(2, false);
-        layer = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(identifier, 2);
+		coder.writeWord(layer, 2);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		identifier = coder.readWord(2, false);
+		layer = coder.readWord(2, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSRemoveObject2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSRemoveObject2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSRemoveObject2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,125 +31,150 @@
 package com.flagstone.transform;
 
 /**
-FSRemoveObject2 removes an object from the display list.
+ * FSRemoveObject2 removes an object from the display list.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The number of the layer in the Flash Player's Display List where the
+ * object is displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRemoveObject2 class only requires the layer number to identify a
+ * particular object, unlike the FSRemoveObject class which also requires the
+ * object's identifier although only one object can be placed on a given layer.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSRemoveObject2 class represents the RemoveObject2 tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSRemoveObject2 extends FSMovieObject
+{
+	private int layer = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSRemoveObject2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSRemoveObject2(FSCoder coder)
+	{
+		super(RemoveObject2);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSRemoveObject2, specifying the layer in the display list
+	 * where the object to be removed is currently displayed.
+	 * 
+	 * @param layer
+	 *            the layer number on which the object is displayed.
+	 */
+	public FSRemoveObject2(int layer)
+	{
+		super(RemoveObject2);
+		setLayer(layer);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveObject2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSRemoveObject2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSRemoveObject2 object.
+	 */
+	public FSRemoveObject2(FSRemoveObject2 obj)
+	{
+		super(obj);
+		layer = obj.layer;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSRemoveObject2_1&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the layer in the Flash Player's Display List where the object is displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the layer in the display list where the object to be removed is
+	 * currently displayed.
+	 * 
+	 * @return the layer number where the object is currently displayed.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the layer in the display list from which the object will be removed.
+	 * 
+	 * @param aLayer
+	 *            the layer number on which the object is displayed.
+	 */
+	public void setLayer(int aLayer)
+	{
+		layer = aLayer;
+	}
 
-&lt;p&gt;The FSRemoveObject2 class only requires the layer number to identify a particular object, unlike the FSRemoveObject class which also requires the object's identifier although only one object can be placed on a given layer.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSRemoveObject2 typedObject = (FSRemoveObject2) anObject;
 
-&lt;p&gt;The FSRemoveObject2 class represents the RemoveObject2 tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash in Flash 3.&lt;/p&gt;
- */ 
-public class FSRemoveObject2 extends FSMovieObject
-{
-    private int layer = 0;
+			result = layer == typedObject.layer;
+		}
+		return result;
+	}
 
-    /**
-     * Construct an FSRemoveObject2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSRemoveObject2(FSCoder coder)
-    {
-        super(RemoveObject2);
-        decode(coder);
-    }
-    /** Constructs an FSRemoveObject2, specifying the layer in the display list where the object to be removed is currently displayed.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param layer the layer number on which the object is displayed.
-        */
-    public FSRemoveObject2(int layer)
-    {
-        super(RemoveObject2);
-        setLayer(layer);
-    }
-    /**
-     * Constructs an FSRemoveObject2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSRemoveObject2 object.
-     */
-    public FSRemoveObject2(FSRemoveObject2 obj)
-    {
-        super(obj);
-        layer = obj.layer;
-    }    
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;layer&quot;, layer);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Gets the layer in the display list where the object to be removed is currently displayed.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += 2;
 
-        @return the layer number where the object is currently displayed.
-        */
-    public int getLayer() { return layer; }
+		return length;
+	}
 
-    /** Sets the layer in the display list from which the object will be removed.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(layer, 2);
+		coder.endObject(name());
+	}
 
-        @param aLayer the layer number on which the object is displayed.
-        */
-    public void setLayer(int aLayer)
-    {
-        layer = aLayer;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSRemoveObject2 typedObject = (FSRemoveObject2)anObject;
-            
-            result = layer == typedObject.layer;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;layer&quot;, layer);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += 2;
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(layer, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        layer = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		layer = coder.readWord(2, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSScreenVideoPacket.java
===================================================================
--- trunk/src/com/flagstone/transform/FSScreenVideoPacket.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSScreenVideoPacket.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,251 +33,259 @@
 import java.util.Iterator;
 
 /**
- * The FSScreenVideoPacket class is used to encode or decode a frame of video data using 
- * Macromedia's ScreenVideo format.
+ * The FSScreenVideoPacket class is used to encode or decode a frame of video
+ * data using Macromedia's ScreenVideo format.
  * 
  */
 public final class FSScreenVideoPacket implements Cloneable
 {
-    private boolean keyFrame;
-    private int codec;
-    
-    private int blockWidth;
-    private int blockHeight;
+	private boolean keyFrame;
 
-    private int imageWidth;
-    private int imageHeight;
-    
-    private ArrayList imageBlocks;
+	private int codec;
 
+	private int blockWidth;
+
+	private int blockHeight;
+
+	private int imageWidth;
+
+	private int imageHeight;
+
+	private ArrayList imageBlocks;
+
 	public FSScreenVideoPacket(byte[] data)
 	{
 		decode(data);
 	}
 
-    public FSScreenVideoPacket(boolean key, int codec, int imageWidth, int imageHeight, int blockWidth, int blockHeight, ArrayList blocks)
+	public FSScreenVideoPacket(boolean key, int codec, int imageWidth,
+								int imageHeight, int blockWidth,
+								int blockHeight, ArrayList blocks)
 	{
-    	setKeyFrame(key);
-    	setCodec(codec);
-        setImageWidth(imageWidth);
-        setImageHeight(imageHeight);
-        setBlockWidth(blockWidth);
-        setBlockHeight(blockHeight);
-        setImageBlocks(blocks);
+		setKeyFrame(key);
+		setCodec(codec);
+		setImageWidth(imageWidth);
+		setImageHeight(imageHeight);
+		setBlockWidth(blockWidth);
+		setBlockHeight(blockHeight);
+		setImageBlocks(blocks);
 	}
-    
-    public void add(FSImageBlock block)
-    {
-        imageBlocks.add(block);
-    }
 
-	public boolean getKeyFrame() 
-    {
-        return keyFrame; 
-    }
+	public void add(FSImageBlock block)
+	{
+		imageBlocks.add(block);
+	}
 
-	public void setKeyFrame(boolean key) 
-    {
-        keyFrame = key; 
-    }
+	public boolean getKeyFrame()
+	{
+		return keyFrame;
+	}
 
-	public int getCodec() 
-    {
-        return codec; 
-    }
+	public void setKeyFrame(boolean key)
+	{
+		keyFrame = key;
+	}
 
-	public void setCodec(int codec) 
-    {
-        this.codec = codec; 
-    }
+	public int getCodec()
+	{
+		return codec;
+	}
 
-	public int getImageWidth() 
-    {
-        return imageWidth; 
-    }
+	public void setCodec(int codec)
+	{
+		this.codec = codec;
+	}
 
-	public void setImageWidth(int width) 
-    {
-        imageWidth = width; 
-    }
+	public int getImageWidth()
+	{
+		return imageWidth;
+	}
 
-    public int getImageHeight() 
-    { 
-        return imageHeight; 
-    }
+	public void setImageWidth(int width)
+	{
+		imageWidth = width;
+	}
 
-	public void setImageHeight(int height) 
-    {
-        imageHeight = height; 
-    }
+	public int getImageHeight()
+	{
+		return imageHeight;
+	}
 
-	public int getBlockWidth() 
-    {
-        return blockWidth; 
-    }
+	public void setImageHeight(int height)
+	{
+		imageHeight = height;
+	}
 
-	public void setBlockWidth(int width) 
-    {
-        blockWidth = width; 
-    }
+	public int getBlockWidth()
+	{
+		return blockWidth;
+	}
 
-    public int getBlockHeight() 
-    { 
-        return blockHeight; 
-    }
+	public void setBlockWidth(int width)
+	{
+		blockWidth = width;
+	}
 
-	public void setBlockHeight(int height) 
-    {
-        blockHeight = height; 
-    }
+	public int getBlockHeight()
+	{
+		return blockHeight;
+	}
 
-    public ArrayList getImageBlocks() 
-    { 
-        return imageBlocks; 
-    }
+	public void setBlockHeight(int height)
+	{
+		blockHeight = height;
+	}
 
-	public void setImageBlocks(ArrayList blocks) 
-    {
-        imageBlocks = new ArrayList(blocks); 
-    }
+	public ArrayList getImageBlocks()
+	{
+		return imageBlocks;
+	}
 
-    public Object clone()
+	public void setImageBlocks(ArrayList blocks)
 	{
-        FSScreenVideoPacket anObject = null;
-        
-        try
-        {
-            anObject = (FSScreenVideoPacket)super.clone();
-        
-            anObject.imageBlocks = new ArrayList();
-			
-            for (Iterator i = imageBlocks.iterator(); i.hasNext();)
-                anObject.imageBlocks.add(((FSImageBlock)i.next()).clone());
-	    }
-	    catch (CloneNotSupportedException e)
-	    {
-            throw new InternalError();
-	    }
+		imageBlocks = new ArrayList(blocks);
+	}
+
+	public Object clone()
+	{
+		FSScreenVideoPacket anObject = null;
+
+		try
+		{
+			anObject = (FSScreenVideoPacket) super.clone();
+
+			anObject.imageBlocks = new ArrayList();
+
+			for (Iterator i = imageBlocks.iterator(); i.hasNext();)
+				anObject.imageBlocks.add(((FSImageBlock) i.next()).clone());
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
 		{
-			FSScreenVideoPacket typedObject = (FSScreenVideoPacket)anObject;
-			
-            result = keyFrame == typedObject.keyFrame;
-            result = result &amp;&amp; codec == typedObject.codec;
-            result = result &amp;&amp; imageWidth == typedObject.imageWidth;
-            result = result &amp;&amp; imageHeight == typedObject.imageHeight;
-            result = result &amp;&amp; blockHeight == typedObject.blockHeight;
-            result = result &amp;&amp; blockWidth == typedObject.blockWidth;
-            result = result &amp;&amp; imageBlocks.equals(typedObject.imageBlocks);	
-        }
+			FSScreenVideoPacket typedObject = (FSScreenVideoPacket) anObject;
+
+			result = keyFrame == typedObject.keyFrame;
+			result = result &amp;&amp; codec == typedObject.codec;
+			result = result &amp;&amp; imageWidth == typedObject.imageWidth;
+			result = result &amp;&amp; imageHeight == typedObject.imageHeight;
+			result = result &amp;&amp; blockHeight == typedObject.blockHeight;
+			result = result &amp;&amp; blockWidth == typedObject.blockWidth;
+			result = result &amp;&amp; imageBlocks.equals(typedObject.imageBlocks);
+		}
 		return result;
-    }
+	}
 
-    private int length()
+	private int length()
 	{
 		int length = 5;
-        
-        FSImageBlock block;
-        
-		for (Iterator i = imageBlocks.iterator(); i.hasNext();) 
+
+		FSImageBlock block;
+
+		for (Iterator i = imageBlocks.iterator(); i.hasNext();)
 		{
-			block = (FSImageBlock)i.next();
-			
+			block = (FSImageBlock) i.next();
+
 			length += 2;
 
-			if (!block.isEmpty()) {
+			if (!block.isEmpty())
+			{
 				length += block.getData().length;
 			}
-        }
+		}
 		return length;
 	}
 
 	public byte[] encode()
 	{
-        byte[] data = new byte[length()];
-        
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
-    
-        coder.writeBits(keyFrame ? FSVideo.KeyFrame : FSVideo.Frame, 4);
-        coder.writeBits(codec, 4);
-        
-        coder.writeBits((blockWidth/16)-1, 4);
-        coder.writeBits(imageWidth, 12);
-        coder.writeBits((blockHeight/16)-1, 4);
-        coder.writeBits(imageHeight, 12);
-        
-        FSImageBlock block;
-        byte[] blockData;
+		byte[] data = new byte[length()];
 
-        for (Iterator i=imageBlocks.iterator(); i.hasNext();) 
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
+
+		coder.writeBits(keyFrame ? FSVideo.KeyFrame : FSVideo.Frame, 4);
+		coder.writeBits(codec, 4);
+
+		coder.writeBits((blockWidth / 16) - 1, 4);
+		coder.writeBits(imageWidth, 12);
+		coder.writeBits((blockHeight / 16) - 1, 4);
+		coder.writeBits(imageHeight, 12);
+
+		FSImageBlock block;
+		byte[] blockData;
+
+		for (Iterator i = imageBlocks.iterator(); i.hasNext();)
 		{
-			block = (FSImageBlock)i.next();
-			
-			if (block.isEmpty()) {
-		        coder.writeWord(0, 2);
-			}
-			else {
+			block = (FSImageBlock) i.next();
+
+			if (block.isEmpty())
+			{
+				coder.writeWord(0, 2);
+			} else
+			{
 				blockData = block.getData();
-		        coder.writeBits(blockData.length, 16);
-		        coder.writeBytes(blockData);				
+				coder.writeBits(blockData.length, 16);
+				coder.writeBytes(blockData);
 			}
-        }
-		
-        return coder.getData();
+		}
+
+		return coder.getData();
 	}
-	
+
 	public void decode(byte[] data)
-	{        
-        FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
-        
-        keyFrame = coder.readBits(4, false) == 1 ? true : false;
-        codec = coder.readBits(4, false);
-        
-        blockWidth = (coder.readBits(4, false) + 1) * 16;
-        imageWidth = coder.readBits(12, false);
-        blockHeight = (coder.readBits(4, false) + 1) * 16;
-        imageHeight = coder.readBits(12, false);
+	{
+		FSCoder coder = new FSCoder(FSCoder.LITTLE_ENDIAN, data);
 
-        int columns = imageWidth / blockWidth + ((imageWidth % blockWidth &gt; 0) ? 1 : 0);
-        int rows = imageHeight / blockHeight + ((imageHeight % blockHeight &gt; 0) ? 1 : 0);
-        
-        int height = imageHeight;
-        int width = imageWidth;
-        
-        imageBlocks = new ArrayList(rows*columns);
-        FSImageBlock block;
+		keyFrame = coder.readBits(4, false) == 1 ? true : false;
+		codec = coder.readBits(4, false);
 
-        for (int i=0; i&lt;rows; i++, height -= blockHeight)
-        {
-            for (int j=0; j&lt;columns; j++, width -= blockWidth)
-            {
-                int length = coder.readBits(16, false);
-                
-                if (length != 0)
-                {
-                    byte[] blockData = new byte[length];
-                    
-                    coder.readBytes(blockData);
-                    
-                    int dataHeight = (height &lt; blockHeight) ? height : blockHeight;
-                    int dataWidth = (width &lt; blockWidth) ? width : blockWidth;
-            
-                    block = new FSImageBlock(dataHeight, dataWidth, blockData);
-                }
-                else 
-                {
-                	block = new FSImageBlock(0, 0, null);
-                }
-        
-                imageBlocks.add(block);
-            }
-        }
+		blockWidth = (coder.readBits(4, false) + 1) * 16;
+		imageWidth = coder.readBits(12, false);
+		blockHeight = (coder.readBits(4, false) + 1) * 16;
+		imageHeight = coder.readBits(12, false);
+
+		int columns = imageWidth / blockWidth
+						+ ((imageWidth % blockWidth &gt; 0) ? 1 : 0);
+		int rows = imageHeight / blockHeight
+						+ ((imageHeight % blockHeight &gt; 0) ? 1 : 0);
+
+		int height = imageHeight;
+		int width = imageWidth;
+
+		imageBlocks = new ArrayList(rows * columns);
+		FSImageBlock block;
+
+		for (int i = 0; i &lt; rows; i++, height -= blockHeight)
+		{
+			for (int j = 0; j &lt; columns; j++, width -= blockWidth)
+			{
+				int length = coder.readBits(16, false);
+
+				if (length != 0)
+				{
+					byte[] blockData = new byte[length];
+
+					coder.readBytes(blockData);
+
+					int dataHeight = (height &lt; blockHeight) ? height
+									: blockHeight;
+					int dataWidth = (width &lt; blockWidth) ? width : blockWidth;
+
+					block = new FSImageBlock(dataHeight, dataWidth, blockData);
+				} else
+				{
+					block = new FSImageBlock(0, 0, null);
+				}
+
+				imageBlocks.add(block);
+			}
+		}
 	}
 }

Modified: trunk/src/com/flagstone/transform/FSSerialNumber.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSerialNumber.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSerialNumber.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,136 +31,156 @@
 package com.flagstone.transform;
 
 /**
-FSSerialNumber is used to add a user-defined serial number into a Flash file. 
- 
-&lt;p&gt;The serial number is simply a string and can contain arbitrary information.&lt;/p&gt;
+ * FSSerialNumber is used to add a user-defined serial number into a Flash file.
+ * 
+ * &lt;p&gt;
+ * The serial number is simply a string and can contain arbitrary information.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;serialNumber&lt;/td&gt;
+ * &lt;td&gt;A string containing the serial number.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ * movie.add(new FSSerialNumber(&quot;1234-DGF-2354&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSerialNumber represents the SerialNumber tag in the Macromedia Flash
+ * (SWF) File Format Specification. It is not known when this tag was
+ * introduced.
+ * &lt;/p&gt;
+ */
+public class FSSerialNumber extends FSMovieObject
+{
+	private String serialNumber = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSerialNumber object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSerialNumber(FSCoder coder)
+	{
+		super(SerialNumber);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSerialNumber action with the specified string.
+	 * 
+	 * @param aString
+	 *            an arbitrary string containing the serial number.
+	 */
+	public FSSerialNumber(String aString)
+	{
+		super(SerialNumber);
+		setSerialNumber(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSerialNumber_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSerialNumber object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSerialNumber object.
+	 */
+	public FSSerialNumber(FSSerialNumber obj)
+	{
+		super(obj);
+		serialNumber = new String(obj.serialNumber);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSerialNumber_1&quot;&gt;serialNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A string containing the serial number.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the serial number.
+	 * 
+	 * @return the serial number string.
+	 */
+	public String getSerialNumber()
+	{
+		return serialNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	/**
+	 * Sets the serial number.
+	 * 
+	 * @param aString
+	 *            an arbitrary string containing the serial number.
+	 */
+	public void setSerialNumber(String aString)
+	{
+		serialNumber = aString;
+	}
 
-&lt;pre&gt;
-movie.add(new FSSerialNumber(&quot;1234-DGF-2354&quot;));
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSSerialNumber typedObject = (FSSerialNumber) anObject;
 
-&lt;p&gt;The FSSerialNumber represents the SerialNumber tag in the Macromedia Flash (SWF) File Format Specification. It is not known when this tag was introduced.&lt;/p&gt;
- */  
-public class FSSerialNumber extends FSMovieObject
-{
-    private String serialNumber = null;
-    
-    /**
-     * Construct an FSSerialNumber object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSerialNumber(FSCoder coder)
-    {
-        super(SerialNumber);
-        decode(coder);
-    }
-    /** Constructs an FSSerialNumber action with the specified string. 
+			if (serialNumber != null)
+				result = serialNumber.equals(typedObject.serialNumber);
+			else
+				result = serialNumber == typedObject.serialNumber;
+		}
+		return result;
+	}
 
-        @param aString an arbitrary string containing the serial number.
-        */
-    public FSSerialNumber(String aString)
-    {
-        super(SerialNumber);
-        setSerialNumber(aString);
-    }
-    /**
-     * Constructs an FSSerialNumber object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSerialNumber object.
-     */
-    public FSSerialNumber(FSSerialNumber obj)
-    {
-        super(obj);
-        serialNumber = new String(obj.serialNumber);
-    }    
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the serial number.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;serialNumber&quot;, serialNumber);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the serial number string.
-        */
-    public String getSerialNumber() { return serialNumber; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the serial number.
+		length += coder.strlen(serialNumber, true);
 
-        @param aString an arbitrary string containing the serial number.
-        */
-    public void setSerialNumber(String aString)
-    {
-        serialNumber = aString;
-    } 
+		return length;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSerialNumber typedObject = (FSSerialNumber)anObject;
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeString(serialNumber);
+		coder.writeWord(0, 1);
+		coder.endObject(name());
+	}
 
-            if (serialNumber != null)
-                result = serialNumber.equals(typedObject.serialNumber);
-            else
-                result = serialNumber == typedObject.serialNumber;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;serialNumber&quot;, serialNumber);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        length += coder.strlen(serialNumber, true);
-
-        return length;
-    }    
-
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-           coder.writeString(serialNumber);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        serialNumber = coder.readString(length-1);
-        coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		serialNumber = coder.readString(length - 1);
+		coder.readWord(1, false);
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSSetBackgroundColor.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSetBackgroundColor.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSetBackgroundColor.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,147 +31,178 @@
 package com.flagstone.transform;
 
 /**
-FSSetBackgroundColor sets the background colour displayed in every frame in the movie.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSSetBackgroundColor sets the background colour displayed in every frame in
+ * the movie.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;color&lt;/td&gt;
+ * &lt;td&gt;An FSColor object that defines the background colour.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Although the colour is specified using an FSColor object the colour displayed
+ * is completely opaque - the alpha channel information in the object is
+ * ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The background colour must be set before the first frame is displayed
+ * otherwise the background colour defaults to white. This is typically the
+ * first object in a coder. If more than one FSSetBackgroundColor object is
+ * added to a movie then only first one sets the background colour. Subsequent
+ * objects are ignored.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSMovie movie = new FSMovie();
+ * 
+ *  movie.setFrameSize(new FSBounds(0, 0, 8000, 8000)); // twips = 400 x 400 pixels
+ *  movie.setFrameRate(1.0f); 1 frame per second.
+ * 
+ *  movie.add(new FSSetBackgroundColor(new FSColor(0xAD, 0xD8, 0xE6))); // light blue
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSetBackgroundColor class represents the SetBackgroundColor tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSSetBackgroundColor extends FSMovieObject
+{
+	private FSColor color = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSSetBackgroundColor object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSetBackgroundColor(FSCoder coder)
+	{
+		super(FSMovieObject.SetBackgroundColor);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSetBackgroundColor_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetBackgroundColor object with a the specified colour.
+	 * 
+	 * @param aColor
+	 *            the colour for the background.
+	 */
+	public FSSetBackgroundColor(FSColor aColor)
+	{
+		super(FSMovieObject.SetBackgroundColor);
+		setColor(aColor);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSetBackgroundColor_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColor object that defines the background colour.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetBackgroundColor object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSSetBackgroundColor object.
+	 */
+	public FSSetBackgroundColor(FSSetBackgroundColor obj)
+	{
+		super(obj);
+		color = new FSColor(obj.color);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the colour for the movie background.
+	 * 
+	 * @return the FSColor object defining the movie's background colour.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-&lt;p&gt;Although the colour is specified using an FSColor object the colour displayed is completely opaque - the alpha channel information in the object is ignored.&lt;/p&gt;
+	/**
+	 * Sets the colour for the movie background.
+	 * 
+	 * @param aColor
+	 *            the colour for the background.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-&lt;p&gt;The background colour must be set before the first frame is displayed otherwise the background colour defaults to white. This is typically the first object in a coder. If more than one FSSetBackgroundColor object is added to a movie then only first one sets the background colour. Subsequent objects are ignored.&lt;/p&gt;
+	public Object clone()
+	{
+		FSSetBackgroundColor anObject = (FSSetBackgroundColor) super.clone();
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-movie.setFrameSize(new FSBounds(0, 0, 8000, 8000)); // twips = 400 x 400 pixels
-movie.setFrameRate(1.0f); 1 frame per second.
+		return anObject;
+	}
 
-movie.add(new FSSetBackgroundColor(new FSColor(0xAD, 0xD8, 0xE6))); // light blue
-&lt;/pre&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (super.equals(anObject))
+		{
+			FSSetBackgroundColor typedObject = (FSSetBackgroundColor) anObject;
 
-&lt;p&gt;The FSSetBackgroundColor class represents the SetBackgroundColor tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSSetBackgroundColor extends FSMovieObject
-{
-    private FSColor color = null;
-    
-    /**
-     * Construct an FSSetBackgroundColor object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSetBackgroundColor(FSCoder coder)
-    {
-        super(FSMovieObject.SetBackgroundColor);
-        decode(coder);
-    }
-    /** Constructs an FSSetBackgroundColor object with a the specified colour.
+			if (color != null)
+				result = color.equals(typedObject.color);
+			else
+				result = color == typedObject.color;
+		}
+		return result;
+	}
 
-        @param aColor the colour for the background.
-        */
-    public FSSetBackgroundColor(FSColor aColor)
-    {
-        super(FSMovieObject.SetBackgroundColor);
-        setColor(aColor);
-    }
-    /**
-     * Constructs an FSSetBackgroundColor object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSSetBackgroundColor object.
-     */
-    public FSSetBackgroundColor(FSSetBackgroundColor obj)
-    {
-        super(obj);
-        color = new FSColor(obj.color);
-    }    
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Gets the colour for the movie background.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;color&quot;, color, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the FSColor object defining the movie's background colour.
-        */
-    public FSColor getColor() { return color; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Sets the colour for the movie background.
+		length += color.length(coder);
 
-        @param aColor the colour for the background.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+		return length;
+	}
 
-    public Object clone()
-    {
-        FSSetBackgroundColor anObject = (FSSetBackgroundColor)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
-        
-        return anObject;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		color.encode(coder);
+		coder.endObject(name());
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSetBackgroundColor typedObject = (FSSetBackgroundColor)anObject;
-            
-            if (color != null)
-                result = color.equals(typedObject.color);
-            else
-                result = color == typedObject.color;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += color.length(coder);
-
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        color.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        color = new FSColor(coder);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		color = new FSColor(coder);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSetTarget.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSetTarget.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSetTarget.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,141 +31,166 @@
 package com.flagstone.transform;
 
 /**
-FSSetTarget is used to control the time-line of a particular movie clip. 
- 
-&lt;p&gt;The action performs a &quot;context switch&quot;. All following actions such as GotoFrame, Play, etc. will be applied to the specified object until another &lt;b&gt;FSSetTarget&lt;/b&gt; action is executed. Setting the target to be the empty string (&quot;&quot;) returns the target to the movie's main timeline.&lt;/p&gt;
+ * FSSetTarget is used to control the time-line of a particular movie clip.
+ * 
+ * &lt;p&gt;
+ * The action performs a &quot;context switch&quot;. All following actions such as
+ * GotoFrame, Play, etc. will be applied to the specified object until another
+ * &lt;b&gt;FSSetTarget&lt;/b&gt; action is executed. Setting the target to be the empty
+ * string (&quot;&quot;) returns the target to the movie's main timeline.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;target&lt;/td&gt;
+ * &lt;td&gt;The name assigned to a movie clip. Names are assigned using the
+ * FSPlaceObject2 class when the movie clip is placed on the Flash Player's
+ * Display List.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ *  // Direct all subsequent actions to this movie clip
+ * 
+ *  actions.add(new FSSetTarget(&quot;/MovieClip:3&quot;));
+ *  ...
+ *  &lt;movie clip actions&gt;
+ *  ...
+ * 
+ *  // Restore the actions to the main movie timeline
+ * 
+ *  actions.add(new FSSetTarget(&quot;&quot;));
+ * &lt;/pre&gt;
+ * 
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSetTarget class represents the SetTarget action of the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSSetTarget extends FSActionObject
+{
+	private String target = &quot;&quot;;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSetTarget object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSetTarget(FSCoder coder)
+	{
+		super(SetTarget);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetTarget action that changes the context to the
+	 * specified target.
+	 * 
+	 * @param aString
+	 *            the name of a movie clip.
+	 */
+	public FSSetTarget(String aString)
+	{
+		super(SetTarget);
+		setTarget(aString);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSetTarget_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSetTarget object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSetTarget object.
+	 */
+	public FSSetTarget(FSSetTarget obj)
+	{
+		super(obj);
+		target = new String(obj.target);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSetTarget_1&quot;&gt;target&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The name assigned to a movie clip. Names are assigned using the FSPlaceObject2 class when the movie clip is placed on the Flash Player's Display List.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the name of the target movie clip.
+	 * 
+	 * @return the name of the target movie clip.
+	 */
+	public String getTarget()
+	{
+		return target;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the name of the target movie clip.
+	 * 
+	 * @param aString
+	 *            the name of a movie clip.
+	 */
+	public void setTarget(String aString)
+	{
+		target = aString;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Example&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-// Direct all subsequent actions to this movie clip
+		if (super.equals(anObject))
+			result = target.equals(((FSSetTarget) anObject).getTarget());
 
-actions.add(new FSSetTarget(&quot;/MovieClip:3&quot;));
-...
-&lt;movie clip actions&gt;
-...
+		return result;
+	}
 
-// Restore the actions to the main movie timeline
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-actions.add(new FSSetTarget(&quot;&quot;));
-&lt;/pre&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;target&quot;, target);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		length += coder.strlen(target, true);
 
-&lt;p&gt;The FSSetTarget class represents the SetTarget action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */ 
-public class FSSetTarget extends FSActionObject
-{
-    private String target = &quot;&quot;;
-    
-    /**
-     * Construct an FSSetTarget object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSetTarget(FSCoder coder)
-    {
-        super(SetTarget);
-        decode(coder);
-    }
-    /** Constructs an FSSetTarget action that changes the context to the specified target.
+		return length;
+	}
 
-        @param aString the name of a movie clip.
-        */
-    public FSSetTarget(String aString)
-    {
-        super(SetTarget);
-        setTarget(aString);
-    }
-    /**
-     * Constructs an FSSetTarget object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSetTarget object.
-     */
-    public FSSetTarget(FSSetTarget obj)
-    {
-        super(obj);
-        target = new String(obj.target);
-    }    
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    /** Gets the name of the target movie clip. 
+		coder.writeString(target);
+		coder.writeWord(0, 1);
+		coder.endObject(name());
+	}
 
-        @return the name of the target movie clip.
-        */
-    public String getTarget() { return target; }
-
-    /** Sets the name of the target movie clip.
-
-        @param aString the name of a movie clip.
-        */
-    public void setTarget(String aString)
-    {
-        target = aString;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = target.equals(((FSSetTarget)anObject).getTarget());
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;target&quot;, target);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += coder.strlen(target, true);
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-         coder.writeString(target);
-        coder.writeWord(0, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        target = coder.readString();
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		target = coder.readString();
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSShape.java
===================================================================
--- trunk/src/com/flagstone/transform/FSShape.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSShape.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,232 +33,254 @@
 import java.util.*;
 
 /**
-FSShape is a container for the shape objects (FSLine, FSCurve and FSShapeStyle objects) 
-that describe how a particular shape is drawn.
+ * FSShape is a container for the shape objects (FSLine, FSCurve and
+ * FSShapeStyle objects) that describe how a particular shape is drawn.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;objects&lt;/td&gt;
+ * &lt;td&gt;An array of shape (FSLine, FSCurve and FSShapeStyle) objects which are
+ * used to draw the outline of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * FSShapes are used in shape and font definitions. The FSShape class is used to
+ * simplify the design of these classes and provides no added functionality
+ * other than acting as a container class.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSShape class represents the Shape record from the Macromedia Flash (SWF)
+ * File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSShape extends FSTransformObject
+{
+	private ArrayList objects = null;
+	private byte[] encodedObjects = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/*
+	 * This method is only used when lazily decoding shapes.
+	 */
+	FSShape(FSCoder coder, int length)
+	{
+		/*
+		 * This test is used to overcome a bug in SWFTool's pdf2swf where empty
+		 * glyphs are only encoded using 1 byte - should be 2.
+		 */
+		if (length &gt; 1)
+			encodedObjects = new byte[length];
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSShape_0&quot;&gt;objects&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of shape (FSLine, FSCurve and FSShapeStyle) objects which are used to draw the outline of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSShape object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSShape(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;/table&gt;
-&lt;/p&gt;
+	/** Constructs an FSShape object with no shape objects. */
+	public FSShape()
+	{
+		objects = new ArrayList();
+	}
 
-&lt;p&gt;FSShapes are used in shape and font definitions. The FSShape class is used to simplify the design of these classes and provides no added functionality other than acting as a container class.&lt;/p&gt;
+	/**
+	 * Constructs an FSShape object, specifying the Objects that describe how
+	 * the shape is drawn.
+	 * 
+	 * @param anArray
+	 *            the array of shape records.
+	 */
+	public FSShape(ArrayList anArray)
+	{
+		setObjects(anArray);
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Constructs an FSShape object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSShape object.
+	 */
+	public FSShape(FSShape obj)
+	{
+		if (objects != null)
+		{
+			objects = new ArrayList();
 
-&lt;p&gt;The FSShape class represents the Shape record from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSShape extends FSTransformObject
-{
-    private ArrayList objects = null;
-    private byte[] encodedObjects = null; 
+			for (Iterator i = obj.objects.iterator(); i.hasNext();)
+				objects.add(((FSTransformObject) i.next()).clone());
+		} else
+		{
+			encodedObjects = Transform.clone(obj.encodedObjects);
+		}
+	}
 
-    /*
-     * This method is only used when lazily decoding shapes.
-     */
-    FSShape(FSCoder coder, int length)
-    {
-        /*
-         * This test is used to overcome a bug in SWFTool's pdf2swf where empty 
-         * glyphs are only encoded using 1 byte - should be 2.
-         */
-        if (length &gt; 1)
-            encodedObjects = new byte[length];
-        
-        decode(coder);
-    }
+	/**
+	 * Adds the object to the array of shape records.
+	 * 
+	 * @param anObject
+	 *            an instance of FSShapeStyle, FSLine or FSCurve.
+	 */
+	public void add(FSTransformObject anObject)
+	{
+		if (encodedObjects != null)
+		{
+			objects = FSMovie.decodeShape(encodedObjects);
+			encodedObjects = null;
+		}
+		objects.add(anObject);
+	}
 
-    /**
-     * Construct an FSShape object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSShape(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSShape object with no shape objects. */
-    public FSShape()
-    {
-        objects = new ArrayList();
-    }
-    /** Constructs an FSShape object, specifying the Objects that describe how the shape is drawn.
+	/**
+	 * Gets the array of shape records that define the shape.
+	 * 
+	 * @return the array of shape records.
+	 */
+	public ArrayList getObjects()
+	{
+		if (encodedObjects != null)
+		{
+			objects = FSMovie.decodeShape(encodedObjects);
+			encodedObjects = null;
+		}
+		return objects;
+	}
 
-        @param anArray the array of shape records.
-        */
-    public FSShape(ArrayList anArray)
-    {
-        setObjects(anArray);
-    }
-    /**
-     * Constructs an FSShape object by copying values from an existing object.
-     *
-     * @param obj an FSShape object.
-     */
-    public FSShape(FSShape obj)
-    {
-        if (objects != null)
-        {
-            objects = new ArrayList();
-        
-            for (Iterator i = obj.objects.iterator(); i.hasNext();)
-                objects.add(((FSTransformObject)i.next()).clone());
-        }
-        else
-        {
-            encodedObjects = Transform.clone(obj.encodedObjects);
-        }
-    }
+	/**
+	 * Sets the array of shape records.
+	 * 
+	 * @param anArray
+	 *            the array of shape records.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-    /** Adds the object to the array of shape records.
+	public Object clone()
+	{
+		FSShape anObject = (FSShape) super.clone();
 
-        @param anObject an instance of FSShapeStyle, FSLine or FSCurve.
-        */
-    public void add(FSTransformObject anObject)
-    {
-        if (encodedObjects != null)
-        {
-            objects = FSMovie.decodeShape(encodedObjects);
-            encodedObjects = null;
-        }            
-        objects.add(anObject);
-     }
+		if (objects != null)
+		{
+			anObject.objects = new ArrayList();
 
-    /** Gets the array of shape records that define the shape.
+			for (Iterator i = objects.iterator(); i.hasNext();)
+				anObject.objects.add(((FSTransformObject) i.next()).clone());
+		} else
+		{
+			anObject.encodedObjects = Transform.clone(encodedObjects);
+		}
 
-        @return the array of shape records.
-        */
-    public ArrayList getObjects() 
-    {
-        if (encodedObjects != null)
-        {
-            objects = FSMovie.decodeShape(encodedObjects);
-            encodedObjects = null;
-        }
-        return objects;
-    }
+		return anObject;
+	}
 
-    /** Sets the array of shape records.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anArray the array of shape records.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+		if (super.equals(anObject))
+		{
+			FSShape typedObject = (FSShape) anObject;
 
-    public Object clone()
-    {
-        FSShape anObject = (FSShape)super.clone();
-        
-        if (objects != null)
-        {
-            anObject.objects = new ArrayList();
-        
-            for (Iterator i = objects.iterator(); i.hasNext();)
-                anObject.objects.add(((FSTransformObject)i.next()).clone());
-        }
-        else
-        {
-            anObject.encodedObjects = Transform.clone(encodedObjects);
-        }
+			if (objects != null)
+				result = objects.equals(typedObject.objects);
+			else
+				result = objects == typedObject.objects;
+		}
+		return result;
+	}
 
-        return anObject;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSShape typedObject = (FSShape)anObject;
-            
-            if (objects != null)
-                result = objects.equals(typedObject.objects);
-            else
-                result = objects == typedObject.objects;
-        }
-        return result;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;objects&quot;, objects, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+	public int length(FSCoder coder)
+	{
+		int numberOfBits = 0;
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;objects&quot;, objects, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		coder.context[FSCoder.NumberOfShapeBits] = numberOfBits;
 
-    public int length(FSCoder coder)
-    {
-        int numberOfBits = 0;
-        
-        coder.context[FSCoder.NumberOfShapeBits] = numberOfBits;
-        
-        if (objects != null)
-        {
-            numberOfBits += 8;
-            
-            for (Iterator shapeIterator = objects.iterator(); shapeIterator.hasNext();) 
-                numberOfBits += ((FSTransformObject)shapeIterator.next()).length(coder);
-                
-            numberOfBits += 6; // Add size of end of shape
-        
-            numberOfBits += (numberOfBits % 8 &gt; 0) ? 8-(numberOfBits % 8) : 0;
-        }
-        else
-        {
-            numberOfBits += encodedObjects.length &lt;&lt; 3;
-        }
-        return numberOfBits&gt;&gt;3;
-    }
+		if (objects != null)
+		{
+			numberOfBits += 8;
 
-    public void encode(FSCoder coder)
-    {
-        if (objects != null)
-        {      
-            coder.writeBits(coder.context[FSCoder.NumberOfFillBits], 4);
-            coder.writeBits(coder.context[FSCoder.NumberOfLineBits], 4);
+			for (Iterator shapeIterator = objects.iterator(); shapeIterator
+							.hasNext();)
+				numberOfBits += ((FSTransformObject) shapeIterator.next())
+								.length(coder);
 
-            for (Iterator shapeIterator = objects.iterator(); shapeIterator.hasNext();) 
-                ((FSTransformObject)shapeIterator.next()).encode(coder);
-        
-            coder.writeBits(0, 6); // End of shape
-            coder.alignToByte();
-        }
-        else
-        {
-            coder.writeBytes(encodedObjects);
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        if (encodedObjects != null)
-        {
-            coder.readBytes(encodedObjects);            
-        }
-        else
-        {
-            objects = FSMovie.decodeShape(coder);
-        }
-    }
+			numberOfBits += 6; // Add size of end of shape
+
+			numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
+		} else
+		{
+			numberOfBits += encodedObjects.length &lt;&lt; 3;
+		}
+		return numberOfBits &gt;&gt; 3;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		if (objects != null)
+		{
+			coder.writeBits(coder.context[FSCoder.NumberOfFillBits], 4);
+			coder.writeBits(coder.context[FSCoder.NumberOfLineBits], 4);
+
+			for (Iterator shapeIterator = objects.iterator(); shapeIterator
+							.hasNext();)
+				((FSTransformObject) shapeIterator.next()).encode(coder);
+
+			coder.writeBits(0, 6); // End of shape
+			coder.alignToByte();
+		} else
+		{
+			coder.writeBytes(encodedObjects);
+		}
+	}
+
+	public void decode(FSCoder coder)
+	{
+		if (encodedObjects != null)
+		{
+			coder.readBytes(encodedObjects);
+		} else
+		{
+			objects = FSMovie.decodeShape(coder);
+		}
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSShapeStyle.java
===================================================================
--- trunk/src/com/flagstone/transform/FSShapeStyle.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSShapeStyle.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,798 +33,1022 @@
 import java.util.*;
 
 /**
-FSShapeStyle is used to change the drawing environment when a shape is drawn. 
- 
-&lt;p&gt;Three operations can be performed:&lt;/p&gt;
+ * FSShapeStyle is used to change the drawing environment when a shape is drawn.
+ * Three operations can be performed:
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;Select a line style or fill style.&lt;/li&gt;
+ * &lt;li&gt;Move the current drawing point.&lt;/li&gt;
+ * &lt;li&gt;Define a new set of line and fill styles.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * An FSShapeStyle object can specify one or more of the operations rather than
+ * specifying them in separate FSShapeStyle objects - compacting the size of the
+ * binary data when the object is encoded. Conversely if an operation is not
+ * defined then the values may be omitted.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyle&lt;/td&gt;
+ * &lt;td&gt;The index of the line style in the parent shape's line style array.
+ * Optional. May be set to the framework constant Transform.VALUE_NOT_SET if no
+ * style is selected.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyle&lt;/td&gt;
+ * &lt;td&gt;The index of the fill style in the parent shape's fill style array.
+ * Optional. May be set to the framework constant Transform.VALUE_NOT_SET if no
+ * style is selected.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;altFillStyle&lt;/td&gt;
+ * &lt;td&gt;The index of the alternate fill style in the parent shape's fill style
+ * array. Optional. May be set to the framework constant Transform.VALUE_NOT_SET
+ * if no style is selected.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;moveX&lt;/td&gt;
+ * &lt;td&gt;The absolute x-coordinate of the new drawing point. Optional. May be set
+ * to the framework constant Transform.VALUE_NOT_SET if the drawing point is not
+ * being moved.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;moveY&lt;/td&gt;
+ * &lt;td&gt;The absolute y-coordinate of the new drawing point. Optional. May be set
+ * to the framework constant Transform.VALUE_NOT_SET if the drawing point is not
+ * being moved.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;lineStyles&lt;/td&gt;
+ * &lt;td&gt;An array of new line styles for the parent shape. Optional. May be set
+ * to null or an empty array if no line or fill styles are being added.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;fillStyles&lt;/td&gt;
+ * &lt;td&gt;An array of new fill styles for the parent shape. Optional. May be set
+ * to null or an empty array if no line or fill styles are being added.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Line and Fill styles are selected by the index position, starting at 1, of
+ * the style in an array of styles. An index of zero means that no style is
+ * selected. Using the constant Transform.VALUE_NOT_SET means that the current
+ * style is unchanged. Two types of fill style are supported: fillStyle is used
+ * where a shape does not contain overlapping areas and altFillStyle is used
+ * where areas overlap. This differs from graphics environments that only
+ * support one fill style as the overlapping area would form a hole in the shape
+ * and not be filled.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * In the following example, when a shape is drawn the fillStyle defines the
+ * style to the left of the line drawing the outline while the altFillStyle
+ * defines the style applied to the right of the outline.
+ * &lt;/p&gt;
+ * 
+ * &lt;img src=&quot;doc-files/fillStyles.gif&quot;&gt;
+ * &lt;p&gt;
+ * New fill and line styles can be added to the FSShapeStyle object to change
+ * the way shapes are drawn.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * A new drawing point is specified using the absolute x and y coordinates. If
+ * an FSShapeStyle object is the first in a shape then the current drawing point
+ * is the origin of the shape (0,0).
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Optional Attributes&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * Since the FSShapeStyle object can encode three different types of operation,
+ * the unused attributes are optional. Setting line or fill styles to the
+ * framework constant Transform.VALUE_NOT_SET omits the attribute when the
+ * object is encoded - reduced the size.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * For the line and fill styles setting the respective attribute to
+ * Transform.VALUE_NOT_SET is different from setting to zero. When the attribute
+ * is set to Transform.VALUE_NOT_SET attribute is not encoded. When the
+ * attribute is set to zero then that instructs the Flash Player that no current
+ * line or fill style is selected. The latter is important when filling areas of
+ * a shape that overlap - the altFillStyle attribute will be set to the desired
+ * style while the lineStyle and fillStyle attributes are set to zero.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Similarly moveX and moveY may be set to Transform.VALUE_NOT_SET to indicate
+ * that the current drawing point will not be changed. This can also be achieved
+ * by setting moveX and moveY to zero. However using Transform.VALUE_NOT_SET
+ * means that the attributes are not encoded reducing the binary representation.
+ * For large files the savings can be significant.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The line or fill style arrays May be empty if no new styles are being
+ * specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Note that the values for the moveX and moveY attributes and the line and fill
+ * styles arrays are defined in pairs and are optional only if both are set to
+ * zero or NULL respectively.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The class provides a range of constructors which define different subsets of
+ * the attributes according to the type of operation that will be performed. If
+ * an attribute is not specified in a constructor then it will be assigned the
+ * default value of Transform.VALUE_NOT_SET and will be omitted when the object
+ * is encoded.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Select line and fill styles.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSDefineShape shape = new FSShape(movie.newIdentifier(), ...);
+ * 
+ *  // Add fill styles to the shape definition
+ *  shape.add(new FSSolidFill(FSColor(0, 0, 255)));
+ *  shape.add(new FSBitmapFill(FSFillStyle.Tiled, imageId, transform));
+ * 
+ *  // Add a line styles to the shape definition
+ * 
+ *  shape.add(new FSSolidLine(20, FSColor(0, 0, 0)));
+ * 
+ *  // Select the solid line style and the bitmap fill style. Note that the
+ *  // ordinal position of the styles is used. A style index of 0 means that
+ *  // style is not set.
+ * 
+ *  shape.add(new FSShapeStyle(1, 2, 0));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Move the current drawing point.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The drawing point is changed by specifying the position from the current
+ * drawing point:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSShapeStyle style = new FSShapeStyle(x, y);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 3. Specifying New Styles.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Adding a new set of styles to an FSShapeStyle object will replace the
+ * existing set of styles defined for the shape.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds,
+ * 				fillStyles, lineStyles, shape);
+ * 
+ * // Replace the existing set of fill and line styles in the shape definition
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(FSColor(255, 0, 0)));
+ * fillStyles.add(new FSSolidFill(FSColor(0, 255, 0)));
+ * fillStyles.add(new FSSolidFill(FSColor(0, 0, 255)));
+ * 
+ * lineStyles.add(new FSSolidLine(1, FSColor(0, 0, 0)));
+ * 
+ * shape.add(new FSShapeStyle(lineStyles, fillStyles));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 4. Creating an overlapping shape.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // Create the bounding rectangle for the shape. Two rectangles 100 x 100 pixels 
+ * // are drawn. The area overlap area is 50 x 50 pixels.
+ * 
+ * FSBounds bounds = new FSBounds(0, -50, 150, 100);
+ * 
+ * // Define the styles for the shape.
+ * 
+ * ArrayList fillStyles = new ArrayList();
+ * ArrayList lineStyles = new ArrayList();
+ * 
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
+ * fillStyles.add(new FSSolidFill(new FSColor(255, 255, 0)));
+ * fillStyles.add(new FSSolidFill(new FSColor(16, 123, 255)));
+ * 
+ * lineStyles.add(new FSSolidLine(20, new FSColor(0, 0, 0)));
+ * 
+ * FSDefineShape shape = new FSDefineShape(movie.newIdentifier, bounds,
+ * 				fillStyles, lineStyles, new FSShape());
+ * &lt;/pre&gt;
+ * 
+ * &lt;pre&gt;
+ * // To create the overlapping shape shown above the following styles 
+ * // selections are made while the shape is drawn.
+ * 
+ * shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
+ * shape.add(new FSLine(50, 0));
+ * shape.add(new FSShapeStyle(1, 1, 3));
+ * shape.add(new FSLine(0, 50));
+ * shape.add(new FSLine(50, 0));
+ * shape.add(new FSShapeStyle(1, 0, 2));
+ * shape.add(new FSLine(50, 0));
+ * shape.add(new FSLine(0, -100));
+ * shape.add(new FSLine(-100, 0));
+ * shape.add(new FSLine(0, 50));
+ * shape.add(new FSShapeStyle(1, 3, 2));
+ * shape.add(new FSLine(50, 0));
+ * shape.add(new FSLine(0, 50));
+ * shape.add(new FSShapeStyle(1, 1, 0));
+ * shape.add(new FSLine(0, 50));
+ * shape.add(new FSLine(-100, 0));
+ * shape.add(new FSLine(0, -100));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSShapeStyle class represents the StyleChange record from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSShapeStyle extends FSTransformObject
+{
+	private int moveX = Transform.VALUE_NOT_SET;
+	private int moveY = Transform.VALUE_NOT_SET;
+	private int fillStyle = Transform.VALUE_NOT_SET;
+	private int altFillStyle = Transform.VALUE_NOT_SET;
+	private int lineStyle = Transform.VALUE_NOT_SET;
+	private ArrayList fillStyles = null;
+	private ArrayList lineStyles = null;
 
-&lt;ul&gt;
-&lt;li&gt;Select a line style or fill style.&lt;/li&gt;
-&lt;li&gt;Move the current drawing point.&lt;/li&gt;
-&lt;li&gt;Define a new set of line and fill styles.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Construct an FSShapeStyle object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSShapeStyle(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;p&gt;An FSShapeStyle object can specify one or more of the operations rather than specifying them in separate FSShapeStyle objects - compacting the size of the binary data when the object is encoded. Conversely if an operation is not defined then the values may be omitted.&lt;/p&gt;
+	/**
+	 * Constructs an FSShapeStyle object, selecting the line and fill styles.
+	 * 
+	 * @param lineStyleIndex
+	 *            selects the line style at lineStyleIndex in the line styles
+	 *            array of the parent FSShape object.
+	 * @param fillStyleIndex
+	 *            selects the fill style at fillStyleIndex in the fill styles
+	 *            array of the parent FSShape object.
+	 * @param altFillStyleIndex
+	 *            selects the alternate fill style at altFillStyleIndex in the
+	 *            fill styles array of the parent FSShape object.
+	 */
+	public FSShapeStyle(int lineStyleIndex, int fillStyleIndex,
+						int altFillStyleIndex)
+	{
+		setLineStyle(lineStyleIndex);
+		setFillStyle(fillStyleIndex);
+		setAltFillStyle(altFillStyleIndex);
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Constructs an FSShapeStyle object, selecting the relative drawing point.
+	 * 
+	 * @param relativeX
+	 *            move the current point by relativeX in the x direction.
+	 * @param relativeY
+	 *            move the current point by relativeY in the y direction.
+	 */
+	public FSShapeStyle(int relativeX, int relativeY)
+	{
+		setMoveX(relativeX);
+		setMoveY(relativeY);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSShapeStyle object, specifying the new set of line and
+	 * fill styles for the parent shape.
+	 * 
+	 * @param lineStylesArray
+	 *            an array of FSLineStyle objects.
+	 * @param fillStylesArray
+	 *            an array of fill style objects.
+	 */
+	public FSShapeStyle(ArrayList lineStylesArray, ArrayList fillStylesArray)
+	{
+		setLineStyles(lineStylesArray);
+		setFillStyles(fillStylesArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_0&quot;&gt;lineStyle&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index of the line style in the parent shape's line style array. Optional. May be set to the framework constant Transform.VALUE_NOT_SET if no style is selected.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSShapeStyle object, selecting the line and fill styles and
+	 * drawing point.
+	 * 
+	 * @param lineStyleIndex
+	 *            selects the line style at lineStyleIndex in the line styles
+	 *            array of the parent FSShape object.
+	 * @param fillStyleIndex
+	 *            selects the fill style at fillStyleIndex in the fill styles
+	 *            array of the parent FSShape object.
+	 * @param altFillStyleIndex
+	 *            selects the alternate fill style at altFillStyleIndex in the
+	 *            fill styles array of the parent FSShape object.
+	 * @param relativeX
+	 *            move the current point by relativeX in the x direction.
+	 * @param relativeY
+	 *            move the current point by relativeY in the y direction.
+	 */
+	public FSShapeStyle(int lineStyleIndex, int fillStyleIndex,
+						int altFillStyleIndex, int relativeX, int relativeY)
+	{
+		setLineStyle(lineStyleIndex);
+		setFillStyle(fillStyleIndex);
+		setAltFillStyle(altFillStyleIndex);
+		setMoveX(relativeX);
+		setMoveY(relativeY);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_1&quot;&gt;fillStyle&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index of the fill style in the parent shape's fill style array. Optional. May be set to the framework constant Transform.VALUE_NOT_SET if no style is selected.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSShapeStyle object, selecting the line and fill styles,
+	 * new line and new fill styles.
+	 * 
+	 * @param lineStyleIndex
+	 *            selects the line style at lineStyleIndex in the line styles
+	 *            array of the parent FSShape object.
+	 * @param fillStyleIndex
+	 *            selects the fill style at fillStyleIndex in the fill styles
+	 *            array of the parent FSShape object.
+	 * @param altFillStyleIndex
+	 *            selects the alternate fill style at altFillStyleIndex in the
+	 *            fill styles array of the parent FSShape object.
+	 * @param lineStylesArray
+	 *            an array of FSLineStyle objects.
+	 * @param fillStylesArray
+	 *            an array of fill style objects.
+	 */
+	public FSShapeStyle(int lineStyleIndex, int fillStyleIndex,
+						int altFillStyleIndex, ArrayList lineStylesArray,
+						ArrayList fillStylesArray)
+	{
+		setLineStyle(lineStyleIndex);
+		setFillStyle(fillStyleIndex);
+		setAltFillStyle(altFillStyleIndex);
+		setLineStyles(lineStylesArray);
+		setFillStyles(fillStylesArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_2&quot;&gt;altFillStyle&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index of the alternate fill style in the parent shape's fill style array. Optional. May be set to the framework constant Transform.VALUE_NOT_SET if no style is selected.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSShapeStyle object, selecting the line and fill styles,
+	 * drawing point, new line and new fill styles.
+	 * 
+	 * @param lineStyleIndex
+	 *            selects the line style at lineStyleIndex in the line styles
+	 *            array of the parent FSShape object.
+	 * @param fillStyleIndex
+	 *            selects the fill style at fillStyleIndex in the fill styles
+	 *            array of the parent FSShape object.
+	 * @param altFillStyleIndex
+	 *            selects the alternate fill style at altFillStyleIndex in the
+	 *            fill styles array of the parent FSShape object.
+	 * @param relativeX
+	 *            move the current point by relativeX in the x direction.
+	 * @param relativeY
+	 *            move the current point by relativeY in the y direction.
+	 * @param lineStylesArray
+	 *            an array of FSLineStyle objects.
+	 * @param fillStylesArray
+	 *            an array of fill style objects.
+	 */
+	public FSShapeStyle(int lineStyleIndex, int fillStyleIndex,
+						int altFillStyleIndex, int relativeX, int relativeY,
+						ArrayList lineStylesArray, ArrayList fillStylesArray)
+	{
+		setLineStyle(lineStyleIndex);
+		setFillStyle(fillStyleIndex);
+		setAltFillStyle(altFillStyleIndex);
+		setMoveX(relativeX);
+		setMoveY(relativeY);
+		setLineStyles(lineStylesArray);
+		setFillStyles(fillStylesArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_3&quot;&gt;moveX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The absolute x-coordinate of the new drawing point. Optional. May be set to the framework constant Transform.VALUE_NOT_SET if the drawing point is not being moved.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSShapeStyle object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSShapeStyle object.
+	 */
+	public FSShapeStyle(FSShapeStyle obj)
+	{
+		moveX = obj.moveX;
+		moveY = obj.moveY;
+		fillStyle = obj.fillStyle;
+		altFillStyle = obj.altFillStyle;
+		lineStyle = obj.lineStyle;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_4&quot;&gt;moveY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The absolute y-coordinate of the new drawing point. Optional. May be set to the framework constant Transform.VALUE_NOT_SET if the drawing point is not being moved.&lt;/td&gt;
-&lt;/tr&gt;
+		if (obj.fillStyles != null)
+		{
+			fillStyles = new ArrayList();
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_5&quot;&gt;lineStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of new line styles for the parent shape. Optional. May be set to null or an empty array if no line or fill styles are being added.&lt;/td&gt;
-&lt;/tr&gt;
+			for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
+				fillStyles.add(((FSFillStyle) i.next()).clone());
+		}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSShapeStyle_6&quot;&gt;fillStyles&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of new fill styles for the parent shape. Optional. May be set to null or an empty array if no line or fill styles are being added.&lt;/td&gt;
-&lt;/tr&gt;
+		if (obj.lineStyles != null)
+		{
+			lineStyles = new ArrayList();
 
-&lt;/table&gt;
+			for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
+				lineStyles.add(((FSLineStyle) i.next()).clone());
+		}
+	}
 
-&lt;p&gt;Line and Fill styles are selected by the index position, starting at 1, of the style in an array of styles. An index of zero means that no style is selected. Using the constant Transform.VALUE_NOT_SET means that the current style is unchanged. Two types of fill style are supported: fillStyle is used where a shape does not contain overlapping areas and altFillStyle is used where areas overlap. This differs from graphics environments that only support one fill style as the overlapping area would form a hole in the shape and not be filled.&lt;/p&gt;
+	/**
+	 * Add a FSSolidLine object to the array of line styles.
+	 * 
+	 * @param aLineStyle
+	 *            and FSSolidLine object.
+	 */
+	public void add(FSLineStyle aLineStyle)
+	{
+		lineStyles.add(aLineStyle);
+	}
 
-&lt;p&gt;In the following example, when a shape is drawn the fillStyle defines the style to the left of the line drawing the outline while the altFillStyle defines the style applied to the right of the outline.&lt;/p&gt;
+	/**
+	 * Add the fill style object to the array of fill styles.
+	 * 
+	 * @param aFillStyle
+	 *            and FSFillStyle object.
+	 */
+	public void add(FSFillStyle aFillStyle)
+	{
+		fillStyles.add(aFillStyle);
+	}
 
-&lt;img src=&quot;doc-files/fillStyles.gif&quot;&gt;
+	/**
+	 * Gets the x-coordinate of any relative move specified.
+	 * 
+	 * @return the x-coordinate of the relative move.
+	 */
+	public int getMoveX()
+	{
+		return moveX;
+	}
 
-&lt;p&gt;New fill and line styles can be added to the FSShapeStyle object to change the way shapes are drawn.&lt;/p&gt;
+	/**
+	 * Gets the y-coordinate of any relative move specified. If the attribute is
+	 * set to Transform.VALUE_NOT_SET then the value is not affected.
+	 * 
+	 * @return the y-coordinate of the relative move.
+	 */
+	public int getMoveY()
+	{
+		return moveY;
+	}
 
-&lt;p&gt;A new drawing point is specified using the absolute x and y coordinates. If an FSShapeStyle object is the first in a shape then the current drawing point is the origin of the shape (0,0).&lt;/p&gt;
+	/**
+	 * Gets the index of the line style that will be applied to any line drawn.
+	 * Returns the value Transform.VALUE_NOT_SET if no line style is defined.
+	 * 
+	 * @return the index of the selected line style.
+	 */
+	public int getLineStyle()
+	{
+		return lineStyle;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Optional Attributes&lt;/h1&gt;
+	/**
+	 * Gets the index of the fill style that will be applied to any area filled.
+	 * Returns the value Transform.VALUE_NOT_SET if no fill style is defined.
+	 * 
+	 * @return the index of the selected fill style.
+	 */
+	public int getFillStyle()
+	{
+		return fillStyle;
+	}
 
-&lt;p&gt;Since the FSShapeStyle object can encode three different types of operation, the unused attributes are optional. Setting line or fill styles to the framework constant Transform.VALUE_NOT_SET omits the attribute when the object is encoded - reduced the size.&lt;/p&gt;
+	/**
+	 * Gets the index of the fill style that will be applied to any overlapping
+	 * area filled. Returns the value Transform.VALUE_NOT_SET if no alternate
+	 * fill style is defined.
+	 * 
+	 * @return the index of the selected alternate style.
+	 */
+	public int getAltFillStyle()
+	{
+		return altFillStyle;
+	}
 
-&lt;p&gt;For the line and fill styles setting the respective attribute to Transform.VALUE_NOT_SET is different from setting to zero. When the attribute is set to Transform.VALUE_NOT_SET attribute is not encoded. When the attribute is set to zero then that instructs the Flash Player that no current line or fill style is selected. The latter is important when filling areas of a shape that overlap - the altFillStyle attribute will be set to the desired style while the lineStyle and fillStyle attributes are set to zero.&lt;/p&gt;
+	/**
+	 * Gets the array of new line styles.
+	 * 
+	 * @return the array of FSLineStyle objects.
+	 */
+	public ArrayList getLineStyles()
+	{
+		return lineStyles;
+	}
 
-&lt;p&gt;Similarly moveX and moveY may be set to Transform.VALUE_NOT_SET to indicate that the current drawing point will not be changed.  This can also be achieved by setting moveX and moveY to zero. However using Transform.VALUE_NOT_SET means that the attributes are not encoded reducing the binary representation. For large files the savings can be significant.&lt;/p&gt;
+	/**
+	 * Gets the array of new fill styles.
+	 * 
+	 * @return the array of fill style objects.
+	 */
+	public ArrayList getFillStyles()
+	{
+		return fillStyles;
+	}
 
-&lt;p&gt;The line or fill style arrays May be empty if no new styles are being specified.&lt;/p&gt;
+	/**
+	 * Sets the x-coordinate of any relative move. May be set to
+	 * Transform.VALUE_NOT_SET if the attribute should not be encoded.
+	 * 
+	 * @param aNumber
+	 *            move the current point by aNumber in the x direction.
+	 */
+	public void setMoveX(int aNumber)
+	{
+		moveX = aNumber;
+	}
 
-&lt;p&gt;Note that the values for the moveX and moveY attributes and the line and fill styles arrays are defined in pairs and are optional only if both are set to zero or NULL respectively.&lt;/p&gt;
+	/**
+	 * Sets the y-coordinate of any relative move. May be set to
+	 * Transform.VALUE_NOT_SET if the attribute should not be encoded.
+	 * 
+	 * @param aNumber
+	 *            move the current point by aNumber in the y direction.
+	 */
+	public void setMoveY(int aNumber)
+	{
+		moveY = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the drawing point.
+	 * 
+	 * @param x
+	 *            the x-coordinate of the drawing point.
+	 * @param y
+	 *            the y-coordinate of the drawing point.
+	 */
+	public void setMove(int x, int y)
+	{
+		moveX = x;
+		moveY = y;
+	}
 
-&lt;p&gt;The class provides a range of constructors which define different subsets of the attributes according to the type of operation that will be performed. If an attribute is not specified in a constructor then it will be assigned the default value of Transform.VALUE_NOT_SET and will be omitted when the object is encoded.&lt;/p&gt;
+	/**
+	 * Sets the index of the fill style that will be applied to any area filled.
+	 * May be set to zero if no style is selected or Transform.VALUE_NOT_SET if
+	 * the attribute should not be encoded.
+	 * 
+	 * @param anIndex
+	 *            selects the fill style at anIndex in the fill styles array of
+	 *            the parent FSShape object.
+	 */
+	public void setFillStyle(int anIndex)
+	{
+		fillStyle = anIndex;
+	}
 
-&lt;p&gt;1. Select line and fill styles.&lt;/p&gt;
+	/**
+	 * Sets the index of the fill style that will be applied to any overlapping
+	 * area filled. May be set to zero if no style is selected or
+	 * Transform.VALUE_NOT_SET if the attribute should not be encoded.
+	 * 
+	 * @param anIndex
+	 *            selects the alternate fill style at anIndex in the fill styles
+	 *            array of the parent FSShape object.
+	 */
+	public void setAltFillStyle(int anIndex)
+	{
+		altFillStyle = anIndex;
+	}
 
-&lt;pre&gt;
-FSDefineShape shape = new FSShape(movie.newIdentifier(), ...);
+	/**
+	 * Sets the index of the line style that will be applied to any line drawn.
+	 * May be set to zero if no style is selected or Transform.VALUE_NOT_SET if
+	 * the attribute should not be encoded.
+	 * 
+	 * @param anIndex
+	 *            selects the line style at anIndex in the line styles array of
+	 *            the parent FSShape object.
+	 */
+	public void setLineStyle(int anIndex)
+	{
+		lineStyle = anIndex;
+	}
 
-// Add fill styles to the shape definition
+	/**
+	 * Sets the array of new line styles. May be set to null if no styles are
+	 * being defined.
+	 * 
+	 * @param anArray
+	 *            an array of FSLineStyle objects.
+	 */
+	public void setLineStyles(ArrayList anArray)
+	{
+		lineStyles = anArray;
+	}
 
-shape.add(new FSSolidFill(FSColor(0, 0, 255)));
-shape.add(new FSBitmapFill(FSFillStyle.Tiled, imageId, transform));
+	/**
+	 * Sets the array of new fill styles. May be set to null if no styles are
+	 * being defined.
+	 * 
+	 * @param anArray
+	 *            an array of fill style objects.
+	 */
+	public void setFillStyles(ArrayList anArray)
+	{
+		fillStyles = anArray;
+	}
 
-// Add a line styles to the shape definition
+	public Object clone()
+	{
+		FSShapeStyle anObject = (FSShapeStyle) super.clone();
 
-shape.add(new FSSolidLine(20, FSColor(0, 0, 0)));
+		if (fillStyles != null)
+		{
+			anObject.fillStyles = new ArrayList();
 
-// Select the solid line style and the bitmap fill style. Note that the
-// ordinal position of the styles is used. A style index of 0 means that
-// style is not set.
+			for (Iterator i = fillStyles.iterator(); i.hasNext();)
+				anObject.fillStyles.add(((FSFillStyle) i.next()).clone());
+		}
 
-shape.add(new FSShapeStyle(1, 2, 0));
-&lt;/pre&gt;
+		if (lineStyles != null)
+		{
+			anObject.lineStyles = new ArrayList();
 
-&lt;p&gt;2. Move the current drawing point.&lt;/p&gt;
+			for (Iterator i = lineStyles.iterator(); i.hasNext();)
+				anObject.lineStyles.add(((FSLineStyle) i.next()).clone());
+		}
 
-&lt;p&gt;The drawing point is changed by specifying the position from the current drawing point:&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;pre&gt;
-FSShapeStyle style = new FSShapeStyle(x, y);
-&lt;/pre&gt;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;3. Specifying New Styles.&lt;/p&gt;
+		if (super.equals(anObject))
+		{
+			FSShapeStyle typedObject = (FSShapeStyle) anObject;
 
-&lt;p&gt;Adding a new set of styles to an FSShapeStyle object will replace the existing set of styles defined for the shape.&lt;/p&gt;
+			result = moveX == typedObject.moveX;
+			result = result &amp;&amp; moveY == typedObject.moveY;
+			result = result &amp;&amp; fillStyle == typedObject.fillStyle;
+			result = result &amp;&amp; altFillStyle == typedObject.altFillStyle;
+			result = result &amp;&amp; lineStyle == typedObject.lineStyle;
 
-&lt;pre&gt;
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier(), bounds, fillStyles, lineStyles, shape);
+			if (fillStyles != null)
+				result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
+			else
+				result = result &amp;&amp; fillStyles == typedObject.fillStyles;
 
-// Replace the existing set of fill and line styles in the shape definition
+			if (lineStyles != null)
+				result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
+			else
+				result = result &amp;&amp; lineStyles == typedObject.lineStyles;
+		}
+		return result;
+	}
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-fillStyles.add(new FSSolidFill(FSColor(255, 0, 0)));
-fillStyles.add(new FSSolidFill(FSColor(0, 255, 0)));
-fillStyles.add(new FSSolidFill(FSColor(0, 0, 255)));
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;moveX&quot;, moveX);
+			Transform.append(buffer, &quot;moveY&quot;, moveY);
+			Transform.append(buffer, &quot;fillStyle&quot;, fillStyle);
+			Transform.append(buffer, &quot;altFillStyle&quot;, altFillStyle);
+			Transform.append(buffer, &quot;lineStyle&quot;, lineStyle);
+			Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
+			Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-lineStyles.add(new FSSolidLine(1, FSColor(0, 0, 0)));
+	public int length(FSCoder coder)
+	{
+		boolean _containsStyles = containsStyles();
+		boolean _containsLineStyle = containsLineStyle();
+		boolean _containsAltFillStyle = containsAltFillStyle();
+		boolean _containsFillStyle = containsFillStyle();
+		boolean _containsMove = containsMove();
 
-shape.add(new FSShapeStyle(lineStyles, fillStyles));
-&lt;/pre&gt;
+		int numberOfBits = 0;
 
-&lt;p&gt;4. Creating an overlapping shape.&lt;/p&gt;
+		numberOfBits += 6;
 
-&lt;pre&gt;
-// Create the bounding rectangle for the shape. Two rectangles 100 x 100 pixels 
-// are drawn. The area overlap area is 50 x 50 pixels.
+		if (_containsMove)
+		{
+			int _moveFieldSize = FSCoder.size(new int[]
+			{
+				moveX, moveY }, true);
 
-FSBounds bounds = new FSBounds(0, -50, 150, 100);
+			numberOfBits += 5 + _moveFieldSize * 2;
+		}
 
-// Define the styles for the shape.
+		numberOfBits += (_containsFillStyle) ? coder.context[FSCoder.NumberOfFillBits]
+						: 0;
+		numberOfBits += (_containsAltFillStyle) ? coder.context[FSCoder.NumberOfFillBits]
+						: 0;
+		numberOfBits += (_containsLineStyle) ? coder.context[FSCoder.NumberOfLineBits]
+						: 0;
 
-ArrayList fillStyles = new ArrayList();
-ArrayList lineStyles = new ArrayList();
+		coder.context[FSCoder.NumberOfShapeBits] += numberOfBits;
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0)));
-fillStyles.add(new FSSolidFill(new FSColor(255, 255, 0)));
-fillStyles.add(new FSSolidFill(new FSColor(16, 123, 255)));
+		if (_containsStyles)
+		{
+			int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+			int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-lineStyles.add(new FSSolidLine(20, new FSColor(0, 0, 0)));
+			boolean countExtended = coder.context[FSCoder.ArrayCountExtended] != 0;
 
-FSDefineShape shape = new FSDefineShape(movie.newIdentifier, bounds, fillStyles, lineStyles, new FSShape());
-&lt;/pre&gt;
+			int numberOfStyleBits = 0;
+			int flushBits = coder.context[FSCoder.NumberOfShapeBits];
 
-&lt;pre&gt;
-// To create the overlapping shape shown above the following styles 
-// selections are made while the shape is drawn.
+			numberOfStyleBits += (flushBits % 8 &gt; 0) ? 8 - (flushBits % 8) : 0;
+			numberOfStyleBits += (countExtended &amp;&amp; fillStyles.size() &gt;= 255) ? 24
+							: 8;
 
-shape.add(new FSShapeStyle(1, 1, 0, 0, 0));
-shape.add(new FSLine(50,0));
-shape.add(new FSShapeStyle(1, 1, 3));
-shape.add(new FSLine(0,50));
-shape.add(new FSLine(50,0));
-shape.add(new FSShapeStyle(1, 0, 2));
-shape.add(new FSLine(50,0));
-shape.add(new FSLine(0,-100));
-shape.add(new FSLine(-100,0));
-shape.add(new FSLine(0,50));
-shape.add(new FSShapeStyle(1, 3, 2));
-shape.add(new FSLine(50,0));
-shape.add(new FSLine(0,50));
-shape.add(new FSShapeStyle(1, 1, 0));
-shape.add(new FSLine(0,50));
-shape.add(new FSLine(-100,0));
-shape.add(new FSLine(0,-100));
-&lt;/pre&gt;
+			for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+							.hasNext();)
+				numberOfStyleBits += ((FSTransformObject) styleIterator.next())
+								.length(coder) * 8;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+			numberOfStyleBits += (countExtended &amp;&amp; lineStyles.size() &gt;= 255) ? 24
+							: 8;
 
-&lt;p&gt;The FSShapeStyle class represents the StyleChange record from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSShapeStyle extends FSTransformObject
-{
-    private int moveX = Transform.VALUE_NOT_SET;
-    private int moveY = Transform.VALUE_NOT_SET;
-    private int fillStyle = Transform.VALUE_NOT_SET;
-    private int altFillStyle = Transform.VALUE_NOT_SET;
-    private int lineStyle = Transform.VALUE_NOT_SET;
-    private ArrayList fillStyles = null;
-    private ArrayList lineStyles = null;
+			for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+							.hasNext();)
+				numberOfStyleBits += ((FSTransformObject) styleIterator.next())
+								.length(coder) * 8;
 
-    /**
-     * Construct an FSShapeStyle object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSShapeStyle(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSShapeStyle object, selecting the line and fill styles.
+			numberOfStyleBits += 8;
 
-        @param lineStyleIndex selects the line style at lineStyleIndex in the line styles array of the parent FSShape object.
-        @param fillStyleIndex selects the fill style at fillStyleIndex in the fill styles array of the parent FSShape object.
-        @param altFillStyleIndex selects the alternate fill style at altFillStyleIndex in the fill styles array of the parent FSShape object.
-        */
-    public FSShapeStyle(int lineStyleIndex, int fillStyleIndex, int altFillStyleIndex)
-    {
-        setLineStyle(lineStyleIndex);
-        setFillStyle(fillStyleIndex);
-        setAltFillStyle(altFillStyleIndex);
-    }
-    /** Constructs an FSShapeStyle object, selecting the relative drawing point.
+			coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+			coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+			coder.context[FSCoder.NumberOfShapeBits] += numberOfStyleBits;
 
-        @param relativeX move the current point by relativeX in the x direction.
-        @param relativeY move the current point by relativeY in the y direction.
-        */
-    public FSShapeStyle(int relativeX, int relativeY)
-    {
-        setMoveX(relativeX);
-        setMoveY(relativeY);
-    }
-    /** Constructs an FSShapeStyle object, specifying the new set of line and fill styles for the parent shape.
+			numberOfBits += numberOfStyleBits;
+		}
+		return numberOfBits;
+	}
 
-        @param lineStylesArray an array of FSLineStyle objects.
-        @param fillStylesArray an array of fill style objects.
-        */
-    public FSShapeStyle(ArrayList lineStylesArray, ArrayList fillStylesArray)
-    {
-        setLineStyles(lineStylesArray);
-        setFillStyles(fillStylesArray);
-    }
+	public void encode(FSCoder coder)
+	{
+		boolean _containsStyles = containsStyles();
+		boolean _containsLineStyle = containsLineStyle();
+		boolean _containsAltFillStyle = containsAltFillStyle();
+		boolean _containsFillStyle = containsFillStyle();
+		boolean _containsMove = containsMove();
 
-    /** Constructs an FSShapeStyle object, selecting the line and fill styles and drawing point.
+		int numberOfFillBits = coder.context[FSCoder.NumberOfFillBits];
+		int numberOfLineBits = coder.context[FSCoder.NumberOfLineBits];
 
-        @param lineStyleIndex selects the line style at lineStyleIndex in the line styles array of the parent FSShape object.
-        @param fillStyleIndex selects the fill style at fillStyleIndex in the fill styles array of the parent FSShape object.
-        @param altFillStyleIndex selects the alternate fill style at altFillStyleIndex in the fill styles array of the parent FSShape object.
-        @param relativeX move the current point by relativeX in the x direction.
-        @param relativeY move the current point by relativeY in the y direction.
-        */
-    public FSShapeStyle(int lineStyleIndex, int fillStyleIndex, int altFillStyleIndex, int relativeX, int relativeY)
-    {
-        setLineStyle(lineStyleIndex);
-        setFillStyle(fillStyleIndex);
-        setAltFillStyle(altFillStyleIndex);
-        setMoveX(relativeX);
-        setMoveY(relativeY);
-    }
+		coder.writeBits(0, 1);
+		coder.writeBits(_containsStyles ? 1 : 0, 1);
+		coder.writeBits(_containsLineStyle ? 1 : 0, 1);
+		coder.writeBits(_containsAltFillStyle ? 1 : 0, 1);
+		coder.writeBits(_containsFillStyle ? 1 : 0, 1);
+		coder.writeBits(_containsMove ? 1 : 0, 1);
 
-    /** Constructs an FSShapeStyle object, selecting the line and fill styles, new line and new fill styles.
+		if (_containsMove)
+		{
+			int _moveFieldSize = FSCoder.size(new int[]
+			{
+				moveX, moveY }, true);
 
-        @param lineStyleIndex selects the line style at lineStyleIndex in the line styles array of the parent FSShape object.
-        @param fillStyleIndex selects the fill style at fillStyleIndex in the fill styles array of the parent FSShape object.
-        @param altFillStyleIndex selects the alternate fill style at altFillStyleIndex in the fill styles array of the parent FSShape object.
-        @param lineStylesArray an array of FSLineStyle objects.
-        @param fillStylesArray an array of fill style objects.
-        */
-    public FSShapeStyle(int lineStyleIndex, int fillStyleIndex, int altFillStyleIndex, ArrayList lineStylesArray, ArrayList fillStylesArray)
-    {
-        setLineStyle(lineStyleIndex);
-        setFillStyle(fillStyleIndex);
-        setAltFillStyle(altFillStyleIndex);
-        setLineStyles(lineStylesArray);
-        setFillStyles(fillStylesArray);
-    }
+			coder.writeBits(_moveFieldSize, 5);
+			coder.writeBits(moveX, _moveFieldSize);
+			coder.writeBits(moveY, _moveFieldSize);
+		}
 
-    /** Constructs an FSShapeStyle object, selecting the line and fill styles, drawing point, new line and new fill styles.
+		if (_containsFillStyle)
+			coder.writeBits(fillStyle, numberOfFillBits);
 
-        @param lineStyleIndex selects the line style at lineStyleIndex in the line styles array of the parent FSShape object.
-        @param fillStyleIndex selects the fill style at fillStyleIndex in the fill styles array of the parent FSShape object.
-        @param altFillStyleIndex selects the alternate fill style at altFillStyleIndex in the fill styles array of the parent FSShape object.
-        @param relativeX move the current point by relativeX in the x direction.
-        @param relativeY move the current point by relativeY in the y direction.
-        @param lineStylesArray an array of FSLineStyle objects.
-        @param fillStylesArray an array of fill style objects.
-        */
-    public FSShapeStyle(int lineStyleIndex, int fillStyleIndex, int altFillStyleIndex, int relativeX, int relativeY, ArrayList lineStylesArray, ArrayList fillStylesArray)
-    {
-        setLineStyle(lineStyleIndex);
-        setFillStyle(fillStyleIndex);
-        setAltFillStyle(altFillStyleIndex);
-        setMoveX(relativeX);
-        setMoveY(relativeY);
-        setLineStyles(lineStylesArray);
-        setFillStyles(fillStylesArray);
-    }
-    /**
-     * Constructs an FSShapeStyle object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSShapeStyle object.
-     */
-    public FSShapeStyle(FSShapeStyle obj)
-    {
-        moveX = obj.moveX;
-        moveY = obj.moveY;
-        fillStyle = obj.fillStyle;
-        altFillStyle = obj.altFillStyle;
-        lineStyle = obj.lineStyle;
+		if (_containsAltFillStyle)
+			coder.writeBits(altFillStyle, numberOfFillBits);
 
-        if (obj.fillStyles != null)
-        {
-            fillStyles = new ArrayList();
-            
-            for (Iterator i = obj.fillStyles.iterator(); i.hasNext();)
-                fillStyles.add(((FSFillStyle)i.next()).clone());
-        }
+		if (_containsLineStyle)
+			coder.writeBits(lineStyle, numberOfLineBits);
 
-        if (obj.lineStyles != null)
-        {
-            lineStyles = new ArrayList();
-            
-            for (Iterator i = obj.lineStyles.iterator(); i.hasNext();)
-                lineStyles.add(((FSLineStyle)i.next()).clone());
-        }
-    }    
+		if (_containsStyles)
+		{
+			boolean countExtended = coder.context[FSCoder.ArrayCountExtended] != 0;
 
-    /** Add a FSSolidLine object to the array of line styles.
+			if (lineStyles == null)
+			{
+				lineStyles = new ArrayList();
+			}
 
-        @param aLineStyle and FSSolidLine object.
-        */
-    public void add(FSLineStyle aLineStyle)
-    {
-        lineStyles.add(aLineStyle);
-    }
+			if (fillStyles == null)
+			{
+				fillStyles = new ArrayList();
+			}
 
-    /** Add the fill style object to the array of fill styles.
+			coder.alignToByte();
 
-        @param aFillStyle and FSFillStyle object.
-        */
-    public void add(FSFillStyle aFillStyle)
-    {
-        fillStyles.add(aFillStyle);
-    }
+			if (countExtended &amp;&amp; fillStyles.size() &gt;= 255)
+			{
+				coder.writeBits(0xFF, 8);
+				coder.writeBits(fillStyles.size(), 16);
+			} else
+			{
+				coder.writeBits(fillStyles.size(), 8);
+			}
 
-    /** Gets the x-coordinate of any relative move specified.
+			for (Iterator styleIterator = fillStyles.iterator(); styleIterator
+							.hasNext();)
+				((FSTransformObject) styleIterator.next()).encode(coder);
 
-        @return the x-coordinate of the relative move.
-        */
-    public int getMoveX() 
-    {
-        return moveX;
-    }
+			if (countExtended &amp;&amp; lineStyles.size() &gt;= 255)
+			{
+				coder.writeBits(0xFF, 8);
+				coder.writeBits(lineStyles.size(), 16);
+			} else
+			{
+				coder.writeBits(lineStyles.size(), 8);
+			}
 
-    /** Gets the y-coordinate of any relative move specified. If the attribute is set to Transform.VALUE_NOT_SET then the value is not affected.
+			for (Iterator styleIterator = lineStyles.iterator(); styleIterator
+							.hasNext();)
+				((FSTransformObject) styleIterator.next()).encode(coder);
 
-        @return the y-coordinate of the relative move.
-        */
-    public int getMoveY()
-    {
-        return moveY;
-    }
+			numberOfFillBits = FSCoder.size(fillStyles.size(), false);
+			numberOfLineBits = FSCoder.size(lineStyles.size(), false);
 
-    /** Gets the index of the line style that will be applied to any line drawn. Returns the value Transform.VALUE_NOT_SET if no line style is defined.
+			coder.writeBits(numberOfFillBits, 4);
+			coder.writeBits(numberOfLineBits, 4);
 
-        @return the index of the selected line style.
-        */
-    public int getLineStyle() { return lineStyle; }
+			// Update the stream with the new numbers of line and fill bits
+			coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+			coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		}
+	}
 
-    /** Gets the index of the fill style that will be applied to any area filled. Returns the value Transform.VALUE_NOT_SET if no fill style is defined.
+	public void decode(FSCoder coder)
+	{
+		boolean containsStyles = false;
+		boolean containsLineStyle = false;
+		boolean containsAltFillStyle = false;
+		boolean containsFillStyle = false;
+		boolean containsMove = false;
 
-        @return the index of the selected fill style.
-        */
-    public int getFillStyle() { return fillStyle; }
+		int numberOfFillBits = coder.context[FSCoder.NumberOfFillBits];
+		int numberOfLineBits = coder.context[FSCoder.NumberOfLineBits];
 
-    /** Gets the index of the fill style that will be applied to any overlapping area filled. Returns the value Transform.VALUE_NOT_SET if no alternate fill style is defined.
+		/* shapeType */coder.readBits(1, false);
+		containsStyles = coder.readBits(1, false) != 0 ? true : false;
+		containsLineStyle = coder.readBits(1, false) != 0 ? true : false;
+		containsAltFillStyle = coder.readBits(1, false) != 0 ? true : false;
+		containsFillStyle = coder.readBits(1, false) != 0 ? true : false;
+		containsMove = coder.readBits(1, false) != 0 ? true : false;
 
-        @return the index of the selected alternate style.
-        */
-    public int getAltFillStyle() { return altFillStyle; }
+		if (containsMove)
+		{
+			int moveFieldSize = coder.readBits(5, false);
+			moveX = coder.readBits(moveFieldSize, true);
+			moveY = coder.readBits(moveFieldSize, true);
+		}
 
-    /** Gets the array of new line styles.
+		if (containsFillStyle)
+			fillStyle = coder.readBits(numberOfFillBits, false);
 
-        @return the array of FSLineStyle objects.
-        */
-    public ArrayList getLineStyles() { return lineStyles; }
+		if (containsAltFillStyle)
+			altFillStyle = coder.readBits(numberOfFillBits, false);
 
-    /** Gets the array of new fill styles.
+		if (containsLineStyle)
+			lineStyle = coder.readBits(numberOfLineBits, false);
 
-        @return the array of fill style objects.
-        */
-    public ArrayList getFillStyles() { return fillStyles; }
+		if (containsStyles)
+		{
+			coder.alignToByte();
 
-    /** Sets the x-coordinate of any relative move. May be set to Transform.VALUE_NOT_SET if the attribute should not be encoded.
+			fillStyles = new ArrayList();
+			lineStyles = new ArrayList();
 
-        @param aNumber move the current point by aNumber in the x direction.
-        */
-    public void setMoveX(int aNumber)
-    {
-        moveX = aNumber;
-    }
+			int fillStyleCount = coder.readWord(1, false);
 
-    /** Sets the y-coordinate of any relative move. May be set to Transform.VALUE_NOT_SET if the attribute should not be encoded.
+			if (coder.context[FSCoder.ArrayCountExtended] != 0
+							&amp;&amp; fillStyleCount == 0xFF)
+				fillStyleCount = coder.readWord(2, false);
 
-        @param aNumber move the current point by aNumber in the y direction.
-    */
-    public void setMoveY(int aNumber)
-    {
-        moveY = aNumber;
-    }
+			fillStyles = new ArrayList();
 
-    /** Sets the drawing point.
-        
-        @param x the x-coordinate of the drawing point.
-        @param y the y-coordinate of the drawing point.
-        */
-    public void setMove(int x, int y)
-    {
-        moveX = x;
-        moveY = y;
-    }
+			for (int i = 0; i &lt; fillStyleCount; i++)
+			{
+				switch (coder.scanWord(1, false))
+				{
+					case FSFillStyle.Solid:
+						fillStyles.add(new FSSolidFill(coder));
+						break;
+					case FSFillStyle.Linear:
+						fillStyles.add(new FSGradientFill(coder));
+						break;
+					case FSFillStyle.Radial:
+						fillStyles.add(new FSGradientFill(coder));
+						break;
+					case FSFillStyle.Tiled:
+						fillStyles.add(new FSBitmapFill(coder));
+						break;
+					case FSFillStyle.Clipped:
+						fillStyles.add(new FSBitmapFill(coder));
+						break;
+					case FSFillStyle.Unsmoothed_Tiled:
+						fillStyles.add(new FSBitmapFill(coder));
+						break;
+					case FSFillStyle.Unsmoothed_Clipped:
+						fillStyles.add(new FSBitmapFill(coder));
+						break;
+					default:
+						break;
+				}
+			}
 
-    /**    Sets the index of the fill style that will be applied to any area filled. May be set to zero if no style is selected or Transform.VALUE_NOT_SET if the attribute should not be encoded.
+			int lineStyleCount = coder.readWord(1, false);
 
-     @param anIndex selects the fill style at anIndex in the fill styles array of the parent FSShape object.
-    */
-    public void setFillStyle(int anIndex)
-    {
-        fillStyle = anIndex;
-    }
+			if (coder.context[FSCoder.ArrayCountExtended] != 0
+							&amp;&amp; lineStyleCount == 0xFF)
+				lineStyleCount = coder.readWord(2, false);
 
-    /** Sets the index of the fill style that will be applied to any overlapping area filled. May be set to zero if no style is selected or Transform.VALUE_NOT_SET if the attribute should not be encoded.
+			for (int i = 0; i &lt; lineStyleCount; i++)
+				lineStyles.add(new FSSolidLine(coder));
 
-        @param anIndex selects the alternate fill style at anIndex in the fill styles array of the parent FSShape object.
-        */
-    public void setAltFillStyle(int anIndex)
-    {
-        altFillStyle = anIndex;
-    }
+			numberOfFillBits = coder.readBits(4, false);
+			numberOfLineBits = coder.readBits(4, false);
 
-    /** Sets the index of the line style that will be applied to any line drawn. May be set to zero if no style is selected or Transform.VALUE_NOT_SET if the attribute should not be encoded.
+			coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
+			coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
+		}
+	}
 
-        @param anIndex selects the line style at anIndex in the line styles array of the parent FSShape object.
-        */
-    public void setLineStyle(int anIndex)
-    {
-        lineStyle = anIndex;
-    }
+	private boolean containsStyles()
+	{
+		return lineStyles != null || fillStyles != null;
+	}
 
-    /** Sets the array of new line styles. May be set to null if no styles are being defined.
+	private boolean containsLineStyle()
+	{
+		return lineStyle != Transform.VALUE_NOT_SET;
+	}
 
-        @param anArray an array of FSLineStyle objects.
-        */
-    public void setLineStyles(ArrayList anArray)
-    {
-        lineStyles = anArray;
-    }
+	private boolean containsAltFillStyle()
+	{
+		return altFillStyle != Transform.VALUE_NOT_SET;
+	}
 
-    /** Sets the array of new fill styles. May be set to null if no styles are being defined.
+	private boolean containsFillStyle()
+	{
+		return fillStyle != Transform.VALUE_NOT_SET;
+	}
 
-        @param anArray an array of fill style objects.
-        */
-    public void setFillStyles(ArrayList anArray)
-    {
-        fillStyles = anArray;
-    }
-
-    public Object clone()
-    {
-        FSShapeStyle anObject = (FSShapeStyle)super.clone();
-        
-        if (fillStyles != null)
-        {
-            anObject.fillStyles = new ArrayList();
-            
-            for (Iterator i = fillStyles.iterator(); i.hasNext();)
-                anObject.fillStyles.add(((FSFillStyle)i.next()).clone());
-        }
-
-        if (lineStyles != null)
-        {
-            anObject.lineStyles = new ArrayList();
-            
-            for (Iterator i = lineStyles.iterator(); i.hasNext();)
-                anObject.lineStyles.add(((FSLineStyle)i.next()).clone());
-        }
-
-        return anObject;
-    }
-
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSShapeStyle typedObject = (FSShapeStyle)anObject;
-            
-            result = moveX == typedObject.moveX;
-            result = result &amp;&amp; moveY == typedObject.moveY;
-            result = result &amp;&amp; fillStyle == typedObject.fillStyle;
-            result = result &amp;&amp; altFillStyle == typedObject.altFillStyle;
-            result = result &amp;&amp; lineStyle == typedObject.lineStyle;
-            
-            if (fillStyles != null)
-                result = result &amp;&amp; fillStyles.equals(typedObject.fillStyles);
-            else
-                result = result &amp;&amp; fillStyles == typedObject.fillStyles;
-            
-            if (lineStyles != null)
-                result = result &amp;&amp; lineStyles.equals(typedObject.lineStyles);
-            else
-                result = result &amp;&amp; lineStyles == typedObject.lineStyles;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;moveX&quot;, moveX);
-            Transform.append(buffer, &quot;moveY&quot;, moveY);
-            Transform.append(buffer, &quot;fillStyle&quot;, fillStyle);
-            Transform.append(buffer, &quot;altFillStyle&quot;, altFillStyle);
-            Transform.append(buffer, &quot;lineStyle&quot;, lineStyle);
-            Transform.append(buffer, &quot;fillStyles&quot;, fillStyles, depth);
-            Transform.append(buffer, &quot;lineStyles&quot;, lineStyles, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        boolean _containsStyles = containsStyles();
-        boolean _containsLineStyle = containsLineStyle();
-        boolean _containsAltFillStyle = containsAltFillStyle();
-        boolean _containsFillStyle = containsFillStyle();
-        boolean _containsMove = containsMove();
-    
-        int numberOfBits = 0;
-    
-        numberOfBits += 6;
-
-        if (_containsMove)
-        {
-            int _moveFieldSize = FSCoder.size(new int[] {moveX, moveY}, true);
-
-            numberOfBits += 5 + _moveFieldSize*2;
-        }
-    
-        numberOfBits += (_containsFillStyle) ? coder.context[FSCoder.NumberOfFillBits] : 0;
-        numberOfBits += (_containsAltFillStyle) ? coder.context[FSCoder.NumberOfFillBits] : 0;
-        numberOfBits += (_containsLineStyle) ? coder.context[FSCoder.NumberOfLineBits] : 0;
-        
-        coder.context[FSCoder.NumberOfShapeBits] += numberOfBits;
-
-        if (_containsStyles)
-        {
-            int numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-            int numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-            
-            boolean countExtended = coder.context[FSCoder.ArrayCountExtended] != 0;
-
-            int numberOfStyleBits = 0;
-            int flushBits = coder.context[FSCoder.NumberOfShapeBits];
-            
-            numberOfStyleBits += (flushBits % 8 &gt; 0) ? 8 - (flushBits % 8) : 0;
-            numberOfStyleBits += (countExtended &amp;&amp; fillStyles.size() &gt;= 255) ? 24 : 8;
-    
-            for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-                numberOfStyleBits += ((FSTransformObject)styleIterator.next()).length(coder)*8;
-
-            numberOfStyleBits += (countExtended &amp;&amp; lineStyles.size() &gt;= 255) ? 24 : 8;
-    
-            for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-                numberOfStyleBits += ((FSTransformObject)styleIterator.next()).length(coder)*8;
-
-            numberOfStyleBits += 8;
-    
-            coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-            coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-            coder.context[FSCoder.NumberOfShapeBits] += numberOfStyleBits;
-
-            numberOfBits += numberOfStyleBits;
-        }
-        return numberOfBits;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsStyles = containsStyles();
-        boolean _containsLineStyle = containsLineStyle();
-        boolean _containsAltFillStyle = containsAltFillStyle();
-        boolean _containsFillStyle = containsFillStyle();
-        boolean _containsMove = containsMove();
-    
-        int numberOfFillBits = coder.context[FSCoder.NumberOfFillBits];
-        int numberOfLineBits = coder.context[FSCoder.NumberOfLineBits];
-            
-        coder.writeBits(0, 1);
-        coder.writeBits(_containsStyles ? 1 : 0, 1);
-        coder.writeBits(_containsLineStyle ? 1 : 0, 1);
-        coder.writeBits(_containsAltFillStyle ? 1 : 0, 1);
-        coder.writeBits(_containsFillStyle ? 1 : 0, 1);
-        coder.writeBits(_containsMove ? 1 : 0, 1);
-
-        if (_containsMove)
-        {
-            int _moveFieldSize = FSCoder.size(new int[] { moveX, moveY }, true);
-            
-            coder.writeBits(_moveFieldSize, 5);
-            coder.writeBits(moveX, _moveFieldSize);
-            coder.writeBits(moveY, _moveFieldSize);
-        }
-    
-        if (_containsFillStyle)
-            coder.writeBits(fillStyle, numberOfFillBits);
-    
-        if (_containsAltFillStyle)
-            coder.writeBits(altFillStyle, numberOfFillBits);
-    
-        if (_containsLineStyle)
-            coder.writeBits(lineStyle, numberOfLineBits);
-    
-        if (_containsStyles)
-        {
-            boolean countExtended = coder.context[FSCoder.ArrayCountExtended] != 0;
-            
-            if (lineStyles == null) {
-            	lineStyles = new ArrayList();
-            }
-            
-            if (fillStyles == null) {
-            	fillStyles = new ArrayList();
-            }
-
-            coder.alignToByte();
-        
-            if (countExtended &amp;&amp; fillStyles.size() &gt;= 255)
-            {
-                coder.writeBits(0xFF, 8);
-                coder.writeBits(fillStyles.size(), 16);
-            }
-            else
-            {
-                coder.writeBits(fillStyles.size(), 8);
-            }
-    
-            for (Iterator styleIterator = fillStyles.iterator(); styleIterator.hasNext();) 
-                ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-            if (countExtended &amp;&amp; lineStyles.size() &gt;= 255)
-            {
-                coder.writeBits(0xFF, 8);
-                coder.writeBits(lineStyles.size(), 16);
-            }
-            else
-            {
-                coder.writeBits(lineStyles.size(), 8);
-            }
-    
-            for (Iterator styleIterator = lineStyles.iterator(); styleIterator.hasNext();) 
-                ((FSTransformObject)styleIterator.next()).encode(coder);
-    
-            numberOfFillBits = FSCoder.size(fillStyles.size(), false);
-            numberOfLineBits = FSCoder.size(lineStyles.size(), false);
-        
-            coder.writeBits(numberOfFillBits, 4);
-            coder.writeBits(numberOfLineBits, 4);
-
-            // Update the stream with the new numbers of line and fill bits
-            coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-            coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean containsStyles = false;
-        boolean containsLineStyle = false;
-        boolean containsAltFillStyle = false;
-        boolean containsFillStyle = false;
-        boolean containsMove = false;
-        
-        int numberOfFillBits = coder.context[FSCoder.NumberOfFillBits];
-        int numberOfLineBits = coder.context[FSCoder.NumberOfLineBits];
-
-        /* shapeType */ coder.readBits(1, false);
-        containsStyles = coder.readBits(1, false) != 0 ? true : false;
-        containsLineStyle = coder.readBits(1, false) != 0 ? true : false;
-        containsAltFillStyle = coder.readBits(1, false) != 0 ? true : false;
-        containsFillStyle = coder.readBits(1, false) != 0 ? true : false;
-        containsMove = coder.readBits(1, false) != 0 ? true : false;
-        
-        if (containsMove)
-        {
-            int moveFieldSize = coder.readBits(5, false);
-            moveX = coder.readBits(moveFieldSize, true);
-            moveY = coder.readBits(moveFieldSize, true);
-        }
-
-        if (containsFillStyle)
-            fillStyle = coder.readBits(numberOfFillBits, false);
-
-        if (containsAltFillStyle)
-            altFillStyle = coder.readBits(numberOfFillBits, false);
-
-        if (containsLineStyle)
-            lineStyle = coder.readBits(numberOfLineBits, false);
-
-        if (containsStyles)
-        {
-            coder.alignToByte();
-            
-            fillStyles = new ArrayList();
-            lineStyles = new ArrayList();
-        
-            int fillStyleCount = coder.readWord(1, false);
-
-            if (coder.context[FSCoder.ArrayCountExtended] != 0 &amp;&amp; fillStyleCount == 0xFF)
-                fillStyleCount = coder.readWord(2, false);
-
-            fillStyles = new ArrayList();
-
-            for (int i=0; i&lt;fillStyleCount; i++)
-            {
-                switch (coder.scanWord(1, false))
-                {
-                    case FSFillStyle.Solid:
-                        fillStyles.add(new FSSolidFill(coder));
-                        break;
-                    case FSFillStyle.Linear:
-                        fillStyles.add(new FSGradientFill(coder));
-                        break;
-                    case FSFillStyle.Radial:
-                        fillStyles.add(new FSGradientFill(coder));
-                        break;
-                    case FSFillStyle.Tiled:
-                        fillStyles.add(new FSBitmapFill(coder));
-                        break;
-                    case FSFillStyle.Clipped:
-                        fillStyles.add(new FSBitmapFill(coder));
-                        break;
-                    case FSFillStyle.Unsmoothed_Tiled:
-                        fillStyles.add(new FSBitmapFill(coder));
-                        break;
-                    case FSFillStyle.Unsmoothed_Clipped:
-                        fillStyles.add(new FSBitmapFill(coder));
-                        break;
-                    default:
-                        break;    
-                }        
-            }
-            
-            int lineStyleCount = coder.readWord(1, false);
-
-            if (coder.context[FSCoder.ArrayCountExtended] != 0 &amp;&amp; lineStyleCount == 0xFF)
-                lineStyleCount = coder.readWord(2, false);
-
-            for (int i=0; i&lt;lineStyleCount; i++)
-                lineStyles.add(new FSSolidLine(coder));
-            
-            numberOfFillBits = coder.readBits(4, false);
-            numberOfLineBits = coder.readBits(4, false);
-    
-            coder.context[FSCoder.NumberOfFillBits] = numberOfFillBits;
-            coder.context[FSCoder.NumberOfLineBits] = numberOfLineBits;
-        }
-    }
-
-    private boolean containsStyles()
-    {
-        return lineStyles != null || fillStyles != null;
-    }
-
-    private boolean containsLineStyle()
-    {
-        return lineStyle != Transform.VALUE_NOT_SET;
-    }
-
-    private boolean containsAltFillStyle()
-    {
-        return altFillStyle != Transform.VALUE_NOT_SET;
-    }
-
-    private boolean containsFillStyle()
-    {
-        return fillStyle != Transform.VALUE_NOT_SET;
-    }
-
-    private boolean containsMove()
-    {
-        return moveX != Transform.VALUE_NOT_SET &amp;&amp; moveY != Transform.VALUE_NOT_SET;
-    }
+	private boolean containsMove()
+	{
+		return moveX != Transform.VALUE_NOT_SET
+						&amp;&amp; moveY != Transform.VALUE_NOT_SET;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSShowFrame.java
===================================================================
--- trunk/src/com/flagstone/transform/FSShowFrame.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSShowFrame.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,131 +31,159 @@
 package com.flagstone.transform;
 
 /**
-FSShowFrame is used to instruct the Flash Player to display a single frame in a movie or 
-movie clip. 
- 
-&lt;p&gt;When a frame is displayed the Flash Player performs the following:&lt;/p&gt;
+ * FSShowFrame is used to instruct the Flash Player to display a single frame in
+ * a movie or movie clip.
+ * 
+ * &lt;p&gt;
+ * When a frame is displayed the Flash Player performs the following:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;The contents of the Flash Player's display list are drawn on the screen.&lt;/li&gt;
+ * &lt;li&gt;Any actions defined using a FSDoAction object are executed.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Objects are placed in the display list using the FSPlaceObject and
+ * FSPlaceObject2 classes and removed using the FSRemoveObject and
+ * FSRemoveObject2 classes. An object which has been added to the display list
+ * will be displayed in each frame until it is explicitly removed. There is no
+ * need to repeatedly add it to the display list.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The scope of a frame is delineated by successive FSShowFrame objects. All the
+ * commands that affect change the state of the display list or define actions
+ * to be executed take effect when the Flash Player displays the frame. All the
+ * objects displayed in a frame must be defined before they can be displayed.
+ * The movie is displayed as it is downloaded so displaying objects that are
+ * defined later in a movie is not allowed.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  FSMovie movie = new FSMovie();
+ * 
+ *  // Frame 1 - starts from the beginning of the file.
+ *  ...
+ *  movie.add(new FSShowFrame());
+ * 
+ *  // Frame 2 - starts when the previous frame is displayed.
+ * 
+ *  // All displayable objects are referenced using unique identifier.
+ * 
+ *  int identifier = movie.newIdentifier();
+ * 
+ *  // Define a shape to be displayed.
+ * 
+ *  movie.add(new FSDefineShape(identifier, ......));
+ * 
+ *  // Add the shape to the display list - on layer 1 at coordinates (400, 400)
+ * 
+ *  movie.add(new FSPlaceObject(FSPlaceObject.New, identifier, 1, 400, 400));
+ * 
+ *  // Add some actions
+ * 
+ *  FSDoAction frameActions = new FSDoAction(); 
+ * 
+ *  frameActions.add(anAction);
+ *  frameActions.add(anotherAction);
+ * 
+ *  movie.add(frameActions);
+ * 
+ *  // The shape is displayed and the actions executed when the FSShowFrame command is executed.
+ * 
+ *  movie.add(new FSShowFrame());
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSShowFrame class represents the ShowFrame data structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
+ */
+public class FSShowFrame extends FSMovieObject
+{
+	private static final FSShowFrame instance = new FSShowFrame();
 
-&lt;ul&gt;
-&lt;li&gt;The contents of the Flash Player's display list are drawn on the screen.&lt;/li&gt;
-&lt;li&gt;Any actions defined using a FSDoAction object are executed.&lt;/li&gt;
-&lt;/ul&gt;
+	/**
+	 * Returns a canonical FSShowFrame object.
+	 * 
+	 * @return an object that can safely be shared among objects.
+	 */
+	public static FSShowFrame getInstance()
+	{
+		return instance;
+	}
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSShowFrame object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSShowFrame(FSCoder coder)
+	{
+		super(FSMovieObject.ShowFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Constructs an FSShowFrame object. */
+	public FSShowFrame()
+	{
+		super(FSMovieObject.ShowFrame);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSShowFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSShowFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSShowFrame object.
+	 */
+	public FSShowFrame(FSShowFrame obj)
+	{
+		super(obj);
+	}
 
-&lt;/table&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
 
-&lt;p&gt;Objects are placed in the display list using the FSPlaceObject and FSPlaceObject2 classes and removed using the FSRemoveObject and FSRemoveObject2 classes. An object which has been added to the display list will be displayed in each frame until it is explicitly removed. There is no need to repeatedly add it to the display list.&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;p&gt;The scope of a frame is delineated by successive FSShowFrame objects. All the commands that affect change the state of the display list or define actions to be executed take effect when the Flash Player displays the frame. All the objects displayed in a frame must be defined before they can be displayed. The movie is displayed as it is downloaded so displaying objects that are defined later in a movie is not allowed.&lt;/p&gt;
+		return length;
+	}
 
-&lt;pre&gt;
-FSMovie movie = new FSMovie();
+	public void encode(FSCoder coder)
+	{
+		coder.context[FSCoder.Empty] = 1;
+		super.encode(coder);
+		coder.context[FSCoder.Empty] = 0;
+		coder.endObject(name());
+	}
 
-// Frame 1 - starts from the beginning of the file.
-...
-movie.add(new FSShowFrame());
-
-// Frame 2 - starts when the previous frame is displayed.
-
-// All displayable objects are referenced using unique identifier.
-
-int identifier = movie.newIdentifier();
-
-// Define a shape to be displayed.
-
-movie.add(new FSDefineShape(identifier, ......));
-
-// Add the shape to the display list - on layer 1 at coordinates (400, 400)
-
-movie.add(new FSPlaceObject(FSPlaceObject.New, identifier, 1, 400, 400));
-
-// Add some actions
-
-FSDoAction frameActions = new FSDoAction(); 
-
-frameActions.add(anAction);
-frameActions.add(anotherAction);
-
-movie.add(frameActions);
-
-// The shape is displayed and the actions executed when the FSShowFrame command is executed.
-
-movie.add(new FSShowFrame());
-&lt;/pre&gt;
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSShowFrame class represents the ShowFrame data structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSShowFrame extends FSMovieObject
-{
-    private static final FSShowFrame instance = new FSShowFrame();
-    
-    /**
-     * Returns a canonical FSShowFrame object.
-     * 
-     * @return an object that can safely be shared among objects.
-     */
-    public static FSShowFrame getInstance()
-    {
-        return instance;
-    }
-    /**
-     * Construct an FSShowFrame object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSShowFrame(FSCoder coder)
-    {
-        super(FSMovieObject.ShowFrame);
-        decode(coder);
-    }
-    /** Constructs an FSShowFrame object. */
-    public FSShowFrame()
-    {
-        super(FSMovieObject.ShowFrame);
-    }
-    /**
-     * Constructs an FSShowFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSShowFrame object.
-     */
-    public FSShowFrame(FSShowFrame obj)
-    {
-        super(obj);
-    }    
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-
-        return length;
-    }    
-
-    public void encode(FSCoder coder)
-    {
-        coder.context[FSCoder.Empty] = 1;
-        super.encode(coder);
-        coder.context[FSCoder.Empty] = 0;
-        coder.endObject(name());
-    }
-
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSolidFill.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSolidFill.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSolidFill.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,175 +31,220 @@
 package com.flagstone.transform;
 
 /**
-FSSolidFill defines a solid colour that is used to fill an enclosed area in a shape.
+ * FSSolidFill defines a solid colour that is used to fill an enclosed area in a
+ * shape.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;color&lt;/td&gt;
+ * &lt;td&gt;The colour used to fill the area of the shape.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The parent class, FSFillStyle allows the type to be set. This should only be
+ * used for manipulating bitmap and gradient fill styles.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Fill styles are selected using the FSShapeStyle class and are referenced by
+ * their ordinal position in the array of available styles. The ordinal position
+ * in the array is used rather than the index (which starts at 0). An index of 0
+ * is used to specify that a fill style is not selected.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * An FSSolidFill object is created by specifying the colour to fill the shape:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSColor red = new FSColor(255, 0, 0);
+ * 
+ * FSSolidFill fill = new FSSolidFill(red);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Shapes can be filled with transparent colours - rather than specifying that
+ * the entire shape is transparent when adding it to the display list using the
+ * FSPlaceObject2 class:
+ * 
+ * &lt;pre&gt;
+ * FSColor transparentRed = new FSColor(255, 0, 0, 128);
+ * 
+ * FSSolidFill transparentFill = new FSSolidFill(transparentRed);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Note however that the object used to create the shape definition determines
+ * whether the alpha channel is encoded. Simply specifying the level of
+ * transparency in the FSColor object is not sufficient. Transparent colours are
+ * only supports in Flash 3 onwards.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * To reference different colours to fill a shape use the ordinal position of
+ * the FSSolidFill object in the array of fill styles defined in the shape:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList fillStyles = new ArrayList();
+ *  fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0))); // red 
+ *  fillStyles.add(new FSSolidFill(new FSColor(0, 255, 0))); // green
+ * 
+ *  FSShape shape = new FSShape(); \n&quot;; 
+ * 
+ *  // The fill styles are referenced by their ordinal position in the 
+ *  // array of styles.
+ *  int redStyle = 1; 
+ *  int greenStyle = 2; 
+ * 
+ *  // fill the enclosed area with red.
+ *  shape.add(new FSShapeStyle(0, redStyle, 0));
+ *  ...
+ *  // now fill the remaining area with green.
+ *  shape.add(new FSShapeStyle(0, greenStyle, 0));
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;
+ * History
+ * &lt;/h1&gt;
+ * &lt;p&gt;
+ * The FSSolidFill class represents the FillStyle structure from the 
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in 
+ * Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSSolidFill extends FSFillStyle
+{
+	private FSColor color = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSolidFill object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSolidFill(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSolidFill object of the specified colour.
+	 * 
+	 * @param aColor
+	 *            an FSColor object that defines the colour that the area will
+	 *            be filled with.
+	 */
+	public FSSolidFill(FSColor aColor)
+	{
+		super(FSFillStyle.Solid);
+		setColor(aColor);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSolidFill_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSolidFill object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSolidFill object.
+	 */
+	public FSSolidFill(FSSolidFill obj)
+	{
+		super(obj);
+		color = new FSColor(obj.color);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSolidFill_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour used to fill the area of the shape.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the colour of the fill style.
+	 * 
+	 * @return the colour defined for the solid fill.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the colour of the fill style.
+	 * 
+	 * @param aColor
+	 *            an FSColor object that defines the colour that the area will
+	 *            be filled with.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-&lt;p&gt;The parent class, FSFillStyle allows the type to be set. This should only be used for manipulating bitmap and gradient fill styles.&lt;/p&gt; 
+	public Object clone()
+	{
+		FSSolidFill anObject = (FSSolidFill) super.clone();
 
-&lt;p&gt;Fill styles are selected using the FSShapeStyle class and are referenced by their ordinal position in the array of available styles. The ordinal position in the array is used rather than the index (which starts at 0). An index of 0 is used to specify that a fill style is not selected.&lt;/p&gt;
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+		return anObject;
+	}
 
-&lt;p&gt;An FSSolidFill object is created by specifying the colour to fill the shape:&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSColor red = new FSColor(255, 0, 0);
-FSSolidFill fill = new FSSolidFill(red);
-&lt;/pre&gt;
+		if (super.equals(anObject))
+		{
+			FSSolidFill typedObject = (FSSolidFill) anObject;
 
-&lt;p&gt;Shapes can be filled with transparent colours - rather than specifying that the entire shape is transparent when adding it to the display list using the FSPlaceObject2 class:
+			if (color != null)
+				result = color.equals(typedObject.color);
+			else
+				result = color == typedObject.color;
+		}
+		return result;
+	}
 
-&lt;pre&gt;
-FSColor transparentRed = new FSColor(255, 0, 0, 128);
-FSSolidFill transparentFill = new FSSolidFill(transparentRed);
-&lt;/pre&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;p&gt;Note however that the object used to create the shape definition determines whether the alpha channel is encoded. Simply specifying the level of transparency in the FSColor object is not sufficient. Transparent colours are only supports in Flash 3 onwards.&lt;/p&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;color&quot;, color, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;To reference different colours to fill a shape use the ordinal position of the FSSolidFill object in the array of fill styles defined in the shape:&lt;/p&gt;
+	public int length(FSCoder coder)
+	{
+		int length = super.length(coder);
 
-&lt;pre&gt;
-ArrayList fillStyles = new ArrayList();
+		length += color.length(coder);
 
-fillStyles.add(new FSSolidFill(new FSColor(255, 0, 0))); // red 
-fillStyles.add(new FSSolidFill(new FSColor(0, 255, 0))); // green
+		return length;
+	}
 
-FSShape shape = new FSShape(); \n&quot;; 
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		color.encode(coder);
+	}
 
-// The fill styles are referenced by their ordinal position in the 
-// array of styles.
-
-int redStyle = 1; 
-int greenStyle = 2; 
-
-// fill the enclosed area with red.
-shape.add(new FSShapeStyle(0, redStyle, 0));
-...
-// now fill the remaining area with green.
-shape.add(new FSShapeStyle(0, greenStyle, 0));
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSSolidFill class represents the FillStyle structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
- */
-public class FSSolidFill extends FSFillStyle
-{
-    private FSColor color = null;
-    
-    /**
-     * Construct an FSSolidFill object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSolidFill(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**    Constructs an FSSolidFill object of the specified colour.
-
-        @param aColor an FSColor object that defines the colour that the area will be filled with.
-        */
-    public FSSolidFill(FSColor aColor)
-    {
-        super(FSFillStyle.Solid);
-        setColor(aColor);
-    }
-    /**
-     * Constructs an FSSolidFill object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSolidFill object.
-     */
-    public FSSolidFill(FSSolidFill obj)
-    {
-        super(obj);
-        color = new FSColor(obj.color);
-    }    
-
-    /** Gets the colour of the fill style.
-
-        @return the colour defined for the solid fill.
-        */
-    public FSColor getColor() { return color; }
-
-    /** Sets the colour of the fill style.
-
-        @param aColor an FSColor object that defines the colour that the area will be filled with.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
-
-    public Object clone()
-    {
-        FSSolidFill anObject = (FSSolidFill)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSolidFill typedObject = (FSSolidFill)anObject;
-            
-            if (color != null)
-                result = color.equals(typedObject.color);
-            else
-                result = color == typedObject.color;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = super.length(coder);
-    
-        length += color.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        color.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        color = new FSColor(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		color = new FSColor(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSolidLine.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSolidLine.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSolidLine.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,192 +31,239 @@
 package com.flagstone.transform;
 
 /**
-FSSolidLine defines the width and colour of a line that is used when drawing the outline of a shape.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSSolidLine defines the width and colour of a line that is used when drawing
+ * the outline of a shape.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSolidLine_0&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The width of the line drawn in twips.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSolidLine_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The colour used to draw the line.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * All lines are drawn with rounded corners and end caps. Different join and
+ * line end styles can be created by drawing line segments as a sequence of
+ * filled shapes. With 1 twip equal to 1/20th of a pixel this technique can
+ * easily be used to draw the narrowest of visible lines.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Whether the alpha channel in the colour is used is determined by the class
+ * used to define the shape. Transparent colours are only supported from Flash 3
+ * onwards. Simply specifying the level of transparency in the FSColor object is
+ * not sufficient.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;pre&gt;
+ * FSSolidLine lineStyle = new FSSolidLine(20, new FSColor(0, 0, 0));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Draws a black line, 1 pixel wide.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSSolidLine lineStyle = new FSSolidLine(20, new FSColor(255, 0, 0, 128));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * Draws a transparent red line, 1 pixel wide. If the alpha channel is not
+ * specified then the value defaults to 255 generating a completely opaque
+ * colour.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * Flash only supports contiguous lines. Dashed line styles can be created by
+ * drawing the line as a series of short line segments by interspersing
+ * FSShapeStyle objects to move the current point in between the FSLine objects
+ * that draw the line segments.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * // define the line style
+ * lineStyles.add(new FSSolidLine(20, new FSColor(0, 0, 0)));
+ * 
+ * // Select the line style
+ * shape.add(new FSShapeStyle(1, 0, 0));
+ * 
+ * // Draw the dashed line with lines and gaps each 5 pixels long
+ * shape.add(new FSShapeStyle(1, 0, 0));
+ * 
+ * for (int i = 0; i &lt; 10; i++)
+ * {
+ * 	shape.add(new FSLine(100, 0));
+ * 	shape.add(new FSShapeStyle(0, 0, 0));
+ * 	shape.add(new FSLine(100, 0));
+ * }
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSolidLine class represents the LineStyle structure from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1. Support
+ * for transparent colours was added in Flash 3.
+ * &lt;/p&gt;
+ */
+public class FSSolidLine extends FSLineStyle
+{
+	private int width = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	private FSColor color = null;
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSolidLine_0&quot;&gt;width&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The width of the line drawn in twips.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct an FSSolidLine object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSolidLine(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSolidLine_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The colour used to draw the line.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSolidLine, specifying the width and colour of the line.
+	 * 
+	 * @param aWidth
+	 *            the width of the line.
+	 * @param aColor
+	 *            the colour of the line.
+	 */
+	public FSSolidLine(int aWidth, FSColor aColor)
+	{
+		setWidth(aWidth);
+		setColor(aColor);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Constructs an FSSolidLine object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSolidLine object.
+	 */
+	public FSSolidLine(FSSolidLine obj)
+	{
+		width = obj.width;
+		color = new FSColor(obj.color);
+	}
 
-&lt;p&gt;All lines are drawn with rounded corners and end caps. Different join and line end styles can be created by drawing line segments as a sequence of filled shapes. With 1 twip equal to 1/20th of a pixel this technique can easily be used to draw the narrowest of visible lines.&lt;/p&gt;
+	/**
+	 * Gets the width of the line.
+	 * 
+	 * @return the width of the line.
+	 */
+	public int getWidth()
+	{
+		return width;
+	}
 
-&lt;p&gt;Whether the alpha channel in the colour is used is determined by the class used to define the shape. Transparent colours are only supported from Flash 3 onwards. Simply specifying the level of transparency in the FSColor object is not sufficient.&lt;/p&gt;
+	/**
+	 * Gets the colour of the line.
+	 * 
+	 * @return the colour for the line.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	/**
+	 * Sets the width of the line.
+	 * 
+	 * @param aNumber
+	 *            the width of the line.
+	 */
+	public void setWidth(int aNumber)
+	{
+		width = aNumber;
+	}
 
-&lt;pre&gt;
-FSSolidLine lineStyle = new FSSolidLine(20, new FSColor(0, 0, 0));
-&lt;/pre&gt;
+	/**
+	 * Sets the colour of the line.
+	 * 
+	 * @param aColor
+	 *            the colour of the line.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-&lt;p&gt;Draws a black line, 1 pixel wide.&lt;/p&gt;
+	public Object clone()
+	{
+		FSSolidLine anObject = (FSSolidLine) super.clone();
 
-&lt;pre&gt;
-FSSolidLine lineStyle = new FSSolidLine(20, new FSColor(255, 0, 0, 128));
-&lt;/pre&gt;
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-&lt;p&gt;Draws a transparent red line, 1 pixel wide. If the alpha channel is not specified then the value defaults to 255 generating a completely opaque colour.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;p&gt;Flash only supports contiguous lines. Dashed line styles can be created by drawing the line as a series of short line segments by interspersing FSShapeStyle objects to move the current point in between the FSLine objects that draw the line segments.&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-// define the line style
-lineStyles.add(new FSSolidLine(20, new FSColor(0, 0, 0)));
+		if (super.equals(anObject))
+		{
+			FSSolidLine typedObject = (FSSolidLine) anObject;
 
-// Select the line style
-shape.add(new FSShapeStyle(1, 0, 0));
+			result = width == typedObject.width;
 
-// Draw the dashed line with lines and gaps each 5 pixels long
-shape.add(new FSShapeStyle(1, 0, 0));
+			if (color != null)
+				result = result &amp;&amp; color.equals(typedObject.color);
+			else
+				result = result &amp;&amp; color == typedObject.color;
+		}
+		return result;
+	}
 
-for (int i=0; i&lt;10; i++)
-{
-    shape.add(new FSLine(100, 0));
-    shape.add(new FSShapeStyle(0, 0, 0));
-    shape.add(new FSLine(100, 0));
-}
-&lt;/pre&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;width&quot;, width);
+			Transform.append(buffer, &quot;color&quot;, color, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSSolidLine class represents the LineStyle structure from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1. Support for transparent colours was added in Flash 3.&lt;/p&gt;
- */
-public class FSSolidLine extends FSLineStyle
-{
-    private int width = 0;
-    private FSColor color = null;
-    
-    /**
-     * Construct an FSSolidLine object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSolidLine(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSSolidLine, specifying the width and colour of the line. 
+	public int length(FSCoder coder)
+	{
+		int length = 2;
 
-        @param aWidth the width of the line.
-        @param aColor the colour of the line.
-        */
-    public FSSolidLine(int aWidth, FSColor aColor)
-    {
-        setWidth(aWidth);
-        setColor(aColor);
-    }
-    /**
-     * Constructs an FSSolidLine object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSolidLine object.
-     */
-    public FSSolidLine(FSSolidLine obj)
-    {
-        width = obj.width;
-        color = new FSColor(obj.color);
-    }    
+		length += color.length(coder);
 
-    /**  Gets the width of the line.
+		return length;
+	}
 
-        @return the width of the line.
-        */
-    public int getWidth() 
-    {  
-        return width;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.writeWord(width, 2);
+		color.encode(coder);
+	}
 
-    /** Gets the colour of the line.
-
-        @return the colour for the line.
-        */
-    public FSColor getColor() { return color; }
-
-    /** Sets the width of the line.
-
-        @param aNumber the width of the line.
-        */
-    public void setWidth(int aNumber)
-    {
-        width = aNumber;
-    }
-
-    /** Sets the colour of the line.
-
-        @param aColor the colour of the line.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
-
-    public Object clone()
-    {
-        FSSolidLine anObject = (FSSolidLine)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
-        
-        return anObject;
-    }
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSolidLine typedObject = (FSSolidLine)anObject;
-            
-            result = width == typedObject.width;
-
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;width&quot;, width);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        int length = 2;
-    
-        length += color.length(coder);
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        coder.writeWord(width, 2);
-        color.encode(coder);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        width = coder.readWord(2, false);
-        color = new FSColor(coder);
-    }
+	public void decode(FSCoder coder)
+	{
+		width = coder.readWord(2, false);
+		color = new FSColor(coder);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSound.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSound.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSound.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,439 +33,600 @@
 import java.util.*;
 
 /**
-The FSSound class identifies a sound (previously defined using The FSDefineSound class) 
-and controls how it is played.
+ * The FSSound class identifies a sound (previously defined using The
+ * FSDefineSound class) and controls how it is played.
+ * 
+ * &lt;p&gt;
+ * FSSound defines how the sound fades in and out, whether it is repeated as
+ * well as specifying an envelope that provides a finer degree of control over
+ * the levels at which the sound is played.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSound_0&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the FSDefineSound object that
+ * contains the sound data.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSound_1&quot;&gt;mode&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;Controls how the sound is played, either: Start - start playing the
+ * sound, Continue - start playing the sound if it is not already playing and
+ * Stop - stop playing the sound.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSound_2&quot;&gt;inPoint&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The sample number that the sound increases in volume to until full
+ * volume is reached. Optional. Set to 0 if the sound does not fade in.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSound_3&quot;&gt;outPoint&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The sample number at which the that the sound starts to fades until the
+ * sound has finished playing. Optional. Set to 0 if the sound does not fade
+ * out.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSound_4&quot;&gt;loopCount&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The number of times the sound is repeated. Optional. Must be at least 1
+ * if a sound is being played. Set to 0 if a sound is being stopped.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSSound_5&quot;&gt;envelopes&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An array of FSEnvelope objects that control how the sound is played.
+ * Optional. May be set to null or an empty array if no envelope is defined.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Not all the attributes are required to play a sound. Only the identifier and
+ * the mode is required. The other attributes are optional and may be added as a
+ * greater degree of control is required. The inPoint and outPoint attributes
+ * may be set to zero if the sound does not fade in or out respectively. The
+ * loopCount may be set to zero if a sound is being stopped. The envelopes array
+ * may be left empty if no envelope is defined for the sound. The class provides
+ * different constructors to specify different sets of attributes.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The in and out point specify the sample number which marks the point in time
+ * at which the sound stops increasing or starts decreasing in volume
+ * respectively. Sounds are played by the Flash player at 44.1KHz so the sample
+ * number also indicates the time when the total number of samples in the sound
+ * is taken into account.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSound class is based on the SoundInfo data structure from the
+ * Macromedia Flash (SWF) File Format Specification. However it also contains
+ * the identifier for the sound which is a separate attribute in the data
+ * structures defined in the specification that contain SoundInfo data.
+ * &lt;/p&gt;
+ */
+public class FSSound extends FSTransformObject
+{
+	/**
+	 * Identifies an uncompressed pulse code modulated sound. The byte-order for
+	 * 16-bit sound samples is dependent on the host platform on which the sound
+	 * is played.
+	 */
+	public static final int NATIVE_PCM = 0;
 
-&lt;p&gt;FSSound defines how the sound fades in and out, whether it is repeated as well as specifying an envelope that provides a finer degree of control over the levels at which the sound is played.&lt;/p&gt;
+	/** Identifies an adaptive pulse code modulated sound. */
+	public static final int ADPCM = 1;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/** Identifies an MP3 format sound. */
+	public static final int MP3 = 2;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Identifies an uncompressed pulse code modulated sound, little-endian byte
+	 * order.
+	 */
+	public static final int PCM = 3;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_0&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the FSDefineSound object that contains the sound data.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 6
+	// / Identifies a Nellymoser Asao encoded sound.
+	public static final int NELLYMOSER = 6;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_1&quot;&gt;mode&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Controls how the sound is played, either: Start - start playing the sound, Continue - start playing the sound if it is not already playing and Stop - stop playing the sound.&lt;/td&gt;
-&lt;/tr&gt;
+	// End Flash 6
+	/** Start playing the sound. */
+	public static final int Start = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_2&quot;&gt;inPoint&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sample number that the sound increases in volume to until full volume is reached. Optional. Set to 0 if the sound does not fade in.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Start playing the sound or continues if it is already playing. */
+	public static final int Continue = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_3&quot;&gt;outPoint&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The sample number at which the that the sound starts to fades until the sound has finished playing. Optional. Set to 0 if the sound does not fade out.&lt;/td&gt;
-&lt;/tr&gt;
+	/** Stop playing the sound. */
+	public static final int Stop = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_4&quot;&gt;loopCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of times the sound is repeated. Optional. Must be at least 1 if a sound is being played. Set to 0 if a sound is being stopped.&lt;/td&gt;
-&lt;/tr&gt;
+	private int identifier = 0;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSound_5&quot;&gt;envelopes&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSEnvelope objects that control how the sound is played. Optional. May be set to null or an empty array if no envelope is defined.&lt;/td&gt;
-&lt;/tr&gt;
+	private int mode = 0;
 
-&lt;/table&gt;
+	private int inPoint = 0;
 
-&lt;p&gt;Not all the attributes are required to play a sound. Only the identifier and the mode is required. The other attributes are optional and may be added as a greater degree of control is required. The inPoint and outPoint attributes may be set to zero if the sound does not fade in or out respectively. The loopCount may be set to zero if a sound is being stopped. The envelopes array may be left empty if no envelope is defined for the sound. The class provides different constructors to specify different sets of attributes.&lt;/p&gt;
+	private int outPoint = 0;
 
-&lt;p&gt;The in and out point specify the sample number which marks the point in time at which the sound stops increasing or starts decreasing in volume respectively. Sounds are played by the Flash player at 44.1KHz so the sample number also indicates the time when the total number of samples in the sound is taken into account.&lt;/p&gt;
+	private int loopCount = 0;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	private ArrayList envelopes = null;
 
-&lt;p&gt;The FSSound class is based on the SoundInfo data structure from the Macromedia Flash (SWF) File Format Specification. However it also contains the identifier for the sound which is a separate attribute in the data structures defined in the specification that contain SoundInfo data.&lt;/p&gt;
- */
-public class FSSound extends FSTransformObject
-{
-    /** Identifies an uncompressed pulse code modulated sound. The byte-order for 16-bit sound samples
-     is dependent on the host platform on which the sound is played. */
-    public static final int NATIVE_PCM = 0;
-    /** Identifies an adaptive pulse code modulated sound. */
-    public static final int ADPCM = 1;
-    /** Identifies an MP3 format sound. */
-    public static final int MP3 = 2;
-    /** Identifies an uncompressed pulse code modulated sound, little-endian byte order. */
-    public static final int PCM = 3;
-// Flash 6
-    /// Identifies a Nellymoser Asao encoded sound.
-    public static final int NELLYMOSER = 6;
-// End Flash 6
-    /** Start playing the sound. */
-    public static final int Start = 0;
-    /** Start playing the sound or continues if it is already playing. */
-    public static final int Continue = 1;
-    /** Stop playing the sound. */
-    public static final int Stop = 2;
+	/**
+	 * Construct an FSSound object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSound(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-    private int identifier = 0;
-    private int mode = 0;
-    private int inPoint = 0;
-    private int outPoint = 0;
-    private int loopCount = 0;
-    private ArrayList envelopes = null;
+	/**
+	 * Constructs an FSSound object specifying how the sound is played.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Start - start playing the sound, Continue - do not play the
+	 *            sound if it is already playing and Stop - stop playing the
+	 *            sound.
+	 */
+	public FSSound(int anIdentifier, int aMode)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+	}
 
-    /**
-     * Construct an FSSound object, initalizing it with values decoded from an 
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSound(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSSound object specifying how the sound is played.
+	/**
+	 * Constructs and FSSound object specifying how the sound is played and the
+	 * number of times the sound is repeated.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param aCount
+	 *            the number of times the sound is repeated. May be set to zero
+	 *            if the sound will not be repeated.
+	 */
+	public FSSound(int anIdentifier, int aMode, int aCount)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setLoopCount(aCount);
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Start - start playing the sound, Continue - do not play the sound if it is already playing and Stop - stop playing the sound.
-        */
-    public FSSound(int anIdentifier, int aMode)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-    }
+	/**
+	 * Constructs and FSSound object specifying how the sound is played and the
+	 * points at which the sound fades in and out.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param anInPoint
+	 *            the sample number which the sound fades in to. May be set to
+	 *            zero if the sound does not fade in.
+	 * @param anOutPoint
+	 *            the sample number at which the sound starts to fade. May be
+	 *            set to zero if the sound does not fade out.
+	 */
+	public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setInPoint(anInPoint);
+		setOutPoint(anOutPoint);
+	}
 
-    /** Constructs and FSSound object specifying how the sound is played and the number of times the sound is repeated.
+	/**
+	 * Constructs and FSSound object specifying how the sound is played, the
+	 * point at which the sound fades in and out and the number of times the
+	 * sound is repeated.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param anInPoint
+	 *            the sample number which the sound fades in to. May be set to
+	 *            zero if the sound does not fade in.
+	 * @param anOutPoint
+	 *            the sample number at which the sound starts to fade. May be
+	 *            set to zero if the sound does not fade out.
+	 * @param aCount
+	 *            the number of times the sound is repeated. May be set to zero
+	 *            if the sound will not be repeated.
+	 */
+	public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint,
+					int aCount)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setInPoint(anInPoint);
+		setOutPoint(anOutPoint);
+		setLoopCount(aCount);
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param aCount the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
-        */
-    public FSSound(int anIdentifier, int aMode, int aCount)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setLoopCount(aCount);
-    }
+	/**
+	 * Constructs and FSSound object specifying how the sound is played, the
+	 * point at which the sound fades in and out, the number of times the sound
+	 * is repeated and the envelopes used to control how the sound is played.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the object that contains the sound
+	 *            data.
+	 * @param aMode
+	 *            how the sound is synchronised when the frames are displayed:
+	 *            Play - do not play the sound if it is already playing and Stop -
+	 *            stop playing the sound.
+	 * @param anInPoint
+	 *            the sample number which the sound fades in to. May be set to
+	 *            zero if the sound does not fade in.
+	 * @param anOutPoint
+	 *            the sample number at which the sound starts to fade. May be
+	 *            set to zero if the sound does not fade out.
+	 * @param aCount
+	 *            the number of times the sound is repeated. May be set to zero
+	 *            if the sound will not be repeated.
+	 * @param anArray
+	 *            an array of FSEnvelope objects that define the levels at which
+	 *            a sound is played over the duration of the sound. May be set
+	 *            to NULL if no envelope is defined.
+	 */
+	public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint,
+					int aCount, ArrayList anArray)
+	{
+		setIdentifier(anIdentifier);
+		setMode(aMode);
+		setInPoint(anInPoint);
+		setOutPoint(anOutPoint);
+		setLoopCount(aCount);
+		setEnvelopes(anArray);
+	}
 
-    /** Constructs and FSSound object specifying how the sound is played and the points at which the sound fades in and out.
+	/**
+	 * Constructs an FSSound object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSSound object.
+	 */
+	public FSSound(FSSound obj)
+	{
+		identifier = obj.identifier;
+		mode = obj.mode;
+		inPoint = obj.inPoint;
+		outPoint = obj.outPoint;
+		loopCount = obj.loopCount;
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param anInPoint the sample number which the sound fades in to. May be set to zero if the sound does not fade in.
-        @param anOutPoint the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
-        */
-    public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setInPoint(anInPoint);
-        setOutPoint(anOutPoint);
-    }
+		envelopes = new ArrayList();
 
-    /** Constructs and FSSound object specifying how the sound is played, the point at which the sound fades in and out and the number of times the sound is repeated.
+		for (Iterator i = obj.envelopes.iterator(); i.hasNext();)
+			envelopes.add(((FSEnvelope) i.next()).clone());
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param anInPoint the sample number which the sound fades in to. May be set to zero if the sound does not fade in.
-        @param anOutPoint the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
-        @param aCount the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
-        */
-    public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint, int aCount)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setInPoint(anInPoint);
-        setOutPoint(anOutPoint);
-        setLoopCount(aCount);
-    }
+	/**
+	 * Add a FSEnvelope object to the array of envelope objects.
+	 * 
+	 * @param anEnvelope
+	 *            an FSEnvelope object.
+	 */
+	public void add(FSEnvelope anEnvelope)
+	{
+		envelopes.add(anEnvelope);
+	}
 
-    /** Constructs and FSSound object specifying how the sound is played, the point at which the sound fades in and out, the number of times the sound is repeated and the envelopes used to control how the sound is played.
+	/**
+	 * Gets the identifier of the sound to the played.
+	 * 
+	 * @return the sound identifier.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-        @param anIdentifier the unique identifier of the object that contains the sound data.
-        @param aMode how the sound is synchronised when the frames are displayed: Play - do not play the sound if it is already playing and Stop - stop playing the sound.
-        @param anInPoint the sample number which the sound fades in to. May be set to zero if the sound does not fade in.
-        @param anOutPoint the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
-        @param aCount the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
-        @param anArray an array of FSEnvelope objects that define the levels at which a sound is played over the duration of the sound. May be set to NULL if no envelope is defined.
-        */
-    public FSSound(int anIdentifier, int aMode, int anInPoint, int anOutPoint, int aCount, ArrayList anArray)
-    {
-        setIdentifier(anIdentifier);
-        setMode(aMode);
-        setInPoint(anInPoint);
-        setOutPoint(anOutPoint);
-        setLoopCount(aCount);
-        setEnvelopes(anArray);
-    }
-    /**
-     * Constructs an FSSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSound object.
-     */
-    public FSSound(FSSound obj)
-    {
-        identifier = obj.identifier;
-        mode = obj.mode;
-        inPoint = obj.inPoint;
-        outPoint = obj.outPoint;
-        loopCount = obj.loopCount;
-        
-        envelopes = new ArrayList();
-        
-        for (Iterator i = obj.envelopes.iterator(); i.hasNext();)
-            envelopes.add(((FSEnvelope)i.next()).clone());        
-    }
+	/**
+	 * Gets the synchronisation mode: SyncNoMultiple - do not play the sound if
+	 * it is already playing and SyncStop - stop playing the sound.
+	 * 
+	 * @return the synchronisation mode of the sound.
+	 */
+	public int getMode()
+	{
+		return mode;
+	}
 
-    /** Add a FSEnvelope object to the array of envelope objects.
+	/**
+	 * Gets the sample number at which the sound reaches full volume when fading
+	 * in.
+	 * 
+	 * @return the in point
+	 */
+	public int getInPoint()
+	{
+		return inPoint;
+	}
 
-        @param anEnvelope an FSEnvelope object.
-        */
-    public void add(FSEnvelope anEnvelope) { envelopes.add(anEnvelope); }
+	/**
+	 * Gets the sample number at which the sound starts to fade.
+	 * 
+	 * @return the out point
+	 */
+	public int getOutPoint()
+	{
+		return outPoint;
+	}
 
-    /** Gets the identifier of the sound to the played.
+	/**
+	 * Gets the number of times the sound will be repeated.
+	 * 
+	 * @return the Loop Count.
+	 */
+	public int getLoopCount()
+	{
+		return loopCount;
+	}
 
-        @return the sound identifier.
-        */
-    public int getIdentifier() { return identifier; }
+	/**
+	 * Gets the array of FSEnvelope objects that control the levels the sound is
+	 * played.
+	 * 
+	 * @return an array of FSEnvelope objects.
+	 */
+	public ArrayList getEnvelopes()
+	{
+		return envelopes;
+	}
 
-    /** Gets the synchronisation mode: SyncNoMultiple - do not play the sound if it is already playing and SyncStop - stop playing the sound.
+	/**
+	 * Sets the identifier of the sound to the played.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier for the sound to be played.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-        @return the synchronisation mode of the sound.
-        */
-    public int getMode() { return mode; }
+	/**
+	 * Sets how the sound is synchronised when the frames are displayed: Start -
+	 * start playing the sound, Continue - do not play the sound if it is
+	 * already playing and Stop - stop playing the sound.
+	 * 
+	 * @param aMode
+	 *            how the sound is played.
+	 */
+	public void setMode(int aMode)
+	{
+		mode = aMode;
+	}
 
-    /**
-        Gets the sample number at which the sound reaches full volume when fading in.
+	/**
+	 * Sets the sample number at which the sound reaches full volume when fading
+	 * in. May be set to zero if the sound does not fade in.
+	 * 
+	 * @param aNumber
+	 *            the sample number which the sound fades in to.
+	 */
+	public void setInPoint(int aNumber)
+	{
+		inPoint = aNumber;
+	}
 
-     @return the in point
-     */
-    public int getInPoint() { return inPoint; }
+	/**
+	 * Sets the sample number at which the sound starts to fade. May be set to
+	 * zero if the sound does not fade out.
+	 * 
+	 * @param aNumber
+	 *            the sample number at which the sound starts to fade.
+	 */
+	public void setOutPoint(int aNumber)
+	{
+		outPoint = aNumber;
+	}
 
-    /**
-        Gets the sample number at which the sound starts to fade.
+	/**
+	 * Sets the number of times the sound is repeated. May be set to zero if the
+	 * sound will not be repeated.
+	 * 
+	 * @param aNumber
+	 *            the number of times the sound is repeated.
+	 */
+	public void setLoopCount(int aNumber)
+	{
+		loopCount = aNumber;
+	}
 
-     @return the out point
-     */
-    public int getOutPoint() { return outPoint; }
+	/**
+	 * Sets the array of FSEnvelope objects that define the levels at which a
+	 * sound is played over the duration of the sound. May be set to null if no
+	 * envelope is defined.
+	 * 
+	 * @param anArray
+	 *            an array of FSEnvelope objects.
+	 */
+	public void setEnvelopes(ArrayList anArray)
+	{
+		envelopes = anArray;
+	}
 
-    /**
-        Gets the number of times the sound will be repeated.
+	public Object clone()
+	{
+		FSSound anObject = (FSSound) super.clone();
 
-     @return the Loop Count.
-     */
-    public int getLoopCount() { return loopCount; }
+		anObject.envelopes = new ArrayList();
 
-    /**
-        Gets the array of FSEnvelope objects that control the levels the sound is played.
+		for (Iterator i = envelopes.iterator(); i.hasNext();)
+			anObject.envelopes.add(((FSEnvelope) i.next()).clone());
 
-     @return an array of FSEnvelope objects.
-     */
-    public ArrayList getEnvelopes() { return envelopes; }
+		return anObject;
+	}
 
-    /** Sets the identifier of the sound to the played.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @param anIdentifier the identifier for the sound to be played.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		if (super.equals(anObject))
+		{
+			FSSound typedObject = (FSSound) anObject;
 
-    /** Sets how the sound is synchronised when the frames are displayed: Start - start playing the sound, Continue - do not play the sound if it is already playing and Stop - stop playing the sound.
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; mode == typedObject.mode;
+			result = result &amp;&amp; inPoint == typedObject.inPoint;
+			result = result &amp;&amp; outPoint == typedObject.outPoint;
+			result = result &amp;&amp; loopCount == typedObject.loopCount;
 
-        @param aMode how the sound is played.
-        */
-    public void setMode(int aMode)
-    {
-        mode = aMode;
-    }
+			if (envelopes != null)
+				result = result &amp;&amp; envelopes.equals(typedObject.envelopes);
+			else
+				result = result &amp;&amp; envelopes == typedObject.envelopes;
+		}
+		return result;
+	}
 
-    /** Sets the sample number at which the sound reaches full volume when fading in. May be set to zero if the sound does not fade in.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param aNumber the sample number which the sound fades in to.
-        */
-    public void setInPoint(int aNumber)
-    {
-        inPoint = aNumber;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;mode&quot;, mode);
+			Transform.append(buffer, &quot;inPoint&quot;, inPoint);
+			Transform.append(buffer, &quot;outPoint&quot;, outPoint);
+			Transform.append(buffer, &quot;loopCount&quot;, loopCount);
+			Transform.append(buffer, &quot;envelopes&quot;, envelopes, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the sample number at which the sound starts to fade. May be set to zero if the sound does not fade out.
+	public int length(FSCoder coder)
+	{
+		boolean _containsInPoint = containsInPoint();
+		boolean _containsOutPoint = containsOutPoint();
+		boolean _containsLoopCount = containsLoopCount();
+		boolean _containsEnvelopes = containsEnvelopes();
 
-     @param aNumber the sample number at which the sound starts to fade.
-     */
-    public void setOutPoint(int aNumber)
-    {
-        outPoint = aNumber;
-    }
+		int length = 3;
 
-    /** Sets the number of times the sound is repeated. May be set to zero if the sound will not be repeated.
+		length += (_containsInPoint) ? 4 : 0;
+		length += (_containsOutPoint) ? 4 : 0;
+		length += (_containsLoopCount) ? 2 : 0;
+		length += (_containsEnvelopes) ? 1 : 0;
+		length += (_containsEnvelopes) ? envelopes.size() * 8 : 0;
 
-        @param aNumber the number of times the sound is repeated.
-        */
-    public void setLoopCount(int aNumber)
-    {
-        loopCount = aNumber;
-    }
+		return length;
+	}
 
-    /** Sets the array of FSEnvelope objects that define the levels at which a sound is played over the duration of the sound. May be set to null if no envelope is defined.
+	public void encode(FSCoder coder)
+	{
+		boolean _containsInPoint = containsInPoint();
+		boolean _containsOutPoint = containsOutPoint();
+		boolean _containsLoopCount = containsLoopCount();
+		boolean _containsEnvelopes = containsEnvelopes();
 
-        @param anArray an array of FSEnvelope objects.
-        */
-    public void setEnvelopes(ArrayList anArray)
-    {
-        envelopes = anArray;
-    }
+		coder.writeWord(identifier, 2);
+		coder.writeBits(mode, 4);
+		coder.writeBits(_containsEnvelopes ? 1 : 0, 1);
+		coder.writeBits(_containsLoopCount ? 1 : 0, 1);
+		coder.writeBits(_containsOutPoint ? 1 : 0, 1);
+		coder.writeBits(_containsInPoint ? 1 : 0, 1);
 
-    public Object clone()
-    {
-        FSSound anObject = (FSSound)super.clone();
-        
-        anObject.envelopes = new ArrayList();
-        
-        for (Iterator i = envelopes.iterator(); i.hasNext();)
-            anObject.envelopes.add(((FSEnvelope)i.next()).clone());
+		if (_containsInPoint)
+			coder.writeWord(inPoint, 4);
+		if (_containsOutPoint)
+			coder.writeWord(outPoint, 4);
+		if (_containsLoopCount)
+			coder.writeWord(loopCount, 2);
+		if (_containsEnvelopes)
+		{
+			coder.writeWord(envelopes.size(), 1);
 
-        return anObject;
-    }
+			for (int i = 0; i &lt; envelopes.size(); i++)
+				((FSTransformObject) envelopes.get(i)).encode(coder);
+		}
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSound typedObject = (FSSound)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; mode == typedObject.mode;
-            result = result &amp;&amp; inPoint == typedObject.inPoint;
-            result = result &amp;&amp; outPoint == typedObject.outPoint;
-            result = result &amp;&amp; loopCount == typedObject.loopCount;
+	public void decode(FSCoder coder)
+	{
+		boolean _containsInPoint = false;
+		boolean _containsOutPoint = false;
+		boolean _containsLoopCount = false;
+		boolean _containsEnvelopes = false;
 
-            if (envelopes != null)
-                result = result &amp;&amp; envelopes.equals(typedObject.envelopes);
-            else
-                result = result &amp;&amp; envelopes == typedObject.envelopes;
-        }
-        return result;
-    }
+		envelopes = new ArrayList();
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;mode&quot;, mode);
-            Transform.append(buffer, &quot;inPoint&quot;, inPoint);
-            Transform.append(buffer, &quot;outPoint&quot;, outPoint);
-            Transform.append(buffer, &quot;loopCount&quot;, loopCount);
-            Transform.append(buffer, &quot;envelopes&quot;, envelopes, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		int envelopeCount = 0;
 
-    public int length(FSCoder coder)
-    {
-        boolean _containsInPoint = containsInPoint();
-        boolean _containsOutPoint = containsOutPoint();
-        boolean _containsLoopCount = containsLoopCount();
-        boolean _containsEnvelopes = containsEnvelopes();
-        
-        int length = 3;
-    
-        length += (_containsInPoint) ? 4 : 0;
-        length += (_containsOutPoint) ? 4 : 0;
-        length += (_containsLoopCount) ? 2 : 0;
-        length += (_containsEnvelopes) ? 1 : 0;
-        length += (_containsEnvelopes) ? envelopes.size()*8 : 0;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsInPoint = containsInPoint();
-        boolean _containsOutPoint = containsOutPoint();
-        boolean _containsLoopCount = containsLoopCount();
-        boolean _containsEnvelopes = containsEnvelopes();
-        
-        coder.writeWord(identifier, 2);
-        coder.writeBits(mode, 4);
-        coder.writeBits(_containsEnvelopes ? 1 : 0, 1);
-        coder.writeBits(_containsLoopCount ? 1 : 0, 1);
-        coder.writeBits(_containsOutPoint ? 1 : 0, 1);
-        coder.writeBits(_containsInPoint ? 1 : 0, 1);
-    
-        if (_containsInPoint)
-            coder.writeWord(inPoint, 4);
-        if (_containsOutPoint)
-            coder.writeWord(outPoint, 4);
-        if (_containsLoopCount)
-            coder.writeWord(loopCount, 2);
-        if (_containsEnvelopes)
-        {
-            coder.writeWord(envelopes.size(), 1);
+		identifier = coder.readWord(2, false);
+		mode = coder.readBits(4, false);
+		_containsEnvelopes = coder.readBits(1, false) != 0 ? true : false;
+		_containsLoopCount = coder.readBits(1, false) != 0 ? true : false;
+		_containsOutPoint = coder.readBits(1, false) != 0 ? true : false;
+		_containsInPoint = coder.readBits(1, false) != 0 ? true : false;
 
-            for (int i=0; i&lt;envelopes.size(); i++)
-                ((FSTransformObject)envelopes.get(i)).encode(coder);
-        }
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        boolean _containsInPoint = false;
-        boolean _containsOutPoint = false;
-        boolean _containsLoopCount = false;
-        boolean _containsEnvelopes = false;
-        
-        envelopes = new ArrayList();
+		if (_containsInPoint)
+			inPoint = coder.readWord(4, false);
 
-        int envelopeCount = 0;
+		if (_containsOutPoint)
+			outPoint = coder.readWord(4, false);
 
-        identifier = coder.readWord(2, false);
-        mode = coder.readBits(4, false);
-        _containsEnvelopes = coder.readBits(1, false) != 0 ? true : false;
-        _containsLoopCount = coder.readBits(1, false) != 0 ? true : false;
-        _containsOutPoint = coder.readBits(1, false) != 0 ? true : false;
-        _containsInPoint = coder.readBits(1, false) != 0 ? true : false;
-    
-        if (_containsInPoint)
-            inPoint = coder.readWord(4, false);
-            
-        if (_containsOutPoint)
-            outPoint = coder.readWord(4, false);
-            
-        if (_containsLoopCount)
-            loopCount = coder.readWord(2, false);
-            
-        if (_containsEnvelopes)
-        {
-            envelopeCount = coder.readWord(1, false);
+		if (_containsLoopCount)
+			loopCount = coder.readWord(2, false);
 
-            for (int i=0; i&lt;envelopeCount; i++)
-                envelopes.add(new FSEnvelope(coder));
-        }
-    }
+		if (_containsEnvelopes)
+		{
+			envelopeCount = coder.readWord(1, false);
 
-    private boolean containsInPoint()
-    {
-        return inPoint != 0;
-    }
+			for (int i = 0; i &lt; envelopeCount; i++)
+				envelopes.add(new FSEnvelope(coder));
+		}
+	}
 
-    private boolean containsOutPoint()
-    {
-        return outPoint != 0;
-    }
-    
-    private boolean containsLoopCount()
-    {
-        return loopCount != 0;
-    }
+	private boolean containsInPoint()
+	{
+		return inPoint != 0;
+	}
 
-    private boolean containsEnvelopes()
-    {
-        return envelopes != null &amp;&amp; envelopes.size() &gt; 0;
-    }
+	private boolean containsOutPoint()
+	{
+		return outPoint != 0;
+	}
+
+	private boolean containsLoopCount()
+	{
+		return loopCount != 0;
+	}
+
+	private boolean containsEnvelopes()
+	{
+		return envelopes != null &amp;&amp; envelopes.size() &gt; 0;
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSoundStreamBlock.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSoundStreamBlock.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSoundStreamBlock.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,147 +31,173 @@
 package com.flagstone.transform;
 
 /**
-FSSoundStreamBlock contains the sound data being streamed to the Flash Player. 
- 
-&lt;p&gt;Streaming sounds are played in tight synchronisation with one FSSoundStreamBlock 
-object defining the sound for each frame displayed in a movie.&lt;/p&gt;
+ * FSSoundStreamBlock contains the sound data being streamed to the Flash
+ * Player.
+ * 
+ * &lt;p&gt;
+ * Streaming sounds are played in tight synchronisation with one
+ * FSSoundStreamBlock object defining the sound for each frame displayed in a
+ * movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;soundData&lt;/td&gt;
+ * &lt;td&gt;The encoded sound data for a single frame in a movie. The format for the
+ * sound is defined by an FSSoundStreamHead object. Sounds may be encoded using
+ * the uncompressed PCM (big or little endian byte order), compressed ADPCM,
+ * compressed MP3 or NELLYMOSER formats.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * When a streaming sound is played if the Flash Player cannot render the frames
+ * fast enough to maintain synchronisation with the sound being played then
+ * frames will be skipped. Normally the player will reduce the frame rate so
+ * every frame of a movie is played.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamBlock class represents the SoundStreamBlock tag from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1 with support for Uncompressed PCM encoded sounds (both Little-Endian and
+ * Big-Endian formats) and the compressed ADPCM format. Support for MP3 was
+ * added in Flash 3. The Nellymoser Asao format was added in Flash 6.
+ * &lt;/p&gt;
+ */
+public class FSSoundStreamBlock extends FSMovieObject
+{
+	private byte[] soundData = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSSoundStreamBlock object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSoundStreamBlock(FSCoder coder)
+	{
+		super(FSMovieObject.SoundStreamBlock);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamBlock specifying the sound data in the format
+	 * defined by a preceding FSSoundStreamHead or FSSoundStreamHead2 object.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the sound data.
+	 */
+	public FSSoundStreamBlock(byte[] bytes)
+	{
+		super(FSMovieObject.SoundStreamBlock);
+		setSoundData(bytes);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamBlock_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSSoundStreamBlock object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSSoundStreamBlock object.
+	 */
+	public FSSoundStreamBlock(FSSoundStreamBlock obj)
+	{
+		super(obj);
+		soundData = Transform.clone(obj.soundData);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamBlock_1&quot;&gt;soundData&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded sound data for a single frame in a movie. The format for the sound 
-is defined by an FSSoundStreamHead object. Sounds may be encoded using the uncompressed 
-PCM (big or little endian byte order), compressed ADPCM, compressed MP3 or NELLYMOSER
-formats.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the sound data in the format defined by a preceding
+	 * FSSoundStreamHead or FSSoundStreamHead2 object.
+	 * 
+	 * @return the sound data.
+	 */
+	public byte[] getSoundData()
+	{
+		return soundData;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the sound data.
+	 * 
+	 * @param bytes
+	 *            an array of bytes containing the sound data.
+	 */
+	public void setSoundData(byte[] bytes)
+	{
+		soundData = bytes;
+	}
 
-&lt;p&gt;When a streaming sound is played if the Flash Player cannot render the frames fast 
-enough to maintain synchronisation with the sound being played then frames will be 
-skipped. Normally the player will reduce the frame rate so every frame of a movie 
-is played.&lt;/p&gt;
+	public Object clone()
+	{
+		FSSoundStreamBlock anObject = (FSSoundStreamBlock) super.clone();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		anObject.soundData = Transform.clone(soundData);
 
-&lt;p&gt;The FSSoundStreamBlock class represents the SoundStreamBlock tag from the Macromedia 
-Flash (SWF) File Format Specification. It was introduced in Flash 1 with support for 
-Uncompressed PCM encoded sounds (both Little-Endian and Big-Endian formats) and the 
-compressed ADPCM format. Support for MP3 was added in Flash 3. The Nellymoser Asao
-format was added in Flash 6.&lt;/p&gt;
- */
-public class FSSoundStreamBlock extends FSMovieObject
-{
-    private byte[] soundData = null;
-    
-    /**
-     * Construct an FSSoundStreamBlock object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSoundStreamBlock(FSCoder coder)
-    {
-        super(FSMovieObject.SoundStreamBlock);
-        decode(coder);
-    }
-    /** Constructs an FSSoundStreamBlock specifying the sound data in the format defined by a preceding FSSoundStreamHead or FSSoundStreamHead2 object.
+		return anObject;
+	}
 
-        @param bytes an array of bytes containing the sound data.
-        */
-    public FSSoundStreamBlock(byte[] bytes)
-    {
-        super(FSMovieObject.SoundStreamBlock);
-        setSoundData(bytes);
-    }
-    /**
-     * Constructs an FSSoundStreamBlock object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSSoundStreamBlock object.
-     */
-    public FSSoundStreamBlock(FSSoundStreamBlock obj)
-    {
-        super(obj);
-        soundData = Transform.clone(obj.soundData);
-    }    
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Gets the sound data in the format defined by a preceding FSSoundStreamHead or FSSoundStreamHead2 object.
+		if (super.equals(anObject))
+		{
+			FSSoundStreamBlock typedObject = (FSSoundStreamBlock) anObject;
 
-        @return the sound data.
-        */
-    public byte[] getSoundData() { return soundData; }
+			result = Transform.equals(soundData, typedObject.soundData);
+		}
+		return result;
+	}
 
-    /** Sets the sound data.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param bytes an array of bytes containing the sound data.
-        */
-    public void setSoundData(byte[] bytes)
-    {
-        soundData = bytes;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;soundData&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public Object clone()
-    {
-        FSSoundStreamBlock anObject = (FSSoundStreamBlock)super.clone();
-        
-        anObject.soundData = Transform.clone(soundData);
-        
-        return anObject;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSoundStreamBlock typedObject = (FSSoundStreamBlock)anObject;
-            
-            result = Transform.equals(soundData, typedObject.soundData);
-        }
-        return result;
-    }
+		length += soundData.length;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;soundData&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		return length;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += soundData.length;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(soundData);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        soundData = new byte[length];
-        coder.readBytes(soundData);
-        coder.endObject(name());
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(soundData);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		soundData = new byte[length];
+		coder.readBytes(soundData);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSoundStreamHead.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSoundStreamHead.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSoundStreamHead.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,465 +31,569 @@
 package com.flagstone.transform;
 
 /**
-FSSoundStreamHead defines the format of a streaming sound, identifying the encoding scheme, 
-the rate at which the sound will be played and the size of the decoded samples. 
- 
-&lt;p&gt;The actual sound is streamed used the FSSoundStreamBlock class which contains 
-the data for each frame in a movie.&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_1&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little0endian byte order), 
-FSSound.ADPCM, or FSSound.NATIVE_PCM (Big-endian or Little-Endian byte order depending
-on the platform where the sound was generated.).&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_2&quot;&gt;playbackRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_3&quot;&gt;playbackSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in an uncompressed sample when the sound is played, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_4&quot;&gt;playbackChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_5&quot;&gt;streamRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The rate at which the streaming sound was samples - 5512, 11025, 22050 or 44100 Hz.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_6&quot;&gt;streamSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_7&quot;&gt;streamChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of channels: 1 = mono or 2 = stereo, in the streaming sound&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_8&quot;&gt;streamSampleCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The average number of samples in each FSSoundStreamBlock object.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_9&quot;&gt;latency&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Latency defines the number of samples to skip only when playing sounds encoded 
-with the MP3 format.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;Four encoded formats for the sound data are supported:&lt;/p&gt;
-
-&lt;ul&gt;
-&lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes. For two-byte samples the byte order is dependent on the platform on which the Flash Player is hosted. Sounds created on a platform which supports big-endian byte order will not be played correctly when listened to on a platform which supports little-endian byte order.&lt;/li&gt;
-&lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes with 
-the latter presented in Little-Endian byte order. This ensures that sounds can be played across different platforms.&lt;/li&gt;
-&lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded and compressed
-by comparing the difference between successive sound sample which dramatically reduces
-the size of the encoded sound when compared to the uncompressed PCM formats. Use this 
-format whenever possible.&lt;/li&gt;
-&lt;li&gt;MP3 - MPEG Layer 3 encoded sound.&lt;/li&gt;
-&lt;/ul&gt;
-
-&lt;p&gt;Constants representing the different formats are defined in the FSSound class.&lt;/p&gt;
-
-&lt;p&gt;When a stream sound is played if the Flash Player cannot render the frames fast enough 
-to maintain synchronisation with the sound being played then frames will be skipped. 
-Normally the player will reduce the frame rate so every frame of a movie is played. 
-The different sets of attributes that identify how the sound will be played compared 
-to the way it was encoded allows the Player more control over how the animation is 
-rendered. Reducing the resolution or playback rate can improve synchronisation with 
-the frames displayed.&lt;/p&gt;
-
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSSoundStreamHead class represents the SoundStreamHead structure from the 
-Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1.&lt;/p&gt;
+ * FSSoundStreamHead defines the format of a streaming sound, identifying the
+ * encoding scheme, the rate at which the sound will be played and the size of
+ * the decoded samples.
+ * 
+ * &lt;p&gt;
+ * The actual sound is streamed used the FSSoundStreamBlock class which contains
+ * the data for each frame in a movie.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;format&lt;/td&gt;
+ * &lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little0endian byte
+ * order), FSSound.ADPCM, or FSSound.NATIVE_PCM (Big-endian or Little-Endian
+ * byte order depending on the platform where the sound was generated.).&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackRate&lt;/td&gt;
+ * &lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackSampleSize&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in an uncompressed sample when the sound is played,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackChannels&lt;/td&gt;
+ * &lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamRate&lt;/td&gt;
+ * &lt;td&gt;The rate at which the streaming sound was samples - 5512, 11025, 22050
+ * or 44100 Hz.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleSize&lt;/td&gt;
+ * &lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamChannels&lt;/td&gt;
+ * &lt;td&gt;The number of channels: 1 = mono or 2 = stereo, in the streaming sound&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleCount&lt;/td&gt;
+ * &lt;td&gt;The average number of samples in each FSSoundStreamBlock object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;latency&lt;/td&gt;
+ * &lt;td&gt;Latency defines the number of samples to skip only when playing sounds
+ * encoded with the MP3 format.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Four encoded formats for the sound data are supported:
+ * &lt;/p&gt;
+ * 
+ * &lt;ul&gt;
+ * &lt;li&gt;NATIVE_PCM - uncompressed Pulse Code Modulated: samples are either 1 or
+ * 2 bytes. For two-byte samples the byte order is dependent on the platform on
+ * which the Flash Player is hosted. Sounds created on a platform which supports
+ * big-endian byte order will not be played correctly when listened to on a
+ * platform which supports little-endian byte order.&lt;/li&gt;
+ * &lt;li&gt;PCM - uncompressed Pulse Code Modulated: samples are either 1 or 2 bytes
+ * with the latter presented in Little-Endian byte order. This ensures that
+ * sounds can be played across different platforms.&lt;/li&gt;
+ * &lt;li&gt;ADPCM - compressed ADaptive Pulse Code Modulated: samples are encoded
+ * and compressed by comparing the difference between successive sound sample
+ * which dramatically reduces the size of the encoded sound when compared to the
+ * uncompressed PCM formats. Use this format whenever possible.&lt;/li&gt;
+ * &lt;li&gt;MP3 - MPEG Layer 3 encoded sound.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * &lt;p&gt;
+ * Constants representing the different formats are defined in the FSSound
+ * class.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When a stream sound is played if the Flash Player cannot render the frames
+ * fast enough to maintain synchronisation with the sound being played then
+ * frames will be skipped. Normally the player will reduce the frame rate so
+ * every frame of a movie is played. The different sets of attributes that
+ * identify how the sound will be played compared to the way it was encoded
+ * allows the Player more control over how the animation is rendered. Reducing
+ * the resolution or playback rate can improve synchronisation with the frames
+ * displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamHead class represents the SoundStreamHead structure from the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 1.
+ * &lt;/p&gt;
  */
 public class FSSoundStreamHead extends FSMovieObject
 {
-    private int format = FSSound.ADPCM;
+	private int format = FSSound.ADPCM;
+	private int playbackRate = 5512;
+	private int playbackChannels = 1;
+	private int playbackSampleSize = 16;
+	private int streamRate = 5512;
+	private int streamChannels = 1;
+	private int streamSampleSize = 16;
+	private int streamSampleCount = 0;
+	private int latency = 0;
 
-    private int playbackRate = 5512;
-    private int playbackChannels = 1;
-    private int playbackSampleSize = 16;
+	/**
+	 * Construct an FSSoundStreamHead object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSoundStreamHead(FSCoder coder)
+	{
+		super(FSMovieObject.SoundStreamHead);
+		decode(coder);
+	}
 
-    private int streamRate = 5512;
-    private int streamChannels = 1;
-    private int streamSampleSize = 16;
-    private int streamSampleCount = 0;
-    private int latency = 0;
+	/**
+	 * Constructs an FSSoundStreamHead object specifying all the parameters
+	 * required to define the sound.
+	 * 
+	 * @param playRate
+	 *            the recommended rate for playing the sound, either 5512,
+	 *            11025, 22050 or 44100 Hz.
+	 * @param playChannels
+	 *            The recommended number of playback channels: 1 = mono or 2 =
+	 *            stereo.
+	 * @param playSize
+	 *            the recommended uncompressed sample size for playing the
+	 *            sound, either 1 or 2 bytes.
+	 * @param streamingRate
+	 *            the rate at which the sound was sampled, either 5512, 11025,
+	 *            22050 or 44100 Hz.
+	 * @param streamingChannels
+	 *            the number of channels: 1 = mono or 2 = stereo.
+	 * @param streamingSize
+	 *            the sample size for the sound in bytes, either 1 or 2.
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 * @param latency
+	 *            defines the number of samples to skip only when playing sounds
+	 *            encoded with the MP3 format.
+	 */
+	public FSSoundStreamHead(int playRate, int playChannels, int playSize,
+								int streamingRate, int streamingChannels,
+								int streamingSize, int streamingCount,
+								int latency)
+	{
+		super(FSMovieObject.SoundStreamHead);
 
-    /**
-     * Construct an FSSoundStreamHead object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSoundStreamHead(FSCoder coder)
-    {
-        super(FSMovieObject.SoundStreamHead);
-        decode(coder);
-    }
-    /** Constructs an FSSoundStreamHead object specifying all the parameters required to define the sound.
+		setPlaybackRate(playRate);
+		setPlaybackChannels(playChannels);
+		setPlaybackSampleSize(playSize);
 
-        @param playRate the recommended rate for playing the sound, either 5512, 11025, 22050 or 44100 Hz.
-        @param playChannels The recommended number of playback channels: 1 = mono or 2 = stereo.
-        @param playSize the recommended uncompressed sample size for playing the sound, either 1 or 2 bytes.
-        @param streamingRate the rate at which the sound was sampled, either 5512, 11025, 22050 or 44100 Hz.
-        @param streamingChannels the number of channels: 1 = mono or 2 = stereo.
-        @param streamingSize the sample size for the sound in bytes, either 1 or 2.
-        @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-        @param latency defines the number of samples to skip only when playing sounds encoded with the MP3 format.
-        */
-    public FSSoundStreamHead(int playRate, int playChannels, int playSize, int streamingRate, int streamingChannels, int streamingSize, int streamingCount, int latency)
-    {
-        super(FSMovieObject.SoundStreamHead);
-        
-        setPlaybackRate(playRate);
-        setPlaybackChannels(playChannels);
-        setPlaybackSampleSize(playSize);
+		setStreamRate(streamingRate);
+		setStreamChannels(streamingChannels);
+		setStreamSampleSize(streamingSize);
+		setStreamSampleCount(streamingCount);
+		setLatency(latency);
+	}
 
-        setStreamRate(streamingRate);
-        setStreamChannels(streamingChannels);
-        setStreamSampleSize(streamingSize);
-        setStreamSampleCount(streamingCount);
-        setLatency(latency);
-    }
-    /**
-     * Constructs an FSSoundStreamHead object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSSoundStreamHead object.
-     */
-    public FSSoundStreamHead(FSSoundStreamHead obj)
-    {
-        super(obj);
-        format = obj.format;
-        playbackRate = obj.playbackRate;
-        playbackChannels = obj.playbackChannels;
-        playbackSampleSize = obj.playbackSampleSize;
-        
-        streamRate = obj.streamRate;
-        streamChannels = obj.streamChannels;
-        streamSampleSize = obj.streamSampleSize;
-        streamSampleCount = obj.streamSampleCount;
-        latency = obj.latency;
-    }
-    
-    /** Gets the streaming sound format. For the FSSoundStreamHead class supports 
-     * ADPCM or MP3 encoded sound data.
-    
-        @return the format used to play the sound.
-        */
-    public int getFormat()
-    {
-        return format;
-    }
+	/**
+	 * Constructs an FSSoundStreamHead object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSSoundStreamHead object.
+	 */
+	public FSSoundStreamHead(FSSoundStreamHead obj)
+	{
+		super(obj);
+		format = obj.format;
+		playbackRate = obj.playbackRate;
+		playbackChannels = obj.playbackChannels;
+		playbackSampleSize = obj.playbackSampleSize;
 
-    /** Sets the format for the streaming sound.
+		streamRate = obj.streamRate;
+		streamChannels = obj.streamChannels;
+		streamSampleSize = obj.streamSampleSize;
+		streamSampleCount = obj.streamSampleCount;
+		latency = obj.latency;
+	}
 
-        @param encoding the compression format for the sound data, either 
-        FSSound.ADPCM or FSSound.MP3.
-    */
-    public void setFormat(int encoding)
-    {
-        format = encoding;
-    }
+	/**
+	 * Gets the streaming sound format. For the FSSoundStreamHead class supports
+	 * ADPCM or MP3 encoded sound data.
+	 * 
+	 * @return the format used to play the sound.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-   /** Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	/**
+	 * Sets the format for the streaming sound.
+	 * 
+	 * @param encoding
+	 *            the compression format for the sound data, either
+	 *            FSSound.ADPCM or FSSound.MP3.
+	 */
+	public void setFormat(int encoding)
+	{
+		format = encoding;
+	}
 
-        @return the rate at which the sound will be played back.
-        */
-    public int getPlaybackRate() { return playbackRate; }
+	/**
+	 * Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	 * 
+	 * @return the rate at which the sound will be played back.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-    /** Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	/**
+	 * Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @return the number of channels for the sound playback.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-        @return the number of channels for the sound playback.
-        */
-    public int getPlaybackChannels() { return playbackChannels; }
+	/**
+	 * Gets the recommended playback sample range in bytes: 1 or 2.
+	 * 
+	 * @return the sample size used to play back the sound.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-    /** Gets the recommended playback sample range in bytes: 1 or 2.
+	/**
+	 * Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming
+	 * sound.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public float getStreamRate()
+	{
+		return streamRate;
+	}
 
-        @return the sample size used to play back the sound.
-        */
-    public int getPlaybackSampleSize() { return playbackSampleSize; }
+	/**
+	 * Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	 * 
+	 * @return the number of channels in the sound.
+	 */
+	public int getStreamChannels()
+	{
+		return streamChannels;
+	}
 
-    /** Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming sound.
+	/**
+	 * Gets the sample size in bytes: 1 or 2 in the streaming sound.
+	 * 
+	 * @return the sample size.
+	 */
+	public int getStreamSampleSize()
+	{
+		return streamSampleSize;
+	}
 
-        @return the rate at which the sound was sampled.
-        */
-    public float getStreamRate() { return streamRate; }
+	/**
+	 * Gets the average number of samples in each stream block following.
+	 * 
+	 * @return the number of sound samples in each following FSSoundStreamBlock
+	 *         object.
+	 */
+	public int getStreamSampleCount()
+	{
+		return streamSampleCount;
+	}
 
-    /** Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	/**
+	 * Sets the recommended playback rate in Hz. Must be either: 5512, 11025,
+	 * 22050 or 44100.
+	 * 
+	 * @param playRate
+	 *            the recommended rate for playing the sound.
+	 */
+	public void setPlaybackRate(int playRate)
+	{
+		playbackRate = playRate;
+	}
 
-        @return the number of channels in the sound.
-        */
-    public int getStreamChannels() { return streamChannels; }
+	/**
+	 * Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @param aNumber
+	 *            the recommended number of playback channels.
+	 */
+	public void setPlaybackChannels(int aNumber)
+	{
+		playbackChannels = aNumber;
+	}
 
-    /** Gets the sample size in bytes: 1 or 2 in the streaming sound.
+	/**
+	 * Sets the recommended playback sample size in bytes. Must be wither 1 or
+	 * 2.
+	 * 
+	 * @param playSize
+	 *            the recommended sample size for playing the sound.
+	 */
+	public void setPlaybackSampleSize(int playSize)
+	{
+		playbackSampleSize = playSize;
+	}
 
-        @return the sample size.
-        */
-    public int getStreamSampleSize() { return streamSampleSize; }
+	/**
+	 * Sets the sample rate in Hz for the streaming sound. Must be either: 5512,
+	 * 11025, 22050 or 44100.
+	 * 
+	 * @param streamingRate
+	 *            the rate at which the streaming sound was sampled.
+	 */
+	public void setStreamRate(int streamingRate)
+	{
+		streamRate = streamingRate;
+	}
 
-    /** Gets the average number of samples in each stream block following.
+	/**
+	 * Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+	 * 
+	 * @param streamingChannels
+	 *            the number of channels in the streaming sound.
+	 */
+	public void setStreamChannels(int streamingChannels)
+	{
+		streamChannels = streamingChannels;
+	}
 
-        @return the number of sound samples in each following FSSoundStreamBlock object.
-        */
-    public int getStreamSampleCount() { return streamSampleCount; }
+	/**
+	 * Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+	 * 
+	 * @param streamingSize
+	 *            the sample size for the sound.
+	 */
+	public void setStreamSampleSize(int streamingSize)
+	{
+		streamSampleSize = streamingSize;
+	}
 
-    /** Sets the recommended playback rate in Hz. Must be either: 5512, 11025, 22050 or 44100.
+	/**
+	 * Sets the number of samples in each stream block.
+	 * 
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 */
+	public void setStreamSampleCount(int streamingCount)
+	{
+		streamSampleCount = streamingCount;
+	}
 
-        @param playRate the recommended rate for playing the sound.
-        */
-    public void setPlaybackRate(int playRate)
-    {
-        playbackRate = playRate;
-    }
+	/**
+	 * For MP3 encoded sounds, returns the number of samples to skip when
+	 * starting to play a sound.
+	 * 
+	 * @return the number of samples skipped in an MP3 encoded sound Returns 0
+	 *         for other sound formats.
+	 */
+	public int getLatency()
+	{
+		return latency;
+	}
 
-    /** Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+	/**
+	 * Set the number of samples to skip when starting to play an MP3 encoded
+	 * sound.
+	 * 
+	 * @param latency
+	 *            the number of samples to be skipped in an MP3 encoded sound
+	 *            should be 0 for other sound formats.
+	 */
+	public void setLatency(int latency)
+	{
+		this.latency = latency;
+	}
 
-        @param aNumber the recommended number of playback channels.
-        */
-    public void setPlaybackChannels(int aNumber)
-    {
-        playbackChannels = aNumber;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /** Sets the recommended playback sample size in bytes. Must be wither 1 or 2.
+		if (super.equals(anObject))
+		{
+			FSSoundStreamHead typedObject = (FSSoundStreamHead) anObject;
 
-        @param playSize the recommended sample size for playing the sound.
-        */
-    public void setPlaybackSampleSize(int playSize)
-    {
-        playbackSampleSize = playSize;
-    }
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result &amp;&amp; streamRate == typedObject.streamRate;
+			result = result &amp;&amp; streamChannels == typedObject.streamChannels;
+			result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
+			result = result
+							&amp;&amp; streamSampleCount == typedObject.streamSampleCount;
+			result = result &amp;&amp; latency == typedObject.latency;
+		}
+		return result;
+	}
 
-    /** Sets the sample rate in Hz for the streaming sound. Must be either: 5512, 11025, 22050 or 44100.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param streamingRate the rate at which the streaming sound was sampled.
-        */
-    public void setStreamRate(int streamingRate)
-    {
-        streamRate = streamingRate;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;format&quot;, format);
+			Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
+			Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
+			Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
+			Transform.append(buffer, &quot;streamRate&quot;, streamRate);
+			Transform.append(buffer, &quot;streamChannels&quot;, streamChannels);
+			Transform.append(buffer, &quot;streamSampleSize&quot;, streamSampleSize);
+			Transform.append(buffer, &quot;streamSampleCount&quot;, streamSampleCount);
+			Transform.append(buffer, &quot;latency&quot;, latency);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param streamingChannels the number of channels in the streaming sound.
-        */
-    public void setStreamChannels(int streamingChannels)
-    {
-        streamChannels = streamingChannels;
-    }
+		length += 4;
 
-    /** Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			length += 2;
 
-        @param streamingSize the sample size for the sound.
-        */
-    public void setStreamSampleSize(int streamingSize)
-    {
-        streamSampleSize = streamingSize;
-    }
+		return length;
+	}
 
-    /** Sets the number of samples in each stream block.
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-        @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-        */
-    public void setStreamSampleCount(int streamingCount)
-    {
-        streamSampleCount = streamingCount;
-    }
+		coder.writeBits(0, 4);
 
-    /**
-     * For MP3 encoded sounds, returns the number of samples to skip when starting to play a sound.
-     *
-     * @return the number of samples skipped in an MP3 encoded sound Returns 0 for other sound formats.
-     */
-    public int getLatency() 
-    { 
-        return latency; 
-    }
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
 
-    /**
-     * Set the number of samples to skip when starting to play an MP3 encoded sound.
-     *
-     * @param latency the number of samples to be skipped in an MP3 encoded sound should be 0 for other sound formats.
-     */
-    public void setLatency(int latency)
-    {
-        this.latency = latency;
-    }
+		coder.writeBits(format, 4);
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSSoundStreamHead typedObject = (FSSoundStreamHead)anObject;
-            
-            result = format == typedObject.format;
-            result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-            result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-            result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-            result = result &amp;&amp; streamRate == typedObject.streamRate;
-            result = result &amp;&amp; streamChannels == typedObject.streamChannels;
-            result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
-            result = result &amp;&amp; streamSampleCount == typedObject.streamSampleCount;
-            result = result &amp;&amp; latency == typedObject.latency;
-        }
-        return result;
-    }
+		switch (streamRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(streamSampleSize - 1, 1);
+		coder.writeBits(streamChannels - 1, 1);
+		coder.writeWord(streamSampleCount, 2);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;format&quot;, format);
-            Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-            Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-            Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-            Transform.append(buffer, &quot;streamRate&quot;, streamRate);
-            Transform.append(buffer, &quot;streamChannels&quot;, streamChannels);
-            Transform.append(buffer, &quot;streamSampleSize&quot;, streamSampleSize);
-            Transform.append(buffer, &quot;streamSampleCount&quot;, streamSampleCount);
-            Transform.append(buffer, &quot;latency&quot;, latency);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			coder.writeWord(latency, 2);
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 4;
-        
-        if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-            length += 2;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-         coder.writeBits(0, 4);
+		coder.endObject(name());
+	}
 
-        switch (playbackRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(playbackSampleSize-1, 1);
-        coder.writeBits(playbackChannels-1, 1);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        coder.writeBits(format, 4);
+		coder.readBits(4, false);
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
 
-        switch (streamRate)
-        {
-            case 5512:
-                coder.writeBits(0, 2);
-                break;
-            case 11025:
-                coder.writeBits(1, 2);
-                break;
-            case 22050:
-                coder.writeBits(2, 2);
-                break;
-            case 44100:
-                coder.writeBits(3, 2);
-                break;
-        }
-        coder.writeBits(streamSampleSize-1, 1);
-        coder.writeBits(streamChannels-1, 1);
-        coder.writeWord(streamSampleCount, 2);
+		format = coder.readBits(4, false);
 
-        if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-            coder.writeWord(latency, 2);
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				streamRate = 5512;
+				break;
+			case 1:
+				streamRate = 11025;
+				break;
+			case 2:
+				streamRate = 22050;
+				break;
+			case 3:
+				streamRate = 44100;
+				break;
+		}
+		streamSampleSize = coder.readBits(1, false) + 1;
+		streamChannels = coder.readBits(1, false) + 1;
+		streamSampleCount = coder.readWord(2, false);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        coder.readBits(4, false);
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                playbackRate = 5512;
-                break;
-            case 1:
-                playbackRate = 11025;
-                break;
-            case 2:
-                playbackRate = 22050;
-                break;
-            case 3:
-                playbackRate = 44100;
-                break;
-        }
-        playbackSampleSize = coder.readBits(1, false)+1;
-        playbackChannels = coder.readBits(1, false)+1;
+		if (length == 6 &amp;&amp; format == FSSound.MP3)
+			latency = coder.readWord(2, true);
 
-        format = coder.readBits(4, false);
-
-        switch (coder.readBits(2, false))
-        {
-            case 0:
-                streamRate = 5512;
-                break;
-            case 1:
-                streamRate = 11025;
-                break;
-            case 2:
-                streamRate = 22050;
-                break;
-            case 3:
-                streamRate = 44100;
-                break;
-        }
-        streamSampleSize = coder.readBits(1, false)+1;
-        streamChannels = coder.readBits(1, false)+1;
-        streamSampleCount = coder.readWord(2, false);
-        
-        if (length == 6 &amp;&amp; format == FSSound.MP3)
-            latency = coder.readWord(2, true);
-
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSSoundStreamHead2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSSoundStreamHead2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSSoundStreamHead2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,471 +31,569 @@
 package com.flagstone.transform;
 
 /**
-FSSoundStreamHead2 defines an sound compressed using different compression formats
-that is streamed in tight synchronisation with the movie being played.
-
-&lt;p&gt;The FSSoundStreamHead2 class defines how the streaming sound is played. Objects 
-of the FSSoundStreamBlock class contains the sound data.&lt;/P&gt;
-
-&lt;p&gt;When a stream sound is played if the Flash Player cannot render the frames fast 
-enough to maintain synchronisation with the sound being played then frames will 
-be skipped. Normally the player will reduce the frame rate so every frame of a 
-movie is played.&lt;/p&gt;
-
-&lt;p&gt;To define the stream sound the parameters for and sampled sound and how it will 
-be played back must be specified:&lt;/p&gt;
-
-&lt;table class=&quot;datasheet&quot;&gt;
-
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
-
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_1&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little-Endian byte order), 
-FSSound.ADPCM, FSSound.NATIVE_PCM (Big-Endian or Little-Endian byte order 
-depending on the platform where the sound was created), FSSound.MP3 or 
-FSSound.NELLYMOSER&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_2&quot;&gt;playbackRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_3&quot;&gt;playbackSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of bytes in an uncompressed sample when the sound is played, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_4&quot;&gt;playbackChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_5&quot;&gt;streamRate&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The stream sampling rate - 5512, 11025, 22050 or 44100 Hz&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_6&quot;&gt;streamSampleSize&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes, either 1 or 2.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_7&quot;&gt;streamChannels&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of channels: 1 = mono or 2 = stereo in the streaming sound&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_8&quot;&gt;streamSampleCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The average number of samples in each sound stream block.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSSoundStreamHead2_9&quot;&gt;latency&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Latency defines the number of samples to skip only when playing sounds encoded 
-with the MP3 format.&lt;/td&gt;
-&lt;/tr&gt;
-
-&lt;/table&gt;
-
-&lt;p&gt;FSSoundStreamHead2 allows way the sound is played to differ from the way it is 
-encoded and streamed to the player. This allows the Player more control over how 
-the animation is rendered. Reducing the resolution or playback rate can improve 
-synchronisation with the frames displayed.&lt;/p&gt;
-
-&lt;b&gt;History&lt;/b&gt;
-
-&lt;p&gt;The FSSoundStreamHead2 class represents the SoundStreamHead structure from the 
-Flash specification. It was introduced in Flash 3. Support for the Nellymoser Asao
-format was added in Flash 6.&lt;/p&gt;
+ * FSSoundStreamHead2 defines an sound compressed using different compression
+ * formats that is streamed in tight synchronisation with the movie being
+ * played.
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamHead2 class defines how the streaming sound is played.
+ * Objects of the FSSoundStreamBlock class contains the sound data.
+ * &lt;/P&gt;
+ * 
+ * &lt;p&gt;
+ * When a stream sound is played if the Flash Player cannot render the frames
+ * fast enough to maintain synchronisation with the sound being played then
+ * frames will be skipped. Normally the player will reduce the frame rate so
+ * every frame of a movie is played.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * To define the stream sound the parameters for and sampled sound and how it
+ * will be played back must be specified:
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;format&lt;/td&gt;
+ * &lt;td&gt;The format of the encoded sound data - FSSound.PCM (Little-Endian byte
+ * order), FSSound.ADPCM, FSSound.NATIVE_PCM (Big-Endian or Little-Endian byte
+ * order depending on the platform where the sound was created), FSSound.MP3 or
+ * FSSound.NELLYMOSER&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackRate&lt;/td&gt;
+ * &lt;td&gt;The recommended playback rate in Hertz - 5512, 11025, 22050 or 44100.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackSampleSize&lt;/td&gt;
+ * &lt;td&gt;The number of bytes in an uncompressed sample when the sound is played,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;playbackChannels&lt;/td&gt;
+ * &lt;td&gt;The recommended number of playback channels: 1 = mono or 2 = stereo.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamRate&lt;/td&gt;
+ * &lt;td&gt;The stream sampling rate - 5512, 11025, 22050 or 44100 Hz&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleSize&lt;/td&gt;
+ * &lt;td&gt;The size of an uncompressed sample in the streaming sound in bytes,
+ * either 1 or 2.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamChannels&lt;/td&gt;
+ * &lt;td&gt;The number of channels: 1 = mono or 2 = stereo in the streaming sound&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;streamSampleCount&lt;/td&gt;
+ * &lt;td&gt;The average number of samples in each sound stream block.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;latency&lt;/td&gt;
+ * &lt;td&gt;Latency defines the number of samples to skip only when playing sounds
+ * encoded with the MP3 format.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSSoundStreamHead2 allows way the sound is played to differ from the way it
+ * is encoded and streamed to the player. This allows the Player more control
+ * over how the animation is rendered. Reducing the resolution or playback rate
+ * can improve synchronisation with the frames displayed.
+ * &lt;/p&gt;
+ * 
+ * &lt;b&gt;History&lt;/b&gt;
+ * 
+ * &lt;p&gt;
+ * The FSSoundStreamHead2 class represents the SoundStreamHead structure from
+ * the Flash specification. It was introduced in Flash 3. Support for the
+ * Nellymoser Asao format was added in Flash 6.
+ * &lt;/p&gt;
  */
 public class FSSoundStreamHead2 extends FSMovieObject
 {
-    private int format = FSSound.ADPCM;
+	private int format = FSSound.ADPCM;
+	private int playbackRate = 5512;
+	private int playbackChannels = 1;
+	private int playbackSampleSize = 16;
+	private int streamRate = 5512;
+	private int streamChannels = 1;
+	private int streamSampleSize = 16;
+	private int streamSampleCount = 0;
+	private int latency = 0;
 
-    private int playbackRate = 5512;
-    private int playbackChannels = 1;
-    private int playbackSampleSize = 16;
+	/*
+	 * The following variable is used to preserve the value of a reserved field
+	 * when decoding then encoding an existing Flash file. Macromedia's file
+	 * file format specification states that this field is always zero - it is
+	 * not, so this is used to preserve the value in case it is implementing an
+	 * undocumented feature.
+	 */
+	private int _reserved = 0;
 
-    private int streamRate = 5512;
-    private int streamChannels = 1;
-    private int streamSampleSize = 16;
-    private int streamSampleCount = 0;
-    private int latency = 0;
-    
-    /*
-     * The following variable is used to preserve the value of a reserved field
-     * when decoding then encoding an existing Flash file. Macromedia's file 
-     * file format specification states that this field is always zero - it is
-     * not, so this is used to preserve the value in case it is implementing 
-     * an undocumented feature.
-     */
-    private int _reserved = 0;
+	/**
+	 * Construct an FSSoundStreamHead2 object, initialising it with values
+	 * decoded from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSSoundStreamHead2(FSCoder coder)
+	{
+		super(SoundStreamHead2);
+		decode(coder);
+	}
 
-    /**
-     * Construct an FSSoundStreamHead2 object, initalizing it with values 
-     * decoded from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSSoundStreamHead2(FSCoder coder)
-    {
-        super(SoundStreamHead2);
-        decode(coder);
-    }
-    /** Constructs an FSSoundStreamHead2 object specifying all the parameters required to define the sound.
+	/**
+	 * Constructs an FSSoundStreamHead2 object specifying all the parameters
+	 * required to define the sound.
+	 * 
+	 * @param encoding
+	 *            the compression format for the sound data, either
+	 *            FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or
+	 *            FSSound.NELLYMOSER (Flash 6+ only).
+	 * @param playRate
+	 *            the recommended rate for playing the sound, either 5512,
+	 *            11025, 22050 or 44100 Hz.
+	 * @param playChannels
+	 *            The recommended number of playback channels: 1 = mono or 2 =
+	 *            stereo.
+	 * @param playSize
+	 *            the recommended uncompressed sample size for playing the
+	 *            sound, either 1 or 2 bytes.
+	 * @param streamingRate
+	 *            the rate at which the sound was sampled, either 5512, 11025,
+	 *            22050 or 44100 Hz.
+	 * @param streamingChannels
+	 *            the number of channels: 1 = mono or 2 = stereo.
+	 * @param streamingSize
+	 *            the sample size for the sound, either 1 or 2 bytes.
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 * @param latency
+	 *            defines the number of samples to skip only when playing sounds
+	 *            encoded with the MP3 format.
+	 */
+	public FSSoundStreamHead2(int encoding, int playRate, int playChannels,
+								int playSize, int streamingRate,
+								int streamingChannels, int streamingSize,
+								int streamingCount, int latency)
+	{
+		super(SoundStreamHead2);
 
-    @param encoding the compression format for the sound data, either FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER (Flash 6+ only).
-    @param playRate the recommended rate for playing the sound, either 5512, 11025, 22050 or 44100 Hz.
-    @param playChannels The recommended number of playback channels: 1 = mono or 2 = stereo.
-    @param playSize the recommended uncompressed sample size for playing the sound, either 1 or 2 bytes.
-    @param streamingRate the rate at which the sound was sampled, either 5512, 11025, 22050 or 44100 Hz.
-    @param streamingChannels the number of channels: 1 = mono or 2 = stereo.
-    @param streamingSize the sample size for the sound, either 1 or 2 bytes.
-    @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-    @param latency defines the number of samples to skip only when playing sounds encoded with the MP3 format.
-    */
-    public FSSoundStreamHead2(int encoding, int playRate, int playChannels, int playSize, int streamingRate, int streamingChannels, int streamingSize, int streamingCount, int latency)
-    {
-        super(SoundStreamHead2);
+		setFormat(encoding);
 
-        setFormat(encoding);
+		setPlaybackRate(playRate);
+		setPlaybackChannels(playChannels);
+		setPlaybackSampleSize(playSize);
 
-        setPlaybackRate(playRate);
-        setPlaybackChannels(playChannels);
-        setPlaybackSampleSize(playSize);
+		setStreamRate(streamingRate);
+		setStreamChannels(streamingChannels);
+		setStreamSampleSize(streamingSize);
+		setStreamSampleCount(streamingCount);
+		setLatency(latency);
+	}
 
-        setStreamRate(streamingRate);
-        setStreamChannels(streamingChannels);
-        setStreamSampleSize(streamingSize);
-        setStreamSampleCount(streamingCount);
-        setLatency(latency);
-    }
-    /**
-     * Constructs an FSSoundStreamHead2 object by copying values from an 
-     * existing object.
-     *
-     * @param obj an FSSoundStreamHead2 object.
-     */
-    public FSSoundStreamHead2(FSSoundStreamHead2 obj)
-    {
-        super(obj);
-        format = obj.format;
-        playbackRate = obj.playbackRate;
-        playbackChannels = obj.playbackChannels;
-        playbackSampleSize = obj.playbackSampleSize;
-        
-        streamRate = obj.streamRate;
-        streamChannels = obj.streamChannels;
-        streamSampleSize = obj.streamSampleSize;
-        streamSampleCount = obj.streamSampleCount;
-        latency = obj.latency;
-        _reserved = obj._reserved;
-    }
+	/**
+	 * Constructs an FSSoundStreamHead2 object by copying values from an
+	 * existing object.
+	 * 
+	 * @param obj
+	 *            an FSSoundStreamHead2 object.
+	 */
+	public FSSoundStreamHead2(FSSoundStreamHead2 obj)
+	{
+		super(obj);
+		format = obj.format;
+		playbackRate = obj.playbackRate;
+		playbackChannels = obj.playbackChannels;
+		playbackSampleSize = obj.playbackSampleSize;
 
-    /** 
-     * Gets the streaming sound format. For the FSSoundStreamHead2 class supports 
-     * NATIVE_PCM, ADPCM, MP3, PCM or NELLYMOSER encoded sound data.
-    
-        @return the format used to play the sound.
-        */
-    public int getFormat()
-    {
-        return format;
-    }
+		streamRate = obj.streamRate;
+		streamChannels = obj.streamChannels;
+		streamSampleSize = obj.streamSampleSize;
+		streamSampleCount = obj.streamSampleCount;
+		latency = obj.latency;
+		_reserved = obj._reserved;
+	}
 
-    /** Sets the format for the streaming sound.
+	/**
+	 * Gets the streaming sound format. For the FSSoundStreamHead2 class
+	 * supports NATIVE_PCM, ADPCM, MP3, PCM or NELLYMOSER encoded sound data.
+	 * 
+	 * @return the format used to play the sound.
+	 */
+	public int getFormat()
+	{
+		return format;
+	}
 
-       @param encoding the compression format for the sound data, either 
-       FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or FSSound.NELLYMOSER.
-    */
-    public void setFormat(int encoding)
-    {
-        format = encoding;
-    }
+	/**
+	 * Sets the format for the streaming sound.
+	 * 
+	 * @param encoding
+	 *            the compression format for the sound data, either
+	 *            FSSound.NATIVE_PCM, FSSound.ADPCM, FSSound.MP3, FSSound.PCM or
+	 *            FSSound.NELLYMOSER.
+	 */
+	public void setFormat(int encoding)
+	{
+		format = encoding;
+	}
 
-    /** Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	/**
+	 * Gets the recommended playback rate: 5512, 11025, 22050 or 44100 Hertz.
+	 * 
+	 * @return the rate at which the sound will be played back.
+	 */
+	public int getPlaybackRate()
+	{
+		return playbackRate;
+	}
 
-         @return the rate at which the sound will be played back.
-         */
-     public int getPlaybackRate() { return playbackRate; }
+	/**
+	 * Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @return the number of channels for the sound playback.
+	 */
+	public int getPlaybackChannels()
+	{
+		return playbackChannels;
+	}
 
-     /** Gets the recommended number of playback channels = 1 = mono 2 = stereo.
+	/**
+	 * Gets the recommended playback sample range in bytes: 1 or 2.
+	 * 
+	 * @return the sample size used to play back the sound.
+	 */
+	public int getPlaybackSampleSize()
+	{
+		return playbackSampleSize;
+	}
 
-         @return the number of channels for the sound playback.
-         */
-     public int getPlaybackChannels() { return playbackChannels; }
+	/**
+	 * Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming
+	 * sound.
+	 * 
+	 * @return the rate at which the sound was sampled.
+	 */
+	public float getStreamRate()
+	{
+		return streamRate;
+	}
 
-     /** Gets the recommended playback sample range in bytes: 1 or 2.
+	/**
+	 * Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	 * 
+	 * @return the number of channels in the sound.
+	 */
+	public int getStreamChannels()
+	{
+		return streamChannels;
+	}
 
-         @return the sample size used to play back the sound.
-         */
-     public int getPlaybackSampleSize() { return playbackSampleSize; }
+	/**
+	 * Gets the sample size in bytes: 1 or 2 in the streaming sound.
+	 * 
+	 * @return the sample size.
+	 */
+	public int getStreamSampleSize()
+	{
+		return streamSampleSize;
+	}
 
-     /** Gets the sample rate: 5512, 11025, 22050 or 44100 Hz in the streaming sound.
+	/**
+	 * Gets the average number of samples in each stream block following.
+	 * 
+	 * @return the number of sound samples in each following FSSoundStreamBlock
+	 *         object.
+	 */
+	public int getStreamSampleCount()
+	{
+		return streamSampleCount;
+	}
 
-         @return the rate at which the sound was sampled.
-         */
-     public float getStreamRate() { return streamRate; }
+	/**
+	 * Sets the recommended playback rate in Hz. Must be either: 5512, 11025,
+	 * 22050 or 44100.
+	 * 
+	 * @param playRate
+	 *            the recommended rate for playing the sound.
+	 */
+	public void setPlaybackRate(int playRate)
+	{
+		playbackRate = playRate;
+	}
 
-     /** Gets the number of channels, 1 = mono 2 = stereo, in the streaming sound.
+	/**
+	 * Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+	 * 
+	 * @param aNumber
+	 *            the recommended number of playback channels.
+	 */
+	public void setPlaybackChannels(int aNumber)
+	{
+		playbackChannels = aNumber;
+	}
 
-         @return the number of channels in the sound.
-         */
-     public int getStreamChannels() { return streamChannels; }
+	/**
+	 * Sets the recommended playback sample size in bytes. Must be wither 1 or
+	 * 2.
+	 * 
+	 * @param playSize
+	 *            the recommended sample size for playing the sound.
+	 */
+	public void setPlaybackSampleSize(int playSize)
+	{
+		playbackSampleSize = playSize;
+	}
 
-     /** Gets the sample size in bytes: 1 or 2 in the streaming sound.
+	/**
+	 * Sets the sample rate in Hz for the streaming sound. Must be either: 5512,
+	 * 11025, 22050 or 44100.
+	 * 
+	 * @param streamingRate
+	 *            the rate at which the streaming sound was sampled.
+	 */
+	public void setStreamRate(int streamingRate)
+	{
+		streamRate = streamingRate;
+	}
 
-         @return the sample size.
-         */
-     public int getStreamSampleSize() { return streamSampleSize; }
+	/**
+	 * Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+	 * 
+	 * @param streamingChannels
+	 *            the number of channels in the streaming sound.
+	 */
+	public void setStreamChannels(int streamingChannels)
+	{
+		streamChannels = streamingChannels;
+	}
 
-     /** Gets the average number of samples in each stream block following.
+	/**
+	 * Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+	 * 
+	 * @param streamingSize
+	 *            the sample size for the sound.
+	 */
+	public void setStreamSampleSize(int streamingSize)
+	{
+		streamSampleSize = streamingSize;
+	}
 
-         @return the number of sound samples in each following FSSoundStreamBlock object.
-         */
-     public int getStreamSampleCount() { return streamSampleCount; }
+	/**
+	 * Sets the number of samples in each stream block.
+	 * 
+	 * @param streamingCount
+	 *            the number of samples in each subsequent FSSoundStreamBlock
+	 *            object.
+	 */
+	public void setStreamSampleCount(int streamingCount)
+	{
+		streamSampleCount = streamingCount;
+	}
 
-     /** Sets the recommended playback rate in Hz. Must be either: 5512, 11025, 22050 or 44100.
+	/**
+	 * For MP3 encoded sounds, returns the number of samples to skip when
+	 * starting to play a sound.
+	 * 
+	 * @return the number of samples skipped in an MP3 encoded sound Returns 0
+	 *         for other sound formats.
+	 */
+	public int getLatency()
+	{
+		return latency;
+	}
 
-         @param playRate the recommended rate for playing the sound.
-         */
-     public void setPlaybackRate(int playRate)
-     {
-         playbackRate = playRate;
-     }
+	/**
+	 * Set the number of samples to skip when starting to play an MP3 encoded
+	 * sound.
+	 * 
+	 * @param latency
+	 *            the number of samples to be skipped in an MP3 encoded sound
+	 *            should be 0 for other sound formats.
+	 */
+	public void setLatency(int latency)
+	{
+		this.latency = latency;
+	}
 
-     /** Sets the recommended number of playback channels = 1 = mono 2 = stereo.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-         @param aNumber the recommended number of playback channels.
-         */
-     public void setPlaybackChannels(int aNumber)
-     {
-         playbackChannels = aNumber;
-     }
+		if (super.equals(anObject))
+		{
+			FSSoundStreamHead2 typedObject = (FSSoundStreamHead2) anObject;
 
-     /** Sets the recommended playback sample size in bytes. Must be wither 1 or 2.
+			result = format == typedObject.format;
+			result = result &amp;&amp; playbackRate == typedObject.playbackRate;
+			result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
+			result = result
+							&amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
+			result = result &amp;&amp; streamRate == typedObject.streamRate;
+			result = result &amp;&amp; streamChannels == typedObject.streamChannels;
+			result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
+			result = result
+							&amp;&amp; streamSampleCount == typedObject.streamSampleCount;
+			result = result &amp;&amp; latency == typedObject.latency;
+		}
+		return result;
+	}
 
-         @param playSize the recommended sample size for playing the sound.
-         */
-     public void setPlaybackSampleSize(int playSize)
-     {
-         playbackSampleSize = playSize;
-     }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-     /** Sets the sample rate in Hz for the streaming sound. Must be either: 5512, 11025, 22050 or 44100.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;format&quot;, format);
+			Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
+			Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
+			Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
+			Transform.append(buffer, &quot;streamRate&quot;, streamRate);
+			Transform.append(buffer, &quot;streamChannels&quot;, streamChannels);
+			Transform.append(buffer, &quot;streamSampleSize&quot;, streamSampleSize);
+			Transform.append(buffer, &quot;streamSampleCount&quot;, streamSampleCount);
+			Transform.append(buffer, &quot;latency&quot;, latency);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-         @param streamingRate the rate at which the streaming sound was sampled.
-         */
-     public void setStreamRate(int streamingRate)
-     {
-         streamRate = streamingRate;
-     }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-     /** Sets the number of channels in the streaming sound: 1 = mono 2 = stereo.
+		length += 4;
 
-         @param streamingChannels the number of channels in the streaming sound.
-         */
-     public void setStreamChannels(int streamingChannels)
-     {
-         streamChannels = streamingChannels;
-     }
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			length += 2;
 
-     /** Sets the sample size in bytes for the streaming sound. Must be 1 or 2.
+		return length;
+	}
 
-         @param streamingSize the sample size for the sound.
-         */
-     public void setStreamSampleSize(int streamingSize)
-     {
-         streamSampleSize = streamingSize;
-     }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-     /** Sets the number of samples in each stream block.
+		coder.writeBits(_reserved, 4);
 
-         @param streamingCount the number of samples in each subsequent FSSoundStreamBlock object.
-         */
-     public void setStreamSampleCount(int streamingCount)
-     {
-         streamSampleCount = streamingCount;
-     }
+		switch (playbackRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(playbackSampleSize - 1, 1);
+		coder.writeBits(playbackChannels - 1, 1);
 
-     /**
-      * For MP3 encoded sounds, returns the number of samples to skip when starting to play a sound.
-      *
-      * @return the number of samples skipped in an MP3 encoded sound Returns 0 for other sound formats.
-      */
-     public int getLatency() 
-     { 
-         return latency; 
-     }
+		coder.writeBits(format, 4);
 
-     /**
-      * Set the number of samples to skip when starting to play an MP3 encoded sound.
-      *
-      * @param latency the number of samples to be skipped in an MP3 encoded sound should be 0 for other sound formats.
-      */
-     public void setLatency(int latency)
-     {
-         this.latency = latency;
-     }
-     
-     public boolean equals(Object anObject)
-     {
-         boolean result = false;
-        
-         if (super.equals(anObject))
-         {
-             FSSoundStreamHead2 typedObject = (FSSoundStreamHead2)anObject;
-            
-             result = format == typedObject.format;
-             result = result &amp;&amp; playbackRate == typedObject.playbackRate;
-             result = result &amp;&amp; playbackChannels == typedObject.playbackChannels;
-             result = result &amp;&amp; playbackSampleSize == typedObject.playbackSampleSize;
-             result = result &amp;&amp; streamRate == typedObject.streamRate;
-             result = result &amp;&amp; streamChannels == typedObject.streamChannels;
-             result = result &amp;&amp; streamSampleSize == typedObject.streamSampleSize;
-             result = result &amp;&amp; streamSampleCount == typedObject.streamSampleCount;
-             result = result &amp;&amp; latency == typedObject.latency;
-         }
-         return result;
-     }
+		switch (streamRate)
+		{
+			case 5512:
+				coder.writeBits(0, 2);
+				break;
+			case 11025:
+				coder.writeBits(1, 2);
+				break;
+			case 22050:
+				coder.writeBits(2, 2);
+				break;
+			case 44100:
+				coder.writeBits(3, 2);
+				break;
+		}
+		coder.writeBits(streamSampleSize - 1, 1);
+		coder.writeBits(streamChannels - 1, 1);
+		coder.writeWord(streamSampleCount, 2);
 
-     public void appendDescription(StringBuffer buffer, int depth)
-     {
-         buffer.append(name());
-        
-         if (depth &gt; 0)
-         {
-             buffer.append(&quot;: { &quot;);
-             Transform.append(buffer, &quot;format&quot;, format);
-             Transform.append(buffer, &quot;playbackRate&quot;, playbackRate);
-             Transform.append(buffer, &quot;playbackChannels&quot;, playbackChannels);
-             Transform.append(buffer, &quot;playbackSampleSize&quot;, playbackSampleSize);
-             Transform.append(buffer, &quot;streamRate&quot;, streamRate);
-             Transform.append(buffer, &quot;streamChannels&quot;, streamChannels);
-             Transform.append(buffer, &quot;streamSampleSize&quot;, streamSampleSize);
-             Transform.append(buffer, &quot;streamSampleCount&quot;, streamSampleCount);
-             Transform.append(buffer, &quot;latency&quot;, latency);
-             buffer.append(&quot;}&quot;);
-         }
-     }
+		if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
+			coder.writeWord(latency, 2);
 
-     public int length(FSCoder coder)
-     {
-         super.length(coder);
-    
-         length += 4;
-        
-         if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-             length += 2;
-        
-         return length;
-     }
-    
-     public void encode(FSCoder coder)
-     {
-         super.encode(coder);
-        
-         coder.writeBits(_reserved, 4);
+		coder.endObject(name());
+	}
 
-         switch (playbackRate)
-         {
-             case 5512:
-                 coder.writeBits(0, 2);
-                 break;
-             case 11025:
-                 coder.writeBits(1, 2);
-                 break;
-             case 22050:
-                 coder.writeBits(2, 2);
-                 break;
-             case 44100:
-                 coder.writeBits(3, 2);
-                 break;
-         }
-         coder.writeBits(playbackSampleSize-1, 1);
-         coder.writeBits(playbackChannels-1, 1);
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-         coder.writeBits(format, 4);
+		_reserved = coder.readBits(4, false);
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				playbackRate = 5512;
+				break;
+			case 1:
+				playbackRate = 11025;
+				break;
+			case 2:
+				playbackRate = 22050;
+				break;
+			case 3:
+				playbackRate = 44100;
+				break;
+		}
+		playbackSampleSize = coder.readBits(1, false) + 1;
+		playbackChannels = coder.readBits(1, false) + 1;
 
-         switch (streamRate)
-         {
-             case 5512:
-                 coder.writeBits(0, 2);
-                 break;
-             case 11025:
-                 coder.writeBits(1, 2);
-                 break;
-             case 22050:
-                 coder.writeBits(2, 2);
-                 break;
-             case 44100:
-                 coder.writeBits(3, 2);
-                 break;
-         }
-         coder.writeBits(streamSampleSize-1, 1);
-         coder.writeBits(streamChannels-1, 1);
-         coder.writeWord(streamSampleCount, 2);
+		format = coder.readBits(4, false);
 
-         if (format == FSSound.MP3 &amp;&amp; latency &gt; 0)
-             coder.writeWord(latency, 2);
+		switch (coder.readBits(2, false))
+		{
+			case 0:
+				streamRate = 5512;
+				break;
+			case 1:
+				streamRate = 11025;
+				break;
+			case 2:
+				streamRate = 22050;
+				break;
+			case 3:
+				streamRate = 44100;
+				break;
+		}
+		streamSampleSize = coder.readBits(1, false) + 1;
+		streamChannels = coder.readBits(1, false) + 1;
+		streamSampleCount = coder.readWord(2, false);
 
-         coder.endObject(name());
-     }
-    
-     public void decode(FSCoder coder)
-     {
-         super.decode(coder);
-        
-         _reserved = coder.readBits(4, false);
-         switch (coder.readBits(2, false))
-         {
-             case 0:
-                 playbackRate = 5512;
-                 break;
-             case 1:
-                 playbackRate = 11025;
-                 break;
-             case 2:
-                 playbackRate = 22050;
-                 break;
-             case 3:
-                 playbackRate = 44100;
-                 break;
-         }
-         playbackSampleSize = coder.readBits(1, false)+1;
-         playbackChannels = coder.readBits(1, false)+1;
+		if (length == 6 &amp;&amp; format == FSSound.MP3)
+			latency = coder.readWord(2, true);
 
-         format = coder.readBits(4, false);
-
-         switch (coder.readBits(2, false))
-         {
-             case 0:
-                 streamRate = 5512;
-                 break;
-             case 1:
-                 streamRate = 11025;
-                 break;
-             case 2:
-                 streamRate = 22050;
-                 break;
-             case 3:
-                 streamRate = 44100;
-                 break;
-         }
-         streamSampleSize = coder.readBits(1, false)+1;
-         streamChannels = coder.readBits(1, false)+1;
-         streamSampleCount = coder.readWord(2, false);
-        
-         if (length == 6 &amp;&amp; format == FSSound.MP3)
-             latency = coder.readWord(2, true);
-
-         coder.endObject(name());
-     }
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSStartSound.java
===================================================================
--- trunk/src/com/flagstone/transform/FSStartSound.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSStartSound.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,134 +31,160 @@
 package com.flagstone.transform;
 
 /**
-FSStartSound instructs the player to start or stop playing a sound defined using the 
- FSDefineSound class.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * FSStartSound instructs the player to start or stop playing a sound defined
+ * using the FSDefineSound class.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;sound&lt;/td&gt;
+ * &lt;td&gt;An FSSound object that identifies the sound and controls how it is
+ * played - how the sound fades in or out, whether it is repeated along with an
+ * envelope that controls the sound levels as it is played.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSStartSound class represents the StartSound tag from the Macromedia
+ * Flash (SWF) File Format Specification. It was introduced in Flash 1. In the
+ * Macromedia Flash (SWF) File Format Specification the StartSound tag contains
+ * an identifier and an FSSoundInfo structure. The Transform FSSound object
+ * simply combines both to simplify the design of other sound classes. The
+ * information encoded is identical.
+ * &lt;/p&gt;
+ */
+public class FSStartSound extends FSMovieObject
+{
+	private FSSound sound = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSStartSound object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSStartSound(FSCoder coder)
+	{
+		super(FSMovieObject.StartSound);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSStartSound_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSStartSound object with an FSSound object that identifies
+	 * the sound and controls how it is played.
+	 * 
+	 * @param aSound
+	 *            the FSSound object.
+	 */
+	public FSStartSound(FSSound aSound)
+	{
+		super(FSMovieObject.StartSound);
+		setSound(aSound);
+	}
 
-&lt;tr&gt;&lt;td&gt;&lt;a name=&quot;FSStartSound_1&quot;&gt;sound&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSSound object that identifies the sound and controls how it is played - how the sound fades in or out, whether it is repeated along with an envelope that controls the sound levels as it is played.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSStartSound object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSStartSound object.
+	 */
+	public FSStartSound(FSStartSound obj)
+	{
+		super(obj);
+		sound = new FSSound(obj.sound);
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the FSSound object describing how the sound will be played.
+	 * 
+	 * @return the FSSound object.
+	 */
+	public FSSound getSound()
+	{
+		return sound;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the FSSound object that describes how the sound will be played.
+	 * 
+	 * @param aSound
+	 *            the FSSound object that controls how the sound is played.
+	 */
+	public void setSound(FSSound aSound)
+	{
+		sound = aSound;
+	}
 
-&lt;p&gt;The FSStartSound class represents the StartSound tag from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 1. In the Macromedia Flash (SWF) File Format Specification the StartSound tag contains an identifier and an FSSoundInfo structure. The Transform FSSound object simply combines both to simplify the design of other sound classes. The information encoded is identical.&lt;/p&gt;
- */
-public class FSStartSound extends FSMovieObject
-{
-    private FSSound sound = null;
+	public Object clone()
+	{
+		FSStartSound anObject = (FSStartSound) super.clone();
 
-    /**
-     * Construct an FSStartSound object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSStartSound(FSCoder coder)
-    {
-        super(FSMovieObject.StartSound);
-        decode(coder);
-    }
-    /** Constructs an FSStartSound object with an FSSound object that identifies the sound and controls how it is played.
+		anObject.sound = (sound != null) ? (FSSound) sound.clone() : null;
 
-        @param aSound the FSSound object.
-        */
-    public FSStartSound(FSSound aSound)
-    {
-        super(FSMovieObject.StartSound);
-        setSound(aSound);
-    }
-    /**
-     * Constructs an FSStartSound object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSStartSound object.
-     */
-    public FSStartSound(FSStartSound obj)
-    {
-        super(obj);
-        sound = new FSSound(obj.sound);
-    }    
+		return anObject;
+	}
 
-    /**  Gets the FSSound object describing how the sound will be played.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the FSSound object.
-        */
-    public FSSound getSound() { return sound; }
+		if (super.equals(anObject))
+		{
+			FSStartSound typedObject = (FSStartSound) anObject;
 
-    /**  Sets the FSSound object that describes how the sound will be played.
+			if (sound != null)
+				result = sound.equals(typedObject.sound);
+			else
+				result = sound == typedObject.sound;
+		}
+		return result;
+	}
 
-        @param aSound the FSSound object that controls how the sound is played.
-        */
-    public void setSound(FSSound aSound)
-    {
-        sound = aSound;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    public Object clone()
-    {
-        FSStartSound anObject = (FSStartSound)super.clone();
-        
-        anObject.sound = (sound!= null) ? (FSSound)sound.clone() : null;
-        
-        return anObject;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;sound&quot;, sound, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSStartSound typedObject = (FSStartSound)anObject;
-            
-            if (sound != null)
-                 result = sound.equals(typedObject.sound);
-            else
-                result = sound == typedObject.sound;
-        }            
-        return result;
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+		length += sound.length(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;sound&quot;, sound, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        length += sound.length(coder);
+		return length;
+	}
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        sound.encode(coder);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);        
-        sound = new FSSound(coder);
-        coder.endObject(name());
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		sound.encode(coder);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		sound = new FSSound(coder);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSTabOrder.java
===================================================================
--- trunk/src/com/flagstone/transform/FSTabOrder.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSTabOrder.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,167 +31,185 @@
 package com.flagstone.transform;
 
 /**
-The FSTabOrder class is used to set the tabbing order of text fields, movie clips and 
-buttons visible on the display list.
- 
-&lt;table class=&quot;datasheet&quot;&gt;
+ * The FSTabOrder class is used to set the tabbing order of text fields, movie
+ * clips and buttons visible on the display list.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;layer&lt;/td&gt;
+ * &lt;td&gt;The layer number which contains the object assigned to the tabbing
+ * order.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;index&lt;/td&gt;
+ * &lt;td&gt;The index of the object in the tabbing order.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSTabOrder object represents the SetTabIndex tag in the Flash file
+ * specification . It was introduced in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSTabOrder extends FSMovieObject
+{
+	private int layer = 0;
+	private int index = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSTabOrder object, initializing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSTabOrder(FSCoder coder)
+	{
+		super(TabOrder);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Construct a FSTabOrder object that set the tab order for the object on
+	 * the display list at the specified layer.
+	 * 
+	 * @param layer
+	 *            the layer number which contains the object assigned to the
+	 *            tabbing order.
+	 * @param index
+	 *            the index of the object in the tabbing order.
+	 */
+	public FSTabOrder(int layer, int index)
+	{
+		super(TabOrder);
+		setLayer(layer);
+		setIndex(index);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_1&quot;&gt;layer&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The layer number which contains the object assigned to the tabbing order.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSTabOrder object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSTabOrder object.
+	 */
+	public FSTabOrder(FSTabOrder obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSDefineVideo_2&quot;&gt;index&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The index of the object in the tabbing order.&lt;/td&gt;
-&lt;/tr&gt;
+		layer = obj.layer;
+		index = obj.index;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Gets the layer number which contains the object assigned to the tabbing
+	 * order.
+	 * 
+	 * @return the layer number.
+	 */
+	public int getLayer()
+	{
+		return layer;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the layer number which contains the object assigned to the tabbing
+	 * order.
+	 * 
+	 * @param layer
+	 *            the layer number.
+	 */
+	public void setLayer(int layer)
+	{
+		this.layer = layer;
+	}
 
-&lt;p&gt;The FSTabOrder object represents the SetTabIndex tag in the Flash file specification . It was introduced in Flash 7.&lt;/p&gt;
- */  
-public class FSTabOrder extends FSMovieObject
-{
-    private int layer = 0; 
-    private int index = 0; 
-    
-    /**
-     * Construct an FSTabOrder object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSTabOrder(FSCoder coder)
-    {
-        super(TabOrder);
-        decode(coder);
-    }
+	/**
+	 * Gets the index of the object in the tabbing order.
+	 * 
+	 * @return the index in the tabbing order.
+	 */
+	public int getIndex()
+	{
+		return index;
+	}
 
-    /**
-     * Construct a FSTabOrder object that set the tab order for the object on the display list
-     * at the specified layer.
-     *
-     * @param layer the layer number which contains the object assigned to the tabbing order.
-     * @param index the index of the object in the tabbing order.
-     */
-    public FSTabOrder(int layer, int index)
-    {
-        super(TabOrder);
-        setLayer(layer);
-        setIndex(index);
-    }
-    /**
-     * Constructs an FSTabOrder object by copying values from an existing object.
-     *
-     * @param obj an FSTabOrder object.
-     */
-    public FSTabOrder(FSTabOrder obj)
-    {
-        super(obj);
-        
-        layer = obj.layer;
-        index = obj.index;
-    }
-    /**
-     * Gets the layer number which contains the object assigned to the tabbing order.
-     *
-     * @return the layer number.
-     */
-    public int getLayer() 
-    {
-        return layer;
-    }
+	/**
+	 * Sets the index of the object in the tabbing order.
+	 * 
+	 * @param index
+	 *            the index in the tabbing order.
+	 */
+	public void setIndex(int index)
+	{
+		this.index = index;
+	}
 
-    /**
-     * Sets the layer number which contains the object assigned to the tabbing order.
-     *
-     * @param layer the layer number.
-     */
-    public void setLayer(int layer)
-    {
-        this.layer = layer;
-    }
-    
-    /**
-     * Gets the index of the object in the tabbing order.
-     *
-     * @return the index in the tabbing order.
-     */
-    public int getIndex() 
-    {
-        return index;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Sets the index of the object in the tabbing order.
-     *
-     * @param index the index in the tabbing order.
-     */
-    public void setIndex(int index)
-    {
-        this.index = index;
-    }
-    
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSTabOrder typedObject = (FSTabOrder) anObject;
-            
-            result = layer == typedObject.layer;
-            result = result &amp;&amp; index == typedObject.index;
-        }
-        return result;
-    }
+		if (super.equals(anObject))
+		{
+			FSTabOrder typedObject = (FSTabOrder) anObject;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;layer&quot;, this.layer);
-            Transform.append(buffer, &quot;index&quot;, index);
-              buffer.append(&quot;}&quot;);
-        }
-    }
+			result = layer == typedObject.layer;
+			result = result &amp;&amp; index == typedObject.index;
+		}
+		return result;
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 4;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(layer, 2);
-        coder.writeWord(index, 2);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        layer = coder.readWord(2, false);
-        index = coder.readWord(2, false);
-        coder.endObject(name());
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;layer&quot;, this.layer);
+			Transform.append(buffer, &quot;index&quot;, index);
+			buffer.append(&quot;}&quot;);
+		}
+	}
+
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
+
+		length += 4;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(layer, 2);
+		coder.writeWord(index, 2);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		layer = coder.readWord(2, false);
+		index = coder.readWord(2, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSTable.java
===================================================================
--- trunk/src/com/flagstone/transform/FSTable.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSTable.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,231 +33,259 @@
 import java.util.*;
 
 /**
-FSTable is used to create a table of string literals that can be referenced by an index 
- rather than using the literal value when executing a sequence of actions.
- 
-&lt;p&gt;Variables and built-in functions are specified by their name and the FSTable 
-class contains a table of the respective strings. References to a variable or 
-function can then use its index in the table rather than the name resulting in 
-a more compact representation when the actions are encoded into binary form.&lt;/p&gt;
+ * FSTable is used to create a table of string literals that can be referenced
+ * by an index rather than using the literal value when executing a sequence of
+ * actions.
+ * 
+ * &lt;p&gt;
+ * Variables and built-in functions are specified by their name and the FSTable
+ * class contains a table of the respective strings. References to a variable or
+ * function can then use its index in the table rather than the name resulting
+ * in a more compact representation when the actions are encoded into binary
+ * form.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;values&lt;/td&gt;
+ * &lt;td&gt;An array of up to 65536 strings.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The use of the FSTable class is illustrated in the following simple
+ * expression:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * var1 = (var1 + var2) / (var1 - var3);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This can be translated into the following sequence of actions:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSTable values = new FSTable();
+ * 
+ * values.add(&quot;var1&quot;);
+ * values.add(&quot;var2&quot;);
+ * values.add(&quot;var3&quot;);
+ * 
+ * actions.add(values);
+ * 
+ * actions.add(new FSPush(FSTableIndex(0))); // var1
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSTableIndex(0))); // var1
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSTableIndex(1))); // var2
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSAction(FSAction.Add));
+ * actions.add(new FSPush(FSTableIndex(0))); // var1
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSTableIndex(2))); // var3
+ * actions.add(FSAction.Subtract());
+ * actions.add(FSAction.Divide());
+ * actions.add(FSAction.SetVariable());
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * The table in the FSTable class can support up to 65536 different variables.
+ * As a result using the FSVariable class to reference the variables in the
+ * example above uses one byte rather than the five required to represent the
+ * name directly (including the null character terminating the string).
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The FSTable stores the strings in an array. No checking for duplicate values
+ * is performed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSTable class represents the ActionConstantPool in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5. It was
+ * extended in Flash 6 to support tables of up to 65536 strings.
+ * &lt;/p&gt;
+ */
+public class FSTable extends FSActionObject
+{
+	private ArrayList values = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSTable object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSTable(FSCoder coder)
+	{
+		super(Table);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/** Constructs an empty table. */
+	public FSTable()
+	{
+		super(Table);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSTable_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSTable object using the array of strings.
+	 * 
+	 * @param anArray
+	 *            of Strings that will be added to the table.
+	 */
+	public FSTable(ArrayList anArray)
+	{
+		super(Table);
+		setValues(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSTable_1&quot;&gt;values&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of up to 65536 strings.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSTable object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSTable(FSTable obj)
+	{
+		super(obj);
 
-&lt;p&gt;The use of the FSTable class is illustrated in the following simple expression:&lt;/p&gt;
+		values = new ArrayList(obj.values.size());
 
-&lt;pre&gt;
-var1 = (var1 + var2) / (var1 - var3);
-&lt;/pre&gt;
+		for (Iterator i = obj.values.iterator(); i.hasNext();)
+			values.add(new String((String) i.next()));
+	}
 
-&lt;p&gt;This can be translated into the following sequence of actions:&lt;/p&gt;
+	/**
+	 * Adds a String to the variable table.
+	 * 
+	 * @param aString
+	 *            a String that will be added to the end of the table.
+	 */
+	public void add(String aString)
+	{
+		values.add(aString);
+	}
 
-&lt;pre&gt;
-FSTable values = new FSTable();
+	/**
+	 * Gets the array of Strings stored in the variable table.
+	 * 
+	 * @return the array of string literals.
+	 */
+	public ArrayList getValues()
+	{
+		return values;
+	}
 
-values.add(&quot;var1&quot;);
-values.add(&quot;var2&quot;);
-values.add(&quot;var3&quot;);
+	/**
+	 * Sets the array of Strings stored in the literal table.
+	 * 
+	 * @param anArray
+	 *            of Strings that will replaces the existing literal table.
+	 */
+	public void setValues(ArrayList anArray)
+	{
+		values = anArray;
+	}
 
-actions.add(values);
+	public Object clone()
+	{
+		FSTable anObject = (FSTable) super.clone();
 
-actions.add(new FSPush(FSTableIndex(0)));            // var1
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSTableIndex(0)));            // var1
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSTableIndex(1)));            // var2
-actions.add(FSAction.GetVariable());
-actions.add(new FSAction(FSAction.Add));
-actions.add(new FSPush(FSTableIndex(0)));            // var1
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSTableIndex(2)));            // var3
-actions.add(FSAction.Subtract());
-actions.add(FSAction.Divide());
-actions.add(FSAction.SetVariable());
-&lt;/pre&gt;
+		anObject.values = new ArrayList();
 
-&lt;p&gt;The table in the FSTable class can support up to 65536 different variables. As 
-a result using the FSVariable class to reference the variables in the example 
-above uses one byte rather than the five required to represent the name directly 
-(including the null character terminating the string).&lt;/p&gt;
+		for (Iterator i = values.iterator(); i.hasNext();)
+			anObject.values.add(new String((String) i.next()));
 
-&lt;p&gt;The FSTable stores the strings in an array. No checking for duplicate values is performed.&lt;/p&gt;
+		return anObject;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;p&gt;The FSTable class represents the ActionConstantPool in the Macromedia Flash (SWF)
-File Format Specification. It was introduced in Flash 5. It was extended in Flash 
-6 to support tables of up to 65536 strings.&lt;/p&gt;
- */  
-public class FSTable extends FSActionObject
-{
-    private ArrayList values = null;
-    
-    /**
-     * Construct an FSTable object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSTable(FSCoder coder)
-    {
-        super(Table);
-        decode(coder);
-    }
-    /** Constructs an empty table. */
-    public FSTable()
-    {
-        super(Table);
-    }
-    /** Constructs an FSTable object using the array of strings.
+		if (super.equals(anObject))
+			result = values.equals(((FSTable) anObject).getValues());
 
-        @param anArray of Strings that will be added to the table.
-        */
-    public FSTable(ArrayList anArray)
-    {
-        super(Table);
-        setValues(anArray);
-    }
-    /**
-     * Constructs an FSTable object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSTable(FSTable obj)
-    {
-        super(obj);
+		return result;
+	}
 
-        values = new ArrayList(obj.values.size());
-        
-        for (Iterator i = obj.values.iterator(); i.hasNext();)
-            values.add(new String((String)i.next()));
-    }    
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Adds a String to the variable table.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;values&quot;, values, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @param aString a String that will be added to the end of the table.
-        */
-    public void add(String aString)
-    {
-        values.add(aString);
-    }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Gets the array of Strings stored in the variable table.
+		length += 2;
 
-        @return the array of string literals.
-        */
-    public ArrayList getValues()
-    {
-        return values;
-    }
+		for (Iterator i = values.iterator(); i.hasNext();)
+			length += coder.strlen((String) i.next(), true);
 
-    /** Sets the array of Strings stored in the literal table.
+		return length;
+	}
 
-        @param anArray of Strings that will replaces the existing literal table.
-        */
-    public void setValues(ArrayList anArray)
-    {
-        values = anArray;
-    }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
 
-    public Object clone()
-    {
-        FSTable anObject = (FSTable)super.clone();
-        
-        anObject.values = new ArrayList();
-            
-        for (Iterator i = values.iterator(); i.hasNext();)
-            anObject.values.add(new String((String)i.next()));
+		coder.writeWord(values.size(), 2);
 
-        return anObject;
-    }
+		if (values.size() &gt; 0)
+		{
+			for (Iterator i = values.iterator(); i.hasNext();)
+			{
+				coder.writeString((String) i.next());
+				coder.writeWord(0, 1);
+			}
+		}
+		coder.endObject(name());
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = values.equals(((FSTable)anObject).getValues());
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
 
-        return result;
-    }
+		int attributeCount = coder.readWord(2, false);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;values&quot;, values, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (attributeCount &gt; 0)
+		{
+			values = new ArrayList();
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 2;
-        
-        for (Iterator i = values.iterator(); i.hasNext();)
-            length += coder.strlen((String)i.next(), true); 
-                    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-
-        coder.writeWord(values.size(), 2);
-        
-        if (values.size() &gt; 0)
-        {
-            for (Iterator i = values.iterator(); i.hasNext();)
-            {
-                coder.writeString((String)i.next());
-                coder.writeWord(0, 1);
-            }
-        }
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-
-        int attributeCount = coder.readWord(2, false);
-        
-        if (attributeCount &gt; 0)
-        {
-            values = new ArrayList();
-            
-            for (int i=0; i&lt;attributeCount; i++)
-                values.add(coder.readString());
-        }
-        else
-        {
-            /*
-             * Reset the length as Macromedia is using the length of a 
-             * table to hide coded following an empty table.
-             */
-            length = 2;
-            values = new ArrayList();
-        }
-        coder.endObject(name());
-    }
+			for (int i = 0; i &lt; attributeCount; i++)
+				values.add(coder.readString());
+		} else
+		{
+			/*
+			 * Reset the length as Macromedia is using the length of a table to
+			 * hide coded following an empty table.
+			 */
+			length = 2;
+			values = new ArrayList();
+		}
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSTableIndex.java
===================================================================
--- trunk/src/com/flagstone/transform/FSTableIndex.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSTableIndex.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,140 +31,170 @@
 package com.flagstone.transform;
 
 /**
-FSTableIndex is used with an FSPush action to push a reference to an entry in a table 
-of literals onto the stack. 
- 
-&lt;p&gt;The value is can then be retrieved from the table and used in a subsequent calculation. The data type was extended in Flash 6 to support tables of up to 65535 strings.&lt;/p&gt;
+ * FSTableIndex is used with an FSPush action to push a reference to an entry in
+ * a table of literals onto the stack.
+ * 
+ * &lt;p&gt;
+ * The value is can then be retrieved from the table and used in a subsequent
+ * calculation. The data type was extended in Flash 6 to support tables of up to
+ * 65535 strings.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * In the Macromedia Flash (SWF) File Format Specification all literals used in
+ * calculations are stored as strings. When performing a series of actions each
+ * time a literal value is used in a calculation it must be pushed onto the
+ * stack. Rather than repeatedly pushing the value explicitly using an FSPush
+ * action, all the literals are added to a table in the Flash Player's memory
+ * using the FSTable action. To retrieve a literal from the table a reference to
+ * an entry in the table is pushed onto the stack using an FSTableIndex. The
+ * reduces the number of bytes required to perform a given calculation when the
+ * values are used repeatedly.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * As an example consider the code required to concatenate two strings:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ *  ArrayList actions = new ArrayList();
+ *  ...
+ *  // Create the table of literals
+ *  FSTable literals = new FSTable();
+ *  literals.add(&quot;abc&quot;);
+ *  literals.add(&quot;def&quot;);
+ *  actions.add(literals);
+ *  ...
+ *  // Create references to the string literals
+ *  FSPush push = new FSPush();
+ *  push.add(new FSTableIndex(0));
+ *  push.add(new FSTableIndex(1));
+ *  actions.add(push);
+ *  ...
+ *  // concatenate the strings
+ *  actions.add(new FSAction(FSAction.Add));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * An FSTable can store up to 65536 string literals. Using a table index rather
+ * than specifying the string literal explicitly reduces considerably the number
+ * of bytes required to represent a sequence of actions.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The string literal table was introduced in Flash 5. It was extended in Flash
+ * 6 to support tables of up to 65536 strings.
+ * &lt;/p&gt;
+ */
+public class FSTableIndex extends FSTransformObject
+{
+	private int index = 0;
 
-&lt;p&gt;In the Macromedia Flash (SWF) File Format Specification all literals used in calculations are stored as strings. When performing a series of actions each time a literal value is used in a calculation it must be pushed onto the stack. Rather than repeatedly pushing the value explicitly using an FSPush action, all the literals are added to a table in the Flash Player's memory using the FSTable action. To retrieve a literal from the table a reference to an entry in the table is pushed onto the stack using an FSTableIndex. The reduces the number of bytes required to perform a given calculation when the values are used repeatedly.&lt;/p&gt;
+	/**
+	 * Construct an FSTableIndex object, initalizing it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSTableIndex(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;p&gt;As an example consider the code required to concatenate two strings:&lt;/p&gt;
+	/**
+	 * Constructs an FSTableIndex object referencing the value stored in the
+	 * literal table.
+	 * 
+	 * @param anIndex
+	 *            the index into the literal table.
+	 */
+	public FSTableIndex(int anIndex)
+	{
+		setIndex(anIndex);
+	}
 
-&lt;pre&gt;
-ArrayList actions = new ArrayList();
-...
-// Create the table of literals
-FSTable literals = new FSTable();
-literals.add(&quot;abc&quot;);
-literals.add(&quot;def&quot;);
-actions.add(literals);
-...
-// Create references to the string literals
-FSPush push = new FSPush();
-push.add(new FSTableIndex(0));
-push.add(new FSTableIndex(1));
-actions.add(push);
-...
-// concatenate the strings
-actions.add(new FSAction(FSAction.Add));
-&lt;/pre&gt;
+	/**
+	 * Constructs an FSTableIndex object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSTableIndex object.
+	 */
+	public FSTableIndex(FSTableIndex obj)
+	{
+		index = obj.index;
+	}
 
-&lt;p&gt;An FSTable can store up to 65536 string literals. Using a table index rather 
-than specifying the string literal explicitly reduces considerably the number of 
-bytes required to represent a sequence of actions.&lt;/p&gt;
+	/**
+	 * Gets the index in the table of string literals.
+	 * 
+	 * @return the index into the literal table.
+	 */
+	public int getIndex()
+	{
+		return index;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the index in the table of string literals.
+	 * 
+	 * @param anIndex
+	 *            the index into the literal table.
+	 */
+	public void setIndex(int anIndex)
+	{
+		index = anIndex;
+	}
 
-&lt;p&gt;The string literal table was introduced in Flash 5. It was extended in Flash 
-6 to support tables of up to 65536 strings.&lt;/p&gt;
- */  
-public class FSTableIndex extends FSTransformObject
-{
-    private int index = 0;
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Construct an FSTableIndex object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSTableIndex(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /** Constructs an FSTableIndex object referencing the value stored in the literal table.
+		if (super.equals(anObject))
+			result = index == ((FSTableIndex) anObject).getIndex();
 
-        @param anIndex the index into the literal table.
-        */
-    public FSTableIndex(int anIndex)
-    {
-        setIndex(anIndex);
-    }
-    /**
-     * Constructs an FSTableIndex object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSTableIndex object.
-     */
-    public FSTableIndex(FSTableIndex obj)
-    {
-        index = obj.index;
-    }    
+		return result;
+	}
 
-    /** Gets the index in the table of string literals.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @return the index into the literal table.
-        */
-    public int getIndex() 
-    {
-        return index;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;index&quot;, index);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the index in the table of string literals.
+	public int length(FSCoder coder)
+	{
+		return index &lt; 256 ? 2 : 3;
+	}
 
-        @param anIndex the index into the literal table.
-        */
-    public void setIndex(int anIndex) 
-    {
-        index = anIndex;
-    }
+	public void encode(FSCoder coder)
+	{
+		int type = index &lt; 256 ? 8 : 9;
 
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = index == ((FSTableIndex)anObject).getIndex();
+		coder.writeWord(type, 1);
+		coder.writeWord(index, type == 8 ? 1 : 2);
+	}
 
-        return result;
-    }
+	public void decode(FSCoder coder)
+	{
+		int type = coder.readWord(1, false);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;index&quot;, index);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    { 
-        return index &lt; 256 ? 2 : 3;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        int type = index &lt; 256 ? 8 : 9;
-        
-        coder.writeWord(type, 1);
-        coder.writeWord(index, type == 8 ? 1 : 2);
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int type = coder.readWord(1, false);
-        
-        index = coder.readWord(type == 8 ? 1 : 2, false);
-    }
+		index = coder.readWord(type == 8 ? 1 : 2, false);
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSText.java
===================================================================
--- trunk/src/com/flagstone/transform/FSText.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSText.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,568 +33,676 @@
 import java.util.*;
 
 /**
-FSText is used to display a line of text. 
- 
-&lt;p&gt;It contains an array of FSCharacter 
-objects which identify the glyphs that will be displayed along with style information 
-that sets the colour of the text, the size of the font and the relative placement 
-of the line within a block of text.&lt;/p&gt;
+ * FSText is used to display a line of text.
+ * 
+ * &lt;p&gt;
+ * It contains an array of FSCharacter objects which identify the glyphs that
+ * will be displayed along with style information that sets the colour of the
+ * text, the size of the font and the relative placement of the line within a
+ * block of text.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSText_0&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The identifier, in the range 1..65535, of the font object which contains
+ * the glyphs representing each character displayed. Optional. Set to 0 if the
+ * font is not being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSText_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An FSColor object describing colour of the text. Optional. Set to null
+ * if the colour is not being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSText_2&quot;&gt;offsetX&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The offset, in twips, relative to the left side bounding rectangle of
+ * the text block where the text will be displayed. Optional. Set to zero if no
+ * indent is being specified.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSText_3&quot;&gt;offsetY&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The offset, in twips, relative to the bottom of the bounding rectangle
+ * of the text block where the text will be displayed. Optional. Set to the
+ * height of the font if only a single line of text is being displayed so the
+ * characters are placed correctly within the bounding rectangle defined for the
+ * text object.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSText_4&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;The height of the font, in twips, used to render the characters.
+ * Optional. Set to zero if the font size is not being changed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;&lt;a name=&quot;FSText_5&quot;&gt;characters&lt;/a&gt;&lt;/td&gt;
+ * &lt;td&gt;An array of FSCharacter objects which identify the glyph that will be
+ * displayed along with the spacing to the next character in the line of text.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Whether the alpha channel in the colour needs to be specified depends on the
+ * class the FSText is added to. The FSDefineText2 class supports transparent
+ * text while FSDefineText class does not.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The x and y offsets are used to control how several FSText objects are laid
+ * out to create a block of text. The y offset is specified relative to the
+ * bottom edge of the bounding rectangle, which is actually closer to the top of
+ * the screen as the direction of the y-axis is from the top to the bottom of
+ * the screen. In this respect Flash is counter-intuitive. Lines with higher
+ * offset values are displayed below lines with lower offsets.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * When several FSText objects are used to define a block of text using the
+ * FSDefineText or FSDefineText2 classes the attributes such as the font
+ * selected, size and colour must be specified in the first FSText object. For
+ * the remaining FSText objects these may be set to null or zero. The attributes
+ * will apply to all following FSText object until explicitly changed.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The creation and layout of the glyphs to create the text is too onerous to
+ * perform from scratch. It is easier and more convenient to use existing font
+ * definitions either by parsing an existing Flash file or by converting a font
+ * definition from a specification such as TrueType in order to obtain the
+ * glyphs and layout information.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * 1. Creating a simple string.&lt;br/&gt; This examples assumes a font definition
+ * that contains glyphs for the following set of characters ' ', 'a', 'b', 'c'
+ * .... 'x', 'y', 'z'. The font used fixed size for the spacing between glyphs
+ * .e.g. Courier.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * ArrayList characters = new ArrayList();
+ * 
+ * characters.add(new FSCharacter(1, 120)); // 'a'
+ * characters.add(new FSCharacter(0, 120)); // ' '
+ * characters.add(new FSCharacter(19, 120)); // 's'
+ * characters.add(new FSCharacter(10, 120)); // 't'
+ * characters.add(new FSCharacter(18, 120)); // 'r'
+ * characters.add(new FSCharacter(9, 120)); // 'i'
+ * characters.add(new FSCharacter(14, 120)); // 'n'
+ * characters.add(new FSCharacter(6, 120)); // 'g'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and displaying 
+ * // the characters in black. The text is not indented or offset.
+ * 
+ * int xOffset = 0;
+ * int yOffset = 240;
+ * int fontSize = 240;
+ * 
+ * FSText string = new FSText(font.getIdentifier(), FSColorTable.black(), xOffset,
+ * 				yOffset, fontSize, characters);
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * 2. Creating a block of text.&lt;br/&gt; Again this examples assumes a fixed size
+ * font definition that contains glyphs for the set of characters.
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * ArrayList line1 = new ArrayList();
+ * 
+ * line1.add(new FSCharacter(19, 120)); // 's'
+ * line1.add(new FSCharacter(10, 120)); // 't'
+ * line1.add(new FSCharacter(18, 120)); // 'r'
+ * line1.add(new FSCharacter(9, 120)); // 'i'
+ * line1.add(new FSCharacter(14, 120)); // 'n'
+ * line1.add(new FSCharacter(6, 120)); // 'g'
+ * line1.add(new FSCharacter(0, 120)); // ' '
+ * line1.add(new FSCharacter(28, 120)); // '1'
+ * 
+ * // Create the string setting the height to be 12-point (240 twips) and 
+ * // displaying the characters in black. The text is not indented or offset.
+ * 
+ * int fontSize = 240;
+ * int yOffset = 240;
+ * 
+ * FSText string1 = new FSText(font.getIdentifier(), FSColorTable.black(), 0,
+ * 				yOffset, fontSize, line1);
+ * 
+ * ArrayList line1 = new ArrayList();
+ * 
+ * line2.add(new FSCharacter(19, 120)); // 's'
+ * line2.add(new FSCharacter(10, 120)); // 't'
+ * line2.add(new FSCharacter(18, 120)); // 'r'
+ * line2.add(new FSCharacter(9, 120)); // 'i'
+ * line2.add(new FSCharacter(14, 120)); // 'n'
+ * line2.add(new FSCharacter(6, 120)); // 'g'
+ * line2.add(new FSCharacter(0, 120)); // ' '
+ * line2.add(new FSCharacter(29, 120)); // '2'
+ * 
+ * // Display the second string 'one line' height (240 twips) below the first. 
+ * // The font size and colour remain unchanged.
+ * 
+ * yOffset += fontSize;
+ * 
+ * FSText string2 = new FSText(0, yOffset, line2);
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSText class represents both the TextRecordType0 and TextRecordType1
+ * structures from the Macromedia Flash (SWF) File Format Specification. It was
+ * introduced in Flash 1.
+ * &lt;/p&gt;
+ */
+public class FSText extends FSTransformObject
+{
+	/** Defines that the font character set is based on the Unicode standard. */
+	public static final int Unicode = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Defines that the font character set is based on the SJIS standard for
+	 * representing Kanji characters.
+	 */
+	public static final int SJIS = 2;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Defines that the font character set is based on the ANSI UTF-8 standard
+	 * which supports standard ASCII encoded strings.
+	 */
+	public static final int ANSI = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_0&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier, in the range 1..65535, of the font object which contains the 
-glyphs representing each character displayed. Optional. Set to 0 if the font is 
-not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	// Flash 6
+	// / Code used to identify the spoken language for Latin fonts.
+	public static final int Latin = 1;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_1&quot;&gt;color&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An FSColor object describing colour of the text. Optional. Set to null if the 
-colour is not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for Japanese fonts.
+	public static final int Japanese = 2;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_2&quot;&gt;offsetX&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The offset, in twips, relative to the left side bounding rectangle of the text 
-block where the text will be displayed. Optional. Set to zero if no indent is being 
-specified.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for Japanese fonts.
+	public static final int Korean = 3;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_3&quot;&gt;offsetY&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The offset, in twips, relative to the bottom of the bounding rectangle of the 
-text block where the text will be displayed. Optional. Set to the height of the 
-font if only a single line of text is being displayed so the characters are placed 
-correctly within the bounding rectangle defined for the text object.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for simplified Chinese fonts.
+	public static final int SimplifiedChinese = 4;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_4&quot;&gt;height&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The height of the font, in twips,  used to render the characters. Optional. 
-Set to zero if the font size is not being changed.&lt;/td&gt;
-&lt;/tr&gt;
+	// / Code used to identify the spoken language for traditional Chinese
+	// fonts.
+	public static final int TraditionalChinese = 5;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSText_5&quot;&gt;characters&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of FSCharacter objects which identify the glyph that will be displayed 
-along with the spacing to the next character in the line of text.&lt;/td&gt;
-&lt;/tr&gt;
+	// End Flash 6
 
-&lt;/table&gt;
+	private int identifier = 0;
 
-&lt;p&gt;Whether the alpha channel in the colour needs to be specified depends on the 
-class the FSText is added to. The FSDefineText2 class supports transparent text 
-while FSDefineText class does not.&lt;/p&gt;
+	private FSColor color = null;
 
-&lt;p&gt;The x and y offsets are used to control how several FSText objects are laid 
-out to create a block of text. The y offset is specified relative to the bottom 
-edge of the bounding rectangle, which is actually closer to the top of the screen 
-as the direction of the y-axis is from the top to the bottom of the screen. In this 
-respect Flash is counter-intuitive. Lines with higher offset values are displayed 
-below lines with lower offsets.&lt;/p&gt;
+	private int offsetX = Transform.VALUE_NOT_SET;
 
-&lt;p&gt;When several FSText objects are used to define a block of text using the FSDefineText 
-or FSDefineText2 classes the attributes such as the font selected, size and colour 
-must be specified in the first FSText object. For the remaining FSText objects 
-these may be set to null or zero. The attributes will apply to all following FSText 
-object until explicitly changed.&lt;/p&gt;
+	private int offsetY = Transform.VALUE_NOT_SET;
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+	private int height = 0;
 
-&lt;p&gt;The creation and layout of the glyphs to create the text is too onerous to 
-perform from scratch. It is easier and more convenient to use existing font 
-definitions either by parsing an existing Flash file or by converting a font 
-definition from a specification such as TrueType in order to obtain the glyphs 
-and layout information.&lt;/p&gt;
+	private ArrayList characters = new ArrayList();
 
-&lt;p&gt;1. Creating a simple string.&lt;br/&gt;
-This examples assumes a font definition that contains glyphs for the following 
-set of characters ' ', 'a', 'b', 'c' .... 'x', 'y', 'z'. The font used fixed size 
-for the spacing between glyphs .e.g. Courier.&lt;/p&gt;
+	/**
+	 * Construct an FSText object, initalizing it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSText(FSCoder coder)
+	{
+		decode(coder);
+	}
 
-&lt;pre&gt;
-ArrayList characters = new ArrayList();
+	/**
+	 * Constructs an FSText object specifying the array of characters to be
+	 * displayed and their relative placement within a block of text. The
+	 * selected font, colour of the text and height will remain unchanged from
+	 * previous settings.
+	 * 
+	 * @param xOffset
+	 *            the location of the text relative to the left edge of the
+	 *            bounding rectangle enclosing the block of text.
+	 * @param yOffset
+	 *            the location of the text relative to the bottom edge of the
+	 *            bounding rectangle enclosing the block of text.
+	 * @param anArray
+	 *            an array of FSCharacter objects.
+	 */
+	public FSText(int xOffset, int yOffset, ArrayList anArray)
+	{
+		setOffsetX(xOffset);
+		setOffsetY(yOffset);
+		setCharacters(anArray);
+	}
 
-characters.add(new FSCharacter(1, 120));  // 'a'
-characters.add(new FSCharacter(0, 120));  // ' '
-characters.add(new FSCharacter(19, 120)); // 's'
-characters.add(new FSCharacter(10, 120)); // 't'
-characters.add(new FSCharacter(18, 120)); // 'r'
-characters.add(new FSCharacter(9, 120));  // 'i'
-characters.add(new FSCharacter(14, 120)); // 'n'
-characters.add(new FSCharacter(6, 120));  // 'g'
+	/**
+	 * Constructs an FSText object, specifying the colour and position of the
+	 * following FSText.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the font that the text will be rendered in.
+	 * @param aColor
+	 *            the colour of the text.
+	 * @param xOffset
+	 *            the location of the text relative to the left edge of the
+	 *            bounding rectangle enclosing the text.
+	 * @param yOffset
+	 *            the location of the text relative to the bottom edge of the
+	 *            bounding rectangle enclosing the text.
+	 * @param aHeight
+	 *            the height of the text in the chosen font.
+	 * @param anArray
+	 *            an array of FSCharacter objects.
+	 */
+	public FSText(int anIdentifier, FSColor aColor, int xOffset, int yOffset,
+					int aHeight, ArrayList anArray)
+	{
+		setIdentifier(anIdentifier);
+		setColor(aColor);
+		setOffsetX(xOffset);
+		setOffsetY(yOffset);
+		setHeight(aHeight);
+		setCharacters(anArray);
+	}
 
-// Create the string setting the height to be 12-point (240 twips) and displaying 
-// the characters in black. The text is not indented or offset.
+	/**
+	 * Constructs an FSText object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSText object.
+	 */
+	public FSText(FSText obj)
+	{
+		identifier = obj.identifier;
+		color = new FSColor(obj.color);
+		offsetX = obj.offsetX;
+		offsetY = obj.offsetY;
+		height = obj.height;
 
-int xOffset = 0;
-int yOffset = 240;
-int fontSize = 240;
+		characters = new ArrayList(obj.characters.size());
 
-FSText string = new FSText(font.getIdentifier(), FSColorTable.black(), xOffset, yOffset, fontSize, characters);
-&lt;/pre&gt;
+		for (Iterator i = obj.characters.iterator(); i.hasNext();)
+			characters.add(((FSCharacter) i.next()).clone());
+	}
 
-&lt;p&gt;2. Creating a block of text.&lt;br/&gt;
-Again this examples assumes a fixed size font definition that contains glyphs for 
-the set of characters.&lt;/p&gt;
+	/**
+	 * Gets the identifier of the font in which the text will be displayed.
+	 * 
+	 * @return the identifier of the font.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;pre&gt;
-ArrayList line1 = new ArrayList();
+	/**
+	 * Gets the colour of the font in which the text will be displayed.
+	 * 
+	 * @return the colour of the text.
+	 */
+	public FSColor getColor()
+	{
+		return color;
+	}
 
-line1.add(new FSCharacter(19, 120)); // 's'
-line1.add(new FSCharacter(10, 120)); // 't'
-line1.add(new FSCharacter(18, 120)); // 'r'
-line1.add(new FSCharacter(9, 120));  // 'i'
-line1.add(new FSCharacter(14, 120)); // 'n'
-line1.add(new FSCharacter(6, 120));  // 'g'
-line1.add(new FSCharacter(0, 120));  // ' '
-line1.add(new FSCharacter(28, 120));  // '1'
+	/**
+	 * Gets the location of the start of the text relative to the left edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @return the indentation applied to the text.
+	 */
+	public int getOffsetX()
+	{
+		return offsetX;
+	}
 
-// Create the string setting the height to be 12-point (240 twips) and 
-// displaying the characters in black. The text is not indented or offset.
+	/**
+	 * Gets the location of the start of the text relative to the bottom edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @return the location of the text relative to the bottom of the bounding
+	 *         rectangle.
+	 */
+	public int getOffsetY()
+	{
+		return offsetY;
+	}
 
-int fontSize = 240;
-int yOffset = 240;
+	/**
+	 * Gets the height of the text.
+	 * 
+	 * @return the height of the font used to displayed the text.
+	 */
+	public int getHeight()
+	{
+		return height;
+	}
 
-FSText string1 = new FSText(font.getIdentifier(), FSColorTable.black(), 0, yOffset, fontSize, line1);
+	/**
+	 * Sets the identifier of the font in which the text will be displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the identifier of the font that the text will be rendered in.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
+	/**
+	 * Sets the colour of the font in which the text will be displayed.
+	 * 
+	 * @param aColor
+	 *            the colour of the text.
+	 */
+	public void setColor(FSColor aColor)
+	{
+		color = aColor;
+	}
 
-ArrayList line1 = new ArrayList();
+	/**
+	 * Sets the location of the start of the text relative to the left edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @param xOffset
+	 *            the location of the text relative to the left edge of the
+	 *            bounding rectangle enclosing the text.
+	 */
+	public void setOffsetX(int xOffset)
+	{
+		offsetX = xOffset;
+	}
 
-line2.add(new FSCharacter(19, 120)); // 's'
-line2.add(new FSCharacter(10, 120)); // 't'
-line2.add(new FSCharacter(18, 120)); // 'r'
-line2.add(new FSCharacter(9, 120));  // 'i'
-line2.add(new FSCharacter(14, 120)); // 'n'
-line2.add(new FSCharacter(6, 120));  // 'g'
-line2.add(new FSCharacter(0, 120));  // ' '
-line2.add(new FSCharacter(29, 120));  // '2'
+	/**
+	 * Sets the location of the start of the text relative to the bottom edge of
+	 * the bounding rectangle in twips.
+	 * 
+	 * @param yOffset
+	 *            the location of the text relative to the bottom edge of the
+	 *            bounding rectangle enclosing the text.
+	 */
+	public void setOffsetY(int yOffset)
+	{
+		offsetY = yOffset;
+	}
 
-// Display the second string 'one line' height (240 twips) below the first. 
-// The font size and colour remain unchanged.
+	/**
+	 * Sets the height of the text.
+	 * 
+	 * @param aHeight
+	 *            the height of the text in the chosen font.
+	 */
+	public void setHeight(int aHeight)
+	{
+		height = aHeight;
+	}
 
-yOffset += fontSize;
+	/**
+	 * Adds an FSCharacter object to the array of characters.
+	 * 
+	 * @param aCharacter
+	 *            an FSCharacter object.
+	 */
+	public void add(FSCharacter aCharacter)
+	{
+		characters.add(aCharacter);
+	}
 
-FSText string2 = new FSText(0, yOffset, line2);
-&lt;/pre&gt;
+	/**
+	 * Gets the array of characters to be displayed.
+	 * 
+	 * @return the array of FSCharacter objects.
+	 */
+	public ArrayList getCharacters()
+	{
+		return characters;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the array of characters to be displayed.
+	 * 
+	 * @param anArray
+	 *            an array of FSCharacter objects.
+	 */
+	public void setCharacters(ArrayList anArray)
+	{
+		characters = anArray;
+	}
 
-&lt;p&gt;The FSText class represents both the TextRecordType0 and TextRecordType1 
-structures from the Macromedia Flash (SWF) File Format Specification. It was 
-introduced in Flash 1.&lt;/p&gt; 
- */
-public class FSText extends FSTransformObject
-{
-    /** Defines that the font character set is based on the Unicode standard. */
-    public static final int Unicode = 0;
-    /** Defines that the font character set is based on the SJIS standard for representing Kanji characters. */
-    public static final int SJIS = 2;
-    /** Defines that the font character set is based on the ANSI UTF-8 standard which supports standard ASCII encoded strings. */
-    public static final int ANSI = 1;
+	int glyphBits()
+	{
+		int numberOfBits = 0;
 
-// Flash 6
-    /// Code used to identify the spoken language for Latin fonts.
-    public static final int Latin = 1;
-    /// Code used to identify the spoken language for Japanese fonts.   
-    public static final int Japanese = 2;
-    /// Code used to identify the spoken language for Japanese fonts.   
-    public static final int Korean = 3;
-    /// Code used to identify the spoken language for simplified Chinese fonts.    
-    public static final int SimplifiedChinese = 4;
-    /// Code used to identify the spoken language for traditional Chinese fonts.  
-    public static final int TraditionalChinese = 5;
-// End Flash 6
-          
-    private int identifier = 0;
-    private FSColor color = null;
-    private int offsetX = Transform.VALUE_NOT_SET;
-    private int offsetY = Transform.VALUE_NOT_SET;
-    private int height = 0;
+		for (Iterator charIter = characters.iterator(); charIter.hasNext();)
+			numberOfBits = Math.max(numberOfBits, FSCoder.size(
+							((FSCharacter) charIter.next()).getGlyphIndex(),
+							false));
 
-    private ArrayList characters = new ArrayList();
+		return numberOfBits;
+	}
 
-    /**
-     * Construct an FSText object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSText(FSCoder coder)
-    {
-        decode(coder);
-    }
-    /**
-     * Constructs an FSText object specifying the array of characters to be displayed and their 
-     * relative placement within a block of text. The selected font, colour of the text and height 
-     * will remain unchanged from previous settings.
+	int advanceBits()
+	{
+		int numberOfBits = 0;
 
-        @param xOffset the location of the text relative to the left edge of the bounding rectangle 
-        enclosing the block of text.
-        @param yOffset the location of the text relative to the bottom edge of the bounding rectangle 
-        enclosing the block of text.
-        @param anArray an array of FSCharacter objects.
-        */
-    public FSText(int xOffset, int yOffset, ArrayList anArray)
-    {
-        setOffsetX(xOffset);
-        setOffsetY(yOffset);
-        setCharacters(anArray);
-    }
+		for (Iterator charIter = characters.iterator(); charIter.hasNext();)
+			numberOfBits = Math
+							.max(
+											numberOfBits,
+											FSCoder
+															.size(
+																			((FSCharacter) charIter
+																							.next())
+																							.getAdvance(),
+																			true));
 
-    /** Constructs an FSText object, specifying the colour and position of the following FSText.
+		return numberOfBits;
+	}
 
-        @param anIdentifier the identifier of the font that the text will be rendered in.
-        @param aColor the colour of the text.
-        @param xOffset the location of the text relative to the left edge of the bounding rectangle 
-        enclosing the text.
-        @param yOffset the location of the text relative to the bottom edge of the bounding rectangle 
-        enclosing the text.
-        @param aHeight the height of the text in the chosen font.
-        @param anArray an array of FSCharacter objects.
-        */
-    public FSText(int anIdentifier, FSColor aColor, int xOffset, int yOffset, int aHeight, ArrayList anArray)
-    {
-        setIdentifier(anIdentifier);
-        setColor(aColor);
-        setOffsetX(xOffset);
-        setOffsetY(yOffset);
-        setHeight(aHeight);
-        setCharacters(anArray);
-    }
-    /**
-     * Constructs an FSText object by copying values from an existing object.
-     *
-     * @param obj an FSText object.
-     */
-    public FSText(FSText obj)
-    {
-        identifier = obj.identifier;
-        color = new FSColor(obj.color);
-        offsetX = obj.offsetX;
-        offsetY = obj.offsetY;
-        height = obj.height;
-        
-        characters = new ArrayList(obj.characters.size());
-        
-        for (Iterator i = obj.characters.iterator(); i.hasNext();)
-            characters.add(((FSCharacter)i.next()).clone());
-    }    
+	public Object clone()
+	{
+		FSText anObject = (FSText) super.clone();
 
-    /** Gets the identifier of the font in which the text will be displayed.
+		anObject.color = (color != null) ? (FSColor) color.clone() : null;
 
-     @return the identifier of the font.
-     */
-    public int getIdentifier() { return identifier; }
+		anObject.characters = new ArrayList();
 
-    /** Gets the colour of the font in which the text will be displayed.
+		for (Iterator i = characters.iterator(); i.hasNext();)
+			anObject.characters.add(((FSCharacter) i.next()).clone());
 
-        @return the colour of the text.
-        */
-    public FSColor  getColor() { return color; }
+		return anObject;
+	}
 
-    /** Gets the location of the start of the text relative to the left edge of the bounding rectangle in twips.
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        @return the indentation applied to the text.
-        */
-    public int getOffsetX() { return offsetX; }
+		if (super.equals(anObject))
+		{
+			FSText typedObject = (FSText) anObject;
 
-    /** Gets the location of the start of the text relative to the bottom edge of the bounding rectangle in twips.
+			result = identifier == typedObject.identifier;
 
-        @return the location of the text relative to the bottom of the bounding rectangle.
-        */
-    public int getOffsetY() { return offsetY; }
+			if (color != null)
+				result = result &amp;&amp; color.equals(typedObject.color);
+			else
+				result = result &amp;&amp; color == typedObject.color;
 
-    /** Gets the height of the text.
+			result = result &amp;&amp; offsetX == typedObject.offsetX;
+			result = result &amp;&amp; offsetY == typedObject.offsetY;
+			result = result &amp;&amp; height == typedObject.height;
 
-        @return the height of the font used to displayed the text.
-        */
-    public int getHeight() 
-    { 
-        return height; 
-    }
+			if (characters != null)
+				result = characters.equals(typedObject.characters);
+			else
+				result = characters == typedObject.characters;
+		}
+		return result;
+	}
 
-    /** Sets the identifier of the font in which the text will be displayed.
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-        @param anIdentifier the identifier of the font that the text will be rendered in.
-        */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;color&quot;, color, depth);
+			Transform.append(buffer, &quot;offsetX&quot;, offsetX);
+			Transform.append(buffer, &quot;offsetY&quot;, offsetY);
+			Transform.append(buffer, &quot;height&quot;, height);
+			Transform.append(buffer, &quot;characters&quot;, characters, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-    /** Sets the colour of the font in which the text will be displayed.
+	public int length(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsOffsetX = containsOffsetX();
+		boolean _containsOffsetY = containsOffsetY();
 
-        @param aColor the colour of the text.
-        */
-    public void setColor(FSColor aColor)
-    {
-        color = aColor;
-    }
+		int length = 1;
 
-    /** Sets the location of the start of the text relative to the left edge of the bounding rectangle in twips.
+		if (containsStyle())
+		{
+			length += (_containsFont) ? 2 : 0;
+			length += (_containsColor) ? color.length(coder) : 0;
+			length += (_containsOffsetY) ? 2 : 0;
+			length += (_containsOffsetX) ? 2 : 0;
+			length += (_containsFont) ? 2 : 0;
+		}
 
-        @param xOffset the location of the text relative to the left edge of the bounding rectangle enclosing the text.
-        */
-    public void setOffsetX(int xOffset)
-    {
-        offsetX = xOffset;
-    }
+		length += 1;
 
-    /** Sets the location of the start of the text relative to the bottom edge of the bounding rectangle in twips.
+		if (characters.size() &gt; 0)
+		{
+			int numberOfBits = 0;
+			int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
+			int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
 
-        @param yOffset the location of the text relative to the bottom edge of the bounding rectangle enclosing the text.
-        */
-    public void setOffsetY(int yOffset)
-    {
-        offsetY = yOffset;
-    }
+			numberOfBits = (numberOfGlyphBits + numberOfAdvanceBits)
+							* characters.size();
+			numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
 
-    /** Sets the height of the text.
+			length += numberOfBits &gt;&gt; 3;
+		}
+		return length;
+	}
 
-        @param aHeight the height of the text in the chosen font.
-        */
-    public void setHeight(int aHeight)
-    {
-        height = aHeight;
-    }
+	public void encode(FSCoder coder)
+	{
+		boolean _containsFont = containsFont();
+		boolean _containsColor = containsColor();
+		boolean _containsOffsetY = containsOffsetY();
+		boolean _containsOffsetX = containsOffsetX();
 
-    /** Adds an FSCharacter object to the array of characters.
+		coder.writeBits(1, 1);
+		coder.writeBits(0, 3);
 
-        @param aCharacter an FSCharacter object.
-        */
-    public void add(FSCharacter aCharacter)
-    {
-        characters.add(aCharacter);
-    }
+		coder.writeBits(_containsFont ? 1 : 0, 1);
+		coder.writeBits(_containsColor ? 1 : 0, 1);
+		coder.writeBits(_containsOffsetY ? 1 : 0, 1);
+		coder.writeBits(_containsOffsetX ? 1 : 0, 1);
 
-    /** Gets the array of characters to be displayed.
+		if (_containsFont)
+			coder.writeWord(identifier, 2);
 
-        @return the array of FSCharacter objects.
-        */
-    public ArrayList getCharacters() { return characters; }
+		if (_containsColor)
+			color.encode(coder);
 
-    /** Sets the array of characters to be displayed.
+		if (_containsOffsetX)
+			coder.writeWord(offsetX, 2);
 
-        @param anArray an array of FSCharacter objects.
-        */
-    public void setCharacters(ArrayList anArray)
-    {
-        characters = anArray;
-    }
-    
-    int glyphBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator charIter = characters.iterator(); charIter.hasNext();) 
-            numberOfBits = Math.max(numberOfBits, FSCoder.size(((FSCharacter)charIter.next()).getGlyphIndex(), false));
-        
-        return numberOfBits;
-    }
+		if (_containsOffsetY)
+			coder.writeWord(offsetY, 2);
 
-    int advanceBits()
-    {
-        int numberOfBits = 0;
-        
-        for (Iterator charIter = characters.iterator(); charIter.hasNext();) 
-            numberOfBits = Math.max(numberOfBits, FSCoder.size(((FSCharacter)charIter.next()).getAdvance(), true));
-        
-        return numberOfBits;
-    }
+		if (_containsFont)
+			coder.writeWord(height, 2);
 
-    public Object clone()
-    {
-        FSText anObject = (FSText)super.clone();
-        
-        anObject.color = (color != null) ? (FSColor)color.clone() : null;
+		coder.writeWord(characters.size(), 1);
 
-        anObject.characters = new ArrayList();
-        
-        for (Iterator i = characters.iterator(); i.hasNext();)
-            anObject.characters.add(((FSCharacter)i.next()).clone());
+		for (Iterator charIter = characters.iterator(); charIter.hasNext();)
+			((FSTransformObject) charIter.next()).encode(coder);
 
-        return anObject;
-    }
+		coder.alignToByte();
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSText typedObject = (FSText)anObject;
-            
-            result = identifier == typedObject.identifier;
+	public void decode(FSCoder coder)
+	{
+		/* type */coder.readBits(1, false);
+		/* reserved */coder.readBits(3, false);
 
-            if (color != null)
-                result = result &amp;&amp; color.equals(typedObject.color);
-            else
-                result = result &amp;&amp; color == typedObject.color;
+		boolean _containsFont = coder.readBits(1, false) != 0 ? true : false;
+		boolean _containsColor = coder.readBits(1, false) != 0 ? true : false;
+		boolean _containsOffsetY = coder.readBits(1, false) != 0 ? true : false;
+		boolean _containsOffsetX = coder.readBits(1, false) != 0 ? true : false;
 
-            result = result &amp;&amp; offsetX == typedObject.offsetX;
-            result = result &amp;&amp; offsetY == typedObject.offsetY;
-            result = result &amp;&amp; height == typedObject.height;
+		if (_containsFont)
+			identifier = coder.readWord(2, false);
 
-            if (characters != null)
-                result = characters.equals(typedObject.characters);
-            else
-                result = characters == typedObject.characters;
-        }
-        return result;
-    }
+		if (_containsColor)
+			color = new FSColor(coder);
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;color&quot;, color, depth);
-            Transform.append(buffer, &quot;offsetX&quot;, offsetX);
-            Transform.append(buffer, &quot;offsetY&quot;, offsetY);
-            Transform.append(buffer, &quot;height&quot;, height);
-            Transform.append(buffer, &quot;characters&quot;, characters, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+		if (_containsOffsetX)
+			offsetX = coder.readWord(2, true);
 
-    public int length(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsOffsetX = containsOffsetX();
-        boolean _containsOffsetY = containsOffsetY();
-        
-        int length = 1;
-    
-        if (containsStyle())
-        {
-            length += (_containsFont) ? 2 : 0;
-            length += (_containsColor) ? color.length(coder) : 0;
-            length += (_containsOffsetY) ? 2 : 0;
-            length += (_containsOffsetX) ? 2 : 0;
-            length += (_containsFont) ? 2 : 0;
-        }
-        
-        length += 1;
+		if (_containsOffsetY)
+			offsetY = coder.readWord(2, true);
 
-        if (characters.size() &gt; 0)
-        {
-            int numberOfBits = 0;
-            int numberOfGlyphBits = coder.context[FSCoder.NumberOfGlyphBits];
-            int numberOfAdvanceBits = coder.context[FSCoder.NumberOfAdvanceBits];
-            
-            numberOfBits = (numberOfGlyphBits + numberOfAdvanceBits)*characters.size();
-            numberOfBits += (numberOfBits % 8 &gt; 0) ? 8 - (numberOfBits % 8) : 0;
+		if (_containsFont)
+			height = coder.readWord(2, false);
 
-            length += numberOfBits &gt;&gt; 3;
-        }
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        boolean _containsFont = containsFont();
-        boolean _containsColor = containsColor();
-        boolean _containsOffsetY = containsOffsetY();
-        boolean _containsOffsetX = containsOffsetX();
+		int charCount = coder.readWord(1, false);
 
-        coder.writeBits(1, 1);
-        coder.writeBits(0, 3);
+		characters = new ArrayList(charCount);
 
-        coder.writeBits(_containsFont ? 1 : 0, 1);
-        coder.writeBits(_containsColor ? 1 : 0, 1);
-        coder.writeBits(_containsOffsetY ? 1 : 0, 1);
-        coder.writeBits(_containsOffsetX ? 1 : 0, 1);
-    
-        if (_containsFont)
-            coder.writeWord(identifier, 2);
-    
-        if (_containsColor)
-            color.encode(coder);
-    
-        if (_containsOffsetX)
-            coder.writeWord(offsetX, 2);
-    
-        if (_containsOffsetY)
-            coder.writeWord(offsetY, 2);
-    
-        if (_containsFont)
-            coder.writeWord(height, 2);
+		for (int i = 0; i &lt; charCount; i++)
+			characters.add(new FSCharacter(coder));
 
-        coder.writeWord(characters.size(), 1);
-        
-        for (Iterator charIter = characters.iterator(); charIter.hasNext();) 
-            ((FSTransformObject)charIter.next()).encode(coder);
-            
-        coder.alignToByte();
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        /* type */ coder.readBits(1, false);
-        /* reserved */ coder.readBits(3, false);
-        
-        boolean _containsFont = coder.readBits(1, false) != 0 ? true : false;
-        boolean _containsColor = coder.readBits(1, false) != 0 ? true : false;
-        boolean _containsOffsetY = coder.readBits(1, false) != 0 ? true : false;
-        boolean _containsOffsetX = coder.readBits(1, false) != 0 ? true : false;
+		coder.alignToByte();
+	}
 
-        if (_containsFont)
-            identifier = coder.readWord(2, false);
+	private boolean containsFont()
+	{
+		return identifier != 0 &amp;&amp; height != 0;
+	}
 
-        if (_containsColor)
-            color = new FSColor(coder);
+	private boolean containsColor()
+	{
+		return color != null;
+	}
 
-        if (_containsOffsetX)
-            offsetX = coder.readWord(2, true);
+	private boolean containsOffsetX()
+	{
+		return offsetX != Transform.VALUE_NOT_SET;
+	}
 
-        if (_containsOffsetY)
-            offsetY = coder.readWord(2, true);
+	private boolean containsOffsetY()
+	{
+		return offsetY != Transform.VALUE_NOT_SET;
+	}
 
-        if (_containsFont)
-            height = coder.readWord(2, false);
+	boolean containsStyle()
+	{
+		return containsFont() || containsColor() || containsOffsetX()
+						|| containsOffsetY();
+	}
 
-        int charCount = coder.readWord(1, false);
-        
-        characters = new ArrayList(charCount);
-
-        for (int i=0; i&lt;charCount; i++)
-            characters.add(new FSCharacter(coder));
-        
-        coder.alignToByte();
-    }
-    
-    private boolean containsFont()
-    {
-        return identifier != 0 &amp;&amp; height != 0;
-    }
-
-    private boolean containsColor()
-    {
-        return color != null;
-    }
-
-    private boolean containsOffsetX()
-    {
-        return offsetX != Transform.VALUE_NOT_SET;
-    }
-
-    private boolean containsOffsetY()
-    {
-        return offsetY != Transform.VALUE_NOT_SET;
-    }
-
-    boolean containsStyle()
-    {
-        return containsFont() || containsColor() || containsOffsetX() || containsOffsetY();
-    }
-    
 }

Modified: trunk/src/com/flagstone/transform/FSTransformObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSTransformObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSTransformObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -30,105 +30,113 @@
 
 package com.flagstone.transform;
 
-/** 
- * The FSTransformObject object defines the basic set of method that an object must implement 
- * if it can used to represent the data structures that make up the Flash File Format
- * specification.
+/**
+ * The FSTransformObject object defines the basic set of method that an object
+ * must implement if it can used to represent the data structures that make up
+ * the Flash File Format specification.
  * 
- * Sub-classes can be used to represent either one of the tagged data structures 
+ * Sub-classes can be used to represent either one of the tagged data structures
  * such as PlaceObject and added directly to an FSMovie or one of the data-types
  * that the objects contain e.g. a colour.
- *
- * In addition to the methods directly relating to the coding of the object to and from the 
- * binary data representation that comprises the Flash File Format specification the class
- * also includes a common set of methods used when validating or reporting the state of 
- * individual objects.
+ * 
+ * In addition to the methods directly relating to the coding of the object to
+ * and from the binary data representation that comprises the Flash File Format
+ * specification the class also includes a common set of methods used when
+ * validating or reporting the state of individual objects.
  */
 public abstract class FSTransformObject extends Object implements Cloneable
 {
-    /** 
-     * Return the name of the class without the package prefix. This method is used when 
-      * logging events to identify the object being encoded or decoded.
-     *
-     * @return the name of the class, e.g. FSDefineShape.
-     */
-    public String name()
-    {
-        String className = getClass().getName();
-        int index = className.lastIndexOf(&quot;.&quot;)+1;
+	/**
+	 * Return the name of the class without the package prefix. This method is
+	 * used when logging events to identify the object being encoded or decoded.
+	 * 
+	 * @return the name of the class, e.g. FSDefineShape.
+	 */
+	public String name()
+	{
+		String className = getClass().getName();
+		int index = className.lastIndexOf(&quot;.&quot;) + 1;
 
-        return className.substring(index, className.length());
-    }
-   
-    /** 
-     * Returns true if anObject is equal to this one. Objects are considered 
-     * equal if they would generate identical binary data when they are encoded 
-     * to a Flash file.
-     *
-     * @return true if this object would be identical to anObject when encoded.
-     */
-    public boolean equals(Object anObject)
-    {
-        return getClass().isInstance(anObject);
-    }
+		return className.substring(index, className.length());
+	}
 
-    /** Creates a deep copy of the entire object.
+	/**
+	 * Returns true if anObject is equal to this one. Objects are considered
+	 * equal if they would generate identical binary data when they are encoded
+	 * to a Flash file.
+	 * 
+	 * @return true if this object would be identical to anObject when encoded.
+	 */
+	public boolean equals(Object anObject)
+	{
+		return getClass().isInstance(anObject);
+	}
 
-        @return a copy of the object.
-        */
-    public Object clone()
-    {
-        Object anObject = null;
-        
-        try 
-        {
-           anObject = super.clone();
-        }
-        catch (CloneNotSupportedException e)
-        {
-           throw new InternalError();
-         }
-        return anObject;
-       }
+	/**
+	 * Creates a deep copy of the entire object.
+	 * 
+	 * @return a copy of the object.
+	 */
+	public Object clone()
+	{
+		Object anObject = null;
 
-    /**
-     * Generates a string representation of the event object.
-     * 
-     * This method calls appendDescription with the level set to 2 which will displays the 
-     * contents of the first level of nested objects (level 1 will only show the type of 
-     * any nested objects).
-     * 
-     * @return a string reporting the values in the attributes.
-     */
-    public String toString()
-    {
-           StringBuffer buffer = new StringBuffer();
-        
-           appendDescription(buffer, 2);
-        
-           return buffer.toString();
-       }
+		try
+		{
+			anObject = super.clone();
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
+		return anObject;
+	}
 
-   /** 
-    * AppendDescription is used to present a string description of the object including
-    * all nested objects up to a specified depth. This method provide a more controlled
-    * way of creating a string representation of an object since large objects such as 
-    * font or shape definitions can contain dozens of nested objects.
-    *
-    * The representation of the object is appended to the StringBuffer, showing the 
-    * name of the class and values of the attributes it contains. If the object contains 
-    * any attributes that are objects then the object graph will be traversed up to the
-    * specified depth. If objects are nested at a level less than specified depth then
-    * the full string representation of the object is displayed. For objects at the 
-    * specified depth only the name of the class is displayed. Any objects below this 
-    * depth are not displayed.    
-    *
-    * @param buffer a StringBuffer to which the description of each object is appended.
-    * @param depth the maximum level of nesting up to which objects will be displayed. 
-    */
-    public abstract void appendDescription(StringBuffer buffer, int depth);
-    
-    abstract public int length(FSCoder coder);
-    abstract public void encode(FSCoder coder);
-    abstract public void decode(FSCoder coder);
+	/**
+	 * Generates a string representation of the event object.
+	 * 
+	 * This method calls appendDescription with the level set to 2 which will
+	 * displays the contents of the first level of nested objects (level 1 will
+	 * only show the type of any nested objects).
+	 * 
+	 * @return a string reporting the values in the attributes.
+	 */
+	public String toString()
+	{
+		StringBuffer buffer = new StringBuffer();
+
+		appendDescription(buffer, 2);
+
+		return buffer.toString();
+	}
+
+	/**
+	 * AppendDescription is used to present a string description of the object
+	 * including all nested objects up to a specified depth. This method provide
+	 * a more controlled way of creating a string representation of an object
+	 * since large objects such as font or shape definitions can contain dozens
+	 * of nested objects.
+	 * 
+	 * The representation of the object is appended to the StringBuffer, showing
+	 * the name of the class and values of the attributes it contains. If the
+	 * object contains any attributes that are objects then the object graph
+	 * will be traversed up to the specified depth. If objects are nested at a
+	 * level less than specified depth then the full string representation of
+	 * the object is displayed. For objects at the specified depth only the name
+	 * of the class is displayed. Any objects below this depth are not
+	 * displayed.
+	 * 
+	 * @param buffer
+	 *            a StringBuffer to which the description of each object is
+	 *            appended.
+	 * @param depth
+	 *            the maximum level of nesting up to which objects will be
+	 *            displayed.
+	 */
+	public abstract void appendDescription(StringBuffer buffer, int depth);
+
+	abstract public int length(FSCoder coder);
+
+	abstract public void encode(FSCoder coder);
+
+	abstract public void decode(FSCoder coder);
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSUnknownAction.java
===================================================================
--- trunk/src/com/flagstone/transform/FSUnknownAction.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSUnknownAction.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,140 +31,162 @@
 package com.flagstone.transform;
 
 /**
-FSUnknownAction class is used to represent any action decoded from a Flash file that 
- is currently not supported by the framework. 
- 
-&lt;p&gt;This allows Flash files to be parsed, processed and encoded without affecting any of the actions not directly supported.&lt;/p&gt;
+ * FSUnknownAction class is used to represent any action decoded from a Flash
+ * file that is currently not supported by the framework.
+ * 
+ * &lt;p&gt;
+ * This allows Flash files to be parsed, processed and encoded without affecting
+ * any of the actions not directly supported.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;The value used to identify the type of action. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;data&lt;/td&gt;
+ * &lt;td&gt;The encoded bytes that make up the body of the action's data structure.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The object provides direct access to the encoded data of the action offering
+ * the possibility to encode and decode actions that are not directly supported
+ * in the current release of the framework. However a detailed knowledge of how
+ * the action is encoded and decoded is required.
+ * &lt;/p&gt;
+ */
+public class FSUnknownAction extends FSActionObject
+{
+	private byte[] data = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSUnknownAction object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSUnknownAction(FSCoder coder)
+	{
+		super(0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSUnknownAction object of the specified type with the
+	 * encoded Flash data.
+	 * 
+	 * @param aType
+	 *            the code identifying the action type.
+	 * @param bytes
+	 *            the encoded data for the action.
+	 */
+	public FSUnknownAction(int aType, byte[] bytes)
+	{
+		super(aType);
+		data = bytes;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSUnknownAction_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The value used to identify the type of action. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSUnknownAction object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSUnknownAction object.
+	 */
+	public FSUnknownAction(FSUnknownAction obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSUnknownAction_1&quot;&gt;data&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded bytes that make up the body of the action's data structure.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		if (obj.data != null)
+			data = Transform.clone(obj.data);
+	}
 
-&lt;p&gt;The object provides direct access to the encoded data of the action offering the possibility to encode and decode actions that are not directly supported in the current release of the framework. However a detailed knowledge of how the action is encoded and decoded is required.&lt;/p&gt;
- */
-public class FSUnknownAction extends FSActionObject
-{
-    private byte[] data = null;
-    
-    /**
-     * Construct an FSUnknownAction object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSUnknownAction(FSCoder coder)
-    {
-        super(0);
-        decode(coder);
-    }
-    /** Constructs an FSUnknownAction object of the specified type with the encoded Flash data.
+	/**
+	 * Gets the encoded data for the action.
+	 * 
+	 * @return an array of bytes representing the action data when encoded to a
+	 *         Flash file.
+	 */
+	public byte[] getData()
+	{
+		return data;
+	}
 
-        @param aType the code identifying the action type.
-        @param bytes the encoded data for the action.
-        */
-    public FSUnknownAction(int aType, byte[] bytes)
-    {
-        super(aType);
-        data = bytes;
-    }
-    /**
-     * Constructs an FSUnknownAction object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSUnknownAction object.
-     */
-    public FSUnknownAction(FSUnknownAction obj)
-    {
-        super(obj);
-        
-        if (obj.data != null)
-            data = Transform.clone(obj.data);
-    }    
+	/**
+	 * Sets the encoded data for the action.
+	 * 
+	 * @param bytes
+	 *            the encoded data for the action.
+	 */
+	public void setData(byte[] bytes)
+	{
+		data = bytes;
+	}
 
-    /** Gets the encoded data for the action.
+	public Object clone()
+	{
+		FSUnknownAction anObject = (FSUnknownAction) super.clone();
 
-        @return an array of bytes representing the action data when encoded to a Flash file.
-        */
-    public byte[] getData()
-    {
-        return data;
-    }
+		anObject.data = Transform.clone(data);
 
-    /** Sets the encoded data for the action.
+		return anObject;
+	}
 
-        @param bytes the encoded data for the action.
-        */
-    public void setData(byte[] bytes)
-    {
-        data = bytes;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public Object clone()
-    {
-        FSUnknownAction anObject = (FSUnknownAction)super.clone();
-        
-        anObject.data = Transform.clone(data);
-    
-        return anObject;
-    }
+		if (super.equals(anObject))
+		{
+			FSUnknownAction typedObject = (FSUnknownAction) anObject;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSUnknownAction typedObject = (FSUnknownAction)anObject;
-            
-            result = Transform.equals(data, typedObject.data);
-        }
-        return result;
-    }
+			result = Transform.equals(data, typedObject.data);
+		}
+		return result;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += data.length;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(data);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        if (length &gt; 0)
-        {
-            data = new byte[length];
-            coder.readBytes(data);
-        }
-        else
-            data = new byte[] {};
+		length += data.length;
 
-        coder.endObject(name());
-    }
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(data);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		if (length &gt; 0)
+		{
+			data = new byte[length];
+			coder.readBytes(data);
+		} else
+			data = new byte[]
+			{};
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSUnknownObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSUnknownObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSUnknownObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,133 +31,155 @@
 package com.flagstone.transform;
 
 /**
-FSUnknownObject is used to represent any data structure decoded from a Flash file that 
- is currently not supported by the framework.
- 
-&lt;p&gt;This allows Flash files to be parsed, processed and encoded without affecting any of the data structures not directly supported.&lt;/p&gt;
+ * FSUnknownObject is used to represent any data structure decoded from a Flash
+ * file that is currently not supported by the framework.
+ * 
+ * &lt;p&gt;
+ * This allows Flash files to be parsed, processed and encoded without affecting
+ * any of the data structures not directly supported.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;data&lt;/td&gt;
+ * &lt;td&gt;The encoded bytes that make up the body of the data structure.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The object provides direct access to the encoded data of the data structure
+ * offering the possibility for Transform to encode and decode tags that are not
+ * directly supported in the current release of the package. However a detailed
+ * knowledge of how the data structure is encoded and decoded is required.
+ * &lt;/p&gt;
+ */
+public class FSUnknownObject extends FSMovieObject
+{
+	private byte[] data = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSUnknownObject object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSUnknownObject(FSCoder coder)
+	{
+		super(0);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSUnknownObject object of the specified type with the
+	 * encoded Flash data.
+	 * 
+	 * @param aType
+	 *            the code identifying the tag type.
+	 * @param bytes
+	 *            the encoded data for the tag.
+	 */
+	public FSUnknownObject(int aType, byte[] bytes)
+	{
+		super(aType);
+		setData(bytes);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSUnknownObject_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSUnknownObject object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSUnknownObject object.
+	 */
+	public FSUnknownObject(FSUnknownObject obj)
+	{
+		super(obj);
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSUnknownObject_1&quot;&gt;data&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded bytes that make up the body of the data structure.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+		if (obj.data != null)
+			data = Transform.clone(obj.data);
+	}
 
-&lt;p&gt;The object provides direct access to the encoded data of the data structure offering the possibility for Transform to encode and decode tags that are not directly supported in the current release of the package. However a detailed knowledge of how the data structure is encoded and decoded is required.&lt;/p&gt;
- */
-public class FSUnknownObject extends FSMovieObject
-{
-    private byte[] data = null;
-    
-    /**
-     * Construct an FSUnknownObject object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSUnknownObject(FSCoder coder)
-    {
-        super(0);
-        decode(coder);
-    }
-    /** Constructs an FSUnknownObject object of the specified type with the encoded Flash data.
+	/**
+	 * Gets the encoded data for the tag.
+	 * 
+	 * @return an array of bytes representing the tag data when encoded to a
+	 *         Flash file.
+	 */
+	public byte[] getData()
+	{
+		return data;
+	}
 
-        @param aType the code identifying the tag type.
-        @param bytes the encoded data for the tag.
-        */
-    public FSUnknownObject(int aType, byte[] bytes)
-    {
-        super(aType);
-        setData(bytes);
-    }
-    /**
-     * Constructs an FSUnknownObject object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSUnknownObject object.
-     */
-    public FSUnknownObject(FSUnknownObject obj)
-    {
-        super(obj);
-        
-        if (obj.data != null)
-            data = Transform.clone(obj.data);
-    }    
+	/**
+	 * Sets the encoded data for the tag.
+	 * 
+	 * @param bytes
+	 *            the encoded data for the tag.
+	 */
+	public void setData(byte[] bytes)
+	{
+		data = bytes;
+	}
 
-    /** Gets the encoded data for the tag.
+	public Object clone()
+	{
+		FSUnknownObject anObject = (FSUnknownObject) super.clone();
 
-        @return an array of bytes representing the tag data when encoded to a Flash file.
-        */
-    public byte[] getData()
-    {
-        return data;
-    }
+		anObject.data = Transform.clone(data);
 
-    /** Sets the encoded data for the tag.
+		return anObject;
+	}
 
-        @param bytes the encoded data for the tag.
-        */
-    public void setData(byte[] bytes)
-    {
-        data = bytes;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    public Object clone()
-    {
-        FSUnknownObject anObject = (FSUnknownObject)super.clone();
-        
-        anObject.data = Transform.clone(data);
+		if (super.equals(anObject))
+		{
+			FSUnknownObject typedObject = (FSUnknownObject) anObject;
 
-        return anObject;
-    }
+			result = Transform.equals(data, typedObject.data);
+		}
+		return result;
+	}
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSUnknownObject typedObject = (FSUnknownObject)anObject;
-            
-            result = Transform.equals(data, typedObject.data);
-        }
-        return result;
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
-    
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += data.length;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeBytes(data);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        data = new byte[length];
-        coder.readBytes(data);
-        coder.endObject(name());
-    }
+		length += data.length;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeBytes(data);
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		data = new byte[length];
+		coder.readBytes(data);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSVideo.java
===================================================================
--- trunk/src/com/flagstone/transform/FSVideo.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSVideo.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,68 +33,73 @@
 import java.util.zip.*;
 import java.io.*;
 
-/** 
- * FSVideo is a container class for the objects that represents the data 
- * structures in a Flash video file. It is very similar to the FSMovie class
- * for flash (.swf) files and provides a simple API for decoding and encoding 
- * files and accessing the objects that represent the different data structures
- * used for audio and video data.
- */ 
+/**
+ * FSVideo is a container class for the objects that represents the data
+ * structures in a Flash video file. It is very similar to the FSMovie class for
+ * flash (.swf) files and provides a simple API for decoding and encoding files
+ * and accessing the objects that represent the different data structures used
+ * for audio and video data.
+ */
 public final class FSVideo implements Cloneable
 {
-    /** 
-     * Indicates that the video data was encoded using the Sorenson
-     * modified H263 format.
-     */
-    public static final int H263 = 2;
-    /** 
-     * Indicates that the video data was encoded using Macromedia's 
-     * ScreenVideo format.
-     */
-    public static final int ScreenVideo = 3;
-    
-    /**
-     * Indicates a frame is a key frame in the video stream.
-     */
-    public static final int KeyFrame = 1;
-    
-    /**
-     * Indicates a frame is a normal frame (one displayed between key frames)
-     * in the video stream.
-     */
-    public static final int Frame = 2;
+	/**
+	 * Indicates that the video data was encoded using the Sorenson modified
+	 * H263 format.
+	 */
+	public static final int H263 = 2;
 
-    /**
-     * Indicates a frame is an optional frame - one that may be deleted to maintain
-     * real-time display of the video stream. Used only with video encoded using
-     * the Sorenson modified H263 format.
-     */
-    public static final int Optional = 3;
-    
-    
-    /*
-     * Index values for the context array in FSVideoCoder.
-     */
+	/**
+	 * Indicates that the video data was encoded using Macromedia's ScreenVideo
+	 * format.
+	 */
+	public static final int ScreenVideo = 3;
+
+	/**
+	 * Indicates a frame is a key frame in the video stream.
+	 */
+	public static final int KeyFrame = 1;
+
+	/**
+	 * Indicates a frame is a normal frame (one displayed between key frames) in
+	 * the video stream.
+	 */
+	public static final int Frame = 2;
+
+	/**
+	 * Indicates a frame is an optional frame - one that may be deleted to
+	 * maintain real-time display of the video stream. Used only with video
+	 * encoded using the Sorenson modified H263 format.
+	 */
+	public static final int Optional = 3;
+
+	/*
+	 * Index values for the context array in FSVideoCoder.
+	 */
 	static final int Action = 0;
+
 	static final int Version = 1;
+
 	static final int Type = 2;
-    static final int Delta = 3;
+
+	static final int Delta = 3;
+
 	static final int Identifier = 4;
+
 	static final int Codec = 5;
-	
-    static FSVideoObject decodeObject(FSCoder coder)
-    {
+
+	static FSVideoObject decodeObject(FSCoder coder)
+	{
 		FSVideoObject currentObject = null;
-        
-        int start = coder.getPointer();
 
+		int start = coder.getPointer();
+
 		int type = coder.readWord(1, false);
 		int length = coder.readWord(3, false) &amp; 0x00FFFFFF;
 		int next = start + ((11 + length) &lt;&lt; 3);
-		
+
 		coder.setPointer(start);
-		
- 		switch (type)
+
+		switch (type)
 		{
 			case FSVideoObject.AudioData:
 				currentObject = new FSAudioData(coder);
@@ -108,217 +113,261 @@
 			default:
 				break;
 		}
-    
-        int delta = next - coder.getPointer();            
-        coder.context[FSVideo.Delta] = delta;
+
+		int delta = next - coder.getPointer();
+		coder.context[FSVideo.Delta] = delta;
 		coder.setPointer(next);
-        
+
 		return currentObject;
-    }
-    
+	}
+
 	private String signature = &quot;FLV&quot;;
-    private int version = 1;
-    private ArrayList objects = new ArrayList();
 
-    /** 
-     * Constructs an FSVideo object with no objects.
-     */
+	private int version = 1;
+
+	private ArrayList objects = new ArrayList();
+
+	/**
+	 * Constructs an FSVideo object with no objects.
+	 */
 	public FSVideo()
 	{
 	}
 
-    /** Constructs an FSVideo object and decodes the contents of the specified file to generate an 
-        array of objects representing the video file. If an error occurs while reading and parsing 
-        the file then an exception is thrown.
-
-        @param fileName the path to the Flash Video file that will be parsed.
-        @throws FileNotFoundException - if an error occurs while reading the file.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the file.
-        */
-	public FSVideo(String fileName) throws FileNotFoundException, IOException, DataFormatException
+	/**
+	 * Constructs an FSVideo object and decodes the contents of the specified
+	 * file to generate an array of objects representing the video file. If an
+	 * error occurs while reading and parsing the file then an exception is
+	 * thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash Video file that will be parsed.
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the file.
+	 */
+	public FSVideo(String fileName) throws FileNotFoundException, IOException,
+					DataFormatException
 	{
 		decodeFromFile(fileName);
 	}
 
-    /** 
-     * Constructs an FSVideo object and decodes the binary data presented in the byte array to generate 
-     * an array of objects representing the Flash Video data. If an error occurs while parsing the data then 
-     * an exception is thrown. 
-     *
-     * @param data an array of bytes containing the Flash Video binary data.
-        @throws DataFormatException - if the file does not contain Flash data.
-        @throws IOException - if an error occurs while reading and decoding the data.
-     */
-    public FSVideo(byte[] data) throws IOException, DataFormatException
+	/**
+	 * Constructs an FSVideo object and decodes the binary data presented in the
+	 * byte array to generate an array of objects representing the Flash Video
+	 * data. If an error occurs while parsing the data then an exception is
+	 * thrown.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the Flash Video binary data.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the data.
+	 */
+	public FSVideo(byte[] data) throws IOException, DataFormatException
 	{
-        decodeFromData(data);
+		decodeFromData(data);
 	}
-    
-    /** Gets the number representing the version of Flash Video that the video represents.
 
-        @return an integer defining the Flash Video version number for the coder.
-        */
-    public int getVersion()
-    {
-        return version;
-    }
+	/**
+	 * Gets the number representing the version of Flash Video that the video
+	 * represents.
+	 * 
+	 * @return an integer defining the Flash Video version number for the coder.
+	 */
+	public int getVersion()
+	{
+		return version;
+	}
 
-	/** Sets the Flash Video version.
-
-		@param aNumber the version of the Flash Video file format that this object utilises.
-		*/
+	/**
+	 * Sets the Flash Video version.
+	 * 
+	 * @param aNumber
+	 *            the version of the Flash Video file format that this object
+	 *            utilises.
+	 */
 	public void setVersion(int aNumber)
 	{
 		version = aNumber;
 	}
 
-    /** Gets the array of video objects.
+	/**
+	 * Gets the array of video objects.
+	 * 
+	 * @return the array of objects.
+	 */
+	public ArrayList getObjects()
+	{
+		return objects;
+	}
 
-        @return the array of objects.
-        */
-    public ArrayList getObjects() { return objects; }
+	/**
+	 * Sets the array of objects contained in the Movie.
+	 * 
+	 * @param anArray
+	 *            the array of objects that describe a coder.
+	 */
+	public void setObjects(ArrayList anArray)
+	{
+		objects = anArray;
+	}
 
-    /** Sets the array of objects contained in the Movie.
+	/**
+	 * Adds the object to the Movie.
+	 * 
+	 * @param anObject
+	 *            the object to be added to the coder.
+	 */
+	public void add(FSVideoObject anObject)
+	{
+		objects.add(anObject);
+	}
 
-        @param anArray the array of objects that describe a coder.
-        */
-    public void setObjects(ArrayList anArray)
-    {
-        objects = anArray;
-    }
+	/**
+	 * Adds the array of object to the Video.
+	 * 
+	 * @param array
+	 *            an array of FSVideoObjects that will be added to the video in
+	 *            the order they are in the array.
+	 */
+	public void add(ArrayList array)
+	{
+		objects.addAll(array);
+	}
 
-    /** Adds the object to the Movie.
+	/**
+	 * Decodes the contents of the specified file. An object for each tag
+	 * decoded from the file is placed in the object array in the order they
+	 * were read from the file. If an error occurs while reading and parsing the
+	 * file then an exception is thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the Flash Video file that will be parsed.
+	 * 
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the file.
+	 */
+	public void decodeFromFile(String fileName) throws FileNotFoundException,
+					DataFormatException, IOException
+	{
+		FileInputStream fileContents = null;
+		File swfFile = new File(fileName);
 
-        @param anObject the object to be added to the coder.
-        */
-    public void add(FSVideoObject anObject)
-    {
-        objects.add(anObject);
-    }
+		fileContents = new FileInputStream(swfFile);
 
-    /** Adds the array of object to the Video.
+		int fileLength = (int) swfFile.length();
+		byte[] contents = new byte[fileLength];
 
-        @param array an array of FSVideoObjects that will be added to the video in the order they are 
-        in the array.
-        */
-    public void add(ArrayList array)
-    {
-        objects.addAll(array);
-    }
+		fileContents.read(contents);
+		fileContents.close();
 
-    /** 
-     * Decodes the contents of the specified file. An object for each tag decoded 
-     * from the file is placed in the object array in the order they were read
-     * from the file. If an error occurs while reading and parsing the file then 
-     * an exception is thrown.
-     *
-     * @param fileName the path to the Flash Video file that will be parsed.
-     * 
-     * @throws FileNotFoundException - if an error occurs while reading the file.
-     * @throws DataFormatException - if the file does not contain Flash data.
-     * @throws IOException - if an error occurs while reading and decoding the file.
-     */
-	public void decodeFromFile(String fileName) throws FileNotFoundException, DataFormatException, IOException
-	{
-        FileInputStream fileContents = null;
-        File swfFile = new File(fileName);
-        
-        fileContents = new FileInputStream(swfFile);
-        
-        int fileLength = (int)swfFile.length();
-        byte[] contents = new byte[fileLength];
-        
-        fileContents.read(contents);
-        fileContents.close();
-        
-        decodeFromData(contents);
-    }
+		decodeFromData(contents);
+	}
 
-   /** 
-    * Decodes the binary Flash Video data stored in the byte array. If an error 
-    * occurs while the data is being decoded an exception is thrown.
-    *
-    * @param bytes an array of bytes that contain the encoded Flash Video objects.
-    *
-    * @throws DataFormatException - if the file does not contain Flash data.
-    * @throws IOException - if an error occurs while reading and decoding the file.
-    */
-	public void decodeFromData(byte[] bytes) throws DataFormatException, IOException
+	/**
+	 * Decodes the binary Flash Video data stored in the byte array. If an error
+	 * occurs while the data is being decoded an exception is thrown.
+	 * 
+	 * @param bytes
+	 *            an array of bytes that contain the encoded Flash Video
+	 *            objects.
+	 * 
+	 * @throws DataFormatException -
+	 *             if the file does not contain Flash data.
+	 * @throws IOException -
+	 *             if an error occurs while reading and decoding the file.
+	 */
+	public void decodeFromData(byte[] bytes) throws DataFormatException,
+					IOException
 	{
-        FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
-        FSVideoObject object = null;
-        
-        boolean containsAudio = false;
-        boolean containsVideo = false;
-        
-        isFlashVideo(bytes);
+		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, bytes);
+		FSVideoObject object = null;
 
-        signature = coder.readString(3, &quot;UTF8&quot;);
-        version = coder.readWord(1, false);
-        coder.readBits(5, false);
-        containsAudio = coder.readBits(1, false) != 0;
-        coder.readBits(1, false);
-        containsVideo = coder.readBits(1, false) != 0;
+		boolean containsAudio = false;
+		boolean containsVideo = false;
 
-        int offset = coder.readWord(4, false);
-        offset = coder.readWord(4, false);
-        
-        do {
-            objects.add(decodeObject(coder));
-            
-            if (coder.context[Delta] != 0)
-                throw new IOException();
-            
-            offset = coder.readWord(4, false);    
+		isFlashVideo(bytes);
 
-        } while (!coder.eof());
+		signature = coder.readString(3, &quot;UTF8&quot;);
+		version = coder.readWord(1, false);
+		coder.readBits(5, false);
+		containsAudio = coder.readBits(1, false) != 0;
+		coder.readBits(1, false);
+		containsVideo = coder.readBits(1, false) != 0;
+
+		int offset = coder.readWord(4, false);
+		offset = coder.readWord(4, false);
+
+		do
+		{
+			objects.add(decodeObject(coder));
+
+			if (coder.context[Delta] != 0)
+				throw new IOException();
+
+			offset = coder.readWord(4, false);
+
+		} while (!coder.eof());
 	}
-    
-    /** 
-     * Encodes the array of objects and writes the data to the specified file. 
-     * If an error occurs while encoding the file then an exception is thrown.
-     *
-     * @param fileName the path to the file that the video will be encoded to.
-     *
-     * @throws FileNotFoundException - if an error occurs while reading the file.
-     * @throws IOException - if an error occurs while encoding and writing the file.
-     */
-	public void encodeToFile(String fileName) throws FileNotFoundException, IOException
+
+	/**
+	 * Encodes the array of objects and writes the data to the specified file.
+	 * If an error occurs while encoding the file then an exception is thrown.
+	 * 
+	 * @param fileName
+	 *            the path to the file that the video will be encoded to.
+	 * 
+	 * @throws FileNotFoundException -
+	 *             if an error occurs while reading the file.
+	 * @throws IOException -
+	 *             if an error occurs while encoding and writing the file.
+	 */
+	public void encodeToFile(String fileName) throws FileNotFoundException,
+					IOException
 	{
 		FileOutputStream fileContents = new FileOutputStream(fileName);
-    
-        byte[] encodedData = encode();
 
-        fileContents.write(encodedData);
-        fileContents.close();
-    }
+		byte[] encodedData = encode();
 
-    /** 
-     * Returns the encoded representation of the array of objects that this Video
-     * contains. If an error occurs while encoding the file then an exception is 
-     * thrown.
-     *
-     * @return the array of bytes representing the encoded objects.
-     * @throws IOException if an error occurs while the data is being decoded.
-     */
-    public byte[] encode() throws IOException
-    {
+		fileContents.write(encodedData);
+		fileContents.close();
+	}
+
+	/**
+	 * Returns the encoded representation of the array of objects that this
+	 * Video contains. If an error occurs while encoding the file then an
+	 * exception is thrown.
+	 * 
+	 * @return the array of bytes representing the encoded objects.
+	 * @throws IOException
+	 *             if an error occurs while the data is being decoded.
+	 */
+	public byte[] encode() throws IOException
+	{
 		FSCoder coder = new FSCoder(FSCoder.BIG_ENDIAN, 0);
-        
-        coder.context[FSVideo.Version] = version;
 
-        int fileLength = length(coder);
+		coder.context[FSVideo.Version] = version;
 
- 		coder.setData(FSCoder.BIG_ENDIAN, new byte[fileLength]);         
-        
-        boolean containsAudio = false;
-        boolean containsVideo = false;
-        
-        for (Iterator i=objects.iterator(); i.hasNext(); )
+		int fileLength = length(coder);
+
+		coder.setData(FSCoder.BIG_ENDIAN, new byte[fileLength]);
+
+		boolean containsAudio = false;
+		boolean containsVideo = false;
+
+		for (Iterator i = objects.iterator(); i.hasNext();)
 		{
-			int type = ((FSVideoObject)(i.next())).getType();
-			
+			int type = ((FSVideoObject) (i.next())).getType();
+
 			if (type == FSVideoObject.AudioData)
 				containsAudio = true;
 			else if (type == FSVideoObject.VideoData)
@@ -326,95 +375,103 @@
 		}
 
 		coder.writeString(signature, &quot;UTF8&quot;);
-        coder.writeWord(version, 1);
-        coder.writeBits(0, 5);
-        coder.writeBits(containsAudio ? 1 : 0, 1);
-        coder.writeBits(0, 1);
-        coder.writeBits(containsVideo ? 1 : 0, 1);
-        coder.writeWord(9, 4);
-        coder.writeWord(0, 4);
-        
-        for (Iterator i = objects.iterator(); i.hasNext();)
-        {
-			FSVideoObject object = (FSVideoObject)i.next();
+		coder.writeWord(version, 1);
+		coder.writeBits(0, 5);
+		coder.writeBits(containsAudio ? 1 : 0, 1);
+		coder.writeBits(0, 1);
+		coder.writeBits(containsVideo ? 1 : 0, 1);
+		coder.writeWord(9, 4);
+		coder.writeWord(0, 4);
 
-            int length = object.getLength();
-            int start = coder.getPointer();
-            int next = start + (length &lt;&lt; 3);
-            
-            object.encode(coder);
-            coder.setPointer(next);
-            
-            if (((next - coder.getPointer()) &gt;&gt; 3) != 0)
-                throw new IOException();
-            
-            coder.writeWord(length+11, 4);
-        }
+		for (Iterator i = objects.iterator(); i.hasNext();)
+		{
+			FSVideoObject object = (FSVideoObject) i.next();
+
+			int length = object.getLength();
+			int start = coder.getPointer();
+			int next = start + (length &lt;&lt; 3);
+
+			object.encode(coder);
+			coder.setPointer(next);
+
+			if (((next - coder.getPointer()) &gt;&gt; 3) != 0)
+				throw new IOException();
+
+			coder.writeWord(length + 11, 4);
+		}
 		return coder.getData();
-    }
-    
-    /** 
-     * Creates a deep copy of the entire video.
-     * 
-     * @return a copy of the object.
-     */
+	}
+
+	/**
+	 * Creates a deep copy of the entire video.
+	 * 
+	 * @return a copy of the object.
+	 */
 	public Object clone()
 	{
-        FSVideo anObject = null;
-        
-        try {
-            anObject = (FSVideo)super.clone();
+		FSVideo anObject = null;
 
+		try
+		{
+			anObject = (FSVideo) super.clone();
+
 			anObject.objects = new ArrayList();
-			
+
 			for (Iterator i = objects.iterator(); i.hasNext();)
-				anObject.objects.add(((FSVideoObject)i.next()).clone());
-        }
-        catch (CloneNotSupportedException e)
-        {
-            throw new InternalError();
-        }
-        
+				anObject.objects.add(((FSVideoObject) i.next()).clone());
+		} catch (CloneNotSupportedException e)
+		{
+			throw new InternalError();
+		}
+
 		return anObject;
 	}
 
-    /** 
-     * Returns true if anObject is equal to this one. The comparison is performed 
-     * on all the objects contained in the video. Objects are considered equal 
-     * if they would generate identical binary data when they are encoded to a 
-     * Flash Video file.
-     *
+	/**
+	 * Returns true if anObject is equal to this one. The comparison is
+	 * performed on all the objects contained in the video. Objects are
+	 * considered equal if they would generate identical binary data when they
+	 * are encoded to a Flash Video file.
+	 * 
 	 * @return true if this object would be identical to anObject when encoded.
-     */
+	 */
 	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSVideo typedObject = (FSVideo)anObject;
+		{
+			FSVideo typedObject = (FSVideo) anObject;
 
-            result = version == typedObject.version;
-            result = result &amp;&amp; objects.equals(((FSVideo)anObject).getObjects());            
-        }
+			result = version == typedObject.version;
+			result = result
+							&amp;&amp; objects
+											.equals(((FSVideo) anObject)
+															.getObjects());
+		}
 		return result;
 	}
 
-    /** 
-     * AppendDescription is used to present a string description of the object 
-     * including all nested objects up to a specified depth. 
-     *
-     * The representation of the object is appended to the StringBuffer, showing 
-     * the name of the class and values of the attributes it contains. If the 
-     * object contains any attributes that are objects then the object graph will 
-     * be traversed up to the specified depth. If objects are nested at a level 
-     * less than specified depth then the full string representation of the 
-     * object is displayed. For objects at the specified depth only the name of 
-     * the class is displayed. Any objects below this depth are not displayed.	
-     *
-     * @param buffer a StringBuffer to which the description of each object is appended.
-     * @param depth the maximum level of nesting up to which objects will be displayed. 
-     */
+	/**
+	 * AppendDescription is used to present a string description of the object
+	 * including all nested objects up to a specified depth.
+	 * 
+	 * The representation of the object is appended to the StringBuffer, showing
+	 * the name of the class and values of the attributes it contains. If the
+	 * object contains any attributes that are objects then the object graph
+	 * will be traversed up to the specified depth. If objects are nested at a
+	 * level less than specified depth then the full string representation of
+	 * the object is displayed. For objects at the specified depth only the name
+	 * of the class is displayed. Any objects below this depth are not
+	 * displayed.
+	 * 
+	 * @param buffer
+	 *            a StringBuffer to which the description of each object is
+	 *            appended.
+	 * @param depth
+	 *            the maximum level of nesting up to which objects will be
+	 *            displayed.
+	 */
 	public void appendDescription(StringBuffer buffer, int depth)
 	{
 		buffer.append(&quot;FSVideo&quot;);
@@ -427,23 +484,24 @@
 
 	private int length(FSCoder coder)
 	{
-        int length = 13;
+		int length = 13;
 
-        for (Iterator i = objects.iterator(); i.hasNext();)
+		for (Iterator i = objects.iterator(); i.hasNext();)
 		{
-            length += 4 + ((FSVideoObject)(i.next())).length(coder);
+			length += 4 + ((FSVideoObject) (i.next())).length(coder);
 		}
-        return length;
+		return length;
 	}
 
-    private void isFlashVideo(byte[] bytes) throws DataFormatException
-    {
+	private void isFlashVideo(byte[] bytes) throws DataFormatException
+	{
 		if (bytes == null || bytes.length &lt; 8)
 			throw new DataFormatException();
-            
-        boolean isFlashVideo = bytes[0] == 0x46 &amp;&amp; bytes[1] == 0x4C &amp;&amp; bytes[2] == 0x56;
-        
-        if (isFlashVideo == false)
-            throw new DataFormatException();
-    }
+
+		boolean isFlashVideo = bytes[0] == 0x46 &amp;&amp; bytes[1] == 0x4C
+						&amp;&amp; bytes[2] == 0x56;
+
+		if (isFlashVideo == false)
+			throw new DataFormatException();
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSVideoData.java
===================================================================
--- trunk/src/com/flagstone/transform/FSVideoData.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSVideoData.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -29,7 +29,7 @@
  */
 package com.flagstone.transform;
 
-/**  
+/**
  * The FSVideoData class is used to store the data for a single video frame.
  * 
  * &lt;table class=&quot;datasheet&quot;&gt;
@@ -40,21 +40,22 @@
  * 
  * &lt;tr&gt;
  * &lt;td&gt;timestamp&lt;/td&gt;
- * &lt;td&gt;The time in milliseconds at which the sound will be played. The timestamp 
- * is used exclusively for determining when sound or video will be played. Any 
- * internal timing information in the audio or video data is ignored.&lt;/td&gt;
+ * &lt;td&gt;The time in milliseconds at which the sound will be played. The
+ * timestamp is used exclusively for determining when sound or video will be
+ * played. Any internal timing information in the audio or video data is
+ * ignored.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;codec&lt;/td&gt;
- * &lt;td&gt;Identifies the format of the video data. FSVideo.H263 represents data 
+ * &lt;td&gt;Identifies the format of the video data. FSVideo.H263 represents data
  * encoded using the Sorenson modified H263 format.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
  * &lt;td&gt;frameType&lt;/td&gt;
- * &lt;td&gt;The type of frame being displayed, either FSVideo.KeyFrame, FSVideo.Frame 
- * or FSVideo.Optional.&lt;/td&gt;
+ * &lt;td&gt;The type of frame being displayed, either FSVideo.KeyFrame,
+ * FSVideo.Frame or FSVideo.Optional.&lt;/td&gt;
  * &lt;/tr&gt;
  * 
  * &lt;tr&gt;
@@ -66,38 +67,45 @@
  * 
  * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
  * 
- * The FSVideoData class represents the FLV Tag with the Video Data section from 
- * Macromedia's Flash (SWF) File Format Specification. It was added in Flash 
- * Video 1 with support for the Sorenson modified H263 format. Support for 
- * Macromedia's ScreenVideo format was added when Flash 7 was released.&lt;/p&gt;
- */  
+ * The FSVideoData class represents the FLV Tag with the Video Data section from
+ * Macromedia's Flash (SWF) File Format Specification. It was added in Flash
+ * Video 1 with support for the Sorenson modified H263 format. Support for
+ * Macromedia's ScreenVideo format was added when Flash 7 was released.
+ * &lt;/p&gt;
+ */
 public final class FSVideoData extends FSVideoObject
 {
 	private int codec = 0;
+
 	private int frameType = 0;
-    private byte[] data = null;
 
+	private byte[] data = null;
+
 	FSVideoData(FSCoder coder)
 	{
-        super(FSVideoObject.VideoData, 0);
+		super(FSVideoObject.VideoData, 0);
 		decode(coder);
 	}
 
-    /**
-     * Constructs a new FSVideoData object specifying the time which the video 
-     * should be displayed, the video data and the format used to encode it and 
-     * the type of frame that the video represents - either a key frame, regular 
-     * frame or an optional frame which can be discarded (H263 format only). 
-     *
-	 * @param timestamp the time in milliseconds at which the data should be played.
-     * @param format the format used to encode the video either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     * @param type the type of frame being displayed, either FSVideo.KeyFrame, 
-     * FSVideo.Frame or FSVideo.Optional.
-     * @param data an array of bytes containing the video encoded using the 
-     * format indicated in the codec attribute, either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
+	/**
+	 * Constructs a new FSVideoData object specifying the time which the video
+	 * should be displayed, the video data and the format used to encode it and
+	 * the type of frame that the video represents - either a key frame, regular
+	 * frame or an optional frame which can be discarded (H263 format only).
+	 * 
+	 * @param timestamp
+	 *            the time in milliseconds at which the data should be played.
+	 * @param format
+	 *            the format used to encode the video either FSVideo.H263 or
+	 *            FSVideo.ScreenVideo.
+	 * @param type
+	 *            the type of frame being displayed, either FSVideo.KeyFrame,
+	 *            FSVideo.Frame or FSVideo.Optional.
+	 * @param data
+	 *            an array of bytes containing the video encoded using the
+	 *            format indicated in the codec attribute, either FSVideo.H263
+	 *            or FSVideo.ScreenVideo.
+	 */
 	public FSVideoData(int timestamp, int format, int type, byte[] data)
 	{
 		super(FSVideoObject.VideoData, timestamp);
@@ -106,110 +114,113 @@
 		setData(data);
 	}
 
-    /**
-     * Gets the scheme used to encode the video data, either FSVideo.H263 for 
-     * data that was encoded using the modified Sorenson H263 format or 
-     * FSVideo.ScreenVideo for video that was encoded using Macromedia's 
-     * ScreenVideo format.
-     *
-     * @return the format used to encode the video either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
-    public int getCodec()
-    {
-        return codec;
-    }
+	/**
+	 * Gets the scheme used to encode the video data, either FSVideo.H263 for
+	 * data that was encoded using the modified Sorenson H263 format or
+	 * FSVideo.ScreenVideo for video that was encoded using Macromedia's
+	 * ScreenVideo format.
+	 * 
+	 * @return the format used to encode the video either FSVideo.H263 or
+	 *         FSVideo.ScreenVideo.
+	 */
+	public int getCodec()
+	{
+		return codec;
+	}
 
-    /**
-     * Sets the format used to encode the video data, either FSVideo.H263 for 
-     * data that was encoded using the modified Sorenson H263 format or
-     * FSVideo.ScreenVideo for video that was encoded using Macromedia's 
-     * ScreenVideo format.
-     *
-     * @param format the format used to encode the video either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
-    public void setCodec(int format)
+	/**
+	 * Sets the format used to encode the video data, either FSVideo.H263 for
+	 * data that was encoded using the modified Sorenson H263 format or
+	 * FSVideo.ScreenVideo for video that was encoded using Macromedia's
+	 * ScreenVideo format.
+	 * 
+	 * @param format
+	 *            the format used to encode the video either FSVideo.H263 or
+	 *            FSVideo.ScreenVideo.
+	 */
+	public void setCodec(int format)
 	{
 		codec = format;
 	}
-    
-    /**
-     * Gets the type of frame that will be displayed, either FSVideo.KeyFrame, 
-     * FSVideo.Frame or FSVideo.Optional. The latter is used only to indicate 
-     * disposable frame and is only used with the Sorenson modified H263 format.
-     *
-     * @return the type of frame, either FSVideo.KeyFrame, FSVideo.Frame or 
-     * FSVideo.Optional.
-     */
-    public int getFrameType() 
-    {
-        return frameType;
-    }
 
-    /**
-     * Sets the type of frame type indicating whether it is a key frame 
-     * (FSVideo.KeyFrame), a normal frame (FSVideo.Frame) displayed between key 
-     * frames other whether display of the frame is optional ( FSVideo.Optional). 
-     * The latter is used only with video encoded using the Sorenson modified 
-     * H263 format.
-     *
-     * @param type the type of frame being displayed, either FSVideo.KeyFrame, 
-     * FSVideo.Frame or FSVideo.Optional.
-     */
-    public void setFrameType(int type)
+	/**
+	 * Gets the type of frame that will be displayed, either FSVideo.KeyFrame,
+	 * FSVideo.Frame or FSVideo.Optional. The latter is used only to indicate
+	 * disposable frame and is only used with the Sorenson modified H263 format.
+	 * 
+	 * @return the type of frame, either FSVideo.KeyFrame, FSVideo.Frame or
+	 *         FSVideo.Optional.
+	 */
+	public int getFrameType()
 	{
+		return frameType;
+	}
+
+	/**
+	 * Sets the type of frame type indicating whether it is a key frame
+	 * (FSVideo.KeyFrame), a normal frame (FSVideo.Frame) displayed between key
+	 * frames other whether display of the frame is optional (
+	 * FSVideo.Optional). The latter is used only with video encoded using the
+	 * Sorenson modified H263 format.
+	 * 
+	 * @param type
+	 *            the type of frame being displayed, either FSVideo.KeyFrame,
+	 *            FSVideo.Frame or FSVideo.Optional.
+	 */
+	public void setFrameType(int type)
+	{
 		frameType = type;
 	}
-    
-    /**
-     * Get the encoded video data.
-     *
-     * @return an array of bytes encoded using the format indicated in the codec 
-     * attribute, either FSVideo.H263 or FSVideo.ScreenVideo.
-     */
-    public byte[] getData() 
-    {
-        return data;
-    }
 
-    /**
-     * Sets the encoded video data for the frame.
-     *
-     * @param data an array of bytes containing the video encoded using the 
-     * format indicated in the codec attribute, either FSVideo.H263 or 
-     * FSVideo.ScreenVideo.
-     */
-    public void setData(byte[] data)
+	/**
+	 * Get the encoded video data.
+	 * 
+	 * @return an array of bytes encoded using the format indicated in the codec
+	 *         attribute, either FSVideo.H263 or FSVideo.ScreenVideo.
+	 */
+	public byte[] getData()
 	{
+		return data;
+	}
+
+	/**
+	 * Sets the encoded video data for the frame.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the video encoded using the
+	 *            format indicated in the codec attribute, either FSVideo.H263
+	 *            or FSVideo.ScreenVideo.
+	 */
+	public void setData(byte[] data)
+	{
 		this.data = data;
 	}
-    
-    public Object clone()
+
+	public Object clone()
 	{
-        FSVideoData anObject = (FSVideoData)super.clone();
-        
-        anObject.data = Transform.clone(data);
-        
+		FSVideoData anObject = (FSVideoData) super.clone();
+
+		anObject.data = Transform.clone(data);
+
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSVideoData typedObject = (FSVideoData)anObject;
-            
-            result = codec == typedObject.codec;
-            result = result &amp;&amp; frameType == typedObject.frameType;
+		{
+			FSVideoData typedObject = (FSVideoData) anObject;
 
-            if (data != null)
-                result = result &amp;&amp; Transform.equals(data, typedObject.data);
-            else
-                result = result &amp;&amp; typedObject.data == null;
-        }
+			result = codec == typedObject.codec;
+			result = result &amp;&amp; frameType == typedObject.frameType;
+
+			if (data != null)
+				result = result &amp;&amp; Transform.equals(data, typedObject.data);
+			else
+				result = result &amp;&amp; typedObject.data == null;
+		}
 		return result;
 	}
 
@@ -222,7 +233,7 @@
 			buffer.append(&quot;: { &quot;);
 			Transform.append(buffer, &quot;codec&quot;, codec);
 			Transform.append(buffer, &quot;frameType&quot;, frameType);
-            Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
+			Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
 
 			buffer.append(&quot;}&quot;);
 		}
@@ -231,29 +242,29 @@
 	int length(FSCoder coder)
 	{
 		super.length(coder);
-	
+
 		length += 1 + data.length;
-	
+
 		return length;
 	}
-	
+
 	void encode(FSCoder coder)
 	{
-        super.encode(coder);
-		
+		super.encode(coder);
+
 		coder.writeBits(codec, 4);
 		coder.writeBits(frameType, 4);
-        coder.writeBytes(data);
+		coder.writeBytes(data);
 	}
-	
+
 	void decode(FSCoder coder)
 	{
 		super.decode(coder);
-        
-        data = new byte[length-1];
-        
+
+		data = new byte[length - 1];
+
 		codec = coder.readBits(4, false);
 		frameType = coder.readBits(4, false);
-        coder.readBytes(data);
+		coder.readBytes(data);
 	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSVideoFrame.java
===================================================================
--- trunk/src/com/flagstone/transform/FSVideoFrame.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSVideoFrame.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,221 +31,249 @@
 package com.flagstone.transform;
 
 /**
-FSVideoFrame contains the video data displayed in a single frame of a Flash movie.
- 
- &lt;table class=&quot;datasheet&quot;&gt;
+ * FSVideoFrame contains the video data displayed in a single frame of a Flash
+ * movie.
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;identifier&lt;/td&gt;
+ * &lt;td&gt;The identifier of the FSDefineVideo object that defines the size of the
+ * images displayed.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameNumber&lt;/td&gt;
+ * &lt;td&gt;The number of the frame that the data is for.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;data&lt;/td&gt;
+ * &lt;td&gt;The encoded video data. Encoded using either the modified Sorenson H263
+ * or Macromedia's Screen Video formats.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * Each frame of video is displayed whenever display list is updated using the
+ * FSShowFrame object - any timing information stored within the video data is
+ * ignored. Since the video is updated at the same time as the display list the
+ * frame rate of the video may be the same or less than the frame rate of the
+ * Flash movie but not higher.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSVideoFrame class represents the VideoFrame data structure in the
+ * Macromedia Flash (SWF) File Format Specification. It was added in Flash 6
+ * with support for the Sorenson modified H263 format. Support for Macromedia's
+ * Screen Video format was added in Flash 7.
+ * &lt;/p&gt;
+ */
+public class FSVideoFrame extends FSMovieObject
+{
+	private int identifier = 0;
+	private int frameNumber = 0;
+	private byte[] data = null;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSVideoFrame object, initialising it with values decoded from
+	 * an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSVideoFrame(FSCoder coder)
+	{
+		super(VideoFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs a new FSVideoFrame object which will display the specified
+	 * frame of video data in the FSDefineVideo object that matches the
+	 * identifier.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineVideo object.
+	 * @param frameNumber
+	 *            the number of the frame.
+	 * @param data
+	 *            the encoded video data. For Flash 6 this is encoded in the
+	 *            H263 format. In Flash 7 H263 and ScreenVideo is supported.
+	 */
+	public FSVideoFrame(int anIdentifier, int frameNumber, byte[] data)
+	{
+		super(VideoFrame);
+		setIdentifier(anIdentifier);
+		setFrameNumber(frameNumber);
+		setData(data);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_1&quot;&gt;identifier&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The identifier of the FSDefineVideo object that defines the size of the images displayed.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSVideoFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSVideoFrame object.
+	 */
+	public FSVideoFrame(FSVideoFrame obj)
+	{
+		super(obj);
+		identifier = obj.identifier;
+		frameNumber = obj.frameNumber;
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_1&quot;&gt;frameNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the frame that the data is for.&lt;/td&gt;
-&lt;/tr&gt;
+		data = Transform.clone(obj.data);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSVideoFrame_1&quot;&gt;data&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The encoded video data. Encoded using either the modified Sorenson H263 or Macromedia's Screen Video formats.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Get the identifier of the FSDefineVideo object where the frame will be
+	 * displayed.
+	 * 
+	 * @return the unique identifier of the FSDefineVideo object.
+	 */
+	public int getIdentifier()
+	{
+		return identifier;
+	}
 
-&lt;/table&gt;
+	/**
+	 * Sets the identifier of the FSDefineVideo object where the frame will be
+	 * displayed.
+	 * 
+	 * @param anIdentifier
+	 *            the unique identifier of the FSDefineVideo object.
+	 */
+	public void setIdentifier(int anIdentifier)
+	{
+		identifier = anIdentifier;
+	}
 
-&lt;p&gt;Each frame of video is displayed whenever display list is updated using the FSShowFrame object - any timing information stored within the video data is ignored. Since the video is updated at the same time as the display list the frame rate of the video may be the same or less than the frame rate of the Flash movie but not higher.&lt;/p&gt;
+	/**
+	 * Gets the number of the frame.
+	 * 
+	 * @return the frame number.
+	 */
+	public int getFrameNumber()
+	{
+		return frameNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+	/**
+	 * Sets the number of the frame.
+	 * 
+	 * @param number
+	 *            the frame number.
+	 */
+	public void setFrameNumber(int number)
+	{
+		frameNumber = number;
+	}
 
-&lt;p&gt;The FSVideoFrame class represents the VideoFrame data structure in the Macromedia Flash (SWF) File Format Specification. It was added in Flash 6 with support for the Sorenson modified H263 format. Support for Macromedia's Screen Video format was added in Flash 7.&lt;/p&gt;
- */  
-public class FSVideoFrame extends FSMovieObject
-{
-    private int identifier = 0;
-    private int frameNumber = 0;
-    
-    private byte[] data = null;
+	/**
+	 * Gets the encoded video data. In Flash 6 modified H263 encoded video is
+	 * supported. Flash 7 supports both modified H263 and ScreenVideo.
+	 * 
+	 * @return the encoded video data.
+	 */
+	public byte[] getData()
+	{
+		return data;
+	}
 
-    /**
-     * Construct an FSVideoFrame object, initalizing it with values decoded from
-     * an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSVideoFrame(FSCoder coder)
-    {
-        super(VideoFrame);
-        decode(coder);
-    }
-    /**
-     * Constructs a new FSVideoFrame object which will display the specified frame of video data
-     * in the FSDefineVideo object that matches the identifier. 
-     *
-     * @param anIdentifier the unique identifier of the FSDefineVideo object.
-     * @param frameNumber the number of the frame.
-     * @param data the encoded video data. For Flash 6 this is encoded in the H263 format. In Flash 7
-     * H263 and ScreenVideo is supported.
-     */
-    public FSVideoFrame(int anIdentifier, int frameNumber, byte[] data)
-    {
-        super(VideoFrame);
-        setIdentifier(anIdentifier);
-        setFrameNumber(frameNumber);
-        setData(data);
-    }
-    /**
-     * Constructs an FSVideoFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSVideoFrame object.
-     */
-    public FSVideoFrame(FSVideoFrame obj)
-    {
-        super(obj);
-        identifier = obj.identifier;
-        frameNumber = obj.frameNumber;
-        
-        data = Transform.clone(obj.data);
-    }    
+	/**
+	 * Sets the encoded video data. In Flash 6 modified H263 encoded video is
+	 * supported. Flash 7 supports both modified H263 and ScreenVideo,
+	 * 
+	 * @param data
+	 *            the encoded video data.
+	 */
+	public void setData(byte[] data)
+	{
+		this.data = data;
+	}
 
-    /**
-     * Get the identifier of the FSDefineVideo object where the frame will be displayed.
-     *
-     * @return the unique identifier of the FSDefineVideo object.
-     */
-    public int getIdentifier()
-    {
-        return identifier;
-    }
+	public Object clone()
+	{
+		FSVideoFrame anObject = (FSVideoFrame) super.clone();
 
-    /**
-     * Sets the identifier of the FSDefineVideo object where the frame will be displayed.
-     *
-     * @param anIdentifier the unique identifier of the FSDefineVideo object.
-     */
-    public void setIdentifier(int anIdentifier)
-    {
-        identifier = anIdentifier;
-    }
-    
-    /**
-     * Gets the number of the frame.
-     *
-     * @return the frame number.
-     */
-    public int getFrameNumber() 
-    {
-        return frameNumber;
-    }
+		return anObject;
+	}
 
-    /**
-     * Sets the number of the frame.
-     *
-     * @param number the frame number.
-     */
-    public void setFrameNumber(int number)
-    {
-        frameNumber = number;
-    }
-    
-    /**
-     * Gets the encoded video data. In Flash 6 modified H263 encoded video is supported. Flash 7 supports 
-     * both modified H263 and ScreenVideo.
-     *
-     * @return the encoded video data.
-     */
-    public byte[] getData() 
-    {
-        return data;
-    }
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-    /**
-     * Sets the encoded video data. In Flash 6 modified H263 encoded video is supported. Flash 7 supports 
-     * both modified H263 and ScreenVideo,
-     *
-     * @param data the encoded video data.
-     */
-    public void setData(byte[] data)
-    {
-        this.data = data;
-    }
-    
-    public Object clone()
-    {
-        FSVideoFrame anObject = (FSVideoFrame)super.clone();
-        
-        return anObject;
-    }
+		if (super.equals(anObject))
+		{
+			FSVideoFrame typedObject = (FSVideoFrame) anObject;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSVideoFrame typedObject = (FSVideoFrame)anObject;
-            
-            result = identifier == typedObject.identifier;
-            result = result &amp;&amp; frameNumber == typedObject.frameNumber;
-            
-            if (data != null)
-                result = result &amp;&amp; Transform.equals(data, typedObject.data);
-            else
-                result = result &amp;&amp; typedObject.data == null;
-        }
-        return result;
-    }
+			result = identifier == typedObject.identifier;
+			result = result &amp;&amp; frameNumber == typedObject.frameNumber;
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+			if (data != null)
+				result = result &amp;&amp; Transform.equals(data, typedObject.data);
+			else
+				result = result &amp;&amp; typedObject.data == null;
+		}
+		return result;
+	}
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;identifier&quot;, identifier);
-            Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
-            Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
-            buffer.append(&quot;}&quot;);
-        }
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-    
-        length += 4 + data.length;
-    
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        
-        coder.writeWord(identifier, 2);
-        coder.writeWord(frameNumber, 2);
-        coder.writeBytes(data);
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;identifier&quot;, identifier);
+			Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
+			Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        
-        data = new byte[length-4];
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        identifier = coder.readWord(2, false);
-        frameNumber = coder.readWord(2, false);
-        coder.readBytes(data);
-        
-        coder.endObject(name());
-    }
+		length += 4 + data.length;
+
+		return length;
+	}
+
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+
+		coder.writeWord(identifier, 2);
+		coder.writeWord(frameNumber, 2);
+		coder.writeBytes(data);
+
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+
+		data = new byte[length - 4];
+
+		identifier = coder.readWord(2, false);
+		frameNumber = coder.readWord(2, false);
+		coder.readBytes(data);
+
+		coder.endObject(name());
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSVideoMetaData.java
===================================================================
--- trunk/src/com/flagstone/transform/FSVideoMetaData.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSVideoMetaData.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -29,66 +29,67 @@
  */
 package com.flagstone.transform;
 
-/** 
- * The FSVideoMetaData class is used to store infromation on how the video
+/**
+ * The FSVideoMetaData class is used to store information on how the video
  * stream should be displayed.
  * 
- * Although meta-data can be found in all flash Video files there is no 
- * documentation published by Adobe that describes the data structure. As a 
+ * Although meta-data can be found in all flash Video files there is no
+ * documentation published by Adobe that describes the data structure. As a
  * result the information is decoded as a simple block of binary data.
- */  
+ */
 public final class FSVideoMetaData extends FSVideoObject
 {
 	private byte[] data;
-	
+
 	FSVideoMetaData(FSCoder coder)
 	{
-        super(FSVideoObject.MetaData, 0);
+		super(FSVideoObject.MetaData, 0);
 		decode(coder);
 	}
-    
-    /**
-     * Get the encoded meta data that decribes how the video stream should be 
-     * played.
-     *
-     * @return an array of bytes containing the encoded meta-data.
-     */
-    public byte[] getData() 
-    {
-        return data;
-    }
 
-    /**
-     * Sets the encoded meta data that decribes how the video stream should be 
-     * played.
-     * 
-     * @param data an array of bytes containing the encoded meta-data.
-     */
-    public void setData(byte[] data)
+	/**
+	 * Get the encoded meta data that decribes how the video stream should be
+	 * played.
+	 * 
+	 * @return an array of bytes containing the encoded meta-data.
+	 */
+	public byte[] getData()
 	{
+		return data;
+	}
+
+	/**
+	 * Sets the encoded meta data that decribes how the video stream should be
+	 * played.
+	 * 
+	 * @param data
+	 *            an array of bytes containing the encoded meta-data.
+	 */
+	public void setData(byte[] data)
+	{
 		this.data = data;
 	}
-    
-    public Object clone()
+
+	public Object clone()
 	{
-        FSVideoMetaData anObject = (FSVideoMetaData)super.clone();
-        
+		FSVideoMetaData anObject = (FSVideoMetaData) super.clone();
+
 		return anObject;
 	}
 
-    public boolean equals(Object anObject)
+	public boolean equals(Object anObject)
 	{
 		boolean result = false;
-		
+
 		if (super.equals(anObject))
-        {
-            FSVideoMetaData typedObject = (FSVideoMetaData)anObject;
-            
-            if (data != null)
-                result = result &amp;&amp; Transform.equals(data, typedObject.data);
-            else
-                result = result &amp;&amp; typedObject.data == null;
-        }
+		{
+			FSVideoMetaData typedObject = (FSVideoMetaData) anObject;
+
+			if (data != null)
+				result = result &amp;&amp; Transform.equals(data, typedObject.data);
+			else
+				result = result &amp;&amp; typedObject.data == null;
+		}
 		return result;
 	}
 
@@ -99,7 +100,7 @@
 		if (depth &gt; 0)
 		{
 			buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
+			Transform.append(buffer, &quot;data&quot;, &quot;&lt;data&gt;&quot;);
 			buffer.append(&quot;}&quot;);
 		}
 	}
@@ -107,22 +108,22 @@
 	int length(FSCoder coder)
 	{
 		super.length(coder);
-	
+
 		length += data.length;
-	
+
 		return length;
 	}
-	
+
 	void encode(FSCoder coder)
 	{
-        super.encode(coder);
+		super.encode(coder);
 		coder.writeBytes(data);
 	}
-	
+
 	void decode(FSCoder coder)
 	{
 		super.decode(coder);
-        data = new byte[length];
-        coder.readBytes(data);
+		data = new byte[length];
+		coder.readBytes(data);
 	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSVideoObject.java
===================================================================
--- trunk/src/com/flagstone/transform/FSVideoObject.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSVideoObject.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -29,131 +29,141 @@
  */
 package com.flagstone.transform;
 
-/** 
- * The FSVideoObject is the root class for objects that represent each of the 
- * tagged data structures that make up the Flash Video file format specification.
- *
- * Each of the major data structures defined in the Flash file format specification 
- * start with a header that contains the type identifying the data structure followed 
- * by the number of bytes that the body of the encoded data structure occupies in 
- * the file. The FSVideoObject manages the encoding and decoding of this information.
- *
+/**
+ * The FSVideoObject is the root class for objects that represent each of the
+ * tagged data structures that make up the Flash Video file format
+ * specification.
+ * 
+ * Each of the major data structures defined in the Flash file format
+ * specification start with a header that contains the type identifying the data
+ * structure followed by the number of bytes that the body of the encoded data
+ * structure occupies in the file. The FSVideoObject manages the encoding and
+ * decoding of this information.
+ * 
  * This class is primarily used internally in the library however the getType()
- * method is useful when manipulating decoded video files. Rather than using the 
- * runtime type checking provided in the Java environment the method can be used 
- * to identify the class, derived from FSVideoObject, that represents each data 
+ * method is useful when manipulating decoded video files. Rather than using the
+ * runtime type checking provided in the Java environment the method can be used
+ * to identify the class, derived from FSVideoObject, that represents each data
  * structure, improving performance.
  */
 
 public abstract class FSVideoObject extends Object implements Cloneable
 {
-    /** Type identifying objects containing sound */
-    public static final int AudioData = 8;
-    /** Type identifying objects containing video */
-    public static final int VideoData = 9;
-    /** Type identifying objects containing meta-data */
-    public static final int MetaData = 18;
+	/** Type identifying objects containing sound */
+	public static final int AudioData = 8;
 
-    protected int type = 0;
+	/** Type identifying objects containing video */
+	public static final int VideoData = 9;
+
+	/** Type identifying objects containing meta-data */
+	public static final int MetaData = 18;
+
+	protected int type = 0;
+
 	protected int length = 0;
+
 	protected int timestamp = 0;
 
 	/**
-	 * Constructs a movie object with the specified type. The timestamp identifies the 
-     * time, in milliseconds, relative to the start of the file that the audio or video
-     * will be played.
-     *
-     * The timestamp is used exclusively for determining when sound or video will be 
-     * played. Any internal timing information in the audio or video data is ignored. 
-     *
-	 * @param type an identifier indicating the type of movie object.
-	 * @param timestamp the time in milliseconds at which the data should be played.
+	 * Constructs a movie object with the specified type. The timestamp
+	 * identifies the time, in milliseconds, relative to the start of the file
+	 * that the audio or video will be played.
+	 * 
+	 * The timestamp is used exclusively for determining when sound or video
+	 * will be played. Any internal timing information in the audio or video
+	 * data is ignored.
+	 * 
+	 * @param type
+	 *            an identifier indicating the type of movie object.
+	 * @param timestamp
+	 *            the time in milliseconds at which the data should be played.
 	 */
-    public FSVideoObject(int type, int timestamp)
+	public FSVideoObject(int type, int timestamp)
 	{
 		this.type = type;
-        this.timestamp = timestamp;
+		this.timestamp = timestamp;
 	}
 
-    /** 
-     * Gets the code used that identifies the type of the object when it is 
-     * encoded. 
- 	 *
-     * @return the code used to denote the type of the object.
-     */
-	public int getType() 
-    {
-        return type;
-    }
-    
-    int getLength()
-    {
-    	return length;
-    }
+	/**
+	 * Gets the code used that identifies the type of the object when it is
+	 * encoded.
+	 * 
+	 * @return the code used to denote the type of the object.
+	 */
+	public int getType()
+	{
+		return type;
+	}
 
-    /**
-     * Gets the timestamp, in milliseconds, relative to the start of the file, when the 
-     * audio or video will be played.
-     *
-     * @return the time when the data will be played.
-     */
-	public int getTimestamp() 
-    {
-        return timestamp;
-    }
-    
-    /**
-     * Sets the timestamp, in milliseconds, relative to the start of the file, when the 
-     * audio or video will be played.
-     *
-     * @param time the time in milliseconds relative to the start of the file.
-     */
-	public void setTimestamp(int time) 
-    {
-        timestamp = time;
-    }
-    
+	int getLength()
+	{
+		return length;
+	}
+
+	/**
+	 * Gets the timestamp, in milliseconds, relative to the start of the file,
+	 * when the audio or video will be played.
+	 * 
+	 * @return the time when the data will be played.
+	 */
+	public int getTimestamp()
+	{
+		return timestamp;
+	}
+
+	/**
+	 * Sets the timestamp, in milliseconds, relative to the start of the file,
+	 * when the audio or video will be played.
+	 * 
+	 * @param time
+	 *            the time in milliseconds relative to the start of the file.
+	 */
+	public void setTimestamp(int time)
+	{
+		timestamp = time;
+	}
+
 	public boolean equals(Object anObject)
 	{
-        boolean result = false; 
-        
-        if (getClass().isInstance(anObject))
-        {
-            FSVideoObject typedObject = (FSVideoObject)anObject;
-            
-            result = type == typedObject.type;
-            result = result &amp;&amp; timestamp == typedObject.timestamp;
-        }
-        return result;
+		boolean result = false;
+
+		if (getClass().isInstance(anObject))
+		{
+			FSVideoObject typedObject = (FSVideoObject) anObject;
+
+			result = type == typedObject.type;
+			result = result &amp;&amp; timestamp == typedObject.timestamp;
+		}
+		return result;
 	}
 
-	/** 
-	 * Return the name of the class without the package prefix. This method is used when 
-	 * logging events to identify the object being encoded or decoded.
-	 *
+	/**
+	 * Return the name of the class without the package prefix. This method is
+	 * used when logging events to identify the object being encoded or decoded.
+	 * 
 	 * @return the name of the class, e.g. FSDefineShape.
 	 */
 	public String name()
 	{
 		String className = getClass().getName();
-		int index = className.lastIndexOf(&quot;.&quot;)+1;
+		int index = className.lastIndexOf(&quot;.&quot;) + 1;
 
 		return className.substring(index, className.length());
 	}
-   
-	/** Creates a deep copy of the entire object.
 
-		 @return a copy of the object.
-		 */
+	/**
+	 * Creates a deep copy of the entire object.
+	 * 
+	 * @return a copy of the object.
+	 */
 	public Object clone()
 	{
 		Object anObject = null;
-        
-		try 
+
+		try
 		{
 			anObject = super.clone();
-		}
-		catch (CloneNotSupportedException e)
+		} catch (CloneNotSupportedException e)
 		{
 			throw new InternalError();
 		}
@@ -168,27 +178,27 @@
 	int length(FSCoder coder)
 	{
 		coder.context[FSCoder.Type] = type;
-        
-        length = 11;
-        
+
+		length = 11;
+
 		return length;
 	}
 
 	void encode(FSCoder coder)
 	{
 		coder.context[FSCoder.Type] = type;
-		
-        coder.writeWord(type, 1);			
-        coder.writeWord(length, 3);			
-        coder.writeWord(timestamp, 3);			
-        coder.writeWord(0, 4);			
+
+		coder.writeWord(type, 1);
+		coder.writeWord(length, 3);
+		coder.writeWord(timestamp, 3);
+		coder.writeWord(0, 4);
 	}
-	
+
 	void decode(FSCoder coder)
 	{
-        type = coder.readWord(1, false);
-        length = coder.readWord(3, false);
-        timestamp = coder.readWord(3, false);
-        coder.readWord(4, false); // reserved
+		type = coder.readWord(1, false);
+		length = coder.readWord(3, false);
+		timestamp = coder.readWord(3, false);
+		coder.readWord(4, false); // reserved
 	}
 }

Modified: trunk/src/com/flagstone/transform/FSVoid.java
===================================================================
--- trunk/src/com/flagstone/transform/FSVoid.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSVoid.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,50 +31,53 @@
 package com.flagstone.transform;
 
 /**
-FSVoid is a lightweight object that is used solely to allow void values to be pushed 
-onto the Flash Player stack by The FSPush class.
- 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
-
-&lt;p&gt;The FSVoid class represents the Void data type from the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5.&lt;/p&gt;
-
- */  
+ * FSVoid is a lightweight object that is used solely to allow void values to be
+ * pushed onto the Flash Player stack by The FSPush class.
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSVoid class represents the Void data type from the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5.
+ * &lt;/p&gt;
+ * 
+ */
 public class FSVoid extends FSTransformObject
 {
-    private static final FSVoid instance = new FSVoid();
-    
-    /**
-     * Returns a canonical FSVoid object.
-     * 
-     * @return an object that can safely be shared among objects.
-     */
-    public static FSVoid getInstance()
-    {
-        return instance;
-    }
+	private static final FSVoid instance = new FSVoid();
 
-    /** 
-     * Constructs an FSVoid object. 
-     */     
-    public FSVoid()
-    {
-    }
+	/**
+	 * Returns a canonical FSVoid object.
+	 * 
+	 * @return an object that can safely be shared among objects.
+	 */
+	public static FSVoid getInstance()
+	{
+		return instance;
+	}
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-    }
+	/**
+	 * Constructs an FSVoid object.
+	 */
+	public FSVoid()
+	{
+	}
 
-    public int length(FSCoder coder) 
-    { 
-        return 0; 
-    }
-    
-    public void encode(FSCoder coder) 
-    {
-    }
-    
-    public void decode(FSCoder coder) 
-    {
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
+	}
+
+	public int length(FSCoder coder)
+	{
+		return 0;
+	}
+
+	public void encode(FSCoder coder)
+	{
+	}
+
+	public void decode(FSCoder coder)
+	{
+	}
 }
\ No newline at end of file

Modified: trunk/src/com/flagstone/transform/FSWaitForFrame.java
===================================================================
--- trunk/src/com/flagstone/transform/FSWaitForFrame.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSWaitForFrame.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,178 +31,219 @@
 package com.flagstone.transform;
 
 /**
-The FSWaitForFrame action instructs the player to wait until the specified frame 
- number has been loaded. 
- 
-&lt;p&gt;If the frame has been loaded then the actions in the following &lt;i&gt;n&lt;/i&gt; actions are executed. This action is most often used to execute a short animation loop that plays until the main part of a movie has been loaded.&lt;/p&gt;
+ * The FSWaitForFrame action instructs the player to wait until the specified
+ * frame number has been loaded.
+ * 
+ * &lt;p&gt;
+ * If the frame has been loaded then the actions in the following &lt;i&gt;n&lt;/i&gt;
+ * actions are executed. This action is most often used to execute a short
+ * animation loop that plays until the main part of a movie has been loaded.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;frameNumber&lt;/td&gt;
+ * &lt;td&gt;The number of the frame to check to see whether it has been loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actionCount&lt;/td&gt;
+ * &lt;td&gt;The number of actions, following the FSWaitForFrame action that will be
+ * executed when the frame has been loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * The following example instructs the Flash Player to wait until the eighth
+ * frame of a movie clip has been loaded then to move the time-line to the
+ * loaded frame:
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSWaitForFrame(8, 1));
+ * actions.add(new FSGotoFrame(8));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This method of waiting until a frame has been loaded is considered obsolete.
+ * Determining the number of frames loaded using the FramesLoaded property of
+ * the Flash player in combination with an FSIf action is now the preferred
+ * mechanism:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(&quot;_root&quot;));
+ * actions.add(new FSAction(FSAction.GetVariable));
+ * actions.add(new FSPush(FSPush.FramesLoaded));
+ * actions.add(new FSAction(FSAction.GetProperty));
+ * actions.add(new FSPush(8));
+ * actions.add(new FSAction(FSAction.Less));
+ * actions.add(new FSIf(-29));
+ * 
+ * actions.add(new FSGotoFrame(8));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWaitForFrame class represents the ActionWaitForFrame action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 3.
+ * &lt;/p&gt;
+ */
+public class FSWaitForFrame extends FSActionObject
+{
+	private int frameNumber = 1;
+	private int actionCount = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSWaitForFrame object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSWaitForFrame(FSCoder coder)
+	{
+		super(WaitForFrame);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame object with the specified frame number and
+	 * the number of actions that will be executed when the frame is loaded.
+	 * 
+	 * @param aFrameNumber
+	 *            the number of the frame to wait for.
+	 * @param anActionCount
+	 *            the number of actions to execute.
+	 */
+	public FSWaitForFrame(int aFrameNumber, int anActionCount)
+	{
+		super(WaitForFrame);
+		setFrameNumber(aFrameNumber);
+		setActionCount(anActionCount);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSWaitForFrame object.
+	 */
+	public FSWaitForFrame(FSWaitForFrame obj)
+	{
+		super(obj);
+		frameNumber = obj.frameNumber;
+		actionCount = obj.actionCount;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame_1&quot;&gt;frameNumber&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of the frame to check to see whether it has been loaded.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Gets the frame number.
+	 * 
+	 * @return the number of the frame to wait for.
+	 */
+	public int getFrameNumber()
+	{
+		return frameNumber;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame_2&quot;&gt;actionCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of actions, following the FSWaitForFrame action that will be executed when the frame has been loaded.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the number of actions that will be executed when the specified frame
+	 * is loaded.
+	 * 
+	 * @return the number of actions.
+	 */
+	public int getActionCount()
+	{
+		return actionCount;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-The following example instructs the Flash Player to wait until the eighth frame of a movie clip has been loaded then to move the time-line to the loaded frame:
+	/**
+	 * Sets the frame number.
+	 * 
+	 * @param aNumber
+	 *            the number of the frame to wait for.
+	 */
+	public void setFrameNumber(int aNumber)
+	{
+		frameNumber = aNumber;
+	}
 
-&lt;pre&gt;
-actions.add(new FSWaitForFrame(8, 1));
-actions.add(new FSGotoFrame(8));
-&lt;/pre&gt;
+	/**
+	 * Sets the number of actions to execute if the frame has been loaded.
+	 * Unlike other actions it is the number of actions that are specified not
+	 * the number of bytes in memory they occupy.
+	 * 
+	 * @param aNumber
+	 *            the number of actions to execute.
+	 */
+	public void setActionCount(int aNumber)
+	{
+		actionCount = aNumber;
+	}
 
-&lt;p&gt;This method of waiting until a frame has been loaded is considered obsolete. Determining the number of frames loaded using the FramesLoaded property of the Flash player in combination with an FSIf action is now the preferred mechanism:&lt;/p&gt;
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+		if (super.equals(anObject))
+		{
+			FSWaitForFrame typedObject = (FSWaitForFrame) anObject;
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(new FSAction(FSAction.GetVariable));
-actions.add(new FSPush(FSPush.FramesLoaded));
-actions.add(new FSAction(FSAction.GetProperty));
-actions.add(new FSPush(8));
-actions.add(new FSAction(FSAction.Less));
-actions.add(new FSIf(-29));
+			result = frameNumber == typedObject.frameNumber;
+			result = result &amp;&amp; actionCount == typedObject.actionCount;
+		}
+		return result;
+	}
 
-actions.add(new FSGotoFrame(8));
-&lt;/pre&gt;
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
+			Transform.append(buffer, &quot;actionCount&quot;, actionCount);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-&lt;p&gt;The FSWaitForFrame class represents the ActionWaitForFrame action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 3.&lt;/p&gt;
- */
-public class FSWaitForFrame extends FSActionObject
-{
-    private int frameNumber = 1;
-    private int actionCount = 0;
-    
-    /**
-     * Construct an FSWaitForFrame object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSWaitForFrame(FSCoder coder)
-    {
-        super(WaitForFrame);
-        decode(coder);
-    }
-    /** Constructs an FSWaitForFrame object with the specified frame number and the number of actions that will be executed when the frame is loaded.
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-        @param aFrameNumber the number of the frame to wait for.
-        @param anActionCount the number of actions to execute.
-        */
-    public FSWaitForFrame(int aFrameNumber, int anActionCount)
-    {
-        super(WaitForFrame);
-        setFrameNumber(aFrameNumber);
-        setActionCount(anActionCount);
-    }
-    /**
-     * Constructs an FSWaitForFrame object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSWaitForFrame object.
-     */
-    public FSWaitForFrame(FSWaitForFrame obj)
-    {
-        super(obj);
-        frameNumber = obj.frameNumber;
-        actionCount = obj.actionCount;
-    }    
+		length += 3;
 
-    /** Gets the frame number.
+		return length;
+	}
 
-        @return the number of the frame to wait for.
-        */
-    public int getFrameNumber() { return frameNumber; }
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(frameNumber, 2);
+		coder.writeWord(actionCount, 1);
+		coder.endObject(name());
+	}
 
-    /** Gets the number of actions that will be executed when the specified frame is loaded.
-
-        @return the number of actions.
-        */
-    public int getActionCount() { return actionCount; }
-
-    /** Sets the frame number.
-
-        @param aNumber the number of the frame to wait for.
-        */
-    public void setFrameNumber(int aNumber)
-    {
-        frameNumber = aNumber;
-    } 
-
-    /** Sets the number of actions to execute if the frame has been loaded. Unlike other actions it is the number of actions that are specified not the number of bytes in memory they occupy.
-
-        @param aNumber the number of actions to execute.
-        */
-    public void setActionCount(int aNumber)
-    {
-        actionCount = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-        {
-            FSWaitForFrame typedObject = (FSWaitForFrame)anObject;
-            
-            result = frameNumber == typedObject.frameNumber;
-            result = result &amp;&amp; actionCount == typedObject.actionCount;
-        }
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;frameNumber&quot;, frameNumber);
-            Transform.append(buffer, &quot;actionCount&quot;, actionCount);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 3;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(frameNumber, 2);
-        coder.writeWord(actionCount, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        frameNumber = coder.readWord(2, false);
-        actionCount = coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		frameNumber = coder.readWord(2, false);
+		actionCount = coder.readWord(1, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSWaitForFrame2.java
===================================================================
--- trunk/src/com/flagstone/transform/FSWaitForFrame2.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSWaitForFrame2.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -31,150 +31,185 @@
 package com.flagstone.transform;
 
 /**
-The FSWaitForFrame2 action instructs the player to wait until the specified frame 
-number or named frame has been loaded. 
- 
-&lt;p&gt;If the frame has been loaded then the following &lt;i&gt;n&lt;/i&gt; actions are executed. The FSWaitForFrame2 action extends the FSWaitForFrame action by allowing the name of a frame to be specified.&lt;/p&gt;
+ * The FSWaitForFrame2 action instructs the player to wait until the specified
+ * frame number or named frame has been loaded.
+ * 
+ * &lt;p&gt;
+ * If the frame has been loaded then the following &lt;i&gt;n&lt;/i&gt; actions are
+ * executed. The FSWaitForFrame2 action extends the FSWaitForFrame action by
+ * allowing the name of a frame to be specified.
+ * &lt;/p&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actionCount&lt;/td&gt;
+ * &lt;td&gt;The number of actions following that will be executed when the frame of
+ * interest has been loaded.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * FSWaitForFrame2 is a stack-based action. The frame number or frame name which
+ * should be loaded to trigger execution of the following actions is popped from
+ * the Flash Player's stack.
+ * &lt;/p&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
+ * The following example instructs the Flash Player to wait until the frame with
+ * the name &quot;frame&quot; in a movie clip has been loaded:
+ * 
+ * &lt;pre&gt;
+ * actions.add(new FSPush(&quot;frame&quot;));
+ * actions.add(new FSWaitForFrame2(1));
+ * actions.add(new FSGotoFrame2(&quot;frame&quot;));
+ * &lt;/pre&gt;
+ * 
+ * &lt;p&gt;
+ * This method of waiting until a frame has been loaded is considered obsolete.
+ * Determining the number of frames loaded using the FramesLoaded property of
+ * the Flash player in combination with an FSIf action is now the preferred
+ * mechanism:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * FSDoAction actions = new FSDoAction();
+ * 
+ * actions.add(new FSPush(&quot;_root&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(FSPush.FramesLoaded));
+ * actions.add(FSAction.GetProperty());
+ * actions.add(new FSPush(8));
+ * actions.add(FSAction.Less());
+ * actions.add(new FSIf(-29));
+ * 
+ * actions.add(new FSGotoFrame(8));
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWaitForFrame2 class represents the ActionWaitForFrame2 action of the
+ * Macromedia Flash (SWF) File Format Specification. It was introduced in Flash
+ * 4.
+ * &lt;/p&gt;
+ */
+public class FSWaitForFrame2 extends FSActionObject
+{
+	private int actionCount = 0;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/**
+	 * Construct an FSWaitForFrame2 object, initialising it with values decoded
+	 * from an encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSWaitForFrame2(FSCoder coder)
+	{
+		super(WaitForFrame2);
+		decode(coder);
+	}
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame2 object with the number of actions to
+	 * execute if the frame has been loaded.
+	 * 
+	 * @param aNumber
+	 *            the number of actions to execute.
+	 */
+	public FSWaitForFrame2(int aNumber)
+	{
+		super(WaitForFrame2);
+		setActionCount(aNumber);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame2_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;Identifies the data structure when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWaitForFrame2 object by copying values from an existing
+	 * object.
+	 * 
+	 * @param obj
+	 *            an FSWaitForFrame2 object.
+	 */
+	public FSWaitForFrame2(FSWaitForFrame2 obj)
+	{
+		super(obj);
+		actionCount = obj.actionCount;
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWaitForFrame2_1&quot;&gt;actionCount&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;The number of actions following that will be executed when the frame of interest has been loaded.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Gets the number of actions to execute.
+	 * 
+	 * @return the number of actions to execute.
+	 */
+	public int getActionCount()
+	{
+		return actionCount;
+	}
 
-&lt;p&gt;FSWaitForFrame2 is a stack-based action. The frame number or frame name which should be loaded to trigger execution of the following actions is popped from the Flash Player's stack.&lt;/p&gt;
+	/**
+	 * Sets the number of actions to execute.
+	 * 
+	 * @param aNumber
+	 *            the number of actions to execute.
+	 */
+	public void setActionCount(int aNumber)
+	{
+		actionCount = aNumber;
+	}
 
-&lt;h1 class=&quot;datasheet&quot;&gt;Examples&lt;/h1&gt;
-The following example instructs the Flash Player to wait until the frame with the name &quot;frame&quot; in a movie clip has been loaded:
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-&lt;pre&gt;
-actions.add(new FSPush(&quot;frame&quot;));
-actions.add(new FSWaitForFrame2(1));
-actions.add(new FSGotoFrame2(&quot;frame&quot;));
-&lt;/pre&gt;
+		if (super.equals(anObject))
+			result = actionCount == ((FSWaitForFrame2) anObject)
+							.getActionCount();
 
-&lt;p&gt;This method of waiting until a frame has been loaded is considered obsolete. Determining the number of frames loaded using the FramesLoaded property of the Flash player in combination with an FSIf action is now the preferred mechanism:&lt;/p&gt;
+		return result;
+	}
 
-&lt;pre&gt;
-FSDoAction actions = new FSDoAction();
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(FSPush.FramesLoaded));
-actions.add(FSAction.GetProperty());
-actions.add(new FSPush(8));
-actions.add(FSAction.Less());
-actions.add(new FSIf(-29));
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;actionCount&quot;, actionCount);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-actions.add(new FSGotoFrame(8));
-&lt;/pre&gt;
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		length += 1;
 
-&lt;p&gt;The FSWaitForFrame2 class represents the ActionWaitForFrame2 action of the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 4.&lt;/p&gt;
- */  
-public class FSWaitForFrame2 extends FSActionObject
-{
-    private int actionCount = 0;
-    
-    /**
-     * Construct an FSWaitForFrame2 object, initalizing it with values decoded 
-     * from an encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSWaitForFrame2(FSCoder coder)
-    {
-        super(WaitForFrame2);
-        decode(coder);
-    }
-    /** Constructs an FSWaitForFrame2 object with the number of actions to execute if the frame has been loaded.
+		return length;
+	}
 
-        @param aNumber the number of actions to execute.
-        */
-    public FSWaitForFrame2(int aNumber)
-    {
-        super(WaitForFrame2);
-        setActionCount(aNumber);
-    }
-    /**
-     * Constructs an FSWaitForFrame2 object by copying values from an existing 
-     * object.
-     *
-     * @param obj an FSWaitForFrame2 object.
-     */
-    public FSWaitForFrame2(FSWaitForFrame2 obj)
-    {
-        super(obj);
-        actionCount = obj.actionCount;
-    }    
+	public void encode(FSCoder coder)
+	{
+		super.encode(coder);
+		coder.writeWord(actionCount, 1);
+		coder.endObject(name());
+	}
 
-    /** Gets the number of actions to execute.
-
-        @return the number of actions to execute.
-        */    
-    public int getActionCount() { return actionCount; }
-
-    /** Sets the number of actions to execute.
-
-        @param aNumber the number of actions to execute.
-        */        
-    public void setActionCount(int aNumber)
-    {
-        actionCount = aNumber;
-    } 
-
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = actionCount == ((FSWaitForFrame2)anObject).getActionCount();
-
-        return result;
-    }
-
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
-        
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;actionCount&quot;, actionCount);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-
-    public int length(FSCoder coder)
-    {
-        super.length(coder);
-        
-        length += 1;
-        
-        return length;
-    }
-    
-    public void encode(FSCoder coder)
-    {
-        super.encode(coder);
-        coder.writeWord(actionCount, 1);
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        super.decode(coder);
-        actionCount = coder.readWord(1, false);
-        coder.endObject(name());
-    }
+	public void decode(FSCoder coder)
+	{
+		super.decode(coder);
+		actionCount = coder.readWord(1, false);
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/FSWith.java
===================================================================
--- trunk/src/com/flagstone/transform/FSWith.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/FSWith.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,231 +33,260 @@
 import java.util.*;
 
 /**
-FSWith is a stack-based action and supports the with statement from the ActionScript language.
- 
-&lt;pre&gt;
-with(_root.movieClip)
+ * FSWith is a stack-based action and supports the with statement from the
+ * ActionScript language.
+ * 
+ * &lt;pre&gt;
+ *  with(_root.movieClip)
+ *  {
+ *  gotoAndPlay(&quot;frame&quot;);
+ *  }
+ * &lt;/pre&gt;
+ * 
+ * &lt;table class=&quot;datasheet&quot;&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;type&lt;/td&gt;
+ * &lt;td&gt;A code identifying the action when it is encoded. Read-only.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * 
+ * &lt;tr&gt;
+ * &lt;td&gt;actions&lt;/td&gt;
+ * &lt;td&gt;An array of actions that will be executed for the specified movie clip.&lt;/td&gt;
+ * &lt;/tr&gt;
+ * &lt;/table&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWith action temporarily selects the movie clip allowing the following
+ * stream of actions to control the movie clip's time-line.
+ * &lt;/p&gt;
+ * 
+ * &lt;p&gt;
+ * The ActionScript shown above is represented (compiled) into the following
+ * actions:
+ * &lt;/p&gt;
+ * 
+ * &lt;pre&gt;
+ * clipActions.add(new FSPush(&quot;frame&quot;));
+ * clipActions.add(new FSPush(1));
+ * clipActions.add(new FSPush(&quot;gotoAndPlay&quot;));
+ * clipActions.add(FSAction.ExecuteFunction());
+ * 
+ * // Get the movie clip 
+ * 
+ * actions.add(new FSPush(&quot;_root&quot;));
+ * actions.add(FSAction.GetVariable());
+ * actions.add(new FSPush(&quot;movieClip&quot;));
+ * actions.add(FSAction.GetAttribute());
+ * 
+ * actions.add(new FSWith(clipActions));
+ * 
+ * &lt;/pre&gt;
+ * 
+ * &lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+ * 
+ * &lt;p&gt;
+ * The FSWith class represents the ActionWith action in the Macromedia Flash
+ * (SWF) File Format Specification. It was introduced in Flash 5. FSWith
+ * supersedes the FSSetTarget action.
+ * &lt;/p&gt;
+ */
+public class FSWith extends FSActionObject
 {
-    gotoAndPlay(&quot;frame&quot;);
-}
-&lt;/pre&gt;
+	private ArrayList actions = null;
 
-&lt;table class=&quot;datasheet&quot;&gt;
+	/*
+	 * Variables used when encoding.
+	 */
+	private int actionsLength = 0;
 
-&lt;tr&gt;&lt;th align=&quot;left&quot; colspan=&quot;2&quot;&gt;Attributes&lt;/th&gt;&lt;/tr&gt;
+	/**
+	 * Construct an FSWith object, initialising it with values decoded from an
+	 * encoded object.
+	 * 
+	 * @param coder
+	 *            an FSCoder containing the binary data.
+	 */
+	public FSWith(FSCoder coder)
+	{
+		super(With);
+		decode(coder);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWith_0&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;A code identifying the action when it is encoded. Read-only.&lt;/td&gt;
-&lt;/tr&gt;
+	/**
+	 * Constructs an FSWith object with an array of actions.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public FSWith(ArrayList anArray)
+	{
+		super(With);
+		setActions(anArray);
+	}
 
-&lt;tr&gt;
-&lt;td&gt;&lt;a name=&quot;FSWith_1&quot;&gt;actions&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;An array of actions that will be executed for the specified movie clip.&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
+	/**
+	 * Constructs an FSWith object by copying values from an existing object.
+	 * 
+	 * @param obj
+	 *            an FSGotoFrame object.
+	 */
+	public FSWith(FSWith obj)
+	{
+		super(obj);
 
-&lt;p&gt;The FSWith action temporarily selects the movie clip allowing the following stream of actions to control the movie clip's time-line.&lt;/p&gt;
+		actions = new ArrayList(obj.actions.size());
 
-&lt;p&gt;The ActionScript shown above is represented (compiled) into the following actions:&lt;/p&gt;
+		for (Iterator i = obj.actions.iterator(); i.hasNext();)
+			actions.add(((FSActionObject) i.next()).clone());
+	}
 
-&lt;pre&gt;
-clipActions.add(new FSPush(&quot;frame&quot;));
-clipActions.add(new FSPush(1));
-clipActions.add(new FSPush(&quot;gotoAndPlay&quot;));
-clipActions.add(FSAction.ExecuteFunction());
+	/**
+	 * Adds the action object to the array of actions.
+	 * 
+	 * @param anAction
+	 *            an object belonging to a class derived from FSActionObject.
+	 */
+	public void add(FSActionObject anAction)
+	{
+		actions.add(anAction);
+	}
 
-// Get the movie clip 
+	/**
+	 * Get the array of actions that are executed for the movie clip target.
+	 * 
+	 * @return the array of action objects.
+	 */
+	public ArrayList getActions()
+	{
+		return actions;
+	}
 
-actions.add(new FSPush(&quot;_root&quot;));
-actions.add(FSAction.GetVariable());
-actions.add(new FSPush(&quot;movieClip&quot;));
-actions.add(FSAction.GetAttribute());
+	/**
+	 * Set the array of actions that will be executed for the movie clip target.
+	 * 
+	 * @param anArray
+	 *            the array of action objects.
+	 */
+	public void setActions(ArrayList anArray)
+	{
+		actions = anArray;
+	}
 
-actions.add(new FSWith(clipActions));
+	public Object clone()
+	{
+		FSWith anObject = (FSWith) super.clone();
 
-&lt;/pre&gt;
+		anObject.actions = new ArrayList();
 
-&lt;h1 class=&quot;datasheet&quot;&gt;History&lt;/h1&gt;
+		for (Iterator i = actions.iterator(); i.hasNext();)
+			anObject.actions.add(((FSActionObject) i.next()).clone());
 
-&lt;p&gt;The FSWith class represents the ActionWith action in the Macromedia Flash (SWF) File Format Specification. It was introduced in Flash 5. FSWith supersedes the FSSetTarget action.&lt;/p&gt;
- */  
-public class FSWith extends FSActionObject
-{
-    private ArrayList actions = null;
-    
-    /*
-     * Variables used when encoding.
-     */
-    private int actionsLength = 0;
-    
-    /**
-     * Construct an FSWith object, initalizing it with values decoded from an
-     * encoded object.
-     * 
-     * @param coder an FSCoder containing the binary data.
-     */
-    public FSWith(FSCoder coder)
-    {
-        super(With);
-        decode(coder);
-    }
-    /** Constructs an FSWith object with an array of actions.
+		return anObject;
+	}
 
-        @param anArray the array of action objects.
-        */
-    public FSWith(ArrayList anArray)
-    {
-        super(With);
-        setActions(anArray);
-    }
-    /**
-     * Constructs an FSWith object by copying values from an existing object.
-     *
-     * @param obj an FSGotoFrame object.
-     */
-    public FSWith(FSWith obj)
-    {
-        super(obj);
+	public boolean equals(Object anObject)
+	{
+		boolean result = false;
 
-        actions = new ArrayList(obj.actions.size());
-        
-        for (Iterator i = obj.actions.iterator(); i.hasNext();)
-            actions.add(((FSActionObject)i.next()).clone());
-    }    
+		if (super.equals(anObject))
+			result = actions.equals(((FSWith) anObject).getActions());
 
-    /** Adds the action object to the array of actions.
+		return result;
+	}
 
-        @param anAction an object belonging to a class derived from FSActionObject.
-        */
-    public void add(FSActionObject anAction)
-    {
-        actions.add(anAction);
-    }
+	public void appendDescription(StringBuffer buffer, int depth)
+	{
+		buffer.append(name());
 
-    /** Get the array of actions that are executed for the movie clip target.
+		if (depth &gt; 0)
+		{
+			buffer.append(&quot;: { &quot;);
+			Transform.append(buffer, &quot;actions&quot;, actions, depth);
+			buffer.append(&quot;}&quot;);
+		}
+	}
 
-        @return the array of action objects.
-        */
-    public ArrayList getActions() { return actions; }
+	public int length(FSCoder coder)
+	{
+		super.length(coder);
 
-    /** Set the array of actions that will be executed for the movie clip target.
+		length += 2;
 
-        @param anArray the array of action objects.
-        */
-    public void setActions(ArrayList anArray)
-    {
-        actions = anArray;
-    }
+		actionsLength = 0;
 
-    public Object clone()
-    {
-        FSWith anObject = (FSWith)super.clone();
-        
-         anObject.actions = new ArrayList();
-            
-        for (Iterator i = actions.iterator(); i.hasNext();)
-            anObject.actions.add(((FSActionObject)i.next()).clone());
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject currentAction = (FSActionObject) i.next();
 
-        return anObject;
-    }
+			actionsLength += currentAction.length(coder);
+			actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
+		}
+		length += actionsLength;
 
-    public boolean equals(Object anObject)
-    {
-        boolean result = false;
-        
-        if (super.equals(anObject))
-            result = actions.equals(((FSWith)anObject).getActions());
+		return length;
+	}
 
-        return result;
-    }
+	public void encode(FSCoder coder)
+	{
+		coder.beginObject(name());
 
-    public void appendDescription(StringBuffer buffer, int depth)
-    {
-        buffer.append(name());
+		coder.writeWord(type, 1);
+		coder.writeWord(length - actionsLength, 2);
+		coder.writeWord(actionsLength, 2);
 
-        if (depth &gt; 0)
-        {
-            buffer.append(&quot;: { &quot;);
-            Transform.append(buffer, &quot;actions&quot;, actions, depth);
-            buffer.append(&quot;}&quot;);
-        }
-    }
-    
-    public int length(FSCoder coder)
-    { 
-        super.length(coder);
-        
-        length += 2;
+		for (Iterator i = actions.iterator(); i.hasNext();)
+		{
+			FSActionObject action = (FSActionObject) i.next();
 
-        actionsLength = 0;
-        
-        for (Iterator i = actions.iterator(); i.hasNext();)
-        {
-            FSActionObject currentAction = (FSActionObject)i.next();
-            
-            actionsLength += currentAction.length(coder);
-            actionsLength += (currentAction.getType() &gt; 128) ? 3 : 1;
-        }
-        length += actionsLength;
-        
-        return length;
-    }
-        
-    public void encode(FSCoder coder) 
-    {
-        coder.beginObject(name());
-     
-        coder.writeWord(type, 1);
-        coder.writeWord(length - actionsLength, 2);
-        coder.writeWord(actionsLength, 2);
+			int objStart = coder.getPointer();
+			int start = coder.getPointer()
+							+ ((action.getType() &gt; 128) ? 24 : 8);
+			int next = start + (action.getLength() &lt;&lt; 3);
 
-        for (Iterator i=actions.iterator(); i.hasNext();)
-        {
-            FSActionObject action = (FSActionObject)i.next();
-              
-            int objStart = coder.getPointer();
-            int start = coder.getPointer() + ((action.getType() &gt; 128) ? 24 : 8);
-            int next = start + (action.getLength() &lt;&lt; 3);
-            
-            action.encode(coder);
-            coder.setPointer(next);
-            
-            int delta = (coder.getPointer() - next) &gt;&gt; 3;
-            
-            if (delta != 0)
-            {
-                coder.context[FSCoder.CodingError] = 1;
-                coder.context[FSCoder.TypeInError] = action.getType();
-                coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
-                coder.context[FSCoder.ExpectedLength] = (next-objStart)&gt;&gt;&gt;3;
-                coder.context[FSCoder.Delta] = delta;
-            }
-        }
+			action.encode(coder);
+			coder.setPointer(next);
 
-        coder.endObject(name());
-    }
-    
-    public void decode(FSCoder coder)
-    {
-        int bytesRead = 0;
-        
-        super.decode(coder);
-        
-        actionsLength = coder.readWord(2, false);
-        
-        length += actionsLength;
-        
-        actions = new ArrayList();
+			int delta = (coder.getPointer() - next) &gt;&gt; 3;
 
-        while (bytesRead &lt; actionsLength)
-        {
-            FSActionObject anAction = FSMovie.decodeAction(coder);
-            
-            bytesRead += anAction.getLength() + ((anAction.getType() &gt;= 128) ? 3 : 1);
-            actions.add(anAction);
-        }
+			if (delta != 0)
+			{
+				coder.context[FSCoder.CodingError] = 1;
+				coder.context[FSCoder.TypeInError] = action.getType();
+				coder.context[FSCoder.StartOfError] = objStart &gt;&gt;&gt; 3;
+				coder.context[FSCoder.ExpectedLength] = (next - objStart) &gt;&gt;&gt; 3;
+				coder.context[FSCoder.Delta] = delta;
+			}
+		}
 
-        coder.endObject(name());
-    }
+		coder.endObject(name());
+	}
+
+	public void decode(FSCoder coder)
+	{
+		int bytesRead = 0;
+
+		super.decode(coder);
+
+		actionsLength = coder.readWord(2, false);
+
+		length += actionsLength;
+
+		actions = new ArrayList();
+
+		while (bytesRead &lt; actionsLength)
+		{
+			FSActionObject anAction = FSMovie.decodeAction(coder);
+
+			bytesRead += anAction.getLength()
+							+ ((anAction.getType() &gt;= 128) ? 3 : 1);
+			actions.add(anAction);
+		}
+
+		coder.endObject(name());
+	}
 }

Modified: trunk/src/com/flagstone/transform/Transform.java
===================================================================
--- trunk/src/com/flagstone/transform/Transform.java	2008-04-04 11:43:37 UTC (rev 438)
+++ trunk/src/com/flagstone/transform/Transform.java	2008-04-04 13:47:40 UTC (rev 439)
@@ -33,258 +33,266 @@
 import java.util.*;
 
 /**
- * The %Transform class defines constants and methods used throughout the %Transform package. 
+ * The %Transform class defines constants and methods used throughout the
+ * %Transform package.
  */
 public class Transform
 {
-    /** 
-     * @deprecated No longer required for debugging.
-     * 
-     * DEBUG is used to turn on additional logging and error checking.
-     */
-    public static final boolean DEBUG = false;
-    /** 
-     * VERSION is used to identify the version of Flash that the edition supports.
-     */
-    public static final int VERSION = 7;
+	/**
+	 * @deprecated No longer required for debugging.
+	 * 
+	 * DEBUG is used to turn on additional logging and error checking.
+	 */
+	public static final boolean DEBUG = false;
 
-    /** 
-     * MAJOR is used to identify the current version of the framework. This
-     * is incremented for each new version of Flash supported.
-     */
-    public static final int MAJOR = 2;
-    /** 
-     * MINOR is used to identify the current minor version of the framework. This
-     * is incremented when new functionality is added or API changes are made.
-     */
-    public static final int MINOR = 3;
-    /** 
-     * The RELEASE number is used to differentiate between different releases. 
-     * This number is incremented when an enhancement or bug fix has been made 
-     * and the API is unchanged.
-     */
-    public static final int RELEASE = 0;
-    /** 
-     * VALUE_NOT_SET is used to signify that a field has not yet assigned a value. Some Flash 
-     * tags contain optional fields to reduce the size of the binary data when a tag is encoded. 
-     * These fields are only encoded if they have been assigned a valid value. The range of 
-     * valid values will depend on the number of bits used to encode the field and whether it 
-     * is a signed or unsigned value. VALUE_NOT_SET was chosen to be the largest negative 
-     * integer - since the largest optional field is 16-bits in length and thus no confusion 
-     * will result.
-     */
-    public static final int VALUE_NOT_SET = Integer.MIN_VALUE;
-    
-    /** 
-     * The main method reports basic information about the package. The method prints out the 
-     * version of Flash supported and the version number along with copyright and licensing 
-     * information.
-     */    
-    public static void main(String args[]) 
-    {
-        String version = MAJOR + &quot;.&quot; + MINOR + &quot;.&quot; + RELEASE;
-        
-        System.out.println(&quot;/**&quot;);
+	/**
+	 * VERSION is used to identify the version of Flash that the edition
+	 * supports.
+	 */
+	public static final int VERSION = 7;
 
-        System.out.println(
-            &quot; * Transform For Flash &quot; + VERSION + &quot;, Version &quot; + version);
-        
-        System.out.println(&quot; * &quot;);
-        System.out.println(&quot; * Copyright (c) Flagstone Software Limited, 2001-2008.&quot;);
-        System.out.println(&quot; * All Rights Reserved.&quot;);
-        System.out.println(&quot; * &quot;);
-        System.out.println(&quot; * Use of this software is subject to the terms in the license&quot;);
-        System.out.println(&quot; * that accompanied the software.&quot;);
-        System.out.println(&quot; * &quot;);
-        System.out.println(&quot; */&quot;);
-    }
+	/**
+	 * MAJOR is used to identify the current version of the framework. This is
+	 * incremented for each new version of Flash supported.
+	 */
+	public static final int MAJOR = 2;
 
-    static void append(StringBuffer buffer, String name, int value)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (value == Transform.VALUE_NOT_SET)
-            buffer.append(&quot;&lt;Value Not Set&gt;&quot;);
-        else
-            buffer.append(value);
-            
-        buffer.append(&quot;; &quot;);
-    }
+	/**
+	 * MINOR is used to identify the current minor version of the framework.
+	 * This is incremented when new functionality is added or API changes are
+	 * made.
+	 */
+	public static final int MINOR = 3;
 
-    static void append(StringBuffer buffer, String name, boolean value)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        buffer.append(value);
-        buffer.append(&quot;; &quot;);
-    }
+	/**
+	 * The RELEASE number is used to differentiate between different releases.
+	 * This number is incremented when an enhancement or bug fix has been made
+	 * and the API is unchanged.
+	 */
+	public static final int RELEASE = 0;
 
-    static void append(StringBuffer buffer, String name, float value)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        buffer.append(value);
-        buffer.append(&quot;; &quot;);
-    }
+	/**
+	 * VALUE_NOT_SET is used to signify that a field has not yet assigned a
+	 * value. Some Flash tags contain optional fields to reduce the size of the
+	 * binary data when a tag is encoded. These fields are only encoded if they
+	 * have been assigned a valid value. The range of valid values will depend
+	 * on the number of bits used to encode the field and whether it is a signed
+	 * or unsigned value. VALUE_NOT_SET was chosen to be the largest negative
+	 * integer - since the largest optional field is 16-bits in length and thus
+	 * no confusion will result.
+	 */
+	public static final int VALUE_NOT_SET = Integer.MIN_VALUE;
 
-    static void append(StringBuffer buffer, String name, String value)
-    {
-        if (value == null)
-            value = &quot;null; &quot;;
-        else if (value.equals(&quot;&lt;data&gt;&quot;))
-            value = value + &quot;; &quot;;
-        else
-            value = '&quot;' + value + &quot;\&quot;; &quot;;
-        
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        buffer.append(value);
-    }
+	/**
+	 * The main method reports basic information about the package. The method
+	 * prints out the version of Flash supported and the version number along
+	 * with copyright and licensing information.
+	 */
+	public static void main(String args[])
+	{
+		String version = MAJOR + &quot;.&quot; + MINOR + &quot;.&quot; + RELEASE;
 
-    static void append(StringBuffer buffer, String name, FSTransformObject anObject, int indentLevel)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (anObject != null)
-        {
-            if (indentLevel &gt; 0)
-                anObject.appendDescription(buffer, indentLevel-1);
-            else
-                buffer.append(anObject.name());
-        }
-        else
-        {
-            buffer.append(&quot;null&quot;);
-        }
-        buffer.append(&quot;; &quot;);
-    }
+		System.out.println(&quot;/**&quot;);
 
-    static void append(StringBuffer buffer, String name, ArrayList anArray, int indentLevel)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (anArray != null)
-        {
-            buffer.append(&quot;Array(&quot;);
-            buffer.append(anArray.size());
-            buffer.append(&quot;) [ &quot;);
+		System.out.println(&quot; * Transform For Flash &quot; + VERSION + &quot;, Version &quot;
+						+ version);
 
-            for (Iterator j = anArray.iterator(); j.hasNext();)
-            {
-                Object currentElement = j.next();
-                        
-                if (currentElement instanceof FSTransformObject)
-                {
-                    FSTransformObject object = (FSTransformObject)currentElement;
-                    
-                    if (indentLevel &gt; 0)
-                        object.appendDescription(buffer, indentLevel-1);
-                    else
-                        buffer.append(object.name());
-                }
-                else if (currentElement instanceof String)
-                {
-                    buffer.append('&quot;');
-                    buffer.append(currentElement.toString());
-                    buffer.append('&quot;');
-                }
-                else
-                    buffer.append(currentElement.toString());
-                
-                if (j.hasNext())
-                    buffer.append(',');
-                
-                buffer.append(' ');
-            }
-            buffer.append(&quot;]; &quot;);
-        }
-        else
-        {
-            buffer.append(&quot;null; &quot;);
-        }
-    }
+		System.out.println(&quot; * &quot;);
+		System.out
+						.println(&quot; * Copyright (c) Flagstone Software Limited, 2001-2008.&quot;);
+		System.out.println(&quot; * All Rights Reserved.&quot;);
+		System.out.println(&quot; * &quot;);
+		System.out
+						.println(&quot; * Use of this software is subject to the terms in the license&quot;);
+		System.out.println(&quot; * that accompanied the software.&quot;);
+		System.out.println(&quot; * &quot;);
+		System.out.println(&quot; */&quot;);
+	}
 
-    static void append(StringBuffer buffer, String name, Hashtable table, int indentLevel)
-    {
-        buffer.append(name);
-        buffer.append(&quot; = &quot;);
-        
-        if (table != null)
-        {
-            buffer.append(&quot;Table (&quot;);
-            buffer.append(table.size());
-            buffer.append(&quot;)&quot;);
+	static void append(StringBuffer buffer, String name, int value)
+	{
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
 
-            if (indentLevel &gt; 0)
-            {
-                buffer.append(&quot; {&quot;);
+		if (value == Transform.VALUE_NOT_SET)
+			buffer.append(&quot;&lt;Value Not Set&gt;&quot;);
+		else
+			buffer.append(value);
 
-                for (Enumeration e = table.keys(); e.hasMoreElements(); )
-                {
-                    Object key = e.nextElement();
-                    Object value = table.get(key);
-                                
-                    buffer.append(key);
-                    buffer.append(&quot; = &quot;);
-                        
-                    if (value instanceof FSTransformObject)
-                        ((FSTransformObject)value).appendDescription(buffer, indentLevel-1);
-                    else if (value instanceof String)
-                    {
-                        buffer.append('&quot;');
-                        buffer.append(value.toString());
-                        buffer.append('&quot;');
-                    }
-                    else
-                        buffer.append(value.toString());
-                        
-                    if (e.hasMoreElements())
-                        buffer.append(',');
-                
-                    buffer.append(' ');
-                }
-            }
-            buffer.append(&quot;} &quot;);
-        }
-        else
-        {
-            buffer.append(&quot;null&quot;);
-        }
-    }
+		buffer.append(&quot;; &quot;);
+	}
 
-    static boolean equals(byte[] b1, byte[] b2)
-    {
-        boolean result = false;
-        
-        if (b1 == null &amp;&amp; b2 ==null)
-            return true;
-            
-        if (b1 != null &amp;&amp; b2 != null)
-        {
-            result = b1.length == b2.length;
-            
-            if (result)
-                for (int i=0; i&lt;b1.length; i++)
-                    if (b1[i] != b2[i])
-                        result = false;
-        }
-        return result;
-    }
+	static void append(StringBuffer buffer, String name, boolean value)
+	{
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
+		buffer.append(value);
+		buffer.append(&quot;; &quot;);
+	}
 
-    static byte[] clone(byte[] data)
-    {
-        byte[] newData = null;
-        
-        if (data != null)
-        {
-            newData = new byte[data.length];
-        
-            for (int i=0; i&lt;data.length; i++)
-                newData[i] = data[i];
-        }
-        return newData;
-    }
+	static void append(StringBuffer buffer, String name, float value)
+	{
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
+		buffer.append(value);
+		buffer.append(&quot;; &quot;);
+	}
+
+	static void append(StringBuffer buffer, String name, String value)
+	{
+		if (value == null)
+			value = &quot;null; &quot;;
+		else if (value.equals(&quot;&lt;data&gt;&quot;))
+			value = value + &quot;; &quot;;
+		else
+			value = '&quot;' + value + &quot;\&quot;; &quot;;
+
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
+		buffer.append(value);
+	}
+
+	static void append(StringBuffer buffer, String name,
+						FSTransformObject anObject, int indentLevel)
+	{
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
+
+		if (anObject != null)
+		{
+			if (indentLevel &gt; 0)
+				anObject.appendDescription(buffer, indentLevel - 1);
+			else
+				buffer.append(anObject.name());
+		} else
+		{
+			buffer.append(&quot;null&quot;);
+		}
+		buffer.append(&quot;; &quot;);
+	}
+
+	static void append(StringBuffer buffer, String name, ArrayList anArray,
+						int indentLevel)
+	{
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
+
+		if (anArray != null)
+		{
+			buffer.append(&quot;Array(&quot;);
+			buffer.append(anArray.size());
+			buffer.append(&quot;) [ &quot;);
+
+			for (Iterator j = anArray.iterator(); j.hasNext();)
+			{
+				Object currentElement = j.next();
+
+				if (currentElement instanceof FSTransformObject)
+				{
+					FSTransformObject object = (FSTransformObject) currentElement;
+
+					if (indentLevel &gt; 0)
+						object.appendDescription(buffer, indentLevel - 1);
+					else
+						buffer.append(object.name());
+				} else if (currentElement instanceof String)
+				{
+					buffer.append('&quot;');
+					buffer.append(currentElement.toString());
+					buffer.append('&quot;');
+				} else
+					buffer.append(currentElement.toString());
+
+				if (j.hasNext())
+					buffer.append(',');
+
+				buffer.append(' ');
+			}
+			buffer.append(&quot;]; &quot;);
+		} else
+		{
+			buffer.append(&quot;null; &quot;);
+		}
+	}
+
+	static void append(StringBuffer buffer, String name, Hashtable table,
+						int indentLevel)
+	{
+		buffer.append(name);
+		buffer.append(&quot; = &quot;);
+
+		if (table != null)
+		{
+			buffer.append(&quot;Table (&quot;);
+			buffer.append(table.size());
+			buffer.append(&quot;)&quot;);
+
+			if (indentLevel &gt; 0)
+			{
+				buffer.append(&quot; {&quot;);
+
+				for (Enumeration e = table.keys(); e.hasMoreElements();)
+				{
+					Object key = e.nextElement();
+					Object value = table.get(key);
+
+					buffer.append(key);
+					buffer.append(&quot; = &quot;);
+
+					if (value instanceof FSTransformObject)
+						((FSTransformObject) value).appendDescription(buffer,
+										indentLevel - 1);
+					else if (value instanceof String)
+					{
+						buffer.append('&quot;');
+						buffer.append(value.toString());
+						buffer.append('&quot;');
+					} else
+						buffer.append(value.toString());
+
+					if (e.hasMoreElements())
+						buffer.append(',');
+
+					buffer.append(' ');
+				}
+			}
+			buffer.append(&quot;} &quot;);
+		} else
+		{
+			buffer.append(&quot;null&quot;);
+		}
+	}
+
+	static boolean equals(byte[] b1, byte[] b2)
+	{
+		boolean result = false;
+
+		if (b1 == null &amp;&amp; b2 == null)
+			return true;
+
+		if (b1 != null &amp;&amp; b2 != null)
+		{
+			result = b1.length == b2.length;
+
+			if (result)
+				for (int i = 0; i &lt; b1.length; i++)
+					if (b1[i] != b2[i])
+						result = false;
+		}
+		return result;
+	}
+
+	static byte[] clone(byte[] data)
+	{
+		byte[] newData = null;
+
+		if (data != null)
+		{
+			newData = new byte[data.length];
+
+			for (int i = 0; i &lt; data.length; i++)
+				newData[i] = data[i];
+		}
+		return newData;
+	}
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000374.html">[Transform-svn] r438 - dev/dev-3-0/src/com/flagstone/transform
</A></li>
	<LI>Next message: <A HREF="000375.html">[Transform-svn] r440 - dev/dev-3-0/src/com/flagstone/transform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#379">[ date ]</a>
              <a href="thread.html#379">[ thread ]</a>
              <a href="subject.html#379">[ subject ]</a>
              <a href="author.html#379">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/transform-svn">More information about the Transform-svn
mailing list</a><br>
</body></html>
